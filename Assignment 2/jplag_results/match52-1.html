<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>daihoangquoc_</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.base/com/sun/javafx/collections/ElementObserver.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.collections;

import javafx.collections.ObservableListBase;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.RandomAccess;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.util.Callback;

final class ElementObserver&lt;E&gt; {

    private static class ElementsMapElement {
        InvalidationListener listener;
        int counter;

        public ElementsMapElement(InvalidationListener listener) {
            this.listener = listener;
            this.counter = 1;
        }

        public void increment() {
            counter++;
        }

        public int decrement() {
            return --counter;
        }

        private InvalidationListener getListener() {
            return listener;
        }
    }

<A NAME="1"></A>    private Callback&lt;E, Observable[]&gt; extractor;
    private final Callback&lt;E, InvalidationListener&gt; listenerGenerator;
    private final ObservableListBase&lt;E&gt; list;
    <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#1',2,'match52-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private IdentityHashMap&lt;E, ElementObserver.ElementsMapElement&gt; elementsMap =
            new IdentityHashMap&lt;E, ElementObserver.ElementsMapElement&gt;();

    ElementObserver(Callback&lt;E, Observable[]&gt; extractor, Callback&lt;E, InvalidationListener&gt; listenerGenerator, ObservableListBase&lt;E&gt; list) {
        this.extractor = extractor;
        this.listenerGenerator = listenerGenerator;
        this.list = list;
    }


    void attachListener(final E e) {</B></FONT>
        if (elementsMap != null &amp;&amp; e != null) {
            if (elementsMap.containsKey(e)) {
                elementsMap.get(e).increment();
            } else {
                InvalidationListener listener = listenerGenerator.call(e);
                for (Observable o : extractor.call(e)) {
                    o.addListener(listener);
                }
                elementsMap.put(e, new ElementObserver.ElementsMapElement(listener));
            }
        }
    }

    void detachListener(E e) {
        if (elementsMap != null &amp;&amp; e != null) {
            ElementObserver.ElementsMapElement el = elementsMap.get(e);
            for (Observable o : extractor.call(e)) {
                o.removeListener(el.getListener());
            }
            if (el.decrement() == 0) {
                elementsMap.remove(e);
            }
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/DatePickerContent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import java.time.DateTimeException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DecimalStyle;
import java.time.chrono.Chronology;
import java.time.chrono.ChronoLocalDate;
import java.time.temporal.ChronoUnit;
import java.time.temporal.ValueRange;
import java.time.temporal.WeekFields;
import java.time.YearMonth;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import static java.time.temporal.ChronoField.*;
import static java.time.temporal.ChronoUnit.*;

import com.sun.javafx.scene.control.skin.*;
import javafx.application.Platform;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.WeakChangeListener;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.DatePicker;
import javafx.scene.control.DateCell;
import javafx.scene.control.Label;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.layout.StackPane;

import com.sun.javafx.scene.control.skin.resources.ControlResources;
import com.sun.javafx.scene.traversal.Direction;

import static com.sun.javafx.PlatformUtil.*;
import com.sun.javafx.scene.NodeHelper;

/**
 * The full content for the DatePicker popup. This class could
 * probably be used more or less as-is with an embeddable type of date
 * picker that doesn't use a popup.
 */
public class DatePickerContent extends VBox {
    protected DatePicker datePicker;
    private Button backMonthButton;
    private Button forwardMonthButton;
    private Button backYearButton;
    private Button forwardYearButton;
    private Label monthLabel;
    private Label yearLabel;
    protected GridPane gridPane;

    private int daysPerWeek;
    private List&lt;DateCell&gt; dayNameCells = new ArrayList&lt;DateCell&gt;();
    private List&lt;DateCell&gt; weekNumberCells = new ArrayList&lt;DateCell&gt;();
    protected List&lt;DateCell&gt; dayCells = new ArrayList&lt;DateCell&gt;();
    private LocalDate[] dayCellDates;
    private DateCell lastFocusedDayCell = null;

    final DateTimeFormatter monthFormatter =
        DateTimeFormatter.ofPattern(&quot;MMMM&quot;);

    final DateTimeFormatter monthFormatterSO =
            DateTimeFormatter.ofPattern(&quot;LLLL&quot;); // Standalone month name

    final DateTimeFormatter yearFormatter =
        DateTimeFormatter.ofPattern(&quot;y&quot;);

    final DateTimeFormatter yearWithEraFormatter =
        DateTimeFormatter.ofPattern(&quot;GGGGy&quot;); // For Japanese. What to use for others??

    final DateTimeFormatter weekNumberFormatter =
        DateTimeFormatter.ofPattern(&quot;w&quot;);

    final DateTimeFormatter weekDayNameFormatter =
            DateTimeFormatter.ofPattern(&quot;ccc&quot;); // Standalone day name

    final DateTimeFormatter dayCellFormatter =
        DateTimeFormatter.ofPattern(&quot;d&quot;);

    static String getString(String key) {
        return ControlResources.getString(&quot;DatePicker.&quot;+key);
    }

    public DatePickerContent(final DatePicker datePicker) {
        this.datePicker = datePicker;

        getStyleClass().add(&quot;date-picker-popup&quot;);

        daysPerWeek = getDaysPerWeek();

        {
            LocalDate date = datePicker.getValue();
            displayedYearMonth.set((date != null) ? YearMonth.from(date) : YearMonth.now());
        }

        displayedYearMonth.addListener((observable, oldValue, newValue) -&gt; {
            updateValues();
        });


        getChildren().add(createMonthYearPane());

        gridPane = new GridPane() {
            @Override protected double computePrefWidth(double height) {
                final double width = super.computePrefWidth(height);

                // RT-30903: Make sure width snaps to pixel when divided by
                // number of columns. GridPane doesn't do this with percentage
                // width constraints. See GridPane.adjustColumnWidths().
                final int nCols = daysPerWeek + (datePicker.isShowWeekNumbers() ? 1 : 0);
                final double snaphgap = snapSpaceX(getHgap());
                final double left = snapSpaceX(getInsets().getLeft());
                final double right = snapSpaceX(getInsets().getRight());
                final double hgaps = snaphgap * (nCols - 1);
                final double contentWidth = width - left - right - hgaps;
                return ((snapSizeX(contentWidth / nCols)) * nCols) + left + right + hgaps;
            }

            @Override protected void layoutChildren() {
                // Prevent AssertionError in GridPane
                if (getWidth() &gt; 0 &amp;&amp; getHeight() &gt; 0) {
                    super.layoutChildren();
                }
            }
        };
        gridPane.setFocusTraversable(true);
        gridPane.getStyleClass().add(&quot;calendar-grid&quot;);
        gridPane.setVgap(-1);
        gridPane.setHgap(-1);

        // Add a focus owner listener to Scene when it becomes available.
        final WeakChangeListener&lt;Node&gt; weakFocusOwnerListener =
            new WeakChangeListener&lt;Node&gt;((ov2, oldFocusOwner, newFocusOwner) -&gt; {
                if (newFocusOwner == gridPane) {
                    if (oldFocusOwner instanceof DateCell) {
                        // Backwards traversal, skip gridPane.
                        NodeHelper.traverse(gridPane, Direction.PREVIOUS);
                    } else {
                        // Forwards traversal, pass focus to day cell.
                        if (lastFocusedDayCell != null) {
                            Platform.runLater(() -&gt; {
                                lastFocusedDayCell.requestFocus();
                            });
                        } else {
                            clearFocus();
                        }
                    }
                }
            });
        gridPane.sceneProperty().addListener(new WeakChangeListener&lt;Scene&gt;((ov, oldScene, newScene) -&gt; {
            if (oldScene != null) {
                oldScene.focusOwnerProperty().removeListener(weakFocusOwnerListener);
            }
            if (newScene != null) {
                Platform.runLater(() -&gt; {
                    newScene.focusOwnerProperty().addListener(weakFocusOwnerListener);
                });
            }
        }));
        if (gridPane.getScene() != null) {
            gridPane.getScene().focusOwnerProperty().addListener(weakFocusOwnerListener);
        }

        // get the weekday labels starting with the weekday that is the
        // first-day-of-the-week according to the locale in the
        // displayed LocalDate
        for (int i = 0; i &lt; daysPerWeek; i++) {
            DateCell cell = new DateCell();
            cell.getStyleClass().add(&quot;day-name-cell&quot;);
            dayNameCells.add(cell);
        }

        // Week number column
        for (int i = 0; i &lt; 6; i++) {
            DateCell cell = new DateCell();
            cell.getStyleClass().add(&quot;week-number-cell&quot;);
            weekNumberCells.add(cell);
        }

        createDayCells();
        updateGrid();
        getChildren().add(gridPane);

        refresh();

        // RT-30511: This prevents key events from reaching the popup's owner.
        addEventHandler(KeyEvent.ANY, e -&gt; {
            Node node = getScene().getFocusOwner();
            if (node instanceof DateCell) {
                lastFocusedDayCell = (DateCell)node;
            }

            if (e.getEventType() == KeyEvent.KEY_PRESSED) {
                switch (e.getCode()) {
                  case HOME:
                      goToDate(LocalDate.now(), true);
                      e.consume();
                      break;


                  case PAGE_UP:
                      if ((isMac() &amp;&amp; e.isMetaDown()) || (!isMac() &amp;&amp; e.isControlDown())) {
                          if (!backYearButton.isDisabled()) {
                              forward(-1, YEARS, true);
                          }
                      } else {
                          if (!backMonthButton.isDisabled()) {
                              forward(-1, MONTHS, true);
                          }
                      }
                      e.consume();
                      break;

                  case PAGE_DOWN:
                      if ((isMac() &amp;&amp; e.isMetaDown()) || (!isMac() &amp;&amp; e.isControlDown())) {
                          if (!forwardYearButton.isDisabled()) {
                              forward(1, YEARS, true);
                          }
                      } else {
                          if (!forwardMonthButton.isDisabled()) {
                              forward(1, MONTHS, true);
                          }
                      }
                      e.consume();
                      break;
                }

                node = getScene().getFocusOwner();
                if (node instanceof DateCell) {
                    lastFocusedDayCell = (DateCell)node;
                }
            }

            // Consume all key events except those that control
            // showing the popup and traversal.
            switch (e.getCode()) {
              case F4:
              case F10:
              case UP:
              case DOWN:
              case LEFT:
              case RIGHT:
              case TAB:
                    break;

              case ESCAPE:
                datePicker.hide();
                e.consume();
                break;

              default:
                e.consume();
            }
        });
    }

    private ObjectProperty&lt;YearMonth&gt; displayedYearMonth =
        new SimpleObjectProperty&lt;YearMonth&gt;(this, &quot;displayedYearMonth&quot;);

    public ObjectProperty&lt;YearMonth&gt; displayedYearMonthProperty() {
        return displayedYearMonth;
    }


    protected BorderPane createMonthYearPane() {
        BorderPane monthYearPane = new BorderPane();
        monthYearPane.getStyleClass().add(&quot;month-year-pane&quot;);

        // Month spinner

        HBox monthSpinner = new HBox();
        monthSpinner.getStyleClass().add(&quot;spinner&quot;);

        backMonthButton = new Button();
<A NAME="2"></A>        backMonthButton.getStyleClass().add(&quot;left-button&quot;);

        forwardMonthButton = new Button();
        <FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#2',2,'match52-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>forwardMonthButton.getStyleClass().add(&quot;right-button&quot;);

        StackPane leftMonthArrow = new StackPane();
        leftMonthArrow.getStyleClass().add(&quot;left-arrow&quot;);
        leftMonthArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        backMonthButton.setGraphic(leftMonthArrow);

        StackPane rightMonthArrow = new StackPane();
        rightMonthArrow.getStyleClass().add(&quot;right-arrow&quot;);
        rightMonthArrow.setMaxSize</B></FONT>(USE_PREF_SIZE, USE_PREF_SIZE);
        forwardMonthButton.setGraphic(rightMonthArrow);


        backMonthButton.setOnAction(t -&gt; {
            forward(-1, MONTHS, false);
        });

        monthLabel = new Label();
        monthLabel.getStyleClass().add(&quot;spinner-label&quot;);
        monthLabel.fontProperty().addListener((o, ov, nv) -&gt; {
            updateMonthLabelWidth();
        });

        forwardMonthButton.setOnAction(t -&gt; {
            forward(1, MONTHS, false);
        });

        monthSpinner.getChildren().addAll(backMonthButton, monthLabel, forwardMonthButton);
        monthYearPane.setLeft(monthSpinner);

        // Year spinner

        HBox yearSpinner = new HBox();
        yearSpinner.getStyleClass().add(&quot;spinner&quot;);

        backYearButton = new Button();
        backYearButton.getStyleClass().add(&quot;left-button&quot;);

        forwardYearButton = new Button();
        forwardYearButton.getStyleClass().add(&quot;right-button&quot;);

        StackPane leftYearArrow = new StackPane();
        leftYearArrow.getStyleClass().add(&quot;left-arrow&quot;);
        leftYearArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        backYearButton.setGraphic(leftYearArrow);

        StackPane rightYearArrow = new StackPane();
        rightYearArrow.getStyleClass().add(&quot;right-arrow&quot;);
        rightYearArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        forwardYearButton.setGraphic(rightYearArrow);


        backYearButton.setOnAction(t -&gt; {
            forward(-1, YEARS, false);
        });

        yearLabel = new Label();
        yearLabel.getStyleClass().add(&quot;spinner-label&quot;);

        forwardYearButton.setOnAction(t -&gt; {
            forward(1, YEARS, false);
        });

        yearSpinner.getChildren().addAll(backYearButton, yearLabel, forwardYearButton);
        yearSpinner.setFillHeight(false);
        monthYearPane.setRight(yearSpinner);

        return monthYearPane;
    }

    private void refresh() {
        updateMonthLabelWidth();
        updateDayNameCells();
        updateValues();
    }

    public void updateValues() {
        // Note: Preserve this order, as DatePickerHijrahContent needs
        // updateDayCells before updateMonthYearPane().
        updateWeeknumberDateCells();
        updateDayCells();
        updateMonthYearPane();
    }

    public void updateGrid() {
        gridPane.getColumnConstraints().clear();
        gridPane.getChildren().clear();

        int nCols = daysPerWeek + (datePicker.isShowWeekNumbers() ? 1 : 0);

        ColumnConstraints columnConstraints = new ColumnConstraints();
        columnConstraints.setPercentWidth(100); // Treated as weight
        for (int i = 0; i &lt; nCols; i++) {
            gridPane.getColumnConstraints().add(columnConstraints);
        }

        for (int i = 0; i &lt; daysPerWeek; i++) {
            gridPane.add(dayNameCells.get(i), i + nCols - daysPerWeek, 1);  // col, row
        }

        // Week number column
        if (datePicker.isShowWeekNumbers()) {
            for (int i = 0; i &lt; 6; i++) {
                gridPane.add(weekNumberCells.get(i), 0, i + 2);  // col, row
            }
        }

        // setup: 6 rows of daysPerWeek (which is the maximum number of cells required in the worst case layout)
        for (int row = 0; row &lt; 6; row++) {
            for (int col = 0; col &lt; daysPerWeek; col++) {
                gridPane.add(dayCells.get(row*daysPerWeek+col), col + nCols - daysPerWeek, row + 2);
            }
        }
    }

    public void updateDayNameCells() {
        // first day of week, 1 = monday, 7 = sunday
        int firstDayOfWeek = WeekFields.of(getLocale()).getFirstDayOfWeek().getValue();

        // july 13th 2009 is a Monday, so a firstDayOfWeek=1 must come out of the 13th
        LocalDate date = LocalDate.of(2009, 7, 12 + firstDayOfWeek);
        for (int i = 0; i &lt; daysPerWeek; i++) {
            String name = weekDayNameFormatter.withLocale(getLocale()).format(date.plus(i, DAYS));
            dayNameCells.get(i).setText(titleCaseWord(name));
        }
    }

    public void updateWeeknumberDateCells() {
        if (datePicker.isShowWeekNumbers()) {
            final Locale locale = getLocale();
            final int maxWeeksPerMonth = 6; // TODO: Get this from chronology?

            LocalDate firstOfMonth = displayedYearMonth.get().atDay(1);
            for (int i = 0; i &lt; maxWeeksPerMonth; i++) {
                LocalDate date = firstOfMonth.plus(i, WEEKS);
                // Use a formatter to ensure correct localization,
                // such as when Thai numerals are required.
                String cellText =
                    weekNumberFormatter.withLocale(locale)
                                       .withDecimalStyle(DecimalStyle.of(locale))
                                       .format(date);
                weekNumberCells.get(i).setText(cellText);
            }
        }
    }

    public void updateDayCells() {
        Locale locale = getLocale();
        Chronology chrono = getPrimaryChronology();
        int firstOfMonthIdx = determineFirstOfMonthDayOfWeek();
        YearMonth curMonth = displayedYearMonth.get();

        // RT-31075: The following are now set in the try-catch block.
        YearMonth prevMonth = null;
        YearMonth nextMonth = null;
        int daysInCurMonth = -1;
        int daysInPrevMonth = -1;
        int daysInNextMonth = -1;

        for (int i = 0; i &lt; 6 * daysPerWeek; i++) {
            DateCell dayCell = dayCells.get(i);
            dayCell.getStyleClass().setAll(&quot;cell&quot;, &quot;date-cell&quot;, &quot;day-cell&quot;);
            dayCell.setDisable(false);
            dayCell.setStyle(null);
            dayCell.setGraphic(null);
            dayCell.setTooltip(null);

            try {
                if (daysInCurMonth == -1) {
                    daysInCurMonth = curMonth.lengthOfMonth();
                }
                YearMonth month = curMonth;
                int day = i - firstOfMonthIdx + 1;
                //int index = firstOfMonthIdx + i - 1;
                if (i &lt; firstOfMonthIdx) {
                    if (prevMonth == null) {
                        prevMonth = curMonth.minusMonths(1);
                        daysInPrevMonth = prevMonth.lengthOfMonth();
                    }
                    month = prevMonth;
                    day = i + daysInPrevMonth - firstOfMonthIdx + 1;
                    dayCell.getStyleClass().add(&quot;previous-month&quot;);
                } else if (i &gt;= firstOfMonthIdx + daysInCurMonth) {
                    if (nextMonth == null) {
                        nextMonth = curMonth.plusMonths(1);
                        daysInNextMonth = nextMonth.lengthOfMonth();
                    }
                    month = nextMonth;
                    day = i - daysInCurMonth - firstOfMonthIdx + 1;
                    dayCell.getStyleClass().add(&quot;next-month&quot;);
                }
                LocalDate date = month.atDay(day);
                dayCellDates[i] = date;
                ChronoLocalDate cDate = chrono.date(date);

                dayCell.setDisable(false);

                if (isToday(date)) {
                    dayCell.getStyleClass().add(&quot;today&quot;);
                }

                if (date.equals(datePicker.getValue())) {
                    dayCell.getStyleClass().add(&quot;selected&quot;);
                }

                String cellText =
                    dayCellFormatter.withLocale(locale)
                                    .withChronology(chrono)
                                    .withDecimalStyle(DecimalStyle.of(locale))
                                    .format(cDate);
                dayCell.setText(cellText);

                dayCell.updateItem(date, false);
            } catch (DateTimeException ex) {
                // Date is out of range.
                // System.err.println(dayCellDate(dayCell) + &quot; &quot; + ex);
                dayCell.setText(&quot; &quot;);
                dayCell.setDisable(true);
            }
        }
    }

    private int getDaysPerWeek() {
        ValueRange range = getPrimaryChronology().range(DAY_OF_WEEK);
        return (int)(range.getMaximum() - range.getMinimum() + 1);
    }

    private int getMonthsPerYear() {
        ValueRange range = getPrimaryChronology().range(MONTH_OF_YEAR);
        return (int)(range.getMaximum() - range.getMinimum() + 1);
    }

    private void updateMonthLabelWidth() {
        if (monthLabel != null) {
            int monthsPerYear = getMonthsPerYear();
            double width = 0;
            for (int i = 0; i &lt; monthsPerYear; i++) {
                YearMonth yearMonth = displayedYearMonth.get().withMonth(i + 1);
                String name = monthFormatterSO.withLocale(getLocale()).format(yearMonth);
                if (Character.isDigit(name.charAt(0))) {
                    // Fallback. The standalone format returned a number, so use standard format instead.
                    name = monthFormatter.withLocale(getLocale()).format(yearMonth);
                }
                width = Math.max(width, Utils.computeTextWidth(monthLabel.getFont(), name, 0));
            }
            monthLabel.setMinWidth(width);
        }
    }

    protected void updateMonthYearPane() {
        YearMonth yearMonth = displayedYearMonth.get();
        String str = formatMonth(yearMonth);
        monthLabel.setText(str);

        str = formatYear(yearMonth);
        yearLabel.setText(str);
        double width = Utils.computeTextWidth(yearLabel.getFont(), str, 0);
        if (width &gt; yearLabel.getMinWidth()) {
            yearLabel.setMinWidth(width);
        }

        Chronology chrono = datePicker.getChronology();
        LocalDate firstDayOfMonth = yearMonth.atDay(1);
        backMonthButton.setDisable(!isValidDate(chrono, firstDayOfMonth, -1, DAYS));
        forwardMonthButton.setDisable(!isValidDate(chrono, firstDayOfMonth, +1, MONTHS));
        backYearButton.setDisable(!isValidDate(chrono, firstDayOfMonth, -1, YEARS));
        forwardYearButton.setDisable(!isValidDate(chrono, firstDayOfMonth, +1, YEARS));
    }

    private String formatMonth(YearMonth yearMonth) {
        Chronology chrono = getPrimaryChronology();
        try {
            ChronoLocalDate cDate = chrono.date(yearMonth.atDay(1));

            String str = monthFormatterSO.withLocale(getLocale())
                                         .withChronology(chrono)
                                         .format(cDate);
            if (Character.isDigit(str.charAt(0))) {
                // Fallback. The standalone format returned a number, so use standard format instead.
                str = monthFormatter.withLocale(getLocale())
                                    .withChronology(chrono)
                                    .format(cDate);
            }
            return titleCaseWord(str);
        } catch (DateTimeException ex) {
            // Date is out of range.
            return &quot;&quot;;
        }
    }

    private String formatYear(YearMonth yearMonth) {
        Chronology chrono = getPrimaryChronology();
        try {
            DateTimeFormatter formatter = yearFormatter;
            ChronoLocalDate cDate = chrono.date(yearMonth.atDay(1));
            int era = cDate.getEra().getValue();
            int nEras = chrono.eras().size();

            /*if (cDate.get(YEAR) &lt; 0) {
                formatter = yearForNegYearFormatter;
            } else */
            if ((nEras == 2 &amp;&amp; era == 0) || nEras &gt; 2) {
                formatter = yearWithEraFormatter;
            }

            // Fixme: Format Japanese era names with Japanese text.
            String str = formatter.withLocale(getLocale())
                                  .withChronology(chrono)
                                  .withDecimalStyle(DecimalStyle.of(getLocale()))
                                  .format(cDate);

            return str;
        } catch (DateTimeException ex) {
            // Date is out of range.
            return &quot;&quot;;
        }
    }

    // Ensures that month and day names are titlecased (capitalized).
    private String titleCaseWord(String str) {
        if (str.length() &gt; 0) {
            int firstChar = str.codePointAt(0);
            if (!Character.isTitleCase(firstChar)) {
                str = new String(new int[] { Character.toTitleCase(firstChar) }, 0, 1) +
                      str.substring(Character.offsetByCodePoints(str, 0, 1));
            }
        }
        return str;
    }



    /**
     * determine on which day of week idx the first of the months is
     */
    private int determineFirstOfMonthDayOfWeek() {
        // determine with which cell to start
        int firstDayOfWeek = WeekFields.of(getLocale()).getFirstDayOfWeek().getValue();
        int firstOfMonthIdx = displayedYearMonth.get().atDay(1).getDayOfWeek().getValue() - firstDayOfWeek;
        if (firstOfMonthIdx &lt; 0) {
            firstOfMonthIdx += daysPerWeek;
        }
        return firstOfMonthIdx;
    }

    private boolean isToday(LocalDate localDate) {
        return (localDate.equals(LocalDate.now()));
    }

    protected LocalDate dayCellDate(DateCell dateCell) {
        assert (dayCellDates != null);
        return dayCellDates[dayCells.indexOf(dateCell)];
    }

    // public for behavior class
    public void goToDayCell(DateCell dateCell, int offset, ChronoUnit unit, boolean focusDayCell) {
        goToDate(dayCellDate(dateCell).plus(offset, unit), focusDayCell);
    }

    protected void forward(int offset, ChronoUnit unit, boolean focusDayCell) {
        YearMonth yearMonth = displayedYearMonth.get();
        DateCell dateCell = lastFocusedDayCell;
        if (dateCell == null || !dayCellDate(dateCell).getMonth().equals(yearMonth.getMonth())) {
            dateCell = findDayCellForDate(yearMonth.atDay(1));
        }
        goToDayCell(dateCell, offset, unit, focusDayCell);
    }

    // public for behavior class
    public void goToDate(LocalDate date, boolean focusDayCell) {
        if (isValidDate(datePicker.getChronology(), date)) {
            displayedYearMonth.set(YearMonth.from(date));
            if (focusDayCell) {
                findDayCellForDate(date).requestFocus();
            }
        }
    }

    // public for behavior class
    public void selectDayCell(DateCell dateCell) {
        datePicker.setValue(dayCellDate(dateCell));
        datePicker.hide();
    }

    private DateCell findDayCellForDate(LocalDate date) {
        for (int i = 0; i &lt; dayCellDates.length; i++) {
            if (date.equals(dayCellDates[i])) {
                return dayCells.get(i);
            }
        }
        return dayCells.get(dayCells.size()/2+1);
    }

    public void clearFocus() {
        LocalDate focusDate = datePicker.getValue();
        if (focusDate == null) {
            focusDate = LocalDate.now();
        }
        if (YearMonth.from(focusDate).equals(displayedYearMonth.get())) {
            // focus date
            goToDate(focusDate, true);
        } else {
            // focus month spinner (should not happen)
            backMonthButton.requestFocus();
        }

        // RT-31857
        if (backMonthButton.getWidth() == 0) {
            backMonthButton.requestLayout();
            forwardMonthButton.requestLayout();
            backYearButton.requestLayout();
            forwardYearButton.requestLayout();
        }
    }

    protected void createDayCells() {
        final EventHandler&lt;MouseEvent&gt; dayCellActionHandler = ev -&gt; {
            if (ev.getButton() != MouseButton.PRIMARY) {
                return;
            }

            DateCell dayCell = (DateCell)ev.getSource();
            selectDayCell(dayCell);
            lastFocusedDayCell = dayCell;
        };

        for (int row = 0; row &lt; 6; row++) {
            for (int col = 0; col &lt; daysPerWeek; col++) {
                DateCell dayCell = createDayCell();
                dayCell.addEventHandler(MouseEvent.MOUSE_CLICKED, dayCellActionHandler);
                dayCells.add(dayCell);
            }
        }

        dayCellDates = new LocalDate[6 * daysPerWeek];
    }

    private DateCell createDayCell() {
        DateCell cell = null;
        if (datePicker.getDayCellFactory() != null) {
            cell = datePicker.getDayCellFactory().call(datePicker);
        }
        if (cell == null) {
            cell = new DateCell();
        }

        return cell;
    }

    protected Locale getLocale() {
        return Locale.getDefault(Locale.Category.FORMAT);
    }

    /**
     * The primary chronology for display. This may be overridden to
     * be different than the DatePicker chronology. For example
     * DatePickerHijrahContent uses ISO as primary and Hijrah as a
     * secondary chronology.
     */
    protected Chronology getPrimaryChronology() {
        return datePicker.getChronology();
    }

    protected boolean isValidDate(Chronology chrono, LocalDate date, int offset, ChronoUnit unit) {
        if (date != null) {
            try {
                return isValidDate(chrono, date.plus(offset, unit));
            } catch (DateTimeException ex) {
            }
        }
        return false;
    }

    protected boolean isValidDate(Chronology chrono, LocalDate date) {
        try {
            if (date != null) {
                chrono.date(date);
            }
            return true;
        } catch (DateTimeException ex) {
            return false;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/EmbeddedTextContextMenuContent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import java.util.Map;

import com.sun.javafx.scene.control.skin.*;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.collections.ListChangeListener;
import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.geometry.HPos;
import javafx.geometry.VPos;
import javafx.scene.control.*;
import javafx.scene.control.skin.TextAreaSkin;
import javafx.scene.control.skin.TextFieldSkin;
import javafx.scene.layout.HBox;
import javafx.scene.layout.StackPane;

/**
 * The embedded context menu for a text input control.
 * The menu will be displayed horizontally underneath the cursor
 * with the available text editing options i.e. cut, copy, paste, select all.
 *
 */
public class EmbeddedTextContextMenuContent extends StackPane {

    private ContextMenu contextMenu;
    private StackPane pointer;
    private HBox menuBox;

    public EmbeddedTextContextMenuContent(final ContextMenu popupMenu) {
        this.contextMenu = popupMenu;
        this.menuBox = new HBox();
        this.pointer = new StackPane();
        pointer.getStyleClass().add(&quot;pointer&quot;);

        updateMenuItemContainer();
        getChildren().addAll(pointer, menuBox);

        contextMenu.ownerNodeProperty().addListener(arg0 -&gt; {
            if (contextMenu.getOwnerNode() instanceof TextArea) {
                TextAreaSkin tas = (TextAreaSkin)((TextArea)contextMenu.getOwnerNode()).getSkin();
                tas.getSkinnable().getProperties().addListener(new InvalidationListener() {
                    @Override public void invalidated(Observable arg0) {
                        requestLayout();
                    }
                });
            } else if (contextMenu.getOwnerNode() instanceof TextField) {
                TextFieldSkin tfs = (TextFieldSkin)((TextField)contextMenu.getOwnerNode()).getSkin();
                tfs.getSkinnable().getProperties().addListener(new InvalidationListener() {
                    @Override public void invalidated(Observable arg0) {
                        requestLayout();
                    }
                });
            }
        });

        contextMenu.getItems().addListener((ListChangeListener&lt;MenuItem&gt;) c -&gt; {
            // Listener to items in PopupMenu to update items in PopupMenuContent
            updateMenuItemContainer();
        });
<A NAME="18"></A>    }

    private void updateMenuItemContainer() {
        <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#18',2,'match52-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>menuBox.getChildren().clear();
        for (MenuItem item: contextMenu.getItems()) {
            MenuItemContainer menuItemContainer = new MenuItemContainer(item);
            menuItemContainer.visibleProperty().bind(item.visibleProperty());
            menuBox.getChildren</B></FONT>().add(menuItemContainer);
        }
    }

    private void hideAllMenus(MenuItem item) {
        contextMenu.hide();

        Menu parentMenu;
        while ((parentMenu = item.getParentMenu()) != null) {
            parentMenu.hide();
            item = parentMenu;
        }
        if (parentMenu == null &amp;&amp; item.getParentPopup() != null) {
            item.getParentPopup().hide();
        }
    }

    @Override protected double computePrefHeight(double width) {
        final double pointerHeight = snapSizeY(pointer.prefHeight(width));
        final double menuBoxHeight = snapSizeY(menuBox.prefHeight(width));
        return snappedTopInset() + pointerHeight + menuBoxHeight + snappedBottomInset();
    }

    @Override protected double computePrefWidth(double height) {
        final double menuBoxWidth = snapSizeX(menuBox.prefWidth(height));
        return snappedLeftInset() + menuBoxWidth + snappedRightInset();
    }

    @Override protected void layoutChildren() {
        final double left = snappedLeftInset();
        final double right = snappedRightInset();
        final double top = snappedTopInset();
        final double width = getWidth() - (left + right);
        final double pointerWidth = snapSizeX(Utils.boundedSize(pointer.prefWidth(-1), pointer.minWidth(-1), pointer.maxWidth(-1)));
        final double pointerHeight = snapSizeY(Utils.boundedSize(pointer.prefWidth(-1), pointer.minWidth(-1), pointer.maxWidth(-1)));
        final double menuBoxWidth = snapSizeX(Utils.boundedSize(menuBox.prefWidth(-1), menuBox.minWidth(-1), menuBox.maxWidth(-1)));
        final double menuBoxHeight = snapSizeY(Utils.boundedSize(menuBox.prefWidth(-1), menuBox.minWidth(-1), menuBox.maxWidth(-1)));
        double sceneX = 0;
        double screenX = 0;
        double pointerX = 0;

        // Get the positions of the cursor from the TextArea/TextField and draw the arrow underneath it.
        Map&lt;Object,Object&gt; properties = null;
        if (contextMenu.getOwnerNode() instanceof TextArea) {
            properties = ((TextArea)contextMenu.getOwnerNode()).getProperties();
        } else if (contextMenu.getOwnerNode() instanceof TextField) {
            properties = ((TextField)contextMenu.getOwnerNode()).getProperties();
        }

        if (properties != null) {
            if (properties.containsKey(&quot;CONTEXT_MENU_SCENE_X&quot;)) {
                sceneX = Double.valueOf(properties.get(&quot;CONTEXT_MENU_SCENE_X&quot;).toString());
                properties.remove(&quot;CONTEXT_MENU_SCENE_X&quot;);
            }

            if (properties.containsKey(&quot;CONTEXT_MENU_SCREEN_X&quot;)) {
                screenX = Double.valueOf(properties.get(&quot;CONTEXT_MENU_SCREEN_X&quot;).toString());
                properties.remove(&quot;CONTEXT_MENU_SCREEN_X&quot;);
            }
        }

        if (sceneX == 0) {
            pointerX = width/2;
        } else {
            pointerX = (screenX - sceneX - contextMenu.getX()) + sceneX;
        }

        pointer.resize(pointerWidth, pointerHeight);
        positionInArea(pointer, pointerX, top, pointerWidth, pointerHeight, 0, HPos.CENTER, VPos.CENTER);
        menuBox.resize(menuBoxWidth, menuBoxHeight);
        positionInArea(menuBox, left, top + pointerHeight, menuBoxWidth, menuBoxHeight, 0, HPos.CENTER, VPos.CENTER);
    }

    class MenuItemContainer extends Button {
        private MenuItem item;

        public MenuItemContainer(MenuItem item){
            getStyleClass().addAll(item.getStyleClass());
            setId(item.getId());
            this.item = item;
            setText(item.getText());
            setStyle(item.getStyle());

            // bind to text property in menu item
            textProperty().bind(item.textProperty());
        }

        public MenuItem getItem() {
            return item;
        }

        @Override public void fire() {
            Event.fireEvent(item, new ActionEvent());
            if (!Boolean.TRUE.equals((Boolean)item.getProperties().get(&quot;refreshMenu&quot;))) {
                hideAllMenus(item);
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/CellBehaviorBase.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import javafx.scene.control.Cell;
import javafx.scene.control.Control;
import javafx.scene.control.FocusModel;
import javafx.scene.control.IndexedCell;
import javafx.scene.control.MultipleSelectionModel;
import javafx.scene.control.SelectionMode;
import com.sun.javafx.scene.control.inputmap.InputMap;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;

import java.util.ArrayList;
import java.util.List;

/**
 * Behaviors for standard cells types. Simply defines methods that subclasses
 * implement so that CellSkinBase has API to call.
 */
public abstract class CellBehaviorBase&lt;T extends Cell&gt; extends BehaviorBase&lt;T&gt; {


    /***************************************************************************
     *                                                                         *
     * Private static implementation                                           *
     *                                                                         *
     **************************************************************************/

    private static final String ANCHOR_PROPERTY_KEY = &quot;anchor&quot;;

    // The virtualised controls all start with selection on row 0 by default.
    // This means that we have a default anchor, but it should be removed if
    // a different anchor could be set - and normally we ignore the default
    // anchor anyway.
    private static final String IS_DEFAULT_ANCHOR_KEY = &quot;isDefaultAnchor&quot;;

    public static &lt;T&gt; T getAnchor(Control control, T defaultResponse) {
        return hasNonDefaultAnchor(control) ?
                (T) control.getProperties().get(ANCHOR_PROPERTY_KEY) :
                defaultResponse;
    }

    public static &lt;T&gt; void setAnchor(Control control, T anchor, boolean isDefaultAnchor) {
        if (control == null) return;
        if (anchor == null) {
            removeAnchor(control);
        } else {
            control.getProperties().put(ANCHOR_PROPERTY_KEY, anchor);
            control.getProperties().put(IS_DEFAULT_ANCHOR_KEY, isDefaultAnchor);
        }
    }

    public static boolean hasNonDefaultAnchor(Control control) {
        Boolean isDefaultAnchor = (Boolean) control.getProperties().remove(IS_DEFAULT_ANCHOR_KEY);
        return (isDefaultAnchor == null || isDefaultAnchor == false) &amp;&amp; hasAnchor(control);
    }

    public static boolean hasDefaultAnchor(Control control) {
        Boolean isDefaultAnchor = (Boolean) control.getProperties().remove(IS_DEFAULT_ANCHOR_KEY);
        return isDefaultAnchor != null &amp;&amp; isDefaultAnchor == true &amp;&amp; hasAnchor(control);
    }

    private static boolean hasAnchor(Control control) {
        return control.getProperties().get(ANCHOR_PROPERTY_KEY) != null;
    }

    public static void removeAnchor(Control control) {
        control.getProperties().remove(ANCHOR_PROPERTY_KEY);
        control.getProperties().remove(IS_DEFAULT_ANCHOR_KEY);
    }



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private final InputMap&lt;T&gt; cellInputMap;

    // To support touch devices, we have to slightly modify this behavior, such
    // that selection only happens on mouse release, if only minimal dragging
    // has occurred.
    private boolean latePress = false;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    public CellBehaviorBase(T control) {
        super(control);

        // create a map for cell-specific mappings (this reuses the default
        // InputMap installed on the control, if it is non-null, allowing us to pick up any user-specified mappings)
        cellInputMap = createInputMap();

        // TODO add focus traversal mappings (?)
        // addDefaultMapping(cellInputMap, FocusTraversalInputMap.getFocusTraversalMappings());

        InputMap.MouseMapping pressedMapping, releasedMapping, mouseDragged;
        addDefaultMapping(
            pressedMapping = new InputMap.MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed),
            releasedMapping = new InputMap.MouseMapping(MouseEvent.MOUSE_RELEASED, this::mouseReleased),
            mouseDragged = new InputMap.MouseMapping(MouseEvent.MOUSE_DRAGGED, this::mouseDragged)
        );
        pressedMapping.setAutoConsume(false);
        releasedMapping.setAutoConsume(false);
        mouseDragged.setAutoConsume(false);
    }


    protected abstract Control getCellContainer(); // e.g. ListView
    protected abstract MultipleSelectionModel&lt;?&gt; getSelectionModel();
    protected abstract FocusModel&lt;?&gt; getFocusModel();
    protected abstract void edit(T cell);
    protected boolean handleDisclosureNode(double x, double y) {
        return false;
    }
    protected boolean isClickPositionValid(final double x, final double y) {
        return true;
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public InputMap&lt;T&gt; getInputMap() {
        return cellInputMap;
    }

    protected int getIndex() {
        return getNode() instanceof IndexedCell ? ((IndexedCell&lt;?&gt;)getNode()).getIndex() : -1;
    }

    public void mousePressed(MouseEvent e) {
<A NAME="29"></A>        if (e.isSynthesized()) {
            latePress = true;
        } else {
            <FONT color="#faafba"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#29',2,'match52-top.html#29',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>latePress  = isSelected();
            if (!latePress) {
                doSelect(e.getX(), e.getY(), e.getButton(), e.getClickCount(),
                        e.isShiftDown(), e.isShortcutDown());
            }
        }</B></FONT>
    }

    public void mouseReleased(MouseEvent e) {
        if (latePress) {
            latePress = false;
            doSelect(e.getX(), e.getY(), e.getButton(), e.getClickCount(),
                    e.isShiftDown(), e.isShortcutDown());
        }
    }

    public void mouseDragged(MouseEvent e) {
        latePress = false;
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    protected void doSelect(final double x, final double y, final MouseButton button,
                            final int clickCount, final boolean shiftDown, final boolean shortcutDown) {
        // we update the cell to point to the new tree node
        final T cell = getNode();

        final Control cellContainer = getCellContainer();

        // If the mouse event is not contained within this TreeCell, then
        // we don't want to react to it.
        if (cell.isEmpty() || ! cell.contains(x, y)) {
            return;
        }

        final int index = getIndex();
        boolean selected = cell.isSelected();
        MultipleSelectionModel&lt;?&gt; sm = getSelectionModel();
        if (sm == null) return;

        FocusModel&lt;?&gt; fm = getFocusModel();
        if (fm == null) return;

        // if the user has clicked on the disclosure node, we do nothing other
        // than expand/collapse the tree item (if applicable). We do not do editing!
        if (handleDisclosureNode(x,y)) {
            return;
        }

        // we only care about clicks in certain places (depending on the subclass)
        if (! isClickPositionValid(x, y)) return;

        // if shift is down, and we don't already have the initial focus index
        // recorded, we record the focus index now so that subsequent shift+clicks
        // result in the correct selection occuring (whilst the focus index moves
        // about).
        if (shiftDown) {
            if (! hasNonDefaultAnchor(cellContainer)) {
                setAnchor(cellContainer, fm.getFocusedIndex(), false);
            }
        } else {
            removeAnchor(cellContainer);
        }

        if (button == MouseButton.PRIMARY || (button == MouseButton.SECONDARY &amp;&amp; !selected)) {
            if (sm.getSelectionMode() == SelectionMode.SINGLE) {
                simpleSelect(button, clickCount, shortcutDown);
            } else {
                if (shortcutDown) {
                    if (selected) {
                        // we remove this row from the current selection
                        sm.clearSelection(index);
                        fm.focus(index);
                    } else {
                        // We add this row to the current selection
                        sm.select(index);
                    }
                } else if (shiftDown &amp;&amp; clickCount == 1) {
                    // we add all rows between the current selection focus and
                    // this row (inclusive) to the current selection.
                    final int focusedIndex = getAnchor(cellContainer, fm.getFocusedIndex());

                    selectRows(focusedIndex, index);

                    fm.focus(index);
                } else {
                    simpleSelect(button, clickCount, shortcutDown);
                }
            }
        }
    }

    protected void simpleSelect(MouseButton button, int clickCount, boolean shortcutDown) {
        final int index = getIndex();
        MultipleSelectionModel&lt;?&gt; sm = getSelectionModel();
        boolean isAlreadySelected = sm.isSelected(index);

        if (isAlreadySelected &amp;&amp; shortcutDown) {
            sm.clearSelection(index);
            getFocusModel().focus(index);
            isAlreadySelected = false;
        } else {
            sm.clearAndSelect(index);
        }

        handleClicks(button, clickCount, isAlreadySelected);
    }

    protected void handleClicks(MouseButton button, int clickCount, boolean isAlreadySelected) {
        // handle editing, which only occurs with the primary mouse button
        if (button == MouseButton.PRIMARY) {
            if (clickCount == 1 &amp;&amp; isAlreadySelected) {
                edit(getNode());
            } else if (clickCount == 1) {
                // cancel editing
                edit(null);
            } else if (clickCount == 2 &amp;&amp; getNode().isEditable()) {
                edit(getNode());
            }
        }
    }

    void selectRows(int focusedIndex, int index) {
        final boolean asc = focusedIndex &lt; index;

        // and then determine all row and columns which must be selected
        int minRow = Math.min(focusedIndex, index);
        int maxRow = Math.max(focusedIndex, index);

        // To prevent RT-32119, we make a copy of the selected indices
        // list first, so that we are not iterating and modifying it
        // concurrently.
        List&lt;Integer&gt; selectedIndices = new ArrayList&lt;&gt;(getSelectionModel().getSelectedIndices());
        for (int i = 0, max = selectedIndices.size(); i &lt; max; i++) {
            int selectedIndex = selectedIndices.get(i);
            if (selectedIndex &lt; minRow || selectedIndex &gt; maxRow) {
                getSelectionModel().clearSelection(selectedIndex);
            }
        }

        if (minRow == maxRow) {
            // RT-32560: This prevents the anchor 'sticking' in
            // the wrong place when a range is selected and then
            // selection goes back to the anchor position.
            // (Refer to the video in RT-32560 for more detail).
            getSelectionModel().select(minRow);
        } else {
            // RT-21444: We need to put the range in the correct
            // order or else the last selected row will not be the
            // last item in the selectedItems list of the selection
            // model,
            if (asc) {
                getSelectionModel().selectRange(minRow, maxRow + 1);
            } else {
                getSelectionModel().selectRange(maxRow, minRow - 1);
            }
        }
    }

    protected boolean isSelected() {
        return getNode().isSelected();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/TextFieldBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.scene.control.Properties;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.WeakChangeListener;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.TextField;
import javafx.scene.control.skin.TextFieldSkin;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.text.HitInfo;
import javafx.stage.Screen;
import javafx.stage.Window;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.geom.transform.Affine3D;

import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.stage.WindowHelper;

/**
 * Text field behavior.
 */
public class TextFieldBehavior extends TextInputControlBehavior&lt;TextField&gt; {
    private TextFieldSkin skin;
    private TwoLevelFocusBehavior tlFocus;
    private ChangeListener&lt;Scene&gt; sceneListener;
    private ChangeListener&lt;Node&gt; focusOwnerListener;

    public TextFieldBehavior(final TextField textField) {
        super(textField);

        if (Properties.IS_TOUCH_SUPPORTED) {
            contextMenu.getStyleClass().add(&quot;text-input-context-menu&quot;);
        }

        handleFocusChange();

        // Register for change events
        textField.focusedProperty().addListener((observable, oldValue, newValue) -&gt; {
            handleFocusChange();
        });

        focusOwnerListener = (observable, oldValue, newValue) -&gt; {
            // RT-23699: The selection is now only affected when the TextField
            // gains or loses focus within the Scene, and not when the whole
            // stage becomes active or inactive.
            if (newValue == textField) {
                if (!focusGainedByMouseClick) {
                    textField.selectRange(textField.getLength(), 0);
                }
            } else {
                textField.selectRange(0, 0);
            }
        };

        final WeakChangeListener&lt;Node&gt; weakFocusOwnerListener =
                                new WeakChangeListener&lt;Node&gt;(focusOwnerListener);
        sceneListener = (observable, oldValue, newValue) -&gt; {
            if (oldValue != null) {
                oldValue.focusOwnerProperty().removeListener(weakFocusOwnerListener);
            }
            if (newValue != null) {
                newValue.focusOwnerProperty().addListener(weakFocusOwnerListener);
            }
        };
        textField.sceneProperty().addListener(new WeakChangeListener&lt;Scene&gt;(sceneListener));

        if (textField.getScene() != null) {
            textField.getScene().focusOwnerProperty().addListener(weakFocusOwnerListener);
        }

        // Only add this if we're on an embedded platform that supports 5-button navigation
        if (Utils.isTwoLevelFocus()) {
            tlFocus = new TwoLevelFocusBehavior(textField); // needs to be last.
        }
    }

    @Override public void dispose() {
        if (tlFocus != null) tlFocus.dispose();
        super.dispose();
    }

    private void handleFocusChange() {
        TextField textField = getNode();

        if (textField.isFocused()) {
            if (PlatformUtil.isIOS()) {
                // special handling of focus on iOS is required to allow to
                // control native keyboard, because nat. keyboard is poped-up only when native
                // text component gets focus. When we have JFX keyboard we can remove this code
                TextInputTypes type = TextInputTypes.TEXT_FIELD;
                if (textField.getClass().equals(javafx.scene.control.PasswordField.class)) {
                    type = TextInputTypes.PASSWORD_FIELD;
                } else if (textField.getParent().getClass().equals(javafx.scene.control.ComboBox.class)) {
                    type = TextInputTypes.EDITABLE_COMBO;
                }
                final Bounds bounds = textField.getBoundsInParent();
                double w = bounds.getWidth();
                double h = bounds.getHeight();
                Affine3D trans = calculateNodeToSceneTransform(textField);
//                Insets insets = skin.getInsets();
//                w -= insets.getLeft() + insets.getRight();
//                h -= insets.getTop() + insets.getBottom();
                String text = textField.getText();

                // we need to display native text input component on the place where JFX component is drawn
                // all parameters needed to do that are passed to native impl. here
                WindowHelper.getPeer(textField.getScene().getWindow()).requestInput(
                        text, type.ordinal(), w, h,
                        trans.getMxx(), trans.getMxy(), trans.getMxz(), trans.getMxt(),// + insets.getLeft(),
                        trans.getMyx(), trans.getMyy(), trans.getMyz(), trans.getMyt(),// + insets.getTop(),
                        trans.getMzx(), trans.getMzy(), trans.getMzz(), trans.getMzt());
            }
            if (!focusGainedByMouseClick) {
                setCaretAnimating(true);
            }
        } else {
            if (PlatformUtil.isIOS() &amp;&amp; textField.getScene() != null) {
                // releasing the focus =&gt; we need to hide the native component and also native keyboard
                WindowHelper.getPeer(textField.getScene().getWindow()).releaseInput();
            }
            focusGainedByMouseClick = false;
            setCaretAnimating(false);
        }
    }

    static Affine3D calculateNodeToSceneTransform(Node node) {
        final Affine3D transform = new Affine3D();
        do {
            transform.preConcatenate(NodeHelper.getLeafTransform(node));
            node = node.getParent();
        } while (node != null);

        return transform;
    }

    // An unholy back-reference!
    public void setTextFieldSkin(TextFieldSkin skin) {
        this.skin = skin;
    }

    @Override protected void fire(KeyEvent event) {
        TextField textField = getNode();
        EventHandler&lt;ActionEvent&gt; onAction = textField.getOnAction();
        ActionEvent actionEvent = new ActionEvent(textField, null);

        textField.commitValue();
        textField.fireEvent(actionEvent);

        if (onAction == null &amp;&amp; !actionEvent.isConsumed()) {
            forwardToParent(event);
        }
    }

    @Override
    protected void cancelEdit(KeyEvent event) {
        TextField textField = getNode();
        if (textField.getTextFormatter() != null) {
            textField.cancelEdit();
            event.consume();
        } else {
            super.cancelEdit(event);
        }
    }

    @Override protected void deleteChar(boolean previous) {
        skin.deleteChar(previous);
    }

    @Override protected void replaceText(int start, int end, String txt) {
        skin.setForwardBias(true);
        skin.replaceText(start, end, txt);
    }

    @Override protected void deleteFromLineStart() {
        TextField textField = getNode();
        int end = textField.getCaretPosition();

        if (end &gt; 0) {
            replaceText(0, end, &quot;&quot;);
        }
    }

    @Override protected void setCaretAnimating(boolean play) {
        if (skin != null) {
            skin.setCaretAnimating(play);
        }
    }

    /**
     * Function which beeps. This requires a hook into the toolkit, and should
     * also be guarded by something that indicates whether we should beep
     * (as it is pretty annoying and many native controls don't do it).
     */
    private void beep() {
        // TODO
    }

    /**
     * If the focus is gained via response to a mouse click, then we don't
     * want to select all the text even if selectOnFocus is true.
     */
    private boolean focusGainedByMouseClick = false;
    private boolean shiftDown = false;
    private boolean deferClick = false;

    @Override public void mousePressed(MouseEvent e) {
        TextField textField = getNode();
        // We never respond to events if disabled
        if (!textField.isDisabled()) {
            // If the text field doesn't have focus, then we'll attempt to set
            // the focus and we'll indicate that we gained focus by a mouse
            // click, which will then NOT honor the selectOnFocus variable
            // of the textInputControl
            if (!textField.isFocused()) {
                focusGainedByMouseClick = true;
                textField.requestFocus();
            }

            // stop the caret animation
            setCaretAnimating(false);
            // only if there is no selection should we see the caret
//            setCaretOpacity(if (textInputControl.dot == textInputControl.mark) then 1.0 else 0.0);

            // if the primary button was pressed
            if (e.isPrimaryButtonDown() &amp;&amp; !(e.isMiddleButtonDown() || e.isSecondaryButtonDown())) {
                HitInfo hit = skin.getIndex(e.getX(), e.getY());
                int i = hit.getInsertionIndex();
                final int anchor = textField.getAnchor();
                final int caretPosition = textField.getCaretPosition();
                if (e.getClickCount() &lt; 2 &amp;&amp;
                    (Properties.IS_TOUCH_SUPPORTED ||
                     (anchor != caretPosition &amp;&amp;
                      ((i &gt; anchor &amp;&amp; i &lt; caretPosition) || (i &lt; anchor &amp;&amp; i &gt; caretPosition))))) {
                    // if there is a selection, then we will NOT handle the
                    // press now, but will defer until the release. If you
                    // select some text and then press down, we change the
                    // caret and wait to allow you to drag the text (TODO).
                    // When the drag concludes, then we handle the click

                    deferClick = true;
                    // TODO start a timer such that after some millis we
                    // switch into text dragging mode, change the cursor
                    // to indicate the text can be dragged, etc.
                } else if (!(e.isControlDown() || e.isAltDown() || e.isShiftDown() || e.isMetaDown())) {
                    switch (e.getClickCount()) {
                        case 1: mouseSingleClick(hit); break;
                        case 2: mouseDoubleClick(hit); break;
                        case 3: mouseTripleClick(hit); break;
                        default: // no-op
                    }
                } else if (e.isShiftDown() &amp;&amp; !(e.isControlDown() || e.isAltDown() || e.isMetaDown()) &amp;&amp; e.getClickCount() == 1) {
                    // didn't click inside the selection, so select
                    shiftDown = true;
                    // if we are on mac os, then we will accumulate the
                    // selection instead of just moving the dot. This happens
                    // by figuring out past which (dot/mark) are extending the
                    // selection, and set the mark to be the other side and
                    // the dot to be the new position.
                    // everywhere else we just move the dot.
                    if (isMac()) {
                        textField.extendSelection(i);
                    } else {
                        skin.positionCaret(hit, true);
                    }
                }
                skin.setForwardBias(hit.isLeading());
//                if (textInputControl.editable)
//                    displaySoftwareKeyboard(true);
            }
        }
        if (contextMenu.isShowing()) {
            contextMenu.hide();
        }
    }

    @Override public void mouseDragged(MouseEvent e) {
        final TextField textField = getNode();
        // we never respond to events if disabled, but we do notify any onXXX
        // event listeners on the control
        if (!textField.isDisabled() &amp;&amp; !deferClick) {
            if (e.isPrimaryButtonDown() &amp;&amp; !(e.isMiddleButtonDown() || e.isSecondaryButtonDown())) {
                if (!(e.isControlDown() || e.isAltDown() || e.isShiftDown() || e.isMetaDown())) {
                    skin.positionCaret(skin.getIndex(e.getX(), e.getY()), true);
                }
            }
        }
    }

    @Override public void mouseReleased(MouseEvent e) {
        final TextField textField = getNode();
        // we never respond to events if disabled, but we do notify any onXXX
        // event listeners on the control
        if (!textField.isDisabled()) {
            setCaretAnimating(false);
            if (deferClick) {
                deferClick = false;
                skin.positionCaret(skin.getIndex(e.getX(), e.getY()), shiftDown);
                shiftDown = false;
            }
            setCaretAnimating(true);
        }
    }

    @Override public void contextMenuRequested(ContextMenuEvent e) {
        final TextField textField = getNode();

        if (contextMenu.isShowing()) {
            contextMenu.hide();
        } else if (textField.getContextMenu() == null &amp;&amp;
                   textField.getOnContextMenuRequested() == null) {
            double screenX = e.getScreenX();
            double screenY = e.getScreenY();
            double sceneX = e.getSceneX();

            if (Properties.IS_TOUCH_SUPPORTED) {
                Point2D menuPos;
                if (textField.getSelection().getLength() == 0) {
                    skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false);
                    menuPos = skin.getMenuPosition();
                } else {
                    menuPos = skin.getMenuPosition();
                    if (menuPos != null &amp;&amp; (menuPos.getX() &lt;= 0 || menuPos.getY() &lt;= 0)) {
                        skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false);
                        menuPos = skin.getMenuPosition();
                    }
<A NAME="7"></A>                }

                if (menuPos != null) {
                    Point2D p = <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#7',2,'match52-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getNode().localToScene(menuPos);
                    Scene scene = getNode().getScene();
                    Window window = scene.getWindow();
                    Point2D location = new Point2D(window.getX() + scene.getX() + p.getX</B></FONT>(),
                                                   window.getY() + scene.getY() + p.getY());
                    screenX = location.getX();
                    sceneX = p.getX();
                    screenY = location.getY();
                }
            }

            populateContextMenu();
            double menuWidth = contextMenu.prefWidth(-1);
            double menuX = screenX - (Properties.IS_TOUCH_SUPPORTED ? (menuWidth / 2) : 0);
            Screen currentScreen = com.sun.javafx.util.Utils.getScreenForPoint(screenX, 0);
            Rectangle2D bounds = currentScreen.getBounds();

            if (menuX &lt; bounds.getMinX()) {
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, screenX);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, sceneX);
                contextMenu.show(getNode(), bounds.getMinX(), screenY);
            } else if (screenX + menuWidth &gt; bounds.getMaxX()) {
                double leftOver = menuWidth - ( bounds.getMaxX() - screenX);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, screenX);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, sceneX);
                contextMenu.show(getNode(), screenX - leftOver, screenY);
            } else {
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, 0);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, 0);
                contextMenu.show(getNode(), menuX, screenY);
            }
        }

        e.consume();
    }

    protected void mouseSingleClick(HitInfo hit) {
        skin.positionCaret(hit, false);
    }

    protected void mouseDoubleClick(HitInfo hit) {
        final TextField textField = getNode();
        textField.previousWord();
        if (isWindows()) {
            textField.selectNextWord();
        } else {
            textField.selectEndOfNextWord();
        }
    }

    protected void mouseTripleClick(HitInfo hit) {
        getNode().selectAll();
    }

    // Enumeration of all types of text input that can be simulated on
    // touch device, such as iPad. Type is passed to native code and
    // native text component is shown. It's used as workaround for iOS
    // devices since keyboard control is not possible without native
    // text component being displayed
    enum TextInputTypes {
        TEXT_FIELD,
        PASSWORD_FIELD,
        EDITABLE_COMBO,
        TEXT_AREA;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/skin/FXVKSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.skin;

import javafx.animation.Animation;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.geometry.VPos;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.SkinBase;
import javafx.scene.control.TextInputControl;
import javafx.scene.control.TextField;
import javafx.scene.control.TextArea;
import javafx.scene.control.ComboBoxBase;
import javafx.scene.Scene;
import javafx.scene.control.skin.TextAreaSkin;
import javafx.scene.input.InputEvent;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.layout.Region;
import javafx.scene.text.Text;
import javafx.stage.Popup;
import javafx.stage.Window;
import javafx.util.Duration;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.HashMap;
import static javafx.scene.input.MouseEvent.MOUSE_PRESSED;
import static javafx.scene.input.TouchEvent.TOUCH_PRESSED;
import static javafx.scene.layout.Region.USE_PREF_SIZE;
import java.security.AccessController;
import java.security.PrivilegedAction;


public class FXVKSkin extends SkinBase&lt;FXVK&gt; {

    private static final int GAP = 6;

    private List&lt;List&lt;Key&gt;&gt; currentBoard;
    private static HashMap&lt;String, List&lt;List&lt;Key&gt;&gt;&gt; boardMap = new HashMap&lt;String, List&lt;List&lt;Key&gt;&gt;&gt;();
    private int numCols;

    private boolean capsDown = false;
    private boolean shiftDown = false;
    private boolean isSymbol = false;
    long lastTime = -1L;

    void clearShift() {
        if (shiftDown &amp;&amp; !capsDown) {
            shiftDown = false;
            updateKeys();
        }
        lastTime = -1L;
    }

    void pressShift() {
        long time = System.currentTimeMillis();

        //potential for a shift lock
        if (shiftDown &amp;&amp; !capsDown) {
            if (lastTime &gt; 0L &amp;&amp; time - lastTime &lt; 400L) {
                //set caps lock
                shiftDown = false;
                capsDown =  true;
            } else {
                //set normal
                shiftDown = false;
                capsDown =  false;
            }
        } else if (!shiftDown &amp;&amp; !capsDown) {
            // set shift
            shiftDown=true;
        } else {
            //set to normal
            shiftDown = false;
            capsDown =  false;
        }

        updateKeys();
        lastTime = time;
    }

    void clearSymbolABC() {
        isSymbol = false;
        updateKeys();
    }

    void pressSymbolABC() {
        isSymbol = !isSymbol;
        updateKeys();
    }

    void clearStateKeys() {
        capsDown = false;
        shiftDown = false;
<A NAME="4"></A>        isSymbol = false;
        lastTime = -1L;
        updateKeys();
    <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#4',2,'match52-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    private void updateKeys() {
        for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {</B></FONT>
                key.update(capsDown, shiftDown, isSymbol);
            }
        }
    }

    private static Popup vkPopup;
    private static Popup secondaryPopup;
    private static FXVK primaryVK;

    private static Timeline slideInTimeline = new Timeline();
    private static Timeline slideOutTimeline = new Timeline();
    private static boolean hideAfterSlideOut = false;

    private static FXVK secondaryVK;
    private static Timeline secondaryVKDelay;
    private static CharKey secondaryVKKey;
    private static TextInputKey repeatKey;

    private static Timeline repeatInitialDelay;
    private static Timeline repeatSubsequentDelay;

    // key repeat initial delay (ms)
    private static double KEY_REPEAT_DELAY = 400;
    private static double KEY_REPEAT_DELAY_MIN = 100;
    private static double KEY_REPEAT_DELAY_MAX = 1000;

    // key repeat rate (cps)
    private static double KEY_REPEAT_RATE = 25;
    private static double KEY_REPEAT_RATE_MIN = 2;
    private static double KEY_REPEAT_RATE_MAX = 50;

    private Node attachedNode;
    private String vkType = null;

    FXVK fxvk;

    static final double VK_HEIGHT = 243;
    static final double VK_SLIDE_MILLIS = 250;
    static final double PREF_PORTRAIT_KEY_WIDTH = 40;
    static final double PREF_KEY_HEIGHT = 56;

    static boolean vkAdjustWindow = false;
    static boolean vkLookup = false;

    static {
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            String s = System.getProperty(&quot;com.sun.javafx.vk.adjustwindow&quot;);
            if (s != null) {
                vkAdjustWindow = Boolean.valueOf(s);
            }
            s = System.getProperty(&quot;com.sun.javafx.sqe.vk.lookup&quot;);
            if (s != null) {
                vkLookup = Boolean.valueOf(s);
            }
            s = System.getProperty(&quot;com.sun.javafx.virtualKeyboard.backspaceRepeatDelay&quot;);
            if (s != null) {
                Double delay = Double.valueOf(s);
                KEY_REPEAT_DELAY = Math.min(Math.max(delay, KEY_REPEAT_DELAY_MIN), KEY_REPEAT_DELAY_MAX);
            }
            s = System.getProperty(&quot;com.sun.javafx.virtualKeyboard.backspaceRepeatRate&quot;);
            if (s != null) {
                Double rate = Double.valueOf(s);
                if (rate &lt;= 0) {
                    //disable key repeat
                    KEY_REPEAT_RATE = 0;
                } else {
                    KEY_REPEAT_RATE = Math.min(Math.max(rate, KEY_REPEAT_RATE_MIN), KEY_REPEAT_RATE_MAX);
                }
            }
            return null;
        });
    }

    // Proxy for read-only Window.yProperty() so we can animate.
    private static DoubleProperty winY = new SimpleDoubleProperty();
    static {
        winY.addListener(valueModel -&gt; {
            if (vkPopup != null) {
                vkPopup.setY(winY.get());
            }
        });
    }

    private static void startSlideIn() {
        slideOutTimeline.stop();
        slideInTimeline.playFromStart();
    }

    private static void startSlideOut(boolean doHide) {
        hideAfterSlideOut = doHide;
        slideInTimeline.stop();
        slideOutTimeline.playFromStart();
    }

    private void adjustWindowPosition(final Node node) {
        if ( !(node instanceof TextInputControl) ) {
            return;
        }

        // attached node y position in window coordinates
        double inputControlMinY = node.localToScene(0.0, 0.0).getY() + node.getScene().getY();
        double inputControlHeight = ((TextInputControl) node).getHeight();
        double inputControlMaxY = inputControlMinY + inputControlHeight;

        double screenHeight =
            com.sun.javafx.util.Utils.getScreen(node).getBounds().getHeight();
        double visibleAreaMaxY = screenHeight - VK_HEIGHT;

        double inputLineCenterY = 0.0;
        double inputLineBottomY = 0.0;
        double newWindowYPos = 0.0;
        double screenTopOffset = 10.0;

        if (node instanceof TextField) {
            inputLineCenterY = inputControlMinY + inputControlHeight / 2;
            inputLineBottomY = inputControlMaxY;
            //check for combo box
            Parent parent = attachedNode.getParent();
            if (parent instanceof ComboBoxBase) {
                //combo box
                // position near screen top
                newWindowYPos = Math.min(screenTopOffset - inputControlMinY, 0);
            } else {
                // position at center of visible screen area
                newWindowYPos = Math.min(visibleAreaMaxY / 2 - inputLineCenterY, 0);
            }
        } else if (node instanceof TextArea) {
            TextAreaSkin textAreaSkin = (TextAreaSkin)((TextArea)node).getSkin();
            Bounds caretBounds = textAreaSkin.getCaretBounds();
            double caretMinY = caretBounds.getMinY();
            double caretMaxY = caretBounds.getMaxY();
            inputLineCenterY = inputControlMinY + ( caretMinY + caretMaxY ) / 2;
            inputLineBottomY = inputControlMinY + caretMaxY;

            if (inputControlHeight &lt; visibleAreaMaxY) {
                // position at center of visible screen area
                newWindowYPos = visibleAreaMaxY / 2 - (inputControlMinY + inputControlHeight / 2);
            } else {
                // position the line containing the caret at center of visible screen area
                newWindowYPos = visibleAreaMaxY / 2 - inputLineCenterY;
            }
            newWindowYPos = Math.min(newWindowYPos, 0);

        } else {
            inputLineCenterY = inputControlMinY + inputControlHeight / 2;
            inputLineBottomY = inputControlMaxY;
            // position at center of visible screen area
            newWindowYPos = Math.min(visibleAreaMaxY / 2 - inputLineCenterY, 0);
        }

        Window w = node.getScene().getWindow();
        if (origWindowYPos + inputLineBottomY &gt; visibleAreaMaxY) {
            w.setY(newWindowYPos);
        } else {
            w.setY(origWindowYPos);
        }
    }

    private void saveWindowPosition(final Node node) {
        Window w = node.getScene().getWindow();
        origWindowYPos = w.getY();
    }

    private void restoreWindowPosition(final Node node) {
        if (node != null) {
            Scene scene = node.getScene();
            if (scene != null) {
                Window window = scene.getWindow();
                if (window != null) {
                    window.setY(origWindowYPos);
                }
            }
        }
    }

    EventHandler&lt;InputEvent&gt; unHideEventHandler;

    private boolean isVKHidden = false;
    private Double origWindowYPos = null;

    private void registerUnhideHandler(final Node node) {
        if (unHideEventHandler == null) {
            unHideEventHandler = event -&gt; {
                if (attachedNode != null &amp;&amp; isVKHidden) {
                    double screenHeight = com.sun.javafx.util.Utils.getScreen(attachedNode).getBounds().getHeight();
                    if (fxvk.getHeight() &gt; 0 &amp;&amp; (vkPopup.getY() &gt; screenHeight - fxvk.getHeight())) {
                        if (slideInTimeline.getStatus() != Animation.Status.RUNNING) {
                            startSlideIn();
                            if (vkAdjustWindow) {
                                adjustWindowPosition(attachedNode);
                            }
                        }
                    }
                }
                isVKHidden = false;
            };
        }
        node.addEventHandler(TOUCH_PRESSED, unHideEventHandler);
        node.addEventHandler(MOUSE_PRESSED, unHideEventHandler);
    }

    private void unRegisterUnhideHandler(Node node) {
        if (unHideEventHandler != null) {
            node.removeEventHandler(TOUCH_PRESSED, unHideEventHandler);
            node.removeEventHandler(MOUSE_PRESSED, unHideEventHandler);
        }
    }

    private String getNodeVKType(Node node) {
        Integer vkType = (Integer)node.getProperties().get(FXVK.VK_TYPE_PROP_KEY);
        String typeStr = null;
        if (vkType != null) {
            Object typeValue = FXVK.VK_TYPE_NAMES[vkType];
            if (typeValue instanceof String) {
                typeStr = ((String)typeValue).toLowerCase(Locale.ROOT);
            }
        }
        return (typeStr != null ? typeStr : &quot;text&quot;);
    }

    private void updateKeyboardType(Node node) {
        String oldType = vkType;
        vkType = getNodeVKType(node);
        //VK type changed, rebuild
        if ( oldType == null || !vkType.equals(oldType) ) {
            rebuildPrimaryVK(vkType);
        }
    }

    private void closeSecondaryVK() {
        if (secondaryVK != null) {
            secondaryVK.setAttachedNode(null);
            secondaryPopup.hide();
        }
    }

    private void setupPrimaryVK() {
        fxvk.setFocusTraversable(false);
        fxvk.setVisible(true);

        // init popup window and slide animations
        if (vkPopup == null) {
            vkPopup = new Popup();
            vkPopup.setAutoFix(false);
        }
        vkPopup.getContent().setAll(fxvk);

        double screenHeight =
            com.sun.javafx.util.Utils.getScreen(fxvk).getBounds().getHeight();
        double width = com.sun.javafx.util.Utils.getScreen(fxvk).getBounds().getWidth();

        //Setup VK slide animations
        slideInTimeline.getKeyFrames().setAll(
            new KeyFrame(Duration.millis(VK_SLIDE_MILLIS),
                         new KeyValue(winY, screenHeight - VK_HEIGHT,
                                      Interpolator.EASE_BOTH)));
        slideOutTimeline.getKeyFrames().setAll(
            new KeyFrame(Duration.millis(VK_SLIDE_MILLIS),
                    event -&gt; {
                        if (hideAfterSlideOut &amp;&amp; vkPopup.isShowing()) {
                            vkPopup.hide();
                        }
                    },
                new KeyValue(winY, screenHeight, Interpolator.EASE_BOTH)));

        //Set VK size
        fxvk.setPrefWidth(width);
        fxvk.setMinWidth(USE_PREF_SIZE);
        fxvk.setMaxWidth(USE_PREF_SIZE);

        fxvk.setPrefHeight(VK_HEIGHT);
        fxvk.setMinHeight(USE_PREF_SIZE);


        //set up long-press triger for secondary VK
        if (secondaryVKDelay == null) {
            secondaryVKDelay = new Timeline();
        }
        KeyFrame kf = new KeyFrame(Duration.millis(500), event -&gt; {
            if (secondaryVKKey != null) {
                showSecondaryVK(secondaryVKKey);
            }
        });
        secondaryVKDelay.getKeyFrames().setAll(kf);

        //Setup key repeat animations
        if (KEY_REPEAT_RATE &gt; 0) {
            repeatInitialDelay = new Timeline(new KeyFrame(
                    Duration.millis(KEY_REPEAT_DELAY),
                    event -&gt; {
                        //fire current key
                        repeatKey.sendKeyEvents();
                        //Start repeat animation
                        repeatSubsequentDelay.playFromStart();
                    }
            ));
            repeatSubsequentDelay = new Timeline(new KeyFrame(
                    Duration.millis(1000.0 / KEY_REPEAT_RATE),
                    event -&gt; {
                        //fire current key
                        repeatKey.sendKeyEvents();
                    }
            ));
            repeatSubsequentDelay.setCycleCount(Animation.INDEFINITE);
        }
    }

    void prerender(Node node) {
        if (fxvk != primaryVK) {
            return;
        }

        //Preload all boards
        loadBoard(&quot;text&quot;);
        loadBoard(&quot;numeric&quot;);
        loadBoard(&quot;url&quot;);
        loadBoard(&quot;email&quot;);

        updateKeyboardType(node);
        fxvk.setVisible(true);

        if (!vkPopup.isShowing()) {
            Rectangle2D screenBounds =
                com.sun.javafx.util.Utils.getScreen(node).getBounds();

            vkPopup.setX((screenBounds.getWidth() - fxvk.prefWidth(-1)) / 2);
            winY.set(screenBounds.getHeight());
            vkPopup.show(node.getScene().getWindow());
        }
    }

    public FXVKSkin(final FXVK fxvk) {
        super(fxvk);
        this.fxvk = fxvk;
        if (fxvk == FXVK.vk) {
            primaryVK = fxvk;
        }

        if (fxvk == primaryVK) {
            setupPrimaryVK();
        }

        fxvk.attachedNodeProperty().addListener(new InvalidationListener() {
            @Override public void invalidated(Observable valueModel) {
                Node oldNode = attachedNode;
                attachedNode = fxvk.getAttachedNode();
                if (fxvk != primaryVK) {
                    return;
                }

                closeSecondaryVK();

                if (attachedNode != null) {
                    if (oldNode != null) {
                        unRegisterUnhideHandler(oldNode);
                    }
                    registerUnhideHandler(attachedNode);
                    updateKeyboardType(attachedNode);

                    //owner window has changed so hide VK and show with new owner
                    if (oldNode == null || oldNode.getScene() == null || oldNode.getScene().getWindow() != attachedNode.getScene().getWindow()) {
                        if (vkPopup.isShowing()) {
                            vkPopup.hide();
                        } else {
                        }
                    }

                    if (!vkPopup.isShowing()) {
                        Rectangle2D screenBounds =
                            com.sun.javafx.util.Utils.getScreen(attachedNode).getBounds();

                        vkPopup.setX((screenBounds.getWidth() - fxvk.prefWidth(-1)) / 2);
                        if (oldNode == null || isVKHidden) {
                            //position off screen
                            winY.set(screenBounds.getHeight());
                        } else {
                            //position on screen (no slide in)
                            winY.set(screenBounds.getHeight() - VK_HEIGHT);
                        }
                        vkPopup.show(attachedNode.getScene().getWindow());
                    }

                    if (oldNode == null || isVKHidden) {
                        startSlideIn();
                    }

                    if (vkAdjustWindow) {
                        //update previous window position only if moving from non-input control node or window has changed.
                        if (oldNode == null || oldNode.getScene() == null
                            || oldNode.getScene().getWindow() != attachedNode.getScene().getWindow()) {
                            saveWindowPosition(attachedNode);
                        }
                        // Move window containing input node
                        adjustWindowPosition(attachedNode);
                    }
                } else { // attachedNode == null
                    if (oldNode != null) {
                        unRegisterUnhideHandler(oldNode);
                    }
                    startSlideOut(true);
                    // Restore window position
                    if (vkAdjustWindow) {
                        restoreWindowPosition(oldNode);
                    }
                }
                isVKHidden = false;
            }
        });
    }

    /**
     * builds secondary (long-press) VK
     */
    private void rebuildSecondaryVK() {
        if (secondaryVK.chars == null) {
        } else {
            int nKeys = secondaryVK.chars.length;
            int nRows = (int)Math.floor(Math.sqrt(Math.max(1, nKeys - 2)));
            int nKeysPerRow = (int)Math.ceil(nKeys / (double)nRows);

            Key tmpKey;
            List&lt;List&lt;Key&gt;&gt; rows = new ArrayList&lt;List&lt;Key&gt;&gt;(2);

            for (int i = 0; i &lt; nRows; i++) {
                int start = i * nKeysPerRow;
                int end = Math.min(start + nKeysPerRow, nKeys);
                if (start &gt;= end)
                    break;

                List&lt;Key&gt; keys = new ArrayList&lt;Key&gt;(nKeysPerRow);
                for (int j = start; j &lt; end; j++) {
                    tmpKey = new CharKey(secondaryVK.chars[j], null, null);
                    tmpKey.col= (j - start) * 2;
                    tmpKey.colSpan = 2;
                    for (String sc : tmpKey.getStyleClass()) {
                        tmpKey.text.getStyleClass().add(sc + &quot;-text&quot;);
                        tmpKey.altText.getStyleClass().add(sc + &quot;-alttext&quot;);
                        tmpKey.icon.getStyleClass().add(sc + &quot;-icon&quot;);
                    }
                    if (secondaryVK.chars[j] != null &amp;&amp; secondaryVK.chars[j].length() &gt; 1) {
                        tmpKey.text.getStyleClass().add(&quot;multi-char-text&quot;);
                    }
                    keys.add(tmpKey);
                }
                rows.add(keys);
            }
            currentBoard = rows;

            getChildren().clear();
            numCols = 0;
            for (List&lt;Key&gt; row : currentBoard) {
                for (Key key : row) {
                    numCols = Math.max(numCols, key.col + key.colSpan);
                }
                getChildren().addAll(row);
            }
        }
    }

    /**
     * builds primary VK based on the keyboard
     * type set on the VirtualKeyboard.
     */
    private void rebuildPrimaryVK(String type) {
        currentBoard = loadBoard(type);

        //Clear all state keys and updates current board
        clearStateKeys();

        getChildren().clear();
        numCols = 0;
        for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {
                numCols = Math.max(numCols, key.col + key.colSpan);
            }
            getChildren().addAll(row);
        }
    }

    // This skin is designed such that it gives equal widths to all columns. So
    // the pref width is just some hard-coded value (although I could have maybe
    // done it based on the pref width of a text node with the right font).
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return leftInset + (56 * numCols) + rightInset;
    }

    // Pref height is just some value. This isn't overly important.
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return topInset + (80 * 5) + bottomInset;
    }

    // Lays the buttons comprising the current keyboard out.
    @Override
    protected void layoutChildren(double contentX, double contentY, double contentWidth, double contentHeight) {
        // I have fixed width columns, all the same.
        int numRows = currentBoard.size();
        final double colWidth = ((contentWidth - ((numCols - 1) * GAP)) / numCols);
        double rowHeight = ((contentHeight - ((numRows - 1) * GAP)) / numRows);
        double rowY = contentY;
        for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {
                double startX = contentX + (key.col * (colWidth + GAP));
                double width = (key.colSpan * (colWidth + GAP)) - GAP;
                key.resizeRelocate((int)(startX + .5), (int)(rowY + .5),
                                   width, rowHeight);
            }
            rowY += rowHeight + GAP;
        }
    }


    /**
     * A Key on the virtual keyboard. This is simply a Region. Some information
     * about the key relative to other keys on the layout is given by the col
     * and colSpan fields.
     */
    private class Key extends Region {
        int col = 0;
        int colSpan = 1;
        protected final Text text;
        protected final Text altText;
        protected final Region icon;

        protected Key() {
            icon = new Region();
            text = new Text();
            text.setTextOrigin(VPos.TOP);
            altText = new Text();
            altText.setTextOrigin(VPos.TOP);
            getChildren().setAll(text, altText, icon);
            getStyleClass().setAll(&quot;key&quot;);
            addEventHandler(MouseEvent.MOUSE_PRESSED, event -&gt; {
                if (event.getButton() == MouseButton.PRIMARY)
                    press();
            });
            addEventHandler(MouseEvent.MOUSE_RELEASED, event -&gt; {
                if (event.getButton() == MouseButton.PRIMARY)
                    release();
            });
        }
        protected void press() { }
        protected void release() {
            clearShift();
        }

        public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) { }

        @Override protected void layoutChildren() {
            final double left = snappedLeftInset();
            final double top = snappedTopInset();
            final double width = getWidth() - left - snappedRightInset();
            final double height = getHeight() - top - snappedBottomInset();

            text.setVisible(icon.getBackground() == null);
            double contentPrefWidth = text.prefWidth(-1);
            double contentPrefHeight = text.prefHeight(-1);
            text.resizeRelocate(
                    (int) (left + ((width - contentPrefWidth) / 2) + .5),
                    (int) (top + ((height - contentPrefHeight) / 2) + .5),
                    (int) contentPrefWidth,
                    (int) contentPrefHeight);

            altText.setVisible(icon.getBackground() == null &amp;&amp; altText.getText().length() &gt; 0);
            contentPrefWidth = altText.prefWidth(-1);
            contentPrefHeight = altText.prefHeight(-1);
            altText.resizeRelocate(
                    (int) left + (width - contentPrefWidth) + .5,
                    (int) (top + ((height - contentPrefHeight) / 2) + .5 - height/2),
                    (int) contentPrefWidth,
                    (int) contentPrefHeight);

            icon.resizeRelocate(left-8, top-8, width+16, height+16);
        }

    }

    /**
     * Any key on the keyboard which will send a KeyEvent to the client. This
     * class just maintains the state and logic for firing an event, using the
     * &quot;chars&quot; and &quot;code&quot; as the values sent in the event. A subclass must set
     * these appropriately.
     */
    private class TextInputKey extends Key {
        String chars = &quot;&quot;;

        protected void press() {
        }
        protected void release() {
            if (fxvk != secondaryVK &amp;&amp; secondaryPopup != null &amp;&amp; secondaryPopup.isShowing()) {
                return;
            }
            sendKeyEvents();
            if (fxvk == secondaryVK) {
                showSecondaryVK(null);
            }
            super.release();
        }

        protected void sendKeyEvents() {
            Node target = fxvk.getAttachedNode();
            if (target instanceof EventTarget) {
                if (chars != null) {
                    target.fireEvent(new KeyEvent(KeyEvent.KEY_TYPED, chars, &quot;&quot;, KeyCode.UNDEFINED, shiftDown, false, false, false));
                }
            }
        }
    }

    /**
     * A key which has a letter, a number or symbol on it
     *
     */
    private class CharKey extends TextInputKey {
        private final String letterChars;
        private final String altChars;
        private final String[] moreChars;

        private CharKey(String letter, String alt, String[] moreChars, String id) {
            this.letterChars = letter;
            this.altChars = alt;
            this.moreChars = moreChars;
            this.chars = this.letterChars;

            text.setText(this.chars);
            altText.setText(this.altChars);
            if (vkLookup) {
                setId((id != null ? id : chars).replaceAll(&quot;\\.&quot;, &quot;&quot;));
            }
        }

        private CharKey(String letter, String alt, String[] moreChars) {
            this(letter, alt, moreChars, null);
        }

        protected void press() {
            super.press();
            if (letterChars.equals(altChars) &amp;&amp; moreChars == null) {
                return;
            }
            if (fxvk == primaryVK) {
                showSecondaryVK(null);
                secondaryVKKey = CharKey.this;
                secondaryVKDelay.playFromStart();
            }
        }

        protected void release() {
            super.release();
            if (letterChars.equals(altChars) &amp;&amp; moreChars == null) {
                return;
            }
            if (fxvk == primaryVK) {
                secondaryVKDelay.stop();
            }
        }

        @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
            if (isSymbol) {
                chars = altChars;
                text.setText(chars);
                if (moreChars != null &amp;&amp; moreChars.length &gt; 0 &amp;&amp; !Character.isLetter(moreChars[0].charAt(0))) {
                    altText.setText(moreChars[0]);
                } else {
                    altText.setText(null);
                }
            } else {
                chars = (capsDown || shiftDown) ? letterChars.toUpperCase() : letterChars.toLowerCase();
                text.setText(chars);
                altText.setText(altChars);
            }
        }
    }

    /**
     * One of several TextInputKeys which have super powers, such as &quot;Tab&quot; and
     * &quot;Return&quot; and &quot;Backspace&quot;. These keys still send events to the client,
     * but may also have additional state related functionality on the keyboard
     * such as the &quot;Shift&quot; key.
     */
    private class SuperKey extends TextInputKey {
        private SuperKey(String letter, String code) {
            this.chars = code;
            text.setText(letter);
            getStyleClass().add(&quot;special&quot;);
            if (vkLookup) {
                setId(letter);
            }
        }
    }

    /**
     * Some keys actually do need to use KeyCode for pressed / released events,
     * and BackSpace is one of them.
     */
    private class KeyCodeKey extends SuperKey {
        private KeyCode code;

        private KeyCodeKey(String letter, String c, KeyCode code) {
            super(letter, c);
            this.code = code;
            if (vkLookup) {
                setId(letter);
            }
        }

        protected void sendKeyEvents() {
            Node target = fxvk.getAttachedNode();
            if (target instanceof EventTarget) {
                target.fireEvent(new KeyEvent(KeyEvent.KEY_PRESSED, KeyEvent.CHAR_UNDEFINED, chars, code, shiftDown, false, false, false));
                target.fireEvent(new KeyEvent(KeyEvent.KEY_TYPED, chars, &quot;&quot;, KeyCode.UNDEFINED, shiftDown, false, false, false));
                target.fireEvent(new KeyEvent(KeyEvent.KEY_RELEASED, KeyEvent.CHAR_UNDEFINED, chars, code, shiftDown, false, false, false));
            }
        }
    }

    /**
     * These keys only manipulate the state of the keyboard and never
     * send key events to the client. For example, &quot;Hide&quot;, &quot;Caps Lock&quot;,
     * etc are all KeyboardStateKeys.
     */
    private class KeyboardStateKey extends Key {
        private final String defaultText;
        private final String toggledText;

        private KeyboardStateKey(String defaultText, String toggledText, String id) {
            this.defaultText = defaultText;
            this.toggledText = toggledText;
            text.setText(this.defaultText);
            if (vkLookup &amp;&amp; id != null) {
                setId(id);
            }
            getStyleClass().add(&quot;special&quot;);
        }

        @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
            //change icon

            if (isSymbol) {
                text.setText(this.toggledText);
            } else {
                text.setText(this.defaultText);
            }
        }
    }

    private void showSecondaryVK(final CharKey key) {
        if (key != null) {
            final Node textInput = primaryVK.getAttachedNode();

            if (secondaryVK == null) {
                secondaryVK = new FXVK();
                //secondaryVK.getStyleClass().addAll(&quot;fxvk-secondary&quot;, &quot;fxvk-portrait&quot;);
                secondaryVK.setSkin(new FXVKSkin(secondaryVK));
                secondaryVK.getStyleClass().setAll(&quot;fxvk-secondary&quot;);
                secondaryPopup = new Popup();
                secondaryPopup.setAutoHide(true);
                secondaryPopup.getContent().add(secondaryVK);
            }

            secondaryVK.chars=null;
            ArrayList&lt;String&gt; secondaryList = new ArrayList&lt;String&gt;();

            // Add primary character
            if (!isSymbol) {
                if (key.letterChars != null &amp;&amp; key.letterChars.length() &gt; 0) {
                    if (shiftDown || capsDown) {
                        secondaryList.add(key.letterChars.toUpperCase());
                    } else {
                        secondaryList.add(key.letterChars);
                    }
                }
            }

            // Add secondary character
            if (key.altChars != null &amp;&amp; key.altChars.length() &gt; 0) {
                if (shiftDown || capsDown) {
                    secondaryList.add(key.altChars.toUpperCase());
                } else {
                    secondaryList.add(key.altChars);
                }
            }

            // Add more letters
            if (key.moreChars != null &amp;&amp; key.moreChars.length &gt; 0) {
                if (isSymbol) {
                    //Add non-letters
                    for (String ch : key.moreChars) {
                        if (!Character.isLetter(ch.charAt(0))) {
                            secondaryList.add(ch);
                        }
                    }
                 } else {
                    //Add letters
                    for (String ch : key.moreChars) {
                        if (Character.isLetter(ch.charAt(0))) {
                            if (shiftDown || capsDown) {
                                secondaryList.add(ch.toUpperCase());
                            } else {
                                secondaryList.add(ch);
                            }
                        }
                    }
                }
            }

            boolean isMultiChar = false;
            for (String s : secondaryList) {
                if (s.length() &gt; 1 ) {
                    isMultiChar = true;
                }
            }

            secondaryVK.chars = secondaryList.toArray(new String[secondaryList.size()]);

            if (secondaryVK.chars.length &gt; 1) {
                if (secondaryVK.getSkin() != null) {
                    ((FXVKSkin)secondaryVK.getSkin()).rebuildSecondaryVK();
                }

                secondaryVK.setAttachedNode(textInput);
                FXVKSkin primarySkin = (FXVKSkin)primaryVK.getSkin();
                FXVKSkin secondarySkin = (FXVKSkin)secondaryVK.getSkin();
                //Insets insets = secondarySkin.getInsets();
                int nKeys = secondaryVK.chars.length;
                int nRows = (int)Math.floor(Math.sqrt(Math.max(1, nKeys - 2)));
                int nKeysPerRow = (int)Math.ceil(nKeys / (double)nRows);

                final double w = snappedLeftInset() + snappedRightInset() +
                                 nKeysPerRow * PREF_PORTRAIT_KEY_WIDTH * (isMultiChar ? 2 : 1) + (nKeysPerRow - 1) * GAP;
                final double h = snappedTopInset() + snappedBottomInset() +
                                 nRows * PREF_KEY_HEIGHT + (nRows-1) * GAP;

                secondaryVK.setPrefWidth(w);
                secondaryVK.setMinWidth(USE_PREF_SIZE);
                secondaryVK.setPrefHeight(h);
                secondaryVK.setMinHeight(USE_PREF_SIZE);
                Platform.runLater(() -&gt; {
                    // Position popup on screen
                    Point2D nodePoint =
                        com.sun.javafx.util.Utils.pointRelativeTo(key, w, h, HPos.CENTER, VPos.TOP,
                                                             5, -3, true);
                    double x = nodePoint.getX();
                    double y = nodePoint.getY();
                    Scene scene = key.getScene();
                    x = Math.min(x, scene.getWindow().getX() + scene.getWidth() - w);
                    secondaryPopup.show(key.getScene().getWindow(), x, y);
                });
            }
        } else {
            closeSecondaryVK();
        }
    }


    private List&lt;List&lt;Key&gt;&gt; loadBoard(String type) {
        List&lt;List&lt;Key&gt;&gt; tmpBoard = boardMap.get(type);
        if (tmpBoard != null) {
            return tmpBoard;
        }

        String boardFileName = type.substring(0,1).toUpperCase() + type.substring(1).toLowerCase() + &quot;Board.txt&quot;;
        try {
            tmpBoard = new ArrayList&lt;List&lt;Key&gt;&gt;(5);
            List&lt;Key&gt; keys = new ArrayList&lt;Key&gt;(20);

            InputStream boardFile = FXVKSkin.class.getResourceAsStream(boardFileName);
            BufferedReader reader = new BufferedReader(new InputStreamReader(boardFile, &quot;UTF-8&quot;));
            String line;
            // A pointer to the current column. This will be incremented for every string
            // of text, or space.
            int c = 0;
            // The col at which the key will be placed
            int col = 0;
            // The number of columns that the key will span
            int colSpan = 1;
            // Whether the &quot;chars&quot; is an identifier, like $shift or $SymbolBoard, etc.
            boolean identifier = false;
            // The textual content of the Key
            List&lt;String&gt; charsList = new ArrayList&lt;String&gt;(10);

            while ((line = reader.readLine()) != null) {
                if (line.length() == 0 || line.charAt(0) == '#') {
                    continue;
                }
                // A single line represents a single row of buttons
                for (int i=0; i&lt;line.length(); i++) {
                    char ch = line.charAt(i);

                    // Process the char
                    if (ch == ' ') {
                        c++;
                    } else if (ch == '[') {
                        // Start of a key
                        col = c;
                        charsList = new ArrayList&lt;String&gt;(10);
                        identifier = false;
                    } else if (ch == ']') {
                        String chars = &quot;&quot;;
                        String alt = null;
                        String[] moreChars = null;

                        for (int idx = 0; idx &lt; charsList.size(); idx++) {
                            charsList.set(idx, FXVKCharEntities.get(charsList.get(idx)));
                        }

                        int listSize = charsList.size();
                        if (listSize &gt; 0) {
                            chars = charsList.get(0);
                            if (listSize &gt; 1) {
                                alt = charsList.get(1);
                                if (listSize &gt; 2) {
                                    moreChars = charsList.subList(2, listSize).toArray(new String[listSize - 2]);
                                }
                            }
                        }

                        // End of a key
                        colSpan = c - col;
                        Key key;
                        if (identifier) {
                            if (&quot;$shift&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;&quot;, null, &quot;shift&quot;) {
                                    @Override protected void release() {
                                        pressShift();
                                    }

                                    @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
                                        if (isSymbol) {
                                            this.setDisable(true);
                                            this.setVisible(false);
                                        } else {
                                            if (capsDown) {
                                                icon.getStyleClass().remove(&quot;shift-icon&quot;);
                                                icon.getStyleClass().add(&quot;capslock-icon&quot;);
                                            } else {
                                                icon.getStyleClass().remove(&quot;capslock-icon&quot;);
                                                icon.getStyleClass().add(&quot;shift-icon&quot;);
                                            }
                                            this.setDisable(false);
                                            this.setVisible(true);
                                        }
                                    }
                                };
                                key.getStyleClass().add(&quot;shift&quot;);

                            } else if (&quot;$SymbolABC&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;!#123&quot;, &quot;ABC&quot;, &quot;symbol&quot;) {
                                    @Override protected void release() {
                                        pressSymbolABC();
                                    }
                                };
                            } else if (&quot;$backspace&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;backspace&quot;, &quot;\b&quot;, KeyCode.BACK_SPACE) {
                                    @Override protected void press() {
                                        if (KEY_REPEAT_RATE &gt; 0) {
                                            clearShift();
                                            sendKeyEvents();
                                            repeatKey = this;
                                            repeatInitialDelay.playFromStart();
                                        } else {
                                            super.press();
                                        }
                                    }
                                    @Override protected void release() {
                                        if (KEY_REPEAT_RATE &gt; 0) {
                                            repeatInitialDelay.stop();
                                            repeatSubsequentDelay.stop();
                                        } else {
                                            super.release();
                                        }
                                    }
                                };
                                key.getStyleClass().add(&quot;backspace&quot;);
                            } else if (&quot;$enter&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;enter&quot;, &quot;\n&quot;, KeyCode.ENTER);
                                key.getStyleClass().add(&quot;enter&quot;);
                            } else if (&quot;$tab&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;tab&quot;, &quot;\t&quot;, KeyCode.TAB);
                            } else if (&quot;$space&quot;.equals(chars)) {
                                key = new CharKey(&quot; &quot;, &quot; &quot;, null, &quot;space&quot;);
                            } else if (&quot;$clear&quot;.equals(chars)) {
                                key = new SuperKey(&quot;clear&quot;, &quot;&quot;);
                            } else if (&quot;$.org&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.org&quot;, &quot;.org&quot;);
                            } else if (&quot;$.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.com&quot;, &quot;.com&quot;);
                            } else if (&quot;$.net&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.net&quot;, &quot;.net&quot;);
                            } else if (&quot;$oracle.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;oracle.com&quot;, &quot;oracle.com&quot;);
                            } else if (&quot;$gmail.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;gmail.com&quot;, &quot;gmail.com&quot;);
                            } else if (&quot;$hide&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;hide&quot;, null, &quot;hide&quot;) {
                                    @Override protected void release() {
                                        isVKHidden = true;
                                        startSlideOut(false);
                                        // Restore window position
                                        if (vkAdjustWindow) {
                                            restoreWindowPosition(attachedNode);
                                        }
                                    }
                                };
                                key.getStyleClass().add(&quot;hide&quot;);
                            } else if (&quot;$undo&quot;.equals(chars)) {
                                key = new SuperKey(&quot;undo&quot;, &quot;&quot;);
                            } else if (&quot;$redo&quot;.equals(chars)) {
                                key = new SuperKey(&quot;redo&quot;, &quot;&quot;);
                            } else {
                                //Unknown Key
                                key = null;
                            }
                        } else {
                            key = new CharKey(chars, alt, moreChars);
                        }
                        if (key != null) {
                            key.col = col;
                            key.colSpan = colSpan;
                            for (String sc : key.getStyleClass()) {
                                key.text.getStyleClass().add(sc + &quot;-text&quot;);
                                key.altText.getStyleClass().add(sc + &quot;-alttext&quot;);
                                key.icon.getStyleClass().add(sc + &quot;-icon&quot;);
                            }
                            if (chars != null &amp;&amp; chars.length() &gt; 1) {
                                key.text.getStyleClass().add(&quot;multi-char-text&quot;);
                            }
                            if (alt != null &amp;&amp; alt.length() &gt; 1) {
                                key.altText.getStyleClass().add(&quot;multi-char-text&quot;);
                            }

                            keys.add(key);
                        }
                    } else {
                        // Normal textual characters. Read all the way up to the
                        // next ] or space
                        for (int j=i; j&lt;line.length(); j++) {
                            char c2 = line.charAt(j);
                            boolean e = false;
                            if (c2 == '\\') {
                                j++;
                                i++;
                                e = true;
                                c2 = line.charAt(j);
                            }

                            if (c2 == '$' &amp;&amp; !e) {
                                identifier = true;
                            }

                            if (c2 == '|' &amp;&amp; !e) {
                                charsList.add(line.substring(i, j));
                                i = j + 1;
                            } else if ((c2 == ']' || c2 == ' ') &amp;&amp; !e) {
                                charsList.add(line.substring(i, j));
                                i = j-1;
                                break;
                            }
                        }
                        c++;
                    }
                }

                c = 0;
                col = 0;
                tmpBoard.add(keys);
                keys = new ArrayList&lt;Key&gt;(20);
            }
            reader.close();
            boardMap.put(type, tmpBoard);
            return tmpBoard;
        } catch (Exception e) {
            e.printStackTrace();
            return Collections.emptyList();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/PieChart.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;

import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

import javafx.animation.Animation;
import javafx.animation.FadeTransition;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.binding.StringBinding;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.property.StringPropertyBase;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Side;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.layout.Region;
import javafx.scene.shape.Arc;
import javafx.scene.shape.ArcTo;
import javafx.scene.shape.ArcType;
<A NAME="0"></A>import javafx.scene.shape.ClosePath;
import javafx.scene.shape.LineTo;
import javafx.scene.shape.MoveTo;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#0',2,'match52-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import javafx.scene.shape.Path;
import javafx.scene.text.Text;
import javafx.scene.transform.Scale;
import javafx.util.Duration;

import com.sun.javafx.charts.Legend;
import com.sun.javafx.charts.Legend.LegendItem;
import com.sun.javafx.collections.NonIterableChange;

import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.CssMetaData;

import javafx.css.converter.BooleanConverter;
import javafx.css.converter.SizeConverter;

import javafx.css.Styleable;
import javafx.css.StyleableProperty;

/**
 * Displays a PieChart. The chart content is populated by pie slices based on
 * data set on the PieChart.
 * &lt;p&gt; The clockwise property is set to true by default, which means slices are
 * placed in the clockwise order. The labelsVisible property is used to either display
 * pie slice labels or not.
 *
 * @since JavaFX 2.0
 */
public class PieChart extends Chart {

    // -------------- PRIVATE FIELDS -----------------------------------------------------------------------------------
    private static final int MIN_PIE_RADIUS = 25;
    private static final double LABEL_TICK_GAP = 6;
    private static final double LABEL_BALL_RADIUS = 2;
    private BitSet colorBits = new BitSet(8);
    private double pieRadius</B></FONT>;
    private Data begin = null;
    private final Path labelLinePath = new Path() {
        @Override public boolean usesMirroring() {
            return false;
        }
    };
    private List&lt;LabelLayoutInfo&gt; labelLayoutInfos = null;
    private Legend legend = new Legend();
    private Data dataItemBeingRemoved = null;
    private Timeline dataRemoveTimeline = null;
    private final ListChangeListener&lt;Data&gt; dataChangeListener = c -&gt; {
        while (c.next()) {
            // RT-28090 Probably a sort happened, just reorder the pointers.
            if (c.wasPermutated()) {
                Data ptr = begin;
                for (int i = 0; i &lt; getData().size(); i++) {
                    Data item = getData().get(i);
                    updateDataItemStyleClass(item, i);
                    if (i == 0) {
                        begin = item;
                        ptr = begin;
                        begin.next = null;
                    } else {
                        ptr.next = item;
                        item.next = null;
                        ptr = item;
                    }
                }
                updateLegend();
                requestChartLayout();
                return;
            }
            // recreate linked list &amp; set chart on new data
            for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                Data item = getData().get(i);
                item.setChart(PieChart.this);
                if (begin == null) {
                    begin = item;
                    begin.next = null;
                } else {
                    if (i == 0) {
                        item.next = begin;
                        begin = item;
                    } else {
                        Data ptr = begin;
                        for (int j = 0; j &lt; i -1 ; j++) {
                            ptr = ptr.next;
                        }
                        item.next = ptr.next;
                        ptr.next = item;
                    }
                }
            }
            // call data added/removed methods
            for (Data item : c.getRemoved()) {
                dataItemRemoved(item);
            }
            for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                Data item = getData().get(i);
                // assign default color to the added slice
                // TODO: check nearby colors
                item.defaultColorIndex = colorBits.nextClearBit(0);
                colorBits.set(item.defaultColorIndex);
                dataItemAdded(item, i);
            }
            if (c.wasRemoved() || c.wasAdded()) {
                for (int i = 0; i &lt; getData().size(); i++) {
                    Data item = getData().get(i);
                    updateDataItemStyleClass(item, i);
                }
                updateLegend();
            }
        }
        // re-layout everything
        requestChartLayout();
    };

    // -------------- PUBLIC PROPERTIES ----------------------------------------

    /** PieCharts data */
    private ObjectProperty&lt;ObservableList&lt;Data&gt;&gt; data = new ObjectPropertyBase&lt;ObservableList&lt;Data&gt;&gt;() {
        private ObservableList&lt;Data&gt; old;
        @Override protected void invalidated() {
            final ObservableList&lt;Data&gt; current = getValue();
            // add remove listeners
            if(old != null) old.removeListener(dataChangeListener);
            if(current != null) current.addListener(dataChangeListener);
            // fire data change event if series are added or removed
            if(old != null || current != null) {
                final List&lt;Data&gt; removed = (old != null) ? old : Collections.&lt;Data&gt;emptyList();
                final int toIndex = (current != null) ? current.size() : 0;
                // let data listener know all old data have been removed and new data that has been added
                if (toIndex &gt; 0 || !removed.isEmpty()) {
                    dataChangeListener.onChanged(new NonIterableChange&lt;Data&gt;(0, toIndex, current){
                        @Override public List&lt;Data&gt; getRemoved() { return removed; }
                        @Override public boolean wasPermutated() { return false; }
                        @Override protected int[] getPermutation() {
                            return new int[0];
                        }
                    });
                }
            } else if (old != null &amp;&amp; old.size() &gt; 0) {
                // let series listener know all old series have been removed
                dataChangeListener.onChanged(new NonIterableChange&lt;Data&gt;(0, 0, current){
                    @Override public List&lt;Data&gt; getRemoved() { return old; }
                    @Override public boolean wasPermutated() { return false; }
                    @Override protected int[] getPermutation() {
                        return new int[0];
                    }
                });
            }
            old = current;
        }

        public Object getBean() {
            return PieChart.this;
        }

        public String getName() {
            return &quot;data&quot;;
        }
    };
    public final ObservableList&lt;Data&gt; getData() { return data.getValue(); }
    public final void setData(ObservableList&lt;Data&gt; value) { data.setValue(value); }
    public final ObjectProperty&lt;ObservableList&lt;Data&gt;&gt; dataProperty() { return data; }

    /** The angle to start the first pie slice at */
    private DoubleProperty startAngle = new StyleableDoubleProperty(0) {
        @Override public void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return PieChart.this;
        }

        @Override
        public String getName() {
            return &quot;startAngle&quot;;
        }

        public CssMetaData&lt;PieChart,Number&gt; getCssMetaData() {
            return StyleableProperties.START_ANGLE;
        }
    };
    public final double getStartAngle() { return startAngle.getValue(); }
    public final void setStartAngle(double value) { startAngle.setValue(value); }
    public final DoubleProperty startAngleProperty() { return startAngle; }

    /** When true we start placing slices clockwise from the startAngle */
    private BooleanProperty clockwise = new StyleableBooleanProperty(true) {
        @Override public void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return PieChart.this;
        }

        @Override
        public String getName() {
            return &quot;clockwise&quot;;
        }

        public CssMetaData&lt;PieChart,Boolean&gt; getCssMetaData() {
            return StyleableProperties.CLOCKWISE;
        }
    };
    public final void setClockwise(boolean value) { clockwise.setValue(value);}
    public final boolean isClockwise() { return clockwise.getValue(); }
    public final BooleanProperty clockwiseProperty() { return clockwise; }


    /** The length of the line from the outside of the pie to the slice labels. */
    private DoubleProperty labelLineLength = new StyleableDoubleProperty(20d) {
        @Override public void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return PieChart.this;
        }

        @Override
        public String getName() {
            return &quot;labelLineLength&quot;;
        }

        public CssMetaData&lt;PieChart,Number&gt; getCssMetaData() {
            return StyleableProperties.LABEL_LINE_LENGTH;
        }
    };
    public final double getLabelLineLength() { return labelLineLength.getValue(); }
    public final void setLabelLineLength(double value) { labelLineLength.setValue(value); }
    public final DoubleProperty labelLineLengthProperty() { return labelLineLength; }

    /** When true pie slice labels are drawn */
    private BooleanProperty labelsVisible = new StyleableBooleanProperty(true) {
        @Override public void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return PieChart.this;
        }

        @Override
        public String getName() {
            return &quot;labelsVisible&quot;;
        }

        public CssMetaData&lt;PieChart,Boolean&gt; getCssMetaData() {
            return StyleableProperties.LABELS_VISIBLE;
        }
    };
    public final void setLabelsVisible(boolean value) { labelsVisible.setValue(value);}

    /**
     * Indicates whether pie slice labels are drawn or not
     * @return true if pie slice labels are visible and false otherwise.
     */
    public final boolean getLabelsVisible() { return labelsVisible.getValue(); }
    public final BooleanProperty labelsVisibleProperty() { return labelsVisible; }

    // -------------- CONSTRUCTOR ----------------------------------------------

    /**
     * Construct a new empty PieChart.
     */
    public PieChart() {
        this(FXCollections.&lt;Data&gt;observableArrayList());
    }

    /**
     * Construct a new PieChart with the given data
     *
     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart
     */
    public PieChart(ObservableList&lt;PieChart.Data&gt; data) {
        getChartChildren().add(labelLinePath);
        labelLinePath.getStyleClass().add(&quot;chart-pie-label-line&quot;);
        setLegend(legend);
        setData(data);
        // set chart content mirroring to be always false i.e. chartContent mirrorring is not done
        // when  node orientation is right-to-left for PieChart.
        useChartContentMirroring = false;
    }

    // -------------- METHODS --------------------------------------------------

    private void dataNameChanged(Data item) {
        item.textNode.setText(item.getName());
        requestChartLayout();
        updateLegend();
    }

    private void dataPieValueChanged(Data item) {
        if (shouldAnimate()) {
            animate(
                new KeyFrame(Duration.ZERO, new KeyValue(item.currentPieValueProperty(),
                        item.getCurrentPieValue())),
                new KeyFrame(Duration.millis(500),new KeyValue(item.currentPieValueProperty(),
                        item.getPieValue(), Interpolator.EASE_BOTH))
            );
        } else {
            item.setCurrentPieValue(item.getPieValue());
            requestChartLayout(); // RT-23091
        }
    }

    private Node createArcRegion(Data item) {
        Node arcRegion = item.getNode();
        // check if symbol has already been created
        if (arcRegion == null) {
            arcRegion = new Region();
            arcRegion.setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
            arcRegion.setPickOnBounds(false);
            item.setNode(arcRegion);
        }
        return arcRegion;
    }

    private Text createPieLabel(Data item) {
        Text text = item.textNode;
        text.setText(item.getName());
        return text;
    }

    private void updateDataItemStyleClass(final Data item, int index) {
        Node node = item.getNode();
        if (node != null) {
            // Note: not sure if we want to add or check, ie be more careful and efficient here
            node.getStyleClass().setAll(&quot;chart-pie&quot;, &quot;data&quot; + index,
                    &quot;default-color&quot; + item.defaultColorIndex % 8);
            if (item.getPieValue() &lt; 0) {
                node.getStyleClass().add(&quot;negative&quot;);
            }
        }
    }

    private void dataItemAdded(final Data item, int index) {
        // create shape
        Node shape = createArcRegion(item);
        final Text text = createPieLabel(item);
        item.getChart().getChartChildren().add(shape);
        if (shouldAnimate()) {
            // if the same data item is being removed, first stop the remove animation,
            // remove the item and then start the add animation.
            if (dataRemoveTimeline != null &amp;&amp; dataRemoveTimeline.getStatus().equals(Animation.Status.RUNNING)) {
                if (dataItemBeingRemoved == item) {
                    dataRemoveTimeline.stop();
                    dataRemoveTimeline = null;
                    getChartChildren().remove(item.textNode);
                    getChartChildren().remove(shape);
                    removeDataItemRef(item);
                }
            }
            animate(
                new KeyFrame(Duration.ZERO,
                    new KeyValue(item.currentPieValueProperty(), item.getCurrentPieValue()),
                    new KeyValue(item.radiusMultiplierProperty(), item.getRadiusMultiplier())),
                new KeyFrame(Duration.millis(500),
                        actionEvent -&gt; {
                            text.setOpacity(0);
                            // RT-23597 : item's chart might have been set to null if
                            // this item is added and removed before its add animation finishes.
                            if (item.getChart() == null) item.setChart(PieChart.this);
                            item.getChart().getChartChildren().add(text);
                            FadeTransition ft = new FadeTransition(Duration.millis(150),text);
                            ft.setToValue(1);
                            ft.play();
                        },
                    new KeyValue(item.currentPieValueProperty(), item.getPieValue(), Interpolator.EASE_BOTH),
                    new KeyValue(item.radiusMultiplierProperty(), 1, Interpolator.EASE_BOTH))
            );
        } else {
            getChartChildren().add(text);
            item.setRadiusMultiplier(1);
            item.setCurrentPieValue(item.getPieValue());
        }

        // we sort the text nodes to always be at the end of the children list, so they have a higher z-order
        // (Fix for RT-34564)
        for (int i = 0; i &lt; getChartChildren().size(); i++) {
            Node n = getChartChildren().get(i);
            if (n instanceof Text) {
                n.toFront();
            }
        }
    }

    private void removeDataItemRef(Data item) {
        if (begin == item) {
            begin = item.next;
        } else {
            Data ptr = begin;
            while(ptr != null &amp;&amp; ptr.next != item) {
                ptr = ptr.next;
            }
            if(ptr != null) ptr.next = item.next;
        }
    }

    private Timeline createDataRemoveTimeline(final Data item) {
        final Node shape = item.getNode();
        Timeline t = new Timeline();
        t.getKeyFrames().addAll(new KeyFrame(Duration.ZERO,
                    new KeyValue(item.currentPieValueProperty(), item.getCurrentPieValue()),
                    new KeyValue(item.radiusMultiplierProperty(), item.getRadiusMultiplier())),
                new KeyFrame(Duration.millis(500),
                        actionEvent -&gt; {
                            // removing item
                            colorBits.clear(item.defaultColorIndex);
                            getChartChildren().remove(shape);
                            // fade out label
                            FadeTransition ft = new FadeTransition(Duration.millis(150),item.textNode);
                            ft.setFromValue(1);
                            ft.setToValue(0);
                            ft.setOnFinished(new EventHandler&lt;ActionEvent&gt;() {
                                 @Override public void handle(ActionEvent actionEvent) {
                                     getChartChildren().remove(item.textNode);
                                     // remove chart references from old data - RT-22553
                                     item.setChart(null);
                                     removeDataItemRef(item);
                                     item.textNode.setOpacity(1.0);
                                 }
                            });
                            ft.play();
                        },
                    new KeyValue(item.currentPieValueProperty(), 0, Interpolator.EASE_BOTH),
                    new KeyValue(item.radiusMultiplierProperty(), 0))
                );
        return t;
    }

    private void dataItemRemoved(final Data item) {
        final Node shape = item.getNode();
        if (shouldAnimate()) {
            dataRemoveTimeline = createDataRemoveTimeline(item);
            dataItemBeingRemoved = item;
            animate(dataRemoveTimeline);
        } else {
            colorBits.clear(item.defaultColorIndex);
            getChartChildren().remove(item.textNode);
            getChartChildren().remove(shape);
            // remove chart references from old data
            item.setChart(null);
            removeDataItemRef(item);
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutChartChildren(double top, double left, double contentWidth, double contentHeight) {
        double total = 0.0;
        for (Data item = begin; item != null; item = item.next) {
            total+= Math.abs(item.getCurrentPieValue());
        }
        double scale = (total != 0) ? 360 / total : 0;

         // calculate combined bounds of all labels &amp; pie radius
        double[] labelsX = null;
        double[] labelsY = null;
        double[] labelAngles = null;
        double labelScale = 1;
        List&lt;LabelLayoutInfo&gt; fullPie = null;
        boolean shouldShowLabels = getLabelsVisible();
        if (shouldShowLabels) {
            double xPad = 0d;
            double yPad = 0d;

            labelsX = new double[getDataSize()];
            labelsY = new double[getDataSize()];
            labelAngles = new double[getDataSize()];
            fullPie = new ArrayList&lt;&gt;();
            int index = 0;
            double start = getStartAngle();
            for (Data item = begin; item != null; item = item.next) {
                // remove any scale on the text node
                item.textNode.getTransforms().clear();

                double size = (isClockwise()) ? (-scale * Math.abs(item.getCurrentPieValue())) : (scale * Math.abs(item.getCurrentPieValue()));
                labelAngles[index] = normalizeAngle(start + (size / 2));
                final double sproutX = calcX(labelAngles[index], getLabelLineLength(), 0);
                final double sproutY = calcY(labelAngles[index], getLabelLineLength(), 0);
                labelsX[index] = sproutX;
                labelsY[index] = sproutY;
                xPad = Math.max(xPad, 2 * (item.textNode.getLayoutBounds().getWidth() + LABEL_TICK_GAP + Math.abs(sproutX)));
                if (sproutY &gt; 0) { // on bottom
                    yPad = Math.max(yPad, 2 * Math.abs(sproutY+item.textNode.getLayoutBounds().getMaxY()));
                } else { // on top
                    yPad = Math.max(yPad, 2 * Math.abs(sproutY + item.textNode.getLayoutBounds().getMinY()));
                }
                start+= size;
                index++;
            }
            pieRadius = Math.min(contentWidth - xPad, contentHeight - yPad) / 2;
            // check if this makes the pie too small
            if (pieRadius &lt; MIN_PIE_RADIUS ) {
                // calculate scale for text to fit labels in
                final double roomX = contentWidth-MIN_PIE_RADIUS-MIN_PIE_RADIUS;
                final double roomY = contentHeight-MIN_PIE_RADIUS-MIN_PIE_RADIUS;
                labelScale = Math.min(
                        roomX/xPad,
                        roomY/yPad
                );
                // hide labels if pie radius is less than minimum
                if ((begin == null &amp;&amp; labelScale &lt; 0.7) || ((begin.textNode.getFont().getSize()*labelScale) &lt; 9)) {
                    shouldShowLabels = false;
                    labelScale = 1;
                } else {
                    // set pieRadius to minimum
                    pieRadius = MIN_PIE_RADIUS;
                    // apply scale to all label positions
                    for(int i=0; i&lt; labelsX.length; i++) {
                        labelsX[i] =  labelsX[i] * labelScale;
                        labelsY[i] =  labelsY[i] * labelScale;
                    }
                }
            }
        }

        if (!shouldShowLabels) {
            pieRadius = Math.min(contentWidth,contentHeight) / 2;
            labelLinePath.getElements().clear();
        }

        if (getChartChildren().size() &gt; 0) {
            double centerX = contentWidth / 2 + left;
            double centerY = contentHeight / 2 + top;
            int index = 0;
            for (Data item = begin; item != null; item = item.next) {
                // layout labels for pie slice
                item.textNode.setVisible(shouldShowLabels);
                if (shouldShowLabels) {
                    double size = (isClockwise()) ? (-scale * Math.abs(item.getCurrentPieValue())) : (scale * Math.abs(item.getCurrentPieValue()));
                    final boolean isLeftSide = !(labelAngles[index] &gt; -90 &amp;&amp; labelAngles[index] &lt; 90);

                    double sliceCenterEdgeX = calcX(labelAngles[index], pieRadius, centerX);
                    double sliceCenterEdgeY = calcY(labelAngles[index], pieRadius, centerY);
                    double xval = isLeftSide ?
                        (labelsX[index] + sliceCenterEdgeX - item.textNode.getLayoutBounds().getMaxX() - LABEL_TICK_GAP) :
                        (labelsX[index] + sliceCenterEdgeX - item.textNode.getLayoutBounds().getMinX() + LABEL_TICK_GAP);
                    double yval = labelsY[index] + sliceCenterEdgeY - (item.textNode.getLayoutBounds().getMinY()/2) -2;

                    // do the line (Path)for labels
                    double lineEndX = sliceCenterEdgeX +labelsX[index];
                    double lineEndY = sliceCenterEdgeY +labelsY[index];
                    LabelLayoutInfo info = new LabelLayoutInfo(sliceCenterEdgeX,
                            sliceCenterEdgeY,lineEndX, lineEndY, xval, yval, item.textNode, Math.abs(size));
                    fullPie.add(info);

                    // set label scales
                    if (labelScale &lt; 1) {
                        item.textNode.getTransforms().add(
                            new Scale(
                                    labelScale, labelScale,
                                    isLeftSide ? item.textNode.getLayoutBounds().getWidth() : 0, 0
                            )
                        );
                    }
                }
                index++;
            }

            // update/draw pie slices
            double sAngle = getStartAngle();
            for (Data item = begin; item != null; item = item.next) {
                Node node = item.getNode();
                Arc arc = null;
                if (node != null) {
                    if (node instanceof Region) {
                        Region arcRegion = (Region)node;
                        if (arcRegion.getShape() == null) {
                            arc = new Arc();
                            arcRegion.setShape(arc);
                        } else {
                            arc = (Arc)arcRegion.getShape();
                        }
                        arcRegion.setScaleShape(false);
                        arcRegion.setCenterShape(false);
                        arcRegion.setCacheShape(false);
                    }
                }
                double size = (isClockwise()) ? (-scale * Math.abs(item.getCurrentPieValue())) : (scale * Math.abs(item.getCurrentPieValue()));
                // update slice arc size
                arc.setStartAngle(sAngle);
                arc.setLength(size);
                arc.setType(ArcType.ROUND);
                arc.setRadiusX(pieRadius * item.getRadiusMultiplier());
                arc.setRadiusY(pieRadius * item.getRadiusMultiplier());
                node.setLayoutX(centerX);
                node.setLayoutY(centerY);
                sAngle += size;
            }
            // finally draw the text and line
            if (fullPie != null) {
                // Check for collision and resolve by hiding the label of the smaller pie slice
                resolveCollision(fullPie);

                if (!fullPie.equals(labelLayoutInfos)) {
                    labelLinePath.getElements().clear();
                    for (LabelLayoutInfo info : fullPie) {
                        if (info.text.isVisible()) drawLabelLinePath(info);
                    }
                    labelLayoutInfos = fullPie;
                }
            }
        }
    }

    // We check for pie slice label collision and if collision is detected, we then
    // compare the size of the slices, and hide the label of the smaller slice.
    private void resolveCollision(List&lt;LabelLayoutInfo&gt; list) {
        int boxH = (begin != null) ? (int)begin.textNode.getLayoutBounds().getHeight() : 0;
        for (int i = 0; i &lt; list.size(); i++ ) {
            for (int j = i+1; j &lt; list.size(); j++ ) {
                LabelLayoutInfo box1 = list.get(i);
                LabelLayoutInfo box2 = list.get(j);
                if ((box1.text.isVisible() &amp;&amp; box2.text.isVisible()) &amp;&amp;
                        (fuzzyGT(box2.textY, box1.textY) ? fuzzyLT((box2.textY - boxH - box1.textY), 2) :
                                fuzzyLT((box1.textY - boxH - box2.textY), 2)) &amp;&amp;
                        (fuzzyGT(box1.textX, box2.textX) ? fuzzyLT((box1.textX - box2.textX), box2.text.prefWidth(-1)) :
                                fuzzyLT((box2.textX - box1.textX), box1.text.prefWidth(-1)))) {
                    if (fuzzyLT(box1.size, box2.size)) {
                        box1.text.setVisible(false);
                    } else {
                        box2.text.setVisible(false);
                    }
                }
            }
        }
    }

    private int fuzzyCompare(double o1, double o2) {
       double fuzz = 0.00001;
       return (((Math.abs(o1 - o2)) &lt; fuzz) ? 0 : ((o1 &lt; o2) ? -1 : 1));
    }

    private boolean fuzzyGT(double o1, double o2) {
        return fuzzyCompare(o1, o2) == 1;
    }

    private boolean fuzzyLT(double o1, double o2) {
        return fuzzyCompare(o1, o2) == -1;
    }

    private void drawLabelLinePath(LabelLayoutInfo info) {
        info.text.setLayoutX(info.textX);
        info.text.setLayoutY(info.textY);
        labelLinePath.getElements().add(new MoveTo(info.startX, info.startY));
        labelLinePath.getElements().add(new LineTo(info.endX, info.endY));

        labelLinePath.getElements().add(new MoveTo(info.endX-LABEL_BALL_RADIUS,info.endY));
        labelLinePath.getElements().add(new ArcTo(LABEL_BALL_RADIUS, LABEL_BALL_RADIUS,
                    90, info.endX,info.endY-LABEL_BALL_RADIUS, false, true));
        labelLinePath.getElements().add(new ArcTo(LABEL_BALL_RADIUS, LABEL_BALL_RADIUS,
                    90, info.endX+LABEL_BALL_RADIUS,info.endY, false, true));
        labelLinePath.getElements().add(new ArcTo(LABEL_BALL_RADIUS, LABEL_BALL_RADIUS,
                    90, info.endX,info.endY+LABEL_BALL_RADIUS, false, true));
        labelLinePath.getElements().add(new ArcTo(LABEL_BALL_RADIUS, LABEL_BALL_RADIUS,
                    90, info.endX-LABEL_BALL_RADIUS,info.endY, false, true));
        labelLinePath.getElements().add(new ClosePath());
    }
    /**
     * This is called whenever a series is added or removed and the legend needs to be updated
     */
    private void updateLegend() {
        Node legendNode = getLegend();
        if (legendNode != null &amp;&amp; legendNode != legend) return; // RT-23596 dont update when user has set legend.
        legend.setVertical(getLegendSide().equals(Side.LEFT) || getLegendSide().equals(Side.RIGHT));
        List&lt;Legend.LegendItem&gt; legendList = new ArrayList&lt;&gt;();
        if (getData() != null) {
            for (Data item : getData()) {
                LegendItem legenditem = new LegendItem(item.getName());
                legenditem.getSymbol().getStyleClass().addAll(item.getNode().getStyleClass());
                legenditem.getSymbol().getStyleClass().add(&quot;pie-legend-symbol&quot;);
                legendList.add(legenditem);
            }
        }
        legend.getItems().setAll(legendList);
        if (legendList.size() &gt; 0) {
            if (legendNode == null) {
                setLegend(legend);
            }
        } else {
            setLegend(null);
        }
    }

    private int getDataSize() {
        int count = 0;
        for (Data d = begin; d != null; d = d.next) {
            count++;
        }
        return count;
    }

    private static double calcX(double angle, double radius, double centerX) {
        return (double)(centerX + radius * Math.cos(Math.toRadians(-angle)));
    }

    private static double calcY(double angle, double radius, double centerY) {
        return (double)(centerY + radius * Math.sin(Math.toRadians(-angle)));
    }

     /** Normalize any angle into -180 to 180 deg range */
    private static double normalizeAngle(double angle) {
        double a = angle % 360;
        if (a &lt;= -180) a += 360;
        if (a &gt; 180) a -= 360;
        return a;
    }

    // -------------- INNER CLASSES --------------------------------------------

    // Class holding label line layout info for collision detection and removal
    private final static class LabelLayoutInfo {
        double startX;
        double startY;
        double endX;
        double endY;
        double textX;
        double textY;
        Text text;
        double size;

        LabelLayoutInfo(double startX, double startY, double endX, double endY,
                double textX, double textY, Text text, double size) {
            this.startX = startX;
            this.startY = startY;
            this.endX = endX;
            this.endY = endY;
            this.textX = textX;
            this.textY = textY;
            this.text = text;
            this.size = size;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            LabelLayoutInfo that = (LabelLayoutInfo) o;
            return Double.compare(that.startX, startX) == 0 &amp;&amp;
                    Double.compare(that.startY, startY) == 0 &amp;&amp;
                    Double.compare(that.endX, endX) == 0 &amp;&amp;
                    Double.compare(that.endY, endY) == 0 &amp;&amp;
                    Double.compare(that.textX, textX) == 0 &amp;&amp;
                    Double.compare(that.textY, textY) == 0 &amp;&amp;
                    Double.compare(that.size, size) == 0;
        }

        @Override
        public int hashCode() {
            return Objects.hash(startX, startY, endX, endY, textX, textY, size);
        }
    }

    /**
     * PieChart Data Item, represents one slice in the PieChart
     *
     * @since JavaFX 2.0
     */
    public final static class Data {

        private Text textNode = new Text();
        /**
         * Next pointer for the next data item : so we can do animation on data delete.
         */
        private Data next = null;

        /**
         * Default color index for this slice.
         */
        private int defaultColorIndex;

        // -------------- PUBLIC PROPERTIES ------------------------------------

        /**
         * The chart which this data belongs to.
         */
        private ReadOnlyObjectWrapper&lt;PieChart&gt; chart = new ReadOnlyObjectWrapper&lt;PieChart&gt;(this, &quot;chart&quot;);

        public final PieChart getChart() {
            return chart.getValue();
        }

        private void setChart(PieChart value) {
            chart.setValue(value);
        }

        public final ReadOnlyObjectProperty&lt;PieChart&gt; chartProperty() {
            return chart.getReadOnlyProperty();
        }

        /**
         * The name of the pie slice
         */
        private StringProperty name = new StringPropertyBase() {
            @Override
            protected void invalidated() {
                if (getChart() != null) getChart().dataNameChanged(Data.this);
            }

            @Override
            public Object getBean() {
                return Data.this;
            }

            @Override
            public String getName() {
                return &quot;name&quot;;
            }
        };

        public final void setName(java.lang.String value) {
            name.setValue(value);
        }

        public final java.lang.String getName() {
            return name.getValue();
        }

        public final StringProperty nameProperty() {
            return name;
        }

        /**
         * The value of the pie slice
         */
        private DoubleProperty pieValue = new DoublePropertyBase() {
            @Override
            protected void invalidated() {
                if (getChart() != null) getChart().dataPieValueChanged(Data.this);
            }

            @Override
            public Object getBean() {
                return Data.this;
            }

            @Override
            public String getName() {
                return &quot;pieValue&quot;;
            }
        };

        public final double getPieValue() {
            return pieValue.getValue();
        }

        public final void setPieValue(double value) {
            pieValue.setValue(value);
        }

        public final DoubleProperty pieValueProperty() {
            return pieValue;
        }

        /**
         * The current pie value, used during animation. This will be the last data value, new data value or
         * anywhere in between
         */
        private DoubleProperty currentPieValue = new SimpleDoubleProperty(this, &quot;currentPieValue&quot;);

        private double getCurrentPieValue() {
            return currentPieValue.getValue();
        }

        private void setCurrentPieValue(double value) {
            currentPieValue.setValue(value);
        }

        private DoubleProperty currentPieValueProperty() {
            return currentPieValue;
        }

        /**
         * Multiplier that is used to animate the radius of the pie slice
         */
        private DoubleProperty radiusMultiplier = new SimpleDoubleProperty(this, &quot;radiusMultiplier&quot;);

        private double getRadiusMultiplier() {
            return radiusMultiplier.getValue();
        }

        private void setRadiusMultiplier(double value) {
            radiusMultiplier.setValue(value);
        }

        private DoubleProperty radiusMultiplierProperty() {
            return radiusMultiplier;
        }

        /**
         * Readonly access to the node that represents the pie slice. You can use this to add mouse event listeners etc.
         */
        private ReadOnlyObjectWrapper&lt;Node&gt; node = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;node&quot;);

        /**
         * Returns the node that represents the pie slice. You can use this to
         * add mouse event listeners etc.
         * @return the node that represents the pie slice
         */
        public Node getNode() {
            return node.getValue();
        }

        private void setNode(Node value) {
            node.setValue(value);
        }

        public ReadOnlyObjectProperty&lt;Node&gt; nodeProperty() {
            return node.getReadOnlyProperty();
        }

        // -------------- CONSTRUCTOR -------------------------------------------------

        /**
         * Constructs a PieChart.Data object with the given name and value.
         *
         * @param name  name for Pie
         * @param value pie value
         */
        public Data(java.lang.String name, double value) {
            setName(name);
            setPieValue(value);
            textNode.getStyleClass().addAll(&quot;text&quot;, &quot;chart-pie-label&quot;);
            textNode.setAccessibleRole(AccessibleRole.TEXT);
            textNode.setAccessibleRoleDescription(&quot;slice&quot;);
            textNode.focusTraversableProperty().bind(Platform.accessibilityActiveProperty());
            textNode.accessibleTextProperty().bind( new StringBinding() {
                {bind(nameProperty(), currentPieValueProperty());}
                @Override protected String computeValue() {
                    return getName() + &quot; represents &quot; + getCurrentPieValue() + &quot; percent&quot;;
                }
            });
        }

        // -------------- PUBLIC METHODS ----------------------------------------------

        /**
         * Returns a string representation of this {@code Data} object.
         *
         * @return a string representation of this {@code Data} object.
         */
        @Override
        public java.lang.String toString() {
            return &quot;Data[&quot; + getName() + &quot;,&quot; + getPieValue() + &quot;]&quot;;
        }
    }

    // -------------- STYLESHEET HANDLING --------------------------------------

    /*
     * Super-lazy instantiation pattern from Bill Pugh.
     */
     private static class StyleableProperties {
         private static final CssMetaData&lt;PieChart,Boolean&gt; CLOCKWISE =
             new CssMetaData&lt;PieChart,Boolean&gt;(&quot;-fx-clockwise&quot;,
                 BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(PieChart node) {
                return node.clockwise == null || !node.clockwise.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(PieChart node) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)node.clockwiseProperty();
            }
        };

         private static final CssMetaData&lt;PieChart,Boolean&gt; LABELS_VISIBLE =
             new CssMetaData&lt;PieChart,Boolean&gt;(&quot;-fx-pie-label-visible&quot;,
                 BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(PieChart node) {
                return node.labelsVisible == null || !node.labelsVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(PieChart node) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)node.labelsVisibleProperty();
            }
        };

         private static final CssMetaData&lt;PieChart,Number&gt; LABEL_LINE_LENGTH =
             new CssMetaData&lt;PieChart,Number&gt;(&quot;-fx-label-line-length&quot;,
                 SizeConverter.getInstance(), 20d) {

            @Override
            public boolean isSettable(PieChart node) {
                return node.labelLineLength == null || !node.labelLineLength.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(PieChart node) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)node.labelLineLengthProperty();
            }
        };

         private static final CssMetaData&lt;PieChart,Number&gt; START_ANGLE =
             new CssMetaData&lt;PieChart,Number&gt;(&quot;-fx-start-angle&quot;,
                 SizeConverter.getInstance(), 0d) {

            @Override
            public boolean isSettable(PieChart node) {
                return node.startAngle == null || !node.startAngle.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(PieChart node) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)node.startAngleProperty();
            }
        };

         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
         static {

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Chart.getClassCssMetaData());
            styleables.add(CLOCKWISE);
            styleables.add(LABELS_VISIBLE);
            styleables.add(LABEL_LINE_LENGTH);
            styleables.add(START_ANGLE);
            STYLEABLES = Collections.unmodifiableList(styleables);
         }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

}


</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/Cell.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.ObservableList;
import javafx.scene.Node;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.shape.Rectangle;
import javafx.css.PseudoClass;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyBooleanWrapper;
import javafx.beans.value.WritableValue;
import javafx.css.StyleableProperty;

/**
 * The Cell API is used for virtualized controls such as {@link ListView},
 * {@link TreeView}, and {@link TableView}.
 * A Cell is a {@link Labeled} {@link Control}, and is used to render a single
 * &quot;row&quot; inside  a ListView, TreeView or TableView. Cells are also used for each
 * individual 'cell' inside a TableView (i.e. each row/column intersection). See
 * the JavaDoc for each control separately for more detail.
 * &lt;p&gt;
 * Every Cell is associated with a single data item (represented by the
 * {@link #itemProperty() item} property). The Cell is responsible for
 * rendering that item and, where appropriate, for editing the item. An item
 * within a Cell may be represented by text or some other control such as a
 * {@link CheckBox}, {@link ChoiceBox} or any other {@link Node} such as a
 * {@link HBox}, {@link GridPane}, or even a {@link Rectangle}.
 * &lt;p&gt;
 * Because TreeView, ListView, TableView and other such controls can potentially
 * be used for displaying incredibly large amounts of data, it is not feasible
 * to create an actual Cell for every single item in the control.
 * We represent extremely large data sets using only very few Cells. Each Cell
 * is &quot;recycled&quot;, or reused. This is what we mean when we say that these controls
 * are virtualized.
 * &lt;p&gt;
 * Since Cell is a Control, it is essentially a &quot;model&quot;. Its Skin is responsible
 * for defining the look and layout, while the Behavior is responsible for
 * handling all input events and using that information to modify the Control
 * state. Also, the Cell is styled from CSS just like any other Control.
 * However, it is not necessary to implement a Skin for most uses of a Cell.
 * This is because a cell factory can be set - this is detailed more shortly.
 * &lt;p&gt;
 * Because by far the most common use case for cells is to show text to a user,
 * this use case is specially optimized for within Cell. This is done by Cell
 * extending from {@link Labeled}. This means that subclasses of Cell need only
 * set the {@link #textProperty() text} property, rather than create a separate
 * {@link Label} and set that within the Cell. However, for situations where
 * something more than just plain text is called for, it is possible to place
 * any {@link Node} in the Cell {@link #graphicProperty() graphic} property.
 * Despite the term, a graphic can be any Node, and will be fully interactive.
 * For example, a ListCell might be configured with a {@link Button} as its
 * graphic. The Button text could then be bound to the cells
 * {@link #itemProperty() item} property. In this way, whenever the item in the
 * Cell changes, the Button text is automatically updated.
 * &lt;p&gt;
 * Cell sets focusTraversable to false.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;b&gt;Cell Factories&lt;/b&gt;
 * &lt;p&gt;
 * The default representation of the Cell &lt;code&gt;item&lt;/code&gt; is up to the various
 * virtualized container's skins to render. For example, the ListView by default
 * will convert the item to a String and call {@link #setText(java.lang.String)}
 * with this value. If you want to specialize the Cell used for the
 * ListView (for example), then you must provide an implementation of the
 * {@link ListView#cellFactoryProperty() cellFactory} callback function defined
 * on the ListView. Similar API exists on most controls that use Cells (for example,
 * {@link TreeView#cellFactoryProperty() TreeView},
 * {@link TableView#rowFactoryProperty() TableView},
 * {@link TableColumn#cellFactoryProperty() TableColumn} and
 * {@link ListView#cellFactoryProperty() ListView}.
 * &lt;p&gt;
 * The cell factory is called by the platform whenever it determines that a new
 * cell needs to be created. For example, perhaps your ListView has 10 million
 * items. Creating all 10 million cells would be prohibitively expensive. So
 * instead the ListView skin implementation might only create just enough cells
 * to fit the visual space. If the ListView is resized to be larger, the system
 * will determine that it needs to create some additional cells. In this case
 * it will call the cellFactory callback function (if one is provided) to create
 * the Cell implementation that should be used. If no cell factory is provided,
 * the built-in default implementation will be used.
 * &lt;p&gt;
 * The implementation of the cell factory is then responsible not just for
 * creating a Cell instance, but also configuring that Cell such that it reacts
 * to changes in its state. For example, if I were to create
 * a custom Cell which formatted Numbers such that they would appear as currency
 * types, I might do so like this:
 *
 * &lt;pre&gt;
 * public class MoneyFormatCell extends ListCell&amp;lt;Number&amp;gt; {
 *
 *     public MoneyFormatCell() {    }
 *
 *     &amp;#064;Override protected void updateItem(Number item, boolean empty) {
 *         // calling super here is very important - don't skip this!
 *         super.updateItem(item, empty);
 *
 *         // format the number as if it were a monetary value using the
 *         // formatting relevant to the current locale. This would format
 *         // 43.68 as &quot;$43.68&quot;, and -23.67 as &quot;-$23.67&quot;
 *         setText(item == null ? &quot;&quot; : NumberFormat.getCurrencyInstance().format(item));
 *
 *         // change the text fill based on whether it is positive (green)
 *         // or negative (red). If the cell is selected, the text will
 *         // always be white (so that it can be read against the blue
 *         // background), and if the value is zero, we'll make it black.
 *         if (item != null) {
 *             double value = item.doubleValue();
 *             setTextFill(isSelected() ? Color.WHITE :
 *                 value == 0 ? Color.BLACK :
 *                 value &amp;lt; 0 ? Color.RED : Color.GREEN);
 *         }
 *     }
 * }&lt;/pre&gt;
 *
 * This class could then be used inside a ListView as such:
 *
 * &lt;pre&gt;
 * ObservableList&amp;lt;Number&amp;gt; money = ...;
 * final ListView&amp;lt;Number&amp;gt; listView = new ListView&amp;lt;Number&amp;gt;(money);
 * listView.setCellFactory(new Callback&amp;lt;ListView&amp;lt;Number&amp;gt;, ListCell&amp;lt;Number&amp;gt;&amp;gt;() {
 *     &amp;#064;Override public ListCell&amp;lt;Number&amp;gt; call(ListView&amp;lt;Number&amp;gt; list) {
 *         return new MoneyFormatCell();
 *     }
 * });&lt;/pre&gt;
 *
 * In this example an anonymous inner class is created, that simply returns
 * instances of MoneyFormatCell whenever it is called. The MoneyFormatCell class
 * extends {@link ListCell}, overriding the
 * {@link #updateItem(java.lang.Object, boolean) updateItem} method. This method
 * is called whenever the item in the cell changes, for example when the user
 * scrolls the ListView or the content of the underlying data model changes
 * (and the cell is reused to represent some different item in the ListView).
 * Because of this, there is no need to manage bindings - simply react to the
 * change in items when this method occurs. In the example above, whenever the
 * item changes, we update the cell text property, and also modify the text fill
 * to ensure that we get the correct visuals. In addition, if the cell is &quot;empty&quot;
 * (meaning it is used to fill out space in the ListView but doesn't have any
 * data associated with it), then we just use the empty String.
 * &lt;p&gt;
 * Note that there are additional
 * methods prefixed with 'update' that may be of interest, so be
 * sure to read the API documentation for Cell, and subclasses of Cell, closely.
 * &lt;p&gt;
 * Of course, we can also use the binding API rather than overriding the
 * 'update' methods. Shown below is a very trivial example of how this could
 * be achieved.
 *
 *
 * &lt;pre&gt;
 * public class BoundLabelCell extends ListCell&amp;lt;String&amp;gt; {
 *
 *     public BoundLabelCell() {
 *         textProperty().bind(itemProperty());
 *     }
 * }
 * &lt;/pre&gt;
 *
 * &lt;h3&gt;Key Design Goals&lt;/h3&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;Both time and memory efficient for large data sets&lt;/li&gt;
 *   &lt;li&gt;Easy to build and use libraries for custom cells&lt;/li&gt;
 *   &lt;li&gt;Easy to customize cell visuals&lt;/li&gt;
 *   &lt;li&gt;Easy to customize display formatting (12.34 as $12.34 or 1234% etc)&lt;/li&gt;
 *   &lt;li&gt;Easy to extend for custom visuals&lt;/li&gt;
 *   &lt;li&gt;Easy to have &quot;panels&quot; of data for the visuals&lt;/li&gt;
 *   &lt;li&gt;Easy to animate the cell size or other properties&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Key Use Cases&lt;/h3&gt;
 * Following are a number of key use cases used to drive the Cell API design,
 * along with code examples showing how those use cases are satisfied by this
 * API. This is by no means to be considered the definitive list of capabilities
 * or features supported, but rather, to provide some guidance as to how to use
 * the Cell API. The examples below are focused on the ListView, but the same
 * philosophy applies to TreeCells or other kinds of cells.
 * &lt;p&gt;
 * &lt;b&gt;Changing the Cell's Colors&lt;/b&gt;
 * &lt;p&gt;
 * This should be extraordinarily simple in JavaFX. Each Cell can be styled
 * directly from CSS. So for example, if you wanted to change the default
 * background of every cell in a ListView to be WHITE you could do the
 * following CSS:
 *
 * &lt;pre&gt;
 * .list-cell {
 *   -fx-padding: 3 3 3 3;
 *   -fx-background-color: white;
 * }&lt;/pre&gt;
 *
 * If you wanted to set the color of selected ListView cells to be blue, you
 * could add this to your CSS file:
 *
 * &lt;pre&gt;
 * .list-cell:selected {
 *   -fx-background-color: blue;
 * }&lt;/pre&gt;
 *
 * Most Cell implementations extend from {@link IndexedCell} rather than Cell.
 * IndexedCell adds two other pseudoclass states: &quot;odd&quot; and &quot;even&quot;. Using this
 * you can get alternate row striping by doing something like this in your CSS
 * file:
 *
 * &lt;pre&gt;
 * .list-cell:odd {
 *   -fx-background-color: grey;
 * }&lt;/pre&gt;
 *
 * Each of these examples require no code changes. Simply update your CSS
 * file to alter the colors. You can also use the &quot;hover&quot; and other
 * pseudoclasses in CSS the same as with other controls.
 * &lt;p&gt;
 * Another approach to the first example above (formatting a list of numbers) would
 * be to use style classes. Suppose you had an {@link ObservableList} of Numbers
 * to display in a ListView and wanted to color all of the negative values red
 * and all positive or 0 values black.
 * One way to achieve this is with a custom cellFactory which changes the
 * styleClass of the Cell based on whether the value is negative or positive. This
 * is as simple as adding code to test if the number in the cell is negative,
 * and adding a &quot;negative&quot; styleClass. If the number is not negative, the &quot;negative&quot;
 * string should be removed. This approach allows for the colors to be defined
 * from CSS, allowing for simple customization. The CSS file would then include
 * something like the following:
 *
 * &lt;pre&gt;
 * .list-cell {
 *   -fx-text-fill: black;
 * }
 *
 * .list-cell .negative {
 *   -fx-text-fill: red;
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;Editing&lt;/h3&gt;
 * &lt;p&gt;Most virtualized controls that use the Cell architecture (e.g. {@link ListView},
 * {@link TreeView}, {@link TableView} and {@link TreeTableView}) all support
 * the notion of editing values directly via the cell. You can learn more about
 * the control-specific details by going to the 'editing' section in the class
 * documentation for the controls linked above. The remainder of this section
 * will cover some of the finer details of editing with cells.&lt;/p&gt;
 *
 * &lt;p&gt;The general flow of editing is as follows (note that in these steps the
 * {@link ListView} control is used as an example, but similar API exists for
 * all controls mentioned above, and the process is exactly the same in general):&lt;/p&gt;
 *
 * &lt;ol&gt;
 *     &lt;li&gt;User requests a cell enter editing mode (via keyboard or mouse commands),
 *     or the developer requests that a cell enter editing mode (by calling a
 *     method such as the ListView {@link ListView#edit(int) edit} method.
 *     &lt;strong&gt;Note:&lt;/strong&gt; If the user double-clicks or fires an appropriate
 *     keyboard command to initiate editing, then they are effectively calling
 *     the appropriate edit method on the control (i.e. the entry method for
 *     user-initiated and developer-initiated editing is the same).&lt;/li&gt;
 *     &lt;li&gt;Each cell in the visible region of the control is notified that the
 *     current {@link javafx.scene.control.ListView#editingIndexProperty() editing cell}
 *     has changed, and checks to see if it is itself. At this point one of three
 *     things can happen:
 *         &lt;ol&gt;
 *             &lt;li&gt;If the editing index is the same index as the cell,
 *             {@link #startEdit()} will be called on this cell. Some pointers:
 *                 &lt;ol&gt;
 *                     &lt;li&gt;It is recommended that subclasses of Cell override the {@link #startEdit()}
 *                     method to update the visuals of the cell when enters the editing state. Note
 *                     however that it is very important that subclasses that override the
 *                     {@link #startEdit()} method continue to call {@code super.startEdit()} so
 *                     that parent classes can update additional state that is necessary for
 *                     editing to be successful.&lt;/li&gt;
 *                     &lt;li&gt;Within the {@link #startEdit()} method is an ideal
 *                     time to change the visuals of the cell. For example (and
 *                     note that this example is more fleshed out in the UI control
 *                     javadocs for {@link ListView}, etc), you may set the
 *                     {@link #graphicProperty()} of the cell to a
 *                     {@link TextField} and set the {@link #textProperty()}
 *                     to null. This would allow end users to then type in input
 *                     and make changes to your data model.&lt;/li&gt;
 *                     &lt;li&gt;When the user has completed editing, they will want
 *                     to commit or cancel their change. This is your responsibility
 *                     to handle (e.g. by having the Enter key
 *                     {@link #commitEdit(Object) commit the edit}
 *                     and the ESC key {@link #cancelEdit() cancel the edit}).
 *                     You do this by attaching the appropriate event listeners
 *                     to the nodes you show whilst in the editing state.&lt;/li&gt;
 *                 &lt;/ol&gt;
 *             &lt;/li&gt;
 *             &lt;li&gt;If the editing index is not the same index as the cell, and
 *             if the cell is currently in the {@link #isEditing() editing state},
 *             {@link #cancelEdit()} will be called on this cell. As with the
 *             {@link #startEdit()} method, you should override this method to
 *             clean up the visuals of the cell (and most probably return the
 *             {@link #graphicProperty()} back to null and set the
 *             {@link #textProperty()} to its (possibly new) value. Again,
 *             be sure to always call {@code super.cancelEdit()} to make sure all
 *             state is correctly updated.&lt;/li&gt;
 *             &lt;li&gt;If the editing index is not the same index as the cell, and
 *             if the cell is not currently in the {@link #isEditing()} editing state},
 *             then nothing will happen on this cell.&lt;/li&gt;
 *         &lt;/ol&gt;
 *     &lt;/li&gt;
 * &lt;/ol&gt;
 *
 *
 * @param &lt;T&gt; The type of the item contained within the Cell.
 *
 * @since JavaFX 2.0
 */
public class Cell&lt;T&gt; extends Labeled {

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default Cell with the default style class of 'cell'.
     */
    public Cell() {
        setText(null); // default to null text, to match the null item
        // focusTraversable is styleable through css. Calling setFocusTraversable
        // makes it look to css like the user set the value and css will not
        // override. Initializing focusTraversable by calling set on the
        // CssMetaData ensures that css will be able to override the value.
        ((StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)focusTraversableProperty()).applyStyle(null, Boolean.FALSE);
        getStyleClass().addAll(DEFAULT_STYLE_CLASS);

        /**
         * Indicates whether or not this cell has focus. For example, a
<A NAME="12"></A>         * ListView defines zero or one cell as being the &quot;focused&quot; cell. This cell
         * would have focused set to true.
         */
        <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#12',2,'match52-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>super.focusedProperty().addListener(new InvalidationListener() {
            @Override public void invalidated(Observable property) {
                pseudoClassStateChanged(PSEUDO_CLASS_FOCUSED, isFocused()); // TODO is this necessary??

                // The user has shifted focus, so we should cancel the editing on this cell
                if</B></FONT> (!isFocused() &amp;&amp; isEditing()) {
                    cancelEdit();
                }
            }
        });

        // initialize default pseudo-class state
        pseudoClassStateChanged(PSEUDO_CLASS_EMPTY, true);
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- item
    private ObjectProperty&lt;T&gt; item = new SimpleObjectProperty&lt;T&gt;(this, &quot;item&quot;);

    /**
     * The data value associated with this Cell. This value is set by the
     * virtualized Control when the Cell is created or updated. This represents
     * the raw data value.
    *
    * &lt;p&gt;This value should only be set in subclasses of Cell by the virtualised
    * user interface controls that know how to properly work with the Cell
    * class.
     * @return the data value associated with this cell
     */
    public final ObjectProperty&lt;T&gt; itemProperty() { return item; }

    /**
     * Sets the item to the given value - should not be called directly as the
     * item is managed by the virtualized control.
     * @param value the new data value to set in this cell
     */
    public final void setItem(T value) { item.set(value); }

    /**
     * Returns the data value associated with this Cell.
     * @return the data value associated with this cell
     */
    public final T getItem() { return item.get(); }



    // --- empty
    private ReadOnlyBooleanWrapper empty = new ReadOnlyBooleanWrapper(true) {
        @Override protected void invalidated() {
            final boolean active = get();
            pseudoClassStateChanged(PSEUDO_CLASS_EMPTY,   active);
            pseudoClassStateChanged(PSEUDO_CLASS_FILLED, !active);
        }

        @Override
        public Object getBean() {
            return Cell.this;
        }

        @Override
        public String getName() {
            return &quot;empty&quot;;
        }
    };

    /**
     * A property used to represent whether the cell has any contents.
     * If true, then the Cell contains no data and is not associated with any
     * data item in the virtualized Control.
     *
     * &lt;p&gt;When a cell is empty, it can be styled differently via the 'empty'
     * CSS pseudo class state. For example, it may not receive any
     * alternate row highlighting, or it may not receive hover background
     * fill when hovered.
     * @return the representation of whether this cell has any contents
     */
    public final ReadOnlyBooleanProperty emptyProperty() { return empty.getReadOnlyProperty(); }

    private void setEmpty(boolean value) { empty.set(value); }

    /**
     * Returns a boolean representing whether the cell is considered to be empty
     * or not.
     * @return true if cell is empty, otherwise false
     */
    public final boolean isEmpty() { return empty.get(); }



    // --- selected
    private ReadOnlyBooleanWrapper selected = new ReadOnlyBooleanWrapper() {
        @Override protected void invalidated() {
            pseudoClassStateChanged(PSEUDO_CLASS_SELECTED, get());
        }

        @Override
        public Object getBean() {
            return Cell.this;
        }

        @Override
        public String getName() {
            return &quot;selected&quot;;
        }
    };

    /**
     * Indicates whether or not this cell has been selected. For example, a
     * ListView defines zero or more cells as being the &quot;selected&quot; cells.
     * @return the representation of whether this cell has been selected
     */
    public final ReadOnlyBooleanProperty selectedProperty() { return selected.getReadOnlyProperty(); }

    void setSelected(boolean value) { selected.set(value); }

    /**
     * Returns whether this cell is currently selected or not.
     * @return True if the cell is selected, false otherwise.
     */
    public final boolean isSelected() { return selected.get(); }



    // --- Editing
    private ReadOnlyBooleanWrapper editing;

    private void setEditing(boolean value) {
        editingPropertyImpl().set(value);
    }

    /**
     * Represents whether the cell is currently in its editing state or not.
     * @return true if this cell is currently in its editing state, otherwise
     * false
     */
    public final boolean isEditing() {
        return editing == null ? false : editing.get();
    }

    /**
     * Property representing whether this cell is currently in its editing state.
     * @return the representation of whether this cell is currently in its
     * editing state
     */
    public final ReadOnlyBooleanProperty editingProperty() {
        return editingPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyBooleanWrapper editingPropertyImpl() {
        if (editing == null) {
            editing = new ReadOnlyBooleanWrapper(this, &quot;editing&quot;);
        }
        return editing;
    }



    // --- Editable
    private BooleanProperty editable;

    /**
     * Allows for certain cells to not be able to be edited. This is useful in
     * cases where, say, a List has 'header rows' - it does not make sense for
     * the header rows to be editable, so they should have editable set to
     * false.
     *
     * @param value A boolean representing whether the cell is editable or not.
     *      If true, the cell is editable, and if it is false, the cell can not
     *      be edited.
     */
    public final void setEditable(boolean value) {
        editableProperty().set(value);
    }

    /**
     * Returns whether this cell is allowed to be put into an editing state.
     * @return true if this cell is allowed to be put into an editing state,
     * otherwise false
     */
    public final boolean isEditable() {
        return editable == null ? true : editable.get();
    }

    /**
     * A property representing whether this cell is allowed to be put into an
     * editing state. By default editable is set to true in Cells (although for
     * a subclass of Cell to be allowed to enter its editing state, it may have
     * to satisfy additional criteria. For example, ListCell requires that the
     * ListView {@link ListView#editableProperty() editable} property is also
     * true.
     * @return the representation of whether this cell is allowed to be put into
     * an editing state
     */
    public final BooleanProperty editableProperty() {
        if (editable == null) {
            editable = new SimpleBooleanProperty(this, &quot;editable&quot;, true);
        }
        return editable;
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Call this function to transition from a non-editing state into an editing
     * state, if the cell is editable. If this cell is already in an editing
     * state, it will stay in it.
     */
    public void startEdit() {
        if (isEditable() &amp;&amp; !isEditing() &amp;&amp; !isEmpty()) {
            setEditing(true);
        }
    }

    /**
     * Call this function to transition from an editing state into a non-editing
     * state, without saving any user input.
     */
    public void cancelEdit() {
        if (isEditing()) {
            setEditing(false);
        }
    }

    /**
     * Call this function when appropriate (based on the user interaction requirements
     * of your cell editing user interface) to do two things:
     *
     * &lt;ol&gt;
     *     &lt;li&gt;Fire the appropriate events back to the backing UI control (e.g.
     *     {@link ListView}). This will begin the process of pushing this edit
     *     back to the relevant data source / property (although it does not
     *     guarantee that this will be successful - that is dependent upon the
     *     specific edit commit handler being used). Refer to the UI control
     *     class javadoc for more detail.&lt;/li&gt;
     *     &lt;li&gt;Begin the transition from an editing state into a non-editing state.&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * &lt;p&gt;In general there is no need to override this method in custom cell
     * implementations - it should be sufficient to simply call this method
     * when appropriate (e.g. when the user pressed the Enter key, you may do something
     * like {@code cell.commitEdit(converter.fromString(textField.getText()));}&lt;/p&gt;
     *
     * @param newValue The value as input by the end user, which should be
     *      persisted in the relevant way given the data source underpinning the
     *      user interface and the install edit commit handler of the UI control.
     */
    public void commitEdit(T newValue) {
        if (isEditing()) {
            setEditing(false);
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren() {
        if (itemDirty) {
            updateItem(getItem(), isEmpty());
            itemDirty = false;
        }
        super.layoutChildren();
    }



    /***************************************************************************
     *                                                                         *
     * Expert API                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * The updateItem method should not be called by developers, but it is the
     * best method for developers to override to allow for them to customise the
     * visuals of the cell. To clarify, developers should never call this method
     * in their code (they should leave it up to the UI control, such as the
     * {@link javafx.scene.control.ListView} control) to call this method. However,
     * the purpose of having the updateItem method is so that developers, when
     * specifying custom cell factories (again, like the ListView
     * {@link javafx.scene.control.ListView#cellFactoryProperty() cell factory}),
     * the updateItem method can be overridden to allow for complete customisation
     * of the cell.
     *
     * &lt;p&gt;It is &lt;strong&gt;very important&lt;/strong&gt; that subclasses
     * of Cell override the updateItem method properly, as failure to do so will
     * lead to issues such as blank cells or cells with unexpected content
     * appearing within them. Here is an example of how to properly override the
     * updateItem method:
     *
     * &lt;pre&gt;
     * protected void updateItem(T item, boolean empty) {
     *     super.updateItem(item, empty);
     *
     *     if (empty || item == null) {
     *         setText(null);
     *         setGraphic(null);
     *     } else {
     *         setText(item.toString());
     *     }
     * }
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Note in this code sample two important points:
     * &lt;ol&gt;
     *     &lt;li&gt;We call the super.updateItem(T, boolean) method. If this is not
     *     done, the item and empty properties are not correctly set, and you are
     *     likely to end up with graphical issues.&lt;/li&gt;
     *     &lt;li&gt;We test for the &lt;code&gt;empty&lt;/code&gt; condition, and if true, we
     *     set the text and graphic properties to null. If we do not do this,
     *     it is almost guaranteed that end users will see graphical artifacts
     *     in cells unexpectedly.&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * @param item The new item for the cell.
     * @param empty whether or not this cell represents data from the list. If it
     *        is empty, then it does not represent any domain data, but is a cell
     *        being used to render an &quot;empty&quot; row.
     */
    protected void updateItem(T item, boolean empty) {
        setItem(item);
        setEmpty(empty);
        if (empty &amp;&amp; isSelected()) {
            updateSelected(false);
        }
    }

    /**
     * Updates whether this cell is in a selected state or not.
     * @param selected whether or not to select this cell.
     */
    public void updateSelected(boolean selected) {
        if (selected &amp;&amp; isEmpty()) return;
        boolean wasSelected = isSelected();
        setSelected(selected);

        if (wasSelected != selected) {
            markCellDirty();
        }
    }

    /**
     * This method is called by Cell subclasses so that certain CPU-intensive
     * actions (specifically, calling {@link #updateItem(Object, boolean)}) are
     * only performed when necessary (that is, they are only performed
     * when the currently set {@link #itemProperty() item} is considered to be
     * different than the proposed new item that could be set).
     *
     * &lt;p&gt;The default implementation of this method tests against equality, but
     * developers are able to override this method to perform checks in other ways
     * that are specific to their domain.&lt;/p&gt;
     *
     * @param oldItem The currently-set item contained within the cell (i.e. it is
     *                the same as what is available via {@link #getItem()}).
     * @param newItem The item that will be set in the cell, if this method
     *                returns true. If this method returns false, it may not be
     *                set.
     * @return Returns true if the new item is considered to be different than
     *         the old item. By default this method tests against equality, but
     *         subclasses may alter the implementation to test appropriate to
     *         their needs.
     * @since JavaFX 8u40
     */
    protected boolean isItemChanged(T oldItem, T newItem) {
        return oldItem != null ? !oldItem.equals(newItem) : newItem != null;
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    // itemDirty and markCellDirty introduced as a solution for JDK-8145588.
    // In the fullness of time, a more fully developed solution can be developed
    // that offers a public API around this lazy-dirty impl.
    private boolean itemDirty = false;
    private final void markCellDirty() {
        itemDirty = true;
        requestLayout();
    }


    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;cell&quot;;
    private static final PseudoClass PSEUDO_CLASS_SELECTED =
            PseudoClass.getPseudoClass(&quot;selected&quot;);
    private static final PseudoClass PSEUDO_CLASS_FOCUSED =
            PseudoClass.getPseudoClass(&quot;focused&quot;);
    private static final PseudoClass PSEUDO_CLASS_EMPTY =
            PseudoClass.getPseudoClass(&quot;empty&quot;);
    private static final PseudoClass PSEUDO_CLASS_FILLED =
            PseudoClass.getPseudoClass(&quot;filled&quot;);

    /**
     * Returns the initial focus traversable state of this control, for use
     * by the JavaFX CSS engine to correctly set its initial value. This method
     * is overridden as by default UI controls have focus traversable set to true,
     * but that is not appropriate for this control.
     *
     * @since 9
     */
    @Override protected Boolean getInitialFocusTraversable() {
        return Boolean.FALSE;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/ComboBoxBase.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import javafx.collections.MapChangeListener;
import javafx.css.PseudoClass;
import javafx.beans.property.*;
import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;

/**
 * Abstract base class for ComboBox-like controls. A ComboBox typically has
 * a button that, when clicked, will pop up some means of allowing a user
 * to select one or more values (depending on the implementation). This base
 * class makes no assumptions about what happens when the {@link #show()} and
 * {@link #hide()} methods are called, however commonly this results in either
 * a popup or dialog appearing that allows for the user to provide the
 * required information.
 *
 * &lt;p&gt;A ComboBox has a {@link #valueProperty() value} property that represents
 * the current user input. This may be based on a selection from a drop-down list,
 * or it may be from user input when the ComboBox is
 * {@link #editableProperty() editable}.
 *
 * &lt;p&gt;An {@link #editableProperty() editable} ComboBox is one which provides some
 * means for an end-user to provide input for values that are not otherwise
 * options available to them. For example, in the {@link ComboBox} implementation,
 * an editable ComboBox provides a {@link TextField} that may be typed into.
 * As mentioned above, when the user commits textual input into the textfield
 * (commonly by pressing the Enter keyboard key), the
 * {@link #valueProperty() value} property will be updated.
 *
 * &lt;p&gt;The purpose of the separation between this class and, say, {@link ComboBox}
 * is to allow for ComboBox-like controls that do not necessarily pop up a list
 * of items. Examples of other implementations include color pickers, calendar
 * pickers, etc. The  {@link ComboBox} class provides the default, and most commonly
 * expected implementation. Refer to that classes javadoc for more information.
 *
 * @see ComboBox
 * @param &lt;T&gt; The type of the value that has been selected or otherwise
 *      entered in to this ComboBox.
 * @since JavaFX 2.1
 */
public abstract class ComboBoxBase&lt;T&gt; extends Control {


    /***************************************************************************
     *                                                                         *
     * Static properties and methods                                           *
     *                                                                         *
     **************************************************************************/

    /**
     * &lt;p&gt;Called prior to the ComboBox showing its popup/display after the user
<A NAME="26"></A>     * has clicked or otherwise interacted with the ComboBox.
     * @since JavaFX 2.2
     */
    <FONT color="#95b9c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#26',2,'match52-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>public static final EventType&lt;Event&gt; ON_SHOWING =
            new EventType&lt;Event&gt;(Event.ANY, &quot;COMBO_BOX_BASE_ON_SHOWING&quot;);

    /**
     * &lt;p&gt;Called after the ComboBox has shown its popup/display.
     * @since JavaFX 2.2
     */
    public static final EventType&lt;Event&gt; ON_SHOWN =
            new EventType&lt;Event&gt;(Event.ANY, &quot;COMBO_BOX_BASE_ON_SHOWN&quot;);

    /**
     * &lt;p&gt;Called when the ComboBox popup/display &lt;b&gt;will&lt;/b&gt; be hidden.
     * @since JavaFX 2.2
     */
    public static final EventType&lt;Event&gt; ON_HIDING =
            new EventType&lt;Event&gt;(Event.ANY, &quot;COMBO_BOX_BASE_ON_HIDING&quot;);

    /**
     * &lt;p&gt;Called when the ComboBox popup/display has been hidden.
     * @since JavaFX 2.2
     */
    public static final EventType&lt;Event&gt; ON_HIDDEN =
            new EventType&lt;Event&gt;(Event.ANY, &quot;COMBO_BOX_BASE_ON_HIDDEN&quot;);



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default ComboBoxBase instance.
     */
    public ComboBoxBase() {
        getStyleClass().add(DEFAULT_STYLE_CLASS);

        // Fix for RT-29885
        getProperties().addListener</B></FONT>((MapChangeListener&lt;Object, Object&gt;) change -&gt; {
            if (change.wasAdded()) {
                if (change.getKey() == &quot;FOCUSED&quot;) {
                    setFocused((Boolean)change.getValueAdded());
                    getProperties().remove(&quot;FOCUSED&quot;);
                }
            }
        });
        // End of fix for RT-29885
    }

    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- value
    /**
     * The value of this ComboBox is defined as the selected item if the input
     * is not editable, or if it is editable, the most recent user action:
     * either the value input by the user, or the last selected item.
     * @return the value property
     */
    public ObjectProperty&lt;T&gt; valueProperty() { return value; }
    private ObjectProperty&lt;T&gt; value = new SimpleObjectProperty&lt;T&gt;(this, &quot;value&quot;);

    public final void setValue(T value) { valueProperty().set(value); }
    public final T getValue() { return valueProperty().get(); }


    // --- editable
    /**
     * Specifies whether the ComboBox allows for user input. When editable is
     * true, the ComboBox has a text input area that a user may type in to. This
     * input is then available via the {@link #valueProperty() value} property.
     *
     * &lt;p&gt;Note that when the editable property changes, the value property is
     * reset, along with any other relevant state.
     * @return the editable property
     */
    public BooleanProperty editableProperty() { return editable; }
    public final void setEditable(boolean value) { editableProperty().set(value); }
    public final boolean isEditable() { return editableProperty().get(); }
    private BooleanProperty editable = new SimpleBooleanProperty(this, &quot;editable&quot;, false) {
        @Override protected void invalidated() {
            pseudoClassStateChanged(PSEUDO_CLASS_EDITABLE, get());
        }
    };


    // --- showing
    /**
     * Represents the current state of the ComboBox popup, and whether it is
     * currently visible on screen (although it may be hidden behind other windows).
     */
    private ReadOnlyBooleanWrapper showing;
    public ReadOnlyBooleanProperty showingProperty() { return showingPropertyImpl().getReadOnlyProperty(); }
    public final boolean isShowing() { return showingPropertyImpl().get(); }
    private void setShowing(boolean value) {
        // these events will not fire if the showing property is bound
        Event.fireEvent(this, value ? new Event(ComboBoxBase.ON_SHOWING) :
            new Event(ComboBoxBase.ON_HIDING));
        showingPropertyImpl().set(value);
        Event.fireEvent(this, value ? new Event(ComboBoxBase.ON_SHOWN) :
            new Event(ComboBoxBase.ON_HIDDEN));
    }
    private ReadOnlyBooleanWrapper showingPropertyImpl() {
        if (showing == null) {
            showing = new ReadOnlyBooleanWrapper(false) {
                @Override protected void invalidated() {
                    pseudoClassStateChanged(PSEUDO_CLASS_SHOWING, get());
                    notifyAccessibleAttributeChanged(AccessibleAttribute.EXPANDED);
                }

                @Override
                public Object getBean() {
                    return ComboBoxBase.this;
                }

                @Override
                public String getName() {
                    return &quot;showing&quot;;
                }
            };
        }
        return showing;
    }


    // --- prompt text
    /**
     * The {@code ComboBox} prompt text to display, or {@code null} if no
     * prompt text is displayed. Prompt text is not displayed in all circumstances,
     * it is dependent upon the subclasses of ComboBoxBase to clarify when
     * promptText will be shown. For example, in most cases prompt text will never be
     * shown when a combo box is non-editable (that is, prompt text is only shown
     * when user input is allowed via text input).
     */
    private StringProperty promptText = new SimpleStringProperty(this, &quot;promptText&quot;, null) {
        @Override protected void invalidated() {
            // Strip out newlines
            String txt = get();
            if (txt != null &amp;&amp; txt.contains(&quot;\n&quot;)) {
                txt = txt.replace(&quot;\n&quot;, &quot;&quot;);
                set(txt);
            }
        }
    };
    public final StringProperty promptTextProperty() { return promptText; }
    public final String getPromptText() { return promptText.get(); }
    public final void setPromptText(String value) { promptText.set(value); }


    // --- armed
    /**
     * Indicates that the ComboBox has been &quot;armed&quot; such that a mouse release
     * will cause the ComboBox {@link #show()} method to be invoked. This is
     * subtly different from pressed. Pressed indicates that the mouse has been
     * pressed on a Node and has not yet been released. {@code arm} however
     * also takes into account whether the mouse is actually over the
     * ComboBox and pressed.
     * @return the armed property
     */
    public BooleanProperty armedProperty() { return armed; }
    private final void setArmed(boolean value) { armedProperty().set(value); }
    public final boolean isArmed() { return armedProperty().get(); }
    private BooleanProperty armed = new SimpleBooleanProperty(this, &quot;armed&quot;, false) {
        @Override protected void invalidated() {
            pseudoClassStateChanged(PSEUDO_CLASS_ARMED, get());
        }
    };


    // --- On Action
    /**
     * The ComboBox action, which is invoked whenever the ComboBox
     * {@link #valueProperty() value} property is changed. This
     * may be due to the value property being programmatically changed, when the
     * user selects an item in a popup list or dialog, or, in the case of
     * {@link #editableProperty() editable} ComboBoxes, it may be when the user
     * provides their own input (be that via a {@link TextField} or some other
     * input mechanism.
     * @return the on action property
     */
    public final ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onActionProperty() { return onAction; }
    public final void setOnAction(EventHandler&lt;ActionEvent&gt; value) { onActionProperty().set(value); }
    public final EventHandler&lt;ActionEvent&gt; getOnAction() { return onActionProperty().get(); }
    private ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onAction = new ObjectPropertyBase&lt;EventHandler&lt;ActionEvent&gt;&gt;() {
        @Override protected void invalidated() {
            setEventHandler(ActionEvent.ACTION, get());
        }

        @Override
        public Object getBean() {
            return ComboBoxBase.this;
        }

        @Override
        public String getName() {
            return &quot;onAction&quot;;
        }
    };


    // --- On Showing
    public final ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onShowingProperty() { return onShowing; }
    public final void setOnShowing(EventHandler&lt;Event&gt; value) { onShowingProperty().set(value); }
    public final EventHandler&lt;Event&gt; getOnShowing() { return onShowingProperty().get(); }
    /**
     * Called just prior to the {@code ComboBoxBase} popup/display being shown.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onShowing = new ObjectPropertyBase&lt;EventHandler&lt;Event&gt;&gt;() {
        @Override protected void invalidated() {
            setEventHandler(ON_SHOWING, get());
        }

        @Override public Object getBean() {
            return ComboBoxBase.this;
        }

        @Override public String getName() {
            return &quot;onShowing&quot;;
        }
    };


    // -- On Shown
    public final ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onShownProperty() { return onShown; }
    public final void setOnShown(EventHandler&lt;Event&gt; value) { onShownProperty().set(value); }
    public final EventHandler&lt;Event&gt; getOnShown() { return onShownProperty().get(); }
    /**
     * Called just after the {@link ComboBoxBase} popup/display is shown.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onShown = new ObjectPropertyBase&lt;EventHandler&lt;Event&gt;&gt;() {
        @Override protected void invalidated() {
            setEventHandler(ON_SHOWN, get());
        }

        @Override public Object getBean() {
            return ComboBoxBase.this;
        }

        @Override public String getName() {
            return &quot;onShown&quot;;
        }
    };


    // --- On Hiding
    public final ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onHidingProperty() { return onHiding; }
    public final void setOnHiding(EventHandler&lt;Event&gt; value) { onHidingProperty().set(value); }
    public final EventHandler&lt;Event&gt; getOnHiding() { return onHidingProperty().get(); }
    /**
     * Called just prior to the {@link ComboBox} popup/display being hidden.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onHiding = new ObjectPropertyBase&lt;EventHandler&lt;Event&gt;&gt;() {
        @Override protected void invalidated() {
            setEventHandler(ON_HIDING, get());
        }

        @Override public Object getBean() {
            return ComboBoxBase.this;
        }

        @Override public String getName() {
            return &quot;onHiding&quot;;
        }
    };


    // --- On Hidden
    public final ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onHiddenProperty() { return onHidden; }
    public final void setOnHidden(EventHandler&lt;Event&gt; value) { onHiddenProperty().set(value); }
    public final EventHandler&lt;Event&gt; getOnHidden() { return onHiddenProperty().get(); }
    /**
     * Called just after the {@link ComboBoxBase} popup/display has been hidden.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onHidden = new ObjectPropertyBase&lt;EventHandler&lt;Event&gt;&gt;() {
        @Override protected void invalidated() {
            setEventHandler(ON_HIDDEN, get());
        }

        @Override public Object getBean() {
            return ComboBoxBase.this;
        }

        @Override public String getName() {
            return &quot;onHidden&quot;;
        }
    };


    /***************************************************************************
     *                                                                         *
     * Methods                                                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Requests that the ComboBox display the popup aspect of the user interface.
     * As mentioned in the {@link ComboBoxBase} class javadoc, what is actually
     * shown when this method is called is undefined, but commonly it is some
     * form of popup or dialog window.
     */
    public void show() {
        if (!isDisabled()) {
            setShowing(true);
        }
    }

    /**
     * Closes the popup / dialog that was shown when {@link #show()} was called.
     */
    public void hide() {
        if (isShowing()) {
            setShowing(false);
        }
    }

    /**
     * Arms the ComboBox. An armed ComboBox will show a popup list on the next
     * expected UI gesture.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins or Behaviors. It is not common
     *       for developers or designers to access this function directly.
     */
    public void arm() {
        if (! armedProperty().isBound()) {
            setArmed(true);
        }
    }

    /**
     * Disarms the ComboBox. See {@link #arm()}.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins or Behaviors. It is not common
     *       for developers or designers to access this function directly.
     */
    public void disarm() {
        if (! armedProperty().isBound()) {
            setArmed(false);
        }
    }


    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;combo-box-base&quot;;

    private static final PseudoClass PSEUDO_CLASS_EDITABLE =
            PseudoClass.getPseudoClass(&quot;editable&quot;);
    private static final PseudoClass PSEUDO_CLASS_SHOWING =
            PseudoClass.getPseudoClass(&quot;showing&quot;);
    private static final PseudoClass PSEUDO_CLASS_ARMED =
            PseudoClass.getPseudoClass(&quot;armed&quot;);


    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case EXPANDED: return isShowing();
            case EDITABLE: return isEditable();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case EXPAND: show(); break;
            case COLLAPSE: hide(); break;
            default: super.executeAccessibleAction(action); break;
        }
    }
}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/Tooltip.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;


import com.sun.javafx.beans.IDProperty;
import com.sun.javafx.css.StyleManager;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.stage.PopupWindowHelper;

import javafx.css.SimpleStyleableBooleanProperty;
import javafx.css.SimpleStyleableDoubleProperty;
import javafx.css.SimpleStyleableObjectProperty;
import javafx.css.StyleOrigin;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableStringProperty;

import javafx.css.converter.BooleanConverter;
import javafx.css.converter.EnumConverter;
import javafx.css.converter.SizeConverter;
import javafx.css.converter.StringConverter;
import javafx.css.converter.DurationConverter;
import javafx.scene.control.skin.TooltipSkin;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.beans.property.*;
import javafx.beans.value.WritableValue;
import javafx.css.CssMetaData;
import javafx.css.FontCssMetaData;
import javafx.css.Styleable;
import javafx.css.StyleableProperty;
import javafx.event.EventHandler;
import javafx.geometry.NodeOrientation;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.MouseEvent;
import javafx.scene.text.Font;
import javafx.scene.text.TextAlignment;
import javafx.stage.Window;
import javafx.util.Duration;


/**
 * Tooltips are common UI elements which are typically used for showing
 * additional information about a Node in the scenegraph when the Node is
 * hovered over by the mouse. Any Node can show a tooltip. In most cases a
 * Tooltip is created and its {@link #textProperty() text} property is modified
 * to show plain text to the user. However, a Tooltip is able to show within it
 * an arbitrary scenegraph of nodes - this is done by creating the scenegraph
 * and setting it inside the Tooltip {@link #graphicProperty() graphic}
 * property.
 *
 * &lt;p&gt;You use the following approach to set a Tooltip on any node:
 *
 * &lt;pre&gt;
 * Rectangle rect = new Rectangle(0, 0, 100, 100);
 * Tooltip t = new Tooltip(&quot;A Square&quot;);
 * Tooltip.install(rect, t);
 * &lt;/pre&gt;
 *
 * This tooltip will then participate with the typical tooltip semantics (i.e.
 * appearing on hover, etc). Note that the Tooltip does not have to be
 * uninstalled: it will be garbage collected when it is not referenced by any
 * Node. It is possible to manually uninstall the tooltip, however.
 *
 * &lt;p&gt;A single tooltip can be installed on multiple target nodes or multiple
 * controls.
 *
 * &lt;p&gt;Because most Tooltips are shown on UI controls, there is special API
 * for all controls to make installing a Tooltip less verbose. The example below
 * shows how to create a tooltip for a Button control:
 *
 * &lt;pre&gt;
 * import javafx.scene.control.Tooltip;
 * import javafx.scene.control.Button;
 *
 * Button button = new Button(&quot;Hover Over Me&quot;);
 * button.setTooltip(new Tooltip(&quot;Tooltip for Button&quot;));
 * &lt;/pre&gt;
 * @since JavaFX 2.0
 */
@IDProperty(&quot;id&quot;)
public class Tooltip extends PopupControl {
    private static String TOOLTIP_PROP_KEY = &quot;javafx.scene.control.Tooltip&quot;;

    // RT-31134 : the tooltip style includes a shadow around the tooltip with a
    // width of 9 and height of 5. This causes mouse events to not reach the control
    // underneath resulting in losing hover state on the control while the tooltip is showing.
    // Displaying the tooltip at an offset indicated below resolves this issue.
    // RT-37107: The y-offset was upped to 7 to ensure no overlaps when the tooltip
    // is shown near the right edge of the screen.
    private static int TOOLTIP_XOFFSET = 10;
    private static int TOOLTIP_YOFFSET = 7;

    private static TooltipBehavior BEHAVIOR = new TooltipBehavior(false);

    /**
     * Associates the given {@link Tooltip} with the given {@link Node}. The tooltip
     * can then behave similar to when it is set on any {@link Control}. A single
     * tooltip can be associated with multiple nodes.
     * @param node the node
     * @param t the tooltip
     * @see Tooltip
     */
    public static void install(Node node, Tooltip t) {
        BEHAVIOR.install(node, t);
    }

    /**
     * Removes the association of the given {@link Tooltip} on the specified
     * {@link Node}. Hence hovering on the node will no longer result in showing of the
     * tooltip.
     * @param node the node
     * @param t the tooltip
     * @see Tooltip
     */
    public static void uninstall(Node node, Tooltip t) {
        BEHAVIOR.uninstall(node);
    }

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a tooltip with an empty string for its text.
     */
    public Tooltip() {
        this(null);
    }

    /**
     * Creates a tooltip with the specified text.
     *
     * @param text A text string for the tooltip.
     */
    public Tooltip(String text) {
        super();
        if (text != null) setText(text);
        bridge = new CSSBridge();
        PopupWindowHelper.getContent(this).setAll(bridge);
        getStyleClass().setAll(&quot;tooltip&quot;);
    }

    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/
    /**
     * The text to display in the tooltip. If the text is set to null, an empty
     * string will be displayed, despite the value being null.
     * @return the text property
     */
    public final StringProperty textProperty() { return text; }
    public final void setText(String value) {
        textProperty().setValue(value);
    }
    public final String getText() { return text.getValue() == null ? &quot;&quot; : text.getValue(); }
    private final StringProperty text = new SimpleStringProperty(this, &quot;text&quot;, &quot;&quot;) {
        @Override protected void invalidated() {
            super.invalidated();
            final String value = get();
            if (isShowing() &amp;&amp; value != null &amp;&amp; !value.equals(getText())) {
                //Dynamic tooltip content is location-dependant.
                //Chromium trick.
                setAnchorX(BEHAVIOR.lastMouseX);
                setAnchorY(BEHAVIOR.lastMouseY);
            }
        }
    };

    /**
     * Specifies the behavior for lines of text &lt;em&gt;when text is multiline&lt;/em&gt;.
     * Unlike {@link #contentDisplayProperty() contentDisplay} which affects the
     * graphic and text, this setting only affects multiple lines of text
     * relative to the text bounds.
     * @return the text alignment property
     */
    public final ObjectProperty&lt;TextAlignment&gt; textAlignmentProperty() {
        return textAlignment;
    }
    public final void setTextAlignment(TextAlignment value) {
        textAlignmentProperty().setValue(value);
    }
    public final TextAlignment getTextAlignment() {
        return textAlignmentProperty().getValue();
    }
    private final ObjectProperty&lt;TextAlignment&gt; textAlignment =
            new SimpleStyleableObjectProperty&lt;&gt;(TEXT_ALIGNMENT, this, &quot;textAlignment&quot;, TextAlignment.LEFT);;

    /**
     * Specifies the behavior to use if the text of the {@code Tooltip}
     * exceeds the available space for rendering the text.
     * @return the text overrun property
     */
    public final ObjectProperty&lt;OverrunStyle&gt; textOverrunProperty() {
        return textOverrun;
    }
    public final void setTextOverrun(OverrunStyle value) {
        textOverrunProperty().setValue(value);
    }
    public final OverrunStyle getTextOverrun() {
        return textOverrunProperty().getValue();
    }
    private final ObjectProperty&lt;OverrunStyle&gt; textOverrun =
            new SimpleStyleableObjectProperty&lt;OverrunStyle&gt;(TEXT_OVERRUN, this, &quot;textOverrun&quot;, OverrunStyle.ELLIPSIS);

    /**
     * If a run of text exceeds the width of the Tooltip, then this variable
     * indicates whether the text should wrap onto another line.
     * @return the wrap text property
     */
    public final BooleanProperty wrapTextProperty() {
        return wrapText;
    }
    public final void setWrapText(boolean value) {
        wrapTextProperty().setValue(value);
    }
    public final boolean isWrapText() {
        return wrapTextProperty().getValue();
    }
    private final BooleanProperty wrapText =
            new SimpleStyleableBooleanProperty(WRAP_TEXT, this, &quot;wrapText&quot;, false);


    /**
     * The default font to use for text in the Tooltip. If the Tooltip's text is
     * rich text then this font may or may not be used depending on the font
     * information embedded in the rich text, but in any case where a default
     * font is required, this font will be used.
     * @return the font property
     */
    public final ObjectProperty&lt;Font&gt; fontProperty() {
        return font;
    }
    public final void setFont(Font value) {
        fontProperty().setValue(value);
    }
    public final Font getFont() {
        return fontProperty().getValue();
    }
    private final ObjectProperty&lt;Font&gt; font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
        private boolean fontSetByCss = false;

        @Override public void applyStyle(StyleOrigin newOrigin, Font value) {
            // RT-20727 - if CSS is setting the font, then make sure invalidate doesn't call NodeHelper.reapplyCSS
            try {
                // super.applyStyle calls set which might throw if value is bound.
                // Have to make sure fontSetByCss is reset.
                fontSetByCss = true;
                super.applyStyle(newOrigin, value);
            } catch(Exception e) {
                throw e;
            } finally {
                fontSetByCss = false;
            }
        }

        @Override public void set(Font value) {
            final Font oldValue = get();
            StyleOrigin origin = ((StyleableObjectProperty&lt;Font&gt;)font).getStyleOrigin();
            if (origin == null || (value != null ? !value.equals(oldValue) : oldValue != null)) {
                super.set(value);
            }
        }

        @Override protected void invalidated() {
            // RT-20727 - if font is changed by calling setFont, then
            // css might need to be reapplied since font size affects
            // calculated values for styles with relative values
            if(fontSetByCss == false) {
                NodeHelper.reapplyCSS(Tooltip.this.bridge);
            }
        }

        @Override public CssMetaData&lt;Tooltip.CSSBridge,Font&gt; getCssMetaData() {
            return FONT;
        }

        @Override public Object getBean() {
            return Tooltip.this;
        }

        @Override public String getName() {
            return &quot;font&quot;;
        }
    };


    /**
     * The delay between the mouse entering the hovered node and when the associated tooltip will be shown to the user.
     * The default delay is 1000ms.
     *
     * @return show delay property
     * @since 9
     * @defaultValue 1000ms
     */
    public final ObjectProperty&lt;Duration&gt; showDelayProperty() {
        return showDelayProperty;
    }
    public final void setShowDelay(Duration showDelay) {
        showDelayProperty.set(showDelay);
    }
    public final Duration getShowDelay() {
        return showDelayProperty.get();
    }
    private final ObjectProperty&lt;Duration&gt; showDelayProperty
            = new SimpleStyleableObjectProperty&lt;&gt;(SHOW_DELAY, this, &quot;showDelay&quot;, new Duration(1000));


    /**
     * The duration that the tooltip should remain showing for until it is no longer visible to the user.
     * If the mouse leaves the control before the showDuration finishes, then the tooltip will remain showing
     * for the duration specified in the {@link #hideDelayProperty()}, even if the remaining time of the showDuration
     * is less than the hideDelay duration. The default value is 5000ms.
     *
     * @return the show duration property
     * @since 9
     * @defaultValue 5000ms
     */
    public final ObjectProperty&lt;Duration&gt; showDurationProperty() {
        return showDurationProperty;
    }
    public final void setShowDuration(Duration showDuration) {
        showDurationProperty.set(showDuration);
    }
    public final Duration getShowDuration() {
        return showDurationProperty.get();
    }
    private final ObjectProperty&lt;Duration&gt; showDurationProperty
            = new SimpleStyleableObjectProperty&lt;&gt;(SHOW_DURATION, this, &quot;showDuration&quot;, new Duration(5000));


    /**
     * The duration in which to continue showing the tooltip after the mouse has left the node. Once this time has
     * elapsed the tooltip will hide. The default value is 200ms.
     *
     * @return the hide delay property
     * @since 9
     * @defaultValue 200ms
     */
    public final ObjectProperty&lt;Duration&gt; hideDelayProperty() {
        return hideDelayProperty;
    }
    public final void setHideDelay(Duration hideDelay) {
        hideDelayProperty.set(hideDelay);
    }
    public final Duration getHideDelay() {
        return hideDelayProperty.get();
    }
    private final ObjectProperty&lt;Duration&gt; hideDelayProperty
            = new SimpleStyleableObjectProperty&lt;&gt;(HIDE_DELAY, this, &quot;hideDelay&quot;, new Duration(200));


    /**
     * An optional icon for the Tooltip. This can be positioned relative to the
     * text by using the {@link #contentDisplayProperty() content display}
     * property.
     * The node specified for this variable cannot appear elsewhere in the
     * scene graph, otherwise the {@code IllegalArgumentException} is thrown.
     * See the class description of {@link javafx.scene.Node Node} for more detail.
     * @return the graphic property
     */
    public final ObjectProperty&lt;Node&gt; graphicProperty() {
        return graphic;
    }
    public final void setGraphic(Node value) {
        graphicProperty().setValue(value);
    }
    public final Node getGraphic() {
        return graphicProperty().getValue();
    }
    private final ObjectProperty&lt;Node&gt; graphic = new StyleableObjectProperty&lt;Node&gt;() {
        // The graphic is styleable by css, but it is the
        // imageUrlProperty that handles the style value.
        @Override public CssMetaData getCssMetaData() {
            return GRAPHIC;
        }

        @Override public Object getBean() {
            return Tooltip.this;
        }

        @Override public String getName() {
            return &quot;graphic&quot;;
        }

    };

    private StyleableStringProperty imageUrlProperty() {
        if (imageUrl == null) {
            imageUrl = new StyleableStringProperty() {
                // If imageUrlProperty is invalidated, this is the origin of the style that
                // triggered the invalidation. This is used in the invaildated() method where the
                // value of super.getStyleOrigin() is not valid until after the call to set(v) returns,
                // by which time invalidated will have been called.
                // This value is initialized to USER in case someone calls set on the imageUrlProperty, which
                // is possible:
                //     CssMetaData metaData = ((StyleableProperty)labeled.graphicProperty()).getCssMetaData();
                //     StyleableProperty prop = metaData.getStyleableProperty(labeled);
                //     prop.set(someUrl);
                //
                // TODO: Note that prop != labeled, which violates the contract between StyleableProperty and CssMetaData.
                StyleOrigin origin = StyleOrigin.USER;

                @Override public void applyStyle(StyleOrigin origin, String v) {

                    this.origin = origin;

                    // Don't want applyStyle to throw an exception which would leave this.origin set to the wrong value
                    if (graphic == null || graphic.isBound() == false) super.applyStyle(origin, v);

                    // Origin is only valid for this invocation of applyStyle, so reset it to USER in case someone calls set.
                    this.origin = StyleOrigin.USER;
                }

                @Override protected void invalidated() {

                    // need to call super.get() here since get() is overridden to return the graphicProperty's value
                    final String url = super.get();

                    if (url == null) {
                        ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty()).applyStyle(origin, null);
                    } else {
                        // RT-34466 - if graphic's url is the same as this property's value, then don't overwrite.
                        final Node graphicNode = Tooltip.this.getGraphic();
                        if (graphicNode instanceof ImageView) {
                            final ImageView imageView = (ImageView)graphicNode;
                            final Image image = imageView.getImage();
                            if (image != null) {
                                final String imageViewUrl = image.getUrl();
                                if (url.equals(imageViewUrl)) return;
                            }

                        }

                        final Image img = StyleManager.getInstance().getCachedImage(url);

                        if (img != null) {
                            // Note that it is tempting to try to re-use existing ImageView simply by setting
                            // the image on the current ImageView, if there is one. This would effectively change
                            // the image, but not the ImageView which means that no graphicProperty listeners would
                            // be notified. This is probably not what we want.

                            // Have to call applyStyle on graphicProperty so that the graphicProperty's
                            // origin matches the imageUrlProperty's origin.
                            ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty()).applyStyle(origin, new ImageView(img));
                        }
                    }
                }

                @Override public String get() {
                    // The value of the imageUrlProperty is that of the graphicProperty.
                    // Return the value in a way that doesn't expand the graphicProperty.
                    final Node graphic = getGraphic();
                    if (graphic instanceof ImageView) {
                        final Image image = ((ImageView)graphic).getImage();
                        if (image != null) {
                            return image.getUrl();
                        }
                    }
                    return null;
                }

                @Override public StyleOrigin getStyleOrigin() {
                    // The origin of the imageUrlProperty is that of the graphicProperty.
                    // Return the origin in a way that doesn't expand the graphicProperty.
                    return graphic != null ? ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphic).getStyleOrigin() : null;
                }

                @Override public Object getBean() {
                    return Tooltip.this;
                }

                @Override public String getName() {
                    return &quot;imageUrl&quot;;
                }

                @Override public CssMetaData&lt;Tooltip.CSSBridge,String&gt; getCssMetaData() {
                    return GRAPHIC;
                }
            };
        }
        return imageUrl;
    }

    private StyleableStringProperty imageUrl = null;

    /**
     * Specifies the positioning of the graphic relative to the text.
     * @return the content display property
     */
    public final ObjectProperty&lt;ContentDisplay&gt; contentDisplayProperty() {
        return contentDisplay;
    }
    public final void setContentDisplay(ContentDisplay value) {
        contentDisplayProperty().setValue(value);
    }
    public final ContentDisplay getContentDisplay() {
        return contentDisplayProperty().getValue();
    }
    private final ObjectProperty&lt;ContentDisplay&gt; contentDisplay =
            new SimpleStyleableObjectProperty&lt;&gt;(CONTENT_DISPLAY, this, &quot;contentDisplay&quot;, ContentDisplay.LEFT);

    /**
     * The amount of space between the graphic and text
     * @return the graphic text gap property
     */
    public final DoubleProperty graphicTextGapProperty() {
        return graphicTextGap;
    }
    public final void setGraphicTextGap(double value) {
        graphicTextGapProperty().setValue(value);
    }
    public final double getGraphicTextGap() {
        return graphicTextGapProperty().getValue();
    }
    private final DoubleProperty graphicTextGap =
            new SimpleStyleableDoubleProperty(GRAPHIC_TEXT_GAP, this, &quot;graphicTextGap&quot;, 4d);

    /**
     * Typically, the tooltip is &quot;activated&quot; when the mouse moves over a Control.
     * There is usually some delay between when the Tooltip becomes &quot;activated&quot;
     * and when it is actually shown. The details (such as the amount of delay, etc)
     * is left to the Skin implementation.
     */
    private final ReadOnlyBooleanWrapper activated = new ReadOnlyBooleanWrapper(this, &quot;activated&quot;);
    final void setActivated(boolean value) { activated.set(value); }
    public final boolean isActivated() { return activated.get(); }
    public final ReadOnlyBooleanProperty activatedProperty() { return activated.getReadOnlyProperty(); }



    /***************************************************************************
     *                                                                         *
     * Methods                                                                 *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new TooltipSkin(this);
    }



    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/


    private static final CssMetaData&lt;Tooltip.CSSBridge,Font&gt; FONT =
            new FontCssMetaData&lt;Tooltip.CSSBridge&gt;(&quot;-fx-font&quot;, Font.getDefault()) {

                @Override
                public boolean isSettable(Tooltip.CSSBridge cssBridge) {
                    return !cssBridge.tooltip.fontProperty().isBound();
                }

                @Override
                public StyleableProperty&lt;Font&gt; getStyleableProperty(Tooltip.CSSBridge cssBridge) {
                    return (StyleableProperty&lt;Font&gt;)(WritableValue&lt;Font&gt;)cssBridge.tooltip.fontProperty();
                }
            };

    private static final CssMetaData&lt;Tooltip.CSSBridge,TextAlignment&gt; TEXT_ALIGNMENT =
            new CssMetaData&lt;Tooltip.CSSBridge,TextAlignment&gt;(&quot;-fx-text-alignment&quot;,
                    new EnumConverter&lt;TextAlignment&gt;(TextAlignment.class),
                    TextAlignment.LEFT) {

                @Override
                public boolean isSettable(Tooltip.CSSBridge cssBridge) {
                    return !cssBridge.tooltip.textAlignmentProperty().isBound();
                }

                @Override
                public StyleableProperty&lt;TextAlignment&gt; getStyleableProperty(Tooltip.CSSBridge cssBridge) {
                    return (StyleableProperty&lt;TextAlignment&gt;)(WritableValue&lt;TextAlignment&gt;)cssBridge.tooltip.textAlignmentProperty();
                }
            };

    private static final CssMetaData&lt;Tooltip.CSSBridge,OverrunStyle&gt; TEXT_OVERRUN =
            new CssMetaData&lt;Tooltip.CSSBridge,OverrunStyle&gt;(&quot;-fx-text-overrun&quot;,
                    new EnumConverter&lt;OverrunStyle&gt;(OverrunStyle.class),
                    OverrunStyle.ELLIPSIS) {

                @Override
                public boolean isSettable(Tooltip.CSSBridge cssBridge) {
                    return !cssBridge.tooltip.textOverrunProperty().isBound();
                }

                @Override
                public StyleableProperty&lt;OverrunStyle&gt; getStyleableProperty(Tooltip.CSSBridge cssBridge) {
                    return (StyleableProperty&lt;OverrunStyle&gt;)(WritableValue&lt;OverrunStyle&gt;)cssBridge.tooltip.textOverrunProperty();
                }
            };

    private static final CssMetaData&lt;Tooltip.CSSBridge,Boolean&gt; WRAP_TEXT =
            new CssMetaData&lt;Tooltip.CSSBridge,Boolean&gt;(&quot;-fx-wrap-text&quot;,
                    BooleanConverter.getInstance(), Boolean.FALSE) {

                @Override
                public boolean isSettable(Tooltip.CSSBridge cssBridge) {
                    return !cssBridge.tooltip.wrapTextProperty().isBound();
                }

                @Override
                public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Tooltip.CSSBridge cssBridge) {
                    return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)cssBridge.tooltip.wrapTextProperty();
                }
            };

    private static final CssMetaData&lt;Tooltip.CSSBridge,String&gt; GRAPHIC =
            new CssMetaData&lt;Tooltip.CSSBridge,String&gt;(&quot;-fx-graphic&quot;,
                    StringConverter.getInstance()) {

                @Override
                public boolean isSettable(Tooltip.CSSBridge cssBridge) {
                    return !cssBridge.tooltip.graphicProperty().isBound();
                }

                @Override
                public StyleableProperty&lt;String&gt; getStyleableProperty(Tooltip.CSSBridge cssBridge) {
                    return (StyleableProperty&lt;String&gt;)cssBridge.tooltip.imageUrlProperty();
                }
            };

    private static final CssMetaData&lt;Tooltip.CSSBridge,ContentDisplay&gt; CONTENT_DISPLAY =
            new CssMetaData&lt;Tooltip.CSSBridge,ContentDisplay&gt;(&quot;-fx-content-display&quot;,
                    new EnumConverter&lt;ContentDisplay&gt;(ContentDisplay.class),
                    ContentDisplay.LEFT) {

                @Override
                public boolean isSettable(Tooltip.CSSBridge cssBridge) {
                    return !cssBridge.tooltip.contentDisplayProperty().isBound();
                }

                @Override
                public StyleableProperty&lt;ContentDisplay&gt; getStyleableProperty(Tooltip.CSSBridge cssBridge) {
                    return (StyleableProperty&lt;ContentDisplay&gt;)(WritableValue&lt;ContentDisplay&gt;)cssBridge.tooltip.contentDisplayProperty();
                }
            };

    private static final CssMetaData&lt;Tooltip.CSSBridge,Number&gt; GRAPHIC_TEXT_GAP =
            new CssMetaData&lt;Tooltip.CSSBridge,Number&gt;(&quot;-fx-graphic-text-gap&quot;,
                    SizeConverter.getInstance(), 4.0) {

                @Override
                public boolean isSettable(Tooltip.CSSBridge cssBridge) {
                    return !cssBridge.tooltip.graphicTextGapProperty().isBound();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Tooltip.CSSBridge cssBridge) {
                    return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)cssBridge.tooltip.graphicTextGapProperty();
<A NAME="28"></A>                }
            };

    <FONT color="#717d7d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#28',2,'match52-top.html#28',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private static final CssMetaData&lt;Tooltip.CSSBridge,Duration&gt; SHOW_DELAY =
            new CssMetaData&lt;Tooltip.CSSBridge,Duration&gt;(&quot;-fx-show-delay&quot;,
                    DurationConverter.getInstance(), new Duration(1000)) {

                @Override
                public boolean isSettable(Tooltip.CSSBridge cssBridge) {</B></FONT>
                    return !cssBridge.tooltip.showDelayProperty().isBound();
                }

                @Override
                public StyleableProperty&lt;Duration&gt; getStyleableProperty(Tooltip.CSSBridge cssBridge) {
                    return (StyleableProperty&lt;Duration&gt;)(WritableValue&lt;Duration&gt;)cssBridge.tooltip.showDelayProperty();
                }
            };

    private static final CssMetaData&lt;Tooltip.CSSBridge,Duration&gt; SHOW_DURATION =
            new CssMetaData&lt;Tooltip.CSSBridge,Duration&gt;(&quot;-fx-show-duration&quot;,
                    DurationConverter.getInstance(), new Duration(5000)) {

                @Override
                public boolean isSettable(Tooltip.CSSBridge cssBridge) {
                    return !cssBridge.tooltip.showDurationProperty().isBound();
                }

                @Override
                public StyleableProperty&lt;Duration&gt; getStyleableProperty(Tooltip.CSSBridge cssBridge) {
                    return (StyleableProperty&lt;Duration&gt;)(WritableValue&lt;Duration&gt;)cssBridge.tooltip.showDurationProperty();
                }
            };

    private static final CssMetaData&lt;Tooltip.CSSBridge,Duration&gt; HIDE_DELAY =
            new CssMetaData&lt;Tooltip.CSSBridge,Duration&gt;(&quot;-fx-hide-delay&quot;,
                    DurationConverter.getInstance(), new Duration(200)) {

                @Override
                public boolean isSettable(Tooltip.CSSBridge cssBridge) {
                    return !cssBridge.tooltip.hideDelayProperty().isBound();
                }

                @Override
                public StyleableProperty&lt;Duration&gt; getStyleableProperty(Tooltip.CSSBridge cssBridge) {
                    return (StyleableProperty&lt;Duration&gt;)(WritableValue&lt;Duration&gt;)cssBridge.tooltip.hideDelayProperty();
                }
            };


    private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
    static {
        final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(PopupControl.getClassCssMetaData());
        styleables.add(FONT);
        styleables.add(TEXT_ALIGNMENT);
        styleables.add(TEXT_OVERRUN);
        styleables.add(WRAP_TEXT);
        styleables.add(GRAPHIC);
        styleables.add(CONTENT_DISPLAY);
        styleables.add(GRAPHIC_TEXT_GAP);
        styleables.add(SHOW_DELAY);
        styleables.add(SHOW_DURATION);
        styleables.add(HIDE_DELAY);
        STYLEABLES = Collections.unmodifiableList(styleables);
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    @Override public Styleable getStyleableParent() {
        if (BEHAVIOR.hoveredNode == null) {
            return super.getStyleableParent();
        }
        return BEHAVIOR.hoveredNode;
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    private final class CSSBridge extends PopupControl.CSSBridge {
        private Tooltip tooltip = Tooltip.this;

        CSSBridge() {
            super();
            setAccessibleRole(AccessibleRole.TOOLTIP);
        }
    }


    private static class TooltipBehavior {
        /*
         * There are two key concepts with Tooltip: activated and visible. A Tooltip
         * is activated as soon as a mouse move occurs over the target node. When it
         * becomes activated, we start off the ACTIVATION_TIMER. If the
         * ACTIVATION_TIMER expires before another mouse event occurs, then we will
         * show the popup. This timer typically lasts about 1 second.
         *
         * Once visible, we reset the ACTIVATION_TIMER and start the HIDE_TIMER.
         * This second timer will allow the tooltip to remain visible for some time
         * period (such as 5 seconds). If the mouse hasn't moved, and the HIDE_TIMER
         * expires, then the tooltip is hidden and the tooltip is no longer
         * activated.
         *
         * If another mouse move occurs, the ACTIVATION_TIMER starts again, and the
         * same rules apply as above.
         *
         * If a mouse exit event occurs while the HIDE_TIMER is ticking, we reset
         * the HIDE_TIMER. Thus, the tooltip disappears after 5 seconds from the
         * last mouse move.
         *
         * If some other mouse event occurs while the HIDE_TIMER is running, other
         * than mouse move or mouse enter/exit (such as a click), then the tooltip
         * is hidden, the HIDE_TIMER stopped, and activated set to false.
         *
         * If a mouse exit occurs while the HIDE_TIMER is running, we stop the
         * HIDE_TIMER and start the LEFT_TIMER, and immediately hide the tooltip.
         * This timer is very short, maybe about a 1/2 second. If the mouse enters a
         * new node which also has a tooltip before LEFT_TIMER expires, then the
         * second tooltip is activated and shown immediately (the ACTIVATION_TIMER
         * having been bypassed), and the HIDE_TIMER is started. If the LEFT_TIMER
         * expires and there is no mouse movement over a control with a tooltip,
         * then we are back to the initial steady state where the next mouse move
         * over a node with a tooltip installed will start the ACTIVATION_TIMER.
         */

        private Timeline activationTimer = new Timeline();
        private Timeline hideTimer = new Timeline();
        private Timeline leftTimer = new Timeline();

        /**
         * The Node with a tooltip over which the mouse is hovering. There can
         * only be one of these at a time.
         */
        private Node hoveredNode;

        /**
         * The tooltip that is currently activated. There can only be one
         * of these at a time.
         */
        private Tooltip activatedTooltip;

        /**
         * The tooltip that is currently visible. There can only be one
         * of these at a time.
         */
        private Tooltip visibleTooltip;

        /**
         * The last position of the mouse, in screen coordinates.
         */
        private double lastMouseX;
        private double lastMouseY;

        private boolean hideOnExit;
        private boolean cssForced = false;

        TooltipBehavior(final boolean hideOnExit) {
            this.hideOnExit = hideOnExit;

            activationTimer.setOnFinished(event -&gt; {
                // Show the currently activated tooltip and start the
                // HIDE_TIMER.
                assert activatedTooltip != null;
                final Window owner = getWindow(hoveredNode);
                final boolean treeVisible = isWindowHierarchyVisible(hoveredNode);

                // If the ACTIVATED tooltip is part of a visible window
                // hierarchy, we can go ahead and show the tooltip and
                // start the HIDE_TIMER.
                //
                // If the owner is null or invisible, then it either means a
                // bug in our code, the node was removed from a scene or
                // window or made invisible, or the node is not part of a
                // visible window hierarchy. In that case, we don't show the
                // tooltip, and we don't start the HIDE_TIMER. We simply let
                // ACTIVATED_TIMER expire, and wait until the next mouse
                // the movement to start it again.
                if (owner != null &amp;&amp; owner.isShowing() &amp;&amp; treeVisible) {
                    double x = lastMouseX;
                    double y = lastMouseY;

                    // The tooltip always inherits the nodeOrientation of
                    // the Node that it is attached to (see RT-26147). It
                    // is possible to override this for the Tooltip content
                    // (but not the popup placement) by setting the
                    // nodeOrientation on tooltip.getScene().getRoot().
                    NodeOrientation nodeOrientation = hoveredNode.getEffectiveNodeOrientation();
                    activatedTooltip.getScene().setNodeOrientation(nodeOrientation);
                    if (nodeOrientation == NodeOrientation.RIGHT_TO_LEFT) {
                        x -= activatedTooltip.getWidth();
                    }

                    activatedTooltip.show(owner, x+TOOLTIP_XOFFSET, y+TOOLTIP_YOFFSET);

                    // RT-37107: Ensure the tooltip is displayed in a position
                    // where it will not be under the mouse, even when the tooltip
                    // is near the edge of the screen
                    if ((y+TOOLTIP_YOFFSET) &gt; activatedTooltip.getAnchorY()) {
                        // the tooltip has been shifted vertically upwards,
                        // most likely to be underneath the mouse cursor, so we
                        // need to shift it further by hiding and reshowing
                        // in another location
                        activatedTooltip.hide();

                        y -= activatedTooltip.getHeight();
                        activatedTooltip.show(owner, x+TOOLTIP_XOFFSET, y);
                    }

                    visibleTooltip = activatedTooltip;
                    hoveredNode = null;
                    if (activatedTooltip.getShowDuration() != null) {
                        hideTimer.getKeyFrames().setAll(new KeyFrame(activatedTooltip.getShowDuration()));
                    }
                    hideTimer.playFromStart();
                }

                // Once the activation timer has expired, the tooltip is no
                // longer in the activated state, it is only in the visible
                // state, so we go ahead and set activated to false
                activatedTooltip.setActivated(false);
                activatedTooltip = null;
            });

            hideTimer.setOnFinished(event -&gt; {
                // Hide the currently visible tooltip.
                assert visibleTooltip != null;
                visibleTooltip.hide();
                visibleTooltip = null;
                hoveredNode = null;
            });

            leftTimer.setOnFinished(event -&gt; {
                if (!hideOnExit) {
                    // Hide the currently visible tooltip.
                    assert visibleTooltip != null;
                    visibleTooltip.hide();
                    visibleTooltip = null;
                    hoveredNode = null;
                }
            });
        }

        /**
         * Registers for mouse move events only. When the mouse is moved, this
         * handler will detect it and decide whether to start the ACTIVATION_TIMER
         * (if the ACTIVATION_TIMER is not started), restart the ACTIVATION_TIMER
         * (if ACTIVATION_TIMER is running), or skip the ACTIVATION_TIMER and just
         * show the tooltip (if the LEFT_TIMER is running).
         */
        private EventHandler&lt;MouseEvent&gt; MOVE_HANDLER = (MouseEvent event) -&gt; {
            //Screen coordinates need to be actual for dynamic tooltip.
            //See Tooltip.setText

            lastMouseX = event.getScreenX();
            lastMouseY = event.getScreenY();

            // If the HIDE_TIMER is running, then we don't want this event
            // handler to do anything, or change any state at all.
            if (hideTimer.getStatus() == Timeline.Status.RUNNING) {
                return;
            }

            // Note that the &quot;install&quot; step will both register this handler
            // with the target node and also associate the tooltip with the
            // target node, by stashing it in the client properties of the node.
            hoveredNode = (Node) event.getSource();
            Tooltip t = (Tooltip) hoveredNode.getProperties().get(TOOLTIP_PROP_KEY);
            if (t != null) {
                // In theory we should never get here with an invisible or
                // non-existant window hierarchy, but might in some cases where
                // people are feeding fake mouse events into the hierarchy. So
                // we'll guard against that case.
                final Window owner = getWindow(hoveredNode);
                final boolean treeVisible = isWindowHierarchyVisible(hoveredNode);
                if (owner != null &amp;&amp; treeVisible) {
                    // Now we know that the currently HOVERED node has a tooltip
                    // and that it is part of a visible window Hierarchy.
                    // If LEFT_TIMER is running, then we make this tooltip
                    // visible immediately, stop the LEFT_TIMER, and start the
                    // HIDE_TIMER.
                    if (leftTimer.getStatus() == Timeline.Status.RUNNING) {
                        if (visibleTooltip != null) visibleTooltip.hide();
                        visibleTooltip = t;
                        t.show(owner, event.getScreenX()+TOOLTIP_XOFFSET,
                                event.getScreenY()+TOOLTIP_YOFFSET);
                        leftTimer.stop();
                        if (t.getShowDuration() != null) {
                            hideTimer.getKeyFrames().setAll(new KeyFrame(t.getShowDuration()));
                        }
                        hideTimer.playFromStart();
                    } else {
                        // Force the CSS to be processed for the tooltip so that it uses the
                        // appropriate timings for showDelay, showDuration, and hideDelay.
                        if (!cssForced) {
                            double opacity = t.getOpacity();
                            t.setOpacity(0);
                            t.show(owner);
                            t.hide();
                            t.setOpacity(opacity);
                            cssForced = true;
                        }

                        // Start / restart the timer and make sure the tooltip
                        // is marked as activated.
                        t.setActivated(true);
                        activatedTooltip = t;
                        activationTimer.stop();
                        if (t.getShowDelay() != null) {
                            activationTimer.getKeyFrames().setAll(new KeyFrame(t.getShowDelay()));
                        }
                        activationTimer.playFromStart();
                    }
                }
            } else {
                // TODO should deregister, no point being here anymore!
            }
        };

        /**
         * Registers for mouse exit events. If the ACTIVATION_TIMER is running then
         * this will simply stop it. If the HIDE_TIMER is running then this will
         * stop the HIDE_TIMER, hide the tooltip, and start the LEFT_TIMER.
         */
        private EventHandler&lt;MouseEvent&gt; LEAVING_HANDLER = (MouseEvent event) -&gt; {
            // detect bogus mouse exit events, if it didn't really move then ignore it
            if (activationTimer.getStatus() == Timeline.Status.RUNNING) {
                activationTimer.stop();
            } else if (hideTimer.getStatus() == Timeline.Status.RUNNING) {
                assert visibleTooltip != null;
                hideTimer.stop();
                if (hideOnExit) visibleTooltip.hide();
                Node source = (Node) event.getSource();
                Tooltip t = (Tooltip) source.getProperties().get(TOOLTIP_PROP_KEY);
                if (t != null) {
                    if (t.getHideDelay() != null) {
                        leftTimer.getKeyFrames().setAll(new KeyFrame(t.getHideDelay()));
                    }
                    leftTimer.playFromStart();
                }
            }

            hoveredNode = null;
            activatedTooltip = null;
            if (hideOnExit) visibleTooltip = null;
        };

        /**
         * Registers for mouse click, press, release, drag events. If any of these
         * occur, then the tooltip is hidden (if it is visible), it is deactivated,
         * and any and all timers are stopped.
         */
        private EventHandler&lt;MouseEvent&gt; KILL_HANDLER = (MouseEvent event) -&gt; {
            activationTimer.stop();
            hideTimer.stop();
            leftTimer.stop();
            if (visibleTooltip != null) visibleTooltip.hide();
            hoveredNode = null;
            activatedTooltip = null;
            visibleTooltip = null;
        };

        private void install(Node node, Tooltip t) {
            // Install the MOVE_HANDLER, LEAVING_HANDLER, and KILL_HANDLER on
            // the given node. Stash the tooltip in the node's client properties
            // map so that it is not gc'd. The handlers must all be installed
            // with a TODO weak reference so as not to cause a memory leak
            if (node == null) return;
            node.addEventHandler(MouseEvent.MOUSE_MOVED, MOVE_HANDLER);
            node.addEventHandler(MouseEvent.MOUSE_EXITED, LEAVING_HANDLER);
            node.addEventHandler(MouseEvent.MOUSE_PRESSED, KILL_HANDLER);
            node.getProperties().put(TOOLTIP_PROP_KEY, t);
        }

        private void uninstall(Node node) {
            if (node == null) return;
            node.removeEventHandler(MouseEvent.MOUSE_MOVED, MOVE_HANDLER);
            node.removeEventHandler(MouseEvent.MOUSE_EXITED, LEAVING_HANDLER);
            node.removeEventHandler(MouseEvent.MOUSE_PRESSED, KILL_HANDLER);
            Tooltip t = (Tooltip)node.getProperties().get(TOOLTIP_PROP_KEY);
            if (t != null) {
                node.getProperties().remove(TOOLTIP_PROP_KEY);
                if (t.equals(visibleTooltip) || t.equals(activatedTooltip)) {
                    KILL_HANDLER.handle(null);
                }
            }
        }

        /**
         * Gets the top level window associated with this node.
         * @param node the node
         * @return the top level window
         */
        private Window getWindow(final Node node) {
            final Scene scene = node == null ? null : node.getScene();
            return scene == null ? null : scene.getWindow();
        }

        /**
         * Gets whether the entire window hierarchy is visible for this node.
         * @param node the node to check
         * @return true if entire hierarchy is visible
         */
        private boolean isWindowHierarchyVisible(Node node) {
            boolean treeVisible = node != null;
            Parent parent = node == null ? null : node.getParent();
            while (parent != null &amp;&amp; treeVisible) {
                treeVisible = parent.isVisible();
                parent = parent.getParent();
            }
            return treeVisible;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TableHeaderRow.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import java.util.*;

import javafx.beans.InvalidationListener;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.StringProperty;
import javafx.collections.ListChangeListener;
import javafx.collections.WeakListChangeListener;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.geometry.Side;
import javafx.geometry.VPos;
import javafx.scene.control.CheckMenuItem;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Control;
import javafx.scene.control.Label;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableColumnBase;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;

import com.sun.javafx.scene.control.skin.resources.ControlResources;

/**
 * Region responsible for painting the entire row of column headers.
 *
 * @since 9
 * @see javafx.scene.control.TableView
 * @see TableViewSkin
 * @see javafx.scene.control.TreeTableView
 * @see TreeTableViewSkin
 */
public class TableHeaderRow extends StackPane {

    /***************************************************************************
     *                                                                         *
     * Static Fields                                                           *
     *                                                                         *
     **************************************************************************/


    /***************************************************************************
     *                                                                         *
     * Private Fields                                                          *
     *                                                                         *
     **************************************************************************/

    // JDK-8090129: This constant should not be static, because the
    // Locale may change between instances.
    private final String MENU_SEPARATOR =
            ControlResources.getString(&quot;TableView.nestedColumnControlMenuSeparator&quot;);

    private final VirtualFlow flow;
    final TableViewSkinBase&lt;?,?,?,?,?&gt; tableSkin;
    private Map&lt;TableColumnBase, CheckMenuItem&gt; columnMenuItems = new HashMap&lt;TableColumnBase, CheckMenuItem&gt;();
    private double scrollX;
    private double tableWidth;
    private Rectangle clip;
    private TableColumnHeader reorderingRegion;

    /**
     * This is the ghosted region representing the table column that is being
     * dragged. It moves along the x-axis but is fixed in the y-axis.
     */
    private StackPane dragHeader;
    private final Label dragHeaderLabel = new Label();

    private Region filler;

    /**
     * This is the region where the user can interact with to show/hide columns.
     * It is positioned in the top-right hand corner of the TableHeaderRow, and
     * when clicked shows a PopupMenu consisting of all leaf columns.
     */
    private Pane cornerRegion;

    /**
     * PopupMenu shown to users to allow for them to hide/show columns in the
     * table.
     */
    private ContextMenu columnPopupMenu;

    /**
     * There are two different mouse dragged event handlers in the header code.
     * Firstly, the column reordering functionality, and secondly, the column
     * resizing functionality. Because these are handled in separate classes and
     * with separate event handlers, we occasionally run into the issue where
     * both event handlers were being called, resulting in bad UX. To remove this
     * issue, we lock when the column dragging happens, and prevent resize operations
     * from taking place.
     */
    boolean columnDragLock = false;



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private InvalidationListener tableWidthListener = o -&gt; updateTableWidth();

    private InvalidationListener tablePaddingListener = o -&gt; updateTableWidth();

    // This is necessary for RT-20300 (but was updated for RT-20840)
    private ListChangeListener visibleLeafColumnsListener = c -&gt; getRootHeader().setHeadersNeedUpdate();

    private final ListChangeListener tableColumnsListener = c -&gt; {
        while (c.next()) {
            updateTableColumnListeners(c.getAddedSubList(), c.getRemoved());
        }
    };

    private final InvalidationListener columnTextListener = observable -&gt; {
        TableColumnBase&lt;?,?&gt; column = (TableColumnBase&lt;?,?&gt;) ((StringProperty)observable).getBean();
        CheckMenuItem menuItem = columnMenuItems.get(column);
        if (menuItem != null) {
            menuItem.setText(getText(column.getText(), column));
        }
    };

    private final WeakInvalidationListener weakTableWidthListener =
            new WeakInvalidationListener(tableWidthListener);

    private final WeakInvalidationListener weakTablePaddingListener =
            new WeakInvalidationListener(tablePaddingListener);

    private final WeakListChangeListener weakVisibleLeafColumnsListener =
            new WeakListChangeListener(visibleLeafColumnsListener);

    private final WeakListChangeListener weakTableColumnsListener =
            new WeakListChangeListener(tableColumnsListener);

    private final WeakInvalidationListener weakColumnTextListener =
            new WeakInvalidationListener(columnTextListener);



    /***************************************************************************
     *                                                                         *
     * Constructor                                                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TableHeaderRow instance to visually represent the column
     * header area of controls such as {@link javafx.scene.control.TableView} and
     * {@link javafx.scene.control.TreeTableView}.
     *
     * @param skin The skin used by the UI control.
     */
    public TableHeaderRow(final TableViewSkinBase skin) {
        this.tableSkin = skin;
        this.flow = skin.flow;

        getStyleClass().setAll(&quot;column-header-background&quot;);

        // clip the header so it doesn't show outside of the table bounds
        clip = new Rectangle();
        clip.setSmooth(false);
        clip.heightProperty().bind(heightProperty());
        setClip(clip);

        // listen to table width to keep header in sync
        updateTableWidth();
        tableSkin.getSkinnable().widthProperty().addListener(weakTableWidthListener);
        tableSkin.getSkinnable().paddingProperty().addListener(weakTablePaddingListener);
        TableSkinUtils.getVisibleLeafColumns(skin).addListener(weakVisibleLeafColumnsListener);

        // popup menu for hiding/showing columns
        columnPopupMenu = new ContextMenu();
        updateTableColumnListeners(TableSkinUtils.getColumns(tableSkin), Collections.&lt;TableColumnBase&lt;?,?&gt;&gt;emptyList());
        TableSkinUtils.getVisibleLeafColumns(skin).addListener(weakTableColumnsListener);
        TableSkinUtils.getColumns(tableSkin).addListener(weakTableColumnsListener);

        // drag header region. Used to indicate the current column being reordered
        dragHeader = new StackPane();
        dragHeader.setVisible(false);
        dragHeader.getStyleClass().setAll(&quot;column-drag-header&quot;);
        dragHeader.setManaged(false);
        dragHeader.setMouseTransparent(true);
        dragHeader.getChildren().add(dragHeaderLabel);

        // the header lives inside a NestedTableColumnHeader
        NestedTableColumnHeader rootHeader = createRootHeader();
        setRootHeader(rootHeader);
        rootHeader.setFocusTraversable(false);
        rootHeader.setTableHeaderRow(this);

        // The 'filler' area that extends from the right-most column to the edge
        // of the tableview, or up to the 'column control' button
        filler = new Region();
        filler.getStyleClass().setAll(&quot;filler&quot;);

        // Give focus to the table when an empty area of the header row is clicked.
        // This ensures the user knows that the table has focus.
        setOnMousePressed(e -&gt; {
            skin.getSkinnable().requestFocus();
        });

        // build the corner region button for showing the popup menu
        final StackPane image = new StackPane();
        image.setSnapToPixel(false);
        image.getStyleClass().setAll(&quot;show-hide-column-image&quot;);
        cornerRegion = new StackPane() {
            @Override protected void layoutChildren() {
                double imageWidth = image.snappedLeftInset() + image.snappedRightInset();
                double imageHeight = image.snappedTopInset() + image.snappedBottomInset();

                image.resize(imageWidth, imageHeight);
                positionInArea(image, 0, 0, getWidth(), getHeight() - 3,
                        0, HPos.CENTER, VPos.CENTER);
            }
        };
        cornerRegion.getStyleClass().setAll(&quot;show-hide-columns-button&quot;);
        cornerRegion.getChildren().addAll(image);

        BooleanProperty tableMenuButtonVisibleProperty = TableSkinUtils.tableMenuButtonVisibleProperty(skin);
        if (tableMenuButtonVisibleProperty != null) {
            cornerRegion.visibleProperty().bind(tableMenuButtonVisibleProperty);
        };

        cornerRegion.setOnMousePressed(me -&gt; {
            // show a popupMenu which lists all columns
            columnPopupMenu.show(cornerRegion, Side.BOTTOM, 0, 0);
            me.consume();
        });

        // the actual header
        // the region that is anchored above the vertical scrollbar
        // a 'ghost' of the header being dragged by the user to force column
        // reordering
        getChildren().addAll(filler, rootHeader, cornerRegion, dragHeader);
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- reordering
    private BooleanProperty reordering = new SimpleBooleanProperty(this, &quot;reordering&quot;, false) {
        @Override protected void invalidated() {
            TableColumnHeader r = getReorderingRegion();
            if (r != null) {
                double dragHeaderHeight = r.getNestedColumnHeader() != null ?
                        r.getNestedColumnHeader().getHeight() :
                        getReorderingRegion().getHeight();

                dragHeader.resize(dragHeader.getWidth(), dragHeaderHeight);
                dragHeader.setTranslateY(getHeight() - dragHeaderHeight);
            }
            dragHeader.setVisible(isReordering());
        }
    };
    final void setReordering(boolean value) {
        this.reordering.set(value);
    }
    final boolean isReordering() {
        return reordering.get();
    }
    final BooleanProperty reorderingProperty() {
        return reordering;
    }

    // --- root header
    /*
     * The header row is actually just one NestedTableColumnHeader that spans
     * the entire width. Nested within this is the TableColumnHeader's and
     * NestedTableColumnHeader's, as necessary. This makes it nice and clean
     * to handle column reordering - we basically enforce the rule that column
     * reordering only occurs within a single NestedTableColumnHeader, and only
     * at that level.
     */
    private ReadOnlyObjectWrapper&lt;NestedTableColumnHeader&gt; rootHeader = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;rootHeader&quot;);
    private final ReadOnlyObjectProperty&lt;NestedTableColumnHeader&gt; rootHeaderProperty() {
        return rootHeader.getReadOnlyProperty();
    }
    final NestedTableColumnHeader getRootHeader() {
        return rootHeader.get();
    }
    private final void setRootHeader(NestedTableColumnHeader value) {
        rootHeader.set(value);
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected void layoutChildren() {
        double x = scrollX;
        double headerWidth = snapSizeX(getRootHeader().prefWidth(-1));
        double prefHeight = getHeight() - snappedTopInset() - snappedBottomInset();
        double cornerWidth = snapSizeX(flow.getVbar().prefWidth(-1));

        // position the main nested header
        getRootHeader().resizeRelocate(x, snappedTopInset(), headerWidth, prefHeight);

        // position the filler region
        final Control control = tableSkin.getSkinnable();
        if (control == null) {
            return;
        }

        final BooleanProperty tableMenuButtonVisibleProperty = TableSkinUtils.tableMenuButtonVisibleProperty(tableSkin);

        final double controlInsets = control.snappedLeftInset() + control.snappedRightInset();
        double fillerWidth = tableWidth - headerWidth + filler.getInsets().getLeft() - controlInsets;
        fillerWidth -= tableMenuButtonVisibleProperty != null &amp;&amp; tableMenuButtonVisibleProperty.get() ? cornerWidth : 0;
        filler.setVisible(fillerWidth &gt; 0);
        if (fillerWidth &gt; 0) {
            filler.resizeRelocate(x + headerWidth, snappedTopInset(), fillerWidth, prefHeight);
        }

        // position the top-right rectangle (which sits above the scrollbar)
        cornerRegion.resizeRelocate(tableWidth - cornerWidth, snappedTopInset(), cornerWidth, prefHeight);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height) {
        return getRootHeader().prefWidth(height);
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width) {
        return computePrefHeight(width);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width) {
        // we hardcode 24.0 here to avoid RT-37616, where the
        // entire header row would disappear when all columns were hidden.
        double headerPrefHeight = getRootHeader().prefHeight(width);
        headerPrefHeight = headerPrefHeight == 0.0 ? 24.0 : headerPrefHeight;
        return snappedTopInset() + headerPrefHeight + snappedBottomInset();
    }

    // used to be protected to allow subclasses to modify the horizontal scrolling,
    // but made private again for JDK 9
    void updateScrollX() {
        scrollX = flow.getHbar().isVisible() ? -flow.getHbar().getValue() : 0.0F;
        requestLayout();

        // Fix for RT-36392: without this call even though we call requestLayout()
        // we don't seem to ever see the layoutChildren() method above called,
        // which means the layout is not always updated to use the latest scrollX.
        layout();
    }

    // used to be protected to allow subclass to customise the width, to allow for features
    // such as row headers, but made private again for JDK 9
    private void updateTableWidth() {
        // snapping added for RT-19428
        final Control c = tableSkin.getSkinnable();
        if (c == null) {
            this.tableWidth = 0;
        } else {
            Insets insets = c.getInsets() == null ? Insets.EMPTY : c.getInsets();
            double padding = snapSizeX(insets.getLeft()) + snapSizeX(insets.getRight());
            this.tableWidth = snapSizeX(c.getWidth()) - padding;
        }

        clip.setWidth(tableWidth);
    }

    /**
     * Creates a new NestedTableColumnHeader instance. By default this method should not be overridden, but in some
     * circumstances it makes sense (e.g. testing, or when extreme customization is desired).
     *
     * @return A new NestedTableColumnHeader instance.
     */
    protected NestedTableColumnHeader createRootHeader() {
        return new NestedTableColumnHeader(null);
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    TableColumnHeader getReorderingRegion() {
        return reorderingRegion;
    }

    void setReorderingColumn(TableColumnBase rc) {
        dragHeaderLabel.setText(rc == null ? &quot;&quot; : rc.getText());
    }

    void setReorderingRegion(TableColumnHeader reorderingRegion) {
        this.reorderingRegion = reorderingRegion;

        if (reorderingRegion != null) {
            dragHeader.resize(reorderingRegion.getWidth(), dragHeader.getHeight());
        }
    }

    void setDragHeaderX(double dragHeaderX) {
        dragHeader.setTranslateX(dragHeaderX);
    }

    TableColumnHeader getColumnHeaderFor(final TableColumnBase&lt;?,?&gt; col) {
        if (col == null) return null;
        List&lt;TableColumnBase&lt;?,?&gt;&gt; columnChain = new ArrayList&lt;&gt;();
        columnChain.add(col);

        TableColumnBase&lt;?,?&gt; parent = col.getParentColumn();
        while (parent != null) {
            columnChain.add(0, parent);
            parent = parent.getParentColumn();
        }

        // we now have a list from top to bottom of a nested column hierarchy,
        // and we can now navigate down to retrieve the header with ease
        TableColumnHeader currentHeader = getRootHeader();
        for (int depth = 0; depth &lt; columnChain.size(); depth++) {
            // this is the column we are looking for at this depth
            TableColumnBase&lt;?,?&gt; column = columnChain.get(depth);

            // and now we iterate through the nested table column header at this
            // level to get the header
            currentHeader = getColumnHeaderFor(column, currentHeader);
        }
        return currentHeader;
    }

    private TableColumnHeader getColumnHeaderFor(final TableColumnBase&lt;?,?&gt; col, TableColumnHeader currentHeader) {
        if (currentHeader instanceof NestedTableColumnHeader) {
            List&lt;TableColumnHeader&gt; headers = ((NestedTableColumnHeader)currentHeader).getColumnHeaders();

            for (int i = 0; i &lt; headers.size(); i++) {
                TableColumnHeader header = headers.get(i);
                if (header.getTableColumn() == col) {
                    return header;
                }
            }
        }

<A NAME="33"></A>        return null;
    }

    private void updateTableColumnListeners(List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; added, List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; removed) <FONT color="#736aff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#33',2,'match52-top.html#33',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        // remove binding from all removed items
        for (TableColumnBase tc : removed) {
            remove(tc);
        }

        rebuildColumnMenu();
    }

    privat</B></FONT>e void remove(TableColumnBase&lt;?,?&gt; col) {
        if (col == null) return;

        CheckMenuItem item = columnMenuItems.remove(col);
        if (item != null) {
            col.textProperty().removeListener(weakColumnTextListener);
            item.selectedProperty().unbindBidirectional(col.visibleProperty());

            columnPopupMenu.getItems().remove(item);
        }

        if (! col.getColumns().isEmpty()) {
            for (TableColumnBase tc : col.getColumns()) {
                remove(tc);
            }
        }
    }

    private void rebuildColumnMenu() {
        columnPopupMenu.getItems().clear();

        for (TableColumnBase&lt;?,?&gt; col : TableSkinUtils.getColumns(tableSkin)) {
            // we only create menu items for leaf columns, visible or not
            if (col.getColumns().isEmpty()) {
                createMenuItem(col);
            } else {
                List&lt;TableColumnBase&lt;?,?&gt;&gt; leafColumns = getLeafColumns(col);
                for (TableColumnBase&lt;?,?&gt; _col : leafColumns) {
                    createMenuItem(_col);
                }
            }
        }
    }

    private List&lt;TableColumnBase&lt;?,?&gt;&gt; getLeafColumns(TableColumnBase&lt;?,?&gt; col) {
        List&lt;TableColumnBase&lt;?,?&gt;&gt; leafColumns = new ArrayList&lt;&gt;();

        for (TableColumnBase&lt;?,?&gt; _col : col.getColumns()) {
            if (_col.getColumns().isEmpty()) {
                leafColumns.add(_col);
            } else {
                leafColumns.addAll(getLeafColumns(_col));
            }
        }

        return leafColumns;
    }

    private void createMenuItem(TableColumnBase&lt;?,?&gt; col) {
        CheckMenuItem item = columnMenuItems.get(col);
        if (item == null) {
            item = new CheckMenuItem();
            columnMenuItems.put(col, item);
        }

        // bind column text and isVisible so that the menu item is always correct
        item.setText(getText(col.getText(), col));
        col.textProperty().addListener(weakColumnTextListener);

        // ideally we would have API to observe the binding status of a property,
        // but for now that doesn't exist, so we set this once and then forget
        item.setDisable(col.visibleProperty().isBound());

        // fake bidrectional binding (a real one was used here but resulted in JBS-8136468)
        item.setSelected(col.isVisible());
        final CheckMenuItem _item = item;
        item.selectedProperty().addListener(o -&gt; {
            if (col.visibleProperty().isBound()) return;
            col.setVisible(_item.isSelected());
        });
        col.visibleProperty().addListener(o -&gt; _item.setSelected(col.isVisible()));

        columnPopupMenu.getItems().add(item);
    }

    /*
     * Function used for building the strings in the popup menu
     */
    private String getText(String text, TableColumnBase col) {
        String s = text;
        TableColumnBase parentCol = col.getParentColumn();
        while (parentCol != null) {
            if (isColumnVisibleInHeader(parentCol, TableSkinUtils.getColumns(tableSkin))) {
                s = parentCol.getText() + MENU_SEPARATOR + s;
            }
            parentCol = parentCol.getParentColumn();
        }
        return s;
    }

    // We need to show strings properly. If a column has a parent column which is
    // not inserted into the TableView columns list, it effectively doesn't have
    // a parent column from the users perspective. As such, we shouldn't include
    // the parent column text in the menu. Fixes RT-14482.
    private boolean isColumnVisibleInHeader(TableColumnBase col, List columns) {
        if (col == null) return false;

        for (int i = 0; i &lt; columns.size(); i++) {
            TableColumnBase column = (TableColumnBase) columns.get(i);
            if (col.equals(column)) return true;

            if (! column.getColumns().isEmpty()) {
                boolean isVisible = isColumnVisibleInHeader(col, column.getColumns());
                if (isVisible) return true;
            }
        }

        return false;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.fxml/com/sun/javafx/fxml/expression/Operator.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.fxml.expression;

<A NAME="31"></A>

enum Operator {
    <FONT color="#3ea99f"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#31',2,'match52-top.html#31',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>NEGATE(6),
    NOT(6),
    MULTIPLY(5),
    DIVIDE(5),
    MODULO(5),
    ADD(4)</B></FONT>,
    SUBTRACT(4),
    GREATER_THAN(3),
    GREATER_THAN_OR_EQUAL_TO(3),
    LESS_THAN(3),
    LESS_THAN_OR_EQUAL_TO(3),
    EQUAL_TO(2),
    NOT_EQUAL_TO(2),
    AND(1),
    OR(0);
    private final int priority;

    public static final int MAX_PRIORITY = 6;

    Operator(int priority) {
        this.priority = priority;
    }

    public int getPriority() {
        return priority;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/Clipboard.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui;

import com.sun.glass.ui.delegate.ClipboardDelegate;

import java.lang.annotation.Native;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import java.nio.ByteBuffer;

public class Clipboard {
    /**
     * predefined mime types
     * Have to be synchronized with native realization.
     */
    @Native public final static String TEXT_TYPE = &quot;text/plain&quot;;
    @Native public final static String HTML_TYPE = &quot;text/html&quot;;
    @Native public final static String RTF_TYPE = &quot;text/rtf&quot;;
    @Native public final static String URI_TYPE = &quot;text/uri-list&quot;;//http://www.ietf.org/rfc/rfc2483.txt
    @Native public final static String FILE_LIST_TYPE = &quot;application/x-java-file-list&quot;;
    @Native public final static String RAW_IMAGE_TYPE = &quot;application/x-java-rawimage&quot;;
    @Native public final static String DRAG_IMAGE = &quot;application/x-java-drag-image&quot;;
    @Native public final static String DRAG_IMAGE_OFFSET = &quot;application/x-java-drag-image-offset&quot;;
    @Native public final static String IE_URL_SHORTCUT_FILENAME = &quot;text/ie-shortcut-filename&quot;;

    /**
     * predefined drop-effect actions and combinations.
     */
    @Native public final static int ACTION_NONE = 0x0;
    @Native public final static int ACTION_COPY = 0x1;
    @Native public final static int ACTION_MOVE = 0x2;
    @Native public final static int ACTION_REFERENCE = 0x40000000;
    @Native public final static int ACTION_COPY_OR_MOVE = ACTION_COPY | ACTION_MOVE;
    @Native public final static int ACTION_ANY       = 0x4FFFFFFF;

    /**
     * predefined clipboard name for system shared buffers
     */
    @Native public final static String DND = &quot;DND&quot;;
    @Native public final static String SYSTEM = &quot;SYSTEM&quot;;
    @Native public final static String SELECTION = &quot;SELECTION&quot;;

    private final static Map &lt;String, Clipboard&gt; clipboards  = new HashMap &lt;String, Clipboard&gt; ();
    private final static ClipboardDelegate delegate = PlatformFactory.getPlatformFactory().createClipboardDelegate();

    private final HashSet &lt;ClipboardAssistance&gt; assistants  =  new HashSet &lt;ClipboardAssistance&gt; ();
    private final String name;
    private final Object localDataProtector = new Object();
    private HashMap &lt;String, Object&gt; localSharedData;
    private ClipboardAssistance dataSource;

    /**
     * combination of ACTION_XXXX constants
     */
    protected int supportedActions = ACTION_COPY;

    protected Clipboard (String name) {
        Application.checkEventThread();
        this.name = name;
    }

    public void add (ClipboardAssistance assistant) {
        Application.checkEventThread();
        synchronized(assistants) {
            assistants.add(assistant);
        }
    }

    public void remove (ClipboardAssistance assistant) {
        Application.checkEventThread();
        synchronized(localDataProtector) {
            if (assistant==dataSource) {
                dataSource = null;
            }
        }
        boolean needClose;
        synchronized(assistants) {
            assistants.remove(assistant);
            needClose = assistants.isEmpty();
        }

        if (needClose) {
            synchronized(clipboards) {
                clipboards.remove(name);
            }
            close();
        }
    }

    protected void setSharedData (
            ClipboardAssistance dataSource,
            HashMap&lt;String, Object&gt; cacheData,
            int supportedActions)
    {
        Application.checkEventThread();
        synchronized(localDataProtector) {
            localSharedData = (HashMap&lt;String, Object&gt;) cacheData.clone();
            this.supportedActions = supportedActions;
            this.dataSource = dataSource;
        }
    }

    /**
     *
     * @param cacheData
     * @param supportedActions combination of ACTION_XXXX consts
     */
    public void flush(
        ClipboardAssistance dataSource,
        HashMap&lt;String, Object&gt; cacheData,
        int supportedActions)
    {
        Application.checkEventThread();
        setSharedData(dataSource, cacheData, supportedActions);
        contentChanged();
    }

    public int getSupportedSourceActions() {
        Application.checkEventThread();
        return this.supportedActions;
    }

    public void setTargetAction(int actionDone) {
        Application.checkEventThread();
        actionPerformed(actionDone);
    }

    public void contentChanged() {
        Application.checkEventThread();
        final HashSet &lt;ClipboardAssistance&gt; _assistants;
        synchronized(assistants) {
            _assistants = (HashSet &lt;ClipboardAssistance&gt;)assistants.clone();
        }
        for (ClipboardAssistance assistant : _assistants) {
            assistant.contentChanged();
        }
    }

    /**
     * Called by system and notifies about successful data transfer.
     * Delete-on-move functionality should be implemented here.
     * @param action Clipboard.ACTION_COPY, or Clipboard.ACTION_MOVE, or Clipboard.ACTION_REFERENCE
     */
    public void actionPerformed(int action) {
        Application.checkEventThread();
        synchronized(localDataProtector) {
            if (null!=dataSource) {
                dataSource.actionPerformed(action);
            }
        }
    }


    public Object getData (String mimeType) {
        Application.checkEventThread();
        synchronized(localDataProtector) {
            if (localSharedData == null) {
                return null;
            }
            Object ret = localSharedData.get(mimeType);
            return (ret instanceof DelayedCallback)
                ? ((DelayedCallback)ret).providedData()
                : ret;
        }
    }

    public String[] getMimeTypes () {
        Application.checkEventThread();
        synchronized(localDataProtector) {
            if (localSharedData == null) {
                return null;
            }
            Set&lt;String&gt; mimes = localSharedData.keySet();
            String [] ret = new String[mimes.size()];
            int i = 0;
            for (String mime : mimes) {
                ret[i++] = mime;
            }
            return ret;
        }
    }

    /* We have only one clipboard for each name.
     * but it can be used by several @code{ClipboardAssistance}s
     */
    protected static Clipboard get (String clipboardName) {
        Application.checkEventThread();
        /* return apropriate one*/
        synchronized(clipboards) {
            if (!clipboards.keySet().contains(clipboardName)) {
                Clipboard newClipboard = delegate.createClipboard(clipboardName);
                if (newClipboard == null) {
                    newClipboard = new Clipboard(clipboardName);
                }
                clipboards.put(clipboardName, newClipboard);
            }
            return clipboards.get(clipboardName);
        }
    }

    public Pixels getPixelsForRawImage(byte rawimage[]) {
        Application.checkEventThread();
        ByteBuffer size = ByteBuffer.wrap(rawimage, 0, 8);
        int width = size.getInt();
        int height = size.getInt();

        ByteBuffer pixels = ByteBuffer.wrap(rawimage, 8, rawimage.length - 8); // drop width+height
        return Application.GetApplication().createPixels(width, height, pixels.slice());
    }

    @Override public String toString () {
        return &quot;Clipboard: &quot; + name + &quot;@&quot; + hashCode();
    }

    protected void close() {
        Application.checkEventThread();
        synchronized(localDataProtector) {
            dataSource = null;
        }
    }

<A NAME="6"></A>    public String getName() {
        Application.checkEventThread();
        return name;
    <FONT color="#50ebec"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#6',2,'match52-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    public static String getActionString (int action) {
        Application.checkEventThread();
        StringBuilder ret = new StringBuilder(&quot;&quot;);
        int[] test = {</B></FONT>
            ACTION_COPY,
            ACTION_MOVE,
            ACTION_REFERENCE};
        String[] canDo = {
            &quot;copy&quot;,
            &quot;move&quot;,
            &quot;link&quot;};
        for (int i =0; i &lt; 3; ++i) {
            if ((test[i] &amp; action) &gt; 0) {
                if (ret.length() &gt; 0) {
                    ret.append(&quot;,&quot;);
                }
                ret.append(canDo[i]);
            }
        }
        return ret.toString();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/Window.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui;

import com.sun.glass.events.MouseEvent;
import com.sun.glass.events.WindowEvent;
import com.sun.prism.impl.PrismSettings;

import java.lang.annotation.Native;

import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

public abstract class Window {

    public static class EventHandler {
        public void handleWindowEvent(Window window, long time, int type) {
        }

        /**
         * Notifies a listener that the screen object for this Window instance
         * has been updated.
         *
         * Note that while the old and new screen objects may be different,
         * they can still represent the same physical screen. This can happen
         * if e.g. only a certain parameter of the screen has been updated such
         * as its scale factor.
         *
         * On some platforms when a window is moved to another physical screen
         * an app can receive this event twice. One representing the physical
         * screen change, and another - the display's parameters change. Note
         * that sending two events instead of just one is platform-specific.
         *
         * The event handler can use the {@link Screen#getNativeScreen} method
         * to determine if this is the same physical screen or not. If the
         * native system always creates new native screen instances, there's no
         * way for the app to distinguish between a real move to another screen
         * or jsut a parameters update event. Since this is a somewhat rare
         * event, an app is advised to always process it the same way.
         *
         * @see Window#getScreen
         */
        public void handleScreenChangedEvent(Window window, long time, Screen oldScreen, Screen newScreen) {
        }

        /**
         * Notifies the listener that the window level has changed. The Level should be one of
         * {@link com.sun.glass.ui.Window.Level#NORMAL}, {@link com.sun.glass.ui.Window.Level#FLOATING},
         * {@link com.sun.glass.ui.Window.Level#TOPMOST}.
         * @param level Level from {@link com.sun.glass.ui.Window.Level} class
         */
        public void handleLevelEvent(int level) {
        }
    }

    // Native object handle (HWND, or NSWindow*, etc.)
    private long ptr;

    // 'Delegate window' ptr. Used in e.g. the Full Screen mode.
    private volatile long delegatePtr = 0L;

    // window list
    static private final LinkedList&lt;Window&gt; visibleWindows = new LinkedList&lt;Window&gt;();
     // Return a list of all visible windows.  Note that on platforms without a native window manager,
     // this list will be sorted in proper z-order
    static public synchronized List&lt;Window&gt; getWindows() {
        Application.checkEventThread();
        return Collections.unmodifiableList(Window.visibleWindows);
    }

    static public List&lt;Window&gt; getWindowsClone() {
        Application.checkEventThread();
        return (List&lt;Window&gt;)visibleWindows.clone();
    }

    // used by Lens Native
    static protected void add(Window window) {
        visibleWindows.add(window);
    }

    static protected void addFirst(Window window) {
        visibleWindows.addFirst(window);
    }

    // used by Lens Native
    static protected void remove(Window window) {
        visibleWindows.remove(window);
    }

    // window style mask

    // visual kind: mutually exclusive
    public static final int UNTITLED        = 0;
    public static final int TITLED          = 1 &lt;&lt; 0;
    public static final int TRANSPARENT     = 1 &lt;&lt; 1;

    // functional type: mutually exclusive
    /**
     * Normal window.
     *
     * Usual top-level window.
     */
    public static final int NORMAL          = 0;
    /**
     * An utility window.
     *
     * Often used for floating toolbars. It has smaller than usual decorations
     * and doesn't display a taskbar button.
     */
    @Native public static final int UTILITY         = 1 &lt;&lt; 2;
    /**
     * A popup window.
     *
     * Used to display popups (tooltips, popup menus, etc.) Note that by
     * default it may display a task-bar button. To hide it the window must be
     * owned.
     */
    @Native public static final int POPUP           = 1 &lt;&lt; 3;

    // These affect window decorations as well as system menu actions,
    // so applicable to both decorated and undecorated windows
    @Native public static final int CLOSABLE        = 1 &lt;&lt; 4;
    @Native public static final int MINIMIZABLE     = 1 &lt;&lt; 5;
    @Native public static final int MAXIMIZABLE     = 1 &lt;&lt; 6;

    /**
     * Indicates that the window trim will draw from right to left.
     */
    @Native public static final int RIGHT_TO_LEFT     = 1 &lt;&lt; 7;

    /**
     * Indicates that a window will have a client area textured the same way as the platform decorations
     * and will not have a border between decorations and the client area.
     * This is supported not on all platforms, the client should check if the feature is supported by using
     * {@link com.sun.glass.ui.Application#supportsUnifiedWindows()}
     */
    @Native public static final int UNIFIED = 1 &lt;&lt; 8;

    final static public class State {
        @Native public static final int NORMAL = 1;
        @Native public static final int MINIMIZED = 2;
        @Native public static final int MAXIMIZED = 3;
    }

    /**
     * Available window levels.
     *
     * Note that on some platforms both {@code FLOATING} and {@code TOPMOST}
     * may represent the same window level.
     *
     * @see #setLevel
     */
    public static final class Level {
        @Native private static final int _MIN = 1;

        /** Normal window level. */
        @Native public static final int NORMAL = 1;

        /** A window level that is above all other NORMAL windows. */
        @Native public static final int FLOATING = 2;

        /** A very topmost window level. May cover system UI elements such as dock, taskbar, etc. */
        @Native public static final int TOPMOST = 3;

        @Native private static final int _MAX = 3;
    }

    private final Window owner;
    private final long parent;
    private final int styleMask;
    private final boolean isDecorated;
    private boolean shouldStartUndecoratedMove = false;

    protected View view = null;
    protected Screen screen = null;
    private MenuBar menubar = null;
    private String title = &quot;&quot;;
    private UndecoratedMoveResizeHelper helper = null;

    private int state = State.NORMAL;
    private int level = Level.NORMAL;
    protected int x = 0;
    protected int y = 0;
    protected int width = 0;
    protected int height = 0;
    private float alpha = 1.0f;
    protected float platformScaleX = 1.0f;
    protected float platformScaleY = 1.0f;
    private float outputScaleX = 1.0f;
    private float outputScaleY = 1.0f;
    private float renderScaleX = 1.0f;
    private float renderScaleY = 1.0f;
    private boolean appletMode = false;

    // This is a workaround for RT-15970: as for embedded windows we don't
    // receive any MOVE notifications from the native platform, we poll
    // the window location on screen from timer and post synthetic events
    // if it has changed
    private Timer embeddedLocationTimer = null;
    private int lastKnownEmbeddedX = 0;
    private int lastKnownEmbeddedY = 0;

    private volatile boolean isResizable = false;
    private volatile boolean isVisible = false;
    private volatile boolean isFocused = false;
    private volatile boolean isFocusable = true;
    private volatile boolean isModal = false;

    // Indicates how many times setEnabled(false) has been called.
    // A value of 0 means the window is enabled.
    private volatile int disableCount = 0;

    private int minimumWidth = 0, minimumHeight = 0;
    private int maximumWidth = Integer.MAX_VALUE, maximumHeight = Integer.MAX_VALUE;

    private EventHandler eventHandler;

    protected abstract long _createWindow(long ownerPtr, long screenPtr, int mask);
    protected Window(Window owner, Screen screen, int styleMask) {
        Application.checkEventThread();
        switch (styleMask &amp; (TITLED | TRANSPARENT)) {
            case UNTITLED:
            case TITLED:
            case TRANSPARENT:
                break;
            default:
                throw new RuntimeException(&quot;The visual kind should be UNTITLED, TITLED, or TRANSPARENT, but not a combination of these&quot;);
        }
        switch (styleMask &amp; (POPUP | UTILITY)) {
            case NORMAL:
            case POPUP:
            case UTILITY:
                break;
            default:
                throw new RuntimeException(&quot;The functional type should be NORMAL, POPUP, or UTILITY, but not a combination of these&quot;);
        }

        if (((styleMask &amp; UNIFIED) != 0)
                &amp;&amp; !Application.GetApplication().supportsUnifiedWindows()) {
           styleMask &amp;= ~UNIFIED;
        }

        if (((styleMask &amp; TRANSPARENT) != 0)
                &amp;&amp; !Application.GetApplication().supportsTransparentWindows()) {
            styleMask &amp;= ~TRANSPARENT;
        }


        this.owner = owner;
        this.parent = 0L;
        this.styleMask = styleMask;
        this.isDecorated = (this.styleMask &amp; Window.TITLED) != 0;

        this.screen = screen != null ? screen : Screen.getMainScreen();
        if (PrismSettings.allowHiDPIScaling) {
            this.platformScaleX = this.screen.getPlatformScaleX();
            this.platformScaleY = this.screen.getPlatformScaleY();
            this.outputScaleX = this.screen.getRecommendedOutputScaleX();
            this.outputScaleY = this.screen.getRecommendedOutputScaleY();
        }

        this.ptr = _createWindow(owner != null ? owner.getNativeHandle() : 0L,
                this.screen.getNativeScreen(), this.styleMask);
        if (this.ptr == 0L) {
            throw new RuntimeException(&quot;could not create platform window&quot;);
        }
    }

    protected abstract long _createChildWindow(long parent);
    /**
     * Constructs a child window of the specified native parent window.
     */
    protected Window(long parent) {
        Application.checkEventThread();
        this.owner = null;
        this.parent = parent;
        this.styleMask = Window.UNTITLED;
        this.isDecorated = false;

        // Note: we can't always catch screen changes when parent is moved...
        this.screen = null; // should infer from the parent

        this.ptr = _createChildWindow(parent);
        if (this.ptr == 0L) {
            throw new RuntimeException(&quot;could not create platform window&quot;);
        }

        if (screen == null) {
            screen = Screen.getMainScreen(); // start with a default

            if (PrismSettings.allowHiDPIScaling) {
                this.platformScaleX = this.screen.getPlatformScaleX();
                this.platformScaleY = this.screen.getPlatformScaleY();
                this.outputScaleX = this.screen.getRecommendedOutputScaleX();
                this.outputScaleY = this.screen.getRecommendedOutputScaleY();
            }
        }
    }

    public boolean isClosed() {
        Application.checkEventThread();
        return this.ptr == 0L;
    }

    private void checkNotClosed() {
        if (this.ptr == 0L) {
            throw new IllegalStateException(&quot;The window has already been closed&quot;);
        }
    }

    protected abstract boolean _close(long ptr);
    public void close() {
        Application.checkEventThread();
        if (this.view != null) {
            if (this.ptr != 0L) {
                _setView(this.ptr, null);
            }
            this.view.setWindow(null);
            this.view.close();
            this.view = null;
        }
        if (this.ptr != 0L) {
            _close(this.ptr);
        }
    }

    private boolean isChild() {
        Application.checkEventThread();
        return this.parent != 0L;
    }

    /** This method returns &quot;lowest-level&quot; native window handle
     * (HWND on Windows, NSWindow on Mac, X11 Window handle on linux-gtk etc.)
     */
    public long getNativeWindow() {
        Application.checkEventThread();
        checkNotClosed();
        return this.delegatePtr != 0L ? this.delegatePtr : this.ptr;
    }

    /**
     * This method returns &quot;higher-level&quot; native window handle.
     * glass-mat-lib-gtk GtkWindow.java returns GtkWindow pointer for example.
     */
    public long getNativeHandle() {
        Application.checkEventThread();
        return this.delegatePtr != 0L ? this.delegatePtr : this.ptr;
    }

    /**
     * return the &quot;raw' pointer needed by subclasses to pass to native routines
     * @return the native pointer.
     */
    public long getRawHandle() {
        return ptr;
    }

    public Window getOwner() {
        Application.checkEventThread();
        return this.owner;
    }

    public View getView() {
        Application.checkEventThread();
        return this.view;
    }

    protected abstract boolean _setView(long ptr, View view);
    public void setView(final View view) {
        Application.checkEventThread();
        checkNotClosed();
        View oldView = getView();
        if (oldView == view) {
            return;
        }

        if (oldView != null) {
            oldView.setWindow(null);
        }
        if (view != null) {
            Window host = view.getWindow();
            if (host != null) {
                host.setView(null);
            }
        }

        if (view != null &amp;&amp; _setView(this.ptr, view)) {
            this.view = view;
<A NAME="11"></A>            this.view.setWindow(this);
            if (this.isDecorated == false) {
                this.helper = new UndecoratedMoveResizeHelper();
            <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#11',2,'match52-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
        } else {
            _setView(this.ptr, null);
            this.view = null;
        }
    }

    public Screen getScreen() {</B></FONT>
        Application.checkEventThread();
        return this.screen;
    }

    protected void setScreen(Screen screen) {
        Application.checkEventThread();

        final Screen old = this.screen;
        this.screen = screen;

        if (this.eventHandler != null) {
            if ((old == null &amp;&amp; this.screen != null) ||
                (old != null &amp;&amp; !old.equals(this.screen))) {
                this.eventHandler.handleScreenChangedEvent(this, System.nanoTime(), old, this.screen);
            }
        }
    }

    public int getStyleMask() {
        Application.checkEventThread();
        return this.styleMask;
    }

    public MenuBar getMenuBar() {
        Application.checkEventThread();
        return this.menubar;
    }

    protected abstract boolean _setMenubar(long ptr, long menubarPtr);
    public void setMenuBar(final MenuBar menubar) {
        Application.checkEventThread();
        checkNotClosed();
        if (_setMenubar(this.ptr, menubar.getNativeMenu())) {
            this.menubar = menubar;
        }
    }

    public boolean isDecorated() {
        Application.checkEventThread();
        return this.isDecorated;
    }

    public boolean isMinimized() {
        Application.checkEventThread();
        return (this.state == State.MINIMIZED);
    }

    protected abstract boolean _minimize(long ptr, boolean minimize);
    public boolean minimize(final boolean minimize) {
        Application.checkEventThread();
        checkNotClosed();
        _minimize(this.ptr, minimize);
        //XXX: this is synchronous? On X11 this may not work
        return isMinimized();
    }

    public boolean isMaximized() {
        Application.checkEventThread();
        return (this.state == State.MAXIMIZED);
    }

    protected abstract boolean _maximize(long ptr, boolean maximize, boolean wasMaximized);
    public boolean maximize(final boolean maximize) {
        Application.checkEventThread();
        checkNotClosed();
        _maximize(ptr, maximize, isMaximized());
        return isMaximized();
    }

    protected void notifyScaleChanged(float platformScaleX, float platformScaleY,
                                      float outputScaleX, float outputScaleY)
    {
        if (!PrismSettings.allowHiDPIScaling) return;
        this.platformScaleX = platformScaleX;
        this.platformScaleY = platformScaleY;
        this.outputScaleX = outputScaleX;
        this.outputScaleY = outputScaleY;
        notifyRescale();
    }

    /**
     * Return the horizontal scale used to communicate window locations,
     * sizes, and event coordinates to/from the platform.
     * @return the horizontal platform scaling for screen locations
     */
    public final float getPlatformScaleX() {
        return platformScaleX;
    }

    /**
     * Return the vertical scale used to communicate window locations,
     * sizes, and event coordinates to/from the platform.
     * @return the vertical platform scaling for screen locations
     */
    public final float getPlatformScaleY() {
        return platformScaleY;
    }

    public void setRenderScaleX(float renderScaleX) {
        if (!PrismSettings.allowHiDPIScaling) return;
        this.renderScaleX = renderScaleX;
    }

    public void setRenderScaleY(float renderScaleY) {
        if (!PrismSettings.allowHiDPIScaling) return;
        this.renderScaleY = renderScaleY;
    }

    /**
     * Return the horizontal scale used for rendering the back buffer.
     * @return the horizontal scaling for rendering
     */
    public final float getRenderScaleX() {
        return renderScaleX;
    }

    /**
     * Return the vertical scale used for rendering to the back buffer.
     * @return the vertical scaling for rendering
     */
    public final float getRenderScaleY() {
        return renderScaleY;
    }

    public float getOutputScaleX() {
        return outputScaleX;
    }

    public float getOutputScaleY() {
        return outputScaleY;
    }

    protected abstract int _getEmbeddedX(long ptr);
    protected abstract int _getEmbeddedY(long ptr);

    private void checkScreenLocation() {
        this.x = _getEmbeddedX(ptr);
        this.y = _getEmbeddedY(ptr);
        if ((this.x != lastKnownEmbeddedX) || (this.y != lastKnownEmbeddedY)) {
            lastKnownEmbeddedX = this.x;
            lastKnownEmbeddedY = this.y;
            handleWindowEvent(System.nanoTime(), WindowEvent.MOVE);
        }
    }

    public int getX() {
        Application.checkEventThread();
        return this.x;
    }

    public int getY() {
        Application.checkEventThread();
        return this.y;
    }

    public int getWidth() {
        Application.checkEventThread();
        return this.width;
    }

    public int getHeight() {
        Application.checkEventThread();
        return this.height;
    }

    protected abstract void _setBounds(long ptr, int x, int y, boolean xSet, boolean ySet,
                                       int w, int h, int cw, int ch,
                                       float xGravity, float yGravity);

    /**
     * Sets the window bounds to the specified values.
     *
     * Gravity values specify how to correct window location if only its size
     * changes (for example when stage decorations are added). User initiated
     * resizing should be ignored and must not influence window location through
     * this mechanism.
     *
     * The corresponding correction formulas are:
     *
     * {@code x -= xGravity * deltaW}
     * {@code y -= yGravity * deltaH}
     *
     * @param x the new window horizontal position, ignored if xSet is set to
     *          false
     * @param y the new window vertical position, ignored if ySet is set to
     *          false
     * @param xSet indicates whether the x parameter is valid
     * @param ySet indicates whether the y parameter is valid
     * @param w the new window width, ignored if set to -1
     * @param h the new window height, ignored if set to -1
     * @param cw the new window content width, ignored if set to -1
     * @param ch the new window content height, ignored if set to -1
     * @param xGravity the xGravity coefficient
     * @param yGravity the yGravity coefficient
     */
    public void setBounds(float x, float y, boolean xSet, boolean ySet,
                          float w, float h, float cw, float ch,
                          float xGravity, float yGravity)
    {
        Application.checkEventThread();
        checkNotClosed();
        float pScaleX = platformScaleX;
        float pScaleY = platformScaleY;
        int px = screen.getPlatformX() + Math.round((x - screen.getX()) * pScaleX);
        int py = screen.getPlatformY() + Math.round((y - screen.getY()) * pScaleY);
        int pw = (int) (w &gt; 0 ? Math.ceil(w * pScaleX) : w);
        int ph = (int) (h &gt; 0 ? Math.ceil(h * pScaleY) : h);
        int pcw = (int) (cw &gt; 0 ? Math.ceil(cw * pScaleX) : cw);
        int pch = (int) (ch &gt; 0 ? Math.ceil(ch * pScaleY) : ch);
        _setBounds(ptr, px, py, xSet, ySet, pw, ph, pcw, pch, xGravity, yGravity);
    }

    public void setPosition(int x, int y) {
        Application.checkEventThread();
        checkNotClosed();
        _setBounds(ptr, x, y, true, true, 0, 0, 0, 0, 0, 0);
    }

    public void setSize(int w, int h) {
        Application.checkEventThread();
        checkNotClosed();
        _setBounds(ptr, 0, 0, false, false, w, h, 0, 0, 0, 0);
    }

    public void setContentSize(int cw, int ch) {
        Application.checkEventThread();
        checkNotClosed();
        _setBounds(ptr, 0, 0, false, false, 0, 0, cw, ch, 0, 0);
    }

    public boolean isVisible() {
        Application.checkEventThread();
        return this.isVisible;
    }

    /**
     * Generates a ViewEvent.MOVE aka insets (might have) changed.
     */
    private void synthesizeViewMoveEvent() {
        final View view = getView();
        if (view != null) {
            view.notifyView(com.sun.glass.events.ViewEvent.MOVE);
        }
    }

    protected abstract boolean _setVisible(long ptr, boolean visible);
    public void setVisible(final boolean visible) {
        Application.checkEventThread();
        if (this.isVisible != visible) {
            if (!visible) {
                if (getView() != null) {
                    getView().setVisible(visible);
                }
                // Avoid native call if the window has been closed already
                if (this.ptr != 0L) {
                    this.isVisible = _setVisible(this.ptr, visible);
                } else {
                    this.isVisible = visible;
                }
                remove(this);
                if (parent != 0) {
                    embeddedLocationTimer.stop();
                }
            } else {
                checkNotClosed();
                this.isVisible = _setVisible(this.ptr, visible);

                if (getView() != null) {
                    getView().setVisible(this.isVisible);
                }
                add(this);
                if (parent != 0) {
                    final Runnable checkRunnable = () -&gt; checkScreenLocation();
                    final Runnable timerRunnable = () -&gt; Application.invokeLater(checkRunnable);
                    embeddedLocationTimer =
                           Application.GetApplication().createTimer(timerRunnable);
                    embeddedLocationTimer.start(16);
                }

                synthesizeViewMoveEvent();
            }
        }
    }

    protected abstract boolean _setResizable(long ptr, boolean resizable);
    public boolean setResizable(final boolean resizable) {
        Application.checkEventThread();
        checkNotClosed();
        if (this.isResizable != resizable) {
            if (_setResizable(this.ptr, resizable)) {
                this.isResizable = resizable;
                synthesizeViewMoveEvent();
            }
        }
        return isResizable;
    }

    public boolean isResizable() {
        Application.checkEventThread();
        return this.isResizable;
    }

    public boolean isUnifiedWindow() {
        //The UNIFIED flag is set only if it is supported
        return (this.styleMask &amp; Window.UNIFIED) != 0;
    }

    public boolean isTransparentWindow() {
        //The TRANSPARENT flag is set only if it is supported
        return (this.styleMask &amp; Window.TRANSPARENT) != 0;
    }

    private static volatile Window focusedWindow = null;
    public static Window getFocusedWindow() {
        Application.checkEventThread();
        return Window.focusedWindow;
    }

    private static void setFocusedWindow(final Window window) {
        Window.focusedWindow = window;
    }

    public boolean isFocused() {
        Application.checkEventThread();
        return this.isFocused;
    }

    protected abstract boolean _requestFocus(long ptr, int event);
    /**
     * Requests or resigns focus on this window.
     *
     * If this is a top-level window (owned or not), then the only possible
     * value for the {@code event} argument is WindowEvent.FOCUS_GAINED.
     * Otherwise, if the window is a child window, the argument may be
     * WindowEvent.FOCUS_LOST, FOCUS_GAINED, FOCUS_GAINED_FORWARD, or
     * FOCUS_GAINED_BACKWARD.
     *
     * @param event one of WindowEvent.FOCUS_LOST, FOCUS_GAINED, FOCUS_GAINED_FORWARD, FOCUS_GAINED_BACKWARD
     *
     * @throws IllegalArgumentException if the argument value is invalid for this window
     *
     * @return {@code true} if the operation succeeded
     */
    public boolean requestFocus(int event) {
        Application.checkEventThread();
        checkNotClosed();

        if (!isChild() &amp;&amp; event != WindowEvent.FOCUS_GAINED) {
            throw new IllegalArgumentException(&quot;Invalid focus event ID for top-level window&quot;);
        }

        if (isChild() &amp;&amp; (event &lt; WindowEvent._FOCUS_MIN || event &gt; WindowEvent._FOCUS_MAX)) {
            throw new IllegalArgumentException(&quot;Invalid focus event ID for child window&quot;);
        }

        if (event == WindowEvent.FOCUS_LOST &amp;&amp; !isFocused()) {
            // Already unfocused, nothing to do
            return true;
        }

        // At this point either A) the user requests focus for a focused or unfocused window,
        // or B) the window is focused and the user requests FOCUS_LOST
        if (!this.isFocusable) {
            // It's obviously A). Fail.
            return false;
        }

        return _requestFocus(this.ptr, event);
    }

    public boolean requestFocus() {
        Application.checkEventThread();
        return requestFocus(WindowEvent.FOCUS_GAINED);
    }

    protected abstract void _setFocusable(long ptr, boolean isFocusable);
    /**
     * Sets whether this window is focusable.
     *
     * Clicking an unfocusable window doesn't activate it.
     */
    public void setFocusable(final boolean isFocusable) {
        Application.checkEventThread();
        checkNotClosed();
        this.isFocusable = isFocusable;
        if (isEnabled()) {
            _setFocusable(this.ptr, isFocusable);
        }
    }

    protected abstract boolean _grabFocus(long ptr);
    protected abstract void _ungrabFocus(long ptr);
    /**
     * Grabs focus on this window.
     *
     * All mouse clicks that occur in this window's client area or client-areas
     * of any of its unfocusable owned windows are delivered as usual. Whenever
     * a click occurs on another app's window (not related via the ownership
     * relation with this one, or a focusable owned window), or on non-client
     * area of any window (titlebar, etc.), or any third-party app's window, or
     * native OS GUI (e.g. a taskbar), the grab is automatically reset, and the
     * window that held the grab receives the FOCUS_UNGRAB event.
     *
     * Note that for this functionality to work correctly, the window must have
     * a focus upon calling this method. All owned popup windows that should be
     * operable during the grabbed focus state (e.g. nested popup menus) must
     * be unfocusable (see {@link #setFocusable}). Clicking a focusable owned
     * window will reset the grab due to a focus transfer.
     *
     * The click that occurs in another window and causes resetting of the grab
     * may or may not be delivered to that other window depending on the native
     * OS behavior.
     *
     * If any of the application's windows already holds the grab, it is reset
     * prior to grabbing the focus for this window. The method may be called
     * multiple times for one window. Subsequent calls do not affect the grab
     * status unless it is reset between the calls, in which case the focus
     * is grabbed again.
     *
     * Note that grabbing the focus on an application window may prevent
     * delivering certain events to other applications until the grab is reset.
     * Therefore, if the application has finished showing popup windows based
     * on a user action (e.g. clicking a menu item), and doesn't require the
     * grab any more, it should call the {@link #ungrabFocus} method. The
     * FOCUS_UNGRAB event signals that the grab has been reset.
     *
     * A user event handler associated with a menu item must be invoked after
     * resetting the grab. Otherwise, if a developer debugs the application and
     * has installed a breakpoint in the event handler, the debugger may become
     * unoperable due to events blocking for other applications on some
     * platforms.
     *
     * @return {@code true} if the operation is successful
     * @throws IllegalStateException if the window isn't focused currently
     */
    public boolean grabFocus() {
        Application.checkEventThread();
        checkNotClosed();

        if (!isFocused()) {
            throw new IllegalStateException(&quot;The window must be focused when calling grabFocus()&quot;);
        }

        return _grabFocus(this.ptr);
    }

    /**
     * Manually ungrabs focus grabbed on this window previously.
     *
     * This method resets the grab, and forces sending of the FOCUS_UNGRAB
     * event. It should be used when popup windows (such as menus) should be
     * dismissed manually, e.g. when a user clicks a menu item which usually
     * causes the menus to hide.
     *
     * @see #grabFocus
     */
    public void ungrabFocus() {
        Application.checkEventThread();
        checkNotClosed();
        _ungrabFocus(this.ptr);
    }

    public String getTitle() {
        Application.checkEventThread();
        return this.title;
    }

    protected abstract boolean _setTitle(long ptr, String title);
    public void setTitle(String title) {
        Application.checkEventThread();
        checkNotClosed();
        if (title == null) {
            title = &quot;&quot;;
        }
        if (!title.equals(this.title)) {
            if (_setTitle(this.ptr, title)) {
                this.title = title;
            }
        }
    }

    protected abstract void _setLevel(long ptr, int level);
    /**
     * Set the level of this window in the z-order.
     *
     * @param level one of the constants from {@link Window.Level}
     * @see Window.Level
     */
    public void setLevel(final int level) {
        Application.checkEventThread();
        checkNotClosed();
        if (level &lt; Level._MIN || level &gt; Level._MAX) {
            throw new IllegalArgumentException(&quot;Level should be in the range [&quot; + Level._MIN + &quot;..&quot; + Level._MAX + &quot;]&quot;);
        }
        if (this.level != level) {
            _setLevel(this.ptr, level);
            this.level = level;
        }
    }

    public int getLevel() {
        Application.checkEventThread();
        return this.level;
    }

    private boolean isInFullscreen() {
        final View view = getView();
        return view == null ? false : view.isInFullscreen();
    }

    // Invoked from the View class before sending FULLSCREEN_ to the View.EventHandler
    void notifyFullscreen(boolean entered) {
        final float alpha = getAlpha();
        if (alpha &lt; 1f) {
            if (entered) {
                // Reset alpha at native level
                _setAlpha(this.ptr, 1f);
            } else {
                // restore the current opacity level
                setAlpha(alpha);
            }
        }
    }

    protected abstract void _setAlpha(long ptr, float alpha);
    /**
     * Sets the uniform translucency level for this window.
     *
     * In the full screen mode the native window is always fully opaque.
     * The requested opacity level is applied upon exiting the full screen
     * mode only.
     *
     * @param alpha a value in the range [0..1f] (transparent..fully-opaque)
     */
    public void setAlpha(final float alpha) {
        Application.checkEventThread();
        checkNotClosed();
        if (alpha &lt; 0f || alpha &gt; 1f) {
            throw new IllegalArgumentException(&quot;Alpha should be in the range [0f..1f]&quot;);
        }

        this.alpha = alpha;

        if (alpha &lt; 1f &amp;&amp; isInFullscreen()) {
            return;
        }

        _setAlpha(this.ptr, this.alpha);
    }

    public float getAlpha() {
        Application.checkEventThread();
        return this.alpha;
    }

    public boolean getAppletMode() {
        return appletMode;
    }

    public void setAppletMode(boolean appletMode) {
        this.appletMode = appletMode;
    }

    protected abstract boolean _setBackground(long ptr, float r, float g, float b);
    /**
     * Set the background of the window.
     *
     * In most cases the View covers the whole window, so the background color
     * of the window is never seen by the user. However, a window w/o a view
     * does display the background color in its content area.
     *
     * On some platforms setting the background color may produce flickering
     * when painting the content area of the View (even though the View covers
     * the whole window).  Therefore it is recommended to set the background
     * color to windows w/o views only.
     */
    public boolean setBackground(final float r, final float g, final float b) {
        Application.checkEventThread();
        checkNotClosed();
        return _setBackground(this.ptr, r, g, b);
    }

    public boolean isEnabled() {
        Application.checkEventThread();
        return this.disableCount == 0;
    }

    protected abstract void _setEnabled(long ptr, boolean enabled);
    /**
     * Enables or disables the window.
     *
     * A disabled window is unfocusable by definition.
     * Also, key or mouse events aren't generated for disabled windows.
     *
     * When a user tries to activate a disabled window, or the window gets
     * accidentally brought to the top of the stacking order, the window
     * generates the FOCUS_DISABLED window event. A Glass client should react
     * to this event and bring the currently active modal blocker of the
     * disabled window to top by calling blocker's minimize(false), toFront(),
     * and requestFocus() methods. It may also 'blink' the blocker window to
     * further attract user's attention.
     *
     * It's strongly recommended to process the FOCUS_DISABLED event
     * synchronously and as fast as possible to avoid any possible visual and
     * behavioral artifacts. Note that a disabled window may by no means gain
     * the input focus. The purpose of this event is to make sure that the
     * current modal blocker window is always visible to the user, and the user
     * understands why he can't interact with a disabled window.
     *
     * The method supports nested calls. If you disable the window twice
     * with two calls to setEnabled(false), you must call setEnabled(true)
     * twice as well in order to enable it afterwards. This is to support
     * 'nested' modal dialogs when one modal dialog opens another one.
     */
    public void setEnabled(boolean enabled) {
        Application.checkEventThread();
        checkNotClosed();
        if (!enabled) {
            if (++this.disableCount &gt; 1) {
                // already disabled
                return;
            }
        } else {
            if (this.disableCount == 0) {
                //should report a warning about an extra enable call ?
                return;
            }
            if (--this.disableCount &gt; 0) {
                // not yet enabled
                return;
            }
        }

        //TODO: on Windows _setFocusable(this.ptr, isEnabled() ? this.isFocusable : false);
        _setEnabled(this.ptr, isEnabled());
    }

    public int getMinimumWidth() {
        Application.checkEventThread();
        return this.minimumWidth;
    }

    public int getMinimumHeight() {
        Application.checkEventThread();
        return this.minimumHeight;
    }

    public int getMaximumWidth() {
        Application.checkEventThread();
        return this.maximumWidth;
    }

    public int getMaximumHeight() {
        Application.checkEventThread();
        return this.maximumHeight;
    }

    protected abstract boolean _setMinimumSize(long ptr, int width, int height);
    /**
     * Sets the minimum size for this window.
     * A value of zero indicates no restriction.
     * If the native platform is unable to apply the constraints,
     * the values returned by getMinimumWidth()/Height() won't change.
     *
     * @throws IllegalArgumentException if width or height &lt; 0
     */
    public void setMinimumSize(int width, int height) {
        Application.checkEventThread();
        if (width &lt; 0 || height &lt; 0) {
            throw new IllegalArgumentException(&quot;The width and height must be &gt;= 0. Got: width=&quot; + width + &quot;; height=&quot; + height);
        }
        checkNotClosed();
        if (_setMinimumSize(this.ptr, width, height)) {
            this.minimumWidth = width;
            this.minimumHeight = height;
        }
    }

    protected abstract boolean _setMaximumSize(long ptr, int width, int height);
    /**
     * Sets the maximum size for this window.
     * A value of {@code Integer.MAX_VALUE} indicates no restriction.
     * If the native platform is unable to apply the constraints,
     * the values returned by getMaximumWidth()/Height() won't change.
     *
     * @throws IllegalArgumentException if width or height &lt; 0
     */
    public void setMaximumSize(int width, int height) {
        Application.checkEventThread();
        if (width &lt; 0 || height &lt; 0) {
            throw new IllegalArgumentException(&quot;The width and height must be &gt;= 0. Got: width=&quot; + width + &quot;; height=&quot; + height);
        }
        checkNotClosed();
        if (_setMaximumSize(this.ptr,
                    // for easier handling in native:
                    width == Integer.MAX_VALUE ? -1 : width,
                    height == Integer.MAX_VALUE ? -1 : height))
        {
            this.maximumWidth = width;
            this.maximumHeight = height;
        }
    }


    protected abstract void _setIcon(long ptr, Pixels pixels);

    // In the future we may want to pass a collection of Pixels, so that
    // the native platform could pick up the icon with the best dimensions
    public void setIcon(final Pixels pixels) {
        Application.checkEventThread();
        checkNotClosed();
        _setIcon(this.ptr, pixels);
    }

    protected abstract void _setCursor(long ptr, Cursor cursor);

    /**
     * Sets given cursor as the cursor for this window.
     * If the cursor is NONE, it is automatically hidden,
     * otherwise it is automatically shown.
     * @see Cursor#setVisible(boolean)
     */
    public void setCursor(Cursor cursor) {
        Application.checkEventThread();
        _setCursor(this.ptr, cursor);
    }

    protected abstract void _toFront(long ptr);
    /**
     * Bring the window to front in the z-order.
     * This method DOES NOT activate the window. To make it active use
     * the requestFocus() method right after calling toFront().
     */
    public void toFront() {
        Application.checkEventThread();
        checkNotClosed();
        _toFront(ptr);
    }

    protected abstract void _toBack(long ptr);
    /**
     * Send the window to the bottom of the stacking order.
     * This method may or may not de-focus this window
     * depending on the native platform. To make sure some other
     * window is activated, call requestFocus() on that other window.
     */
    public void toBack() {
        Application.checkEventThread();
        checkNotClosed();
        _toBack(this.ptr);
    }

    // *****************************************************
    // modality (prototype using native platform feature)
    // *****************************************************
    protected abstract void _enterModal(long ptr);
    /**
     * Enter modal state blocking everything except our window.
     */
    public void enterModal() {
        checkNotClosed();
        if (this.isModal == false) {
            this.isModal = true;
            _enterModal(this.ptr);
        }
    }

    protected abstract void _enterModalWithWindow(long dialog, long window);
    /**
     * Enter modal state only blocking the given window.
     * On Mac OS X this is done using a dialog sheet.
     */
    public void enterModal(final Window window) {
        checkNotClosed();
        if (this.isModal == false) {
            this.isModal = true;
            _enterModalWithWindow(this.ptr, window.getNativeHandle());
        }
    }

    protected abstract void _exitModal(long ptr);
    public void exitModal() {
        checkNotClosed();
        if (this.isModal == true) {
            _exitModal(this.ptr);
            this.isModal = false;
        }
    }

    public boolean isModal() {
        return this.isModal;
    }

    /** Only used on Mac when run inside a plugin */
    public void dispatchNpapiEvent(Map eventInfo) {
        Application.checkEventThread();
        throw new RuntimeException(&quot;This operation is not supported on this platform&quot;);
    }

    public EventHandler getEventHandler() {
        Application.checkEventThread();
        return eventHandler;
    }

    public void setEventHandler(EventHandler eventHandler) {
        Application.checkEventThread();
        this.eventHandler = eventHandler;
    }

    /**
     * Enables unconditional start of window move operation when
     * mouse is dragged in the client area.
     */
    public void setShouldStartUndecoratedMove(boolean v) {
        Application.checkEventThread();
        this.shouldStartUndecoratedMove = v;
    }

    // *****************************************************
    // notification callbacks
    // *****************************************************
    protected void notifyClose() {
        handleWindowEvent(System.nanoTime(), WindowEvent.CLOSE);
    }

    protected void notifyDestroy() {
        // Mac is known to send multiple WillClose notifications for some reason
        if (this.ptr == 0) {
            return;
        }

        handleWindowEvent(System.nanoTime(), WindowEvent.DESTROY);

        this.ptr = 0;

        // Do this after setting ptr to 0 to avoid a call to _setVisible()
        setVisible(false);
    }

    protected void notifyMove(final int x, final int y) {
        this.x = x;
        this.y = y;
        handleWindowEvent(System.nanoTime(), WindowEvent.MOVE);
    }

    protected void notifyRescale() {
        handleWindowEvent(System.nanoTime(), WindowEvent.RESCALE);
    }

    protected void notifyMoveToAnotherScreen(Screen newScreen) {
        setScreen(newScreen);
    }

    protected void setState(int state) {
        this.state = state;
    }

    /**
     * type values:
     *   - WindowEvent.RESIZE
     *   - WindowEvent.MINIMIZE
     *   - WindowEvent.MAXIMIZE
     *   - WindowEvent.RESTORE
     */
    protected void notifyResize(final int type, final int width, final int height) {
        if (type == WindowEvent.MINIMIZE) {
            this.state = State.MINIMIZED;
        } else {
            if (type == WindowEvent.MAXIMIZE) {
                this.state = State.MAXIMIZED;
            } else { // WindowEvent.RESIZE or WindowEvent.RESTORE
                this.state = State.NORMAL;
            }
            this.width = width;
            this.height = height;

            // update moveRect/resizeRect
            if (this.helper != null){
                this.helper.updateRectangles();
            }
        }
        handleWindowEvent(System.nanoTime(), type);

        /*
         * Send RESIZE notification as MAXIMIZE and RESTORE change the window size
         */
        if (type == WindowEvent.MAXIMIZE || type == WindowEvent.RESTORE) {
            handleWindowEvent(System.nanoTime(), WindowEvent.RESIZE);
        }
    }

    protected void notifyFocus(int event) {
        final boolean focused = event != WindowEvent.FOCUS_LOST;

        if (this.isFocused != focused) {
            this.isFocused = focused;
            if (this.isFocused) {
                setFocusedWindow(this);
            } else {
                setFocusedWindow(null);
            }
            handleWindowEvent(System.nanoTime(), event);
        }
    }

    protected void notifyFocusDisabled() {
        handleWindowEvent(System.nanoTime(), WindowEvent.FOCUS_DISABLED);
    }

    protected void notifyFocusUngrab() {
        handleWindowEvent(System.nanoTime(), WindowEvent.FOCUS_UNGRAB);
    }

    protected void notifyDelegatePtr(long ptr) {
        this.delegatePtr = ptr;
    }

    // *****************************************************
    // window event handlers
    // *****************************************************
    protected void handleWindowEvent(long time, int type) {
        if (this.eventHandler != null) {
            this.eventHandler.handleWindowEvent(this, time, type);
        }
    }

    // *****************************************************
    // programmatical move/resize
    // *****************************************************
    /** Sets &quot;programmatical move&quot; rectangle.
     * The rectangle is measured from top of the View:
     * width is View.width, height is size.
     *
     * throws RuntimeException for decorated window.
     */
    public void setUndecoratedMoveRectangle(int size) {
        Application.checkEventThread();
        if (this.isDecorated == true) {
            //throw new RuntimeException(&quot;setUndecoratedMoveRectangle is only valid for Undecorated Window&quot;);
            System.err.println(&quot;Glass Window.setUndecoratedMoveRectangle is only valid for Undecorated Window. In the future this will be hard error.&quot;);
            Thread.dumpStack();
            return;
        }

        if (this.helper != null) {
            this.helper.setMoveRectangle(size);
        }
    }
    /** The method called only for undecorated windows
     * x, y: mouse coordinates (in View space).
     *
     * throws RuntimeException for decorated window.
     */
    public boolean shouldStartUndecoratedMove(final int x, final int y) {
        Application.checkEventThread();
        if (this.shouldStartUndecoratedMove == true) {
            return true;
        }
        if (this.isDecorated == true) {
            return false;
        }

        if (this.helper != null) {
            return this.helper.shouldStartMove(x, y);
        } else {
            return false;
        }
    }

    /** Sets &quot;programmatical resize&quot; rectangle.
     * The rectangle is measured from top of the View:
     * width is View.width, height is size.
     *
     * throws RuntimeException for decorated window.
     */
    public void setUndecoratedResizeRectangle(int size) {
        Application.checkEventThread();
        if ((this.isDecorated == true) || (this.isResizable == false)) {
            //throw new RuntimeException(&quot;setUndecoratedMoveRectangle is only valid for Undecorated Resizable Window&quot;);
            System.err.println(&quot;Glass Window.setUndecoratedResizeRectangle is only valid for Undecorated Resizable Window. In the future this will be hard error.&quot;);
            Thread.dumpStack();
            return;
        }

        if (this.helper != null) {
            this.helper.setResizeRectangle(size);
        }
    }

    /** The method called only for undecorated windows
     * x, y: mouse coordinates (in View space).
     *
     * throws RuntimeException for decorated window.
     */
    public boolean shouldStartUndecoratedResize(final int x, final int y) {
        Application.checkEventThread();
        if ((this.isDecorated == true) || (this.isResizable == false)) {
            return false;
        }

        if (this.helper != null) {
            return this.helper.shouldStartResize(x, y);
        }  else {
            return false;
        }
    }

    /** Mouse event handler for processing programmatical resize/move
     * (for undecorated windows only).
     * Must be called by View.
     * x &amp; y are View coordinates.
     * NOTE: it's package private!
     * @return true if the event is processed by the window,
     *         false if it has to be delivered to the app
     */
    boolean handleMouseEvent(int type, int button, int x, int y, int xAbs, int yAbs) {
        if (this.isDecorated == false) {
            return this.helper.handleMouseEvent(type, button, x, y, xAbs, yAbs);
        }
        return false;
    }

    @Override
    public String toString() {
        Application.checkEventThread();
        return  &quot;Window:&quot;+&quot;\n&quot;
                + &quot;    ptr: &quot; + getNativeWindow() + &quot;\n&quot;
                + &quot;    screen ptr: &quot; + (screen != null ? screen.getNativeScreen() : &quot;null&quot;) + &quot;\n&quot;
                + &quot;    isDecorated: &quot; + isDecorated() + &quot;\n&quot;
                + &quot;    title: &quot; + getTitle() + &quot;\n&quot;
                + &quot;    visible: &quot; + isVisible() + &quot;\n&quot;
                + &quot;    focused: &quot; + isFocused() + &quot;\n&quot;
                + &quot;    modal: &quot; + isModal() + &quot;\n&quot;
                + &quot;    state: &quot; + state + &quot;\n&quot;
                + &quot;    x: &quot; + getX() + &quot;, y: &quot; + getY() + &quot;, w: &quot; + getWidth() + &quot;, h: &quot; + getHeight() + &quot;\n&quot;
                + &quot;&quot;;
    }

    // &quot;programmical&quot; move/resize support for undecorated windows

    static private class TrackingRectangle {
        int size = 0;
        int x = 0, y = 0, width = 0, height = 0;
        boolean contains(final int x, final int y) {
            return ((size &gt; 0) &amp;&amp;
                    (x &gt;= this.x) &amp;&amp; (x &lt; (this.x + this.width)) &amp;&amp;
                        (y &gt;= this.y) &amp;&amp; (y &lt; (this.y + this.height)));
        }
    }

    protected void notifyLevelChanged(int level) {
        this.level = level;
        if (this.eventHandler != null) {
            this.eventHandler.handleLevelEvent(level);
        }
    }

    private class UndecoratedMoveResizeHelper {
        TrackingRectangle moveRect = null;
        TrackingRectangle resizeRect = null;

        boolean inMove = false;         // we are in &quot;move&quot; mode
        boolean inResize = false;       // we are in &quot;resize&quot; mode

        int startMouseX, startMouseY;   // start mouse coords
        int startX, startY;             // start window location (for move)
        int startWidth, startHeight;    // start window size (for resize)

        UndecoratedMoveResizeHelper() {
            this.moveRect = new TrackingRectangle();
            this.resizeRect = new TrackingRectangle();
        }

        void setMoveRectangle(final int size) {
            this.moveRect.size = size;

            this.moveRect.x = 0;
            this.moveRect.y = 0;
            this.moveRect.width = getWidth();
            this.moveRect.height = this.moveRect.size;
        }

        boolean shouldStartMove(final int x, final int y) {
            return this.moveRect.contains(x, y);
        }

        boolean inMove() {
            return this.inMove;
        }

        void startMove(final int x, final int y) {
            this.inMove = true;

            this.startMouseX = x;
            this.startMouseY = y;

            this.startX = getX();
            this.startY = getY();
        }

        void deltaMove(final int x, final int y) {
            int deltaX = x - this.startMouseX;
            int deltaY = y - this.startMouseY;

            setPosition(this.startX + deltaX, this.startY + deltaY);
        }

        void stopMove() {
            this.inMove = false;
        }

        void setResizeRectangle(final int size) {
            this.resizeRect.size = size;

            // set the rect (bottom right corner of the Window)
            this.resizeRect.x = getWidth() - this.resizeRect.size;
            this.resizeRect.y = getHeight() - this.resizeRect.size;
            this.resizeRect.width = this.resizeRect.size;
            this.resizeRect.height = this.resizeRect.size;
        }

        boolean shouldStartResize(final int x, final int y) {
            return this.resizeRect.contains(x, y);
        }

        boolean inResize() {
            return this.inResize;
        }

        void startResize(final int x, final int y) {
            this.inResize = true;

            this.startMouseX = x;
            this.startMouseY = y;

            this.startWidth = getWidth();
            this.startHeight = getHeight();
        }

        void deltaResize(final int x, final int y) {
            int deltaX = x - this.startMouseX;
            int deltaY = y - this.startMouseY;

            setSize(this.startWidth + deltaX, this.startHeight + deltaY);
        }

        protected void stopResize() {
            this.inResize = false;
        }

        void updateRectangles() {
            if (this.moveRect.size &gt; 0) {
                setMoveRectangle(this.moveRect.size);
            }
            if (this.resizeRect.size &gt; 0) {
                setResizeRectangle(this.resizeRect.size);
            }
        }

        boolean handleMouseEvent(final int type, final int button, final int x, final int y, final int xAbs, final int yAbs) {
            switch (type) {
                case MouseEvent.DOWN:
                    if (button == MouseEvent.BUTTON_LEFT) {
                        if (shouldStartUndecoratedMove(x, y) == true) {
                            startMove(xAbs, yAbs);
                            return true;
                        } else if (shouldStartUndecoratedResize(x, y) == true) {
                            startResize(xAbs, yAbs);
                            return true;
                        }
                    }
                    break;

                case MouseEvent.MOVE:
                case MouseEvent.DRAG:
                    if (inMove() == true) {
                        deltaMove(xAbs, yAbs);
                        return true;
                    } else if (inResize() == true) {
                        deltaResize(xAbs, yAbs);
                        return true;
                    }
                    break;

                case MouseEvent.UP:
                    boolean wasProcessed = inMove() || inResize();
                    stopResize();
                    stopMove();
                    return wasProcessed;
            }
            return false;
        }
    }

    /**
     * Requests text input in form of native keyboard for text component
     * contained by this Window. Native text input component is drawn on the place
     * of JavaFX component to cover it completely and to provide native text editing
     * techniques. Any change of text is immediately reflected in JavaFX text component.
     *
     * @param text text to be shown in the native text input component
     * @param type type of text input component @see com.sun.javafx.scene.control.behavior.TextInputTypes
     * @param width width of JavaFX text input component
     * @param height height of JavaFX text input component
     * @param M standard transformation matrix for drawing the native text component derived from JavaFX component
     */
    public void requestInput(String text, int type, double width, double height,
                                double Mxx, double Mxy, double Mxz, double Mxt,
                                double Myx, double Myy, double Myz, double Myt,
                                double Mzx, double Mzy, double Mzz, double Mzt) {
        Application.checkEventThread();
        _requestInput(this.ptr, text, type, width, height,
                        Mxx, Mxy, Mxz, Mxt,
                        Myx, Myy, Myz, Myt,
                        Mzx, Mzy, Mzz, Mzt);
    }

    /**
     * Native keyboard for text input is no longer necessary.
     * Keyboard will be hidden and native text input component too.
     */
    public void releaseInput() {
        Application.checkEventThread();
        _releaseInput(this.ptr);
    }

    protected abstract void _requestInput(long ptr, String text, int type, double width, double height,
                                            double Mxx, double Mxy, double Mxz, double Mxt,
                                            double Myx, double Myy, double Myz, double Myt,
                                            double Mzx, double Mzy, double Mzz, double Mzt);

    protected abstract void _releaseInput(long ptr);

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/MonocleApplication.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui.monocle;

import com.sun.glass.ui.Application;
import com.sun.glass.ui.CommonDialogs.ExtensionFilter;
import com.sun.glass.ui.CommonDialogs.FileChooserResult;
import com.sun.glass.ui.Cursor;
import com.sun.glass.ui.GlassRobot;
import com.sun.glass.ui.Pixels;
import com.sun.glass.ui.Screen;
import com.sun.glass.ui.Size;
import com.sun.glass.ui.Timer;
import com.sun.glass.ui.View;
import com.sun.glass.ui.Window;
import javafx.collections.SetChangeListener;

import java.io.File;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.security.AccessController;
import java.security.PrivilegedAction;

public final class MonocleApplication extends Application {

    private final NativePlatform platform =
            NativePlatformFactory.getNativePlatform();
    private final RunnableProcessor runnableProcessor = platform.getRunnableProcessor();

    /** Bit to indicate that a device has touch support */
    private static final int DEVICE_TOUCH = 0;
    /** Bit to indicate that a device has multitouch support */
    private static final int DEVICE_MULTITOUCH = 1;
    /** Bit to indicate that a device has relative motion pointer support */
    private static final int DEVICE_POINTER = 2;
    /** Bit to indicate that a device has arrow keys and a select key */
    private static final int DEVICE_5WAY = 3;
    /** Bit to indicate that a device has a full PC keyboard */
    private static final int DEVICE_PC_KEYBOARD = 4;
    /** Largest bit used in device capability bitmasks */
    private static final int DEVICE_MAX = 4;
    /** A running count of the numbers of devices with each device capability */
    private int[] deviceFlags = new int[DEVICE_MAX + 1];
    private Thread shutdownHookThread;
    private Runnable renderEndNotifier = () -&gt; platform.getScreen().swapBuffers();

    MonocleApplication() {
        for (InputDevice device : platform.getInputDeviceRegistry().getInputDevices()) {
            updateDeviceFlags(device, true);
        }
        platform.getInputDeviceRegistry().getInputDevices().addListener(
                (SetChangeListener&lt;InputDevice&gt;) change -&gt; {
                    if (change.wasAdded()) {
                        InputDevice device = change.getElementAdded();
                        updateDeviceFlags(device, true);
                    } else if (change.wasRemoved()) {
                        InputDevice device = change.getElementRemoved();
                        updateDeviceFlags(device, false);
                    }
                }
        );
    }

    private void updateDeviceFlags(InputDevice device, boolean added) {
        int modifier = added ? 1 : -1;
        if (device.isTouch()) {
            deviceFlags[DEVICE_TOUCH] += modifier;
        }
        if (device.isMultiTouch()) {
            deviceFlags[DEVICE_MULTITOUCH] += modifier;
        }
        if (device.isRelative()) {
            deviceFlags[DEVICE_POINTER] += modifier;
            if (deviceFlags[DEVICE_POINTER] &gt;= 1  &amp;&amp; added) {
                staticCursor_setVisible(true);
            } else if (deviceFlags[DEVICE_POINTER] &lt; 1 &amp;&amp; !added) {
                staticCursor_setVisible(false);
            }
        }
        if (device.isFullKeyboard()) {
            deviceFlags[DEVICE_PC_KEYBOARD] += modifier;
        }
        if (device.is5Way()) {
            deviceFlags[DEVICE_5WAY] += modifier;
        }
    }

    @Override
    protected void runLoop(Runnable launchable) {
        runnableProcessor.invokeLater(launchable);
        long stackSize = AccessController.doPrivileged(
                (PrivilegedAction&lt;Long&gt;)
                        () -&gt; Long.getLong(&quot;monocle.stackSize&quot;, 0));
        Thread t = new Thread(
                new ThreadGroup(&quot;Event&quot;),
                runnableProcessor,
                &quot;Event Thread&quot;,
                stackSize);
        setEventThread(t);
        t.start();
        shutdownHookThread = new Thread(&quot;Monocle shutdown hook&quot;) {
            @Override public void run() {
            platform.shutdown();
            }
        };
        Runtime.getRuntime().addShutdownHook(shutdownHookThread);
    }

    @Override
    protected void _invokeAndWait(Runnable runnable) {
        runnableProcessor.invokeAndWait(runnable);
    }

    @Override
    protected void _invokeLater(Runnable runnable) {
        runnableProcessor.invokeLater(runnable);
    }

    @Override
    protected Object _enterNestedEventLoop() {
        return runnableProcessor.enterNestedEventLoop();
    }

    @Override
    protected void _leaveNestedEventLoop(Object retValue) {
        runnableProcessor.leaveNestedEventLoop(retValue);
    }

    @Override
    public Window createWindow(Window owner, Screen screen, int styleMask) {
        return new MonocleWindow(owner, screen, styleMask);
    }

    @Override
    public Window createWindow(long parent) {
        return new MonocleWindow(parent);
    }

    @Override
    public View createView() {
        return new MonocleView();
    }

    @Override
    public Cursor createCursor(int type) {
        return new MonocleCursor(type);
    }

    @Override
    public Cursor createCursor(int x, int y, Pixels pixels) {
        return new MonocleCursor(x, y, pixels);
    }

    @Override
    protected void staticCursor_setVisible(boolean visible) {
        NativeCursor cursor = NativePlatformFactory.getNativePlatform().getCursor();
        cursor.setVisibility(deviceFlags[DEVICE_POINTER] &gt;= 1 ? visible : false);
    }

    @Override
    protected Size staticCursor_getBestSize(int width, int height) {
        NativeCursor cursor = NativePlatformFactory.getNativePlatform().getCursor();
        return cursor.getBestSize();
    }

    @Override
    public Pixels createPixels(int width, int height, ByteBuffer data) {
        return new MonoclePixels(width, height, data);
    }

    @Override
    public Pixels createPixels(int width, int height, IntBuffer data) {
        return new MonoclePixels(width, height, data);
    }

    @Override
    public Pixels createPixels(int width, int height, IntBuffer data,
                               float scalex, float scaley)
    {
        return new MonoclePixels(width, height, data, scalex, scaley);
    }

    @Override
    protected int staticPixels_getNativeFormat() {
        return platform.getScreen().getNativeFormat();
    }

    @Override
    public GlassRobot createRobot() {
        return new MonocleRobot();
    }

    @Override
    protected double staticScreen_getVideoRefreshPeriod() {
        return 0.0;
    }

    @Override
<A NAME="17"></A>    protected Screen[] staticScreen_getScreens() {
        NativeScreen ns = platform.getScreen();
        Screen screen = new Screen(1l, // dummy native pointer;
                                   <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#17',2,'match52-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ns.getDepth(),
                                   0, 0, ns.getWidth(), ns.getHeight(),
                                   0, 0, ns.getWidth(), ns.getHeight(),
                                   0, 0, ns.getWidth(), ns.getHeight(),
                                   ns.getDPI(), ns.getDPI(),
                                   ns.getScale(), ns.getScale(),
                                   ns.getScale(), ns.getScale());
        // Move the cursor to the middle of the screen
        MouseState mouseState = new MouseState();
        mouseState.setX(ns.getWidth() / 2);
        mouseState.setY(ns.getHeight() / 2);
        MouseInput.getInstance</B></FONT>().setState(mouseState, false);
        return new Screen[] { screen };
    }

    @Override
    public Timer createTimer(Runnable runnable) {
        return new MonocleTimer(runnable);
    }

    @Override
    protected int staticTimer_getMinPeriod() {
        return MonocleTimer.getMinPeriod_impl();
    }

    @Override
    protected int staticTimer_getMaxPeriod() {
        return MonocleTimer.getMaxPeriod_impl();
    }

    public boolean hasWindowManager() {
        return false;
    }

    @Override
    protected FileChooserResult staticCommonDialogs_showFileChooser(
            Window owner, String folder, String filename, String title,
            int type, boolean multipleMode,
            ExtensionFilter[] extensionFilters,
            int defaultFilterIndex) {
        throw new UnsupportedOperationException();
    }

    @Override
    protected File staticCommonDialogs_showFolderChooser(Window owner,
                                                         String folder,
                                                         String title) {
        Thread.dumpStack();
        throw new UnsupportedOperationException();
    }

    @Override
    protected long staticView_getMultiClickTime() {
        return MonocleView._getMultiClickTime();
    }

    @Override
    protected int staticView_getMultiClickMaxX() {
        return MonocleView._getMultiClickMaxX();
    }

    @Override
    protected int staticView_getMultiClickMaxY() {
        return MonocleView._getMultiClickMaxY();
    }

    @Override
    protected boolean _supportsTransparentWindows() {
        return true;
    }

    @Override
    protected boolean _supportsUnifiedWindows() {
        return false;
    }

    @Override
    public boolean hasTwoLevelFocus() {
        return deviceFlags[DEVICE_PC_KEYBOARD] == 0 &amp;&amp; deviceFlags[DEVICE_5WAY] &gt; 0;
    }

    @Override
    public boolean hasVirtualKeyboard() {
        return deviceFlags[DEVICE_PC_KEYBOARD] == 0 &amp;&amp; deviceFlags[DEVICE_TOUCH] &gt; 0;
    }

    @Override
    public boolean hasTouch() {
        return deviceFlags[DEVICE_TOUCH] &gt; 0;
    }

    @Override
    public boolean hasMultiTouch() {
        return deviceFlags[DEVICE_MULTITOUCH] &gt; 0;
    }

    @Override
    public boolean hasPointer() {
        return deviceFlags[DEVICE_POINTER] &gt; 0;
    }

    @Override
    public void notifyRenderingFinished() {
        invokeLater(renderEndNotifier);
    }

    @Override
    protected void finishTerminating() {
        //if this method is getting called, we don't need the shutdown hook
        Runtime.getRuntime().removeShutdownHook(shutdownHookThread);
        setEventThread(null);
        platform.shutdown();
        super.finishTerminating();
    }

    void enterDnDEventLoop() {
        _enterNestedEventLoop();
    }

    void leaveDndEventLoop() {
        _leaveNestedEventLoop(null);
    }

    @Override
    protected int _getKeyCodeForChar(char c) {
        return KeyInput.getInstance().getKeyCodeForChar(c);
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/VNCScreen.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.glass.ui.monocle;

import com.sun.glass.events.MouseEvent;
import javafx.application.Platform;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.channels.WritableByteChannel;
import java.nio.charset.Charset;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.BitSet;
import java.util.HashSet;
import java.util.Set;

/** A headless screen that is available for remote connections using the
 * RFB 3.3 protocol on port 5901.
 */
class VNCScreen extends HeadlessScreen {

    private ServerSocketChannel server;
    private Set&lt;ClientConnection&gt; clients = new HashSet&lt;ClientConnection&gt;();

    VNCScreen() {
        super(1024, 600, 32);
        try {
            server = ServerSocketChannel.open();
            int vncPort = AccessController.doPrivileged(
                    (PrivilegedAction&lt;Integer&gt;)
                            () -&gt; Integer.getInteger(&quot;vnc.port&quot;, 5901));
            server.bind(new InetSocketAddress(vncPort));
            Thread t = new Thread(new ConnectionAccepter());
            t.setDaemon(true);
            t.setName(&quot;VNC Server on port &quot; + vncPort);
            t.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void shutdown() {
        super.shutdown();
        for (ClientConnection cc : clients) {
            try {
                cc.socket.close();
            } catch (IOException e) { }
        }
    }

    @Override
    public void swapBuffers() {
        ClientConnection[] ccs;
<A NAME="5"></A>        synchronized (clients) {
            ccs = clients.toArray(new ClientConnection[clients.size()]);
        }
        for (<FONT color="#c8c2a7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#5',2,'match52-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ClientConnection cc : ccs) {
            try {
                sendBuffer(cc.socket);
            } catch (IOException e) {
                clients.remove(cc);
            }
        }</B></FONT>
        super.swapBuffers();
    }

    private void removeClient(ClientConnection cc, IOException e) {
        synchronized (clients) {
            if (clients.contains(cc)) {
                System.out.format(&quot;Disconnecting %s: %s\n&quot;,
                                  cc.descriptor, e.getMessage());
                clients.remove(cc);
            }
        }
    }

    private void sendBuffer(WritableByteChannel out) throws IOException {
        ByteBuffer buffer = ByteBuffer.allocate(16);
        buffer.order(ByteOrder.BIG_ENDIAN);
        buffer.put((byte) 0);
        buffer.put((byte) 0);
        buffer.putShort((short) 1); // rectangle count
        buffer.putShort((short) 0); // x
        buffer.putShort((short) 0); // y
        buffer.putShort((short) width);
        buffer.putShort((short) height);
        buffer.putInt(0); // raw
        buffer.flip();
        out.write(buffer);
        fb.write(out);
    }

    private class ConnectionAccepter implements Runnable {
        @Override
        public void run() {
            ByteBuffer buffer = ByteBuffer.allocate(64);
            buffer.order(ByteOrder.BIG_ENDIAN);
            while (true) {
                try {
                    SocketChannel client = server.accept();
                    System.out.format(&quot;Connection received from %s\n&quot;,
                                      client.getRemoteAddress());
                    // Declare the server protocol version
                    buffer.clear();
                    buffer.put(&quot;RFB 003.003\n&quot;.getBytes());
                    buffer.flip();
                    client.write(buffer);
                    // Read the client protocol version
                    buffer.clear();
                    buffer.limit(12);
                    client.read(buffer);
                    buffer.flip();
                    System.out.format(&quot;Client supports %s\n&quot;,
                                      Charset.forName(&quot;UTF-8&quot;)
                                              .decode(buffer).toString().trim());
                    buffer.clear();
                    buffer.putInt(1); // no authentication
                    buffer.flip();
                    client.write(buffer);
                    buffer.clear();
                    buffer.limit(1);
                    client.read(buffer);
                    System.out.format(&quot;Client share request: %d\n&quot;,
                                      buffer.get(0));
                    buffer.clear();
                    buffer.putShort((short) width);
                    buffer.putShort((short) height);
                    buffer.put((byte) depth);
                    buffer.put((byte) depth);
                    buffer.put((byte) (ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN) ? 0 : 1));
                    buffer.put((byte) 1); // true color
                    if (depth == 32) {
                        buffer.putShort((short) 255); // red max
                        buffer.putShort((short) 255); // green max
                        buffer.putShort((short) 255); // blue max
                        buffer.put((byte) 16); // red offset
                        buffer.put((byte) 8); // blue offset
                        buffer.put((byte) 0); // green offset
                    } else {
                        buffer.putShort((byte) (short) 31);
                        buffer.putShort((byte) (short) 63);
                        buffer.putShort((byte) (short) 31);
                        buffer.put((byte) 11);
                        buffer.put((byte) 5);
                        buffer.put((byte) 0);
                    }
                    buffer.put((byte) 0); // padding
                    buffer.put((byte) 0);
                    buffer.put((byte) 0);
                    String name = &quot;JavaFX on &quot; + client.getLocalAddress();
                    buffer.putInt(name.length());
                    buffer.put(name.getBytes());
                    buffer.flip();
                    client.write(buffer);
                    ClientConnection cc = new ClientConnection();
                    cc.socket = client;
                    Thread t = new Thread(cc);
                    t.setDaemon(true);
                    t.setName(&quot;VNC client connection from &quot;
                                      + client.getRemoteAddress());
                    t.start();
                    synchronized (clients) {
                        clients.add(cc);
                    }
                    sendBuffer(client);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    private class ClientConnection implements Runnable {
        private SocketChannel socket;
        private String descriptor;
        @Override
        public void run() {
            ByteBuffer buffer = ByteBuffer.allocate(32);
            buffer.order(ByteOrder.BIG_ENDIAN);
            try {
                descriptor = socket.getRemoteAddress().toString();
                while (true) {
                    buffer.clear();
                    buffer.limit(4);
                    socket.read(buffer);
                    switch (buffer.get(0)) {
                        case 0: // SetPixelFormat
                            // discard the message in the next 16 bytes
                            buffer.clear();
                            buffer.limit(16);
                            socket.read(buffer);
                            break;
                        case 1: // FixColorMapEntries
                            buffer.clear();
                            buffer.limit(2);
                            socket.read(buffer);
                            // discard color map entries
                            int colorMapEntryCount = buffer.getShort(0);
                            for (int i = 0; i &lt; colorMapEntryCount; i++) {
                                buffer.clear();
                                buffer.limit(6);
                                socket.read(buffer);
                            }
                            break;
                        case 2: // SetEncodings
                            // discard encodings
                            int encodingCount = buffer.getShort(2);
                            for (int i = 0; i &lt; encodingCount; i++) {
                                buffer.clear();
                                buffer.limit(4);
                                socket.read(buffer);
                            }
                        case 3: // FramebufferUpdateRequest
                            buffer.clear();
                            buffer.limit(6);
                            socket.read(buffer);
                            Platform.runLater(() -&gt; {
                                try {
                                    if (fb.hasReceivedData()) {
                                        // an update is in progress and will
                                        // be sent on the next call to
                                        // swapBuffers. No need to
                                        // respond to this request.
                                    } else {
                                        sendBuffer(socket);
                                    }
                                } catch (IOException e) {
                                    removeClient(ClientConnection.this, e);
                                }
                            });
                            break;
                        case 4: // KeyEvent
                            buffer.clear();
                            buffer.limit(4);
                            socket.read(buffer);
                            break;
                        case 5: { // PointerEvent
                            int x = buffer.getShort(2);
                            buffer.position(1);
                            buffer.limit(2);
                            BitSet buttons = BitSet.valueOf(buffer);
                            buffer.clear();
                            buffer.limit(2);
                            socket.read(buffer);
                            int y = buffer.getShort(0);
                            final MouseState state = new MouseState();
                            state.setX(x);
                            state.setY(y);
                            if (buttons.get(0)) {
                                state.pressButton(MouseEvent.BUTTON_LEFT);
                            }
                            if (buttons.get(1)) {
                                state.pressButton(MouseEvent.BUTTON_OTHER);
                            }
                            if (buttons.get(2)) {
                                state.pressButton(MouseEvent.BUTTON_RIGHT);
                            }
                            Platform.runLater(() -&gt; MouseInput.getInstance().setState(state, false));
                            break;
                        }
                        case 6: // ClientCutText
                            buffer.clear();
                            buffer.limit(4);
                            socket.read(buffer);
                            int textLength = buffer.getInt(0);
                            for (int i = 0; i &lt; textLength; i++) {
                                buffer.clear();
                                buffer.limit(1);
                                socket.read(buffer);
                            }
                            break;
                        default:
                            System.err.format(
                                    &quot;Unknown message %d from client %s\n&quot;,
                                    buffer.get(0), socket.getRemoteAddress());
                    }
                }
            } catch (IOException e) {
                removeClient(this, e);
            }
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/font/CMap.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.font;

import com.sun.javafx.font.FontFileReader.Buffer;

/*
 * A tt font has a CMAP table which is in turn made up of sub-tables which
 * describe the char to glyph mapping in (possibly) multiple ways.
 * CMAP subtables are described by 3 values.
 * 1. Platform ID (eg 3=Microsoft, which is the id we look for in JDK)
 * 2. Encoding (eg 0=symbol, 1=unicode)
 * 3. TrueType subtable format (how the char-&gt;glyph mapping for the encoding
 * is stored in the subtable). See the TrueType spec. Format 4 is required
 * by MS in fonts for windows. Its uses segmented mapping to delta values.
 * Most typically we see are (3,1,4) :
 * CMAP Platform ID=3 is what we prefer. After that any 0,*.
 */
abstract class CMap {

    static final char noSuchChar = (char)0xfffd;
    static final int SHORTMASK = 0x0000ffff;
    static final int INTMASK   = 0xffffffff;

    private static final int MAX_CODE_POINTS = 0x10ffff;

    static CMap initialize(PrismFontFile font) {

        CMap cmap = null;

        int offset, platformID, encodingID=-1;

        int three0=0, three1=0, three10=0, zeroStarOffset=0;
        boolean zeroStar = false, threeStar = false;

        Buffer cmapBuffer = font.readTable(FontConstants.cmapTag);
        short numberSubTables = cmapBuffer.getShort(2);

        /* Locate the offsets of supported 3,* Microsoft platform encodings,
         * and any 0,* Unicode platform encoding. The latter is used by
         * all current OS X fonts that don't have a Microsoft cmap.
         * We will always prefer the Microsoft cmap, for the fonts that
         * provide both. They ought to perform the same mappings. Although
         * I can imagine that a vendor might provide a different looking
         * glyph for some special characters for OS X vs Windows, I'm not
         * actually aware of any such case.
         */
        for (int i=0; i&lt;numberSubTables; i++) {
            cmapBuffer.position(i * 8 + 4);
            platformID = cmapBuffer.getShort();

            if (platformID == 0) {
                zeroStar = true;
                encodingID = cmapBuffer.getShort();
                zeroStarOffset = cmapBuffer.getInt();
            }
            else if (platformID == 3) {
                threeStar = true;
                encodingID = cmapBuffer.getShort();
                offset     = cmapBuffer.getInt();
                switch (encodingID) {
                case 0:  three0  = offset; break; // MS Symbol encoding
                case 1:  three1  = offset; break; // MS Unicode cmap
                case 10: three10 = offset; break; // MS Unicode surrogates
                }
            }
        }

        /* This defines the preference order for cmap subtables */
        if (threeStar) {
            if (three10 != 0) {
                cmap = createCMap(cmapBuffer, three10);
            }
            else if  (three0 != 0) {
                cmap = createCMap(cmapBuffer, three0);
            }
            else if (three1 != 0) {
                cmap = createCMap(cmapBuffer, three1);
            }
        } else if (zeroStar &amp;&amp; zeroStarOffset != 0) {
            cmap = createCMap(cmapBuffer, zeroStarOffset);
        } else {
            /* No 0,* or supported 3,* subtable was found.
             * Use whatever is the first table listed.
             * Since these are supposed to be sorted, there's a good chance
             * it will be Mac Roman (1,0). If its not that then its
             * likely a really old font but not one that's found on either
             * Windows or OS X
             * In fact I didn't even find any OS X font that supported
             * only (1,*).
             * So this seems likely to be an untravelled path which is
             * just as well given that its not likely to work properly.
             */
            cmap = createCMap(cmapBuffer, cmapBuffer.getInt(8));
        }
        return cmap;
    }

    static CMap createCMap(Buffer buffer, int offset) {
        /* First do a sanity check that this cmap subtable is contained
         * within the cmap table.
         */
        int subtableFormat = buffer.getChar(offset);

        switch (subtableFormat) {
        case 0:  return new CMapFormat0(buffer, offset);
        case 2:  return new CMapFormat2(buffer, offset);
        case 4:  return new CMapFormat4(buffer, offset);
        case 6:  return new CMapFormat6(buffer, offset);
        case 8:  return new CMapFormat8(buffer, offset);
        case 10: return new CMapFormat10(buffer, offset);
        case 12: return new CMapFormat12(buffer, offset);
        default: throw new RuntimeException(&quot;Cmap format unimplemented: &quot; +
                                            (int)buffer.getChar(offset));
        }
    }

    abstract char getGlyph(int charCode);

    /* Format 4 Header is
     * ushort format (off=0)
     * ushort length (off=2)
     * ushort language (off=4)
     * ushort segCountX2 (off=6)
     * ushort searchRange (off=8)
     * ushort entrySelector (off=10)
     * ushort rangeShift (off=12)
     * ushort endCount[segCount] (off=14)
     * ushort reservedPad
     * ushort startCount[segCount]
     * short idDelta[segCount]
     * idRangeOFfset[segCount]
     * ushort glyphIdArray[]
     */
    static class CMapFormat4 extends CMap {
        int segCount;
        int entrySelector;
        int rangeShift;
        char[] endCount;
        char[] startCount;
        short[] idDelta;
        char[] idRangeOffset;
        char[] glyphIds;

        CMapFormat4(Buffer buffer, int offset) {

            buffer.position(offset);
            buffer.getChar(); // skip, we already know format=4
            int subtableLength = buffer.getChar();
            /* Try to recover from some bad fonts which specify a subtable
             * length that would overflow the byte buffer holding the whole
             * cmap table. If this isn't a recoverable situation an exception
             * may be thrown which is caught higher up the call stack.
             * Whilst this may seem lenient, in practice, unless the &quot;bad&quot;
             * subtable we are using is the last one in the cmap table we
             * would have no way of knowing about this problem anyway.
             */
            if (offset+subtableLength &gt; buffer.capacity()) {
                subtableLength = buffer.capacity() - offset;
            }
            buffer.getChar(); // skip language
            segCount = buffer.getChar()/2;
            buffer.getChar(); // skip searchRange
            entrySelector = buffer.getChar();
            rangeShift    = buffer.getChar()/2;
            startCount = new char[segCount];
            endCount = new char[segCount];
            idDelta = new short[segCount];
            idRangeOffset = new char[segCount];

            for (int i=0; i&lt;segCount; i++) {
                endCount[i] = buffer.getChar();
            }
            buffer.getChar(); // 2 bytes for reserved pad
            for (int i=0; i&lt;segCount; i++) {
                startCount[i] = buffer.getChar();
            }

            for (int i=0; i&lt;segCount; i++) {
                idDelta[i] = (short)buffer.getChar();
            }

            for (int i=0; i&lt;segCount; i++) {
                char ctmp = buffer.getChar();
                idRangeOffset[i] = (char)((ctmp&gt;&gt;1)&amp;0xffff);
            }
            /* Can calculate the number of glyph IDs by subtracting
             * &quot;pos&quot; from the length of the cmap
             */
            int pos = (segCount*8+16)/2;
            buffer.position(pos*2+offset); // * 2 for chars
            int numGlyphIds = (subtableLength/2 - pos);
            glyphIds = new char[numGlyphIds];
            for (int i=0;i&lt;numGlyphIds;i++) {
                glyphIds[i] = buffer.getChar();
            }
        }

        char getGlyph(int charCode) {

            int index = 0;
            char glyphCode = 0;

            int controlGlyph = getControlCodeGlyph(charCode, true);
            if (controlGlyph &gt;= 0) {
                return (char)controlGlyph;
            }

            /*
             * Citation from the TrueType (and OpenType) spec:
             *   The segments are sorted in order of increasing endCode
             *   values, and the segment values are specified in four parallel
             *   arrays. You search for the first endCode that is greater than
             *   or equal to the character code you want to map. If the
             *   corresponding startCode is less than or equal to the
             *   character code, then you use the corresponding idDelta and
             *   idRangeOffset to map the character code to a glyph index
             *   (otherwise, the missingGlyph is returned).
             */

            /*
             * CMAP format4 defines several fields for optimized search of
             * the segment list (entrySelector, searchRange, rangeShift).
             * However, benefits are neglible and some fonts have incorrect
             * data - so we use straightforward binary search (see bug 6247425)
             */
            int left = 0, right = startCount.length;
            index = startCount.length &gt;&gt; 1;
            while (left &lt; right) {
                if (endCount[index] &lt; charCode) {
                    left = index + 1;
                } else {
                    right = index;
                }
                index = (left + right) &gt;&gt; 1;
            }

            if (charCode &gt;= startCount[index] &amp;&amp; charCode &lt;= endCount[index]) {
                int rangeOffset = idRangeOffset[index];

                if (rangeOffset == 0) {
                    glyphCode = (char)(charCode + idDelta[index]);
                } else {
                    /* Calculate an index into the glyphIds array */
                    int glyphIDIndex = rangeOffset - segCount + index
                                         + (charCode - startCount[index]);
                    glyphCode = glyphIds[glyphIDIndex];
                    if (glyphCode != 0) {
                        glyphCode = (char)(glyphCode + idDelta[index]);
                    }
                }
            }
            return glyphCode;
        }
    }

    // Format 0: Byte Encoding table
    static class CMapFormat0 extends CMap {
        byte [] cmap;

        CMapFormat0(Buffer buffer, int offset) {

            /* skip 6 bytes of format, length, and version */
            int len = buffer.getChar(offset+2);
            cmap = new byte[len-6];
            buffer.get(offset+6, cmap, 0, len-6);
        }

        char getGlyph(int charCode) {
            if (charCode &lt; 256) {
                if (charCode &lt; 0x0010) {
                    switch (charCode) {
                    case 0x0009:
                    case 0x000a:
                    case 0x000d: return CharToGlyphMapper.INVISIBLE_GLYPH_ID;
                    }
                }
                return (char)(0xff &amp; cmap[charCode]);
            } else {
                return 0;
            }
        }
    }

    // Format 2: High-byte mapping through table
    static class CMapFormat2 extends CMap {

        char[] subHeaderKey = new char[256];
         /* Store subheaders in individual arrays
          * A SubHeader entry theoretically looks like {
          *   char firstCode;
          *   char entryCount;
          *   short idDelta;
          *   char idRangeOffset;
          * }
          */
        char[] firstCodeArray;
        char[] entryCountArray;
        short[] idDeltaArray;
        char[] idRangeOffSetArray;

        char[] glyphIndexArray;

        CMapFormat2(Buffer buffer, int offset) {

            int tableLen = buffer.getChar(offset+2);
            buffer.position(offset+6);
            char maxSubHeader = 0;
            for (int i=0;i&lt;256;i++) {
                subHeaderKey[i] = buffer.getChar();
                if (subHeaderKey[i] &gt; maxSubHeader) {
                    maxSubHeader = subHeaderKey[i];
                }
            }
            /* The value of the subHeaderKey is 8 * the subHeader index,
             * so the number of subHeaders can be obtained by dividing
             * this value bv 8 and adding 1.
             */
            int numSubHeaders = (maxSubHeader &gt;&gt; 3) +1;
            firstCodeArray = new char[numSubHeaders];
<A NAME="34"></A>            entryCountArray = new char[numSubHeaders];
            idDeltaArray  = new short[numSubHeaders];
            idRangeOffSetArray  = new char[numSubHeaders];
            <FONT color="#827d6b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#34',2,'match52-top.html#34',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>for (int i=0; i&lt;numSubHeaders; i++) {
                firstCodeArray[i] = buffer.getChar();
                entryCountArray[i] = buffer.getChar();
                idDeltaArray[i] = (short)buffer.getChar();
                idRangeOffSetArray[i] = buffer.getChar();
            }</B></FONT>

            int glyphIndexArrSize = (tableLen-518-numSubHeaders*8)/2;
            glyphIndexArray = new char[glyphIndexArrSize];
            for (int i=0; i&lt;glyphIndexArrSize;i++) {
                glyphIndexArray[i] = buffer.getChar();
            }
        }

        char getGlyph(int charCode) {
            int controlGlyph = getControlCodeGlyph(charCode, true);
            if (controlGlyph &gt;= 0) {
                return (char)controlGlyph;
            }

            char highByte = (char)(charCode &gt;&gt; 8);
            char lowByte = (char)(charCode &amp; 0xff);
            int key = subHeaderKey[highByte]&gt;&gt;3; // index into subHeaders
            char mapMe;

            if (key != 0) {
                mapMe = lowByte;
            } else {
                mapMe = highByte;
                if (mapMe == 0) {
                    mapMe = lowByte;
                }
            }
            char firstCode = firstCodeArray[key];
            if (mapMe &lt; firstCode) {
                return 0;
            } else {
                mapMe -= firstCode;
            }

            if (mapMe &lt; entryCountArray[key]) {
                /* &quot;address&quot; arithmetic is needed to calculate the offset
                 * into glyphIndexArray. &quot;idRangeOffSetArray[key]&quot; specifies
                 * the number of bytes from that location in the table where
                 * the subarray of glyphIndexes starting at &quot;firstCode&quot; begins.
                 * Each entry in the subHeader table is 8 bytes, and the
                 * idRangeOffSetArray field is at offset 6 in the entry.
                 * The glyphIndexArray immediately follows the subHeaders.
                 * So if there are &quot;N&quot; entries then the number of bytes to the
                 * start of glyphIndexArray is (N-key)*8-6.
                 * Subtract this from the idRangeOffSetArray value to get
                 * the number of bytes into glyphIndexArray and divide by 2 to
                 * get the (char) array index.
                 */
                int glyphArrayOffset = ((idRangeOffSetArray.length-key)*8)-6;
                int glyphSubArrayStart =
                        (idRangeOffSetArray[key] - glyphArrayOffset)/2;
                char glyphCode = glyphIndexArray[glyphSubArrayStart+mapMe];
                if (glyphCode != 0) {
                    glyphCode += idDeltaArray[key]; //idDelta
                    return glyphCode;
                }
            }
            return 0;
        }
    }

    // Format 6: Trimmed table mapping
    static class CMapFormat6 extends CMap {

        char firstCode;
        char entryCount;
        char[] glyphIdArray;

        CMapFormat6(Buffer buffer, int offset) {

             buffer.position(offset+6);
             firstCode = buffer.getChar();
             entryCount = buffer.getChar();
             glyphIdArray = new char[entryCount];
             for (int i=0; i&lt; entryCount; i++) {
                 glyphIdArray[i] = buffer.getChar();
             }
         }

         char getGlyph(int charCode) {
             int controlGlyph = getControlCodeGlyph(charCode, true);
             if (controlGlyph &gt;= 0) {
                 return (char)controlGlyph;
             }

             charCode -= firstCode;
             if (charCode &lt; 0 || charCode &gt;= entryCount) {
                  return 0;
             } else {
                  return glyphIdArray[charCode];
             }
         }
    }

    // Format 8: mixed 16-bit and 32-bit coverage
    // Seems unlikely this code will ever get tested as we look for
    // MS platform Cmaps and MS states (in the Opentype spec on their website)
    // that MS doesn't support this format
    static class CMapFormat8 extends CMap {

         CMapFormat8(Buffer buffer, int offset) {
         }

        char getGlyph(int charCode) {
            return 0;
        }

    }


    // Format 4-byte 10: Trimmed table mapping
    // MS platform Cmaps and MS states (in the Opentype spec on their website)
    // that MS doesn't support this format
    static class CMapFormat10 extends CMap {

         long startCharCode;
         int numChars;
         char[] glyphIdArray;

         CMapFormat10(Buffer buffer, int offset) {

             buffer.position(offset+12);
             startCharCode = buffer.getInt() &amp; INTMASK;
             numChars = buffer.getInt() &amp; INTMASK;
             if (numChars &lt;= 0 || numChars &gt; MAX_CODE_POINTS ||
                 offset &gt; buffer.capacity() - numChars*2 - 12 - 8)
             {
                 throw new RuntimeException(&quot;Invalid cmap subtable&quot;);
             }
             glyphIdArray = new char[numChars];
             for (int i=0; i&lt; numChars; i++) {
                 glyphIdArray[i] = buffer.getChar();
             }
         }

         char getGlyph(int charCode) {

             int code = (int)(charCode - startCharCode);
             if (code &lt; 0 || code &gt;= numChars) {
                 return 0;
             } else {
                 return glyphIdArray[code];
             }
         }
    }

    // Format 12: Segmented coverage for UCS-4 (fonts supporting
    // surrogate pairs)
    static class CMapFormat12 extends CMap {

        int numGroups;
        int highBit =0;
        int power;
        int extra;
        long[] startCharCode;
        long[] endCharCode;
        int[] startGlyphID;

        CMapFormat12(Buffer buffer, int offset) {

            numGroups = buffer.getInt(offset+12);
            if (numGroups &lt;= 0 || numGroups &gt; MAX_CODE_POINTS ||
                offset &gt; buffer.capacity() - numGroups*12 - 12 - 4)
            {
                throw new RuntimeException(&quot;Invalid cmap subtable&quot;);
            }
            startCharCode = new long[numGroups];
            endCharCode = new long[numGroups];
            startGlyphID = new int[numGroups];
            buffer.position(offset+16);
            // REMIND: why slice ?
            //buffer = buffer.slice();
            for (int i=0; i&lt;numGroups; i++) {
                startCharCode[i] = buffer.getInt() &amp; INTMASK;
                endCharCode[i] = buffer.getInt() &amp; INTMASK;
                startGlyphID[i] = buffer.getInt() &amp; INTMASK;
            }

            /* Finds the high bit by binary searching through the bits */
            int value = numGroups;

            if (value &gt;= 1 &lt;&lt; 16) {
                value &gt;&gt;= 16;
                highBit += 16;
            }

            if (value &gt;= 1 &lt;&lt; 8) {
                value &gt;&gt;= 8;
                highBit += 8;
            }

            if (value &gt;= 1 &lt;&lt; 4) {
                value &gt;&gt;= 4;
                highBit += 4;
            }

            if (value &gt;= 1 &lt;&lt; 2) {
                value &gt;&gt;= 2;
                highBit += 2;
            }

            if (value &gt;= 1 &lt;&lt; 1) {
                value &gt;&gt;= 1;
                highBit += 1;
            }

            power = 1 &lt;&lt; highBit;
            extra = numGroups - power;
        }

        char getGlyph(int charCode) {
            int controlGlyph = getControlCodeGlyph(charCode, false);
            if (controlGlyph &gt;= 0) {
                return (char)controlGlyph;
            }
            int probe = power;
            int range = 0;

            if (startCharCode[extra] &lt;= charCode) {
                range = extra;
            }

            while (probe &gt; 1) {
                probe &gt;&gt;= 1;

                if (startCharCode[range+probe] &lt;= charCode) {
                    range += probe;
                }
            }

            if (startCharCode[range] &lt;= charCode &amp;&amp;
                  endCharCode[range] &gt;= charCode) {
                return (char)
                    (startGlyphID[range] + (charCode - startCharCode[range]));
            }

            return 0;
        }

    }

    /* Used to substitute for bad Cmaps. */
    static class NullCMapClass extends CMap {

        char getGlyph(int charCode) {
            return 0;
        }
    }

    public static final NullCMapClass theNullCmap = new NullCMapClass();

    final int getControlCodeGlyph(int charCode, boolean noSurrogates) {
        if (charCode &lt; 0x0010) {
            switch (charCode) {
            case 0x0009:
            case 0x000a:
            case 0x000d: return CharToGlyphMapper.INVISIBLE_GLYPH_ID;
            }
        } else if (charCode &gt;= 0x200c) {
            if ((charCode &lt;= 0x200f) ||
                (charCode &gt;= 0x2028 &amp;&amp; charCode &lt;= 0x202e) ||
                (charCode &gt;= 0x206a &amp;&amp; charCode &lt;= 0x206f)) {
                return CharToGlyphMapper.INVISIBLE_GLYPH_ID;
            } else if (noSurrogates &amp;&amp; charCode &gt;= 0xFFFF) {
                return 0;
            }
        }
        return -1;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/geom/transform/Affine2D.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.geom.transform;

import com.sun.javafx.geom.Point2D;

/**
 * The &lt;code&gt;Affine2D&lt;/code&gt; class represents a 2D affine transform
 * that performs a linear mapping from 2D coordinates to other 2D
 * coordinates that preserves the &quot;straightness&quot; and
 * &quot;parallelness&quot; of lines.  Affine transformations can be constructed
 * using sequences of translations, scales, flips, rotations, and shears.
 * &lt;p&gt;
 * Such a coordinate transformation can be represented by a 3 row by
 * 3 column matrix with an implied last row of [ 0 0 1 ].  This matrix
 * transforms source coordinates {@code (x,y)} into
 * destination coordinates {@code (x',y')} by considering
 * them to be a column vector and multiplying the coordinate vector
 * by the matrix according to the following process:
 * &lt;pre&gt;
 *  [ x']   [  m00  m01  m02  ] [ x ]   [ m00x + m01y + m02 ]
 *  [ y'] = [  m10  m11  m12  ] [ y ] = [ m10x + m11y + m12 ]
 *  [ 1 ]   [   0    0    1   ] [ 1 ]   [         1         ]
 * &lt;/pre&gt;
 * &lt;p&gt;
 * &lt;a name=&quot;quadrantapproximation&quot;&gt;&lt;h4&gt;Handling 90-Degree Rotations&lt;/h4&gt;&lt;/a&gt;
 * &lt;p&gt;
 * In some variations of the &lt;code&gt;rotate&lt;/code&gt; methods in the
 * &lt;code&gt;Affine2D&lt;/code&gt; class, a double-precision argument
 * specifies the angle of rotation in radians.
 * These methods have special handling for rotations of approximately
 * 90 degrees (including multiples such as 180, 270, and 360 degrees),
 * so that the common case of quadrant rotation is handled more
 * efficiently.
 * This special handling can cause angles very close to multiples of
 * 90 degrees to be treated as if they were exact multiples of
 * 90 degrees.
 * For small multiples of 90 degrees the range of angles treated
 * as a quadrant rotation is approximately 0.00000121 degrees wide.
 * This section explains why such special care is needed and how
 * it is implemented.
 * &lt;p&gt;
 * Since 90 degrees is represented as &lt;code&gt;PI/2&lt;/code&gt; in radians,
 * and since PI is a transcendental (and therefore irrational) number,
 * it is not possible to exactly represent a multiple of 90 degrees as
 * an exact double precision value measured in radians.
 * As a result it is theoretically impossible to describe quadrant
 * rotations (90, 180, 270 or 360 degrees) using these values.
 * Double precision floating point values can get very close to
 * non-zero multiples of &lt;code&gt;PI/2&lt;/code&gt; but never close enough
 * for the sine or cosine to be exactly 0.0, 1.0 or -1.0.
 * The implementations of &lt;code&gt;Math.sin()&lt;/code&gt; and
 * &lt;code&gt;Math.cos()&lt;/code&gt; correspondingly never return 0.0
 * for any case other than &lt;code&gt;Math.sin(0.0)&lt;/code&gt;.
 * These same implementations do, however, return exactly 1.0 and
 * -1.0 for some range of numbers around each multiple of 90
 * degrees since the correct answer is so close to 1.0 or -1.0 that
 * the double precision significand cannot represent the difference
 * as accurately as it can for numbers that are near 0.0.
 * &lt;p&gt;
 * The net result of these issues is that if the
 * &lt;code&gt;Math.sin()&lt;/code&gt; and &lt;code&gt;Math.cos()&lt;/code&gt; methods
 * are used to directly generate the values for the matrix modifications
 * during these radian-based rotation operations then the resulting
 * transform is never strictly classifiable as a quadrant rotation
 * even for a simple case like &lt;code&gt;rotate(Math.PI/2.0)&lt;/code&gt;,
 * due to minor variations in the matrix caused by the non-0.0 values
 * obtained for the sine and cosine.
 * If these transforms are not classified as quadrant rotations then
 * subsequent code which attempts to optimize further operations based
 * upon the type of the transform will be relegated to its most general
 * implementation.
 * &lt;p&gt;
 * Because quadrant rotations are fairly common,
 * this class should handle these cases reasonably quickly, both in
 * applying the rotations to the transform and in applying the resulting
 * transform to the coordinates.
 * To facilitate this optimal handling, the methods which take an angle
 * of rotation measured in radians attempt to detect angles that are
 * intended to be quadrant rotations and treat them as such.
 * These methods therefore treat an angle &lt;em&gt;theta&lt;/em&gt; as a quadrant
 * rotation if either &lt;code&gt;Math.sin(&lt;em&gt;theta&lt;/em&gt;)&lt;/code&gt; or
 * &lt;code&gt;Math.cos(&lt;em&gt;theta&lt;/em&gt;)&lt;/code&gt; returns exactly 1.0 or -1.0.
 * As a rule of thumb, this property holds true for a range of
 * approximately 0.0000000211 radians (or 0.00000121 degrees) around
 * small multiples of &lt;code&gt;Math.PI/2.0&lt;/code&gt;.
 *
 * @version 1.83, 05/05/07
 */
public class Affine2D extends AffineBase {
    private Affine2D(double mxx, double myx,
                     double mxy, double myy,
                     double mxt, double myt,
                     int state)
    {
        this.mxx = mxx;
        this.myx = myx;
        this.mxy = mxy;
        this.myy = myy;
        this.mxt = mxt;
        this.myt = myt;
        this.state = state;
        this.type = TYPE_UNKNOWN;
    }

    /**
     * Constructs a new &lt;code&gt;Affine2D&lt;/code&gt; representing the
     * Identity transformation.
     */
    public Affine2D() {
        mxx = myy = 1.0;
        // m01 = m10 = m02 = m12 = 0.0;     /* Not needed. */
        // state = APPLY_IDENTITY;      /* Not needed. */
        // type = TYPE_IDENTITY;        /* Not needed. */
    }

    /**
     * Constructs a new &lt;code&gt;Affine2D&lt;/code&gt; that uses the same transform
     * as the specified &lt;code&gt;BaseTransform&lt;/code&gt; object.
     * @param Tx the &lt;code&gt;BaseTransform&lt;/code&gt; object to copy
     */
    public Affine2D(BaseTransform Tx) {
        setTransform(Tx);
    }

    /**
     * Constructs a new &lt;code&gt;Affine2D&lt;/code&gt; from 6 floating point
     * values representing the 6 specifiable entries of the 3x3
     * transformation matrix.
     *
     * @param mxx the X coordinate scaling element of the 3x3 matrix
     * @param myx the Y coordinate shearing element of the 3x3 matrix
     * @param mxy the X coordinate shearing element of the 3x3 matrix
     * @param myy the Y coordinate scaling element of the 3x3 matrix
     * @param mxt the X coordinate translation element of the 3x3 matrix
     * @param myt the Y coordinate translation element of the 3x3 matrix
     */
    public Affine2D(float mxx, float myx,
                    float mxy, float myy,
                    float mxt, float myt)
    {
        this.mxx = mxx;
        this.myx = myx;
        this.mxy = mxy;
        this.myy = myy;
        this.mxt = mxt;
        this.myt = myt;
        updateState2D();
    }

    /**
     * Constructs a new &lt;code&gt;Affine2D&lt;/code&gt; from 6 double
     * precision values representing the 6 specifiable entries of the 3x3
     * transformation matrix.
     *
     * @param mxx the X coordinate scaling element of the 3x3 matrix
     * @param myx the Y coordinate shearing element of the 3x3 matrix
     * @param mxy the X coordinate shearing element of the 3x3 matrix
     * @param myy the Y coordinate scaling element of the 3x3 matrix
     * @param mxt the X coordinate translation element of the 3x3 matrix
     * @param myt the Y coordinate translation element of the 3x3 matrix
     */
    public Affine2D(double mxx, double myx,
                    double mxy, double myy,
                    double mxt, double myt)
    {
        this.mxx = mxx;
        this.myx = myx;
        this.mxy = mxy;
        this.myy = myy;
        this.mxt = mxt;
        this.myt = myt;
        updateState2D();
    }

    @Override
    public Degree getDegree() {
        return Degree.AFFINE_2D;
    }

    @Override
    protected void reset3Delements() { /* NOP for Affine2D */ }

    /**
     * Concatenates this transform with a transform that rotates
     * coordinates around an anchor point.
     * This operation is equivalent to translating the coordinates so
     * that the anchor point is at the origin (S1), then rotating them
     * about the new origin (S2), and finally translating so that the
     * intermediate origin is restored to the coordinates of the original
     * anchor point (S3).
     * &lt;p&gt;
     * This operation is equivalent to the following sequence of calls:
     * &lt;pre&gt;
     *     translate(anchorx, anchory);      // S3: final translation
     *     rotate(theta);                    // S2: rotate around anchor
     *     translate(-anchorx, -anchory);    // S1: translate anchor to origin
     * &lt;/pre&gt;
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * &lt;a href=&quot;#quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;
     * above.
     *
     * @param theta the angle of rotation measured in radians
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
<A NAME="8"></A>     */
    public void rotate(double theta, double anchorx, double anchory) {
        // REMIND: Simple for now - optimize later
        <FONT color="#bce954"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#8',2,'match52-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>translate(anchorx, anchory);
        rotate(theta);
        translate(-anchorx, -anchory);
    }

    /**
     * Concatenates this transform with a transform that rotates
     * coordinates according to a rotation vector.
     * All coordinates rotate about the origin by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both &lt;code&gt;vecx&lt;/code&gt; and &lt;code&gt;vecy&lt;/code&gt; are 0.0,
     * no additional rotation is added to this transform.
     * This operation is equivalent to calling:
     * &lt;pre&gt;
     *          rotate(Math.atan2(vecy, vecx));
     * &lt;/pre&gt;
     *
     * @param vecx the X coordinate of the rotation vector
     * @param vecy the Y coordinate of the rotation vector
     */
    public void rotate(double vecx, double vecy) {
        if (vecy == 0.0) {
            if (vecx &lt; 0.0) {
                rotate180();
            }
            // If vecx &gt; 0.0 - no rotation
            // If vecx == 0.0 - undefined rotation - treat as no rotation
        }</B></FONT> else if (vecx == 0.0) {
            if (vecy &gt; 0.0) {
                rotate90();
            } else {  // vecy must be &lt; 0.0
                rotate270();
            }
        } else {
            double len = Math.sqrt(vecx * vecx + vecy * vecy);
            double sin = vecy / len;
            double cos = vecx / len;
            double M0, M1;
            M0 = mxx;
            M1 = mxy;
            mxx =  cos * M0 + sin * M1;
            mxy = -sin * M0 + cos * M1;
            M0 = myx;
            M1 = myy;
            myx =  cos * M0 + sin * M1;
            myy = -sin * M0 + cos * M1;
            updateState2D();
        }
    }

    /**
     * Concatenates this transform with a transform that rotates
     * coordinates around an anchor point according to a rotation
     * vector.
     * All coordinates rotate about the specified anchor coordinates
     * by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both &lt;code&gt;vecx&lt;/code&gt; and &lt;code&gt;vecy&lt;/code&gt; are 0.0,
     * the transform is not modified in any way.
     * This method is equivalent to calling:
     * &lt;pre&gt;
     *     rotate(Math.atan2(vecy, vecx), anchorx, anchory);
     * &lt;/pre&gt;
     *
     * @param vecx the X coordinate of the rotation vector
     * @param vecy the Y coordinate of the rotation vector
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     */
    public void rotate(double vecx, double vecy,
                       double anchorx, double anchory)
    {
        // REMIND: Simple for now - optimize later
        translate(anchorx, anchory);
        rotate(vecx, vecy);
        translate(-anchorx, -anchory);
    }

    /**
     * Concatenates this transform with a transform that rotates
     * coordinates by the specified number of quadrants.
     * This is equivalent to calling:
     * &lt;pre&gt;
     *     rotate(numquadrants * Math.PI / 2.0);
     * &lt;/pre&gt;
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     * @param numquadrants the number of 90 degree arcs to rotate by
     */
    public void quadrantRotate(int numquadrants) {
        switch (numquadrants &amp; 3) {
        case 0:
            break;
        case 1:
            rotate90();
            break;
        case 2:
            rotate180();
            break;
        case 3:
            rotate270();
            break;
        }
    }

    /**
     * Concatenates this transform with a transform that rotates
     * coordinates by the specified number of quadrants around
     * the specified anchor point.
     * This method is equivalent to calling:
     * &lt;pre&gt;
     *     rotate(numquadrants * Math.PI / 2.0, anchorx, anchory);
     * &lt;/pre&gt;
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     *
     * @param numquadrants the number of 90 degree arcs to rotate by
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     */
    public void quadrantRotate(int numquadrants,
                               double anchorx, double anchory)
    {
        switch (numquadrants &amp; 3) {
        case 0:
            return;
        case 1:
            mxt += anchorx * (mxx - mxy) + anchory * (mxy + mxx);
            myt += anchorx * (myx - myy) + anchory * (myy + myx);
            rotate90();
            break;
        case 2:
            mxt += anchorx * (mxx + mxx) + anchory * (mxy + mxy);
            myt += anchorx * (myx + myx) + anchory * (myy + myy);
            rotate180();
            break;
        case 3:
            mxt += anchorx * (mxx + mxy) + anchory * (mxy - mxx);
            myt += anchorx * (myx + myy) + anchory * (myy - myx);
            rotate270();
            break;
        }
        if (mxt == 0.0 &amp;&amp; myt == 0.0) {
            state &amp;= ~APPLY_TRANSLATE;
            if (type != TYPE_UNKNOWN) {
                type &amp;= ~TYPE_TRANSLATION;
            }
        } else {
            state |= APPLY_TRANSLATE;
            type |= TYPE_TRANSLATION;
        }
    }

    /**
     * Sets this transform to a translation transformation.
     * The matrix representing this transform becomes:
     * &lt;pre&gt;
     *      [   1    0    tx  ]
     *      [   0    1    ty  ]
     *      [   0    0    1   ]
     * &lt;/pre&gt;
     * @param tx the distance by which coordinates are translated in the
     * X axis direction
     * @param ty the distance by which coordinates are translated in the
     * Y axis direction
     */
    public void setToTranslation(double tx, double ty) {
        mxx = 1.0;
        myx = 0.0;
        mxy = 0.0;
        myy = 1.0;
        mxt = tx;
        myt = ty;
        if (tx != 0.0 || ty != 0.0) {
            state = APPLY_TRANSLATE;
            type = TYPE_TRANSLATION;
        } else {
            state = APPLY_IDENTITY;
            type = TYPE_IDENTITY;
        }
    }

    /**
     * Sets this transform to a rotation transformation.
     * The matrix representing this transform becomes:
     * &lt;pre&gt;
     *      [   cos(theta)    -sin(theta)    0   ]
     *      [   sin(theta)     cos(theta)    0   ]
     *      [       0              0         1   ]
     * &lt;/pre&gt;
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * &lt;a href=&quot;#quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;
     * above.
     * @param theta the angle of rotation measured in radians
     */
    public void setToRotation(double theta) {
        double sin = Math.sin(theta);
        double cos;
        if (sin == 1.0 || sin == -1.0) {
            cos = 0.0;
            state = APPLY_SHEAR;
            type = TYPE_QUADRANT_ROTATION;
        } else {
            cos = Math.cos(theta);
            if (cos == -1.0) {
                sin = 0.0;
                state = APPLY_SCALE;
                type = TYPE_QUADRANT_ROTATION;
            } else if (cos == 1.0) {
                sin = 0.0;
                state = APPLY_IDENTITY;
                type = TYPE_IDENTITY;
            } else {
                state = APPLY_SHEAR | APPLY_SCALE;
                type = TYPE_GENERAL_ROTATION;
            }
        }
        mxx =  cos;
        myx =  sin;
        mxy = -sin;
        myy =  cos;
        mxt =  0.0;
        myt =  0.0;
    }

    /**
     * Sets this transform to a translated rotation transformation.
     * This operation is equivalent to translating the coordinates so
     * that the anchor point is at the origin (S1), then rotating them
     * about the new origin (S2), and finally translating so that the
     * intermediate origin is restored to the coordinates of the original
     * anchor point (S3).
     * &lt;p&gt;
     * This operation is equivalent to the following sequence of calls:
     * &lt;pre&gt;
     *     setToTranslation(anchorx, anchory); // S3: final translation
     *     rotate(theta);                      // S2: rotate around anchor
     *     translate(-anchorx, -anchory);      // S1: translate anchor to origin
     * &lt;/pre&gt;
     * The matrix representing this transform becomes:
     * &lt;pre&gt;
     *      [   cos(theta)    -sin(theta)    x-x*cos+y*sin  ]
     *      [   sin(theta)     cos(theta)    y-x*sin-y*cos  ]
     *      [       0              0               1        ]
     * &lt;/pre&gt;
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * &lt;a href=&quot;#quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;
     * above.
     *
     * @param theta the angle of rotation measured in radians
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     */
    public void setToRotation(double theta, double anchorx, double anchory) {
        setToRotation(theta);
        double sin = myx;
        double oneMinusCos = 1.0 - mxx;
        mxt = anchorx * oneMinusCos + anchory * sin;
        myt = anchory * oneMinusCos - anchorx * sin;
        if (mxt != 0.0 || myt != 0.0) {
            state |= APPLY_TRANSLATE;
            type |= TYPE_TRANSLATION;
        }
    }

    /**
     * Sets this transform to a rotation transformation that rotates
     * coordinates according to a rotation vector.
     * All coordinates rotate about the origin by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both &lt;code&gt;vecx&lt;/code&gt; and &lt;code&gt;vecy&lt;/code&gt; are 0.0,
     * the transform is set to an identity transform.
     * This operation is equivalent to calling:
     * &lt;pre&gt;
     *     setToRotation(Math.atan2(vecy, vecx));
     * &lt;/pre&gt;
     *
     * @param vecx the X coordinate of the rotation vector
     * @param vecy the Y coordinate of the rotation vector
     */
    public void setToRotation(double vecx, double vecy) {
        double sin, cos;
        if (vecy == 0) {
            sin = 0.0;
            if (vecx &lt; 0.0) {
                cos = -1.0;
                state = APPLY_SCALE;
                type = TYPE_QUADRANT_ROTATION;
            } else {
                cos = 1.0;
                state = APPLY_IDENTITY;
                type = TYPE_IDENTITY;
            }
        } else if (vecx == 0) {
            cos = 0.0;
            sin = (vecy &gt; 0.0) ? 1.0 : -1.0;
            state = APPLY_SHEAR;
            type = TYPE_QUADRANT_ROTATION;
        } else {
            double len = Math.sqrt(vecx * vecx + vecy * vecy);
            cos = vecx / len;
            sin = vecy / len;
            state = APPLY_SHEAR | APPLY_SCALE;
            type = TYPE_GENERAL_ROTATION;
        }
        mxx =  cos;
        myx =  sin;
        mxy = -sin;
        myy =  cos;
        mxt =  0.0;
        myt =  0.0;
    }

    /**
     * Sets this transform to a rotation transformation that rotates
     * coordinates around an anchor point according to a rotation
     * vector.
     * All coordinates rotate about the specified anchor coordinates
     * by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both &lt;code&gt;vecx&lt;/code&gt; and &lt;code&gt;vecy&lt;/code&gt; are 0.0,
     * the transform is set to an identity transform.
     * This operation is equivalent to calling:
     * &lt;pre&gt;
     *     setToTranslation(Math.atan2(vecy, vecx), anchorx, anchory);
     * &lt;/pre&gt;
     *
     * @param vecx the X coordinate of the rotation vector
     * @param vecy the Y coordinate of the rotation vector
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     */
    public void setToRotation(double vecx, double vecy,
                              double anchorx, double anchory)
    {
        setToRotation(vecx, vecy);
        double sin = myx;
        double oneMinusCos = 1.0 - mxx;
        mxt = anchorx * oneMinusCos + anchory * sin;
        myt = anchory * oneMinusCos - anchorx * sin;
        if (mxt != 0.0 || myt != 0.0) {
            state |= APPLY_TRANSLATE;
            type |= TYPE_TRANSLATION;
        }
    }

    /**
     * Sets this transform to a rotation transformation that rotates
     * coordinates by the specified number of quadrants.
     * This operation is equivalent to calling:
     * &lt;pre&gt;
     *     setToRotation(numquadrants * Math.PI / 2.0);
     * &lt;/pre&gt;
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     * @param numquadrants the number of 90 degree arcs to rotate by
     */
    public void setToQuadrantRotation(int numquadrants) {
        switch (numquadrants &amp; 3) {
        case 0:
            mxx =  1.0;
            myx =  0.0;
            mxy =  0.0;
            myy =  1.0;
            mxt =  0.0;
            myt =  0.0;
            state = APPLY_IDENTITY;
            type = TYPE_IDENTITY;
            break;
        case 1:
            mxx =  0.0;
            myx =  1.0;
            mxy = -1.0;
            myy =  0.0;
            mxt =  0.0;
            myt =  0.0;
            state = APPLY_SHEAR;
            type = TYPE_QUADRANT_ROTATION;
            break;
        case 2:
            mxx = -1.0;
            myx =  0.0;
            mxy =  0.0;
            myy = -1.0;
            mxt =  0.0;
            myt =  0.0;
            state = APPLY_SCALE;
            type = TYPE_QUADRANT_ROTATION;
            break;
        case 3:
            mxx =  0.0;
            myx = -1.0;
            mxy =  1.0;
            myy =  0.0;
            mxt =  0.0;
            myt =  0.0;
            state = APPLY_SHEAR;
            type = TYPE_QUADRANT_ROTATION;
            break;
        }
    }

    /**
     * Sets this transform to a translated rotation transformation
     * that rotates coordinates by the specified number of quadrants
     * around the specified anchor point.
     * This operation is equivalent to calling:
     * &lt;pre&gt;
     *     setToRotation(numquadrants * Math.PI / 2.0, anchorx, anchory);
     * &lt;/pre&gt;
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     *
     * @param numquadrants the number of 90 degree arcs to rotate by
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     */
    public void setToQuadrantRotation(int numquadrants,
                                      double anchorx, double anchory)
    {
        switch (numquadrants &amp; 3) {
        case 0:
            mxx =  1.0;
            myx =  0.0;
            mxy =  0.0;
            myy =  1.0;
            mxt =  0.0;
            myt =  0.0;
            state = APPLY_IDENTITY;
            type = TYPE_IDENTITY;
            break;
        case 1:
            mxx =  0.0;
            myx =  1.0;
            mxy = -1.0;
            myy =  0.0;
            mxt =  anchorx + anchory;
            myt =  anchory - anchorx;
            if (mxt == 0.0 &amp;&amp; myt == 0.0) {
                state = APPLY_SHEAR;
                type = TYPE_QUADRANT_ROTATION;
            } else {
                state = APPLY_SHEAR | APPLY_TRANSLATE;
                type = TYPE_QUADRANT_ROTATION | TYPE_TRANSLATION;
            }
            break;
        case 2:
            mxx = -1.0;
            myx =  0.0;
            mxy =  0.0;
            myy = -1.0;
            mxt =  anchorx + anchorx;
            myt =  anchory + anchory;
            if (mxt == 0.0 &amp;&amp; myt == 0.0) {
                state = APPLY_SCALE;
                type = TYPE_QUADRANT_ROTATION;
            } else {
                state = APPLY_SCALE | APPLY_TRANSLATE;
                type = TYPE_QUADRANT_ROTATION | TYPE_TRANSLATION;
            }
            break;
        case 3:
            mxx =  0.0;
            myx = -1.0;
            mxy =  1.0;
            myy =  0.0;
            mxt =  anchorx - anchory;
            myt =  anchory + anchorx;
            if (mxt == 0.0 &amp;&amp; myt == 0.0) {
                state = APPLY_SHEAR;
                type = TYPE_QUADRANT_ROTATION;
            } else {
                state = APPLY_SHEAR | APPLY_TRANSLATE;
                type = TYPE_QUADRANT_ROTATION | TYPE_TRANSLATION;
            }
            break;
        }
    }

    /**
     * Sets this transform to a scaling transformation.
     * The matrix representing this transform becomes:
     * &lt;pre&gt;
     *      [   sx   0    0   ]
     *      [   0    sy   0   ]
     *      [   0    0    1   ]
     * &lt;/pre&gt;
     * @param sx the factor by which coordinates are scaled along the
     * X axis direction
     * @param sy the factor by which coordinates are scaled along the
     * Y axis direction
     */
    public void setToScale(double sx, double sy) {
        mxx = sx;
        myx = 0.0;
        mxy = 0.0;
        myy = sy;
        mxt = 0.0;
        myt = 0.0;
        if (sx != 1.0 || sy != 1.0) {
            state = APPLY_SCALE;
            type = TYPE_UNKNOWN;
        } else {
            state = APPLY_IDENTITY;
            type = TYPE_IDENTITY;
        }
    }

    /**
     * Sets this transform to a copy of the transform in the specified
     * &lt;code&gt;BaseTransform&lt;/code&gt; object.
     * @param Tx the &lt;code&gt;BaseTransform&lt;/code&gt; object from which to
     * copy the transform
     */
    public void setTransform(BaseTransform Tx) {
        switch (Tx.getDegree()) {
            case IDENTITY:
                setToIdentity();
                break;
            case TRANSLATE_2D:
                setToTranslation(Tx.getMxt(), Tx.getMyt());
                break;
            default:
                if (Tx.getType() &gt; TYPE_AFFINE2D_MASK) {
                    System.out.println(Tx+&quot; is &quot;+Tx.getType());
                    System.out.print(&quot;  &quot;+Tx.getMxx());
                    System.out.print(&quot;, &quot;+Tx.getMxy());
                    System.out.print(&quot;, &quot;+Tx.getMxz());
                    System.out.print(&quot;, &quot;+Tx.getMxt());
                    System.out.println();
                    System.out.print(&quot;  &quot;+Tx.getMyx());
                    System.out.print(&quot;, &quot;+Tx.getMyy());
                    System.out.print(&quot;, &quot;+Tx.getMyz());
                    System.out.print(&quot;, &quot;+Tx.getMyt());
                    System.out.println();
                    System.out.print(&quot;  &quot;+Tx.getMzx());
                    System.out.print(&quot;, &quot;+Tx.getMzy());
                    System.out.print(&quot;, &quot;+Tx.getMzz());
                    System.out.print(&quot;, &quot;+Tx.getMzt());
                    System.out.println();
                    // TODO: Should this be thrown before we modify anything?
                    // (RT-26801)
                    degreeError(Degree.AFFINE_2D);
                }
                /* No Break */
            case AFFINE_2D:
                this.mxx = Tx.getMxx();
                this.myx = Tx.getMyx();
                this.mxy = Tx.getMxy();
                this.myy = Tx.getMyy();
                this.mxt = Tx.getMxt();
                this.myt = Tx.getMyt();
                if (Tx instanceof AffineBase) {
                    this.state = ((AffineBase) Tx).state;
                    this.type = ((AffineBase) Tx).type;
                } else {
                    updateState2D();
                }
                break;
        }
    }

    /**
     * Concatenates a &lt;code&gt;BaseTransform&lt;/code&gt; &lt;code&gt;Tx&lt;/code&gt; to
     * this &lt;code&gt;Affine2D&lt;/code&gt; Cx
     * in a less commonly used way such that &lt;code&gt;Tx&lt;/code&gt; modifies the
     * coordinate transformation relative to the absolute pixel
     * space rather than relative to the existing user space.
     * Cx is updated to perform the combined transformation.
     * Transforming a point p by the updated transform Cx' is
     * equivalent to first transforming p by the original transform
     * Cx and then transforming the result by
     * &lt;code&gt;Tx&lt;/code&gt; like this:
     * Cx'(p) = Tx(Cx(p))
     * In matrix notation, if this transform Cx
     * is represented by the matrix [this] and &lt;code&gt;Tx&lt;/code&gt; is
     * represented by the matrix [Tx] then this method does the
     * following:
     * &lt;pre&gt;
     *      [this] = [Tx] x [this]
     * &lt;/pre&gt;
     * @param Tx the &lt;code&gt;BaseTransform&lt;/code&gt; object to be
     * concatenated with this &lt;code&gt;Affine2D&lt;/code&gt; object.
     * @see #concatenate
     */
    public void preConcatenate(BaseTransform Tx) {
        switch (Tx.getDegree()) {
            case IDENTITY:
                return;
            case TRANSLATE_2D:
                translate(Tx.getMxt(), Tx.getMyt());
                return;
            case AFFINE_2D:
                break;
            default:
                degreeError(Degree.AFFINE_2D);
        }
        double M0, M1;
        double Txx, Txy, Tyx, Tyy;
        double Txt, Tyt;
        int mystate = state;
        Affine2D at = (Affine2D) Tx;
        int txstate = at.state;
        switch ((txstate &lt;&lt; HI_SHIFT) | mystate) {
        case (HI_IDENTITY | APPLY_IDENTITY):
        case (HI_IDENTITY | APPLY_TRANSLATE):
        case (HI_IDENTITY | APPLY_SCALE):
        case (HI_IDENTITY | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_IDENTITY | APPLY_SHEAR):
        case (HI_IDENTITY | APPLY_SHEAR | APPLY_TRANSLATE):
        case (HI_IDENTITY | APPLY_SHEAR | APPLY_SCALE):
        case (HI_IDENTITY | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
            // Tx is IDENTITY...
            return;

        case (HI_TRANSLATE | APPLY_IDENTITY):
        case (HI_TRANSLATE | APPLY_SCALE):
        case (HI_TRANSLATE | APPLY_SHEAR):
        case (HI_TRANSLATE | APPLY_SHEAR | APPLY_SCALE):
            // Tx is TRANSLATE, this has no TRANSLATE
            mxt = at.mxt;
            myt = at.myt;
            state = mystate | APPLY_TRANSLATE;
            type |= TYPE_TRANSLATION;
            return;

        case (HI_TRANSLATE | APPLY_TRANSLATE):
        case (HI_TRANSLATE | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_TRANSLATE | APPLY_SHEAR | APPLY_TRANSLATE):
        case (HI_TRANSLATE | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
            // Tx is TRANSLATE, this has one too
            mxt = mxt + at.mxt;
            myt = myt + at.myt;
            return;

        case (HI_SCALE | APPLY_TRANSLATE):
        case (HI_SCALE | APPLY_IDENTITY):
            // Only these two existing states need a new state
            state = mystate | APPLY_SCALE;
            /* NOBREAK */
        case (HI_SCALE | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_SCALE | APPLY_SHEAR | APPLY_SCALE):
        case (HI_SCALE | APPLY_SHEAR | APPLY_TRANSLATE):
        case (HI_SCALE | APPLY_SHEAR):
        case (HI_SCALE | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_SCALE | APPLY_SCALE):
            // Tx is SCALE, this is anything
            Txx = at.mxx;
            Tyy = at.myy;
            if ((mystate &amp; APPLY_SHEAR) != 0) {
                mxy = mxy * Txx;
                myx = myx * Tyy;
                if ((mystate &amp; APPLY_SCALE) != 0) {
                    mxx = mxx * Txx;
                    myy = myy * Tyy;
                }
            } else {
                mxx = mxx * Txx;
                myy = myy * Tyy;
            }
            if ((mystate &amp; APPLY_TRANSLATE) != 0) {
                mxt = mxt * Txx;
                myt = myt * Tyy;
            }
            type = TYPE_UNKNOWN;
            return;
        case (HI_SHEAR | APPLY_SHEAR | APPLY_TRANSLATE):
        case (HI_SHEAR | APPLY_SHEAR):
            mystate = mystate | APPLY_SCALE;
            /* NOBREAK */
        case (HI_SHEAR | APPLY_TRANSLATE):
        case (HI_SHEAR | APPLY_IDENTITY):
        case (HI_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_SHEAR | APPLY_SCALE):
            state = mystate ^ APPLY_SHEAR;
            /* NOBREAK */
        case (HI_SHEAR | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_SHEAR | APPLY_SHEAR | APPLY_SCALE):
            // Tx is SHEAR, this is anything
            Txy = at.mxy;
            Tyx = at.myx;

            M0 = mxx;
            mxx = myx * Txy;
            myx = M0 * Tyx;

            M0 = mxy;
            mxy = myy * Txy;
            myy = M0 * Tyx;

            M0 = mxt;
            mxt = myt * Txy;
            myt = M0 * Tyx;
            type = TYPE_UNKNOWN;
            return;
        }
        // If Tx has more than one attribute, it is not worth optimizing
        // all of those cases...
        Txx = at.mxx; Txy = at.mxy; Txt = at.mxt;
        Tyx = at.myx; Tyy = at.myy; Tyt = at.myt;
        switch (mystate) {
        default:
            stateError();
            /* NOTREACHED */
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
            M0 = mxt;
            M1 = myt;
            Txt += M0 * Txx + M1 * Txy;
            Tyt += M0 * Tyx + M1 * Tyy;

            /* NOBREAK */
        case (APPLY_SHEAR | APPLY_SCALE):
            mxt = Txt;
            myt = Tyt;

            M0 = mxx;
            M1 = myx;
            mxx = M0 * Txx + M1 * Txy;
            myx = M0 * Tyx + M1 * Tyy;

            M0 = mxy;
            M1 = myy;
            mxy = M0 * Txx + M1 * Txy;
            myy = M0 * Tyx + M1 * Tyy;
            break;

        case (APPLY_SHEAR | APPLY_TRANSLATE):
            M0 = mxt;
            M1 = myt;
            Txt += M0 * Txx + M1 * Txy;
            Tyt += M0 * Tyx + M1 * Tyy;

            /* NOBREAK */
        case (APPLY_SHEAR):
            mxt = Txt;
            myt = Tyt;

            M0 = myx;
            mxx = M0 * Txy;
            myx = M0 * Tyy;

            M0 = mxy;
            mxy = M0 * Txx;
            myy = M0 * Tyx;
            break;

        case (APPLY_SCALE | APPLY_TRANSLATE):
            M0 = mxt;
            M1 = myt;
            Txt += M0 * Txx + M1 * Txy;
            Tyt += M0 * Tyx + M1 * Tyy;

            /* NOBREAK */
        case (APPLY_SCALE):
            mxt = Txt;
            myt = Tyt;

            M0 = mxx;
            mxx = M0 * Txx;
            myx = M0 * Tyx;

            M0 = myy;
            mxy = M0 * Txy;
            myy = M0 * Tyy;
            break;

        case (APPLY_TRANSLATE):
            M0 = mxt;
            M1 = myt;
            Txt += M0 * Txx + M1 * Txy;
            Tyt += M0 * Tyx + M1 * Tyy;

            /* NOBREAK */
        case (APPLY_IDENTITY):
            mxt = Txt;
            myt = Tyt;

            mxx = Txx;
            myx = Tyx;

            mxy = Txy;
            myy = Tyy;

            state = mystate | txstate;
            type = TYPE_UNKNOWN;
            return;
        }
        updateState2D();
    }

    /**
     * Returns an &lt;code&gt;Affine2D&lt;/code&gt; object representing the
     * inverse transformation.
     * The inverse transform Tx' of this transform Tx
     * maps coordinates transformed by Tx back
     * to their original coordinates.
     * In other words, Tx'(Tx(p)) = p = Tx(Tx'(p)).
     * &lt;p&gt;
     * If this transform maps all coordinates onto a point or a line
     * then it will not have an inverse, since coordinates that do
     * not lie on the destination point or line will not have an inverse
     * mapping.
     * The &lt;code&gt;getDeterminant&lt;/code&gt; method can be used to determine if this
     * transform has no inverse, in which case an exception will be
     * thrown if the &lt;code&gt;createInverse&lt;/code&gt; method is called.
     * @return a new &lt;code&gt;Affine2D&lt;/code&gt; object representing the
     * inverse transformation.
     * @see #getDeterminant
     * @exception NoninvertibleTransformException
     * if the matrix cannot be inverted.
     */
    public Affine2D createInverse()
        throws NoninvertibleTransformException
    {
        double det;
        switch (state) {
        default:
            stateError();
            /* NOTREACHED */
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
            det = mxx * myy - mxy * myx;
            if (det == 0 || Math.abs(det) &lt;= Double.MIN_VALUE) {
                throw new NoninvertibleTransformException(&quot;Determinant is &quot;+
                                                          det);
            }
            return new Affine2D( myy / det, -myx / det,
                                -mxy / det,  mxx / det,
                                (mxy * myt - myy * mxt) / det,
                                (myx * mxt - mxx * myt) / det,
                                (APPLY_SHEAR |
                                 APPLY_SCALE |
                                 APPLY_TRANSLATE));
        case (APPLY_SHEAR | APPLY_SCALE):
            det = mxx * myy - mxy * myx;
            if (det == 0 || Math.abs(det) &lt;= Double.MIN_VALUE) {
                throw new NoninvertibleTransformException(&quot;Determinant is &quot;+
                                                          det);
            }
            return new Affine2D( myy / det, -myx / det,
                                -mxy / det,  mxx / det,
                                 0.0,        0.0,
                                (APPLY_SHEAR | APPLY_SCALE));
        case (APPLY_SHEAR | APPLY_TRANSLATE):
            if (mxy == 0.0 || myx == 0.0) {
                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);
            }
            return new Affine2D( 0.0,        1.0 / mxy,
                                 1.0 / myx,  0.0,
                                -myt / myx, -mxt / mxy,
                                (APPLY_SHEAR | APPLY_TRANSLATE));
        case (APPLY_SHEAR):
            if (mxy == 0.0 || myx == 0.0) {
                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);
            }
            return new Affine2D(0.0,       1.0 / mxy,
                                1.0 / myx, 0.0,
                                0.0,       0.0,
                                (APPLY_SHEAR));
        case (APPLY_SCALE | APPLY_TRANSLATE):
            if (mxx == 0.0 || myy == 0.0) {
                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);
            }
            return new Affine2D( 1.0 / mxx,  0.0,
                                 0.0,        1.0 / myy,
                                -mxt / mxx, -myt / myy,
                                (APPLY_SCALE | APPLY_TRANSLATE));
        case (APPLY_SCALE):
            if (mxx == 0.0 || myy == 0.0) {
                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);
            }
            return new Affine2D(1.0 / mxx, 0.0,
                                0.0,       1.0 / myy,
                                0.0,       0.0,
                                (APPLY_SCALE));
        case (APPLY_TRANSLATE):
            return new Affine2D( 1.0,  0.0,
                                 0.0,  1.0,
                                -mxt, -myt,
                                (APPLY_TRANSLATE));
        case (APPLY_IDENTITY):
            return new Affine2D();
        }

        /* NOTREACHED */
    }

    /**
     * Transforms an array of point objects by this transform.
     * If any element of the &lt;code&gt;ptDst&lt;/code&gt; array is
     * &lt;code&gt;null&lt;/code&gt;, a new &lt;code&gt;Point2D&lt;/code&gt; object is allocated
     * and stored into that element before storing the results of the
     * transformation.
     * &lt;p&gt;
     * Note that this method does not take any precautions to
     * avoid problems caused by storing results into &lt;code&gt;Point2D&lt;/code&gt;
     * objects that will be used as the source for calculations
     * further down the source array.
     * This method does guarantee that if a specified &lt;code&gt;Point2D&lt;/code&gt;
     * object is both the source and destination for the same single point
     * transform operation then the results will not be stored until
     * the calculations are complete to avoid storing the results on
     * top of the operands.
     * If, however, the destination &lt;code&gt;Point2D&lt;/code&gt; object for one
     * operation is the same object as the source &lt;code&gt;Point2D&lt;/code&gt;
     * object for another operation further down the source array then
     * the original coordinates in that point are overwritten before
     * they can be converted.
     * @param ptSrc the array containing the source point objects
     * @param ptDst the array into which the transform point objects are
     * returned
     * @param srcOff the offset to the first point object to be
     * transformed in the source array
     * @param dstOff the offset to the location of the first
     * transformed point object that is stored in the destination array
     * @param numPts the number of point objects to be transformed
     */
    public void transform(Point2D[] ptSrc, int srcOff,
                          Point2D[] ptDst, int dstOff,
                          int numPts) {
        int mystate = this.state;
        while (--numPts &gt;= 0) {
            // Copy source coords into local variables in case src == dst
            Point2D src = ptSrc[srcOff++];
            double x = src.x;
            double y = src.y;
            Point2D dst = ptDst[dstOff++];
            if (dst == null) {
                dst = new Point2D();
                ptDst[dstOff - 1] = dst;
            }
            switch (mystate) {
            default:
                stateError();
                /* NOTREACHED */
            case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
                dst.setLocation((float)(x * mxx + y * mxy + mxt),
                                (float)(x * myx + y * myy + myt));
                break;
            case (APPLY_SHEAR | APPLY_SCALE):
                dst.setLocation((float)(x * mxx + y * mxy),
                                (float)(x * myx + y * myy));
                break;
            case (APPLY_SHEAR | APPLY_TRANSLATE):
                dst.setLocation((float)(y * mxy + mxt),
                                (float)(x * myx + myt));
                break;
            case (APPLY_SHEAR):
                dst.setLocation((float)(y * mxy), (float)(x * myx));
                break;
            case (APPLY_SCALE | APPLY_TRANSLATE):
                dst.setLocation((float)(x * mxx + mxt), (float)(y * myy + myt));
                break;
            case (APPLY_SCALE):
                dst.setLocation((float)(x * mxx), (float)(y * myy));
                break;
            case (APPLY_TRANSLATE):
                dst.setLocation((float)(x + mxt), (float)(y + myt));
                break;
            case (APPLY_IDENTITY):
                dst.setLocation((float) x, (float) y);
                break;
            }
        }

        /* NOTREACHED */
    }

    /**
     * Transforms the relative distance vector specified by
     * &lt;code&gt;ptSrc&lt;/code&gt; and stores the result in &lt;code&gt;ptDst&lt;/code&gt;.
     * A relative distance vector is transformed without applying the
     * translation components of the affine transformation matrix
     * using the following equations:
     * &lt;pre&gt;
     *  [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
     *  [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
     *  [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
     * &lt;/pre&gt;
     * If &lt;code&gt;ptDst&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a new
     * &lt;code&gt;Point2D&lt;/code&gt; object is allocated and then the result of the
     * transform is stored in this object.
     * In either case, &lt;code&gt;ptDst&lt;/code&gt;, which contains the
     * transformed point, is returned for convenience.
     * If &lt;code&gt;ptSrc&lt;/code&gt; and &lt;code&gt;ptDst&lt;/code&gt; are the same object,
     * the input point is correctly overwritten with the transformed
     * point.
     * @param ptSrc the distance vector to be delta transformed
     * @param ptDst the resulting transformed distance vector
     * @return &lt;code&gt;ptDst&lt;/code&gt;, which contains the result of the
     * transformation.
     */
    public Point2D deltaTransform(Point2D ptSrc, Point2D ptDst) {
        if (ptDst == null) {
            ptDst = new Point2D();
        }
        // Copy source coords into local variables in case src == dst
        double x = ptSrc.x;
        double y = ptSrc.y;
        switch (state) {
        default:
            stateError();
            /* NOTREACHED */
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
        case (APPLY_SHEAR | APPLY_SCALE):
            ptDst.setLocation((float)(x * mxx + y * mxy), (float)(x * myx + y * myy));
            return ptDst;
        case (APPLY_SHEAR | APPLY_TRANSLATE):
        case (APPLY_SHEAR):
            ptDst.setLocation((float)(y * mxy), (float)(x * myx));
            return ptDst;
        case (APPLY_SCALE | APPLY_TRANSLATE):
        case (APPLY_SCALE):
            ptDst.setLocation((float)(x * mxx), (float)(y * myy));
            return ptDst;
        case (APPLY_TRANSLATE):
        case (APPLY_IDENTITY):
            ptDst.setLocation((float) x, (float) y);
            return ptDst;
        }

        /* NOTREACHED */
    }

    // Round values to sane precision for printing
    // Note that Math.sin(Math.PI) has an error of about 10^-16
    private static double _matround(double matval) {
        return Math.rint(matval * 1E15) / 1E15;
    }

    /**
     * Returns a &lt;code&gt;String&lt;/code&gt; that represents the value of this
     * {@link Object}.
     * @return a &lt;code&gt;String&lt;/code&gt; representing the value of this
     * &lt;code&gt;Object&lt;/code&gt;.
     */
    @Override
    public String toString() {
        return (&quot;Affine2D[[&quot;
                + _matround(mxx) + &quot;, &quot;
                + _matround(mxy) + &quot;, &quot;
                + _matround(mxt) + &quot;], [&quot;
                + _matround(myx) + &quot;, &quot;
                + _matround(myy) + &quot;, &quot;
                + _matround(myt) + &quot;]]&quot;);
    }

    @Override
    public boolean is2D() {
        return true;
    }

    @Override
    public void restoreTransform(double mxx, double myx,
                                 double mxy, double myy,
                                 double mxt, double myt)
    {
        setTransform(mxx, myx, mxy, myy, mxt, myt);
    }

    @Override
    public void restoreTransform(double mxx, double mxy, double mxz, double mxt,
                                 double myx, double myy, double myz, double myt,
                                 double mzx, double mzy, double mzz, double mzt)
    {
        if (                        mxz != 0 ||
                                    myz != 0 ||
            mzx != 0 || mzy != 0 || mzz != 1 || mzt != 0.0)
        {
            degreeError(Degree.AFFINE_2D);
        }
        setTransform(mxx, myx, mxy, myy, mxt, myt);
    }

    @Override
    public BaseTransform deriveWithTranslation(double mxt, double myt) {
        translate(mxt, myt);
        return this;
    }

    @Override
    public BaseTransform deriveWithTranslation(double mxt, double myt, double mzt) {
        if (mzt == 0.0) {
            translate(mxt, myt);
            return this;
        }
        Affine3D a = new Affine3D(this);
        a.translate(mxt, myt, mzt);
        return a;
    }

    @Override
    public BaseTransform deriveWithScale(double mxx, double myy, double mzz) {
        if (mzz == 1.0) {
            scale(mxx, myy);
            return this;
        }
        Affine3D a = new Affine3D(this);
        a.scale(mxx, myy, mzz);
        return a;

    }

    @Override
    public BaseTransform deriveWithRotation(double theta,
            double axisX, double axisY, double axisZ) {
        if (theta == 0.0) {
            return this;
        }
        if (almostZero(axisX) &amp;&amp; almostZero(axisY)) {
            if (axisZ &gt; 0) {
                rotate(theta);
            } else if (axisZ &lt; 0) {
                rotate(-theta);
            } // else rotating about zero vector - NOP
            return this;
        }
        Affine3D a = new Affine3D(this);
        a.rotate(theta, axisX, axisY, axisZ);
        return a;
    }

    @Override
    public BaseTransform deriveWithPreTranslation(double mxt, double myt) {
        this.mxt += mxt;
        this.myt += myt;
        if (this.mxt != 0.0 || this.myt != 0.0) {
            state |= APPLY_TRANSLATE;
//            if (type != TYPE_UNKNOWN) {
                type |= TYPE_TRANSLATION;
//            }
        } else {
            state &amp;= ~APPLY_TRANSLATE;
            if (type != TYPE_UNKNOWN) {
                type &amp;= ~TYPE_TRANSLATION;
            }
        }
        return this;
    }

    @Override
    public BaseTransform deriveWithConcatenation(double mxx, double myx,
                                                 double mxy, double myy,
                                                 double mxt, double myt)
    {
        // TODO: Simplify this (RT-26801)
        BaseTransform tmpTx = getInstance(mxx, myx,
                                          mxy, myy,
                                          mxt, myt);
        concatenate(tmpTx);
        return this;
    }

    @Override
    public BaseTransform deriveWithConcatenation(
            double mxx,   double mxy,   double mxz,   double mxt,
            double myx,   double myy,   double myz,   double myt,
            double mzx,   double mzy,   double mzz,   double mzt) {
        if (                                   mxz == 0.0
                                            &amp;&amp; myz == 0.0
                &amp;&amp; mzx == 0.0 &amp;&amp; mzy == 0.0 &amp;&amp; mzz == 1.0 &amp;&amp; mzt == 0.0) {
            concatenate(mxx, mxy,
                        mxt, myx,
                        myy, myt);
            return this;
        }

        Affine3D t3d = new Affine3D(this);
        t3d.concatenate(mxx, mxy, mxz, mxt,
                        myx, myy, myz, myt,
                        mzx, mzy, mzz, mzt);
        return t3d;
    }

    @Override
    public BaseTransform deriveWithConcatenation(BaseTransform tx) {
        if (tx.is2D()) {
            concatenate(tx);
            return this;
        }
        Affine3D t3d = new Affine3D(this);
        t3d.concatenate(tx);
        return t3d;
    }

    @Override
    public BaseTransform deriveWithPreConcatenation(BaseTransform tx) {
        if (tx.is2D()) {
            preConcatenate(tx);
            return this;
        }
        Affine3D t3d = new Affine3D(this);
        t3d.preConcatenate(tx);
        return t3d;
    }

    @Override
    public BaseTransform deriveWithNewTransform(BaseTransform tx) {
        if (tx.is2D()) {
            setTransform(tx);
            return this;
        }
        return getInstance(tx);
    }

    @Override
    public BaseTransform copy() {
        return new Affine2D(this);
    }

    private static final long BASE_HASH;
    static {
        long bits = 0;
        bits = bits * 31 + Double.doubleToLongBits(IDENTITY_TRANSFORM.getMzz());
        bits = bits * 31 + Double.doubleToLongBits(IDENTITY_TRANSFORM.getMzy());
        bits = bits * 31 + Double.doubleToLongBits(IDENTITY_TRANSFORM.getMzx());
        bits = bits * 31 + Double.doubleToLongBits(IDENTITY_TRANSFORM.getMyz());
        bits = bits * 31 + Double.doubleToLongBits(IDENTITY_TRANSFORM.getMxz());
        BASE_HASH = bits;
    }

    /**
     * Returns the hashcode for this transform.  The base algorithm for
     * computing the hashcode is defined by the implementation in
     * the {@code BaseTransform} class.  This implementation is just a
     * faster way of computing the same value knowing which elements of
     * the transform matrix are populated.
     * @return      a hash code for this transform.
     */
    @Override
    public int hashCode() {
        if (isIdentity()) return 0;
        long bits = BASE_HASH;
        bits = bits * 31 + Double.doubleToLongBits(getMyy());
        bits = bits * 31 + Double.doubleToLongBits(getMyx());
        bits = bits * 31 + Double.doubleToLongBits(getMxy());
        bits = bits * 31 + Double.doubleToLongBits(getMxx());
        bits = bits * 31 + Double.doubleToLongBits(0.0); // mzt
        bits = bits * 31 + Double.doubleToLongBits(getMyt());
        bits = bits * 31 + Double.doubleToLongBits(getMxt());
        return (((int) bits) ^ ((int) (bits &gt;&gt; 32)));
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Affine2D&lt;/code&gt;
     * represents the same coordinate transform as the specified
     * argument.
     * @param obj the &lt;code&gt;Object&lt;/code&gt; to test for equality with this
     * &lt;code&gt;Affine2D&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;obj&lt;/code&gt; equals this
     * &lt;code&gt;Affine2D&lt;/code&gt; object; &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    @Override
    public boolean equals(Object obj) {
        if (obj instanceof BaseTransform) {
            BaseTransform a = (BaseTransform) obj;
            return (a.getType() &lt;= TYPE_AFFINE2D_MASK &amp;&amp;
                    a.getMxx() == this.mxx &amp;&amp;
                    a.getMxy() == this.mxy &amp;&amp;
                    a.getMxt() == this.mxt &amp;&amp;
                    a.getMyx() == this.myx &amp;&amp;
                    a.getMyy() == this.myy &amp;&amp;
                    a.getMyt() == this.myt);
        }
        return false;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/image/impl/ByteRgb.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.image.impl;

import com.sun.javafx.image.AlphaType;
import com.sun.javafx.image.BytePixelGetter;
import com.sun.javafx.image.BytePixelSetter;
import com.sun.javafx.image.ByteToBytePixelConverter;
import com.sun.javafx.image.ByteToIntPixelConverter;
import com.sun.javafx.image.IntPixelSetter;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;

public class ByteRgb {
    public static final BytePixelGetter getter = Getter.instance;

    public static ByteToBytePixelConverter ToByteBgraConverter() {
        return ByteRgb.ToByteBgrfConv.nonpremult;
    }

    public static ByteToBytePixelConverter ToByteBgraPreConverter() {
        return ByteRgb.ToByteBgrfConv.premult;
    }

    public static ByteToIntPixelConverter ToIntArgbConverter() {
        return ByteRgb.ToIntFrgbConv.nonpremult;
    }

    public static ByteToIntPixelConverter ToIntArgbPreConverter() {
        return ByteRgb.ToIntFrgbConv.premult;
    }

    public static ByteToBytePixelConverter ToByteArgbConverter() {
        return ByteRgb.ToByteFrgbConv.nonpremult;
    }

    public static final ByteToBytePixelConverter ToByteBgrConverter() {
        return ByteRgb.SwapThreeByteConverter.rgbToBgrInstance;
    }

    static class Getter implements BytePixelGetter {
        static final BytePixelGetter instance = new Getter();
        private Getter() {}

        @Override
        public AlphaType getAlphaType() {
            return AlphaType.OPAQUE;
        }

        @Override
        public int getNumElements() {
            return 3;
        }

        @Override
        public int getArgb(byte arr[], int offset) {
            return (((arr[offset + 2] &amp; 0xff)      ) |
                    ((arr[offset + 1] &amp; 0xff) &lt;&lt;  8) |
                    ((arr[offset    ] &amp; 0xff) &lt;&lt; 16) |
                    ((                  0xff) &lt;&lt; 24));
        }

        @Override
        public int getArgbPre(byte arr[], int offset) {
            return (((arr[offset + 2] &amp; 0xff)      ) |
                    ((arr[offset + 1] &amp; 0xff) &lt;&lt;  8) |
                    ((arr[offset    ] &amp; 0xff) &lt;&lt; 16) |
                    ((                  0xff) &lt;&lt; 24));
        }

        @Override
        public int getArgb(ByteBuffer buffer, int offset) {
            return (((buffer.get(offset + 2) &amp; 0xff)      ) |
                    ((buffer.get(offset + 1) &amp; 0xff) &lt;&lt;  8) |
                    ((buffer.get(offset    ) &amp; 0xff) &lt;&lt; 16) |
                    ((                         0xff) &lt;&lt; 24));
        }
<A NAME="21"></A>
        @Override
        public int getArgbPre(ByteBuffer buffer, int offset) {
            return (((<FONT color="#00ff00"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#21',2,'match52-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>buffer.get(offset + 2) &amp; 0xff)      ) |
                    ((buffer.get(offset + 1) &amp; 0xff) &lt;&lt;  8) |
                    ((buffer.get(offset    ) &amp; 0xff) &lt;&lt; 16) |
                    ((                         0xff) &lt;&lt; 24));
        }
    }

    static class ToByteBgrfConv extends BaseByteToByteConverter {
        public static final ByteToBytePixelConverter nonpremult =
            new ToByteBgrfConv(ByteBgra.setter);
        public static final ByteToBytePixelConverter    premult =
            new</B></FONT> ToByteBgrfConv(ByteBgraPre.setter);

        private ToByteBgrfConv(BytePixelSetter setter) {
            super(ByteRgb.getter, setter);
        }

        @Override
        void doConvert(byte srcarr[], int srcoff, int srcscanbytes,
                       byte dstarr[], int dstoff, int dstscanbytes,
                       int w, int h)
        {
            srcscanbytes -= w * 3;
            dstscanbytes -= w * 4;
            while (--h &gt;= 0) {
                for (int x = 0; x &lt; w; x++) {
                    dstarr[dstoff++] = srcarr[srcoff + 2];
                    dstarr[dstoff++] = srcarr[srcoff + 1];
                    dstarr[dstoff++] = srcarr[srcoff    ];
                    dstarr[dstoff++] = (byte) 0xff;
                    srcoff += 3;
                }
                srcoff += srcscanbytes;
                dstoff += dstscanbytes;
            }
        }

        @Override
        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,
                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,
                       int w, int h)
        {
            srcscanbytes -= w * 3;
            dstscanbytes -= w * 4;
            while (--h &gt;= 0) {
                for (int x = 0; x &lt; w; x++) {
                    dstbuf.put(dstoff    , srcbuf.get(srcoff + 2));
                    dstbuf.put(dstoff + 1, srcbuf.get(srcoff + 1));
                    dstbuf.put(dstoff + 2, srcbuf.get(srcoff    ));
                    dstbuf.put(dstoff + 3, (byte) 0xff);
                    srcoff += 3;
                    dstoff += 4;
                }
                srcoff += srcscanbytes;
                dstoff += dstscanbytes;
            }
        }
    }

    static class ToIntFrgbConv extends BaseByteToIntConverter {
        public static final ByteToIntPixelConverter nonpremult =
            new ToIntFrgbConv(IntArgb.setter);
        public static final ByteToIntPixelConverter    premult =
            new ToIntFrgbConv(IntArgbPre.setter);

        private ToIntFrgbConv(IntPixelSetter setter) {
            super(ByteRgb.getter, setter);
        }

        @Override
        void doConvert(byte srcarr[], int srcoff, int srcscanbytes,
                       int  dstarr[], int dstoff, int dstscanints,
                       int w, int h)
        {
            srcscanbytes -= w * 3;
            while (--h &gt;= 0) {
                for (int x = 0; x &lt; w; x++) {
                    int r = srcarr[srcoff++] &amp; 0xff;
                    int g = srcarr[srcoff++] &amp; 0xff;
                    int b = srcarr[srcoff++] &amp; 0xff;
                    dstarr[dstoff + x] = 0xff000000 | (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;
                }
                srcoff += srcscanbytes;
                dstoff += dstscanints;
            }
        }

        @Override
        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,
                       IntBuffer  dstbuf, int dstoff, int dstscanints,
                       int w, int h)
        {
            srcscanbytes -= w * 3;
            while (--h &gt;= 0) {
                for (int x = 0; x &lt; w; x++) {
                    int r = srcbuf.get(srcoff    ) &amp; 0xff;
                    int g = srcbuf.get(srcoff + 1) &amp; 0xff;
                    int b = srcbuf.get(srcoff + 2) &amp; 0xff;
                    srcoff += 3;
                    dstbuf.put(dstoff + x, 0xff000000 | (r &lt;&lt; 16) | (g &lt;&lt; 8) | b);
                }
                srcoff += srcscanbytes;
                dstoff += dstscanints;
            }
        }
    }

    static class ToByteFrgbConv extends BaseByteToByteConverter {
        static final ByteToBytePixelConverter nonpremult =
            new ToByteFrgbConv(ByteArgb.setter);

        private ToByteFrgbConv(BytePixelSetter setter) {
            super(ByteRgb.getter, setter);
        }

        @Override
        void doConvert(byte srcarr[], int srcoff, int srcscanbytes,
                       byte dstarr[], int dstoff, int dstscanbytes,
                       int w, int h)
        {
            srcscanbytes -= w * 3;
            srcscanbytes -= w * 4;
            while (--h &gt;= 0) {
                for (int x = 0; x &lt; w; x++) {
                    dstarr[dstoff++] = (byte) 0xff;
                    dstarr[dstoff++] = srcarr[srcoff++];
                    dstarr[dstoff++] = srcarr[srcoff++];
                    dstarr[dstoff++] = srcarr[srcoff++];
                }
                srcoff += srcscanbytes;
                dstoff += dstscanbytes;
            }
        }

        @Override
        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,
                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,
                       int w, int h)
        {
            srcscanbytes -= w * 3;
            srcscanbytes -= w * 4;
            while (--h &gt;= 0) {
                for (int x = 0; x &lt; w; x++) {
                    dstbuf.put(dstoff++, (byte) 0xff);
                    dstbuf.put(dstoff++, srcbuf.get(srcoff++));
                    dstbuf.put(dstoff++, srcbuf.get(srcoff++));
                    dstbuf.put(dstoff++, srcbuf.get(srcoff++));
                }
                srcoff += srcscanbytes;
                dstoff += dstscanbytes;
            }
        }
    }

    static class SwapThreeByteConverter extends BaseByteToByteConverter {
        static final ByteToBytePixelConverter rgbToBgrInstance =
            new SwapThreeByteConverter(ByteRgb.getter, ByteBgr.accessor);

        public SwapThreeByteConverter(BytePixelGetter getter, BytePixelSetter setter) {
            super(getter, setter);
        }

        @Override
        void doConvert(byte[] srcarr, int srcoff, int srcscanbytes,
                       byte[] dstarr, int dstoff, int dstscanbytes,
                       int w, int h)
        {
            srcscanbytes -= w * 3;
            srcscanbytes -= w * 4;
            while (--h &gt;= 0) {
                for (int x = 0; x &lt; w; x++) {
                    dstarr[dstoff++] = srcarr[srcoff + 2];
                    dstarr[dstoff++] = srcarr[srcoff + 1];
                    dstarr[dstoff++] = srcarr[srcoff    ];
                    srcoff += 3;
                }
                srcoff += srcscanbytes;
                dstoff += dstscanbytes;
            }
        }

        @Override
        void doConvert(ByteBuffer srcbuf, int srcoff, int srcscanbytes,
                       ByteBuffer dstbuf, int dstoff, int dstscanbytes,
                       int w, int h)
        {
            srcscanbytes -= w * 3;
            srcscanbytes -= w * 4;
            while (--h &gt;= 0) {
                for (int x = 0; x &lt; w; x++) {
                    dstbuf.put(dstoff++, srcbuf.get(srcoff + 2));
                    dstbuf.put(dstoff++, srcbuf.get(srcoff + 1));
                    dstbuf.put(dstoff++, srcbuf.get(srcoff    ));
                    srcoff += 3;
                }
                srcoff += srcscanbytes;
                dstoff += dstscanbytes;
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/sg/prism/CacheFilter.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.sg.prism;

import com.sun.javafx.logging.PulseLogger;
import javafx.scene.CacheHint;
import java.util.List;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.DirtyRegionContainer;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.prism.Graphics;
import com.sun.prism.RTTexture;
import com.sun.prism.Texture;
import com.sun.scenario.effect.Effect;
import com.sun.scenario.effect.FilterContext;
import com.sun.scenario.effect.Filterable;
import com.sun.scenario.effect.ImageData;
import com.sun.scenario.effect.impl.prism.PrDrawable;
import com.sun.scenario.effect.impl.prism.PrFilterContext;
import javafx.geometry.Insets;
import javafx.scene.layout.Background;
import javafx.scene.layout.BackgroundFill;
import javafx.scene.paint.Color;

/**
 * Base implementation of the Node.cache and cacheHint APIs.
 *
 * When all or a portion of the cacheHint becomes enabled, we should try *not*
 * to re-render the cache.  This avoids a big hiccup at the beginning of the
 * &quot;use SPEED only while animating&quot; use case:
 *   0) Under DEFAULT, we should already have a cached image
 *   1) scale/rotate caching is enabled (no expensive re-render required)
 *   2) animation happens, using the cached image
 *   3) animation completes, caching is disable and the node is re-rendered (at
 *      full-fidelity) with the final transform.
 *
 * Certain transform combinations are not supported, notably scaling by unequal
 * amounts in the x and y directions while also rotating.  Other than simple
 * translation, animations in this case will require re-rendering every frame.
 *
 * Ideally, a simple change to a Node's translation should never regenerate the
 * cached image.
 *
 * The CacheFilter is also capable of optimizing the scrolling of the cached contents.
 * For example, the ScrollView UI Control can define its content area as being cached,
 * such that when the user scrolls, we can shift the old content area and adjust the
 * dirty region so that it only includes the &quot;newly exposed&quot; area.
 */
public class CacheFilter {
    /**
     * Defines the state when we're in the midst of scrolling a cached image
     */
    private static enum ScrollCacheState {
        CHECKING_PRECONDITIONS,
        ENABLED,
        DISABLED
    }

    // Garbage-reduction variables:
    private static final Rectangle TEMP_RECT = new Rectangle();
    private static final DirtyRegionContainer TEMP_CONTAINER = new DirtyRegionContainer(1);
    private static final Affine3D TEMP_CACHEFILTER_TRANSFORM = new Affine3D();
    private static final RectBounds TEMP_BOUNDS = new RectBounds();
    // Fun with floating point
    private static final double EPSILON = 0.0000001;

    private RTTexture tempTexture;
    private double lastXDelta;
    private double lastYDelta;
    private ScrollCacheState scrollCacheState = ScrollCacheState.CHECKING_PRECONDITIONS;
    // Note: this ImageData is always created and assumed to be untransformed.
    private ImageData cachedImageData;
    private Rectangle cacheBounds = new Rectangle();
    // Used to draw into the cache
    private final Affine2D cachedXform = new Affine2D();

    // The scale and rotate used to draw into the cache
    private double cachedScaleX;
    private double cachedScaleY;
    private double cachedRotate;

    private double cachedX;
    private double cachedY;
    private NGNode node;

    // Used to draw the cached image to the screen
    private final Affine2D screenXform = new Affine2D();

    // Cache hint settings
    private boolean scaleHint;
    private boolean rotateHint;
    // We keep this around for the sake of matchesHint
    private CacheHint cacheHint;

    // Was the last paint unsupported by the cache?  If so, will need to
    // regenerate the cache next time.
    private boolean wasUnsupported = false;

    /**
     * Compute the dirty region that must be re-rendered after scrolling
     */
    private Rectangle computeDirtyRegionForTranslate() {
        if (lastXDelta != 0) {
            if (lastXDelta &gt; 0) {
                TEMP_RECT.setBounds(0, 0, (int)lastXDelta, cacheBounds.height);
            } else {
                TEMP_RECT.setBounds(cacheBounds.width + (int)lastXDelta, 0, -(int)lastXDelta, cacheBounds.height);
            }
        } else {
            if (lastYDelta &gt; 0) {
                TEMP_RECT.setBounds(0, 0, cacheBounds.width, (int)lastYDelta);
            } else {
                TEMP_RECT.setBounds(0, cacheBounds.height + (int)lastYDelta, cacheBounds.width, -(int)lastYDelta);
            }
        }
        return TEMP_RECT;
    }

    protected CacheFilter(NGNode node, CacheHint cacheHint) {
        this.node = node;
        this.scrollCacheState = ScrollCacheState.CHECKING_PRECONDITIONS;
        setHint(cacheHint);
    }

    public void setHint(CacheHint cacheHint) {
        this.cacheHint = cacheHint;
        this.scaleHint = (cacheHint == CacheHint.SPEED ||
                          cacheHint == CacheHint.SCALE ||
                          cacheHint == CacheHint.SCALE_AND_ROTATE);
        this.rotateHint = (cacheHint == CacheHint.SPEED ||
                           cacheHint == CacheHint.ROTATE ||
                           cacheHint == CacheHint.SCALE_AND_ROTATE);
    }

    // These two methods exist only for the sake of testing.
    final boolean isScaleHint() { return scaleHint; }
    final boolean isRotateHint() { return rotateHint; }

    /**
     * Indicates whether this CacheFilter's hint matches the CacheHint
     * passed in.
     */
    boolean matchesHint(CacheHint cacheHint) {
        return this.cacheHint == cacheHint;
    }

    /**
     * Are we attempting to use cache for an unsupported transform mode?  Mostly
     * this is for trying to rotate while scaling the object by different
     * amounts in the x and y directions (this also includes shearing).
     */
    boolean unsupported(double[] xformInfo) {
        double scaleX = xformInfo[0];
        double scaleY = xformInfo[1];
        double rotate = xformInfo[2];

        // If we're trying to rotate...
        if (rotate &gt; EPSILON || rotate &lt; -EPSILON) {
            // ...and if scaleX != scaleY.  This can be in the render xform, or
            // may have made it into the cached image.
            if (scaleX &gt; scaleY + EPSILON || scaleY &gt; scaleX + EPSILON ||
                scaleX &lt; scaleY - EPSILON || scaleY &lt; scaleX - EPSILON ||
                cachedScaleX &gt; cachedScaleY + EPSILON ||
                cachedScaleY &gt; cachedScaleX + EPSILON ||
                cachedScaleX &lt; cachedScaleY - EPSILON ||
                cachedScaleY &lt; cachedScaleX - EPSILON ) {
                    return true;
            }
        }
        return false;
    }

    private boolean isXformScrollCacheCapable(double[] xformInfo) {
        if (unsupported(xformInfo)) {
            return false;
        }
        double rotate = xformInfo[2];
        return rotateHint || rotate == 0;
    }

    /*
     * Do we need to regenerate the cached image?
     * Assumes that caller locked and validated the cachedImageData.untximage
     * if not null...
     */
    private boolean needToRenderCache(BaseTransform renderXform, double[] xformInfo,
                                      float pixelScaleX, float pixelScaleY)
    {
        if (cachedImageData == null) {
            return true;
        }

        if (lastXDelta != 0 || lastYDelta != 0) {
            if (Math.abs(lastXDelta) &gt;= cacheBounds.width || Math.abs(lastYDelta) &gt;= cacheBounds.height ||
                    Math.rint(lastXDelta) != lastXDelta || Math.rint(lastYDelta) != lastYDelta) {
                node.clearDirtyTree(); // Need to clear dirty (by translation) flags in the children
                lastXDelta = lastYDelta = 0;
                return true;
            }
            if (scrollCacheState == ScrollCacheState.CHECKING_PRECONDITIONS) {
                if (scrollCacheCapable() &amp;&amp; isXformScrollCacheCapable(xformInfo)) {
                    scrollCacheState = ScrollCacheState.ENABLED;
                } else {
                    scrollCacheState = ScrollCacheState.DISABLED;
                    return true;
                }
            }
        }

        // TODO: is == sufficient for floating point comparison here? (RT-23963)
        if (cachedXform.getMxx() == renderXform.getMxx() &amp;&amp;
            cachedXform.getMyy() == renderXform.getMyy() &amp;&amp;
            cachedXform.getMxy() == renderXform.getMxy() &amp;&amp;
            cachedXform.getMyx() == renderXform.getMyx()) {
            // It's just a translation - use cached Image
            return false;
        }
        // Not just a translation - if was or is unsupported, then must rerender
        if (wasUnsupported || unsupported(xformInfo)) {
            return true;
        }

        double scaleX = xformInfo[0];
        double scaleY = xformInfo[1];
        double rotate = xformInfo[2];
        if (scaleHint) {
            if (cachedScaleX &lt; pixelScaleX || cachedScaleY &lt; pixelScaleY) {
                // We have moved onto a screen with a higher pixelScale and
                // our cache was less than that pixel scale.  Even though
                // we have the scaleHint, we always cache at a minimum of
                // the pixel scale of the screen so we need to re-cache.
                return true;
            }
            if (rotateHint) {
                return false;
            } else {
                // Not caching for rotate: regenerate cache if rotate changed
                if (cachedRotate - EPSILON &lt; rotate &amp;&amp; rotate &lt; cachedRotate + EPSILON) {
                    return false;
                } else {
                    return true;
                }
            }
        } else {
            if (rotateHint) {
                // Not caching for scale: regenerate cache if scale changed
                if (cachedScaleX - EPSILON &lt; scaleX &amp;&amp; scaleX &lt; cachedScaleX + EPSILON &amp;&amp;
                    cachedScaleY - EPSILON &lt; scaleY &amp;&amp; scaleY &lt; cachedScaleY + EPSILON) {
                    return false;
                } else {// Scale is not &quot;equal enough&quot; - regenerate
                    return true;
                }
            }
            else { // Not caching for anything; always regenerate
                return true;
            }
        }
    }

    /*
     * Given the new xform info, update the screenXform as needed to correctly
     * paint the cache to the screen.
     */
    void updateScreenXform(double[] xformInfo) {
        // screenXform will be the difference between the cachedXform and the
        // render xform.

        if (scaleHint) {
            if (rotateHint) {
                double screenScaleX = xformInfo[0] / cachedScaleX;
                double screenScaleY = xformInfo[1] / cachedScaleY;
                double screenRotate = xformInfo[2] - cachedRotate;

                screenXform.setToScale(screenScaleX, screenScaleY);
                screenXform.rotate(screenRotate);
            } else {
                double screenScaleX = xformInfo[0] / cachedScaleX;
                double screenScaleY = xformInfo[1] / cachedScaleY;
                screenXform.setToScale(screenScaleX, screenScaleY);
            }
        } else {
            if (rotateHint) {
                double screenRotate = xformInfo[2] - cachedRotate;
                screenXform.setToRotation(screenRotate, 0.0, 0.0);
            } else {
                // No caching, cache already rendered with xform; just paint it
<A NAME="3"></A>                screenXform.setTransform(BaseTransform.IDENTITY_TRANSFORM);
            }
        }
    <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#3',2,'match52-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    public void invalidate() {
        if (scrollCacheState == ScrollCacheState.ENABLED) {
            scrollCacheState = ScrollCacheState.CHECKING_PRECONDITIONS;
        }
        imageDataUnref();
        l</B></FONT>astXDelta = lastYDelta = 0;
    }

    void imageDataUnref() {
        if (tempTexture != null) {
            tempTexture.dispose();
            tempTexture = null;
        }
        if (cachedImageData != null) {
            // While we hold on to this ImageData we leave the texture
            // unlocked so it can be reclaimed, but the default unref()
            // method assumes it was locked.
            Filterable implImage = cachedImageData.getUntransformedImage();
            if (implImage != null) {
                implImage.lock();
            }
            cachedImageData.unref();
            cachedImageData = null;
        }
    }

    void invalidateByTranslation(double translateXDelta, double translateYDelta) {
        if (cachedImageData == null) {
            return;
        }

        if (scrollCacheState == ScrollCacheState.DISABLED) {
            imageDataUnref();
        } else {
             // When both mxt and myt change, we don't currently use scroll optimization
            if (translateXDelta != 0 &amp;&amp; translateYDelta != 0) {
                imageDataUnref();
            } else {
                lastYDelta = translateYDelta;
                lastXDelta = translateXDelta;
            }
        }
    }

    public void dispose() {
        invalidate();
        node = null;
    }

    /*
     * unmatrix() and the supporting functions are based on the code from
     * &quot;Decomposing A Matrix Into Simple Transformations&quot; by Spencer W. Thomas
     * from Graphics Gems II, as found at
     * http://tog.acm.org/resources/GraphicsGems/
     * which states, &quot;All code here can be used without restrictions.&quot;
     *
     * The code was reduced from handling a 4x4 matrix (3D w/ perspective)
     * to handle just a 2x2 (2D scale/rotate, w/o translate, as that is handled
     * separately).
     */

    /**
     * Given a BaseTransform, decompose it into values for scaleX, scaleY and
     * rotate.
     *
     * The return value is a double[3], the values being:
     *   [0]: scaleX
     *   [1]: scaleY
     *   [2]: rotation angle, in radians, between *** and ***
     *
     * From unmatrix() in unmatrix.c
     */
    double[] unmatrix(BaseTransform xform) {
        double[] retVal = new double[3];

        double[][] row = {{xform.getMxx(), xform.getMxy()},
            {xform.getMyx(), xform.getMyy()}};
        final double xSignum = unitDir(row[0][0]);
        final double ySignum = unitDir(row[1][1]);

        // Compute X scale factor and normalize first row.
        // tran[U_SCALEX] = V3Length(&amp;row[0]);
        // row[0] = *V3Scale(&amp;row[0], 1.0);

        double scaleX = xSignum * v2length(row[0]);
        v2scale(row[0], xSignum);

        // Compute XY shear factor and make 2nd row orthogonal to 1st.
        // tran[U_SHEARXY] = V3Dot(&amp;row[0], &amp;row[1]);
        // (void)V3Combine(&amp;row[1], &amp;row[0], &amp;row[1], 1.0, -tran[U_SHEARXY]);
        //
        // &quot;this is too large by the y scaling factor&quot;
        double shearXY = v2dot(row[0], row[1]);

        // Combine into row[1]
        v2combine(row[1], row[0], row[1], 1.0, -shearXY);

        // Now, compute Y scale and normalize 2nd row
        // tran[U_SCALEY] = V3Length(&amp;row[1]);
        // V3Scale(&amp;row[1], 1.0);
        // tran[U_SHEARXY] /= tran[U_SCALEY];

        double scaleY = ySignum * v2length(row[1]);
        v2scale(row[1], ySignum);

        // Now extract the rotation. (This is new code, not from the Gem.)
        //
        // In our matrix, we now have
        // [   cos(theta)    -sin(theta)    ]
        // [   sin(theta)     cos(theta)    ]
        //
        // TODO: assert: all 4 values are sane (RT-23962)
        //
        double sin = row[1][0];
        double cos = row[0][0];
        double angleRad = 0.0;

        // Recall:
        // arcsin works for theta: -90 -&gt; 90
        // arccos works for theta:   0 -&gt; 180
        if (sin &gt;= 0) {
            // theta is 0 -&gt; 180, use acos()
            angleRad = Math.acos(cos);
        } else {
            if (cos &gt; 0) {
                // sin &lt; 0, cos &gt; 0, so theta is 270 -&gt; 360, aka -90 -&gt; 0
                // use asin(), add 360
                angleRad = 2.0 * Math.PI + Math.asin(sin);
            } else {
                // sin &lt; 0, cos &lt; 0, so theta 180 -&gt; 270
                // cos from 180 -&gt; 270 is inverse of cos from 0-&gt;90,
                // so take acos(-cos) and add 180
                angleRad = Math.PI + Math.acos(-cos);
            }
        }

        retVal[0] = scaleX;
        retVal[1] = scaleY;
        retVal[2] = angleRad;

        return retVal;
    }

    /**
     * Return the unit distance in a direction compatible with the matrix element.
     * @param v the matrix element representing a scale factor
     * @return -1.0 if the matrix element is negative, otherwise 1.0
     */
    double unitDir(double v) {
        return v &lt; 0.0 ? -1.0 : 1.0;
    }

    /**
     * make a linear combination of two vectors and return the result
     * result = (v0 * scalarA) + (v1 * scalarB)
     *
     * From V3Combine() in GGVecLib.c
     */
    void v2combine(double v0[], double v1[], double result[], double scalarA, double scalarB) {
        // make a linear combination of two vectors and return the result.
        // result = (a * ascl) + (b * bscl)
        /*
        Vector3 *V3Combine (a, b, result, ascl, bscl)
        Vector3 *a, *b, *result;
        double ascl, bscl;
        {
                result-&gt;x = (ascl * a-&gt;x) + (bscl * b-&gt;x);
                result-&gt;y = (ascl * a-&gt;y) + (bscl * b-&gt;y);
                result-&gt;z = (ascl * a-&gt;z) + (bscl * b-&gt;z);
                return(result);
        */

        result[0] = scalarA*v0[0] + scalarB*v1[0];
        result[1] = scalarA*v0[1] + scalarB*v1[1];
    }

    /**
     * dot product of 2 vectors of length 2
     */
    double v2dot(double v0[], double v1[]) {
        return v0[0]*v1[0] + v0[1]*v1[1];
    }

    /**
     * scale v[] to be relative to newLen
     *
     * From V3Scale() in GGVecLib.c
     */
    void v2scale(double v[], double newLen) {
        double len = v2length(v);
        if (len != 0) {
            v[0] *= newLen / len;
            v[1] *= newLen / len;
        }
    }

    /**
     * returns length of input vector
     *
     * Based on V3Length() in GGVecLib.c
     */
    double v2length(double v[]) {
        return Math.sqrt(v[0]*v[0] + v[1]*v[1]);
    }

    void render(Graphics g) {
        // The following is safe; xform will not be mutated below
        BaseTransform xform = g.getTransformNoClone();
        FilterContext fctx = PrFilterContext.getInstance(g.getAssociatedScreen()); // getFilterContext

        double[] xformInfo = unmatrix(xform);
        boolean isUnsupported = unsupported(xformInfo);

        lastXDelta = lastXDelta * xformInfo[0];
        lastYDelta = lastYDelta * xformInfo[1];

        if (cachedImageData != null) {
            Filterable implImage = cachedImageData.getUntransformedImage();
            if (implImage != null) {
                implImage.lock();
                if (!cachedImageData.validate(fctx)) {
                    implImage.unlock();
                    invalidate();
                }
            }
        }
        float pixelScaleX = g.getPixelScaleFactorX();
        float pixelScaleY = g.getPixelScaleFactorY();
        if (needToRenderCache(xform, xformInfo, pixelScaleX, pixelScaleY)) {
            if (PulseLogger.PULSE_LOGGING_ENABLED) {
                PulseLogger.incrementCounter(&quot;CacheFilter rebuilding&quot;);
            }
            if (cachedImageData != null) {
                Filterable implImage = cachedImageData.getUntransformedImage();
                if (implImage != null) {
                    implImage.unlock();
                }
                invalidate();
            }
            if (scaleHint) {
                // do not cache the image at a small scale factor when
                // scaleHint is set as it leads to poor rendering results
                // when image is scaled up.
                cachedScaleX = Math.max(pixelScaleX, xformInfo[0]);
                cachedScaleY = Math.max(pixelScaleY, xformInfo[1]);
                cachedRotate = 0;
                cachedXform.setTransform(cachedScaleX, 0.0,
                                         0.0, cachedScaleX,
                                         0.0, 0.0);
                updateScreenXform(xformInfo);
            } else {
                cachedScaleX = xformInfo[0];
                cachedScaleY = xformInfo[1];
                cachedRotate = xformInfo[2];

                // Update the cachedXform to the current xform (ignoring translate).
                cachedXform.setTransform(xform.getMxx(), xform.getMyx(),
                                         xform.getMxy(), xform.getMyy(),
                                         0.0, 0.0);

                // screenXform is always identity in this case, as we've just
                // rendered into the cache using the render xform.
                screenXform.setTransform(BaseTransform.IDENTITY_TRANSFORM);
            }

            cacheBounds = getCacheBounds(cacheBounds, cachedXform);
            cachedImageData = createImageData(fctx, cacheBounds);
            renderNodeToCache(cachedImageData, cacheBounds, cachedXform, null);

            // cachedBounds includes effects, and is in *scene* coords
            Rectangle cachedBounds = cachedImageData.getUntransformedBounds();

            // Save out the (un-transformed) x &amp; y coordinates.  This accounts
            // for effects and other reasons the untranslated location may not
            // be 0,0.
            cachedX = cachedBounds.x;
            cachedY = cachedBounds.y;

        } else {
            if (scrollCacheState == ScrollCacheState.ENABLED &amp;&amp;
                    (lastXDelta != 0 || lastYDelta != 0) ) {
                moveCacheBy(cachedImageData, lastXDelta, lastYDelta);
                renderNodeToCache(cachedImageData, cacheBounds, cachedXform, computeDirtyRegionForTranslate());
                lastXDelta = lastYDelta = 0;
            }
            // Using the cached image; calculate screenXform to paint to screen.
            if (isUnsupported) {
                // Only way we should be using the cached image in the
                // unsupported case is for a change in translate only.  No other
                // xform should be needed, so use identity.

                // TODO: assert cachedXform == render xform (ignoring translate)
                //   or  assert xforminfo == cachedXform info (RT-23962)
                screenXform.setTransform(BaseTransform.IDENTITY_TRANSFORM);
            } else {
                updateScreenXform(xformInfo);
            }
        }
        // If this render is unsupported, remember for next time.  We'll need
        // to regenerate the cache once we're in a supported scenario again.
        wasUnsupported = isUnsupported;

        Filterable implImage = cachedImageData.getUntransformedImage();
        if (implImage == null) {
            if (PulseLogger.PULSE_LOGGING_ENABLED) {
                PulseLogger.incrementCounter(&quot;CacheFilter not used&quot;);
            }
            renderNodeToScreen(g);
        } else {
            double mxt = xform.getMxt();
            double myt = xform.getMyt();
            renderCacheToScreen(g, implImage, mxt, myt);
            implImage.unlock();
        }
    }

    /**
     * Create the ImageData for the cached bitmap, with the specified bounds.
     */
    ImageData createImageData(FilterContext fctx, Rectangle bounds) {
        Filterable ret;
        try {
            ret = Effect.getCompatibleImage(fctx,
                    bounds.width, bounds.height);
            Texture cachedTex = ((PrDrawable) ret).getTextureObject();
            cachedTex.contentsUseful();
        } catch (Throwable e) {
            ret = null;
        }

        return new ImageData(fctx, ret, bounds);
    }

    /**
     * Render node to cache.
     * @param cacheData the cache
     * @param cacheBounds cache bounds
     * @param xform transformation
     * @param dirtyBounds null or dirty rectangle to be rendered
     */
    void renderNodeToCache(ImageData cacheData,
                                Rectangle cacheBounds,
                                BaseTransform xform,
                                Rectangle dirtyBounds) {
        final PrDrawable image = (PrDrawable) cacheData.getUntransformedImage();

        if (image != null) {
            Graphics g = image.createGraphics();
            TEMP_CACHEFILTER_TRANSFORM.setToIdentity();
            TEMP_CACHEFILTER_TRANSFORM.translate(-cacheBounds.x, -cacheBounds.y);
            if (xform != null) {
                TEMP_CACHEFILTER_TRANSFORM.concatenate(xform);
            }
            if (dirtyBounds != null) {
                TEMP_CONTAINER.deriveWithNewRegion((RectBounds)TEMP_BOUNDS.deriveWithNewBounds(dirtyBounds));
                // Culling might save us a lot when there's a dirty region
                node.doPreCulling(TEMP_CONTAINER, TEMP_CACHEFILTER_TRANSFORM, new GeneralTransform3D());
                g.setHasPreCullingBits(true);
                g.setClipRectIndex(0);
                g.setClipRect(dirtyBounds);
            }
            g.transform(TEMP_CACHEFILTER_TRANSFORM);
            if (node.getClipNode() != null) {
                node.renderClip(g);
            } else if (node.getEffectFilter() != null) {
                node.renderEffect(g);
            } else {
                node.renderContent(g);
            }
        }
    }

    /**
     * Render the node directly to the screen, in the case that the cached
     * image is unexpectedly null.  See RT-6428.
     */
    void renderNodeToScreen(Object implGraphics) {
        Graphics g = (Graphics)implGraphics;
        if (node.getEffectFilter() != null) {
            node.renderEffect(g);
        } else {
            node.renderContent(g);
        }
    }

    /**
     * Render the cached image to the screen, translated by mxt, myt.
     */
    void renderCacheToScreen(Object implGraphics, Filterable implImage,
                                  double mxt, double myt)
    {
        Graphics g = (Graphics)implGraphics;

        g.setTransform(screenXform.getMxx(),
                       screenXform.getMyx(),
                       screenXform.getMxy(),
                       screenXform.getMyy(),
                       mxt, myt);
        g.translate((float)cachedX, (float)cachedY);
        Texture cachedTex = ((PrDrawable)implImage).getTextureObject();
        Rectangle cachedBounds = cachedImageData.getUntransformedBounds();
        g.drawTexture(cachedTex, 0, 0,
                      cachedBounds.width, cachedBounds.height);
        // FYI: transform state is restored by the NGNode.render() method
    }

    /**
     * True if we can use scrolling optimization on this node.
     */
    boolean scrollCacheCapable() {
        if (!(node instanceof NGGroup)) {
            return false;
        }
        List&lt;NGNode&gt; children = ((NGGroup)node).getChildren();
        if (children.size() != 1) {
            return false;
        }
        NGNode child = children.get(0);
        if (!child.getTransform().is2D()) {
            return false;
        }

        NGNode clip = node.getClipNode();
        if (clip == null || !clip.isRectClip(BaseTransform.IDENTITY_TRANSFORM, false)) {
            return false;
        }

        if (node instanceof NGRegion) {
            NGRegion region = (NGRegion) node;
            if (!region.getBorder().isEmpty()) {
                return false;
            }
            final Background background = region.getBackground();

            if (!background.isEmpty()) {
                if (!background.getImages().isEmpty()
                        || background.getFills().size() != 1) {
                    return false;
                }
                BackgroundFill fill = background.getFills().get(0);
                javafx.scene.paint.Paint fillPaint = fill.getFill();
                BaseBounds clipBounds = clip.getCompleteBounds(TEMP_BOUNDS, BaseTransform.IDENTITY_TRANSFORM);

                return fillPaint.isOpaque() &amp;&amp; fillPaint instanceof Color &amp;&amp; fill.getInsets().equals(Insets.EMPTY)
                        &amp;&amp; clipBounds.getMinX() == 0 &amp;&amp; clipBounds.getMinY() == 0
                        &amp;&amp; clipBounds.getMaxX() == region.getWidth() &amp;&amp; clipBounds.getMaxY() == region.getHeight();
            }
        }

        return true;
    }

    /**
     * Moves a subregion of the cache, &quot;scrolling&quot; the cache by x/y Delta.
     * On of xDelta/yDelta must be zero. The rest of the pixels will be cleared.
     * @param cachedImageData cache
     * @param xDelta x-axis delta
     * @param yDelta y-axis delta
     */
    void moveCacheBy(ImageData cachedImageData, double xDelta, double yDelta) {
        PrDrawable drawable = (PrDrawable) cachedImageData.getUntransformedImage();
        final Rectangle r = cachedImageData.getUntransformedBounds();
        int x = (int)Math.max(0, (-xDelta));
        int y = (int)Math.max(0, (-yDelta));
        int destX = (int)Math.max(0, (xDelta));
        int destY = (int) Math.max(0, yDelta);
        int w = r.width - (int) Math.abs(xDelta);
        int h = r.height - (int) Math.abs(yDelta);

        final Graphics g = drawable.createGraphics();
        if (tempTexture != null) {
            tempTexture.lock();
            if (tempTexture.isSurfaceLost()) {
                tempTexture = null;
            }
        }
        if (tempTexture == null) {
            tempTexture = g.getResourceFactory().
                createRTTexture(drawable.getPhysicalWidth(), drawable.getPhysicalHeight(),
                                Texture.WrapMode.CLAMP_NOT_NEEDED);
        }
        final Graphics tempG = tempTexture.createGraphics();
        tempG.clear();
        tempG.drawTexture(drawable.getTextureObject(), 0, 0, w, h, x, y, x + w, y + h);
        tempG.sync();

        g.clear();
        g.drawTexture(tempTexture, destX, destY, destX + w, destY + h, 0, 0, w, h);
        tempTexture.unlock();
    }

    /**
     * Get the cache bounds.
     * @param bounds rectangle to store bounds to
     * @param xform transformation
     */
    Rectangle getCacheBounds(Rectangle bounds, BaseTransform xform) {
        final BaseBounds b = node.getClippedBounds(TEMP_BOUNDS, xform);
        bounds.setBounds(b);
        return bounds;
    }

    BaseBounds computeDirtyBounds(BaseBounds region, BaseTransform tx, GeneralTransform3D pvTx) {
        // For now, we just use the computed dirty bounds of the Node and
        // round them out before the transforms.
        // Later, we could use the bounds of the cache
        // to compute the dirty region directly (and more accurately).
        // See RT-34928 for more details.
        if (!node.dirtyBounds.isEmpty()) {
            region = region.deriveWithNewBounds(node.dirtyBounds);
        } else {
            region = region.deriveWithNewBounds(node.transformedBounds);
        }

        if (!region.isEmpty()) {
            region.roundOut();
            region = node.computePadding(region);
            region = tx.transform(region, region);
            region = pvTx.transform(region, region);
        }
        return region;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/sg/prism/NGGroup.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="20"></A> * questions.
 */

<FONT color="#d4a017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#20',2,'match52-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.javafx.sg.prism;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import com.sun.javafx.geom.DirtyRegionContainer;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.scene.NodeHelper;
import com.sun.prism.Graphics;
import com.sun.scenario.effect.Blend;
import com.sun.scenario.effect.Blend.Mode;
import com.sun.scenario.effect.FilterContext;
import com.sun.scenario.effect.ImageData;
import com.sun.scenario.effect.impl.prism.PrDrawable;
import com.sun.scenario.effect.impl.prism.PrEffectHelper;
import javafx.scene.Node;

/**
 */
public class NGGroup extends NGNode {
    /**
     * The blend mode to use with this group.
     */
    private Blend.Mode blendMode = Blend.Mode.SRC_OVER;
    // NOTE I need a special array list here where all nodes added can have
    // their parent set correctly, and all nodes removed have it cleared correctly.
    // Actually, if a node is removed, I probably don't have to worry about
    // clearing it because as soon as it is added to another parent it will be set
    // and there is no magic listener foo going on here.
    private List&lt;NGNode&gt; children = new</B></FONT> ArrayList&lt;&gt;(1);
    private List&lt;NGNode&gt; unmod = Collections.unmodifiableList(children);
    private List&lt;NGNode&gt; removed;

    /**
     * The viewOrderChildren is a list children sorted in decreasing viewOrder
     * order if it is not empty. Its size should always be equal to
     * children.size(). If viewOrderChildren is empty it implies that the
     * rendering order of the children is the same as the order in the children
     * list.
     */
    private final List&lt;NGNode&gt; viewOrderChildren = new ArrayList&lt;&gt;(1);

    /**
     * This mask has all bits that mark that a region intersects this group.
     * Which means it looks like this: 00010101010101010101010101010101 (first bit for sign)
     */
    private static final int REGION_INTERSECTS_MASK = 0x15555555;

    /***************************************************************************
     *                                                                         *
     * Implementation of the PGGroup interface                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Gets an unmodifiable list of the current children on this group
     */
    public List&lt;NGNode&gt; getChildren() { return unmod; }

    /**
     * Adds a node to the given index. An index of -1 means &quot;append&quot;, for legacy
     * reasons (it was easier than asking for the number of children, iirc).
     * @param index -1, or &lt;= node.size()
     * @param node
     */
    public void add(int index, NGNode node) {
        // Validate the arguments
        if ((index &lt; -1) || (index &gt; children.size())) {
            throw new IndexOutOfBoundsException(&quot;invalid index&quot;);
        }

        // NOTE: We used to do checks here to make sure that a node
        // being added didn't already have another parent listed as
        // its parent. Now we just silently accept them. The FX side
        // is already doing this check, and implementing this check
        // properly would require that the &quot;clear&quot; implementation visit
        // all nodes and clear this flag, which is really just wasted work.
        NGNode child = node;

        // When a new node is added, we need to make sure the new node has this
        // group registered as its parent. We also need to make sure I invalidate
        // this group's cache and mark it dirty. Note that we don't have to worry
        // about notifying the other parent that it has lost a node: the FX
        // scene graph will be sure to send a &quot;remove&quot; notification to the other
        // parent, so we don't have to be concerned with the other parent
        // having to be marked dirty or whatnot.
        child.setParent(this);
        childDirty = true;
        if (index == -1) {
            children.add(node);
        } else {
            children.add(index, node);
        }
        child.markDirty();
        markTreeDirtyNoIncrement();
        geometryChanged();
    }

    public void clearFrom(int fromIndex) {
        if (fromIndex &lt; children.size()) {
            children.subList(fromIndex, children.size()).clear();
            geometryChanged();
            childDirty = true;
            markTreeDirtyNoIncrement();
        }
    }

    public List&lt;NGNode&gt; getRemovedChildren() {
        return removed;
    }

    public void addToRemoved(NGNode n) {
        if (removed == null) removed = new ArrayList&lt;&gt;();
        if (dirtyChildrenAccumulated &gt; DIRTY_CHILDREN_ACCUMULATED_THRESHOLD) {
            return;
        }

        removed.add(n);
        dirtyChildrenAccumulated++;

        if (dirtyChildrenAccumulated &gt; DIRTY_CHILDREN_ACCUMULATED_THRESHOLD) {
            removed.clear(); //no need to store anything in this case
        }
    }

    @Override
    protected void clearDirty() {
        super.clearDirty();
        if (removed != null) removed.clear();
    }

    public void remove(NGNode node) {
        // We just remove the node and mark this group as being dirty. Really, if we
        // supported sub-regions within the group, we'd only have to mark the
        // sub-region that had been occupied by the node as dirty, but we do not
        // as yet have this optimization (mostly because we didn't have it in
        // Scenario, mostly because it was hard to optimize correctly).
        children.remove(node);
        geometryChanged();
        childDirty = true;
        markTreeDirtyNoIncrement();
    }

    public void remove(int index) {
        children.remove(index);
        geometryChanged();
        childDirty = true;
        markTreeDirtyNoIncrement();
    }

    public void clear() {
        children.clear();
        childDirty = false;
        geometryChanged();
        markTreeDirtyNoIncrement();
    }

    // Call this method if children view order is needed for rendering.
    // The returned list should be treated as read only.
    private List&lt;NGNode&gt; getOrderedChildren() {
        if (!viewOrderChildren.isEmpty()) {
            return viewOrderChildren;
        }
        return children;
    }

    // NOTE: This method is called on the FX application thread with the
    // RenderLock held.
    public void setViewOrderChildren(List&lt;Node&gt; sortedChildren) {
        viewOrderChildren.clear();
        for (Node child : sortedChildren) {
            NGNode childPeer = NodeHelper.getPeer(child);
            viewOrderChildren.add(childPeer);
        }

        // Mark visual dirty
        visualsChanged();
    }

    /**
     * Set by the FX scene graph.
     * @param blendMode cannot be null
     */
    public void setBlendMode(Object blendMode) {
        // Verify the arguments
        if (blendMode == null) {
            throw new IllegalArgumentException(&quot;Mode must be non-null&quot;);
        }
        // If the blend mode has changed, mark this node as dirty and
        // invalidate its cache
        if (this.blendMode != blendMode) {
            this.blendMode = (Blend.Mode)blendMode;
            visualsChanged();
        }
    }

    @Override
    public void renderForcedContent(Graphics gOptional) {
        List&lt;NGNode&gt; orderedChildren = getOrderedChildren();
        if (orderedChildren == null) {
            return;
        }
        for (int i = 0; i &lt; orderedChildren.size(); i++) {
            orderedChildren.get(i).renderForcedContent(gOptional);
        }
    }

    @Override
    protected void renderContent(Graphics g) {
        List&lt;NGNode&gt; orderedChildren = getOrderedChildren();
        if (orderedChildren == null) {
            return;
        }

        NodePath renderRoot = g.getRenderRoot();
        int startPos = 0;
        if (renderRoot != null) {
            if (renderRoot.hasNext()) {
                renderRoot.next();
                startPos = orderedChildren.indexOf(renderRoot.getCurrentNode());

                for (int i = 0; i &lt; startPos; ++i) {
                    orderedChildren.get(i).clearDirtyTree();
                }
            } else {
                g.setRenderRoot(null);
            }
        }

        if (blendMode == Blend.Mode.SRC_OVER ||
                orderedChildren.size() &lt; 2) {  // Blend modes only work &quot;between&quot; siblings

            for (int i = startPos; i &lt; orderedChildren.size(); i++) {
                NGNode child;
                try {
                    child = orderedChildren.get(i);
                } catch (Exception e) {
                    child = null;
                }
                // minimal protection against concurrent update of the list.
                if (child != null) {
                    child.render(g);
                }
            }
            return;
        }

        Blend b = new Blend(blendMode, null, null);
        FilterContext fctx = getFilterContext(g);

        ImageData bot = null;
        boolean idValid = true;
        do {
            // TODO: probably don't need to wrap the transform here... (RT-26981)
            BaseTransform transform = g.getTransformNoClone().copy();
            if (bot != null) {
                bot.unref();
                bot = null;
            }
            Rectangle rclip = PrEffectHelper.getGraphicsClipNoClone(g);
            for (int i = startPos; i &lt; orderedChildren.size(); i++) {
                NGNode child = orderedChildren.get(i);
                ImageData top = NodeEffectInput.
                    getImageDataForNode(fctx, child, false, transform, rclip);
                if (bot == null) {
                    bot = top;
                } else {
                    ImageData newbot =
                        b.filterImageDatas(fctx, transform, rclip, null, bot, top);
                    bot.unref();
                    top.unref();
                    bot = newbot;
                }
            }
            if (bot != null &amp;&amp; (idValid = bot.validate(fctx))) {
                Rectangle r = bot.getUntransformedBounds();
                PrDrawable botimg = (PrDrawable)bot.getUntransformedImage();
                g.setTransform(bot.getTransform());
                g.drawTexture(botimg.getTextureObject(),
                        r.x, r.y, r.width, r.height);
            }
        } while (bot == null || !idValid);

        if (bot != null) {
            bot.unref();
        }
    }

    @Override
    protected boolean hasOverlappingContents() {
        if (blendMode != Mode.SRC_OVER) {
            // All other modes are flattened so there are no overlapping issues
            return false;
        }
        List&lt;NGNode&gt; orderedChildren = getOrderedChildren();
        int n = (orderedChildren == null ? 0 : orderedChildren.size());
        if (n == 1) {
            return orderedChildren.get(0).hasOverlappingContents();
        }
        return (n != 0);
    }

    public boolean isEmpty() {
        return children == null || children.isEmpty();
    }

    @Override
    protected boolean hasVisuals() {
        return false;
    }


    @Override
    protected boolean needsBlending() {
        Blend.Mode mode = getNodeBlendMode();
        // TODO: If children are all SRC_OVER then we can pass on SRC_OVER too
        // (RT-26981)
        return (mode != null);
    }

    /***************************************************************************
     *                                                                         *
     *                     Culling Related Methods                             *
     *                                                                         *
     **************************************************************************/
    @Override
    protected RenderRootResult computeRenderRoot(NodePath path, RectBounds dirtyRegion, int cullingIndex, BaseTransform tx,
                                       GeneralTransform3D pvTx) {

        // If the NGGroup is completely outside the culling area, then we don't have to traverse down
        // to the children yo.
        if (cullingIndex != -1) {
            final int bits = cullingBits &gt;&gt; (cullingIndex*2);
            if ((bits &amp; DIRTY_REGION_CONTAINS_OR_INTERSECTS_NODE_BOUNDS) == 0) {
                return RenderRootResult.NO_RENDER_ROOT;
            }
            if ((bits &amp; DIRTY_REGION_CONTAINS_NODE_BOUNDS) != 0) {
                cullingIndex = -1; // Do not check culling in children,
                                   // as culling bits are not set for fully interior groups
            }
        }

        if (!isVisible()) {
            return RenderRootResult.NO_RENDER_ROOT;
        }

        if (getOpacity() != 1.0 || (getEffect() != null &amp;&amp; getEffect().reducesOpaquePixels()) || needsBlending()) {
            return RenderRootResult.NO_RENDER_ROOT;
        }

        if (getClipNode() != null) {
            final NGNode clip = getClipNode();
            RectBounds clipBounds = clip.getOpaqueRegion();
            if (clipBounds == null) {
                return RenderRootResult.NO_RENDER_ROOT;
            }
            TEMP_TRANSFORM.deriveWithNewTransform(tx).deriveWithConcatenation(getTransform()).deriveWithConcatenation(clip.getTransform());
            if (!checkBoundsInQuad(clipBounds, dirtyRegion, TEMP_TRANSFORM, pvTx)) {
                return RenderRootResult.NO_RENDER_ROOT;
            }
        }

        // An NGGroup itself never draws pixels, so we don't have to call super. Just visit
        // each child, starting with the top-most.
        double mxx = tx.getMxx();
        double mxy = tx.getMxy();
        double mxz = tx.getMxz();
        double mxt = tx.getMxt();

        double myx = tx.getMyx();
        double myy = tx.getMyy();
        double myz = tx.getMyz();
        double myt = tx.getMyt();

        double mzx = tx.getMzx();
        double mzy = tx.getMzy();
        double mzz = tx.getMzz();
        double mzt = tx.getMzt();
        final BaseTransform chTx = tx.deriveWithConcatenation(getTransform());

        // We need to keep a reference to the result of calling computeRenderRoot on each child
        RenderRootResult result = RenderRootResult.NO_RENDER_ROOT;
        // True if every child _after_ the the found render root is clean
        boolean followingChildrenClean = true;
        // Iterate over all children, looking for a render root.
        List&lt;NGNode&gt; orderedChildren = getOrderedChildren();
        for (int resultIdx = orderedChildren.size() - 1; resultIdx &gt;= 0; resultIdx--) {
            // Get the render root result from the child
            final NGNode child = orderedChildren.get(resultIdx);
            result = child.computeRenderRoot(path, dirtyRegion, cullingIndex, chTx, pvTx);
            // Update this flag, which if true means that this child and all subsequent children
            // of this group are all clean.
            followingChildrenClean &amp;= child.isClean();

            if (result == RenderRootResult.HAS_RENDER_ROOT) {
                // If we have a render root and it is dirty, then we don't really care whether
                // followingChildrenClean is true or false, we just add this group to the
                // path and we're done.
                path.add(this);
                break;
            } else if (result == RenderRootResult.HAS_RENDER_ROOT_AND_IS_CLEAN) {
                path.add(this);
                // If we have a result which is itself reporting that it is clean, but
                // we have some following children which are dirty, then we need to
                // switch the result for this Group to be HAS_RENDER_ROOT.
                if (!followingChildrenClean) {
                    result = RenderRootResult.HAS_RENDER_ROOT;
                }
                break;
            }
        }
        // restore previous transform state
        tx.restoreTransform(mxx, mxy, mxz, mxt, myx, myy, myz, myt, mzx, mzy, mzz, mzt);
        return result;
    }

    @Override
    protected void markCullRegions(
            DirtyRegionContainer drc,
            int cullingRegionsBitsOfParent,
            BaseTransform tx,
            GeneralTransform3D pvTx) {

        //set culling bits for this group first.
        super.markCullRegions(drc, cullingRegionsBitsOfParent, tx, pvTx);

        //cullingRegionsBits == 0 group is outside all dirty regions
        // we can cull all children otherwise check children.
        // If none of the regions intersect this group, skip pre-culling
        if (cullingBits == -1 || (cullingBits != 0 &amp;&amp; (cullingBits &amp; REGION_INTERSECTS_MASK) != 0)) {
            //save current transform
            double mxx = tx.getMxx();
            double mxy = tx.getMxy();
            double mxz = tx.getMxz();
            double mxt = tx.getMxt();

            double myx = tx.getMyx();
            double myy = tx.getMyy();
            double myz = tx.getMyz();
            double myt = tx.getMyt();

            double mzx = tx.getMzx();
            double mzy = tx.getMzy();
            double mzz = tx.getMzz();
            double mzt = tx.getMzt();
            BaseTransform chTx = tx.deriveWithConcatenation(getTransform());

            NGNode child;
            List&lt;NGNode&gt; orderedChildren = getOrderedChildren();
            for (int chldIdx = 0; chldIdx &lt; orderedChildren.size(); chldIdx++) {
                child = orderedChildren.get(chldIdx);
                child.markCullRegions(
                        drc,
                        cullingBits,
                        chTx,
                        pvTx);
            }
            // restore previous transform state
            tx.restoreTransform(mxx, mxy, mxz, mxt, myx, myy, myz, myt, mzx, mzy, mzz, mzt);
        }
    }

    @Override
    public void drawDirtyOpts(final BaseTransform tx, final GeneralTransform3D pvTx,
                              Rectangle clipBounds, int[] countBuffer, int dirtyRegionIndex) {
        super.drawDirtyOpts(tx, pvTx, clipBounds, countBuffer, dirtyRegionIndex);
        // Not really efficient but this code is only executed during debug. This makes sure
        // that the source transform (tx) is not modified.
        BaseTransform clone = tx.copy();
        clone = clone.deriveWithConcatenation(getTransform());
        List&lt;NGNode&gt; orderedChildren = getOrderedChildren();
        for (int childIndex = 0; childIndex &lt; orderedChildren.size(); childIndex++) {
            final NGNode child = orderedChildren.get(childIndex);
            child.drawDirtyOpts(clone, pvTx, clipBounds, countBuffer, dirtyRegionIndex);
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/sg/prism/NGRegion.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.sg.prism;

import javafx.geometry.Insets;
import javafx.geometry.Side;
import javafx.scene.layout.Background;
import javafx.scene.layout.BackgroundFill;
import javafx.scene.layout.BackgroundImage;
import javafx.scene.layout.BackgroundPosition;
import javafx.scene.layout.BackgroundRepeat;
import javafx.scene.layout.BackgroundSize;
import javafx.scene.layout.Border;
import javafx.scene.layout.BorderImage;
import javafx.scene.layout.BorderRepeat;
import javafx.scene.layout.BorderStroke;
import javafx.scene.layout.BorderStrokeStyle;
import javafx.scene.layout.BorderWidths;
import javafx.scene.layout.CornerRadii;
import javafx.scene.paint.Color;
import javafx.scene.paint.LinearGradient;
import javafx.scene.shape.StrokeLineCap;
import javafx.scene.shape.StrokeLineJoin;
import javafx.scene.shape.StrokeType;

import java.util.Collections;
import java.util.List;
import java.util.WeakHashMap;

import com.sun.glass.ui.Screen;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.logging.PulseLogger;
import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.tk.Toolkit;
import com.sun.prism.BasicStroke;
import com.sun.prism.Graphics;
import com.sun.prism.Image;
import com.sun.prism.RTTexture;
import com.sun.prism.Texture;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.paint.ImagePattern;
import com.sun.prism.paint.Paint;
import com.sun.scenario.effect.Offset;

/**
 * Implementation of the Region peer. This behaves like an NGGroup, in that
 * it has children, but like a leaf node, in that it also draws itself if it has
 * a Background or Border which contains non-transparent fills / strokes / images.
 */
public class NGRegion extends NGGroup {
    /**
     * This scratch transform is used when transforming shapes. Because this is
     * a static variable, it is only intended to be used from a single thread,
     * the render thread in this case.
     */
    private static final Affine2D SCRATCH_AFFINE = new Affine2D();

    /**
     * Temporary rect for general use. Because this is a static variable,
     * it is only intended to be used from a single thread, the render thread
     * in this case.
     */
    private static final Rectangle TEMP_RECT = new Rectangle();

    /**
     * Screen to RegionImageCache mapping. This mapping is required as textures
     * are only valid in graphics context used to create them (relies on a one
     * to one mapping between Screen and GraphicsContext).
     */
    private static WeakHashMap&lt;Screen, RegionImageCache&gt; imageCacheMap = new WeakHashMap&lt;&gt;();

    /**
     * Indicates the cached image can be sliced vertically.
     */
    private static final int CACHE_SLICE_V = 0x1;

    /**
     * Indicates the cached image can be sliced horizontally.
     */
    private static final int CACHE_SLICE_H = 0x2;

    /**
     * The background to use for drawing. Since this is an immutable object, I can simply refer to
     * its fields / methods directly when rendering. I will make sure this is not ever null at
     * the time that we do the sync, so that the code in this class can assume non-null.
     */
    private Background background = Background.EMPTY;

    /**
     * The combined insets of all the backgrounds. As of right now, Background doesn't store
     * this information itself, although it probably could (and probably should).
     */
    private Insets backgroundInsets = Insets.EMPTY;

    /**
     * The border to use for drawing. Similar to background, this is not-null and immutable.
     */
    private Border border = Border.EMPTY;

    /**
     * The normalized list of CornerRadii have been precomputed at the FX layer to
     * properly account for percentages, insets and radii scaling to prevent
     * the radii from overflowing the dimensions of the region.
     * The List objects are shared with the FX layer and are therefore
     * unmodifiable.  If the normalized list is null then it means that all
     * of the raw radii in the list were already absolute and non-overflowing
     * and so the originals can be used from the arrays of strokes and fills.
     */
    private List&lt;CornerRadii&gt; normalizedFillCorners;
    private List&lt;CornerRadii&gt; normalizedStrokeCorners;

    /**
     * The shape of the region. Usually this will be null (except for things like check box
     * checks, scroll bar down arrows / up arrows, etc). If this is not null, it determines
     * the shape of the region to draw. If it is null, then the assumed shape of the region is
     * one of a rounded rectangle. This shape is a com.sun.javafx.geom.Shape, and is not
     * touched by the FX scene graph except during synchronization, so it is safe to access
     * on the render thread.
     */
    private Shape shape;
    private NGShape ngShape;

    /**
     * Whether we should scale the shape to match the bounds of the region. Only applies
     * if the shape is not null.
     */
    private boolean scaleShape = true;

    /**
     * Whether we should center the shape within the bounds of the region. Only applies
     * if the shape is not null.
     */
    private boolean centerShape = true;

    /**
     * Whether we should attempt to use region caching for a region with a shape.
     */
    private boolean cacheShape = false;

    /**
     * A cached set of the opaque insets as given to us during synchronization. We hold
     * on to this so that we can determine the opaque insets in the computeOpaqueRegion method.
     */
    private float opaqueTop = Float.NaN,
            opaqueRight = Float.NaN,
            opaqueBottom = Float.NaN,
            opaqueLeft = Float.NaN;

    /**
     * The width and height of the region.
     */
    private float width, height;

    /**
     * Determined when a background is set on the region, this flag indicates whether this
     * background can be cached. As of this time, the only backgrounds which can be cached
     * are those where there are only solid fills or linear gradients.
     */
    private int cacheMode;

    /**
     * Is the key into the image cache that identifies the required background
     * for the region.
     */
    private Integer cacheKey;

    /**
     * Simple Helper Function for cleanup.
     */
    static Paint getPlatformPaint(javafx.scene.paint.Paint paint) {
        return (Paint)Toolkit.getPaintAccessor().getPlatformPaint(paint);
    }

    // We create a class instance of a no op. Effect internally to handle 3D
    // transform if user didn't use Effect for 3D Transformed Region. This will
    // automatically forces Region rendering path to use the Effect path.
    private static final Offset nopEffect = new Offset(0, 0, null);
    private EffectFilter nopEffectFilter;

    /**************************************************************************
     *                                                                        *
     * Methods used during synchronization only.                              *
     *                                                                        *
     *************************************************************************/

    /**
     * Called by the Region during synchronization. The Region *should* ensure that this is only
     * called when one of these properties has changed. The cost of calling it excessively is
     * only that the opaque region is invalidated excessively. Updating the shape and
     * associated booleans is actually a very cheap operation.
     *
     * @param shape    The shape, may be null.
     * @param scaleShape whether to scale the shape
     * @param positionShape whether to center the shape
     */
    public void updateShape(Object shape, boolean scaleShape, boolean positionShape, boolean cacheShape) {
        this.ngShape = shape == null ? null : NodeHelper.getPeer(((javafx.scene.shape.Shape)shape));
        this.shape = shape == null ? null : ngShape.getShape();
        this.scaleShape = scaleShape;
        this.centerShape = positionShape;
        this.cacheShape = cacheShape;
        // Technically I don't think this is needed because whenever the shape changes, setOpaqueInsets
        // is also called, so this will get invalidated twice.
        invalidateOpaqueRegion();
        cacheKey = null;
        visualsChanged();
    }

    /**
     * Called by the Region whenever the width or height of the region has changed.
     * The Region *should* only call this when the width or height have actually changed.
     *
     * @param width     The width of the region, not including insets or outsets
     * @param height    The height of the region, not including insets or outsets
     */
    public void setSize(float width, float height) {
        this.width = width;
        this.height = height;
        invalidateOpaqueRegion();
        cacheKey = null;
        visualsChanged();
        // We only have to clear the background insets when the size changes if the
        // background has fills who's insets are dependent on the size (as would be
        // true only if a CornerRadii of any background fill on the background had
        // a percentage based radius).
        if (background != null &amp;&amp; background.isFillPercentageBased()) {
            backgroundInsets = null;
        }
    }

    /**
     * Called by Region whenever an image that was being loaded in the background has
     * finished loading. Nothing changes in terms of metrics or sizes or caches, but
     * we do need to repaint everything.
     */
    public void imagesUpdated() {
        visualsChanged();
    }

    /**
     * Called by the Region when the Border is changed. The Region *must* only call
     * this method if the border object has actually changed, or excessive work may be done.
     *
     * @param b Border, of type javafx.scene.layout.Border
     */
    public void updateBorder(Border b) {
        // Make sure that the border instance we store on this NGRegion is never null
        final Border old = border;
        border = b == null ? Border.EMPTY : b;

        // Determine whether the geometry has changed, or if only the visuals have
        // changed. Geometry changes will require more work, and an equals check
        // on the border objects is generally very fast (either for identity or
        // for !equals. It is a bit longer for when they really are equal, but faster
        // than a geometryChanged!)
        if (!border.getOutsets().equals(old.getOutsets())) {
            geometryChanged();
        } else {
            visualsChanged();
        }
    }

    /**
     * Called by the Region when any parameters are changed.
     * It is only technically needed when a parameter that affects the size
     * of any percentage or overflowing corner radii is changed, but since
     * the data is not processed here in NGRegion, it is set on every update
     * of the peers for any reason.
     * A null value means that the raw radii in the BorderStroke objects
     * themselves were already absolute and non-overflowing.
     *
     * @param normalizedStrokeCorners a precomputed copy of the radii in the
     *        BorderStroke objects that are not percentages and do not overflow
     */
    public void updateStrokeCorners(List&lt;CornerRadii&gt; normalizedStrokeCorners) {
        this.normalizedStrokeCorners = normalizedStrokeCorners;
    }

    /**
     * Returns the normalized (non-percentage, non-overflowing) radii for the
     * selected index into the BorderStroke objects.
     * If a List was synchronized from the Region object, the value from that
     * List, otherwise the raw radii are fetched from the indicated BorderStroke
     * object.
     *
     * @param index the index of the BorderStroke object being processed
     * @return the normalized radii for the indicated BorderStroke object
     */
    private CornerRadii getNormalizedStrokeRadii(int index) {
        return (normalizedStrokeCorners == null
                ? border.getStrokes().get(index).getRadii()
                : normalizedStrokeCorners.get(index));
    }

    /**
     * Called by the Region when the Background has changed. The Region *must* only call
     * this method if the background object has actually changed, or excessive work may be done.
     *
     * @param b    Background, of type javafx.scene.layout.Background. Can be null.
     */
    public void updateBackground(Background b) {
        // NOTE: We don't explicitly invalidate the opaque region in this method, because the
        // Region will always call setOpaqueInsets whenever the background is changed, and
        // setOpaqueInsets always invalidates the opaque region. So we don't have to do it
        // again here. This wasn't immediately obvious and it might be better to combine
        // the updateBackground and setOpaqueInsets methods into one call, so that we
        // can more easily ensure that the opaque region is updated correctly.

        // Make sure that the background instance we store on this NGRegion is never null
        final Background old = background;
        background = b == null ? Background.EMPTY : b;

        final List&lt;BackgroundFill&gt; fills = background.getFills();
        cacheMode = 0;
        if (!PrismSettings.disableRegionCaching &amp;&amp; !fills.isEmpty() &amp;&amp; (shape == null || cacheShape)) {
            cacheMode = CACHE_SLICE_H | CACHE_SLICE_V;
            for (int i=0, max=fills.size(); i&lt;max &amp;&amp; cacheMode != 0; i++) {
                // We need to now inspect the paint to determine whether we can use a cache for this background.
                // If a shape is being used, we don't care about gradients (we cache 'em both), but for a rectangle
                // fill we omit these (so we can do 3-patch scaling). An ImagePattern is deadly to either
                // (well, only deadly to a shape if it turns out to be a writable image).
                final BackgroundFill fill = fills.get(i);
                javafx.scene.paint.Paint paint = fill.getFill();
                if (shape == null) {
                    if (paint instanceof LinearGradient) {
                        LinearGradient linear = (LinearGradient) paint;
                        if (linear.getStartX() != linear.getEndX()) {
                            cacheMode &amp;= ~CACHE_SLICE_H;
                        }
                        if (linear.getStartY() != linear.getEndY()) {
                            cacheMode &amp;= ~CACHE_SLICE_V;
                        }
                    } else if (!(paint instanceof Color)) {
                        //Either radial gradient or image pattern
                        cacheMode = 0;
                    }
                } else if (paint instanceof javafx.scene.paint.ImagePattern) {
                    cacheMode = 0;
                }
            }
        }
        backgroundInsets = null;
        cacheKey = null;

        // Only update the geom if the new background is geometrically different from the old
        if (!background.getOutsets().equals(old.getOutsets())) {
            geometryChanged();
        } else {
            visualsChanged();
        }
    }

    /**
     * Called by the Region when any parameters are changed.
     * It is only technically needed when a parameter that affects the size
     * of any percentage or overflowing corner radii is changed, but since
     * the data is not processed here in NGRegion, it is set on every update
     * of the peers for any reason.
     * A null value means that the raw radii in the BackgroundFill objects
     * themselves were already absolute and non-overflowing.
     *
     * @param normalizedStrokeCorners a precomputed copy of the radii in the
     *        BackgroundFill objects that are not percentages and do not overflow
     */
    public void updateFillCorners(List&lt;CornerRadii&gt; normalizedFillCorners) {
        this.normalizedFillCorners = normalizedFillCorners;
    }

    /**
     * Returns the normalized (non-percentage, non-overflowing) radii for the
     * selected index into the BackgroundFill objects.
     * If a List was synchronized from the Region object, the value from that
     * List, otherwise the raw radii are fetched from the indicated BackgroundFill
     * object.
     *
     * @param index the index of the BackgroundFill object being processed
     * @return the normalized radii for the indicated BackgroundFill object
     */
    private CornerRadii getNormalizedFillRadii(int index) {
        return (normalizedFillCorners == null
                ? background.getFills().get(index).getRadii()
                : normalizedFillCorners.get(index));
    }

    /**
     * Called by the Region whenever it knows that the opaque insets have changed. The
     * Region &lt;strong&gt;must&lt;/strong&gt; make sure that these opaque insets include the opaque
     * inset information from the Border and Background as well, the NGRegion will not
     * recompute this information. This is done because Border and Background are immutable,
     * and as such this information is computed once and stored rather than recomputed
     * each time we have to render. Any developer supplied opaque insets must be combined
     * with the Border / Background intrinsic opaque insets prior to this call and passed
     * as the arguments to this method.
     *
     * @param top       The top, if NaN then there is no opaque inset at all
     * @param right     The right, must not be NaN or Infinity, etc.
     * @param bottom    The bottom, must not be NaN or Infinity, etc.
     * @param left      The left, must not be NaN or Infinity, etc.
     */
    public void setOpaqueInsets(float top, float right, float bottom, float left) {
        opaqueTop = top;
        opaqueRight = right;
        opaqueBottom = bottom;
        opaqueLeft = left;
        invalidateOpaqueRegion();
    }

    /**
     * When cleaning the dirty tree, we also have to keep in mind
     * the NGShape used by the NGRegion
     */
    @Override public void clearDirtyTree() {
        super.clearDirtyTree();
        if (ngShape != null) {
            ngShape.clearDirtyTree();
        }
    }

    /**************************************************************************
     *                                                                        *
     * Implementations of methods defined in the parent classes, with the     *
     * exception of rendering methods.                                        *
     *                                                                        *
     *************************************************************************/

    private RegionImageCache getImageCache(final Graphics g) {
        final Screen screen = g.getAssociatedScreen();
        RegionImageCache cache = imageCacheMap.get(screen);
        if (cache != null) {
            RTTexture tex = cache.getBackingStore();
            if (tex.isSurfaceLost()) {
                imageCacheMap.remove(screen);
                cache = null;
            }
        }
        if (cache == null) {
            cache = new RegionImageCache(g.getResourceFactory());
            imageCacheMap.put(screen, cache);
        }
        return cache;
    }

    private Integer getCacheKey(int w, int h) {
        if (cacheKey == null) {
            int key = 31 * w;
            key = key * 37 + h;
            key = key * 47 + background.hashCode();
            if (shape != null) {
                key = key * 73 + shape.hashCode();
            }
            cacheKey = key;
        }
        return cacheKey;
    }

    @Override protected boolean supportsOpaqueRegions() { return true; }

    @Override
    protected boolean hasOpaqueRegion() {
        return super.hasOpaqueRegion() &amp;&amp;
                !Float.isNaN(opaqueTop) &amp;&amp; !Float.isNaN(opaqueRight) &amp;&amp;
                !Float.isNaN(opaqueBottom) &amp;&amp; !Float.isNaN(opaqueLeft);
    }

    /**
     * The opaque region of an NGRegion takes into account the opaque insets
     * specified by the Region during synchronization. It also takes into
     * account the clip and the effect.
     *
     * @param opaqueRegion
     * @return
     */
    @Override protected RectBounds computeOpaqueRegion(RectBounds opaqueRegion) {
        // TODO what to do if the opaqueRegion has negative width or height due to excessive opaque insets? (RT-26979)
        return (RectBounds) opaqueRegion.deriveWithNewBounds(opaqueLeft, opaqueTop, 0, width - opaqueRight, height - opaqueBottom, 0);
    }

    @Override protected RenderRootResult computeRenderRoot(NodePath path, RectBounds dirtyRegion,
                                                           int cullingIndex, BaseTransform tx,
                                                           GeneralTransform3D pvTx) {

        RenderRootResult result = super.computeRenderRoot(path, dirtyRegion, cullingIndex, tx, pvTx);
        if (result == RenderRootResult.NO_RENDER_ROOT){
            result = computeNodeRenderRoot(path, dirtyRegion, cullingIndex, tx, pvTx);
        }
        return result;
    }

    @Override protected boolean hasVisuals() {
        // This isn't entirely accurate -- the background might
        // not be empty but still not draw anything since a BackgroundFill
        // might be TRANSPARENT. The same is true of the border, which
        // might have BorderStrokes but perhaps none of them draw.
        return !border.isEmpty() || !background.isEmpty();
    }

    @Override protected boolean hasOverlappingContents() {
        // It may be that this can be optimized further, but I'm a bit
        // worried about it as I would have to check that the children do not
        // overlap with the strokes, and the strokes don't overlap each other,
        // and there are no backgrounds, etc. So there are a few fast paths
        // that could be used, but not sure it is really of any benefit in
        // the real cases.
        return true;
    }

    /**************************************************************************
     *                                                                        *
     * Region drawing.                                                        *
     *                                                                        *
     *************************************************************************/

    @Override protected void renderContent(Graphics g) {
        // Use Effect to render a 3D transformed Region that does not contain 3D
        // transformed children. This is done in order to render the Region's
        // content and children into an image in local coordinates using the identity
        // transform. The resulting image will then be correctly transformed in 3D by
        // the composite transform used to render this Region.
        // However, we avoid doing this for Regions whose children have a 3D
        // transform, because it will flatten the transforms of those children
        // and not look correct.
        if (!g.getTransformNoClone().is2D() &amp;&amp; this.isContentBounds2D()) {
            assert (getEffectFilter() == null);

            // Use Effect to render 3D transformed Region.
            // We will need to use a no op. Effect internally since user
            // didn't use Effect for this Region
            if (nopEffectFilter == null) {
                nopEffectFilter = new EffectFilter(nopEffect, this);
            }
            nopEffectFilter.render(g);

            return;
        }

        // If the shape is not null, then the shape will define what we need to draw for
        // this region. If the shape is null, then the &quot;shape&quot; of the region is just a
        // rectangle (or rounded rectangle, depending on the Background).
        if (shape != null) {
            renderAsShape(g);
        } else if (width &gt; 0 &amp;&amp; height &gt; 0) {
            renderAsRectangle(g);
        }

        // Paint the children
        super.renderContent(g);
    }

    /**************************************************************************
     *                                                                        *
     * Drawing a region background and borders when the Region has been       *
     * specified to have a shape. This is typically used to render some       *
     * portions of a UI Control, such as the tick on a CheckBox, the dot on a *
     * RadioButton, or the disclosure node arrow on a TreeView. In these      *
     * cases, the overall region size is typically very small and can         *
     * therefore easily be cached.                                            *
     *                                                                        *
     *************************************************************************/

    private void renderAsShape(Graphics g) {
        if (!background.isEmpty()) {
            // Note: resizeShape is not cheap. This should be refactored so that we only invoke
            // it if we absolutely have to. Specifically, if the background, shape, and size of the region
            // has not changed since the last time we rendered we could skip all this and render
            // directly out of a cache.
            final Insets outsets = background.getOutsets();
            final Shape outsetShape = resizeShape((float) -outsets.getTop(), (float) -outsets.getRight(),
                                                  (float) -outsets.getBottom(), (float) -outsets.getLeft());
            final RectBounds outsetShapeBounds = outsetShape.getBounds();
            final int textureWidth = Math.round(outsetShapeBounds.getWidth()),
                      textureHeight = Math.round(outsetShapeBounds.getHeight());

            final int border = 1;
            // See if we have a cached representation for this region background already. In UI controls,
            // the arrow in a scroll bar button or the dot in a radio button or the tick in a check box are
            // all examples of cases where we'd like to reuse a cached image for performance reasons rather
            // than re-drawing everything each time.

            RTTexture cached = null;
            Rectangle rect = null;
            // RT-25013: We need to make sure that we do not use a cached image in the case of a
            // scaled region, or things won't look right (they'll looked scaled instead of vector-resized).
            if (cacheMode != 0 &amp;&amp; g.getTransformNoClone().isTranslateOrIdentity()) {
                final RegionImageCache imageCache = getImageCache(g);
                if (imageCache.isImageCachable(textureWidth, textureHeight)) {
                    final Integer key = getCacheKey(textureWidth, textureHeight);
                    rect = TEMP_RECT;
                    rect.setBounds(0, 0, textureWidth + border, textureHeight + border);
                    boolean render = imageCache.getImageLocation(key, rect, background, shape, g);
                    if (!rect.isEmpty()) {
                        // An empty rect indicates a failure occurred in the imageCache
                        cached = imageCache.getBackingStore();
                    }
                    if (cached != null &amp;&amp; render) {
                        Graphics cachedGraphics = cached.createGraphics();

                        // Have to move the origin such that when rendering to x=0, we actually end up rendering
                        // at x=bounds.getMinX(). Otherwise anything rendered to the left of the origin would be lost
                        cachedGraphics.translate(rect.x - outsetShapeBounds.getMinX(),
                                                 rect.y - outsetShapeBounds.getMinY());
                        renderBackgroundShape(cachedGraphics);
                        if (PULSE_LOGGING_ENABLED) {
                            PulseLogger.incrementCounter(&quot;Rendering region shape image to cache&quot;);
                        }
                    }
                }
            }

            // &quot;cached&quot; might not be null if either there was a cached image, or we just created one.
            // In either case, we need to now render from the cached texture to the graphics
            if (cached != null) {
                // We just draw exactly what it was we have cached
                final float dstX1 = outsetShapeBounds.getMinX();
                final float dstY1 = outsetShapeBounds.getMinY();
                final float dstX2 = outsetShapeBounds.getMaxX();
                final float dstY2 = outsetShapeBounds.getMaxY();

                final float srcX1 = rect.x;
                final float srcY1 = rect.y;
                final float srcX2 = srcX1 + textureWidth;
                final float srcY2 = srcY1 + textureHeight;

                g.drawTexture(cached, dstX1, dstY1, dstX2, dstY2, srcX1, srcY1, srcX2, srcY2);
                if (PULSE_LOGGING_ENABLED) {
                    PulseLogger.incrementCounter(&quot;Cached region shape image used&quot;);
                }
            } else {
                // no cache, rendering backgrounds directly to graphics
                renderBackgroundShape(g);
            }
        }

        // Note that if you use borders, you're going to pay a premium in performance.
        // I don't think this is strictly necessary (since we won't stretch a cached
        // region shape anyway), so really this code should some how be combined
        // with the caching code that happened above for backgrounds.
        if (!border.isEmpty()) {
            // We only deal with stroke borders, we never deal with ImageBorders when
            // painting a shape on a Region. This is primarily because we don't know
            // how to handle a 9-patch image on a random shape. We'll have to implement
            // this at some point, but today is not that day.
            final List&lt;BorderStroke&gt; strokes = border.getStrokes();
            for (int i = 0, max = strokes.size(); i &lt; max; i++) {
                // Get the BorderStroke. When stroking a shape, we only honor the
                // topStroke, topStyle, widths.top, and insets.
                final BorderStroke stroke = strokes.get(i);
                // We're stroking a path, so there is no point trying to figure out the length.
                // Instead, we just pass -1, telling setBorderStyle to just do a simple stroke
                setBorderStyle(g, stroke, -1, false);
                final Insets insets = stroke.getInsets();
                g.draw(resizeShape((float) insets.getTop(), (float) insets.getRight(),
                                   (float) insets.getBottom(), (float) insets.getLeft()));
            }
        }
    }

    private void renderBackgroundShape(Graphics g) {
        if (PULSE_LOGGING_ENABLED) {
            PulseLogger.incrementCounter(&quot;NGRegion renderBackgroundShape slow path&quot;);
            PulseLogger.addMessage(&quot;Slow shape path for &quot; + getName());
        }

        // We first need to draw each background fill. We don't pay any attention
        // to the radii of the BackgroundFill, but we do honor the insets and
        // the fill paint itself.
        final List&lt;BackgroundFill&gt; fills = background.getFills();
        for (int i = 0, max = fills.size(); i &lt; max; i++) {
            final BackgroundFill fill = fills.get(i);
            // Get the paint for this BackgroundFill. It should not be possible
            // for it to ever be null
            final Paint paint = getPlatformPaint(fill.getFill());
            assert paint != null;
            g.setPaint(paint);
            // Adjust the box within which we will fit the shape based on the
            // insets. The resize shape method will resize the shape to fit
            final Insets insets = fill.getInsets();
            g.fill(resizeShape((float) insets.getTop(), (float) insets.getRight(),
                               (float) insets.getBottom(), (float) insets.getLeft()));
        }

        // We now need to draw each background image. Only the &quot;cover&quot; property
        // of BackgroundImage, and the &quot;image&quot; property itself, have any impact
        // on how the image is applied to a Shape.
        final List&lt;BackgroundImage&gt; images = background.getImages();
        for (int i = 0, max = images.size(); i &lt; max; i++) {
            final BackgroundImage image = images.get(i);
            final Image prismImage = (Image) Toolkit.getImageAccessor().getPlatformImage(image.getImage());
            if (prismImage == null) {
                // The prismImage might be null if the Image has not completed loading.
                // In that case, we simply must skip rendering of that layer this
                // time around.
                continue;
            }
            // We need to translate the shape based on 0 insets. This will for example
            // center and / or position the shape if necessary.
            final Shape translatedShape = resizeShape(0, 0, 0, 0);
            // Now ensure that the ImagePattern is based on the x/y position of the
            // shape and not on the 0,0 position of the region.
            final RectBounds bounds = translatedShape.getBounds();
            ImagePattern pattern = image.getSize().isCover() ?
                    new ImagePattern(prismImage, bounds.getMinX(), bounds.getMinY(),
                                     bounds.getWidth(), bounds.getHeight(), false, false) :
                    new ImagePattern(prismImage, bounds.getMinX(), bounds.getMinY(),
                                     prismImage.getWidth(), prismImage.getHeight(), false, false);
            g.setPaint(pattern);
            // Go ahead and finally fill!
            g.fill(translatedShape);
        }
    }

    /**************************************************************************
     *                                                                        *
     * Drawing a region background and borders when the Region has no defined *
     * shape, and is therefore treated as a rounded rectangle. This is the    *
     * most common code path for UI Controls.                                 *
     *                                                                        *
     *************************************************************************/

    private void renderAsRectangle(Graphics g) {
        if (!background.isEmpty()) {
            renderBackgroundRectangle(g);
        }

        if (!border.isEmpty()) {
            renderBorderRectangle(g);
        }
    }

    private void renderBackgroundRectangle(Graphics g) {
        // TODO a big chunk of this only makes sense to do if there actually are background fills,
        // and we should guard against that.

        // cacheWidth is the width of the region used within the cached image. For example,
        // perhaps normally the width of a region is 200px. But instead I will render the
        // region as though it is 20px wide into the cached image. 20px in this case is
        // the cache width. Although it may draw into more pixels than this (for example,
        // drawing the focus rectangle extends beyond the width of the region).
        // left + right background insets give us the left / right slice locations, plus 1 pixel for the center.
        // Round the whole thing up to be a whole number.
        if (backgroundInsets == null) updateBackgroundInsets();
        final double leftInset = backgroundInsets.getLeft() + 1;
        final double rightInset = backgroundInsets.getRight() + 1;
        final double topInset = backgroundInsets.getTop() + 1;
        final double bottomInset = backgroundInsets.getBottom() + 1;

        // If the insets are too large, then we want to use the width of the region instead of the
        // computed cacheWidth. RadioButton, for example, enters this case
        int cacheWidth = roundUp(width);
        if ((cacheMode &amp; CACHE_SLICE_H) != 0) {
            cacheWidth = Math.min(cacheWidth, (int) (leftInset + rightInset));
        }
        int cacheHeight = roundUp(height);
        if ((cacheMode &amp; CACHE_SLICE_V) != 0) {
            cacheHeight = Math.min(cacheHeight, (int) (topInset + bottomInset));
        }

        final Insets outsets = background.getOutsets();
        final int outsetsTop = roundUp(outsets.getTop());
        final int outsetsRight = roundUp(outsets.getRight());
        final int outsetsBottom = roundUp(outsets.getBottom());
        final int outsetsLeft = roundUp(outsets.getLeft());

        // The textureWidth / textureHeight is the width/height of the actual image. This needs to be rounded
        // up to the next whole pixel value.
        final int textureWidth = outsetsLeft + cacheWidth + outsetsRight;
        final int textureHeight = outsetsTop + cacheHeight + outsetsBottom;

        // See if we have a cached representation for this region background already.
        // RT-25013: We need to make sure that we do not use a cached image in the case of a
        // scaled region, or things won't look right (they'll looked scaled instead of vector-resized).
        // RT-25049: Need to only use the cache for pixel aligned regions or the result
        // will not look the same as though drawn by vector
        final boolean cache =
                background.getFills().size() &gt; 1 &amp;&amp; // Not worth the overhead otherwise
                cacheMode != 0 &amp;&amp;
                g.getTransformNoClone().isTranslateOrIdentity();
        final int border = 1;
        RTTexture cached = null;
        Rectangle rect = null;
        if (cache) {
            RegionImageCache imageCache = getImageCache(g);
            if (imageCache.isImageCachable(textureWidth, textureHeight)) {
                final Integer key = getCacheKey(textureWidth, textureHeight);
                rect = TEMP_RECT;
                rect.setBounds(0, 0, textureWidth + border, textureHeight + border);
                boolean render = imageCache.getImageLocation(key, rect, background, shape, g);
                if (!rect.isEmpty()) {
                    // An empty rect indicates a failure occurred in the imageCache
                    cached = imageCache.getBackingStore();
                }
                if (cached != null &amp;&amp; render) {
                    Graphics cacheGraphics = cached.createGraphics();

                    // Have to move the origin such that when rendering to x=0, we actually end up rendering
                    // at x=outsets.getLeft(). Otherwise anything rendered to the left of the origin would be lost
                    // Round up to the nearest pixel
                    cacheGraphics.translate(rect.x + outsetsLeft, rect.y + outsetsTop);

                    // Rendering backgrounds to the cache
                    renderBackgroundRectanglesDirectly(cacheGraphics, cacheWidth, cacheHeight);

                    if (PULSE_LOGGING_ENABLED) {
                        PulseLogger.incrementCounter(&quot;Rendering region background image to cache&quot;);
                    }
                }
            }
        }

        // &quot;cached&quot; might not be null if either there was a cached image, or we just created one.
        // In either case, we need to now render from the cached texture to the graphics
        if (cached != null) {
            renderBackgroundRectangleFromCache(
                    g, cached, rect, textureWidth, textureHeight,
                    topInset, rightInset, bottomInset, leftInset,
                    outsetsTop, outsetsRight, outsetsBottom, outsetsLeft);
        } else {
            // no cache, rendering backgrounds directly to graphics
            renderBackgroundRectanglesDirectly(g, width, height);
        }

        final List&lt;BackgroundImage&gt; images = background.getImages();
        for (int i = 0, max = images.size(); i &lt; max; i++) {
            final BackgroundImage image = images.get(i);
            Image prismImage = (Image) Toolkit.getImageAccessor().getPlatformImage(image.getImage());
            if (prismImage == null) {
                // The prismImage might be null if the Image has not completed loading.
                // In that case, we simply must skip rendering of that layer this
                // time around.
                continue;
            }

            final int imgUnscaledWidth = (int)image.getImage().getWidth();
            final int imgUnscaledHeight = (int)image.getImage().getHeight();
            final int imgWidth = prismImage.getWidth();
            final int imgHeight = prismImage.getHeight();
            // TODO need to write tests where we use a writable image and draw to it a lot. (RT-26978)
            if (imgWidth != 0 &amp;&amp; imgHeight != 0) {
                final BackgroundSize size = image.getSize();
                if (size.isCover()) {
                    // When &quot;cover&quot; is true, we can ignore most properties on the BackgroundSize and
                    // BackgroundRepeat and BackgroundPosition. Because the image will be stretched to
                    // fill the entire space, there is no need to know the repeat or position or
                    // size width / height.
                    final float scale = Math.max(width / imgWidth,height / imgHeight);
                    final Texture texture =
                        g.getResourceFactory().getCachedTexture(prismImage, Texture.WrapMode.CLAMP_TO_EDGE);
                    g.drawTexture(texture,
                            0, 0, width, height,
                            0, 0, width/scale, height/scale
                    );
                    texture.unlock();
                } else {
                    // Other than &quot;cover&quot;, all other modes need to pay attention to the repeat,
                    // size, and position in order to determine how to render. This next block
                    // of code is responsible for determining the width and height of the area
                    // that we are going to fill. The size might be percentage based, in which
                    // case we need to multiply by the width or height.
                    final double w = size.isWidthAsPercentage() ? size.getWidth() * width : size.getWidth();
                    final double h = size.isHeightAsPercentage() ? size.getHeight() * height : size.getHeight();

                    // Now figure out the width and height of each tile to be drawn. The actual image
                    // dimensions may be one thing, but we need to figure out what the size of the image
                    // in the destination is going to be.
                    final double tileWidth, tileHeight;
                    if (size.isContain()) {
                        // In the case of &quot;contain&quot;, we compute the destination size based on the largest
                        // possible scale such that the aspect ratio is maintained, yet one side of the
                        // region is completely filled.
                        final float scaleX = width / imgUnscaledWidth;
                        final float scaleY = height / imgUnscaledHeight;
                        final float scale = Math.min(scaleX, scaleY);
                        tileWidth = Math.ceil(scale * imgUnscaledWidth);
                        tileHeight = Math.ceil(scale * imgUnscaledHeight);
                    } else if (size.getWidth() &gt;= 0 &amp;&amp; size.getHeight() &gt;= 0) {
                        // The width and height have been expressly defined. Note that AUTO is -1,
                        // and all other negative values are disallowed, so by checking &gt;= 0, we
                        // are essentially saying &quot;if neither is AUTO&quot;
                        tileWidth = w;
                        tileHeight = h;
                    } else if (w &gt;= 0) {
                        // In this case, the width is specified, but the height is AUTO
                        tileWidth = w;
                        final double scale = tileWidth / imgUnscaledWidth;
                        tileHeight = imgUnscaledHeight * scale;
                    } else if (h &gt;= 0) {
                        // Here the height is specified and the width is AUTO
                        tileHeight = h;
                        final double scale = tileHeight / imgUnscaledHeight;
                        tileWidth = imgUnscaledWidth * scale;
                    } else {
                        // Both are auto.
                        tileWidth = imgUnscaledWidth;
                        tileHeight = imgUnscaledHeight;
                    }

                    // Now figure out where we are going to place the images within the region.
                    // For example, the developer can ask for 20px or 20%, and we need to first
                    // determine where to place the image. This starts by figuring out the pixel
                    // based value for the position.
                    final BackgroundPosition pos = image.getPosition();
                    final double tileX, tileY;

                    if (pos.getHorizontalSide() == Side.LEFT) {
                        final double position = pos.getHorizontalPosition();
                        if (pos.isHorizontalAsPercentage()) {
                            tileX = (position * width) - (position * tileWidth);
                        } else {
                            tileX = position;
                        }
                    } else {
                        if (pos.isHorizontalAsPercentage()) {
                            final double position = 1 - pos.getHorizontalPosition();
                            tileX = (position * width) - (position * tileWidth);
                        } else {
                            tileX = width - tileWidth- pos.getHorizontalPosition();
                        }
                    }

                    if (pos.getVerticalSide() == Side.TOP) {
                        final double position = pos.getVerticalPosition();
                        if (pos.isVerticalAsPercentage()) {
                            tileY = (position * height) - (position * tileHeight);
                        } else {
                            tileY = position;
                        }
                    } else {
                        if (pos.isVerticalAsPercentage()) {
                            final double position = 1 - pos.getVerticalPosition();
                            tileY = (position * height) - (position * tileHeight);
                        } else {
                            tileY = height - tileHeight - pos.getVerticalPosition();
                        }
                    }

                    // Now that we have acquired or computed all the data, we'll let paintTiles
                    // do the actual rendering operation.
                    paintTiles(g, prismImage, image.getRepeatX(), image.getRepeatY(),
                               pos.getHorizontalSide(), pos.getVerticalSide(),
                               0, 0, width, height, // the region area to fill with the image
                               0, 0, imgWidth, imgHeight, // The entire image is used
                               (float) tileX, (float) tileY, (float) tileWidth, (float) tileHeight);
                }
            }
        }
    }

    private void renderBackgroundRectangleFromCache(
            Graphics g, RTTexture cached, Rectangle rect, int textureWidth, int textureHeight,
            double topInset, double rightInset, double bottomInset, double leftInset,
            int outsetsTop, int outsetsRight, int outsetsBottom, int outsetsLeft) {

        // All cache operations are padded by (just shy of) half a pixel so
        // that as we are translated by sub-pixel amounts we continue to sample
        // all of the cached pixels out until they become transparent at (or
        // 1-bit worth of non-zero alhpa from) the center of the border pixel
        // around the cache.  If there is an integer translation, then our
        // padding should come up just shy of including new rows/columns of
        // pixels in the rendering and thus have no impact on pixel fill rates.
        final float pad = 0.5f - 1f/256f;
        final float dstWidth = outsetsLeft + width + outsetsRight;
        final float dstHeight = outsetsTop + height + outsetsBottom;
        final boolean sameWidth = textureWidth == dstWidth;
        final boolean sameHeight = textureHeight == dstHeight;
        final float dstX1 = -outsetsLeft - pad;
        final float dstY1 = -outsetsTop - pad;
        final float dstX2 = width + outsetsRight + pad;
        final float dstY2 = height + outsetsBottom + pad;
        final float srcX1 = rect.x - pad;
        final float srcY1 = rect.y - pad;
        final float srcX2 = rect.x + textureWidth + pad;
        final float srcY2 = rect.y + textureHeight + pad;

        // If total destination width is &lt; the source width, then we need to start
        // shrinking the left and right sides to accommodate. Likewise in the other dimension.
        double adjustedLeftInset = leftInset;
        double adjustedRightInset = rightInset;
        double adjustedTopInset = topInset;
        double adjustedBottomInset = bottomInset;
        if (leftInset + rightInset &gt; width) {
            double fraction = width / (leftInset + rightInset);
            adjustedLeftInset *= fraction;
            adjustedRightInset *= fraction;
        }
        if (topInset + bottomInset &gt; height) {
            double fraction = height / (topInset + bottomInset);
            adjustedTopInset *= fraction;
            adjustedBottomInset *= fraction;
        }

        if (sameWidth &amp;&amp; sameHeight) {
            g.drawTexture(cached, dstX1, dstY1, dstX2, dstY2, srcX1, srcY1, srcX2, srcY2);
        } else if (sameHeight) {
            // We do 3-patch rendering fixed height
            final float left  = pad + (float) (adjustedLeftInset  + outsetsLeft);
            final float right = pad + (float) (adjustedRightInset + outsetsRight);

            final float dstLeftX = dstX1 + left;
            final float dstRightX = dstX2 - right;
            final float srcLeftX = srcX1 + left;
            final float srcRightX = srcX2 - right;

            g.drawTexture3SliceH(cached,
                                 dstX1, dstY1, dstX2, dstY2,
                                 srcX1, srcY1, srcX2, srcY2,
                                 dstLeftX, dstRightX, srcLeftX, srcRightX);
        } else if (sameWidth) {
            // We do 3-patch rendering fixed width
            final float top    = pad + (float) (adjustedTopInset    + outsetsTop);
            final float bottom = pad + (float) (adjustedBottomInset + outsetsBottom);

            final float dstTopY = dstY1 + top;
            final float dstBottomY = dstY2 - bottom;
            final float srcTopY = srcY1 + top;
            final float srcBottomY = srcY2 - bottom;

            g.drawTexture3SliceV(cached,
                                 dstX1, dstY1, dstX2, dstY2,
                                 srcX1, srcY1, srcX2, srcY2,
                                 dstTopY, dstBottomY, srcTopY, srcBottomY);
        } else {
            // We do 9-patch rendering
            final float left   = pad + (float) (adjustedLeftInset   + outsetsLeft);
            final float top    = pad + (float) (adjustedTopInset    + outsetsTop);
            final float right  = pad + (float) (adjustedRightInset  + outsetsRight);
            final float bottom = pad + (float) (adjustedBottomInset + outsetsBottom);

            final float dstLeftX = dstX1 + left;
            final float dstRightX = dstX2 - right;
            final float srcLeftX = srcX1 + left;
            final float srcRightX = srcX2 - right;
            final float dstTopY = dstY1 + top;
            final float dstBottomY = dstY2 - bottom;
            final float srcTopY = srcY1 + top;
            final float srcBottomY = srcY2 - bottom;

            g.drawTexture9Slice(cached,
                                dstX1, dstY1, dstX2, dstY2,
                                srcX1, srcY1, srcX2, srcY2,
                                dstLeftX, dstTopY, dstRightX, dstBottomY,
                                srcLeftX, srcTopY, srcRightX, srcBottomY);
        }

        if (PULSE_LOGGING_ENABLED) {
            PulseLogger.incrementCounter(&quot;Cached region background image used&quot;);
        }
    }

    private void renderBackgroundRectanglesDirectly(Graphics g, float width, float height) {
        final List&lt;BackgroundFill&gt; fills = background.getFills();
        for (int i = 0, max = fills.size(); i &lt; max; i++) {
            final BackgroundFill fill = fills.get(i);
            final Insets insets = fill.getInsets();
            final float t = (float) insets.getTop(),
                    l = (float) insets.getLeft(),
                    b = (float) insets.getBottom(),
                    r = (float) insets.getRight();
            // w and h is the width and height of the area to be filled (width and height less insets)
            float w = width - l - r;
            float h = height - t - b;
            // Only setup and paint for those areas which have positive width and height. This means, if
            // the insets are such that the right edge is left of the left edge, then we have a negative
            // width and will not paint it. TODO we need to document this fact (RT-26924)
            if (w &gt; 0 &amp;&amp; h &gt; 0) {
                // Could optimize this such that if paint is transparent then we go no further.
                final Paint paint = getPlatformPaint(fill.getFill());
                g.setPaint(paint);
                final CornerRadii radii = getNormalizedFillRadii(i);
                // This is a workaround for RT-28435 so we use path rasterizer for small radius's We are
                // keeping old rendering. We do not apply workaround when using Caspian or Embedded
                if (radii.isUniform() &amp;&amp;
                        !(!PlatformImpl.isCaspian() &amp;&amp; !(PlatformUtil.isEmbedded() || PlatformUtil.isIOS()) &amp;&amp; radii.getTopLeftHorizontalRadius() &gt; 0 &amp;&amp; radii.getTopLeftHorizontalRadius() &lt;= 4)) {
                    // If the radii is uniform then we know every corner matches, so we can do some
                    // faster rendering paths.
                    float tlhr = (float) radii.getTopLeftHorizontalRadius();
                    float tlvr = (float) radii.getTopLeftVerticalRadius();
                    if (tlhr == 0 &amp;&amp; tlvr == 0) {
                        // The edges are square, so we can do a simple fill rect
                        g.fillRect(l, t, w, h);
                    } else {
                        // The edges are rounded, so we need to compute the arc width and arc height
                        // and fill a round rect
                        float arcWidth = tlhr + tlhr;
                        float arcHeight = tlvr + tlvr;
                        // If the arc width and arc height are so large as to exceed the width / height of
                        // the region, then we clamp to the width / height of the region (which will give
                        // the look of a circle on that corner)
                        if (arcWidth &gt; w) arcWidth = w;
                        if (arcHeight &gt; h) arcHeight = h;
                        g.fillRoundRect(l, t, w, h, arcWidth, arcHeight);
                    }
                } else {
                    if (PULSE_LOGGING_ENABLED) {
                        PulseLogger.incrementCounter(&quot;NGRegion renderBackgrounds slow path&quot;);
                        PulseLogger.addMessage(&quot;Slow background path for &quot; + getName());
                    }
                    // The edges are not uniform, so we have to render each edge independently
                    // TODO document the issue number which will give us a fast path for rendering
                    // non-uniform corners, and that we want to implement that instead of createPath2
                    // below in such cases. (RT-26979)
                    g.fill(createPath(width, height, t, l, b, r, radii));
                }
            }
        }
    }

    private void renderBorderRectangle(Graphics g) {
        final List&lt;BorderImage&gt; images = border.getImages();
        final List&lt;BorderStroke&gt; strokes = images.isEmpty() ? border.getStrokes() : Collections.emptyList();
        for (int i = 0, max = strokes.size(); i &lt; max; i++) {
            final BorderStroke stroke = strokes.get(i);
            final BorderWidths widths = stroke.getWidths();
            final CornerRadii radii = getNormalizedStrokeRadii(i);
            final Insets insets = stroke.getInsets();

            final javafx.scene.paint.Paint topStroke = stroke.getTopStroke();
            final javafx.scene.paint.Paint rightStroke = stroke.getRightStroke();
            final javafx.scene.paint.Paint bottomStroke = stroke.getBottomStroke();
            final javafx.scene.paint.Paint leftStroke = stroke.getLeftStroke();

            final float topInset = (float) insets.getTop();
            final float rightInset = (float) insets.getRight();
            final float bottomInset = (float) insets.getBottom();
            final float leftInset = (float) insets.getLeft();

            final float topWidth = (float) (widths.isTopAsPercentage() ? height * widths.getTop() : widths.getTop());
            final float rightWidth = (float) (widths.isRightAsPercentage() ? width * widths.getRight() : widths.getRight());
            final float bottomWidth = (float) (widths.isBottomAsPercentage() ? height * widths.getBottom() : widths.getBottom());
            final float leftWidth = (float) (widths.isLeftAsPercentage() ? width * widths.getLeft() : widths.getLeft());

            final BorderStrokeStyle topStyle = stroke.getTopStyle();
            final BorderStrokeStyle rightStyle = stroke.getRightStyle();
            final BorderStrokeStyle bottomStyle = stroke.getBottomStyle();
            final BorderStrokeStyle leftStyle = stroke.getLeftStyle();

            final StrokeType topType = topStyle.getType();
            final StrokeType rightType = rightStyle.getType();
            final StrokeType bottomType = bottomStyle.getType();
            final StrokeType leftType = leftStyle.getType();

            // The Prism Graphics logic can stroke lines only CENTERED and doesn't know what to do with
            // INSIDE or OUTSIDE strokes for lines. The only way to deal with those is
            // to compensate for them here. So we will adjust the bounds that we are going
            // to stroke to take into account the insets (obviously), and also where we
            // want the stroked line to appear (inside, or outside, or centered).
            final float t = topInset +
                    (topType == StrokeType.OUTSIDE ? -topWidth / 2 :
                     topType == StrokeType.INSIDE ? topWidth / 2 : 0);
            final float l = leftInset +
                    (leftType == StrokeType.OUTSIDE ? -leftWidth / 2 :
                     leftType == StrokeType.INSIDE ? leftWidth / 2 : 0);
            final float b = bottomInset +
                    (bottomType == StrokeType.OUTSIDE ? -bottomWidth / 2 :
                     bottomType == StrokeType.INSIDE ? bottomWidth / 2 : 0);
            final float r = rightInset +
                    (rightType == StrokeType.OUTSIDE ? -rightWidth / 2 :
                     rightType == StrokeType.INSIDE ? rightWidth / 2 : 0);

            // If the radii are uniform, then reading any one value is sufficient to
            // know what the radius is for all values
            final float radius = (float) radii.getTopLeftHorizontalRadius();
            if (stroke.isStrokeUniform()) {
                // If the stroke is uniform, then that means that the style, width, and stroke of
                // all four sides is the same.
                if (!(topStroke instanceof Color &amp;&amp; ((Color)topStroke).getOpacity() == 0f) &amp;&amp; topStyle != BorderStrokeStyle.NONE) {
                    float w = width - l - r;
                    float h = height - t - b;
                    // The length of each side of the path we're going to stroke
                    final double di = 2 * radii.getTopLeftHorizontalRadius();
                    final double circle = di*Math.PI;
                    final double totalLineLength =
                            circle +
                            2 * (w - di) +
                            2 * (h - di);

                    if (w &gt;= 0 &amp;&amp; h &gt;= 0) {
                        setBorderStyle(g, stroke, totalLineLength, true);
                        if (radii.isUniform() &amp;&amp; radius == 0) {
                            // We're just drawing a squared stroke on all four sides of the same style
                            // and width and color, so a simple drawRect call is all that is needed.
                            g.drawRect(l, t, w, h);
                        } else if (radii.isUniform()) {
                            // The radii are uniform, but are not squared up, so we have to
                            // draw a rounded rectangle.
                            float ar = radius + radius;
                            if (ar &gt; w) ar = w;
                            if (ar &gt; h) ar = h;
                            g.drawRoundRect(l, t, w, h, ar, ar);
                        } else {
                            // We do not have uniform radii, so we need to create a path that represents
                            // the stroke and then draw that.
                            g.draw(createPath(width, height, t, l, b, r, radii));
                        }
                    }
                }
            } else if (radii.isUniform() &amp;&amp; radius == 0) {

                // We have different styles, or widths, or strokes on one or more sides, and
                // therefore we have to draw each side independently. However, the corner radii
                // are all 0, so we don't have to go to the trouble of constructing some complicated
                // path to represent the border, we just draw each line independently.
                // Note that in each of these checks, if the stroke is identity equal to the TRANSPARENT
                // Color or the style is identity equal to BorderStrokeStyle.NONE, then we skip that
                // side. It is possible however to have a Color as the stroke which is effectively
                // TRANSPARENT and a style that is effectively NONE, but we are not checking for those
                // cases and will in those cases be doing more work than necessary.
                // TODO make sure CSS uses TRANSPARENT and NONE when possible (RT-26943)
                if (!(topStroke instanceof Color &amp;&amp; ((Color)topStroke).getOpacity() == 0f) &amp;&amp; topStyle != BorderStrokeStyle.NONE) {
                    g.setPaint(getPlatformPaint(topStroke));
                    if (BorderStrokeStyle.SOLID == topStyle) {
                        g.fillRect(leftInset, topInset, width - leftInset - rightInset, topWidth);
                    } else {
                        g.setStroke(createStroke(topStyle, topWidth, width, true));
                        g.drawLine(l, t, width - r, t);
                    }
                }

                if (!(rightStroke instanceof Color &amp;&amp; ((Color)rightStroke).getOpacity() == 0f) &amp;&amp; rightStyle != BorderStrokeStyle.NONE) {
                    g.setPaint(getPlatformPaint(rightStroke));
                    if (BorderStrokeStyle.SOLID == rightStyle) {
                        g.fillRect(width - rightInset - rightWidth, topInset,
                                   rightWidth, height - topInset - bottomInset);
                    } else {
                        g.setStroke(createStroke(rightStyle, rightWidth, height, true));
                        g.drawLine(width - r, t, width - r, height - b);
                    }
                }

                if (!(bottomStroke instanceof Color &amp;&amp; ((Color)bottomStroke).getOpacity() == 0f) &amp;&amp; bottomStyle != BorderStrokeStyle.NONE) {
                    g.setPaint(getPlatformPaint(bottomStroke));
                    if (BorderStrokeStyle.SOLID == bottomStyle) {
                        g.fillRect(leftInset, height - bottomInset - bottomWidth,
                                width - leftInset - rightInset, bottomWidth);
                    } else {
                        g.setStroke(createStroke(bottomStyle, bottomWidth, width, true));
                        g.drawLine(l, height - b, width - r, height - b);
                    }
                }

                if (!(leftStroke instanceof Color &amp;&amp; ((Color)leftStroke).getOpacity() == 0f) &amp;&amp; leftStyle != BorderStrokeStyle.NONE) {
                    g.setPaint(getPlatformPaint(leftStroke));
                    if (BorderStrokeStyle.SOLID == leftStyle) {
                        g.fillRect(leftInset, topInset, leftWidth, height - topInset - bottomInset);
                    } else {
                        g.setStroke(createStroke(leftStyle, leftWidth, height, true));
                        g.drawLine(l, t, l, height - b);
                    }
                }
            } else {
                // In this case, we have different styles and/or strokes and/or widths on one or
                // more sides, and either the radii are not uniform, or they are uniform but greater
                // than 0. In this case we have to take a much slower rendering path by turning this
                // stroke into a path (or in the current implementation, an array of paths).
                Shape[] paths = createPaths(t, l, b, r, radii);
                if (topStyle != BorderStrokeStyle.NONE) {
                    double rsum = radii.getTopLeftHorizontalRadius() + radii.getTopRightHorizontalRadius();
                    double topLineLength = width + rsum * (Math.PI / 4 - 1);
                    g.setStroke(createStroke(topStyle, topWidth, topLineLength, true));
                    g.setPaint(getPlatformPaint(topStroke));
                    g.draw(paths[0]);
                }
                if (rightStyle != BorderStrokeStyle.NONE) {
                    double rsum = radii.getTopRightVerticalRadius() + radii.getBottomRightVerticalRadius();
                    double rightLineLength = height + rsum * (Math.PI / 4 - 1);
                    g.setStroke(createStroke(rightStyle, rightWidth, rightLineLength, true));
                    g.setPaint(getPlatformPaint(rightStroke));
                    g.draw(paths[1]);
                }
                if (bottomStyle != BorderStrokeStyle.NONE) {
                    double rsum = radii.getBottomLeftHorizontalRadius() + radii.getBottomRightHorizontalRadius();
                    double bottomLineLength = width + rsum * (Math.PI / 4 - 1);
                    g.setStroke(createStroke(bottomStyle, bottomWidth, bottomLineLength, true));
                    g.setPaint(getPlatformPaint(bottomStroke));
                    g.draw(paths[2]);
                }
                if (leftStyle != BorderStrokeStyle.NONE) {
                    double rsum = radii.getTopLeftVerticalRadius() + radii.getBottomLeftVerticalRadius();
                    double leftLineLength = height + rsum * (Math.PI / 4 - 1);
                    g.setStroke(createStroke(leftStyle, leftWidth, leftLineLength, true));
                    g.setPaint(getPlatformPaint(leftStroke));
                    g.draw(paths[3]);
                }
            }
        }

        for (int i = 0, max = images.size(); i &lt; max; i++) {
            final BorderImage ib = images.get(i);
            final Image prismImage = (Image) Toolkit.getImageAccessor().getPlatformImage(ib.getImage());
            if (prismImage == null) {
                // The prismImage might be null if the Image has not completed loading.
                // In that case, we simply must skip rendering of that layer this
                // time around.
                continue;
            }
            final int imgWidth = prismImage.getWidth();
            final int imgHeight = prismImage.getHeight();
            final float imgScale = prismImage.getPixelScale();
            final BorderWidths widths = ib.getWidths();
            final Insets insets = ib.getInsets();
            final BorderWidths slices = ib.getSlices();

            // we will get gaps if we don't round to pixel boundaries
            final int topInset = (int) Math.round(insets.getTop());
            final int rightInset = (int) Math.round(insets.getRight());
            final int bottomInset = (int) Math.round(insets.getBottom());
            final int leftInset = (int) Math.round(insets.getLeft());

            final int topWidth = widthSize(widths.isTopAsPercentage(), widths.getTop(), height);
            final int rightWidth = widthSize(widths.isRightAsPercentage(), widths.getRight(), width);
            final int bottomWidth = widthSize(widths.isBottomAsPercentage(), widths.getBottom(), height);
            final int leftWidth = widthSize(widths.isLeftAsPercentage(), widths.getLeft(), width);

            final int topSlice = sliceSize(slices.isTopAsPercentage(), slices.getTop(), imgHeight, imgScale);
            final int rightSlice = sliceSize(slices.isRightAsPercentage(), slices.getRight(), imgWidth, imgScale);
            final int bottomSlice = sliceSize(slices.isBottomAsPercentage(), slices.getBottom(), imgHeight, imgScale);
            final int leftSlice = sliceSize(slices.isLeftAsPercentage(), slices.getLeft(), imgWidth, imgScale);

            // handle case where region is too small to fit in borders
            if ((leftInset + leftWidth + rightInset + rightWidth) &gt; width
                    || (topInset + topWidth + bottomInset + bottomWidth) &gt; height) {
                continue;
            }

            // calculate some things we can share
            final int centerMinX = leftInset + leftWidth;
            final int centerMinY = topInset + topWidth;
            final int centerW = Math.round(width) - rightInset - rightWidth - centerMinX;
            final int centerH = Math.round(height) - bottomInset - bottomWidth - centerMinY;
            final int centerMaxX = centerW + centerMinX;
            final int centerMaxY = centerH + centerMinY;
            final int centerSliceWidth = imgWidth - leftSlice - rightSlice;
            final int centerSliceHeight = imgHeight - topSlice - bottomSlice;
            // paint top left corner
            paintTiles(g, prismImage, BorderRepeat.STRETCH, BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
                       leftInset, topInset, leftWidth, topWidth, // target bounds
                       0, 0, leftSlice, topSlice, // src image bounds
                       0, 0, leftWidth, topWidth); // tile bounds
            // paint top slice
            float tileWidth = (ib.getRepeatX() == BorderRepeat.STRETCH) ?
                    centerW : (topSlice &gt; 0 ? (centerSliceWidth * topWidth) / topSlice : 0);
            float tileHeight = topWidth;
            paintTiles(
                    g, prismImage, ib.getRepeatX(), BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
                    centerMinX, topInset, centerW, topWidth,
                    leftSlice, 0, centerSliceWidth, topSlice,
                    (centerW - tileWidth) / 2, 0, tileWidth, tileHeight);
            // paint top right corner
            paintTiles(g, prismImage, BorderRepeat.STRETCH, BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
                       centerMaxX, topInset, rightWidth, topWidth,
                       (imgWidth - rightSlice), 0, rightSlice, topSlice,
                       0, 0, rightWidth, topWidth);
            // paint left slice
            tileWidth = leftWidth;
            tileHeight = (ib.getRepeatY() == BorderRepeat.STRETCH) ?
                    centerH : (leftSlice &gt; 0 ? (leftWidth * centerSliceHeight) / leftSlice : 0);
            paintTiles(g, prismImage, BorderRepeat.STRETCH, ib.getRepeatY(), Side.LEFT, Side.TOP,
                       leftInset, centerMinY, leftWidth, centerH,
                       0, topSlice, leftSlice, centerSliceHeight,
                       0, (centerH - tileHeight) / 2, tileWidth, tileHeight);
            // paint right slice
            tileWidth = rightWidth;
            tileHeight = (ib.getRepeatY() == BorderRepeat.STRETCH) ?
                    centerH : (rightSlice &gt; 0 ? (rightWidth * centerSliceHeight) / rightSlice : 0);
            paintTiles(g, prismImage, BorderRepeat.STRETCH, ib.getRepeatY(), Side.LEFT, Side.TOP,
                       centerMaxX, centerMinY, rightWidth, centerH,
                       imgWidth - rightSlice, topSlice, rightSlice, centerSliceHeight,
                       0, (centerH - tileHeight) / 2, tileWidth, tileHeight);
            // paint bottom left corner
            paintTiles(g, prismImage, BorderRepeat.STRETCH, BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
                       leftInset, centerMaxY, leftWidth, bottomWidth,
                       0, imgHeight - bottomSlice, leftSlice, bottomSlice,
                       0, 0, leftWidth, bottomWidth);
            // paint bottom slice
            tileWidth = (ib.getRepeatX() == BorderRepeat.STRETCH) ?
                    centerW : (bottomSlice &gt; 0 ? (centerSliceWidth * bottomWidth) / bottomSlice : 0);
            tileHeight = bottomWidth;
            paintTiles(g, prismImage, ib.getRepeatX(), BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
                       centerMinX, centerMaxY, centerW, bottomWidth,
                       leftSlice, imgHeight - bottomSlice, centerSliceWidth, bottomSlice,
                       (centerW - tileWidth) / 2, 0, tileWidth, tileHeight);
            // paint bottom right corner
            paintTiles(g, prismImage, BorderRepeat.STRETCH, BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
                       centerMaxX, centerMaxY, rightWidth, bottomWidth,
                       imgWidth - rightSlice, imgHeight - bottomSlice, rightSlice, bottomSlice,
                       0, 0, rightWidth, bottomWidth);
            // paint the center slice
            if (ib.isFilled()) {
                // handle no repeat as stretch
                final float imgW = (ib.getRepeatX() == BorderRepeat.STRETCH) ? centerW : centerSliceWidth;
                final float imgH = (ib.getRepeatY() == BorderRepeat.STRETCH) ? centerH : centerSliceHeight;
                paintTiles(g, prismImage, ib.getRepeatX(), ib.getRepeatY(), Side.LEFT, Side.TOP,
                           centerMinX, centerMinY, centerW, centerH,
                           leftSlice, topSlice, centerSliceWidth, centerSliceHeight,
                           0, 0, imgW, imgH);
            }
        }
    }

    /**
     * Visits each of the background fills and takes their radii into account to determine the insets.
     * The backgroundInsets variable is cleared whenever the fills change, or whenever the size of the
     * region has changed (because if the size of the region changed and a radius is percentage based
     * then we need to recompute the insets).
     */
    private void updateBackgroundInsets() {
        float top=0, right=0, bottom=0, left=0;
        final List&lt;BackgroundFill&gt; fills = background.getFills();
        for (int i=0, max=fills.size(); i&lt;max; i++) {
            // We need to now inspect the paint to determine whether we can use a cache for this background.
            // If a shape is being used, we don't care about gradients (we cache 'em both), but for a rectangle
            // fill we omit these (so we can do 3-patch scaling). An ImagePattern is deadly to either
            // (well, only deadly to a shape if it turns out to be a writable image).
            final BackgroundFill fill = fills.get(i);
            final Insets insets = fill.getInsets();
            final CornerRadii radii = getNormalizedFillRadii(i);
            top = (float) Math.max(top, insets.getTop() + Math.max(radii.getTopLeftVerticalRadius(), radii.getTopRightVerticalRadius()));
            right = (float) Math.max(right, insets.getRight() + Math.max(radii.getTopRightHorizontalRadius(), radii.getBottomRightHorizontalRadius()));
<A NAME="14"></A>            bottom = (float) Math.max(bottom, insets.getBottom() + Math.max(radii.getBottomRightVerticalRadius(), radii.getBottomLeftVerticalRadius()));
            left = (float) Math.max(left, insets.getLeft() + Math.max(radii.getTopLeftHorizontalRadius(), radii.getBottomLeftHorizontalRadius()));
        }
        <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#14',2,'match52-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>backgroundInsets = new Insets(roundUp(top), roundUp(right), roundUp(bottom), roundUp(left));
    }

    private int widthSize(boolean isPercent, double sliceSize</B></FONT>, float objSize) {
        //Not strictly correct. See RT-34051
        return (int) Math.round(isPercent ? sliceSize * objSize : sliceSize);
    }

    private int sliceSize(boolean isPercent, double sliceSize, float objSize, float scale) {
        if (isPercent) sliceSize *= objSize;
        if (sliceSize &gt; objSize) sliceSize = objSize;
        return (int) Math.round(sliceSize * scale);
    }

    private int roundUp(double d) {
        return (d - (int)d) == 0 ? (int) d : (int) (d + 1);
    }


    /**
     * Creates a Prism BasicStroke based on the stroke style, width, and line length.
     *
     * @param sb             The BorderStrokeStyle
     * @param strokeWidth    The width of the stroke we're going to draw
     * @param lineLength     The total linear length of this stroke. This is needed for
     *                       handling &quot;dashed&quot; and &quot;dotted&quot; cases, otherwise, it is ignored.
     * @param forceCentered  When this is set to true, the stroke is always centered.
     *                       The &quot;outer/inner&quot; stroking has to be done by moving the line
     * @return A prism BasicStroke
     */
    private BasicStroke createStroke(BorderStrokeStyle sb,
                                     double strokeWidth,
                                     double lineLength,
                                     boolean forceCentered) {
        int cap;
        if (sb.getLineCap() == StrokeLineCap.BUTT) {
            cap = BasicStroke.CAP_BUTT;
        } else if (sb.getLineCap() == StrokeLineCap.SQUARE) {
            cap = BasicStroke.CAP_SQUARE;
        } else {
            cap = BasicStroke.CAP_ROUND;
        }

        int join;
        if (sb.getLineJoin() == StrokeLineJoin.BEVEL) {
            join = BasicStroke.JOIN_BEVEL;
        } else if (sb.getLineJoin() == StrokeLineJoin.MITER) {
            join = BasicStroke.JOIN_MITER;
        } else {
            join = BasicStroke.JOIN_ROUND;
        }

        int type;
        if (forceCentered) {
            type = BasicStroke.TYPE_CENTERED;
        } else if (scaleShape) {
            // Note: this is just a workaround that allows us to avoid shape bounds computation with the given stroke.
            // By using inner stroke, we know the shape bounds and the shape will be scaled correctly, but the size of
            // the stroke after the scale will be slightly different, but this should be visible only with big stroke widths
            // See https://javafx-jira.kenai.com/browse/RT-38384
            type = BasicStroke.TYPE_INNER;
        } else {
            switch (sb.getType()) {
                case INSIDE:
                    type = BasicStroke.TYPE_INNER;
                    break;
                case OUTSIDE:
                    type = BasicStroke.TYPE_OUTER;
                    break;
                case CENTERED:
                default:
                    type = BasicStroke.TYPE_CENTERED;
                    break;
            }
        }

        BasicStroke bs;
        if (sb == BorderStrokeStyle.NONE) {
            throw new AssertionError(&quot;Should never have been asked to draw a border with NONE&quot;);
        } else if (strokeWidth &lt;= 0) {
            // The stroke essentially disappears in this case, but some of the
            // dashing calculations below can produce degenerate dash arrays
            // that are problematic when the strokeWidth is 0.

            // Ideally the calling code would not even be trying to perform a
            // stroke under these conditions, but there are so many unchecked
            // calls to createStroke() in the code that pass the result directly
            // to a Graphics and then use it, that we need to return something
            // valid, even if it represents a NOP.

            bs = new BasicStroke((float) strokeWidth, cap, join,
                    (float) sb.getMiterLimit());
        } else if (sb.getDashArray().size() &gt; 0) {
            List&lt;Double&gt; dashArray = sb.getDashArray();
            double[] array;
            float dashOffset;
            if (dashArray == BorderStrokeStyle.DOTTED.getDashArray()) {
                // NOTE: IF line length is &gt; 0, then we are going to do some math to try to make the resulting
                // dots look pleasing. It is set to -1 if we are stroking a random path (vs. a rounded rect), in
                // which case we are going to just scale the dotting pattern based on the stroke width, but we won't
                // try to adjust the phase to make it look better.
                if (lineLength &gt; 0) {
                    // For DOTTED we want the dash array to be 0, val, where the &quot;val&quot; is as close to strokewidth*2 as
                    // possible, but we want the spacing to be such that we get an even spacing between all dots around
                    // the edge.
                    double remainder = lineLength % (strokeWidth * 2);
                    double numSpaces = lineLength / (strokeWidth * 2);
                    double spaceWidth = (strokeWidth * 2) + (remainder / numSpaces);
                    array = new double[] {0, spaceWidth};
                    dashOffset = 0;
                } else {
                    array = new double[] {0, strokeWidth * 2};
                    dashOffset = 0;
                }
            } else if (dashArray == BorderStrokeStyle.DASHED.getDashArray()) {
                // NOTE: IF line length is &gt; 0, then we are going to do some math to try to make the resulting
                // dash look pleasing. It is set to -1 if we are stroking a random path (vs. a rounded rect), in
                // which case we are going to just scale the dashing pattern based on the stroke width, but we won't
                // try to adjust the phase to make it look better.
                if (lineLength &gt; 0) {
                    // For DASHED we want the dash array to be 2*strokewidth, val where &quot;val&quot; is as close to
                    // 1.4*strokewidth as possible, but we want the spacing to be such that we get an even spacing between
                    // all dashes around the edge. Maybe we can start with the dash phase at half the dash length.
                    final double dashLength = strokeWidth * 2;
                    double gapLength = strokeWidth * 1.4;
                    final double segmentLength = dashLength + gapLength;
                    final double divided = lineLength / segmentLength;
                    final double numSegments = (int) divided;
                    if (numSegments &gt; 0) {
                        final double dashCumulative = numSegments * dashLength;
                        gapLength = (lineLength - dashCumulative) / numSegments;
                    }
                    array = new double[] {dashLength, gapLength};
                    dashOffset = (float) (dashLength*.6);
                } else {
                    array = new double[] {2 * strokeWidth, 1.4 * strokeWidth};
                    dashOffset = 0;
                }
            } else {
                // If we are not DASHED or DOTTED or we're stroking a path and not a basic rounded rectangle
                // so we just take what we've been given.
                array = new double[dashArray.size()];
                for (int i=0; i&lt;array.length; i++) {
                    array[i] = dashArray.get(i);
                }
                dashOffset = (float) sb.getDashOffset();
            }

            bs = new BasicStroke(type, (float) strokeWidth, cap, join,
                    (float) sb.getMiterLimit(),
                    array, dashOffset);
        } else {
            bs = new BasicStroke(type, (float) strokeWidth, cap, join,
                    (float) sb.getMiterLimit());
        }

        return bs;
    }

    private void setBorderStyle(Graphics g, BorderStroke sb, double length, boolean forceCentered) {
        // Any one of, or all of, the sides could be 'none'.
        // Take the first side that isn't.
        final BorderWidths widths = sb.getWidths();
        BorderStrokeStyle bs = sb.getTopStyle();
        double sbWidth = widths.isTopAsPercentage() ? height * widths.getTop() : widths.getTop();
        Paint sbFill = getPlatformPaint(sb.getTopStroke());
        if (bs == null) {
            bs = sb.getLeftStyle();
            sbWidth = widths.isLeftAsPercentage() ? width * widths.getLeft() : widths.getLeft();
            sbFill = getPlatformPaint(sb.getLeftStroke());
            if (bs == null) {
                bs = sb.getBottomStyle();
                sbWidth = widths.isBottomAsPercentage() ? height * widths.getBottom() : widths.getBottom();
                sbFill = getPlatformPaint(sb.getBottomStroke());
                if (bs == null) {
                    bs = sb.getRightStyle();
                    sbWidth = widths.isRightAsPercentage() ? width * widths.getRight() : widths.getRight();
                    sbFill = getPlatformPaint(sb.getRightStroke());
                }
            }
        }
        if (bs == null || bs == BorderStrokeStyle.NONE) {
            return;
        }

        g.setStroke(createStroke(bs, sbWidth, length, forceCentered));
        g.setPaint(sbFill);
    }

    /**
     * Inserts geometry into the specified Path2D object for the specified
     * corner of a general rounded rectangle.
     *
     * The corner drawn is specified by the quadrant parameter, whose least
     * significant 2 bits specify the following corners and the associated
     * start, corner, and end points (which are always drawn clockwise):
     *
     * 0 - Top Left:      X + 0 , Y + VR,      X, Y,      X + HR, Y + 0
     * 1 - Top Right:     X - HR, Y + 0 ,      X, Y,      X + 0 , Y + VR
     * 2 - Bottom Right:  X + 0 , Y - VR,      X, Y,      X - HR, Y + 0
     * 3 - Bottom Left:   X + HR, Y + 0 ,      X, Y,      X + 0 , Y - VR
     *
     * The associated horizontal and vertical radii are fetched from the
     * indicated CornerRadii object which is assumed to be absolute (not
     * percentage based) and already scaled so that no pair of radii are
     * larger than the indicated width/height of the rounded rectangle being
     * expressed.
     *
     * The tstart and tend parameters specify what portion of the rounded
     * corner should be drawn with 0f =&gt; 1f being the entire rounded corner.
     *
     * The newPath parameter indicates whether the path should reach the
     * starting point with a moveTo() command or a lineTo() segment.
     *
     * @param path
     * @param radii
     * @param x
     * @param y
     * @param quadrant
     * @param tstart
     * @param tend
     * @param newPath
     */
    private void doCorner(Path2D path, CornerRadii radii,
                          float x, float y, int quadrant,
                          float tstart, float tend, boolean newPath)
    {
        float dx0, dy0, dx1, dy1;
        float hr, vr;
        switch (quadrant &amp; 0x3) {
            case 0:
                hr = (float) radii.getTopLeftHorizontalRadius();
                vr = (float) radii.getTopLeftVerticalRadius();
                // 0 - Top Left:      X + 0 , Y + VR,      X, Y,      X + HR, Y + 0
                dx0 =  0f;  dy0 =  vr;    dx1 =  hr;  dy1 =  0f;
                break;
            case 1:
                hr = (float) radii.getTopRightHorizontalRadius();
                vr = (float) radii.getTopRightVerticalRadius();
                // 1 - Top Right:     X - HR, Y + 0 ,      X, Y,      X + 0 , Y + VR
                dx0 = -hr;  dy0 =  0f;    dx1 =  0f;  dy1 =  vr;
                break;
            case 2:
                hr = (float) radii.getBottomRightHorizontalRadius();
                vr = (float) radii.getBottomRightVerticalRadius();
                // 2 - Bottom Right:  X + 0 , Y - VR,      X, Y,      X - HR, Y + 0
                dx0 =  0f;  dy0 = -vr;    dx1 = -hr;  dy1 = 0f;
                break;
            case 3:
                hr = (float) radii.getBottomLeftHorizontalRadius();
                vr = (float) radii.getBottomLeftVerticalRadius();
                // 3 - Bottom Left:   X + HR, Y + 0 ,      X, Y,      X + 0 , Y - VR
                dx0 =  hr;  dy0 =  0f;    dx1 =  0f;  dy1 = -vr;
                break;
            default: return; // Can never happen
        }
        if (hr &gt; 0 &amp;&amp; vr &gt; 0) {
            path.appendOvalQuadrant(x + dx0, y + dy0, x, y, x + dx1, y + dy1, tstart, tend,
                                    (newPath)
                                        ? Path2D.CornerPrefix.MOVE_THEN_CORNER
                                        : Path2D.CornerPrefix.LINE_THEN_CORNER);
        } else if (newPath) {
            path.moveTo(x, y);
        } else {
            path.lineTo(x, y);
        }
    }

    /**
     * Creates a rounded rectangle path with our width and height, different corner radii,
     * offset with given offsets
     */
    private Path2D createPath(float width, float height, float t, float l, float bo, float ro, CornerRadii radii) {
        float r = width - ro;
        float b = height - bo;
        Path2D path = new Path2D();
        doCorner(path, radii, l, t, 0, 0f, 1f, true);
        doCorner(path, radii, r, t, 1, 0f, 1f, false);
        doCorner(path, radii, r, b, 2, 0f, 1f, false);
        doCorner(path, radii, l, b, 3, 0f, 1f, false);
        path.closePath();
        return path;
    }

    private Path2D makeRoundedEdge(CornerRadii radii,
                                   float x0, float y0, float x1, float y1,
                                   int quadrant)
    {
        Path2D path = new Path2D();
        doCorner(path, radii, x0, y0, quadrant,   0.5f, 1.0f, true);
        doCorner(path, radii, x1, y1, quadrant+1, 0.0f, 0.5f, false);
        return path;
    }

    /**
     * Creates a rounded rectangle path with our width and height, different corner radii, offset with given offsets.
     * Each side as a separate path.  The sides are returned in the CSS standard
     * order of top, right, bottom, left.
     */
    private Path2D[] createPaths(float t, float l, float bo, float ro, CornerRadii radii)
    {
        float r = width - ro;
        float b = height - bo;
        return new Path2D[] {
            makeRoundedEdge(radii, l, t, r, t, 0), // top
            makeRoundedEdge(radii, r, t, r, b, 1), // right
            makeRoundedEdge(radii, r, b, l, b, 2), // bottom
            makeRoundedEdge(radii, l, b, l, t, 3), // left
        };
    }

    /**
     * Create a bigger or smaller version of shape. If not scaleShape then the shape is just centered rather
     * than resized. Proportions are not maintained when resizing. This is necessary so as to ensure
     * that the fill never looks scaled. For example, a tile-imaged based background will look stretched
     * if we were to render a scaled shape. Instead, we produce a new shape based on the scaled size and
     * then fill that shape without additional transforms.
     */
    private Shape resizeShape(float topOffset, float rightOffset, float bottomOffset, float leftOffset) {
        // The bounds of the shape, before any centering / scaling takes place
        final RectBounds bounds = shape.getBounds();
        if (scaleShape) {
            // First we need to modify the transform to scale the shape so that it will fit
            // within the insets.
            SCRATCH_AFFINE.setToIdentity();
            SCRATCH_AFFINE.translate(leftOffset, topOffset);
            // width &amp; height are the width and height of the region. w &amp; h are the width and height
            // of the box within which the new shape must fit.
            final float w = width - leftOffset - rightOffset;
            final float h = height - topOffset - bottomOffset;
            SCRATCH_AFFINE.scale(w / bounds.getWidth(), h / bounds.getHeight());
            // If we also need to center it, we need to adjust the transform so as to place
            // the shape in the center of the bounds
            if (centerShape) {
                SCRATCH_AFFINE.translate(-bounds.getMinX(), -bounds.getMinY());
            }
            return SCRATCH_AFFINE.createTransformedShape(shape);
        } else if (centerShape) {
            // We are only centering. In this case, what we want is for the
            // original shape to be centered. If there are offsets (insets)
            // then we must pre-scale about the center to account for it.
            final float boundsWidth = bounds.getWidth();
            final float boundsHeight = bounds.getHeight();
            float newW = boundsWidth - leftOffset - rightOffset;
            float newH = boundsHeight - topOffset - bottomOffset;
            SCRATCH_AFFINE.setToIdentity();
            SCRATCH_AFFINE.translate(leftOffset + (width - boundsWidth)/2 - bounds.getMinX(),
                                     topOffset + (height - boundsHeight)/2 - bounds.getMinY());
            if (newH != boundsHeight || newW != boundsWidth) {
                SCRATCH_AFFINE.translate(bounds.getMinX(), bounds.getMinY());
                SCRATCH_AFFINE.scale(newW / boundsWidth, newH / boundsHeight);
                SCRATCH_AFFINE.translate(-bounds.getMinX(), -bounds.getMinY());
            }
            return SCRATCH_AFFINE.createTransformedShape(shape);
        } else if (topOffset != 0 || rightOffset != 0 || bottomOffset != 0 || leftOffset != 0) {
            // We are neither centering nor scaling, but we still have to resize the
            // shape because we have to fit within the bounds defined by the offsets
            float newW = bounds.getWidth() - leftOffset - rightOffset;
            float newH = bounds.getHeight() - topOffset - bottomOffset;
            SCRATCH_AFFINE.setToIdentity();
            SCRATCH_AFFINE.translate(leftOffset, topOffset);
            SCRATCH_AFFINE.translate(bounds.getMinX(), bounds.getMinY());
            SCRATCH_AFFINE.scale(newW / bounds.getWidth(), newH / bounds.getHeight());
            SCRATCH_AFFINE.translate(-bounds.getMinX(), -bounds.getMinY());
            return SCRATCH_AFFINE.createTransformedShape(shape);
        } else {
            // Nothing has changed, so we can simply return!
            return shape;
        }
    }

    private void paintTiles(Graphics g, Image img, BorderRepeat repeatX, BorderRepeat repeatY, Side horizontalSide, Side verticalSide,
            final float regionX, final float regionY, final float regionWidth, final float regionHeight,
            final int srcX, final int srcY, final int srcW, final int srcH,
            float tileX, float tileY, float tileWidth, float tileHeight)
    {
        BackgroundRepeat rx = null;
        BackgroundRepeat ry = null;

        switch (repeatX) {
            case REPEAT: rx = BackgroundRepeat.REPEAT; break;
            case STRETCH: rx = BackgroundRepeat.NO_REPEAT; break;
            case ROUND: rx = BackgroundRepeat.ROUND; break;
            case SPACE: rx = BackgroundRepeat.SPACE; break;
        }

        switch (repeatY) {
            case REPEAT: ry = BackgroundRepeat.REPEAT; break;
            case STRETCH: ry = BackgroundRepeat.NO_REPEAT; break;
            case ROUND: ry = BackgroundRepeat.ROUND; break;
            case SPACE: ry = BackgroundRepeat.SPACE; break;
        }

        paintTiles(g, img, rx, ry, horizontalSide, verticalSide, regionX, regionY, regionWidth, regionHeight,
                   srcX, srcY, srcW, srcH, tileX, tileY, tileWidth, tileHeight);
    }

    /**
     * Paints a subsection (srcX,srcY,srcW,srcH) of an image tiled or stretched to fill the destination area
     * (regionWidth,regionHeight). It is assumed we are pre-transformed to the correct origin, top left or destination area. When
     * tiling the first tile is positioned within the rectangle (tileX,tileY,tileW,tileH).
     *
     * Drawing two images next to each other on a non-pixel boundary can not be done simply so we use integers here. This
     * assumption may be wrong when drawing though a scale transform.
     *
     * @param g        The graphics context to draw image into
     * @param img       The image to draw
     * @param repeatX   The horizontal repeat style for filling the area with the src image
     * @param repeatY   The vertical repeat style for filling the area with the src image
     * @param horizontalSide The left or right
     * @param verticalSide The top or bottom
     * @param regionX      The top left corner X of the area of the graphics context to fill with our img
     * @param regionY      The top left corner Y of the area of the graphics context to fill with our img
     * @param regionWidth      The width of the area of the graphics context to fill with our img
     * @param regionHeight      The height of the area of the graphics context to fill with our img
     * @param srcX      The top left corner X of the area of the image to paint with
     * @param srcY      The top left corner Y of the area of the image to paint with
     * @param srcW      The width of the area of the image to paint with, -1 to use the original image width
     * @param srcH      The height of the area of the image to paint with, -1 to use the original image height
     * @param tileX     The top left corner X of the area of the first tile within the destination rectangle. In some
     *                  cases we begin by drawing the center tile, and working to the left &amp; right (for example), so
     *                  this value is not always the same as regionX.
     * @param tileY     The top left corner Y of the area of the first tile within the destination rectangle
     * @param tileWidth The width of the area of the first tile within the destination rectangle, if &lt;= 0, then the use intrinsic value
     * @param tileHeight The height of the area of the first tile within the destination rectangle, if &lt;= 0, then the use intrinsic value
     */
    private void paintTiles(Graphics g, Image img, BackgroundRepeat repeatX, BackgroundRepeat repeatY, Side horizontalSide, Side verticalSide,
            final float regionX, final float regionY, final float regionWidth, final float regionHeight,
            final int srcX, final int srcY, final int srcW, final int srcH,
            float tileX, float tileY, float tileWidth, float tileHeight)
    {
        // If the destination width/height is 0 or the src width / height is 0 then we have
        // nothing to draw, so we can just bail.
        if (regionWidth &lt;= 0 || regionHeight &lt;= 0 || srcW &lt;= 0 || srcH &lt;= 0) return;

        // At this point we should have real values for the image source coordinates
        assert srcX &gt;= 0 &amp;&amp; srcY &gt;= 0 &amp;&amp; srcW &gt; 0 &amp;&amp; srcH &gt; 0;

        // If we are repeating in both the x &amp; y directions, then we can take a fast path and just
        // use the ImagePattern directly instead of having to issue a large number of drawTexture calls.
        // This is the generally common case where we are tiling the background in both dimensions.
        // Note that this only works if the anchor point is the top-left, otherwise the ImagePattern would
        // not give the correct expected results.
        if (tileX == 0 &amp;&amp; tileY == 0 &amp;&amp; repeatX == BackgroundRepeat.REPEAT &amp;&amp; repeatY == BackgroundRepeat.REPEAT) {
            if (srcX != 0 || srcY != 0 || srcW != img.getWidth() || srcH != img.getHeight()) {
                img = img.createSubImage(srcX, srcY, srcW, srcH);
            }
            g.setPaint(new ImagePattern(img, 0, 0, tileWidth, tileHeight, false, false));
            g.fillRect(regionX, regionY, regionWidth, regionHeight);
        } else {
            // If SPACE repeat mode is being used, then we need to take special action if there is not enough
            // space to have more than one tile. Basically, it needs to act as NO_REPEAT in that case (see
            // section 3.4 of the spec for details under rules for SPACE).
            if (repeatX == BackgroundRepeat.SPACE &amp;&amp; (regionWidth &lt; (tileWidth * 2))) {
                repeatX = BackgroundRepeat.NO_REPEAT;
            }

            if (repeatY == BackgroundRepeat.SPACE &amp;&amp; (regionHeight &lt; (tileHeight * 2))) {
                repeatY = BackgroundRepeat.NO_REPEAT;
            }

            // The following variables are computed and used in order to lay out the tiles in the x and y directions.
            // &quot;count&quot; is used to keep track of the number of tiles to lay down in the x and y directions.
            final int countX, countY;
            // The amount to increment the dstX and dstY by during the rendering loop. This may be positive or
            //negative and will include any space between tiles.
            final float xIncrement, yIncrement;

            // Based on the repeat mode, populate the above variables
            if (repeatX == BackgroundRepeat.REPEAT) {
                // In some cases we have a large positive offset but are in repeat mode. What we need
                // to do is tile, but we want to do so in such a way that we are &quot;anchored&quot; to the center,
                // or right, or whatnot. That is what offsetX will be used for.
                float offsetX = 0;
                if (tileX != 0) {
                    float mod = tileX % tileWidth;
                    tileX = mod == 0 ? 0 : tileX &lt; 0 ? mod : mod - tileWidth;
                    offsetX = tileX;
                }
                countX = (int) Math.max(1, Math.ceil((regionWidth - offsetX) / tileWidth));
                xIncrement = horizontalSide == Side.RIGHT ? -tileWidth : tileWidth;
            } else if (repeatX == BackgroundRepeat.SPACE) {
                tileX = 0; // Space will always start from the top left
                countX = (int) (regionWidth / tileWidth);
                float remainder = (regionWidth % tileWidth);
                xIncrement = tileWidth + (remainder / (countX - 1));
            } else if (repeatX == BackgroundRepeat.ROUND) {
                tileX = 0; // Round will always start from the top left
                countX = (int) (regionWidth / tileWidth);
                tileWidth = regionWidth / (int)(regionWidth / tileWidth);
                xIncrement = tileWidth;
            } else { // no repeat
                countX = 1;
                xIncrement = horizontalSide == Side.RIGHT ? -tileWidth : tileWidth;
            }

            if (repeatY == BackgroundRepeat.REPEAT) {
                float offsetY = 0;
                if (tileY != 0) {
                    float mod = tileY % tileHeight;
                    tileY = mod == 0 ? 0 : tileY &lt; 0 ? mod : mod - tileHeight;
                    offsetY = tileY;
                }
                countY = (int) Math.max(1, Math.ceil((regionHeight - offsetY) / tileHeight));
                yIncrement = verticalSide == Side.BOTTOM ? -tileHeight : tileHeight;
            } else if (repeatY == BackgroundRepeat.SPACE) {
                tileY = 0; // Space will always start from the top left
                countY = (int) (regionHeight / tileHeight);
                float remainder = (regionHeight % tileHeight);
                yIncrement = tileHeight + (remainder / (countY - 1));
            } else if (repeatY == BackgroundRepeat.ROUND) {
                tileY = 0; // Round will always start from the top left
                countY = (int) (regionHeight / tileHeight);
                tileHeight = regionHeight / (int)(regionHeight / tileHeight);
                yIncrement = tileHeight;
            } else { // no repeat
                countY = 1;
                yIncrement = verticalSide == Side.BOTTOM ? -tileHeight : tileHeight;
            }

            // paint loop
            final Texture texture =
                g.getResourceFactory().getCachedTexture(img, Texture.WrapMode.CLAMP_TO_EDGE);
            final int srcX2 = srcX + srcW;
            final int srcY2 = srcY + srcH;
            final float regionX2 = regionX + regionWidth;
            final float regionY2 = regionY + regionHeight;

            float dstY = regionY + tileY;
            for (int y = 0; y &lt; countY; y++) {
                float dstY2 = dstY + tileHeight;
                float dstX = regionX + tileX;
                for (int x = 0; x &lt; countX; x++) {
                    float dstX2 = dstX + tileWidth;
                    // We don't want to end up rendering if we find that the destination rect is completely
                    // off of the region rendering area
                    boolean skipRender = false;
                    float dx1 = dstX &lt; regionX ? regionX : dstX;
                    float dy1 = dstY &lt; regionY ? regionY : dstY;
                    if (dx1 &gt; regionX2 || dy1 &gt; regionY2) skipRender = true;

                    float dx2 = dstX2 &gt; regionX2 ? regionX2 : dstX2;
                    float dy2 = dstY2 &gt; regionY2 ? regionY2 : dstY2;
                    if (dx2 &lt; regionX || dy2 &lt; regionY) skipRender = true;

                    if (!skipRender) {
                        // We know that dstX, dstY, dstX2, dstY2 overlap the region drawing area. Now we need
                        // to compute the source rectangle, and then draw.
                        float sx1 = dstX &lt; regionX ? srcX + srcW * (-tileX / tileWidth) : srcX;
                        float sy1 = dstY &lt; regionY ? srcY + srcH * (-tileY / tileHeight) : srcY;
                        float sx2 = dstX2 &gt; regionX2 ? srcX2 - srcW * ((dstX2 - regionX2) / tileWidth) : srcX2;
                        float sy2 = dstY2 &gt; regionY2 ? srcY2 - srcH * ((dstY2 - regionY2) / tileHeight) : srcY2;
//                        System.out.println(&quot;g.drawTexture(texture, &quot; + dx1 + &quot;, &quot; + dy1 + &quot;, &quot; + dx2 + &quot;, &quot; + dy2 + &quot;, &quot; + sx1 + &quot;, &quot; + sy1 + &quot;, &quot; + sx2 + &quot;, &quot; + sy2 + &quot;)&quot;);
                        g.drawTexture(texture, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2);
                    }
                    dstX += xIncrement;
                }
                dstY += yIncrement;
            }
            texture.unlock();
        }
    }

    final Border getBorder() {
        return border;
    }

    final Background getBackground() {
        return background;
    }

    final float getWidth() {
        return width;
    }

    final float getHeight() {
        return height;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/marlin/stats/StatLong.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.marlin.stats;

/**
 * Statistics as long values
 */
public class StatLong {

    public final String name;
    public long count = 0l;
    public long sum = 0l;
    public long min = Integer.MAX_VALUE;
    public long max = Integer.MIN_VALUE;

    public StatLong(final String name) {
        this.name = name;
    }

    public void reset() {
        count = 0l;
        sum = 0l;
        min = Integer.MAX_VALUE;
<A NAME="10"></A>        max = Integer.MIN_VALUE;
    }

    public void add(final int val) <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#10',2,'match52-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        count++;
        sum += val;
        if (val &lt; min) {
            min = val;
        }
        if (val &gt; max) {
            max = val;
        }
    }

    pub</B></FONT>lic void add(final long val) {
        count++;
        sum += val;
        if (val &lt; min) {
            min = val;
        }
        if (val &gt; max) {
            max = val;
        }
    }

    @Override
    public String toString() {
        return toString(new StringBuilder(128)).toString();
    }

    public final StringBuilder toString(final StringBuilder sb) {
        sb.append(name).append('[').append(count);
        sb.append(&quot;] sum: &quot;).append(sum).append(&quot; avg: &quot;);
        sb.append(trimTo3Digits(((double) sum) / count));
        sb.append(&quot; [&quot;).append(min).append(&quot; | &quot;).append(max).append(&quot;]&quot;);
        return sb;
    }

    /**
     * Adjust the given double value to keep only 3 decimal digits
     *
     * @param value value to adjust
     * @return double value with only 3 decimal digits
     */
    public static double trimTo3Digits(final double value) {
        return ((long) (1e3d * value)) / 1e3d;
    }
}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/BasicStroke.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism;

import com.sun.javafx.geom.Area;
import com.sun.javafx.geom.GeneralShapePair;
import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.PathIterator;
import com.sun.javafx.geom.RoundRectangle2D;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.ShapePair;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.prism.impl.shape.ShapeUtil;

public final class BasicStroke {

    /** Constant value for end cap style. */
    public static final int CAP_BUTT = 0;
    /** Constant value for end cap style. */
    public static final int CAP_ROUND = 1;
    /** Constant value for end cap style. */
    public static final int CAP_SQUARE = 2;

<A NAME="22"></A>    /** Constant value for join style. */
    public static final int JOIN_MITER = 0;
    /** Constant value for join style. */
    <FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#22',2,'match52-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>public static final int JOIN_ROUND = 1;
    /** Constant value for join style. */
    public static final int JOIN_BEVEL = 2;

    public static final int TYPE_CENTERED = 0;
    public static final int TYPE_INNER = 1;
    public static final int TYPE_OUTER = 2;

    float width;
    int type;
    int cap;
    int join;
    float miterLimit;
    float dash[];
    float dashPhase;

    public BasicStroke() {
        set</B></FONT>(TYPE_CENTERED, 1.0f, CAP_SQUARE, JOIN_MITER, 10f);
    }

    public BasicStroke(float width, int cap, int join, float miterLimit) {
        set(TYPE_CENTERED, width, cap, join, miterLimit);
    }

    public BasicStroke(int type, float width,
                       int cap, int join, float miterLimit)
    {
        set(type, width, cap, join, miterLimit);
    }

    public BasicStroke(float width, int cap, int join, float miterLimit,
                       float[] dash, float dashPhase)
    {
        set(TYPE_CENTERED, width, cap, join, miterLimit);
        set(dash, dashPhase);
    }

    public BasicStroke(float width, int cap, int join, float miterLimit,
                       double[] dash, float dashPhase)
    {
        set(TYPE_CENTERED, width, cap, join, miterLimit);
        set(dash, dashPhase);
    }

    public BasicStroke(int type, float width, int cap, int join, float miterLimit,
                       float[] dash, float dashPhase)
    {
        set(type, width, cap, join, miterLimit);
        set(dash, dashPhase);
    }

    public BasicStroke(int type, float width, int cap, int join, float miterLimit,
                       double[] dash, float dashPhase)
    {
        set(type, width, cap, join, miterLimit);
        set(dash, dashPhase);
    }

    public void set(int type, float width,
                    int cap, int join, float miterLimit)
    {
        if (type != TYPE_CENTERED &amp;&amp; type != TYPE_INNER &amp;&amp; type != TYPE_OUTER) {
            throw new IllegalArgumentException(&quot;illegal type&quot;);
        }
        if (width &lt; 0.0f) {
            throw new IllegalArgumentException(&quot;negative width&quot;);
        }
        if (cap != CAP_BUTT &amp;&amp; cap != CAP_ROUND &amp;&amp; cap != CAP_SQUARE) {
            throw new IllegalArgumentException(&quot;illegal end cap value&quot;);
        }
        if (join == JOIN_MITER) {
            if (miterLimit &lt; 1.0f) {
                throw new IllegalArgumentException(&quot;miter limit &lt; 1&quot;);
            }
        } else if (join != JOIN_ROUND &amp;&amp; join != JOIN_BEVEL) {
            throw new IllegalArgumentException(&quot;illegal line join value&quot;);
        }
        this.type = type;
        this.width = width;
        this.cap = cap;
        this.join = join;
        this.miterLimit = miterLimit;
    }

    public void set(float dash[], float dashPhase) {
        if (dash != null) {
            boolean allzero = true;
            for (int i = 0; i &lt; dash.length; i++) {
                float d = dash[i];
                if (d &gt; 0.0) {
                    allzero = false;
                } else if (d &lt; 0.0) {
                    throw new IllegalArgumentException(&quot;negative dash length&quot;);
                }
            }
            if (allzero) {
                throw new IllegalArgumentException(&quot;dash lengths all zero&quot;);
            }
        }
        this.dash = dash;
        this.dashPhase = dashPhase;
    }

    public void set(double dash[], float dashPhase) {
        if (dash != null) {
            float newdashes[] = new float[dash.length];
            boolean allzero = true;
            for (int i = 0; i &lt; dash.length; i++) {
                float d = (float) dash[i];
                if (d &gt; 0.0) {
                    allzero = false;
                } else if (d &lt; 0.0) {
                    throw new IllegalArgumentException(&quot;negative dash length&quot;);
                }
                newdashes[i] = d;
            }
            if (allzero) {
                throw new IllegalArgumentException(&quot;dash lengths all zero&quot;);
            }
            this.dash = newdashes;
        } else {
            this.dash = null;
        }
        this.dashPhase = dashPhase;
    }

    /**
     * Returns the stroke type, one of {@code TYPE_CENTERED},
     * {@code TYPE_INNER}, or {@code TYPE_OUTER}.
     * @return the stroke type
     */
    public int getType() {
        return type;
    }

    /**
     * Returns the line width.  Line width is represented in user space,
     * which is the default-coordinate space used by Java 2D.  See the
     * &lt;code&gt;Graphics2D&lt;/code&gt; class comments for more information on
     * the user space coordinate system.
     * @return the line width of this &lt;code&gt;BasicStroke&lt;/code&gt;.
     */
    public float getLineWidth() {
        return width;
    }

    /**
     * Returns the end cap style.
     * @return the end cap style of this &lt;code&gt;BasicStroke&lt;/code&gt; as one
     * of the static &lt;code&gt;int&lt;/code&gt; values that define possible end cap
     * styles.
     */
    public int getEndCap() {
        return cap;
    }

    /**
     * Returns the line join style.
     * @return the line join style of the &lt;code&gt;BasicStroke&lt;/code&gt; as one
     * of the static &lt;code&gt;int&lt;/code&gt; values that define possible line
     * join styles.
     */
    public int getLineJoin() {
        return join;
    }

    /**
     * Returns the limit of miter joins.
     * @return the limit of miter joins of the &lt;code&gt;BasicStroke&lt;/code&gt;.
     */
    public float getMiterLimit() {
        return miterLimit;
    }

    /**
     * Returns true if this stroke object will apply dashing attributes
     * to the path.
     * @return whether the stroke has dashes
     */
    public boolean isDashed() {
        return (dash != null);
    }
    /**
     * Returns the array representing the lengths of the dash segments.
     * Alternate entries in the array represent the user space lengths
     * of the opaque and transparent segments of the dashes.
     * As the pen moves along the outline of the &lt;code&gt;Shape&lt;/code&gt;
     * to be stroked, the user space
     * distance that the pen travels is accumulated.  The distance
     * value is used to index into the dash array.
     * The pen is opaque when its current cumulative distance maps
     * to an even element of the dash array and transparent otherwise.
     * @return the dash array.
     */
    public float[] getDashArray() {
        return dash;
    }

    /**
     * Returns the current dash phase.
     * The dash phase is a distance specified in user coordinates that
     * represents an offset into the dashing pattern. In other words, the dash
     * phase defines the point in the dashing pattern that will correspond to
     * the beginning of the stroke.
     * @return the dash phase as a &lt;code&gt;float&lt;/code&gt; value.
     */
    public float getDashPhase() {
        return dashPhase;
    }

    public Shape createStrokedShape(Shape s) {
        Shape ret;
        if (s instanceof RoundRectangle2D) {
            ret = strokeRoundRectangle((RoundRectangle2D) s);
        } else {
            ret = null;
        }
        if (ret != null) {
            return ret;
        }

        ret = createCenteredStrokedShape(s);

        if (type == TYPE_INNER) {
            ret = makeIntersectedShape(ret, s);
        } else if (type == TYPE_OUTER) {
            ret = makeSubtractedShape(ret, s);
        }
        return ret;
    }

    private boolean isCW(final float dx1, final float dy1,
                         final float dx2, final float dy2)
    {
        return dx1 * dy2 &lt;= dy1 * dx2;
    }

    private void computeOffset(final float lx, final float ly,
                               final float w, final float[] m, int off) {
        final float len = (float) Math.sqrt(lx * lx + ly * ly);
        if (len == 0) {
            m[off + 0] = m[off + 1] = 0;
        } else {
            m[off + 0] = (ly * w) / len;
            m[off + 1] = -(lx * w) / len;
        }
    }

    private void computeMiter(final float x0, final float y0,
                              final float x1, final float y1,
                              final float x0p, final float y0p,
                              final float x1p, final float y1p,
                              final float[] m, int off)
    {
        float x10 = x1 - x0;
        float y10 = y1 - y0;
        float x10p = x1p - x0p;
        float y10p = y1p - y0p;

        // if this is 0, the lines are parallel. If they go in the
        // same direction, there is no intersection so m[off] and
        // m[off+1] will contain infinity, so no miter will be drawn.
        // If they go in the same direction that means that the start of the
        // current segment and the end of the previous segment have the same
        // tangent, in which case this method won't even be involved in
        // miter drawing because it won't be called by drawMiter (because
        // (mx == omx &amp;&amp; my == omy) will be true, and drawMiter will return
        // immediately).
        float den = x10*y10p - x10p*y10;
        float t = x10p*(y0-y0p) - y10p*(x0-x0p);
        t /= den;
        m[off++] = x0 + t*x10;
        m[off] = y0 + t*y10;
    }


    // taken from com.sun.javafx.geom.Shape.accumulateQuad (added the width)
    private void accumulateQuad(float bbox[], int off,
                               float v0, float vc, float v1, float w)
    {
        // Breaking this quad down into a polynomial:
        // eqn[0] = v0;
        // eqn[1] = vc + vc - v0 - v0;
        // eqn[2] = v0 - vc - vc + v1;
        // Deriving the polynomial:
        // eqn'[0] = 1*eqn[1] = 2*(vc-v0)
        // eqn'[1] = 2*eqn[2] = 2*((v1-vc)-(vc-v0))
        // Solving for zeroes on the derivative:
        // e1*t + e0 = 0
        // t = -e0/e1;
        // t = -2(vc-v0) / 2((v1-vc)-(vc-v0))
        // t = (v0-vc) / (v1-vc+v0-vc)
        float num = v0 - vc;
        float den = v1 - vc + num;
        if (den != 0f) {
            float t = num / den;
            if (t &gt; 0 &amp;&amp; t &lt; 1) {
                float u = 1f - t;
                float v = v0 * u * u + 2 * vc * t * u + v1 * t * t;
                if (bbox[off] &gt; v - w) bbox[off] = v - w;
                if (bbox[off+2] &lt; v + w) bbox[off+2] = v + w;
            }
        }
    }

    // taken from com.sun.javafx.geom.Shape.accumulateCubic (added the width)
    private void accumulateCubic(float bbox[], int off, float t,
                                float v0, float vc0, float vc1, float v1, float w)
    {
        if (t &gt; 0 &amp;&amp; t &lt; 1) {
            float u = 1f - t;
            float v =        v0 * u * u * u
                      + 3 * vc0 * t * u * u
                      + 3 * vc1 * t * t * u
                      +      v1 * t * t * t;
            if (bbox[off] &gt; v - w) bbox[off] = v - w;
            if (bbox[off+2] &lt; v + w) bbox[off+2] = v + w;
        }
    }

    // taken from com.sun.javafx.geom.Shape.accumulateCubic (added the width)
    private void accumulateCubic(float bbox[], int off,
                                float v0, float vc0, float vc1, float v1, float w)
    {
        // Breaking this cubic down into a polynomial:
        // eqn[0] = v0;
        // eqn[1] = (vc0 - v0) * 3f;
        // eqn[2] = (vc1 - vc0 - vc0 + v0) * 3f;
        // eqn[3] = v1 + (vc0 - vc1) * 3f - v0;
        // Deriving the polynomial:
        // eqn'[0] = 1*eqn[1] = 3(vc0-v0)
        // eqn'[1] = 2*eqn[2] = 6((vc1-vc0)-(vc0-v0))
        // eqn'[2] = 3*eqn[3] = 3((v1-vc1)-2(vc1-vc0)+(vc0-v0))
        // Solving for zeroes on the derivative:
        // e2*t*t + e1*t + e0 = a*t*t + b*t + c = 0
        // Note that in solving for 0 we can divide all e0,e1,e2 by 3
        // t = (-b +/- sqrt(b*b-4ac))/2a
        float c = vc0 - v0;
        float b = 2f * ((vc1 - vc0) - c);
        float a = (v1 - vc1) - b - c;
        if (a == 0f) {
            // The quadratic parabola has degenerated to a line.
            if (b == 0f) {
                // The line has degenerated to a constant.
                return;
            }
            accumulateCubic(bbox, off, -c/b, v0, vc0, vc1, v1, w);
        } else {
            // From Numerical Recipes, 5.6, Quadratic and Cubic Equations
            float d = b * b - 4f * a * c;
            if (d &lt; 0f) {
                // If d &lt; 0.0, then there are no roots
                return;
            }
            d = (float) Math.sqrt(d);
            // For accuracy, calculate one root using:
            //     (-b +/- d) / 2a
            // and the other using:
            //     2c / (-b +/- d)
            // Choose the sign of the +/- so that b+d gets larger in magnitude
            if (b &lt; 0f) {
                d = -d;
            }
            float q = (b + d) / -2f;
            // We already tested a for being 0 above
            accumulateCubic(bbox, off, q/a, v0, vc0, vc1, v1, w);
            if (q != 0f) {
                accumulateCubic(bbox, off, c/q, v0, vc0, vc1, v1, w);
            }
        }
    }

    // Basically any type of transform that does not violate a uniform
    // unsheared 2D scale.  We may have to scale the associated line width,
    // but we can accumulate everything in device space with no problems.
    private static final int SAFE_ACCUMULATE_MASK =
        (BaseTransform.TYPE_FLIP |
         BaseTransform.TYPE_GENERAL_ROTATION |
         BaseTransform.TYPE_QUADRANT_ROTATION |
         BaseTransform.TYPE_TRANSLATION |
         BaseTransform.TYPE_UNIFORM_SCALE);

    public void accumulateShapeBounds(float bbox[], Shape shape, BaseTransform tx) {
        if (type == TYPE_INNER) {
            Shape.accumulate(bbox, shape, tx);
            return;
        }
        if ((tx.getType() &amp; ~SAFE_ACCUMULATE_MASK) != 0) {
            // This is a work-around for RT-15648.  That bug still applies here
            // since we should be optimizing that case, but at least with this
            // work-around, someone who calls this method, and is not aware of
            // that bug, will not be bitten by a bad answer.
            Shape.accumulate(bbox, createStrokedShape(shape), tx);
            return;
        }
        PathIterator pi = shape.getPathIterator(tx);
        boolean lastSegmentMove = true;
        float coords[] = new float[6];
        float w = type == TYPE_CENTERED ? getLineWidth() / 2 : getLineWidth();
        // Length(Transform(w, 0)) == w * Length(Transform(1, 0))
        w *= Math.hypot(tx.getMxx(), tx.getMyx());
        // starting x,y; previous x0, y0 and current x1,y1
        float sx = 0f, sy = 0f, x0 = 0f, y0 = 0f, x1, y1;
        // starting delta x,y; delta x,y; previous delta x,y
        float sdx = 0f, sdy = 0f, dx, dy, pdx = 0f, pdy = 0f;
        // current offset
        float o[] = new float[4];
        // previous offset; starting offset
        float pox = 0f, poy = 0f, sox = 0f, soy = 0f;

        while (!pi.isDone()) {
            int cur = pi.currentSegment(coords);
            switch (cur) {
                case PathIterator.SEG_MOVETO:
                    if (!lastSegmentMove) {
                        accumulateCap(pdx, pdy, x0, y0, pox, poy, bbox, w);
                        accumulateCap(-sdx, -sdy, sx, sy, -sox, -soy, bbox, w);
                    }

                    x0 = sx = coords[0];
                    y0 = sy = coords[1];
                    break;
                case PathIterator.SEG_LINETO:
                    x1 = coords[0];
                    y1 = coords[1];
                    dx = x1 - x0;
                    dy = y1 - y0;
                    if (dx == 0f &amp;&amp; dy == 0f) {
                        // Ideally these segments should be ignored, but both
                        // Java 2D and OpenPisces treat this case as if we
                        // were joining to a segment that was horizontal.
                        dx = 1f;
                    }

                    computeOffset(dx, dy, w, o, 0);

                    if (!lastSegmentMove) {
                        accumulateJoin(pdx, pdy, dx, dy, x0, y0, pox, poy, o[0], o[1], bbox, w);
                    }

                    x0 = x1;
                    y0 = y1;
                    pdx = dx;
                    pdy = dy;
                    pox = o[0];
                    poy = o[1];
                    if (lastSegmentMove) {
                        sdx = pdx;
                        sdy = pdy;
                        sox = pox;
                        soy = poy;
                    }
                    break;
                case PathIterator.SEG_QUADTO:
                    x1 = coords[2];
                    y1 = coords[3];
                    dx = coords[0] - x0;
                    dy = coords[1] - y0;

                    computeOffset(dx, dy, w, o, 0);
                    if (!lastSegmentMove) {
                        accumulateJoin(pdx, pdy, dx, dy, x0, y0, pox, poy, o[0], o[1], bbox, w);
                    }

                    if (bbox[0] &gt; coords[0] - w || bbox[2] &lt; coords[0] + w) {
                        accumulateQuad(bbox, 0, x0, coords[0], x1, w);
                    }
                    if (bbox[1] &gt; coords[1] - w || bbox[3] &lt; coords[1] + w) {
                        accumulateQuad(bbox, 1, y0, coords[1], y1, w);
                    }
                    x0 = x1;
                    y0 = y1;
                    if (lastSegmentMove) {
                        sdx = dx;
                        sdy = dy;
                        sox = o[0];
                        soy = o[1];
                    }
                    pdx = x1 - coords[0];
                    pdy = y1 - coords[1];
                    computeOffset(pdx, pdy, w, o, 0);
                    pox = o[0];
                    poy = o[1];
                    break;
                case PathIterator.SEG_CUBICTO:
                    x1 = coords[4];
                    y1 = coords[5];
                    dx = coords[0] - x0;
                    dy = coords[1] - y0;

                    computeOffset(dx, dy, w, o, 0);
                    if (!lastSegmentMove) {
                        accumulateJoin(pdx, pdy, dx, dy, x0, y0, pox, poy, o[0], o[1], bbox, w);
                    }

                    if (bbox[0] &gt; coords[0] - w || bbox[2] &lt; coords[0] + w ||
                        bbox[0] &gt; coords[2] - w || bbox[2] &lt; coords[2] + w)
                    {
                        accumulateCubic(bbox, 0, x0, coords[0], coords[2], x1, w);
                    }
                    if (bbox[1] &gt; coords[1] - w|| bbox[3] &lt; coords[1] + w ||
                        bbox[1] &gt; coords[3] - w|| bbox[3] &lt; coords[3] + w)
                    {
                        accumulateCubic(bbox, 1, y0, coords[1], coords[3], y1, w);
                    }
                    x0 = x1;
                    y0 = y1;
                    if (lastSegmentMove) {
                        sdx = dx;
                        sdy = dy;
                        sox = o[0];
                        soy = o[1];
                    }
                    pdx = x1 - coords[2];
                    pdy = y1 - coords[3];
                    computeOffset(pdx, pdy, w, o, 0);
                    pox = o[0];
                    poy = o[1];
                    break;
                case PathIterator.SEG_CLOSE:
                    dx = sx - x0;
                    dy = sy - y0;
                    x1 = sx;
                    y1 = sy;

                    if (!lastSegmentMove) {
                        computeOffset(sdx, sdy, w, o, 2);
                        if (dx == 0 &amp;&amp; dy == 0) {
                            accumulateJoin(pdx, pdy, sdx, sdy, sx, sy, pox, poy, o[2], o[3], bbox, w);
                        } else {
                            computeOffset(dx, dy, w, o, 0);
                            accumulateJoin(pdx, pdy, dx, dy, x0, y0, pox, poy, o[0], o[1], bbox, w);
                            accumulateJoin(dx, dy, sdx, sdy, x1, y1, o[0], o[1], o[2], o[3], bbox, w);
                        }
                    }
                    x0 = x1;
                    y0 = y1;
                    break;
            }
            // Close behaves like a move in certain ways - after close, line will draw a cap,
            // like if the close implicitely did move to the original coordinates
            lastSegmentMove = cur == PathIterator.SEG_MOVETO || cur == PathIterator.SEG_CLOSE;
            pi.next();
        }

        if (!lastSegmentMove) {
            accumulateCap(pdx, pdy, x0, y0, pox, poy, bbox, w);
            accumulateCap(-sdx, -sdy, sx, sy, -sox, -soy, bbox, w);
        }
    }

    private void accumulate(float o0, float o1, float o2, float o3, float[] bbox) {
        if (o0 &lt;= o2) {
            if (o0 &lt; bbox[0]) bbox[0] = o0;
            if (o2 &gt; bbox[2]) bbox[2] = o2;
        } else {
            if (o2 &lt; bbox[0]) bbox[0] = o2;
            if (o0 &gt; bbox[2]) bbox[2] = o0;
        }
        if (o1 &lt;= o3) {
            if (o1 &lt; bbox[1]) bbox[1] = o1;
            if (o3 &gt; bbox[3]) bbox[3] = o3;
        } else {
            if (o3 &lt; bbox[1]) bbox[1] = o3;
            if (o1 &gt; bbox[3]) bbox[3] = o1;
        }
    }

    private void accumulateOrdered(float o0, float o1, float o2, float o3, float[] bbox) {
        if (o0 &lt; bbox[0]) bbox[0] = o0;
        if (o2 &gt; bbox[2]) bbox[2] = o2;
        if (o1 &lt; bbox[1]) bbox[1] = o1;
        if (o3 &gt; bbox[3]) bbox[3] = o3;
    }


    private void accumulateJoin(float pdx, float pdy, float dx, float dy, float x0, float y0,
                                float pox, float poy, float ox, float oy, float[] bbox, float w) {

        if (join == JOIN_BEVEL) {
            accumulateBevel(x0, y0, pox, poy, ox, oy, bbox);
        } else if (join == JOIN_MITER) {
            accumulateMiter(pdx, pdy, dx, dy, pox, poy, ox, oy, x0, y0, bbox, w);
        } else { // JOIN_ROUND
            accumulateOrdered(x0 - w, y0 - w, x0 + w, y0 + w, bbox);
        }


    }

    private void accumulateCap(float dx, float dy, float x0, float y0,
                               float ox, float oy, float[] bbox, float w) {
        if (cap == CAP_SQUARE) {
            accumulate(x0 + ox - oy, y0 + oy + ox, x0 - ox - oy, y0 - oy + ox, bbox);
        } else if (cap == CAP_BUTT) {
            accumulate(x0 + ox, y0 + oy, x0 - ox, y0 - oy, bbox);
        } else { //cap == CAP_ROUND
            accumulateOrdered(x0 - w, y0 - w, x0 + w, y0 + w, bbox);
        }

    }

    private float[] tmpMiter = new float[2];

    private void accumulateMiter(float pdx, float pdy, float dx, float dy,
                                    float pox, float poy, float ox, float oy,
                                    float x0, float y0, float[] bbox, float w) {
        // Always accumulate bevel for cases of degenerate miters...
        accumulateBevel(x0, y0, pox, poy, ox, oy, bbox);

        boolean cw = isCW(pdx, pdy, dx, dy);

        if (cw) {
            pox = -pox;
            poy = -poy;
            ox = -ox;
            oy = -oy;
        }

        computeMiter((x0 - pdx) + pox, (y0 - pdy) + poy, x0 + pox, y0 + poy,
                     (x0 + dx) + ox, (y0 + dy) + oy, x0 + ox, y0 + oy,
                     tmpMiter, 0);
        float lenSq = (tmpMiter[0] - x0) * (tmpMiter[0] - x0) + (tmpMiter[1] - y0) * (tmpMiter[1] - y0);

        float miterLimitWidth = miterLimit * w;
        if (lenSq &lt; miterLimitWidth * miterLimitWidth) {
            accumulateOrdered(tmpMiter[0], tmpMiter[1], tmpMiter[0], tmpMiter[1], bbox);
        }
    }


    private void accumulateBevel(float x0, float y0, float pox, float poy, float ox, float oy, float[] bbox) {
        accumulate(x0 + pox, y0 + poy, x0 - pox, y0 - poy, bbox);
        accumulate(x0 + ox, y0 + oy, x0 - ox, y0 - oy, bbox);
    }

    public Shape createCenteredStrokedShape(final Shape s) {
        return ShapeUtil.createCenteredStrokedShape(s, this);
    }

    static final float SQRT_2 = (float) Math.sqrt(2);

    Shape strokeRoundRectangle(RoundRectangle2D rr) {
        if (rr.width &lt; 0 || rr.height &lt; 0) {
            return new Path2D();
        }
        if (isDashed()) {
            return null;
        }
        int j;
        float aw = rr.arcWidth;
        float ah = rr.arcHeight;
        if (aw &lt;= 0f || ah &lt;= 0f) {
            aw = ah = 0f;
            if (type == TYPE_INNER) {
                j = JOIN_MITER;
            } else {
                j = this.join;
                if (j == JOIN_MITER &amp;&amp; miterLimit &lt; SQRT_2) {
                    j = JOIN_BEVEL;
                }
            }
        } else {
            if (aw &lt; ah * 0.9f || ah &lt; aw * 0.9f) {
                // RT-27416
                // TODO: Need to check these multipliers and
                // optimize this case...
                return null;
            }
            j = JOIN_ROUND;
        }
        float id, od;
        if (type == TYPE_INNER) {
            od = 0f;
            id = this.width;
        } else if (type == TYPE_OUTER) {
            od = this.width;
            id = 0f;
        } else {
            od = id = this.width/2f;
        }
        Shape outer;
        switch (j) {
            case JOIN_MITER:
                outer = new RoundRectangle2D(rr.x - od, rr.y - od,
                                             rr.width+od*2f, rr.height+od*2f,
                                             0f, 0f);
                break;
            case JOIN_BEVEL:
                outer = makeBeveledRect(rr.x, rr.y, rr.width, rr.height, od);
                break;
            case JOIN_ROUND:
                outer = new RoundRectangle2D(rr.x - od, rr.y - od,
                                             rr.width+od*2f, rr.height+od*2f,
                                             aw+od*2f, ah+od*2f);
                break;
            default:
                throw new InternalError(&quot;Unrecognized line join style&quot;);
        }
        if (rr.width &lt;= id*2f || rr.height &lt;= id*2f) {
            return outer;
        }
        aw -= id*2f;
        ah -= id*2f;
        if (aw &lt;= 0f || ah &lt;= 0f) {
            aw = ah = 0f;
        }
        Shape inner = new RoundRectangle2D(rr.x + id, rr.y + id,
                                           rr.width-id*2f, rr.height-id*2f,
                                           aw, ah);
        Path2D p2d = (outer instanceof Path2D)
            ? ((Path2D) outer) : new Path2D(outer);
        p2d.setWindingRule(Path2D.WIND_EVEN_ODD);
        p2d.append(inner, false);
        return p2d;
    }

    static Shape makeBeveledRect(float rx, float ry,
                                 float rw, float rh,
                                 float d)
    {
        float rx0 = rx;
        float ry0 = ry;
        float rx1 = rx + rw;
        float ry1 = ry + rh;
        Path2D p = new Path2D();
        p.moveTo(rx0, ry0 - d);
        p.lineTo(rx1, ry0 - d);
        p.lineTo(rx1 + d, ry0);
        p.lineTo(rx1 + d, ry1);
        p.lineTo(rx1, ry1 + d);
        p.lineTo(rx0, ry1 + d);
        p.lineTo(rx0 - d, ry1);
        p.lineTo(rx0 - d, ry0);
        p.closePath();
        return p;
    }

    protected Shape makeIntersectedShape(Shape outer, Shape inner) {
        return new CAGShapePair(outer, inner, ShapePair.TYPE_INTERSECT);
    }

    protected Shape makeSubtractedShape(Shape outer, Shape inner) {
        return new CAGShapePair(outer, inner, ShapePair.TYPE_SUBTRACT);
    }

    static class CAGShapePair extends GeneralShapePair {
        private Shape cagshape;

        public CAGShapePair(Shape outer, Shape inner, int type) {
            super(outer, inner, type);
        }

        @Override
        public PathIterator getPathIterator(BaseTransform tx) {
            if (cagshape == null) {
                Area o = new Area(getOuterShape());
                Area i = new Area(getInnerShape());
                if (getCombinationType() == ShapePair.TYPE_INTERSECT) {
                    o.intersect(i);
                } else {
                    o.subtract(i);
                }
                cagshape = o;
            }
            return cagshape.getPathIterator(tx);
        }
    }

    /**
     * Returns the hashcode for this stroke.
     * @return      a hash code for this stroke.
     */
    @Override
    public int hashCode() {
        int hash = Float.floatToIntBits(width);
        hash = hash * 31 + join;
        hash = hash * 31 + cap;
        hash = hash * 31 + Float.floatToIntBits(miterLimit);
        if (dash != null) {
            hash = hash * 31 + Float.floatToIntBits(dashPhase);
            for (int i = 0; i &lt; dash.length; i++) {
                hash = hash * 31 + Float.floatToIntBits(dash[i]);
            }
        }
        return hash;
    }

    /**
     * Tests if a specified object is equal to this &lt;code&gt;BasicStroke&lt;/code&gt;
     * by first testing if it is a &lt;code&gt;BasicStroke&lt;/code&gt; and then comparing
     * its width, join, cap, miter limit, dash, and dash phase attributes with
     * those of this &lt;code&gt;BasicStroke&lt;/code&gt;.
     * @param  obj the specified object to compare to this
     *              &lt;code&gt;BasicStroke&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if the width, join, cap, miter limit, dash, and
     *            dash phase are the same for both objects;
     *            &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof BasicStroke)) {
            return false;
        }
        BasicStroke bs = (BasicStroke) obj;
        if (width != bs.width) {
            return false;
        }
        if (join != bs.join) {
            return false;
        }
        if (cap != bs.cap) {
            return false;
        }
        if (miterLimit != bs.miterLimit) {
            return false;
        }
        if (dash != null) {
            if (dashPhase != bs.dashPhase) {
                return false;
            }
            if (!java.util.Arrays.equals(dash, bs.dash)) {
                return false;
            }
        }
        else if (bs.dash != null) {
            return false;
        }

        return true;
    }

    public BasicStroke copy() {
        return new BasicStroke(type, width, cap, join, miterLimit, dash, dashPhase);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/d3d/D3DMeshView.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.d3d;

import com.sun.prism.Graphics;
import com.sun.prism.Material;
import com.sun.prism.impl.BaseMeshView;
import com.sun.prism.impl.Disposer;

/**
 * TODO: 3D - Need documentation
 */
class D3DMeshView extends BaseMeshView {

    static int count = 0;
    private final D3DContext context;
    private final long nativeHandle;

    // TODO: 3D - Need a mechanism to &quot;decRefCount&quot; Mesh and Material
    //            if we need to do eager clean up
    final private D3DMesh mesh;
    private D3DPhongMaterial material;

    private D3DMeshView(D3DContext context, long nativeHandle, D3DMesh mesh,
            Disposer.Record disposerRecord) {
        super(disposerRecord);
        this.context = context;
        this.mesh = mesh;
        this.nativeHandle = nativeHandle;
        count++;
    }

    static D3DMeshView create(D3DContext context, D3DMesh mesh) {
        long nativeHandle = context.createD3DMeshView(mesh.getNativeHandle());
        return new D3DMeshView(context, nativeHandle, mesh, new D3DMeshViewDisposerRecord(context, nativeHandle));
    }

    @Override
    public void setCullingMode(int cullingMode) {
        context.setCullingMode(nativeHandle, cullingMode);
    }

    @Override
    public void setMaterial(Material material) {
        context.setMaterial(nativeHandle,
                ((D3DPhongMaterial) material).getNativeHandle());
        this.material = (D3DPhongMaterial) material;
    }

    @Override
    public void setWireframe(boolean wireframe) {
        context.setWireframe(nativeHandle, wireframe);
    }

    @Override
    public void setAmbientLight(float r, float g, float b) {
        context.setAmbientLight(nativeHandle, r, g, b);
    }

    @Override
    public void setPointLight(int index, float x, float y, float z, float r, float g, float b, float w) {
        // NOTE: We only support up to 3 point lights at the present
        if (index &gt;= 0 &amp;&amp; index &lt;= 2) {
            context.setPointLight(nativeHandle, index, x, y, z, r, g, b, w);
        }
    }

    @Override
    public void render(Graphics g) {
        material.lockTextureMaps();
        context.renderMeshView(nativeHandle, g);
        material.unlockTextureMaps();
    }

    @Override
    public void dispose() {
        // TODO: 3D - Need a mechanism to &quot;decRefCount&quot; Mesh and Material
        material = null;
        disposerRecord.dispose();
        count--;
    }

    public int getCount() {
        return count;
    }

    static class D3DMeshViewDisposerRecord implements Disposer.Record {

        private final D3DContext context;
        private long nativeHandle;

        D3DMeshViewDisposerRecord(D3DContext context, long nativeHandle) {
            this.context = context;
            this.nativeHandle = nativeHandle;
<A NAME="23"></A>        }

        void traceDispose() {
        <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#23',2,'match52-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

        public void dispose() {
            if (nativeHandle != 0L) {
                traceDispose();
                context.releaseD3DMeshView(nativeHandle);
                nativeHandle = 0L;
            }</B></FONT>
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/impl/BaseResourcePool.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.impl;

import java.lang.ref.WeakReference;

/**
 * The base implementation of the {@link ResourcePool} interface, providing
 * bookkeeping for the {@link managed()} method and support for sharing
 * resources amongst multiple pools.
 * @param &lt;T&gt; the type of objects stored in this resource pool
 */
public abstract class BaseResourcePool&lt;T&gt; implements ResourcePool&lt;T&gt; {
    // Number of calls to freeDisposalRequestedAndCheckResources() before we
    // consider a resource to have not been used in a hypothetical &quot;FOREVER&quot;.
    private static final int FOREVER = 1024;
    // Number of calls to freeDisposalRequestedAndCheckResources() before we
    // consider a resource to have not been used &quot;RECENTLY&quot;, with different
    // cutoffs for useful and unuseful textures.
    private static final int RECENTLY_USEFUL = 100;
    private static final int RECENT = 10;

    static interface Predicate {
        boolean test(ManagedResource&lt;?&gt; mr);
    }

    private static final Predicate stageTesters[];
    private static final String    stageReasons[];
    static {
        stageTesters = new Predicate[6];
        stageReasons = new String[6];
        stageTesters[0] = (mr) -&gt; { return !mr.isInteresting() &amp;&amp; mr.getAge() &gt; FOREVER; };
        stageReasons[0] = &quot;Pruning unuseful older than &quot;+FOREVER;
        stageTesters[1] = (mr) -&gt; { return !mr.isInteresting() &amp;&amp; mr.getAge() &gt; FOREVER/2; };
        stageReasons[1] = &quot;Pruning unuseful older than &quot;+FOREVER/2;
        stageTesters[2] = (mr) -&gt; { return !mr.isInteresting() &amp;&amp; mr.getAge() &gt; RECENT; };
        stageReasons[2] = &quot;Pruning unuseful older than &quot;+RECENT;
        stageTesters[3] = (mr) -&gt; { return mr.getAge() &gt; FOREVER; };
        stageReasons[3] = &quot;Pruning all older than &quot;+FOREVER;
        stageTesters[4] = (mr) -&gt; { return mr.getAge() &gt; FOREVER/2; };
        stageReasons[4] = &quot;Pruning all older than &quot;+FOREVER/2;
        stageTesters[5] = (mr) -&gt; { return mr.getAge() &gt; RECENTLY_USEFUL; };
        stageReasons[5] = &quot;Pruning all older than &quot;+RECENTLY_USEFUL;
    }

    long managedSize;
    final long origTarget;
    long curTarget;
    final long maxSize;
    final ResourcePool&lt;T&gt; sharedParent;
    private final Thread managerThread;
    private WeakLinkedList&lt;T&gt; resourceHead;

    protected BaseResourcePool(long target, long max) {
        this(null, target, max);
<A NAME="13"></A>    }

    protected BaseResourcePool(ResourcePool&lt;T&gt; parent) {
        <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#13',2,'match52-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>this(parent, parent.target(), parent.max());
    }

    protected BaseResourcePool(ResourcePool&lt;T&gt; parent, long target, long max) {
        t</B></FONT>his.resourceHead = new WeakLinkedList&lt;&gt;();
        this.sharedParent = parent;
        this.origTarget = this.curTarget = target;
        this.maxSize = ((parent == null)
                        ? max
                        : Math.min(parent.max(), max));
        managerThread = Thread.currentThread();
    }

    /**
     * Clean up the resources in the indicated pool using a standard
     * algorithm until at least the specified amount of resource units
     * have been reclaimed.
     * The standard algorithm uses the following stages until it obtains
     * enough room in the pool:
     * &lt;ol&gt;
     * &lt;li&gt; Prune any resources which are already free, but have not been
     *      accounted for yet.
     * &lt;li&gt; Go through a few passes cleaning out any non-interesting resources
     *      that have not been used in a long time with decreasing cutoff
     *      limits for the maximum age of the resource.
     * &lt;li&gt; Go through more passes cleaning out even interesting resources that
     *      have not been used in a fairly long time with decreasing age limits.
     * &lt;li&gt; Attempt to grow the target to accommodate the new request.
     * &lt;li&gt; Finally, prune any resources that are not currently in the process
     *      of being used (i.e. locked or permanent).
     * &lt;/ol&gt;
     *
     * @param needed
     * @return boolean indicating if the requested space is now available
     */
    public boolean cleanup(long needed) {
        if (used() + needed &lt;= target()) return true;
        long wasused = used();
        long wanted = target() / 16;
        if (wanted &lt; needed) {
            wanted = needed;
        }
        if (PrismSettings.poolDebug) {
            System.err.printf(&quot;Need %,d (hoping for %,d) from pool: %s\n&quot;, needed, wanted, this);
            printSummary(false);
        }

        try {
            // First cleanup pass is just for previously freed resources that
            // are in the Disposer queue already or were manually freed by
            // mechanisms and are still in the accounting list.
            // The pruner predicate choose no additional resources to free.
            Disposer.cleanUp();
            if (PrismSettings.poolDebug) System.err.println(&quot;Pruning obsolete in pool: &quot;+this);
            cleanup((mr) -&gt; { return false; });
            if (used() + wanted &lt;= target()) return true;

            // Multiple stages of pruning useful and unuseful resources of
            // various ages as determined by the static initializer above.
            for (int stage = 0; stage &lt; stageTesters.length; stage++) {
                if (PrismSettings.poolDebug) {
                    System.err.println(stageReasons[stage]+&quot; in pool: &quot;+this);
                }
                cleanup(stageTesters[stage]);
                if (used() + wanted &lt;= target()) return true;
            }

            // Now look to grow the target if we can satisfy this allocation at
            // less than max().
            long rem = max() - used();
            if (wanted &gt; rem) {
                wanted = needed;
            }
            if (wanted &lt;= rem) {
                long grow = (max() - origTarget()) / 32;
                if (grow &lt; wanted) {
                    grow = wanted;
                } else if (grow &gt; rem) {
                    grow = rem;
                }
                setTarget(used() + grow);
                if (PrismSettings.poolDebug || PrismSettings.verbose) {
                    System.err.printf(&quot;Growing pool %s target to %,d\n&quot;, this, target());
                }
                return true;
            }

            // Finally, look to the garbage collector to dislodge some unreferenced
            // resources that we can free with a very aggressive age set of (0, 0)
            // which will target all unlocked/non-permanent textures.
            // Two tries, one with just a gc(), and a desperate one with a sleep...
            for (int i = 0; i &lt; 2; i++) {
                pruneLastChance(i &gt; 0);
                if (used() + needed &lt;= max()) {
                    if (used() + needed &gt; target()) {
                        setTarget(used() + needed);
                        if (PrismSettings.poolDebug || PrismSettings.verbose) {
                            System.err.printf(&quot;Growing pool %s target to %,d\n&quot;, this, target());
                        }
                    }
                    return true;
                }
            }

            // That was our last gasp, we either succeeded in making room under
            // the max() amount or we failed and need to return false.
            return false;
        } finally {
            if (PrismSettings.poolDebug) {
                System.err.printf(&quot;cleaned up %,d from pool: %s\n&quot;, wasused - used(), this);
                printSummary(false);
                System.err.println();
            }
        }
    }

    private void pruneLastChance(boolean desperate) {
        System.gc();
        if (desperate) {
            // Our alternative is to return false here and cause an allocation
            // failure which is usually bad news for any SG, so it is worth
            // sleeping on the second time around to give one last GC some time
            // to find a dead resource that was dropped on the floor...
            try { Thread.sleep(20); }
            catch (InterruptedException e) { }
        }
        Disposer.cleanUp();
        if (PrismSettings.poolDebug) {
            if (desperate) {
                System.err.print(&quot;Last chance pruning&quot;);
            } else {
                System.err.print(&quot;Pruning everything&quot;);
            }
            System.err.println(&quot; in pool: &quot;+this);
        }
        cleanup((mr) -&gt; { return true; });
    }

    private void cleanup(Predicate predicate) {
        WeakLinkedList&lt;T&gt; prev = resourceHead;
        WeakLinkedList&lt;T&gt; cur = prev.next;
        while (cur != null) {
            ManagedResource&lt;T&gt; mr = cur.getResource();
            if (ManagedResource._isgone(mr)) {
                if (PrismSettings.poolDebug) showLink(&quot;unlinking&quot;, cur, false);
                recordFree(cur.size);
                cur = cur.next;
                prev.next = cur;
            } else if (!mr.isPermanent() &amp;&amp;
                       !mr.isLocked() &amp;&amp;
                       predicate.test(mr))
            {
                if (PrismSettings.poolDebug) showLink(&quot;pruning&quot;, cur, true);
                mr.free();
                mr.resource = null;
                recordFree(cur.size);
                cur = cur.next;
                prev.next = cur;
            } else {
                prev = cur;
                cur = cur.next;
            }
        }
    }

    static void showLink(String label, WeakLinkedList&lt;?&gt; cur, boolean showAge) {
        ManagedResource&lt;?&gt; mr = cur.getResource();
        System.err.printf(&quot;%s: %s (size=%,d)&quot;, label, mr, cur.size);
        if (mr != null) {
            if (showAge) {
                System.err.printf(&quot; (age=%d)&quot;, mr.getAge());
            }
            if (mr.isPermanent())   System.err.print(&quot; perm&quot;);
            if (mr.isLocked())      System.err.print(&quot; lock&quot;);
            if (mr.isInteresting()) System.err.print(&quot; int&quot;);
        }
        System.err.println();
    }

    /**
     * Check that all resources are in the correct state for an idle condition
     * and free any resources which were disposed from a non-resource thread.
     * This method must be called on a thread that is appropriate for disposing
     * and managing resources for the resource pools.
     * The boolean {@code forgiveStaleLocks} parameter is used to indicate that
     * an exceptional condition occurred which caused the caller to abort a
     * cycle of resource usage, potentially with outstanding resource locks.
     * This method will unlock all non-permanent resources that have outstanding
     * locks if {@code forgiveStaleLocks} is {@code true}, or it will print out
     * a warning and a resource summary if that parameter is {@code false}.
     *
     * @param forgiveStaleLocks {@code true} if the caller wishes to forgive
     *         and unlock all outstanding locks on non-permanent resources
     */
    @Override
    public void freeDisposalRequestedAndCheckResources(boolean forgiveStaleLocks) {
        boolean anyLockedResources = false;
        WeakLinkedList&lt;T&gt; prev = resourceHead;
        WeakLinkedList&lt;T&gt; cur = prev.next;
        while (cur != null) {
            ManagedResource&lt;?&gt; mr = cur.getResource();
            if (ManagedResource._isgone(mr)) {
                recordFree(cur.size);
                cur = cur.next;
                prev.next = cur;
            } else {
                if (!mr.isPermanent()) {
                    if (mr.isLocked() &amp;&amp; !mr.wasMismatched()) {
                        if (forgiveStaleLocks) {
                            mr.unlockall();
                        } else {
                            mr.setMismatched();
                            anyLockedResources = true;
                        }
                    }
                    mr.bumpAge(FOREVER);
                }
                prev = cur;
                cur = cur.next;
            }
        }

        if (PrismSettings.poolStats || anyLockedResources) {
            if (anyLockedResources) {
                System.err.println(&quot;Outstanding resource locks detected:&quot;);
            }
            printSummary(true);
            System.err.println();
        }
    }

    static String commas(long v) {
        return String.format(&quot;%,d&quot;, v);
    }

    public void printSummary(boolean printlocksources) {
        int numgone = 0;
        int numlocked = 0;
        int numpermanent = 0;
        int numinteresting = 0;
        int nummismatched = 0;
        int numancient = 0;
        long total_age = 0;
        int total = 0;
        boolean trackLockSources = ManagedResource.trackLockSources;

        double percentUsed = used() * 100.0 / max();
        double percentTarget = target() * 100.0 / max();
        System.err.printf(&quot;%s: %,d used (%.1f%%), %,d target (%.1f%%), %,d max\n&quot;,
                          this, used(), percentUsed,
                          target(), percentTarget,
                          max());

        for (WeakLinkedList&lt;T&gt; cur = resourceHead.next; cur != null; cur = cur.next) {
            ManagedResource&lt;T&gt; mr = cur.getResource();
            total++;
            if (mr == null || !mr.isValid() || mr.isDisposalRequested()) {
                numgone++;
            } else {
                int a = mr.getAge();
                total_age += a;
                if (a &gt;= FOREVER) {
                    numancient++;
                }
                if (mr.wasMismatched()) {
                    nummismatched++;
                }
                if (mr.isPermanent()) {
                    numpermanent++;
                } else if (mr.isLocked()) {
                    numlocked++;
                    if (trackLockSources &amp;&amp; printlocksources) {
                        for (Throwable th : mr.lockedFrom) {
                            th.printStackTrace(System.err);
                        }
                        mr.lockedFrom.clear();
                    }
                }
                if (mr.isInteresting()) {
                    numinteresting++;
                }
            }
        }

        double avg_age = ((double) total_age) / total;
        System.err.println(total+&quot; total resources being managed&quot;);
        System.err.printf(&quot;average resource age is %.1f frames\n&quot;, avg_age);
        printpoolpercent(numancient, total, &quot;at maximum supported age&quot;);
        printpoolpercent(numpermanent, total, &quot;marked permanent&quot;);
        printpoolpercent(nummismatched, total, &quot;have had mismatched locks&quot;);
        printpoolpercent(numlocked, total, &quot;locked&quot;);
        printpoolpercent(numinteresting, total, &quot;contain interesting data&quot;);
        printpoolpercent(numgone, total, &quot;disappeared&quot;);
    }

    private static void printpoolpercent(int stat, int total, String desc) {
        double percent = stat * 100.0 / total;
        System.err.printf(&quot;%,d resources %s (%.1f%%)\n&quot;, stat, desc, percent);
    }

    @Override
    public boolean isManagerThread() {
        return Thread.currentThread() == managerThread;
    }

    @Override
    public final long managed() {
        return managedSize;
    }

    @Override
    public long used() {
        if (sharedParent != null) {
            return sharedParent.used();
        }
        return managedSize;
    }

    @Override
    public final long max() {
        return maxSize;
    }

    @Override
    public final long origTarget() {
        return origTarget;
    }

    @Override
    public final long target() {
        return curTarget;
    }

    @Override
    public final void setTarget(long newTarget) {
        if (newTarget &gt; maxSize) {
            throw new IllegalArgumentException(&quot;New target &quot;+newTarget+
                                               &quot; larger than max &quot;+maxSize);
        }
        if (newTarget &lt; origTarget) {
            throw new IllegalArgumentException(&quot;New target &quot;+newTarget+
                                               &quot; smaller than initial target &quot;+origTarget);
        }
        curTarget = newTarget;
    }

    @Override
    public boolean prepareForAllocation(long size) {
        return cleanup(size);
    }

    @Override
    public final void recordAllocated(long size) {
        managedSize += size;
    }

    @Override
    public final void resourceManaged(ManagedResource&lt;T&gt; mr) {
        long size = size(mr.resource);
        resourceHead.insert(mr, size);
        recordAllocated(size);
    }

    @Override
    public final void resourceFreed(ManagedResource&lt;T&gt; freed) {
        WeakLinkedList&lt;T&gt; prev = resourceHead;
        WeakLinkedList&lt;T&gt; cur = prev.next;
        while (cur != null) {
            ManagedResource&lt;T&gt; res = cur.getResource();
            if (res == null || res == freed) {
                recordFree(cur.size);
                cur = cur.next;
                prev.next = cur;
                if (res == freed) {
                    return;
                }
            } else {
                prev = cur;
                cur = cur.next;
            }
        }
        throw new IllegalStateException(&quot;unmanaged resource freed from pool &quot;+this);
    }

    @Override
    public final void recordFree(long size) {
        managedSize -= size;
        if (managedSize &lt; 0) {
            throw new IllegalStateException(&quot;Negative resource amount&quot;);
        }
    }

    static class WeakLinkedList&lt;T&gt; {
        final WeakReference&lt;ManagedResource&lt;T&gt;&gt; theResourceRef;
        final long size;
        WeakLinkedList&lt;T&gt; next;

        WeakLinkedList() {
            this.theResourceRef = null;
            this.size = 0L;
        }

        WeakLinkedList(ManagedResource&lt;T&gt; mresource, long size, WeakLinkedList&lt;T&gt; next) {
            this.theResourceRef = new WeakReference&lt;&gt;(mresource);
            this.size = size;
            this.next = next;
        }

        void insert(ManagedResource&lt;T&gt; mresource, long size) {
            this.next = new WeakLinkedList&lt;&gt;(mresource, size, next);
        }

        ManagedResource&lt;T&gt; getResource() {
            return theResourceRef.get();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/scenario/effect/impl/prism/PrEffectHelper.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.scenario.effect.impl.prism;

import com.sun.glass.ui.Screen;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.Point2D;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGPerspectiveCamera;
import com.sun.prism.Graphics;
import com.sun.prism.RenderTarget;
import com.sun.prism.ResourceFactory;
import com.sun.prism.Texture;
import com.sun.scenario.effect.Effect;
import com.sun.scenario.effect.FilterContext;
import com.sun.scenario.effect.ImageData;
import com.sun.scenario.effect.impl.EffectPeer;
import com.sun.scenario.effect.impl.ImagePool;

public class PrEffectHelper {

    /**
     * Applies the given filter effect to the series of inputs and then renders
     * the result to the provided {@code Graphics} at the specified
     * location.
     * This method is similar to the following pseudo-code:
     * &lt;pre&gt;
     *     g.drawTexture(effect.filter(g.getTransform()), x, y);
     * &lt;/pre&gt;
     * except that it is likely to be more efficient (and correct).
     *
     * @param effect the effect to be rendered
     * @param g the {@code Graphics} to which the {@code Effect} will be
     *          rendered
     * @param x the x location of the filtered result
     * @param y the y location of the filtered result
     * @param defaultInput the default input {@code Effect} to be used if
     *                     any of the inputs for any of the effects in the
     *                     chain are unspecified (i.e. {@code null}).
     */
    public static void render(Effect effect,
                              Graphics g, float x, float y,
                              Effect defaultInput)
    {
        BaseTransform transform;
        Rectangle rclip = getGraphicsClipNoClone(g);
        BaseTransform origtx = g.getTransformNoClone().copy();
        BaseTransform rendertx;
        if (origtx.is2D()) {
            // process the effect using the current 2D transform, and then
            // render the resulting image in device space (i.e., with identity)
            if (x != 0f || y != 0f || !origtx.isIdentity()) {
                transform = new Affine2D(origtx);
                ((Affine2D) transform).translate(x, y);
            } else {
                transform = BaseTransform.IDENTITY_TRANSFORM;
            }
            g.setTransform(null);
            rendertx = null;
        } else {
            // process the effect with an identity (2D) transform, and then
            // render the resulting image using the current (3D) modelview
            // and/or projection transform
            // RT-27555
            // TODO: this will not work if the effect is applied to a Group
            // that has children with 3D transforms (relative to the Group),
            // but at least it's good enough for simple effects applied to
            // leaf nodes (e.g. applying a Reflection to a leaf ImageView node)
            double scalex = Math.hypot(origtx.getMxx(), origtx.getMyx());
            double scaley = Math.hypot(origtx.getMxy(), origtx.getMyy());
            double scale = Math.max(scalex, scaley);
            if (scale &lt;= 1.0) {
                transform = BaseTransform.IDENTITY_TRANSFORM;
                rendertx = origtx;
            } else {
                transform = BaseTransform.getScaleInstance(scale, scale);
                rendertx = new Affine3D(origtx);
                scale = 1.0 / scale;
                ((Affine3D) rendertx).scale(scale, scale);
            }
            NGCamera cam = g.getCameraNoClone();
            BaseTransform inv;
            try {
                inv = rendertx.createInverse();
            } catch (NoninvertibleTransformException e) {
                return;
            }
            PickRay ray = new PickRay();
            Vec3d tmpvec = new Vec3d();
            // See FilterEffect.untransformClip for a description of
            // why we round in by half a pixel here.
            float x1 = rclip.x + 0.5f;
            float y1 = rclip.y + 0.5f;
            float x2 = rclip.x + rclip.width - 0.5f;
            float y2 = rclip.y + rclip.height - 0.5f;
            double rtw = g.getRenderTarget().getContentWidth();
            double rth = g.getRenderTarget().getContentHeight();
            Point2D cul = project(x1, y1, rtw, rth, cam, inv, ray, tmpvec, null);
            Point2D cur = project(x2, y1, rtw, rth, cam, inv, ray, tmpvec, null);
            Point2D cll = project(x1, y2, rtw, rth, cam, inv, ray, tmpvec, null);
            Point2D clr = project(x2, y2, rtw, rth, cam, inv, ray, tmpvec, null);
            rclip = clipbounds(cul, cur, cll, clr);
        }

        Screen screen = g.getAssociatedScreen();
        FilterContext fctx;
        // RT-27555
        if (screen == null) {
            ResourceFactory factory = g.getResourceFactory();
            fctx = PrFilterContext.getPrinterContext(factory);
        } else {
            fctx = PrFilterContext.getInstance(screen);
        }
        // TODO: Pass the camera down so that nodes can render with it
        // for proper perspective below this level.
        PrRenderInfo prinfo;
        if (rendertx != null) {
            // Whatever results are produced will have to be post-transformed
            // so attempts at direct rendering would use the wrong transform.
            prinfo = null;
        } else if (g.isDepthBuffer() &amp;&amp; g.isDepthTest()) {
            // Some of the multi-step operations may produce both flat image
            // results that would not track the actual Z depth of any direct
            // Node rendering so we must disable direct rendering to avoid
            // depth buffer conflicts.
            prinfo = null;
        } else {
            // If none of the above conditions apply, then the PrRenderInfo
            // can represent all information necessary to directly render
            // any ImageData or Node to the destination.
            prinfo = new PrRenderInfo(g);
        }
        boolean valid;
        ImagePool.numEffects++;

        do {
            ImageData res = effect.filter(fctx, transform, rclip, prinfo, defaultInput);
            if (res == null) return;
            if (valid = res.validate(fctx)) {
                Rectangle r = res.getUntransformedBounds();
                // the actual image may be much larger than the region
                // of interest (&quot;r&quot;), so to improve performance we render
                // only that subregion here
                Texture tex = ((PrTexture)res.getUntransformedImage()).getTextureObject();
                g.setTransform(rendertx);
                g.transform(res.getTransform());
                g.drawTexture(tex, r.x, r.y, r.width, r.height);
            }
            res.unref();
        } while (!valid);
        g.setTransform(origtx);
    }

    static Point2D project(float x, float y, double vw, double vh,
                           NGCamera cam, BaseTransform inv,
                           PickRay tmpray, Vec3d tmpvec, Point2D ret)
    {
        // Calculations in cam.computePickRay are done relative to the
        // view w,h in the camera which may not match our actual view
        // dimensions so we scale them to that rectangle, compute the
        // pick rays, then scale the back to the actual device space before
        // intersecting with our chosen rendering plane.
        double xscale = cam.getViewWidth() / vw;
        double yscale = cam.getViewHeight() / vh;
        x *= xscale;
        y *= yscale;
        tmpray = cam.computePickRay(x, y, tmpray);
        unscale(tmpray.getOriginNoClone(), xscale, yscale);
        unscale(tmpray.getDirectionNoClone(), xscale, yscale);
        return tmpray.projectToZeroPlane(inv, cam instanceof NGPerspectiveCamera,
                                         tmpvec, ret);
    }
    private static void unscale(Vec3d v, double sx, double sy) {
        v.x /= sx;
        v.y /= sy;
    }

    static Rectangle clipbounds(Point2D cul, Point2D cur, Point2D cll, Point2D clr) {
        // Note that 3D perspective transforms frequently deal with infinite
        // values as a plane is rotated towards an end-on view from the eye.
        // The standard ways of getting the bounds of 4 float points tend to
        // ignore overflow, but we would frequently see trouble as objects are
        // flipped over if we didn't have the tests for integer overflow near
        // the bottom of this method.  When those conditions occur it usually
        // means we can see down an arbitrary distance (perhaps to the horizon)
        // on the plane of the node being rendered so we need to render it
        // with no clip to make sure we get all the data for the effect.
        if (cul != null &amp;&amp; cur != null &amp;&amp; cll != null &amp;&amp; clr != null) {
            double x1, y1, x2, y2;
            if (cul.x &lt; cur.x) {
                x1 = cul.x; x2 = cur.x;
            } else {
                x1 = cur.x; x2 = cul.x;
            }
<A NAME="9"></A>            if (cul.y &lt; cur.y) {
                y1 = cul.y; y2 = cur.y;
            } else {
                <FONT color="#f88017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#9',2,'match52-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>y1 = cur.y; y2 = cul.y;
            }
            if (cll.x &lt; clr.x) {
                x1 = Math.min(x1, cll.x); x</B></FONT>2 = Math.max(x2, clr.x);
            } else {
                x1 = Math.min(x1, clr.x); x2 = Math.max(x2, cll.x);
            }
            if (cll.y &lt; clr.y) {
                y1 = Math.min(y1, cll.y); y2 = Math.max(y2, clr.y);
            } else {
                y1 = Math.min(y1, clr.y); y2 = Math.max(y2, cll.y);
            }
            // See FilterEffect.untransformClip for a description of
            // why we round out by half a pixel here.
            x1 = Math.floor(x1-0.5f);
            y1 = Math.floor(y1-0.5f);
            x2 = Math.ceil(x2+0.5f)-x1;
            y2 = Math.ceil(y2+0.5f)-y1;
            int x = (int) x1;
            int y = (int) y1;
            int w = (int) x2;
            int h = (int) y2;
            if (x == x1 &amp;&amp; y == y1 &amp;&amp; w == x2 &amp;&amp; h == y2) {
                // Return a valid rectangle only if we do not overflow,
                // otherwise let the method return a null below for
                // unclipped operation.
                return new Rectangle(x, y, w, h);
            }
        }
        return null;
    }

    public static Rectangle getGraphicsClipNoClone(Graphics g) {
        Rectangle rclip = g.getClipRectNoClone();
        if (rclip == null) {
            RenderTarget rt = g.getRenderTarget();
            rclip = new Rectangle(rt.getContentWidth(), rt.getContentHeight());
        }
        return rclip;
    }

    public static void renderImageData(Graphics gdst,
                                       ImageData srcData,
                                       Rectangle dstBounds)
    {
        int w = dstBounds.width;
        int h = dstBounds.height;
        PrDrawable src = (PrDrawable) srcData.getUntransformedImage();
        BaseTransform srcTx = srcData.getTransform();
        Rectangle srcBounds = srcData.getUntransformedBounds();
        float dx1 = 0f;
        float dy1 = 0f;
        float dx2 = dx1 + w;
        float dy2 = dy1 + h;
        if (srcTx.isTranslateOrIdentity()) {
            float tx = (float) srcTx.getMxt();
            float ty = (float) srcTx.getMyt();
            float sx1 = dstBounds.x - (srcBounds.x + tx);
            float sy1 = dstBounds.y - (srcBounds.y + ty);
            float sx2 = sx1 + w;
            float sy2 = sy1 + h;
            gdst.drawTexture(src.getTextureObject(),
                             dx1, dy1, dx2, dy2,
                             sx1, sy1, sx2, sy2);
        } else {
            float[] srcRect = new float[8];
            int srcCoords =
                EffectPeer.getTextureCoordinates(srcRect,
                                                 srcBounds.x, srcBounds.y,
                                                 src.getPhysicalWidth(),
                                                 src.getPhysicalHeight(),
                                                 dstBounds, srcTx);
            if (srcCoords &lt; 8) {
                gdst.drawTextureRaw(src.getTextureObject(),
                                    dx1, dy1, dx2, dy2,
                                    srcRect[0], srcRect[1],
                                    srcRect[2], srcRect[3]);
            } else {
                gdst.drawMappedTextureRaw(src.getTextureObject(),
                                          dx1, dy1, dx2, dy2,
                                          srcRect[0], srcRect[1],
                                          srcRect[4], srcRect[5],
                                          srcRect[6], srcRect[7],
                                          srcRect[2], srcRect[3]);
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/scenario/effect/impl/prism/PrRenderer.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.scenario.effect.impl.prism;

import java.lang.reflect.Method;
import java.util.HashSet;
import java.util.Set;
import com.sun.glass.ui.Screen;
import com.sun.prism.GraphicsPipeline;
import com.sun.prism.GraphicsPipeline.ShaderModel;
import com.sun.prism.RTTexture;
import com.sun.scenario.effect.FilterContext;
import com.sun.scenario.effect.impl.Renderer;

public abstract class PrRenderer extends Renderer {

    /**
     * Maintain a list of peers that are implemented using Prism, so that
<A NAME="24"></A>     * we can do a fast check to see whether the given peer name is an
     * intrinsic one instead of relying on reflection to do the check.
     */
    <FONT color="#ada96e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#24',2,'match52-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private static final Set&lt;String&gt; intrinsicPeerNames;
    static {
        intrinsicPeerNames = new HashSet&lt;String&gt;(4);
        intrinsicPeerNames.add(&quot;Crop&quot;);
        intrinsicPeerNames.add(&quot;Flood&quot;);
        intrinsicPeerNames.add(&quot;Merge&quot;);
        intrinsicPeerNames.add(&quot;Reflection&quot;);
    }</B></FONT>

    /**
     * Private constructor to prevent instantiation.
     */
    protected PrRenderer() {
    }

    public abstract PrDrawable createDrawable(RTTexture rtt);

    public static Renderer createRenderer(FilterContext fctx) {
        Object ref = fctx.getReferent();
        if (!(ref instanceof Screen)) {
            return null;
        }
        boolean isHW;
        if (((PrFilterContext) fctx).isForceSoftware()) {
            isHW = false;
        } else {
            GraphicsPipeline pipe = GraphicsPipeline.getPipeline();
            if (pipe == null) {
                return null;
            }
            isHW = pipe.supportsShaderModel(ShaderModel.SM3);
        }
        return createRenderer(fctx, isHW);
    }

    private static PrRenderer createRenderer(FilterContext fctx, boolean isHW) {
        String klassName = isHW ?
            Renderer.rootPkg + &quot;.impl.prism.ps.PPSRenderer&quot; :
            Renderer.rootPkg + &quot;.impl.prism.sw.PSWRenderer&quot;;
        try {
            Class klass = Class.forName(klassName);
            Method m = klass.getMethod(&quot;createRenderer&quot;, new Class[] { FilterContext.class });
            return (PrRenderer)m.invoke(null, new Object[] { fctx });
        } catch (Throwable e) {}
        return null;
    }

    public static boolean isIntrinsicPeer(String name) {
        return intrinsicPeerNames.contains(name);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/Node.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene;


import com.sun.javafx.geometry.BoundsUtils;
import javafx.application.Platform;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.binding.BooleanExpression;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.BooleanPropertyBase;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyBooleanPropertyBase;
import javafx.beans.property.ReadOnlyBooleanWrapper;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectPropertyBase;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.property.StringPropertyBase;
import javafx.beans.value.ChangeListener;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener.Change;
import javafx.collections.ObservableList;
import javafx.collections.ObservableMap;
import javafx.collections.ObservableSet;
import javafx.css.CssMetaData;
import javafx.css.ParsedValue;
import javafx.css.PseudoClass;
import javafx.css.StyleConverter;
import javafx.css.Styleable;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.event.Event;
import javafx.event.EventDispatchChain;
import javafx.event.EventDispatcher;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.event.EventType;
import javafx.geometry.BoundingBox;
import javafx.geometry.Bounds;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Orientation;
import javafx.geometry.Point2D;
import javafx.geometry.Point3D;
import javafx.geometry.Rectangle2D;
import javafx.scene.effect.BlendMode;
import javafx.scene.effect.Effect;
import javafx.scene.image.WritableImage;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.DragEvent;
import javafx.scene.input.Dragboard;
import javafx.scene.input.InputEvent;
import javafx.scene.input.InputMethodEvent;
import javafx.scene.input.InputMethodRequests;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.PickResult;
import javafx.scene.input.RotateEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.input.SwipeEvent;
import javafx.scene.input.TouchEvent;
import javafx.scene.input.TransferMode;
import javafx.scene.input.ZoomEvent;
import javafx.scene.text.Font;
import javafx.scene.transform.Rotate;
import javafx.scene.transform.Transform;
import javafx.stage.Window;
import javafx.util.Callback;
import java.security.AccessControlContext;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.sun.glass.ui.Accessible;
import com.sun.glass.ui.Application;
import com.sun.javafx.util.Logging;
import com.sun.javafx.util.TempState;
import com.sun.javafx.util.Utils;
import com.sun.javafx.beans.IDProperty;
import com.sun.javafx.beans.event.AbstractNotifyListener;
import com.sun.javafx.binding.ExpressionHelper;
import com.sun.javafx.collections.TrackableObservableList;
import com.sun.javafx.collections.UnmodifiableListSet;
import com.sun.javafx.css.PseudoClassState;
import javafx.css.Selector;
import javafx.css.Style;
import javafx.css.converter.BooleanConverter;
import javafx.css.converter.CursorConverter;
import javafx.css.converter.EffectConverter;
import javafx.css.converter.EnumConverter;
import javafx.css.converter.SizeConverter;
import com.sun.javafx.effect.EffectDirtyBits;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.BoxBounds;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.javafx.perf.PerformanceTracker;
import com.sun.javafx.scene.BoundsAccessor;
import com.sun.javafx.scene.CameraHelper;
import com.sun.javafx.scene.CssFlags;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.EventHandlerProperties;
import com.sun.javafx.scene.LayoutFlags;
import com.sun.javafx.scene.NodeEventDispatcher;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.SceneHelper;
import com.sun.javafx.scene.SceneUtils;
import com.sun.javafx.scene.input.PickResultChooser;
import com.sun.javafx.scene.transform.TransformHelper;
import com.sun.javafx.scene.transform.TransformUtils;
import com.sun.javafx.scene.traversal.Direction;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.tk.Toolkit;
import com.sun.prism.impl.PrismSettings;
import com.sun.scenario.effect.EffectHelper;

import javafx.scene.shape.Shape3D;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;

/**
 * Base class for scene graph nodes. A scene graph is a set of tree data structures
 * where every item has zero or one parent, and each item is either
 * a &quot;leaf&quot; with zero sub-items or a &quot;branch&quot; with zero or more sub-items.
 * &lt;p&gt;
 * Each item in the scene graph is called a {@code Node}. Branch nodes are
 * of type {@link Parent}, whose concrete subclasses are {@link Group},
 * {@link javafx.scene.layout.Region}, and {@link javafx.scene.control.Control},
 * or subclasses thereof.
 * &lt;p&gt;
 * Leaf nodes are classes such as
 * {@link javafx.scene.shape.Rectangle}, {@link javafx.scene.text.Text},
 * {@link javafx.scene.image.ImageView}, {@link javafx.scene.media.MediaView},
 * or other such leaf classes which cannot have children. Only a single node within
 * each scene graph tree will have no parent, which is referred to as the &quot;root&quot; node.
 * &lt;p&gt;
 * There may be several trees in the scene graph. Some trees may be part of
 * a {@link Scene}, in which case they are eligible to be displayed.
 * Other trees might not be part of any {@link Scene}.
 * &lt;p&gt;
 * A node may occur at most once anywhere in the scene graph. Specifically,
 * a node must appear no more than once in all of the following:
 * as the root node of a {@link Scene},
 * the children ObservableList of a {@link Parent},
 * or as the clip of a {@link Node}.
 * &lt;p&gt;
 * The scene graph must not have cycles. A cycle would exist if a node is
 * an ancestor of itself in the tree, considering the {@link Group} content
 * ObservableList, {@link Parent} children ObservableList, and {@link Node} clip relationships
 * mentioned above.
 * &lt;p&gt;
 * If a program adds a child node to a Parent (including Group, Region, etc)
 * and that node is already a child of a different Parent or the root of a Scene,
 * the node is automatically (and silently) removed from its former parent.
 * If a program attempts to modify the scene graph in any other way that violates
 * the above rules, an exception is thrown, the modification attempt is ignored
 * and the scene graph is restored to its previous state.
 * &lt;p&gt;
 * It is possible to rearrange the structure of the scene graph, for
 * example, to move a subtree from one location in the scene graph to
 * another. In order to do this, one would normally remove the subtree from
 * its old location before inserting it at the new location. However, the
 * subtree will be automatically removed as described above if the application
 * doesn't explicitly remove it.
 * &lt;p&gt;
 * Node objects may be constructed and modified on any thread as long they are
 * not yet attached to a {@link Scene} in a {@link Window} that is
 * {@link Window#isShowing showing}.
 * An application must attach nodes to such a Scene or modify them on the JavaFX
 * Application Thread.
 *
 * &lt;p&gt;
 * The JavaFX Application Thread is created as part of the startup process for
 * the JavaFX runtime. See the {@link javafx.application.Application} class and
 * the {@link Platform#startup(Runnable)} method for more information.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * An application should not extend the Node class directly. Doing so may lead to
 * an UnsupportedOperationException being thrown.
 * &lt;/p&gt;
 *
 * &lt;h3&gt;String ID&lt;/h3&gt;
 * &lt;p&gt;
 * Each node in the scene graph can be given a unique {@link #idProperty id}. This id is
 * much like the &quot;id&quot; attribute of an HTML tag in that it is up to the designer
 * and developer to ensure that the {@code id} is unique within the scene graph.
 * A convenience function called {@link #lookup(String)} can be used to find
 * a node with a unique id within the scene graph, or within a subtree of the
 * scene graph. The id can also be used identify nodes for applying styles; see
 * the CSS section below.
 *
 * &lt;h3&gt;Coordinate System&lt;/h3&gt;
 * &lt;p&gt;
 * The {@code Node} class defines a traditional computer graphics &quot;local&quot;
 * coordinate system in which the {@code x} axis increases to the right and the
 * {@code y} axis increases downwards.  The concrete node classes for shapes
 * provide variables for defining the geometry and location of the shape
 * within this local coordinate space.  For example,
 * {@link javafx.scene.shape.Rectangle} provides {@code x}, {@code y},
 * {@code width}, {@code height} variables while
 * {@link javafx.scene.shape.Circle} provides {@code centerX}, {@code centerY},
 * and {@code radius}.
 * &lt;p&gt;
 * At the device pixel level, integer coordinates map onto the corners and
 * cracks between the pixels and the centers of the pixels appear at the
 * midpoints between integer pixel locations.  Because all coordinate values
 * are specified with floating point numbers, coordinates can precisely
 * point to these corners (when the floating point values have exact integer
 * values) or to any location on the pixel.  For example, a coordinate of
 * {@code (0.5, 0.5)} would point to the center of the upper left pixel on the
 * {@code Stage}.  Similarly, a rectangle at {@code (0, 0)} with dimensions
 * of {@code 10} by {@code 10} would span from the upper left corner of the
 * upper left pixel on the {@code Stage} to the lower right corner of the
 * 10th pixel on the 10th scanline.  The pixel center of the last pixel
 * inside that rectangle would be at the coordinates {@code (9.5, 9.5)}.
 * &lt;p&gt;
 * In practice, most nodes have transformations applied to their coordinate
 * system as mentioned below.  As a result, the information above describing
 * the alignment of device coordinates to the pixel grid is relative to
 * the transformed coordinates, not the local coordinates of the nodes.
 * The {@link javafx.scene.shape.Shape Shape} class describes some additional
 * important context-specific information about coordinate mapping and how
 * it can affect rendering.
 *
 * &lt;h3&gt;Transformations&lt;/h3&gt;
 * &lt;p&gt;
 * Any {@code Node} can have transformations applied to it. These include
 * translation, rotation, scaling, or shearing.
 * &lt;p&gt;
 * A &lt;b&gt;translation&lt;/b&gt; transformation is one which shifts the origin of the
 * node's coordinate space along either the x or y axis. For example, if you
 * create a {@link javafx.scene.shape.Rectangle} which is drawn at the origin
 * (x=0, y=0) and has a width of 100 and a height of 50, and then apply a
 * {@link javafx.scene.transform.Translate} with a shift of 10 along the x axis
 * (x=10), then the rectangle will appear drawn at (x=10, y=0) and remain
 * 100 points wide and 50 tall. Note that the origin was shifted, not the
 * {@code x} variable of the rectangle.
 * &lt;p&gt;
 * A common node transform is a translation by an integer distance, most often
 * used to lay out nodes on the stage.  Such integer translations maintain the
 * device pixel mapping so that local coordinates that are integers still
 * map to the cracks between pixels.
 * &lt;p&gt;
 * A &lt;b&gt;rotation&lt;/b&gt; transformation is one which rotates the coordinate space of
 * the node about a specified &quot;pivot&quot; point, causing the node to appear rotated.
 * For example, if you create a {@link javafx.scene.shape.Rectangle} which is
 * drawn at the origin (x=0, y=0) and has a width of 100 and height of 30 and
 * you apply a {@link javafx.scene.transform.Rotate} with a 90 degree rotation
 * (angle=90) and a pivot at the origin (pivotX=0, pivotY=0), then
 * the rectangle will be drawn as if its x and y were zero but its height was
 * 100 and its width -30. That is, it is as if a pin is being stuck at the top
 * left corner and the rectangle is rotating 90 degrees clockwise around that
 * pin. If the pivot point is instead placed in the center of the rectangle
 * (at point x=50, y=15) then the rectangle will instead appear to rotate about
 * its center.
 * &lt;p&gt;
 * Note that as with all transformations, the x, y, width, and height variables
 * of the rectangle (which remain relative to the local coordinate space) have
 * not changed, but rather the transformation alters the entire coordinate space
 * of the rectangle.
 * &lt;p&gt;
 * A &lt;b&gt;scaling&lt;/b&gt; transformation causes a node to either appear larger or
 * smaller depending on the scaling factor. Scaling alters the coordinate space
 * of the node such that each unit of distance along the axis in local
 * coordinates is multiplied by the scale factor. As with rotation
 * transformations, scaling transformations are applied about a &quot;pivot&quot; point.
 * You can think of this as the point in the Node around which you &quot;zoom&quot;.  For
 * example, if you create a {@link javafx.scene.shape.Rectangle} with a
 * {@code strokeWidth} of 5, and a width and height of 50, and you apply a
 * {@link javafx.scene.transform.Scale} with scale factors (x=2.0, y=2.0) and
 * a pivot at the origin (pivotX=0, pivotY=0), the entire rectangle
 * (including the stroke) will double in size, growing to the right and
 * downwards from the origin.
 * &lt;p&gt;
 * A &lt;b&gt;shearing&lt;/b&gt; transformation, sometimes called a skew, effectively
 * rotates one axis so that the x and y axes are no longer perpendicular.
 * &lt;p&gt;
 * Multiple transformations may be applied to a node by specifying an ordered
 * chain of transforms.  The order in which the transforms are applied is
 * defined by the ObservableList specified in the {@link #getTransforms transforms} variable.
 *
 * &lt;h3&gt;Bounding Rectangles&lt;/h3&gt;
 * &lt;p&gt;
 * Since every {@code Node} has transformations, every Node's geometric
 * bounding rectangle can be described differently depending on whether
 * transformations are accounted for or not.
 * &lt;p&gt;
 * Each {@code Node} has a read-only {@link #boundsInLocalProperty boundsInLocal}
 * variable which specifies the bounding rectangle of the {@code Node} in
 * untransformed local coordinates. {@code boundsInLocal} includes the
 * Node's shape geometry, including any space required for a
 * non-zero stroke that may fall outside the local position/size variables,
 * and its {@link #clipProperty clip} and {@link #effectProperty effect} variables.
 * &lt;p&gt;
 * Each {@code Node} also has a read-only {@link #boundsInParentProperty boundsInParent} variable which
 * specifies the bounding rectangle of the {@code Node} after all transformations
 * have been applied, including those set in {@link #getTransforms transforms},
 * {@link #scaleXProperty scaleX}/{@link #scaleYProperty scaleY}, {@link #rotateProperty rotate},
 * {@link #translateXProperty translateX}/{@link #translateYProperty translateY}, and {@link #layoutXProperty layoutX}/{@link #layoutYProperty layoutY}.
 * It is called &quot;boundsInParent&quot; because the rectangle will be relative to the
 * parent's coordinate system.  This is the 'visual' bounds of the node.
 * &lt;p&gt;
 * Finally, the {@link #layoutBoundsProperty layoutBounds} variable defines the rectangular bounds of
 * the {@code Node} that should be used as the basis for layout calculations and
 * may differ from the visual bounds of the node.  For shapes, Text, and ImageView,
 * layoutBounds by default includes only the shape geometry, including space required
 * for a non-zero {@code strokeWidth}, but does &lt;i&gt;not&lt;/i&gt; include the effect,
 * clip, or any transforms. For resizable classes (Regions and Controls)
 * layoutBounds will always map to {@code 0,0 width x height}.
 *
 * &lt;p&gt; The image shows a node without any transformation and its {@code boundsInLocal}:
 * &lt;p&gt; &lt;img src=&quot;doc-files/boundsLocal.png&quot; alt=&quot;A sine wave shape enclosed by
 * an axis-aligned rectangular bounds&quot;&gt; &lt;/p&gt;
 * If we rotate the image by 20 degrees we get following result:
 * &lt;p&gt; &lt;img src=&quot;doc-files/boundsParent.png&quot; alt=&quot;An axis-aligned rectangular
 * bounds that encloses the shape rotated by 20 degrees&quot;&gt; &lt;/p&gt;
 * The red rectangle represents {@code boundsInParent} in the
 * coordinate space of the Node's parent. The {@code boundsInLocal} stays the same
 * as in the first image, the green rectangle in this image represents {@code boundsInLocal}
 * in the coordinate space of the Node.
 *
 * &lt;p&gt; The images show a filled and stroked rectangle and their bounds. The
 * first rectangle {@code [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:0]}
 * has the following bounds bounds: {@code [x:10.0 y:10.0 width:100.0 height:100.0]}.
 *
 * The second rectangle {@code [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:5]}
 * has the following bounds: {@code [x:7.5 y:7.5 width:105 height:105]}
 * (the stroke is centered by default, so only half of it is outside
 * of the original bounds; it is also possible to create inside or outside
 * stroke).
 *
 * Since neither of the rectangles has any transformation applied,
 * {@code boundsInParent} and {@code boundsInLocal} are the same. &lt;/p&gt;
 * &lt;p&gt; &lt;img src=&quot;doc-files/bounds.png&quot; alt=&quot;The rectangles are enclosed by their
 * respective bounds&quot;&gt; &lt;/p&gt;
 *
 *
 * &lt;h3&gt;CSS&lt;/h3&gt;
 * &lt;p&gt;
 * The {@code Node} class contains {@code id}, {@code styleClass}, and
 * {@code style} variables that are used in styling this node from
 * CSS. The {@code id} and {@code styleClass} variables are used in
 * CSS style sheets to identify nodes to which styles should be
 * applied. The {@code style} variable contains style properties and
 * values that are applied directly to this node.
 * &lt;p&gt;
 * For further information about CSS and how to apply CSS styles
 * to nodes, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
 * Guide&lt;/a&gt;.
 * @since JavaFX 2.0
 */
@IDProperty(&quot;id&quot;)
public abstract class Node implements EventTarget, Styleable {

    /*
     * Store the singleton instance of the NodeHelper subclass corresponding
     * to the subclass of this instance of Node
     */
    private NodeHelper nodeHelper = null;

    static {
        PerformanceTracker.logEvent(&quot;Node class loaded&quot;);

        // This is used by classes in different packages to get access to
        // private and package private methods.
        NodeHelper.setNodeAccessor(new NodeHelper.NodeAccessor() {
            @Override
            public NodeHelper getHelper(Node node) {
                return node.nodeHelper;
            }

            @Override
            public void setHelper(Node node, NodeHelper nodeHelper) {
                node.nodeHelper = nodeHelper;
            }

            @Override
            public void doMarkDirty(Node node, DirtyBits dirtyBit) {
                node.doMarkDirty(dirtyBit);
            }

            @Override
            public void doUpdatePeer(Node node) {
                node.doUpdatePeer();
            }

            @Override
            public BaseTransform getLeafTransform(Node node) {
                return node.getLeafTransform();
            }

            @Override
            public Bounds doComputeLayoutBounds(Node node) {
                return node.doComputeLayoutBounds();
            }

            @Override
            public void doTransformsChanged(Node node) {
                node.doTransformsChanged();
            }

            @Override
            public void doPickNodeLocal(Node node, PickRay localPickRay,
                    PickResultChooser result) {
                node.doPickNodeLocal(localPickRay, result);
            }

            @Override
            public boolean doComputeIntersects(Node node, PickRay pickRay,
                    PickResultChooser pickResult) {
                return node.doComputeIntersects(pickRay, pickResult);
            }

            @Override
            public void doGeomChanged(Node node) {
                node.doGeomChanged();
            }

            @Override
            public void doNotifyLayoutBoundsChanged(Node node) {
                node.doNotifyLayoutBoundsChanged();
            }

            @Override
            public void doProcessCSS(Node node) {
                node.doProcessCSS();
            }

            @Override
            public boolean isDirty(Node node, DirtyBits dirtyBit) {
                return node.isDirty(dirtyBit);
            }

            @Override
            public boolean isDirtyEmpty(Node node) {
                return node.isDirtyEmpty();
            }

            @Override
            public void syncPeer(Node node) {
                node.syncPeer();
            }

            @Override
            public void layoutBoundsChanged(Node node) {
                node.layoutBoundsChanged();
            }

            @Override
            public &lt;P extends NGNode&gt; P getPeer(Node node) {
                return node.getPeer();
            }

            @Override
            public void setShowMnemonics(Node node, boolean value) {
                node.setShowMnemonics(value);
            }

            @Override
            public boolean isShowMnemonics(Node node) {
                return node.isShowMnemonics();
            }

            @Override
            public BooleanProperty showMnemonicsProperty(Node node) {
                return node.showMnemonicsProperty();
            }

            @Override
            public boolean traverse(Node node, Direction direction) {
                return node.traverse(direction);
            }

            @Override
            public double getPivotX(Node node) {
                return node.getPivotX();
            }

            @Override
            public double getPivotY(Node node) {
                return node.getPivotY();
            }

            @Override
            public double getPivotZ(Node node) {
                return node.getPivotZ();
            }

            @Override
            public void pickNode(Node node,PickRay pickRay,
                    PickResultChooser result) {
                node.pickNode(pickRay, result);
            }

            @Override
            public boolean intersects(Node node, PickRay pickRay,
                    PickResultChooser pickResult) {
                return node.intersects(pickRay, pickResult);
            }

            @Override
            public double intersectsBounds(Node node, PickRay pickRay) {
                return node.intersectsBounds(pickRay);
            }

            @Override
            public void layoutNodeForPrinting(Node node) {
                node.doCSSLayoutSyncForSnapshot();
            }

            @Override
            public boolean isDerivedDepthTest(Node node) {
                return node.isDerivedDepthTest();
            }

            @Override
            public SubScene getSubScene(Node node) {
                return node.getSubScene();
            }

            @Override
            public void setLabeledBy(Node node, Node labeledBy) {
                node.labeledBy = labeledBy;
            }

            @Override
            public Accessible getAccessible(Node node) {
                return node.getAccessible();
            }

            @Override
            public void reapplyCSS(Node node) {
                node.reapplyCSS();
            }

            @Override
            public boolean isTreeVisible(Node node) {
                return node.isTreeVisible();
            }

            @Override
            public BooleanExpression treeVisibleProperty(Node node) {
                return node.treeVisibleProperty();
            }

            @Override
            public boolean isTreeShowing(Node node) {
                return node.isTreeShowing();
            }

            @Override
            public BooleanExpression treeShowingProperty(Node node) {
                return node.treeShowingProperty();
            }

            @Override
            public List&lt;Style&gt; getMatchingStyles(CssMetaData cssMetaData,
                    Styleable styleable) {
                return Node.getMatchingStyles(cssMetaData, styleable);
            }

            @Override
            public Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; findStyles(Node node,
                    Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; styleMap) {
                return node.findStyles(styleMap);
            }
        });
    }

    /**************************************************************************
     *                                                                        *
     * Methods and state for managing the dirty bits of a Node. The dirty     *
     * bits are flags used to keep track of what things are dirty on the      *
     * node and therefore need processing on the next pulse. Since the pulse  *
     * happens asynchronously to the change that made the node dirty (for     *
     * performance reasons), we need to keep track of what things have        *
     * changed.                                                               *
     *                                                                        *
     *************************************************************************/

    /*
     * Set of dirty bits that are set when state is invalidated and cleared by
     * the updateState method, which is called from the synchronizer.
     */
    private int dirtyBits;

    /*
     * Mark the specified bit as dirty, and add this node to the scene's dirty list.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doMarkDirty(DirtyBits dirtyBit) {
        if (isDirtyEmpty()) {
            addToSceneDirtyList();
        }

        dirtyBits |= dirtyBit.getMask();
    }

    private void addToSceneDirtyList() {
        Scene s = getScene();
        if (s != null) {
            s.addToDirtyList(this);
            if (getSubScene() != null) {
                getSubScene().setDirty(this);
            }
        }
    }

    /*
     * Test whether the specified dirty bit is set
     */
    final boolean isDirty(DirtyBits dirtyBit) {
        return (dirtyBits &amp; dirtyBit.getMask()) != 0;
    }

    /*
     * Clear the specified dirty bit
     */
    final void clearDirty(DirtyBits dirtyBit) {
        dirtyBits &amp;= ~dirtyBit.getMask();
    }

    /*
     * Set all dirty bits
     */
    private void setDirty() {
        dirtyBits = ~0;
    }

    /*
     * Clear all dirty bits
     */
    private void clearDirty() {
        dirtyBits = 0;
    }

    /*
     * Test whether the set of dirty bits is empty
     */
    final boolean isDirtyEmpty() {
        return dirtyBits == 0;
    }

    /**************************************************************************
     *                                                                        *
     * Methods for synchronizing state from this Node to its PG peer. This    *
     * should only *ever* be called during synchronization initialized as a   *
     * result of a pulse. Any attempt to synchronize at any other time may    *
     * cause rendering artifacts.                                             *
     *                                                                        *
     *************************************************************************/

    /*
     * Called by the synchronizer to update the state and
     * clear dirtybits of this node in the PG graph
     */
    final void syncPeer() {
        // Do not synchronize invisible nodes unless their visibility has changed
        // or they have requested a forced synchronization
        if (!isDirtyEmpty() &amp;&amp; (treeVisible
                                     || isDirty(DirtyBits.NODE_VISIBLE)
                                     || isDirty(DirtyBits.NODE_FORCE_SYNC)))
        {
            NodeHelper.updatePeer(this);
            clearDirty();
        }
    }

    /**
     * A temporary rect used for computing bounds by the various bounds
     * variables. This bounds starts life as a RectBounds, but may be promoted
     * to a BoxBounds if there is a 3D transform mixed into its computation.
     * These two fields were held in a thread local, but were then pulled
     * out of it so that we could compute bounds before holding the
     * synchronization lock. These objects have to be per-instance so
     * that we can pass the right data down to the PG side later during
     * synchronization (rather than statics as they were before).
     */
    private BaseBounds _geomBounds = new RectBounds(0, 0, -1, -1);
    private BaseBounds _txBounds = new RectBounds(0, 0, -1, -1);

    private boolean pendingUpdateBounds = false;

    // Happens before we hold the sync lock
    void updateBounds() {
        // Note: the clip must be handled before the visibility is checked. This is because the visiblity might be
        // changing in the clip and it is going to be synchronized, so it needs to recompute the bounds.
        Node n = getClip();
        if (n != null) {
            n.updateBounds();
        }

        // See syncPeer()
        if (!treeVisible &amp;&amp; !isDirty(DirtyBits.NODE_VISIBLE)) {

            // Need to save the dirty bits since they will be cleared even for the
            // case of short circuiting dirty bit processing.
            if (isDirty(DirtyBits.NODE_TRANSFORM)
                    || isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)
                    || isDirty(DirtyBits.NODE_BOUNDS)) {
                pendingUpdateBounds = true;
            }

            return;
        }

        // Set transform and bounds dirty bits when this node becomes visible
        if (pendingUpdateBounds) {
            NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORM);
            NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORMED_BOUNDS);
            NodeHelper.markDirty(this, DirtyBits.NODE_BOUNDS);

            pendingUpdateBounds = false;
        }

        if (isDirty(DirtyBits.NODE_TRANSFORM) || isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)) {
            if (isDirty(DirtyBits.NODE_TRANSFORM)) {
                updateLocalToParentTransform();
            }
            _txBounds = getTransformedBounds(_txBounds,
                                             BaseTransform.IDENTITY_TRANSFORM);
        }

        if (isDirty(DirtyBits.NODE_BOUNDS)) {
            _geomBounds = getGeomBounds(_geomBounds,
                    BaseTransform.IDENTITY_TRANSFORM);
        }

    }

    /*
     * This function is called during synchronization to update the state of the
     * NG Node from the FX Node. Subclasses of Node should override this method
     * and must call NodeHelper.updatePeer(this)
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        final NGNode peer = getPeer();

        // For debug / diagnostic purposes, we will copy across a name for this node down to
        // the NG layer, where we can use the name to figure out what the NGNode represents.
        // An alternative would be to have a back-reference from the NGNode back to the Node it
        // is a peer to, however it was felt that this would make it too easy to communicate back
        // to the Node and possibly violate thread invariants. But of course, we only need to do this
        // if we're going to print the render graph (otherwise all the work we'd do to keep the name
        // properly updated would be a waste).
        if (PrismSettings.printRenderGraph &amp;&amp; isDirty(DirtyBits.DEBUG)) {
            final String id = getId();
            String className = getClass().getSimpleName();
            if (className.isEmpty()) {
                className = getClass().getName();
            }
            peer.setName(id == null ? className : id + &quot;(&quot; + className + &quot;)&quot;);
        }

        if (isDirty(DirtyBits.NODE_TRANSFORM)) {
            peer.setTransformMatrix(localToParentTx);
        }

        if (isDirty(DirtyBits.NODE_VIEW_ORDER)) {
            peer.setViewOrder(getViewOrder());
        }

        if (isDirty(DirtyBits.NODE_BOUNDS)) {
            peer.setContentBounds(_geomBounds);
        }

        if (isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)) {
            peer.setTransformedBounds(_txBounds, !isDirty(DirtyBits.NODE_BOUNDS));
        }

        if (isDirty(DirtyBits.NODE_OPACITY)) {
            peer.setOpacity((float)Utils.clamp(0, getOpacity(), 1));
        }

        if (isDirty(DirtyBits.NODE_CACHE)) {
            peer.setCachedAsBitmap(isCache(), getCacheHint());
        }

        if (isDirty(DirtyBits.NODE_CLIP)) {
            peer.setClipNode(getClip() != null ? getClip().getPeer() : null);
        }

        if (isDirty(DirtyBits.EFFECT_EFFECT)) {
            if (getEffect() != null) {
                EffectHelper.sync(getEffect());
                peer.effectChanged();
            }
        }

        if (isDirty(DirtyBits.NODE_EFFECT)) {
            peer.setEffect(getEffect() != null ? EffectHelper.getPeer(getEffect()) : null);
        }

        if (isDirty(DirtyBits.NODE_VISIBLE)) {
            peer.setVisible(isVisible());
        }

        if (isDirty(DirtyBits.NODE_DEPTH_TEST)) {
            peer.setDepthTest(isDerivedDepthTest());
        }

        if (isDirty(DirtyBits.NODE_BLENDMODE)) {
            BlendMode mode = getBlendMode();
            peer.setNodeBlendMode((mode == null)
                                  ? null
                                  : EffectHelper.getToolkitBlendMode(mode));
        }
    }

    /*************************************************************************
    *                                                                        *
    *                                                                        *
    *                                                                        *
    *************************************************************************/

    private static final Object USER_DATA_KEY = new Object();
    // A map containing a set of properties for this node
    private ObservableMap&lt;Object, Object&gt; properties;

    /**
      * Returns an observable map of properties on this node for use primarily
      * by application developers.
      *
      * @return an observable map of properties on this node for use primarily
      * by application developers
      */
     public final ObservableMap&lt;Object, Object&gt; getProperties() {
        if (properties == null) {
            properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
        }
        return properties;
    }

    /**
     * Tests if Node has properties.
     * @return true if node has properties.
     */
     public boolean hasProperties() {
        return properties != null &amp;&amp; !properties.isEmpty();
    }

    /**
     * Convenience method for setting a single Object property that can be
     * retrieved at a later date. This is functionally equivalent to calling
     * the getProperties().put(Object key, Object value) method. This can later
     * be retrieved by calling {@link Node#getUserData()}.
     *
     * @param value The value to be stored - this can later be retrieved by calling
     *          {@link Node#getUserData()}.
     */
    public void setUserData(Object value) {
        getProperties().put(USER_DATA_KEY, value);
    }

    /**
     * Returns a previously set Object property, or null if no such property
     * has been set using the {@link Node#setUserData(java.lang.Object)} method.
     *
     * @return The Object that was previously set, or null if no property
     *          has been set or if null was set.
     */
    public Object getUserData() {
        return getProperties().get(USER_DATA_KEY);
    }

    /**************************************************************************
     *                                                                        *
     *
     *                                                                        *
     *************************************************************************/

    /**
     * The parent of this {@code Node}. If this {@code Node} has not been added
     * to a scene graph, then parent will be null.
     *
     * @defaultValue null
     */
    private ReadOnlyObjectWrapper&lt;Parent&gt; parent;

    final void setParent(Parent value) {
        parentPropertyImpl().set(value);
    }

    public final Parent getParent() {
        return parent == null ? null : parent.get();
    }

    public final ReadOnlyObjectProperty&lt;Parent&gt; parentProperty() {
        return parentPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyObjectWrapper&lt;Parent&gt; parentPropertyImpl() {
        if (parent == null) {
            parent = new ReadOnlyObjectWrapper&lt;Parent&gt;() {
                private Parent oldParent;

                @Override
                protected void invalidated() {
                    if (oldParent != null) {
                        oldParent.disabledProperty().removeListener(parentDisabledChangedListener);
                        oldParent.treeVisibleProperty().removeListener(parentTreeVisibleChangedListener);
                        if (nodeTransformation != null &amp;&amp; nodeTransformation.listenerReasons &gt; 0) {
                            ((Node) oldParent).localToSceneTransformProperty().removeListener(
                                    nodeTransformation.getLocalToSceneInvalidationListener());
                        }
                    }
                    updateDisabled();
                    computeDerivedDepthTest();
                    final Parent newParent = get();
                    if (newParent != null) {
                        newParent.disabledProperty().addListener(parentDisabledChangedListener);
                        newParent.treeVisibleProperty().addListener(parentTreeVisibleChangedListener);
                        if (nodeTransformation != null &amp;&amp; nodeTransformation.listenerReasons &gt; 0) {
                            ((Node) newParent).localToSceneTransformProperty().addListener(
                                    nodeTransformation.getLocalToSceneInvalidationListener());
                        }
                        //
                        // if parent changed, then CSS needs to be reapplied so
                        // that this node will get the right styles. This used
                        // to be done from Parent.children's onChanged method.
                        // See the comments there, also.
                        //
                        reapplyCSS();
                    } else {
                        // RT-31168: reset CssFlag to clean so css will be reapplied if the node is added back later.
                        // If flag is REAPPLY, then reapplyCSS() will just return and the call to
                        // notifyParentsOfInvalidatedCSS() will be skipped thus leaving the node un-styled.
                        cssFlag = CssFlags.CLEAN;
                    }
                    updateTreeVisible(true);
                    oldParent = newParent;
                    invalidateLocalToSceneTransform();
                    parentResolvedOrientationInvalidated();
                    notifyAccessibleAttributeChanged(AccessibleAttribute.PARENT);
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;parent&quot;;
                }
            };
        }
        return parent;
    }

    private final InvalidationListener parentDisabledChangedListener = valueModel -&gt; updateDisabled();

    private final InvalidationListener parentTreeVisibleChangedListener = valueModel -&gt; updateTreeVisible(true);

    private final ChangeListener&lt;Boolean&gt; windowShowingChangedListener
            = (win, oldVal, newVal) -&gt; updateTreeShowing();

    private final ChangeListener&lt;Window&gt; sceneWindowChangedListener = (scene, oldWindow, newWindow) -&gt; {
        // Replace the windowShowingListener and call updateTreeShowing()
        if (oldWindow != null) {
            oldWindow.showingProperty().removeListener(windowShowingChangedListener);
        }
        if (newWindow != null) {
            newWindow.showingProperty().addListener(windowShowingChangedListener);
        }
        updateTreeShowing();
    };

    private SubScene subScene = null;

    /**
     * The {@link Scene} that this {@code Node} is part of. If the Node is not
     * part of a scene, then this variable will be null.
     *
     * @defaultValue null
     */
    private ReadOnlyObjectWrapperManualFire&lt;Scene&gt; scene = new ReadOnlyObjectWrapperManualFire&lt;Scene&gt;();

    private class ReadOnlyObjectWrapperManualFire&lt;T&gt; extends ReadOnlyObjectWrapper&lt;T&gt; {
        @Override
        public Object getBean() {
            return Node.this;
        }

        @Override
        public String getName() {
            return &quot;scene&quot;;
        }

        @Override
        protected void fireValueChangedEvent() {
            /*
             * Note: This method has been intentionally made into a no-op. In
             * order to override the default set behavior. By default calling
             * set(...) on a different scene will trigger:
             * - invalidated();
             * - fireValueChangedEvent();
             * Both of the above are no-ops, but are handled manually via
             * - Node.this.setScenes(...)
             * - Node.this.invalidatedScenes(...)
             * - forceValueChangedEvent()
             */
        }

        public void fireSuperValueChangedEvent() {
            super.fireValueChangedEvent();
        }
    }

    private void invalidatedScenes(Scene oldScene, SubScene oldSubScene) {
        Scene newScene = sceneProperty().get();
        boolean sceneChanged = oldScene != newScene;
        SubScene newSubScene = subScene;

        if (getClip() != null) {
            getClip().setScenes(newScene, newSubScene);
        }
        if (sceneChanged) {
            updateCanReceiveFocus();
            if (isFocusTraversable()) {
                if (newScene != null) {
                    newScene.initializeInternalEventDispatcher();
                }
            }
            focusSetDirty(oldScene);
            focusSetDirty(newScene);
        }
        scenesChanged(newScene, newSubScene, oldScene, oldSubScene);

        // isTreeShowing needs to take into account of Window's showing
        if (oldScene != null) {
            oldScene.windowProperty().removeListener(sceneWindowChangedListener);
        }
        if (newScene != null) {
            newScene.windowProperty().addListener(sceneWindowChangedListener);
        }
        updateTreeShowing();

        if (sceneChanged) reapplyCSS();

        if (sceneChanged &amp;&amp; !isDirtyEmpty()) {
            //Note: no need to remove from scene's dirty list
            //Scene's is checking if the node's scene is correct
            /* TODO: looks like an existing bug when a node is moved from one
             * location to another, setScenes will be called twice by
             * Parent.VetoableListDecorator onProposedChange and onChanged
             * respectively. Removing the node and setting setScense(null,null)
             * then adding it back to potentially the same scene. Causing the
             * same node to being added twice to the same scene.
             */
            addToSceneDirtyList();
        }

        if (newScene == null &amp;&amp; peer != null) {
            peer.release();
        }

        if (oldScene != null) {
            oldScene.clearNodeMnemonics(this);
        }
        if (getParent() == null) {
            // if we are the root we need to handle scene change
            parentResolvedOrientationInvalidated();
        }

        if (sceneChanged) { scene.fireSuperValueChangedEvent(); }

        /* Dispose the accessible peer, if any. If AT ever needs this node again
         * a new accessible peer is created. */
        if (accessible != null) {
            /* Generally accessibility does not retain any state, therefore deleting objects
             * generally does not cause problems (AT just asks everything back).
             * The exception to this rule is when the object sends a notifications to the AT,
             * in which case it is expected to be around to answer request for the new values.
             * It is possible that a object is reparented (within the scene) in the middle of
             * this process. For example, when a tree item is expanded, the notification is
             * sent to the AT by the cell. But when the TreeView relayouts the cell can be
             * reparented before AT can query the relevant information about the expand event.
             * If the accessible was disposed, AT can't properly report the event.
             *
             * The fix is to defer the disposal of the accessible to the next pulse.
             * If at that time the node is placed back to the scene, then the accessible is hooked
             * to Node and AT requests are processed. Otherwise the accessible is disposed.
             */
            if (oldScene != null &amp;&amp; oldScene != newScene &amp;&amp; newScene == null) {
                // Strictly speaking we need some type of accessible.thaw() at this point.
                oldScene.addAccessible(Node.this, accessible);
            } else {
                accessible.dispose();
            }
            /* Always set to null to ensure this accessible is never on more than one
             * Scene#accMap at the same time (At lest not with the same accessible).
             */
            accessible = null;
        }
    }

    final void setScenes(Scene newScene, SubScene newSubScene) {
        Scene oldScene = sceneProperty().get();
        if (newScene != oldScene || newSubScene != subScene) {
            scene.set(newScene);
            SubScene oldSubScene = subScene;
            subScene = newSubScene;
            invalidatedScenes(oldScene, oldSubScene);
            if (this instanceof SubScene) { // TODO: find better solution
                SubScene thisSubScene = (SubScene)this;
                thisSubScene.getRoot().setScenes(newScene, thisSubScene);
            }
        }
    }

    final SubScene getSubScene() {
        return subScene;
    }

    public final Scene getScene() {
        return scene.get();
    }

    public final ReadOnlyObjectProperty&lt;Scene&gt; sceneProperty() {
        return scene.getReadOnlyProperty();
    }

    /**
     * Exists for Parent and LightBase
     */
    void scenesChanged(final Scene newScene, final SubScene newSubScene,
                       final Scene oldScene, final SubScene oldSubScene) { }


    /**
     * The id of this {@code Node}. This simple string identifier is useful for
     * finding a specific Node within the scene graph. While the id of a Node
     * should be unique within the scene graph, this uniqueness is not enforced.
     * This is analogous to the &quot;id&quot; attribute on an HTML element
     * (&lt;a href=&quot;http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier&quot;&gt;CSS ID Specification&lt;/a&gt;).
     * &lt;p&gt;
     *     For example, if a Node is given the id of &quot;myId&quot;, then the lookup method can
     *     be used to find this node as follows: &lt;code&gt;scene.lookup(&quot;#myId&quot;);&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @defaultValue null
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     */
    private StringProperty id;

    public final void setId(String value) {
        idProperty().set(value);
    }

    //TODO: this is copied from the property in order to add the @return statement.
    //      We should have a better, general solution without the need to copy it.
    /**
     * The id of this {@code Node}. This simple string identifier is useful for
     * finding a specific Node within the scene graph. While the id of a Node
     * should be unique within the scene graph, this uniqueness is not enforced.
     * This is analogous to the &quot;id&quot; attribute on an HTML element
     * (&lt;a href=&quot;http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier&quot;&gt;CSS ID Specification&lt;/a&gt;).
     *
     * @return the id assigned to this {@code Node} using the {@code setId}
     *         method or {@code null}, if no id has been assigned.
     * @defaultValue null
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
     */
    public final String getId() {
        return id == null ? null : id.get();
    }

    public final StringProperty idProperty() {
        if (id == null) {
            id = new StringPropertyBase() {

                @Override
                protected void invalidated() {
                    reapplyCSS();
                    if (PrismSettings.printRenderGraph) {
                        NodeHelper.markDirty(Node.this, DirtyBits.DEBUG);
                    }
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;id&quot;;
                }
            };
        }
        return id;
    }

    /**
     * A list of String identifiers which can be used to logically group
     * Nodes, specifically for an external style engine. This variable is
     * analogous to the &quot;class&quot; attribute on an HTML element and, as such,
     * each element of the list is a style class to which this Node belongs.
     *
     * @see &lt;a href=&quot;http://www.w3.org/TR/css3-selectors/#class-html&quot;&gt;CSS3 class selectors&lt;/a&gt;
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     * @defaultValue null
     */
    private ObservableList&lt;String&gt; styleClass = new TrackableObservableList&lt;String&gt;() {
        @Override
        protected void onChanged(Change&lt;String&gt; c) {
            reapplyCSS();
        }

        @Override
        public String toString() {
            if (size() == 0) {
                return &quot;&quot;;
            } else if (size() == 1) {
                return get(0);
            } else {
                StringBuilder buf = new StringBuilder();
                for (int i = 0; i &lt; size(); i++) {
                    buf.append(get(i));
                    if (i + 1 &lt; size()) {
                        buf.append(' ');
                    }
                }
                return buf.toString();
            }
        }
    };

    @Override
    public final ObservableList&lt;String&gt; getStyleClass() {
        return styleClass;
    }

    /**
     * A string representation of the CSS style associated with this
     * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
     * HTML element. Note that, like the HTML style attribute, this
     * variable contains style properties and values and not the
     * selector portion of a style rule.
     * @defaultValue empty string
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     */
    private StringProperty style;

    /**
     * A string representation of the CSS style associated with this
     * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
     * HTML element. Note that, like the HTML style attribute, this
     * variable contains style properties and values and not the
     * selector portion of a style rule.
     * @param value The inline CSS style to use for this {@code Node}.
     *         {@code null} is implicitly converted to an empty String.
     * @defaultValue empty string
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
     */
    public final void setStyle(String value) {
        styleProperty().set(value);
    }

    // TODO: javadoc copied from property for the sole purpose of providing a return tag
    /**
     * A string representation of the CSS style associated with this
     * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
     * HTML element. Note that, like the HTML style attribute, this
     * variable contains style properties and values and not the
     * selector portion of a style rule.
     * @defaultValue empty string
     * @return The inline CSS style associated with this {@code Node}.
     *         If this {@code Node} does not have an inline style,
     *         an empty String is returned.
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
     */
    public final String getStyle() {
        return style == null ? &quot;&quot; : style.get();
    }

    public final StringProperty styleProperty() {
        if (style == null) {
            style = new StringPropertyBase(&quot;&quot;) {

                @Override public void set(String value) {
                    // getStyle returns an empty string if the style property
                    // is null. To be consistent, getStyle should also return
                    // an empty string when the style property's value is null.
                    super.set((value != null) ? value : &quot;&quot;);
                }

                @Override
                protected void invalidated() {
                    // If the style has changed, then styles of this node
                    // and child nodes might be affected.
                    reapplyCSS();
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;style&quot;;
                }
            };
        }
        return style;
    }

    /**
     * Specifies whether this {@code Node} and any subnodes should be rendered
     * as part of the scene graph. A node may be visible and yet not be shown
     * in the rendered scene if, for instance, it is off the screen or obscured
     * by another Node. Invisible nodes never receive mouse events or
     * keyboard focus and never maintain keyboard focus when they become
     * invisible.
     *
     * @defaultValue true
     */
    private BooleanProperty visible;

    public final void setVisible(boolean value) {
        visibleProperty().set(value);
    }

    public final boolean isVisible() {
        return visible == null ? true : visible.get();
    }

    public final BooleanProperty visibleProperty() {
        if (visible == null) {
            visible = new StyleableBooleanProperty(true) {
                boolean oldValue = true;
                @Override
                protected void invalidated() {
                    if (oldValue != get()) {
                        NodeHelper.markDirty(Node.this, DirtyBits.NODE_VISIBLE);
                        NodeHelper.geomChanged(Node.this);
                        updateTreeVisible(false);
                        if (getParent() != null) {
                            // notify the parent of the potential change in visibility
                            // of this node, since visibility affects bounds of the
                            // parent node
                            getParent().childVisibilityChanged(Node.this);
                        }
                        oldValue = get();
                    }
                }

                @Override
                public CssMetaData getCssMetaData() {
                    return StyleableProperties.VISIBILITY;
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;visible&quot;;
                }
            };
        }
        return visible;
    }

    public final void setCursor(Cursor value) {
        cursorProperty().set(value);
    }

    public final Cursor getCursor() {
        return (miscProperties == null) ? DEFAULT_CURSOR
                                        : miscProperties.getCursor();
    }

    /**
     * Defines the mouse cursor for this {@code Node} and subnodes. If null,
     * then the cursor of the first parent node with a non-null cursor will be
     * used. If no Node in the scene graph defines a cursor, then the cursor
     * of the {@code Scene} will be used.
     *
     * @return the mouse cursor for this {@code Node} and subnodes
     * @defaultValue null
     */
    public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
        return getMiscProperties().cursorProperty();
    }

    /**
     * Specifies how opaque (that is, solid) the {@code Node} appears. A Node
     * with 0% opacity is fully translucent. That is, while it is still
     * {@link #visibleProperty visible} and rendered, you generally won't be able to see it. The
     * exception to this rule is when the {@code Node} is combined with a
     * blending mode and blend effect in which case a translucent Node may still
     * have an impact in rendering. An opacity of 50% will render the node as
     * being 50% transparent.
     * &lt;p&gt;
     * A {@link #visibleProperty visible} node with any opacity setting still receives mouse
     * events and can receive keyboard focus. For example, if you want to have
     * a large invisible rectangle overlay all {@code Node}s in the scene graph
     * in order to intercept mouse events but not be visible to the user, you could
     * create a large {@code Rectangle} that had an opacity of 0%.
     * &lt;p&gt;
     * Opacity is specified as a value between 0 and 1. Values less than 0 are
     * treated as 0, values greater than 1 are treated as 1.
     * &lt;p&gt;
     * On some platforms ImageView might not support opacity variable.
     *
     * &lt;p&gt;
     * There is a known limitation of mixing opacity &amp;lt; 1.0 with a 3D Transform.
     * Opacity/Blending is essentially a 2D image operation. The result of
     * an opacity &amp;lt; 1.0 set on a {@link Group} node with 3D transformed children
     * will cause its children to be rendered in order without Z-buffering
     * applied between those children.
     *
     * @defaultValue 1.0
     */
    private DoubleProperty opacity;

    public final void setOpacity(double value) {
        opacityProperty().set(value);
    }
    public final double getOpacity() {
        return opacity == null ? 1 : opacity.get();
    }

    public final DoubleProperty opacityProperty() {
        if (opacity == null) {
            opacity = new StyleableDoubleProperty(1) {

                @Override
                public void invalidated() {
                    NodeHelper.markDirty(Node.this, DirtyBits.NODE_OPACITY);
                }

                @Override
                public CssMetaData getCssMetaData() {
                    return StyleableProperties.OPACITY;
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;opacity&quot;;
                }
            };
        }
        return opacity;
    }

    /**
     * The {@link javafx.scene.effect.BlendMode} used to blend this individual node
     * into the scene behind it. If this node happens to be a Group then all of the
     * children will be composited individually into a temporary buffer using their
     * own blend modes and then that temporary buffer will be composited into the
     * scene using the specified blend mode.
     *
     * A value of {@code null} is treated as pass-though this means no effect on a
     * parent such as a Group and the equivalent of SRC_OVER for a single Node.
     *
     * @defaultValue null
     */
    private javafx.beans.property.ObjectProperty&lt;BlendMode&gt; blendMode;

    public final void setBlendMode(BlendMode value) {
        blendModeProperty().set(value);
    }
    public final BlendMode getBlendMode() {
        return blendMode == null ? null : blendMode.get();
    }

    public final ObjectProperty&lt;BlendMode&gt; blendModeProperty() {
        if (blendMode == null) {
            blendMode = new StyleableObjectProperty&lt;BlendMode&gt;(null) {
                @Override public void invalidated() {
                    NodeHelper.markDirty(Node.this, DirtyBits.NODE_BLENDMODE);
                }

                @Override
                public CssMetaData getCssMetaData() {
                    return StyleableProperties.BLEND_MODE;
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;blendMode&quot;;
                }
            };
        }
        return blendMode;
    }

    public final void setClip(Node value) {
        clipProperty().set(value);
    }

    public final Node getClip() {
        return (miscProperties == null) ? DEFAULT_CLIP
                                        : miscProperties.getClip();
    }

    /**
     * Specifies a {@code Node} to use to define the the clipping shape for this
     * Node. This clipping Node is not a child of this {@code Node} in the scene
     * graph sense. Rather, it is used to define the clip for this {@code Node}.
     * &lt;p&gt;
     * For example, you can use an {@link javafx.scene.image.ImageView} Node as
     * a mask to represent the Clip. Or you could use one of the geometric shape
     * Nodes such as {@link javafx.scene.shape.Rectangle} or
     * {@link javafx.scene.shape.Circle}. Or you could use a
     * {@link javafx.scene.text.Text} node to represent the Clip.
     * &lt;p&gt;
     * See the class documentation for {@link Node} for scene graph structure
     * restrictions on setting the clip. If these restrictions are violated by
     * a change to the clip variable, the change is ignored and the
     * previous value of the clip variable is restored.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SHAPE_CLIP ConditionalFeature.SHAPE_CLIP}
     * for more information.
     * &lt;p&gt;
     * There is a known limitation of mixing Clip with a 3D Transform.
     * Clipping is essentially a 2D image operation. The result of
     * a Clip set on a {@link Group} node with 3D transformed children
     * will cause its children to be rendered in order without Z-buffering
     * applied between those children.
     *
     * @return the the clipping shape for this {@code Node}
     * @defaultValue null
     */
    public final ObjectProperty&lt;Node&gt; clipProperty() {
        return getMiscProperties().clipProperty();
    }

    public final void setCache(boolean value) {
        cacheProperty().set(value);
    }

    public final boolean isCache() {
        return (miscProperties == null) ? DEFAULT_CACHE
                                        : miscProperties.isCache();
    }

    /**
     * A performance hint to the system to indicate that this {@code Node}
     * should be cached as a bitmap. Rendering a bitmap representation of a node
     * will be faster than rendering primitives in many cases, especially in the
     * case of primitives with effects applied (such as a blur). However, it
     * also increases memory usage. This hint indicates whether that trade-off
     * (increased memory usage for increased performance) is worthwhile. Also
     * note that on some platforms such as GPU accelerated platforms there is
     * little benefit to caching Nodes as bitmaps when blurs and other effects
     * are used since they are very fast to render on the GPU.
     *
     * The {@link #cacheHintProperty} variable provides additional options for enabling
     * more aggressive bitmap caching.
     *
     * &lt;p&gt;
     * Caching may be disabled for any node that has a 3D transform on itself,
     * any of its ancestors, or any of its descendants.
     *
     * @return the hint to cache for this {@code Node}
     * @see #cacheHintProperty
     * @defaultValue false
     */
    public final BooleanProperty cacheProperty() {
        return getMiscProperties().cacheProperty();
    }

    public final void setCacheHint(CacheHint value) {
        cacheHintProperty().set(value);
    }

    public final CacheHint getCacheHint() {
        return (miscProperties == null) ? DEFAULT_CACHE_HINT
                                        : miscProperties.getCacheHint();
    }

    /**
     * Additional hint for controlling bitmap caching.
     * &lt;p&gt;
     * Under certain circumstances, such as animating nodes that are very
     * expensive to render, it is desirable to be able to perform
     * transformations on the node without having to regenerate the cached
     * bitmap.  An option in such cases is to perform the transforms on the
     * cached bitmap itself.
     * &lt;p&gt;
     * This technique can provide a dramatic improvement to animation
     * performance, though may also result in a reduction in visual quality.
     * The {@code cacheHint} variable provides a hint to the system about how
     * and when that trade-off (visual quality for animation performance) is
     * acceptable.
     * &lt;p&gt;
     * It is possible to enable the cacheHint only at times when your node is
     * animating.  In this way, expensive nodes can appear on screen with full
     * visual quality, yet still animate smoothly.
     * &lt;p&gt;
     * Example:
     * &lt;pre&gt;{@code
        expensiveNode.setCache(true);
        expensiveNode.setCacheHint(CacheHint.QUALITY);
        ...
        // Do an animation
        expensiveNode.setCacheHint(CacheHint.SPEED);
        new Timeline(
            new KeyFrame(Duration.seconds(2),
                new KeyValue(expensiveNode.scaleXProperty(), 2.0),
                new KeyValue(expensiveNode.scaleYProperty(), 2.0),
                new KeyValue(expensiveNode.rotateProperty(), 360),
                new KeyValue(expensiveNode.cacheHintProperty(), CacheHint.QUALITY)
            )
        ).play();
     }&lt;/pre&gt;
     *
     * Note that {@code cacheHint} is only a hint to the system.  Depending on
     * the details of the node or the transform, this hint may be ignored.
     *
     * &lt;p&gt;
     * If {@code Node.cache} is false, cacheHint is ignored.
     * Caching may be disabled for any node that has a 3D transform on itself,
     * any of its ancestors, or any of its descendants.
     *
     * @return the {@code CacheHint} for this {@code Node}
     * @see #cacheProperty
     * @defaultValue CacheHint.DEFAULT
     */
    public final ObjectProperty&lt;CacheHint&gt; cacheHintProperty() {
        return getMiscProperties().cacheHintProperty();
    }

    public final void setEffect(Effect value) {
        effectProperty().set(value);
    }

    public final Effect getEffect() {
        return (miscProperties == null) ? DEFAULT_EFFECT
                                        : miscProperties.getEffect();
    }

    /**
     * Specifies an effect to apply to this {@code Node}.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#EFFECT ConditionalFeature.EFFECT}
     * for more information.
     *
     * &lt;p&gt;
     * There is a known limitation of mixing Effect with a 3D Transform. Effect is
     * essentially a 2D image operation. The result of an Effect set on
     * a {@link Group} node with 3D transformed children will cause its children
     * to be rendered in order without Z-buffering applied between those
     * children.
     *
     * @return the effect for this {@code Node}
     * @defaultValue null
     */
    public final ObjectProperty&lt;Effect&gt; effectProperty() {
        return getMiscProperties().effectProperty();
    }

    public final void setDepthTest(DepthTest value) {
        depthTestProperty().set(value);
    }

    public final DepthTest getDepthTest() {
        return (miscProperties == null) ? DEFAULT_DEPTH_TEST
                                        : miscProperties.getDepthTest();
    }

    /**
     * Indicates whether depth testing is used when rendering this node.
     * If the depthTest flag is {@code DepthTest.DISABLE}, then depth testing
     * is disabled for this node.
     * If the depthTest flag is {@code DepthTest.ENABLE}, then depth testing
     * is enabled for this node.
     * If the depthTest flag is {@code DepthTest.INHERIT}, then depth testing
     * is enabled for this node if it is enabled for the parent node or the
     * parent node is null.
     * &lt;p&gt;
     * The depthTest flag is only used when the depthBuffer flag for
     * the {@link Scene} is true (meaning that the
     * {@link Scene} has an associated depth buffer)
     * &lt;p&gt;
     * Depth test comparison is only done among nodes with depthTest enabled.
     * A node with depthTest disabled does not read, test, or write the depth buffer,
     * that is to say its Z value will not be considered for depth testing
     * with other nodes.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     * &lt;p&gt;
     * See the constructor in Scene with depthBuffer as one of its input
     * arguments.
     *
     * @return the depth test setting for this {@code Node}
     * @see javafx.scene.Scene
     * @defaultValue INHERIT
     */
    public final ObjectProperty&lt;DepthTest&gt; depthTestProperty() {
        return getMiscProperties().depthTestProperty();
    }

    /**
     * Recompute the derived depth test flag. This flag is true
     * if the depthTest flag for this node is true and the
     * depth test flag for each ancestor node is true. It is false
     * otherwise. Equivalently, the derived depth flag is true
     * if the depthTest flag for this node is true and the derivedDepthTest
     * flag for its parent is true.
     */
    void computeDerivedDepthTest() {
        boolean newDDT;
        if (getDepthTest() == DepthTest.INHERIT) {
            if (getParent() != null) {
                newDDT = getParent().isDerivedDepthTest();
            } else {
                newDDT = true;
            }
        } else if (getDepthTest() == DepthTest.ENABLE) {
            newDDT = true;
        } else {
            newDDT = false;
        }

        if (isDerivedDepthTest() != newDDT) {
            NodeHelper.markDirty(this, DirtyBits.NODE_DEPTH_TEST);
            setDerivedDepthTest(newDDT);
        }
    }

    // This is the derived depthTest value to pass to PG level
    private boolean derivedDepthTest = true;

    void setDerivedDepthTest(boolean value) {
        derivedDepthTest = value;
    }

    boolean isDerivedDepthTest() {
        return derivedDepthTest;
    }

    public final void setDisable(boolean value) {
        disableProperty().set(value);
    }

    public final boolean isDisable() {
        return (miscProperties == null) ? DEFAULT_DISABLE
                                        : miscProperties.isDisable();
    }

    /**
     * Defines the individual disabled state of this {@code Node}. Setting
     * {@code disable} to true will cause this {@code Node} and any subnodes to
     * become disabled. This property should be used only to set the disabled
     * state of a {@code Node}.  For querying the disabled state of a
     * {@code Node}, the {@link #disabledProperty disabled} property should instead be used,
     * since it is possible that a {@code Node} was disabled as a result of an
     * ancestor being disabled even if the individual {@code disable} state on
     * this {@code Node} is {@code false}.
     *
     * @return the disabled state for this {@code Node}
     * @defaultValue false
     */
    public final BooleanProperty disableProperty() {
        return getMiscProperties().disableProperty();
    }


//    /**
//     * TODO document - null by default, could be non-null in subclasses (e.g. Control)
//     */
//    public final ObjectProperty&lt;InputMap&lt;?&gt;&gt; inputMapProperty() {
//        if (inputMap == null) {
//            inputMap = new SimpleObjectProperty&lt;InputMap&lt;?&gt;&gt;(this, &quot;inputMap&quot;) {
//                private InputMap&lt;?&gt; currentMap = get();
//                @Override protected void invalidated() {
//                    if (currentMap != null) {
//                        currentMap.dispose();
//                    }
//                    currentMap = get();
//                }
//            };
//        }
//        return inputMap;
//    }
//    public final void setInputMap(InputMap&lt;?&gt; value) { inputMapProperty().set(value); }
//    public final InputMap&lt;?&gt; getInputMap() { return inputMapProperty().getValue(); }
//    private ObjectProperty&lt;InputMap&lt;?&gt;&gt; inputMap;


    /**************************************************************************
     *                                                                        *
     *
     *                                                                        *
     *************************************************************************/
    /**
     * Defines how the picking computation is done for this node when
     * triggered by a {@code MouseEvent} or a {@code contains} function call.
     *
     * If {@code pickOnBounds} is {@code true}, then picking is computed by
     * intersecting with the bounds of this node, else picking is computed
     * by intersecting with the geometric shape of this node.
     *
     * The default value of this property is {@code false} unless
     * overridden by a subclass. The default value is {@code true}
     * for {@link javafx.scene.layout.Region}.
     *
     * @defaultValue false; true for {@code Region}
     */
    private BooleanProperty pickOnBounds;

    public final void setPickOnBounds(boolean value) {
        pickOnBoundsProperty().set(value);
    }

    public final boolean isPickOnBounds() {
        return pickOnBounds == null ? false : pickOnBounds.get();
    }

    public final BooleanProperty pickOnBoundsProperty() {
        if (pickOnBounds == null) {
            pickOnBounds = new SimpleBooleanProperty(this, &quot;pickOnBounds&quot;);
        }
        return pickOnBounds;
    }

    /**
     * Indicates whether or not this {@code Node} is disabled.  A {@code Node}
     * will become disabled if {@link #disableProperty disable} is set to {@code true} on either
     * itself or one of its ancestors in the scene graph.
     * &lt;p&gt;
     * A disabled {@code Node} should render itself differently to indicate its
     * disabled state to the user.
     * Such disabled rendering is dependent on the implementation of the
     * {@code Node}. The shape classes contained in {@code javafx.scene.shape}
     * do not implement such rendering by default, therefore applications using
     * shapes for handling input must implement appropriate disabled rendering
     * themselves. The user-interface controls defined in
     * {@code javafx.scene.control} will implement disabled-sensitive rendering,
     * however.
     * &lt;p&gt;
     * A disabled {@code Node} does not receive mouse or key events.
     *
     * @defaultValue false
     */
    private ReadOnlyBooleanWrapper disabled;

    protected final void setDisabled(boolean value) {
        disabledPropertyImpl().set(value);
    }

    public final boolean isDisabled() {
        return disabled == null ? false : disabled.get();
    }

    public final ReadOnlyBooleanProperty disabledProperty() {
        return disabledPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyBooleanWrapper disabledPropertyImpl() {
        if (disabled == null) {
            disabled = new ReadOnlyBooleanWrapper() {

                @Override
                protected void invalidated() {
                    pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, get());
                    updateCanReceiveFocus();
                    focusSetDirty(getScene());
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;disabled&quot;;
                }
            };
        }
        return disabled;
    }

    private void updateDisabled() {
        boolean isDisabled = isDisable();
        if (!isDisabled) {
            isDisabled = getParent() != null ? getParent().isDisabled() :
                    getSubScene() != null &amp;&amp; getSubScene().isDisabled();
        }
        setDisabled(isDisabled);
        if (this instanceof SubScene) {
            ((SubScene)this).getRoot().setDisabled(isDisabled);
        }
    }

    /**
     * Finds this {@code Node}, or the first sub-node, based on the given CSS selector.
     * If this node is a {@code Parent}, then this function will traverse down
     * into the branch until it finds a match. If more than one sub-node matches the
     * specified selector, this function returns the first of them.
     * &lt;p&gt;
     *     For example, if a Node is given the id of &quot;myId&quot;, then the lookup method can
     *     be used to find this node as follows: &lt;code&gt;scene.lookup(&quot;#myId&quot;);&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param selector The css selector of the node to find
     * @return The first node, starting from this {@code Node}, which matches
     *         the CSS {@code selector}, null if none is found.
     */
    public Node lookup(String selector) {
        if (selector == null) return null;
        Selector s = Selector.createSelector(selector);
        return s != null &amp;&amp; s.applies(this) ? this : null;
    }

    /**
     * Finds all {@code Node}s, including this one and any children, which match
     * the given CSS selector. If no matches are found, an empty unmodifiable set is
     * returned. The set is explicitly unordered.
     *
     * @param selector The css selector of the nodes to find
     * @return All nodes, starting from and including this {@code Node}, which match
     *         the CSS {@code selector}. The returned set is always unordered and
     *         unmodifiable, and never null.
     */
    public Set&lt;Node&gt; lookupAll(String selector) {
        final Selector s = Selector.createSelector(selector);
        final Set&lt;Node&gt; empty = Collections.emptySet();
        if (s == null) return empty;
        List&lt;Node&gt; results = lookupAll(s, null);
        return results == null ? empty : new UnmodifiableListSet&lt;Node&gt;(results);
    }

    /**
     * Used by Node and Parent for traversing the tree and adding all nodes which
     * match the given selector.
     *
     * @param selector The Selector. This will never be null.
     * @param results The results. This will never be null.
     */
    List&lt;Node&gt; lookupAll(Selector selector, List&lt;Node&gt; results) {
        if (selector.applies(this)) {
            // Lazily create the set to reduce some trash.
            if (results == null) {
                results = new LinkedList&lt;Node&gt;();
            }
            results.add(this);
        }
        return results;
    }

    /**
     * Moves this {@code Node} to the back of its sibling nodes in terms of
     * z-order.  This is accomplished by moving this {@code Node} to the
     * first position in its parent's {@code content} ObservableList.
     * This function has no effect if this {@code Node} is not part of a group.
     */
    public void toBack() {
        if (getParent() != null) {
            getParent().toBack(this);
        }
    }

    /**
     * Moves this {@code Node} to the front of its sibling nodes in terms of
     * z-order.  This is accomplished by moving this {@code Node} to the
     * last position in its parent's {@code content} ObservableList.
     * This function has no effect if this {@code Node} is not part of a group.
     */
    public void toFront() {
        if (getParent() != null) {
            getParent().toFront(this);
        }
    }

    // TODO: need to verify whether this is OK to do starting from a node in
    // the scene graph other than the root.
    private void doCSSPass() {
        if (this.cssFlag != CssFlags.CLEAN) {
            // The dirty bit isn't checked but we must ensure it is cleared.
            // The cssFlag is set to clean in either Node.processCSS or
            // NodeHelper.processCSS

            // Don't clear the dirty bit in case it will cause problems
            // with a full CSS pass on the scene.
            // TODO: is this the right thing to do?
            // this.clearDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);

            this.processCSS();
        }
    }

    /**
     * Recursive function for synchronizing a node and all descendents
     */
    private static void syncAll(Node node) {
        node.syncPeer();
        if (node instanceof Parent) {
            Parent p = (Parent) node;
            final int childrenCount = p.getChildren().size();

            for (int i = 0; i &lt; childrenCount; i++) {
                Node n = p.getChildren().get(i);
                if (n != null) {
                    syncAll(n);
                }
            }
        }
        if (node.getClip() != null) {
            syncAll(node.getClip());
        }
    }

    private void doLayoutPass() {
        if (this instanceof Parent) {
            // TODO: As an optimization we only need to layout those dirty
            // roots that are descendants of this node
            Parent p = (Parent)this;
            for (int i = 0; i &lt; 3; i++) {
                p.layout();
            }
        }
    }

    private void doCSSLayoutSyncForSnapshot() {
        doCSSPass();
        doLayoutPass();
        updateBounds();
        Scene.setAllowPGAccess(true);
        syncAll(this);
        Scene.setAllowPGAccess(false);
    }

    private WritableImage doSnapshot(SnapshotParameters params, WritableImage img) {
        if (getScene() != null) {
            getScene().doCSSLayoutSyncForSnapshot(this);
        } else {
            doCSSLayoutSyncForSnapshot();
        }

        BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;
        if (params.getTransform() != null) {
            Affine3D tempTx = new Affine3D();
            TransformHelper.apply(params.getTransform(), tempTx);
            transform = tempTx;
        }
        double x;
        double y;
        double w;
        double h;
        Rectangle2D viewport = params.getViewport();
        if (viewport != null) {
            // Use the specified viewport
            x = viewport.getMinX();
            y = viewport.getMinY();
            w = viewport.getWidth();
            h = viewport.getHeight();
        } else {
            // Get the bounds in parent of this node, transformed by the
            // specified transform.
            BaseBounds tempBounds = TempState.getInstance().bounds;
            tempBounds = getTransformedBounds(tempBounds, transform);
            x = tempBounds.getMinX();
            y = tempBounds.getMinY();
            w = tempBounds.getWidth();
            h = tempBounds.getHeight();
        }
        WritableImage result = Scene.doSnapshot(getScene(), x, y, w, h,
                this, transform, params.isDepthBufferInternal(),
                params.getFill(), params.getEffectiveCamera(), img);

        return result;
    }

    /**
     * Takes a snapshot of this node and returns the rendered image when
     * it is ready.
     * CSS and layout processing will be done for the node, and any of its
     * children, prior to rendering it.
     * The entire destination image is cleared to the fill {@code Paint}
     * specified by the SnapshotParameters. This node is then rendered to
     * the image.
     * If the viewport specified by the SnapshotParameters is null, the
     * upper-left pixel of the {@code boundsInParent} of this
     * node, after first applying the transform specified by the
     * SnapshotParameters,
     * is mapped to the upper-left pixel (0,0) in the image.
     * If a non-null viewport is specified,
     * the upper-left pixel of the viewport is mapped to upper-left pixel
     * (0,0) in the image.
     * In both cases, this mapping to (0,0) of the image is done with an integer
     * translation. The portion of the node that is outside of the rendered
     * image will be clipped by the image.
     *
     * &lt;p&gt;
     * When taking a snapshot of a scene that is being animated, either
     * explicitly by the application or implicitly (such as chart animation),
     * the snapshot will be rendered based on the state of the scene graph at
     * the moment the snapshot is taken and will not reflect any subsequent
     * animation changes.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * NOTE: In order for CSS and layout to function correctly, the node
     * must be part of a Scene (the Scene may be attached to a Stage, but need
     * not be).
     * &lt;/p&gt;
     *
     * @param params the snapshot parameters containing attributes that
     * will control the rendering. If the SnapshotParameters object is null,
     * then the Scene's attributes will be used if this node is part of a scene,
     * or default attributes will be used if this node is not part of a scene.
     *
     * @param image the writable image that will be used to hold the rendered node.
     * It may be null in which case a new WritableImage will be constructed.
     * The new image is constructed using integer width and
     * height values that are derived either from the transformed bounds of this
     * Node or from the size of the viewport as specified in the
     * SnapShotParameters. These integer values are chosen such that the image
     * will wholly contain the bounds of this Node or the specified viewport.
     * If the image is non-null, the node will be rendered into the
     * existing image.
     * In this case, the width and height of the image determine the area
     * that is rendered instead of the width and height of the bounds or
     * viewport.
     *
     * @throws IllegalStateException if this method is called on a thread
     *     other than the JavaFX Application Thread.
     *
     * @return the rendered image
     * @since JavaFX 2.2
     */
    public WritableImage snapshot(SnapshotParameters params, WritableImage image) {
        Toolkit.getToolkit().checkFxUserThread();

        if (params == null) {
            params = new SnapshotParameters();
            Scene s = getScene();
            if (s != null) {
                params.setCamera(s.getEffectiveCamera());
                params.setDepthBuffer(s.isDepthBufferInternal());
                params.setFill(s.getFill());
            }
        }

        return doSnapshot(params, image);
    }

    /**
     * Takes a snapshot of this node at the next frame and calls the
     * specified callback method when the image is ready.
     * CSS and layout processing will be done for the node, and any of its
     * children, prior to rendering it.
     * The entire destination image is cleared to the fill {@code Paint}
     * specified by the SnapshotParameters. This node is then rendered to
     * the image.
     * If the viewport specified by the SnapshotParameters is null, the
     * upper-left pixel of the {@code boundsInParent} of this
     * node, after first applying the transform specified by the
     * SnapshotParameters,
     * is mapped to the upper-left pixel (0,0) in the image.
     * If a non-null viewport is specified,
     * the upper-left pixel of the viewport is mapped to upper-left pixel
     * (0,0) in the image.
     * In both cases, this mapping to (0,0) of the image is done with an integer
     * translation. The portion of the node that is outside of the rendered
     * image will be clipped by the image.
     *
     * &lt;p&gt;
     * This is an asynchronous call, which means that other
     * events or animation might be processed before the node is rendered.
     * If any such events modify the node, or any of its children, that
     * modification will be reflected in the rendered image (just like it
     * will also be reflected in the frame rendered to the Stage, if this node
     * is part of a live scene graph).
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * When taking a snapshot of a node that is being animated, either
     * explicitly by the application or implicitly (such as chart animation),
     * the snapshot will be rendered based on the state of the scene graph at
     * the moment the snapshot is taken and will not reflect any subsequent
     * animation changes.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * NOTE: In order for CSS and layout to function correctly, the node
     * must be part of a Scene (the Scene may be attached to a Stage, but need
     * not be).
     * &lt;/p&gt;
     *
     * @param callback a class whose call method will be called when the image
     * is ready. The SnapshotResult that is passed into the call method of
     * the callback will contain the rendered image, the source node
     * that was rendered, and a copy of the SnapshotParameters.
     * The callback parameter must not be null.
     *
     * @param params the snapshot parameters containing attributes that
     * will control the rendering. If the SnapshotParameters object is null,
     * then the Scene's attributes will be used if this node is part of a scene,
     * or default attributes will be used if this node is not part of a scene.
     *
     * @param image the writable image that will be used to hold the rendered node.
     * It may be null in which case a new WritableImage will be constructed.
     * The new image is constructed using integer width and
     * height values that are derived either from the transformed bounds of this
     * Node or from the size of the viewport as specified in the
     * SnapShotParameters. These integer values are chosen such that the image
     * will wholly contain the bounds of this Node or the specified viewport.
     * If the image is non-null, the node will be rendered into the
     * existing image.
     * In this case, the width and height of the image determine the area
     * that is rendered instead of the width and height of the bounds or
     * viewport.
     *
     * @throws IllegalStateException if this method is called on a thread
     *     other than the JavaFX Application Thread.
     *
     * @throws NullPointerException if the callback parameter is null.
     * @since JavaFX 2.2
     */
    public void snapshot(Callback&lt;SnapshotResult, Void&gt; callback,
            SnapshotParameters params, WritableImage image) {

        Toolkit.getToolkit().checkFxUserThread();
        if (callback == null) {
            throw new NullPointerException(&quot;The callback must not be null&quot;);
        }

        if (params == null) {
            params = new SnapshotParameters();
            Scene s = getScene();
            if (s != null) {
                params.setCamera(s.getEffectiveCamera());
                params.setDepthBuffer(s.isDepthBufferInternal());
                params.setFill(s.getFill());
            }
        } else {
            params = params.copy();
        }

        final SnapshotParameters theParams = params;
        final Callback&lt;SnapshotResult, Void&gt; theCallback = callback;
        final WritableImage theImage = image;

        // Create a deferred runnable that will be run from a pulse listener
        // that is called after all of the scenes have been synced but before
        // any of them have been rendered.
        final Runnable snapshotRunnable = () -&gt; {
            WritableImage img = doSnapshot(theParams, theImage);
            SnapshotResult result = new SnapshotResult(img, Node.this, theParams);
//                System.err.println(&quot;Calling snapshot callback&quot;);
            try {
                Void v = theCallback.call(result);
            } catch (Throwable th) {
                System.err.println(&quot;Exception in snapshot callback&quot;);
                th.printStackTrace(System.err);
            }
        };

//        System.err.println(&quot;Schedule a snapshot in the future&quot;);
        Scene.addSnapshotRunnable(snapshotRunnable);
    }

    /* ************************************************************************
     *                                                                        *
     *
     *                                                                        *
     *************************************************************************/

    public final void setOnDragEntered(
            EventHandler&lt;? super DragEvent&gt; value) {
        onDragEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragEntered() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragEntered();
    }

    /**
     * Defines a function to be called when drag gesture
     * enters this {@code Node}.
     * @return the event handler that is called when drag gesture enters this
     * {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
            onDragEnteredProperty() {
        return getEventHandlerProperties().onDragEnteredProperty();
    }

    public final void setOnDragExited(
            EventHandler&lt;? super DragEvent&gt; value) {
        onDragExitedProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragExited() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragExited();
    }

    /**
     * Defines a function to be called when drag gesture
     * exits this {@code Node}.
     * @return the event handler that is called when drag gesture exits this
     * {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
            onDragExitedProperty() {
        return getEventHandlerProperties().onDragExitedProperty();
    }

    public final void setOnDragOver(
            EventHandler&lt;? super DragEvent&gt; value) {
        onDragOverProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragOver() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragOver();
    }

    /**
     * Defines a function to be called when drag gesture progresses within
     * this {@code Node}.
     * @return the event handler that is called when drag gesture progresses
     * within this {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
            onDragOverProperty() {
        return getEventHandlerProperties().onDragOverProperty();
    }

    // Do we want DRAG_TRANSFER_MODE_CHANGED event?
//    public final void setOnDragTransferModeChanged(
//            EventHandler&lt;? super DragEvent&gt; value) {
//        onDragTransferModeChangedProperty().set(value);
//    }
//
//    public final EventHandler&lt;? super DragEvent&gt; getOnDragTransferModeChanged() {
//        return (eventHandlerProperties == null)
//                ? null : eventHandlerProperties.getOnDragTransferModeChanged();
//    }
//
//    /**
//     * Defines a function to be called this {@code Node} if it is a potential
//     * drag-and-drop target when the user takes action to change the intended
//     * {@code TransferMode}.
//     * The user can change the intended {@link TransferMode} by holding down
//     * or releasing key modifiers.
//     */
//    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
//            onDragTransferModeChangedProperty() {
//        return getEventHandlerProperties().onDragTransferModeChangedProperty();
//    }

    public final void setOnDragDropped(
            EventHandler&lt;? super DragEvent&gt; value) {
        onDragDroppedProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragDropped() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragDropped();
    }

    /**
     * Defines a function to be called when the mouse button is released
     * on this {@code Node} during drag and drop gesture. Transfer of data from
     * the {@link DragEvent}'s {@link DragEvent#getDragboard() dragboard} should
     * happen in this function.
     * @return the event handler that is called when the mouse button is
     * released on this {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
            onDragDroppedProperty() {
        return getEventHandlerProperties().onDragDroppedProperty();
    }

    public final void setOnDragDone(
            EventHandler&lt;? super DragEvent&gt; value) {
        onDragDoneProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragDone() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragDone();
    }

    /**
     * Defines a function to be called when this {@code Node} is a
     * drag and drop gesture source after its data has
     * been dropped on a drop target. The {@code transferMode} of the
     * event shows what just happened at the drop target.
     * If {@code transferMode} has the value {@code MOVE}, then the source can
     * clear out its data. Clearing the source's data gives the appropriate
     * appearance to a user that the data has been moved by the drag and drop
     * gesture. A {@code transferMode} that has the value {@code NONE}
     * indicates that no data was transferred during the drag and drop gesture.
     * @return the event handler that is called when this {@code Node} is a drag
     * and drop gesture source after its data has been dropped on a drop target
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
            onDragDoneProperty() {
        return getEventHandlerProperties().onDragDoneProperty();
    }

    /**
     * Confirms a potential drag and drop gesture that is recognized over this
     * {@code Node}.
     * Can be called only from a DRAG_DETECTED event handler. The returned
     * {@link Dragboard} is used to transfer data during
     * the drag and drop gesture. Placing this {@code Node}'s data on the
     * {@link Dragboard} also identifies this {@code Node} as the source of
     * the drag and drop gesture.
     * More detail about drag and drop gestures is described in the overivew
     * of {@link DragEvent}.
     *
     * @see DragEvent
     * @param transferModes The supported {@code TransferMode}(s) of this {@code Node}
     * @return A {@code Dragboard} to place this {@code Node}'s data on
     * @throws IllegalStateException if drag and drop cannot be started at this
     * moment (it's called outside of {@code DRAG_DETECTED} event handling or
     * this node is not in scene).
     */
    public Dragboard startDragAndDrop(TransferMode... transferModes) {
        if (getScene() != null) {
            return getScene().startDragAndDrop(this, transferModes);
        }

        throw new IllegalStateException(&quot;Cannot start drag and drop on node &quot;
                + &quot;that is not in scene&quot;);
    }

    /**
     * Starts a full press-drag-release gesture with this node as gesture
     * source. This method can be called only from a {@code DRAG_DETECTED} mouse
     * event handler. More detail about dragging gestures can be found
     * in the overview of {@link MouseEvent} and {@link MouseDragEvent}.
     *
     * @see MouseEvent
     * @see MouseDragEvent
     * @throws IllegalStateException if the full press-drag-release gesture
     * cannot be started at this moment (it's called outside of
     * {@code DRAG_DETECTED} event handling or this node is not in scene).
     * @since JavaFX 2.1
     */
    public void startFullDrag() {
        if (getScene() != null) {
            getScene().startFullDrag(this);
            return;
        }

        throw new IllegalStateException(&quot;Cannot start full drag on node &quot;
                + &quot;that is not in scene&quot;);
    }

    ////////////////////////////
    //  Private Implementation
    ////////////////////////////

    /**
     * If this Node is being used as the clip of another Node, that other node
     * is referred to as the clipParent. If the boundsInParent of this Node
     * changes, it must update the clipParent's bounds as well.
     */
    private Node clipParent;
    // Use a getter function instead of giving clipParent package access,
    // so that clipParent doesn't get turned into a Location.
    final Node getClipParent() {
        return clipParent;
    }

    /**
     * Determines whether this node is connected anywhere in the scene graph.
     */
    boolean isConnected() {
        // don't need to check scene, because if scene is non-null
        // parent must also be non-null
        return getParent() != null || clipParent != null;
    }

    /**
     * Tests whether creating a parent-child relationship between these
     * nodes would cause a cycle. The parent relationship includes not only
     * the &quot;real&quot; parent (child of Group) but also the clipParent.
     */
    boolean wouldCreateCycle(Node parent, Node child) {
        if (child != null &amp;&amp; child.getClip() == null &amp;&amp; (!(child instanceof Parent))) {
            return false;
    }

        Node n = parent;
        while (n != child) {
            if (n.getParent() != null) {
                n = n.getParent();
            } else if (n.getSubScene() != null) {
                n = n.getSubScene();
            } else if (n.clipParent != null) {
                n = n.clipParent;
            } else {
                return false;
            }
        }
        return true;
    }

    /**
     * The peer node created by the graphics Toolkit/Pipeline implementation
     */
    private NGNode peer;

    @SuppressWarnings(&quot;CallToPrintStackTrace&quot;)
    &lt;P extends NGNode&gt; P getPeer() {
        if (Utils.assertionEnabled()) {
            // Assertion checking code
            if (getScene() != null &amp;&amp; !Scene.isPGAccessAllowed()) {
                java.lang.System.err.println();
                java.lang.System.err.println(&quot;*** unexpected PG access&quot;);
                java.lang.Thread.dumpStack();
            }
        }

        if (peer == null) {
            //if (PerformanceTracker.isLoggingEnabled()) {
            //    PerformanceTracker.logEvent(&quot;Creating NGNode for [{this}, id=\&quot;{id}\&quot;]&quot;);
            //}
            peer = NodeHelper.createPeer(this);
            //if (PerformanceTracker.isLoggingEnabled()) {
            //    PerformanceTracker.logEvent(&quot;NGNode created&quot;);
            //}
        }
        return (P) peer;
    }

    /***************************************************************************
     *                                                                         *
     *                              Initialization                             *
     *                                                                         *
     *  To Note limit the number of bounds computations and improve startup    *
     *  performance.                                                           *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new instance of Node.
     */
    protected Node() {
        //if (PerformanceTracker.isLoggingEnabled()) {
        //    PerformanceTracker.logEvent(&quot;Node.init for [{this}, id=\&quot;{id}\&quot;]&quot;);
        //}
        setDirty();
        updateTreeVisible(false);
        //if (PerformanceTracker.isLoggingEnabled()) {
        //    PerformanceTracker.logEvent(&quot;Node.postinit &quot; +
        //                                &quot;for [{this}, id=\&quot;{id}\&quot;] finished&quot;);
        //}
    }

    /***************************************************************************
     *                                                                         *
     * Layout related APIs.                                                    *
     *                                                                         *
     **************************************************************************/
    /**
     * Defines whether or not this node's layout will be managed by it's parent.
     * If the node is managed, it's parent will factor the node's geometry
     * into its own preferred size and {@link #layoutBoundsProperty layoutBounds}
     * calculations and will lay it
     * out during the scene's layout pass.  If a managed node's layoutBounds
     * changes, it will automatically trigger relayout up the scene-graph
     * to the nearest layout root (which is typically the scene's root node).
     * &lt;p&gt;
     * If the node is unmanaged, its parent will ignore the child in both preferred
     * size computations and layout.   Changes in layoutBounds will not trigger
     * relayout above it.   If an unmanaged node is of type {@link javafx.scene.Parent Parent},
     * it will act as a &quot;layout root&quot;, meaning that calls to {@link Parent#requestLayout()}
     * beneath it will cause only the branch rooted by the node to be relayed out,
     * thereby isolating layout changes to that root and below.  It's the application's
     * responsibility to set the size and position of an unmanaged node.
     * &lt;p&gt;
     * By default all nodes are managed.
     * &lt;/p&gt;
     *
     * @see #isResizable()
     * @see #layoutBoundsProperty()
     * @see Parent#requestLayout()
     *
     */
    private BooleanProperty managed;

    public final void setManaged(boolean value) {
        managedProperty().set(value);
    }

    public final boolean isManaged() {
        return managed == null ? true : managed.get();
    }

    public final BooleanProperty managedProperty() {
        if (managed == null) {
            managed = new BooleanPropertyBase(true) {

                @Override
                protected void invalidated() {
                    final Parent parent = getParent();
                    if (parent != null) {
                        parent.managedChildChanged();
                    }
                    notifyManagedChanged();
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;managed&quot;;
                }

            };
        }
        return managed;
    }

    /**
     * Called whenever the &quot;managed&quot; flag has changed. This is only
     * used by Parent as an optimization to keep track of whether a
     * Parent node is a layout root or not.
     */
    void notifyManagedChanged() { }

    /**
     * Defines the x coordinate of the translation that is added to this {@code Node}'s
     * transform for the purpose of layout. The value should be computed as the
     * offset required to adjust the position of the node from its current
     * {@link #layoutBoundsProperty() layoutBounds minX} position (which might not be 0) to the desired location.
     *
     * &lt;p&gt;For example, if {@code textnode} should be positioned at {@code finalX}
     * &lt;pre&gt;{@code
     *     textnode.setLayoutX(finalX - textnode.getLayoutBounds().getMinX());
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * Failure to subtract {@code layoutBounds minX} may result in misplacement
     * of the node.  The {@link #relocate(double, double) relocate(x, y)} method will automatically do the
     * correct computation and should generally be used over setting layoutX directly.
     * &lt;p&gt;
     * The node's final translation will be computed as {@code layoutX} + {@link #translateXProperty translateX},
     * where {@code layoutX} establishes the node's stable position
     * and {@code translateX} optionally makes dynamic adjustments to that
     * position.
     * &lt;p&gt;
     * If the node is managed and has a {@link javafx.scene.layout.Region}
     * as its parent, then the layout region will set {@code layoutX} according to its
     * own layout policy.   If the node is unmanaged or parented by a {@link Group},
     * then the application may set {@code layoutX} directly to position it.
     *
     * @see #relocate(double, double)
     * @see #layoutBoundsProperty()
     *
     */
    private DoubleProperty layoutX;

    public final void setLayoutX(double value) {
        layoutXProperty().set(value);
    }

    public final double getLayoutX() {
        return layoutX == null ? 0.0 : layoutX.get();
    }

    public final DoubleProperty layoutXProperty() {
        if (layoutX == null) {
            layoutX = new DoublePropertyBase(0.0) {

                @Override
                protected void invalidated() {
                    NodeHelper.transformsChanged(Node.this);
                    final Parent p = getParent();

                    // Propagate layout if this change isn't triggered by its parent
                    if (p != null &amp;&amp; !p.isCurrentLayoutChild(Node.this)) {
                        if (isManaged()) {
                            // Force its parent to fix the layout since it is a managed child.
                            p.requestLayout(true);
                        } else {
                            // Parent size changed, parent's parent might need to re-layout
                            p.clearSizeCache();
                            p.requestParentLayout();
                        }
                    }
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;layoutX&quot;;
                }
            };
        }
        return layoutX;
    }

    /**
     * Defines the y coordinate of the translation that is added to this {@code Node}'s
     * transform for the purpose of layout. The value should be computed as the
     * offset required to adjust the position of the node from its current
     * {@link #layoutBoundsProperty() layoutBounds minY} position (which might not be 0) to the desired location.
     *
     * &lt;p&gt;For example, if {@code textnode} should be positioned at {@code finalY}
     * &lt;pre&gt;{@code
     *     textnode.setLayoutY(finalY - textnode.getLayoutBounds().getMinY());
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * Failure to subtract {@code layoutBounds minY} may result in misplacement
     * of the node.  The {@link #relocate(double, double) relocate(x, y)} method will automatically do the
     * correct computation and should generally be used over setting layoutY directly.
     * &lt;p&gt;
     * The node's final translation will be computed as {@code layoutY} + {@link #translateYProperty translateY},
     * where {@code layoutY} establishes the node's stable position
     * and {@code translateY} optionally makes dynamic adjustments to that
     * position.
     * &lt;p&gt;
     * If the node is managed and has a {@link javafx.scene.layout.Region}
     * as its parent, then the region will set {@code layoutY} according to its
     * own layout policy.   If the node is unmanaged or parented by a {@link Group},
     * then the application may set {@code layoutY} directly to position it.
     *
     * @see #relocate(double, double)
     * @see #layoutBoundsProperty()
     */
    private DoubleProperty layoutY;

    public final void setLayoutY(double value) {
        layoutYProperty().set(value);
    }

    public final double getLayoutY() {
        return layoutY == null ? 0.0 : layoutY.get();
    }

    public final DoubleProperty layoutYProperty() {
        if (layoutY == null) {
            layoutY = new DoublePropertyBase(0.0) {

                @Override
                protected void invalidated() {
                    NodeHelper.transformsChanged(Node.this);
                    final Parent p = getParent();

                    // Propagate layout if this change isn't triggered by its parent
                    if (p != null &amp;&amp; !p.isCurrentLayoutChild(Node.this)) {
                        if (isManaged()) {
                            // Force its parent to fix the layout since it is a managed child.
                            p.requestLayout(true);
                        } else {
                            // Parent size changed, parent's parent might need to re-layout
                            p.clearSizeCache();
                            p.requestParentLayout();
                        }
                    }
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;layoutY&quot;;
                }

            };
        }
        return layoutY;
    }

    /**
     * Sets the node's layoutX and layoutY translation properties in order to
     * relocate this node to the x,y location in the parent.
     * &lt;p&gt;
     * This method does not alter translateX or translateY, which if also set
     * will be added to layoutX and layoutY, adjusting the final location by
     * corresponding amounts.
     *
     * @param x the target x coordinate location
     * @param y the target y coordinate location
     */
    public void relocate(double x, double y) {
        setLayoutX(x - getLayoutBounds().getMinX());
        setLayoutY(y - getLayoutBounds().getMinY());

        PlatformLogger logger = Logging.getLayoutLogger();
        if (logger.isLoggable(Level.FINER)) {
            logger.finer(this.toString()+&quot; moved to (&quot;+x+&quot;,&quot;+y+&quot;)&quot;);
        }
    }

    /**
     * Indicates whether this node is a type which can be resized by its parent.
     * If this method returns true, then the parent will resize the node (ideally
     * within its size range) by calling node.resize(width,height) during the
     * layout pass.  All Regions, Controls, and WebView are resizable classes
     * which depend on their parents resizing them during layout once all sizing
     * and CSS styling information has been applied.
     * &lt;p&gt;
     * If this method returns false, then the parent cannot resize it during
     * layout (resize() is a no-op) and it should return its layoutBounds for
     * minimum, preferred, and maximum sizes.  Group, Text, and all Shapes are not
     * resizable and hence depend on the application to establish their sizing
     * by setting appropriate properties (e.g.  width/height for Rectangle,
     * text on Text, and so on).  Non-resizable nodes may still be relocated
     * during layout.
     *
     * @see #getContentBias()
     * @see #minWidth(double)
     * @see #minHeight(double)
     * @see #prefWidth(double)
     * @see #prefHeight(double)
     * @see #maxWidth(double)
     * @see #maxHeight(double)
     * @see #resize(double, double)
     * @see #getLayoutBounds()
     *
     * @return whether or not this node type can be resized by its parent during layout
     */
    public boolean isResizable() {
        return false;
    }

    /**
     * Returns the orientation of a node's resizing bias for layout purposes.
     * If the node type has no bias, returns null.  If the node is resizable and
     * it's height depends on its width, returns HORIZONTAL, else if its width
     * depends on its height, returns VERTICAL.
     * &lt;p&gt;
     * Resizable subclasses should override this method to return an
     * appropriate value.
     *
     * @see #isResizable()
     * @see #minWidth(double)
     * @see #minHeight(double)
     * @see #prefWidth(double)
     * @see #prefHeight(double)
     * @see #maxWidth(double)
     * @see #maxHeight(double)
     *
     * @return orientation of width/height dependency or null if there is none
     */
    public Orientation getContentBias() {
        return null;
    }

    /**
     * Returns the node's minimum width for use in layout calculations.
     * If the node is resizable, its parent should not resize its width any
     * smaller than this value.  If the node is not resizable, returns its
     * layoutBounds width.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a vertical content-bias, then callers
     * should pass in a height value that the minimum width should be based on.
     * If the node has either a horizontal or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a vertical content-bias should honor the height
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the height parameter (which will likely be -1).
     * &lt;p&gt;
     * If Node's {@link #maxWidth(double)} is lower than this number,
     * {@code minWidth} takes precedence. This means the Node should never be resized below {@code minWidth}.
     *
     * @see #isResizable()
     * @see #getContentBias()
     *
     * @param height the height that should be used if minimum width depends on it
     * @return the minimum width that the node should be resized to during layout.
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double minWidth(double height) {
        return prefWidth(height);
    }

    /**
     * Returns the node's minimum height for use in layout calculations.
     * If the node is resizable, its parent should not resize its height any
     * smaller than this value.  If the node is not resizable, returns its
     * layoutBounds height.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a horizontal content-bias, then callers
     * should pass in a width value that the minimum height should be based on.
     * If the node has either a vertical or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a horizontal content-bias should honor the width
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the width parameter (which will likely be -1).
     * &lt;p&gt;
     * If Node's {@link #maxHeight(double)} is lower than this number,
     * {@code minHeight} takes precedence. This means the Node should never be resized below {@code minHeight}.
     *
     * @see #isResizable()
     * @see #getContentBias()
     *
     * @param width the width that should be used if minimum height depends on it
     * @return the minimum height that the node should be resized to during layout
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double minHeight(double width) {
        return prefHeight(width);
    }

    /**
     * Returns the node's preferred width for use in layout calculations.
     * If the node is resizable, its parent should treat this value as the
     * node's ideal width within its range.  If the node is not resizable,
     * just returns its layoutBounds width, which should be treated as the rigid
     * width of the node.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a vertical content-bias, then callers
     * should pass in a height value that the preferred width should be based on.
     * If the node has either a horizontal or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a vertical content-bias should honor the height
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the height parameter (which will likely be -1).
     *
     * @see #isResizable()
     * @see #getContentBias()
     * @see #autosize()
     *
     * @param height the height that should be used if preferred width depends on it
     * @return the preferred width that the node should be resized to during layout
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double prefWidth(double height) {
        final double result = getLayoutBounds().getWidth();
        return Double.isNaN(result) || result &lt; 0 ? 0 : result;
    }

    /**
     * Returns the node's preferred height for use in layout calculations.
     * If the node is resizable, its parent should treat this value as the
     * node's ideal height within its range.  If the node is not resizable,
     * just returns its layoutBounds height, which should be treated as the rigid
     * height of the node.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a horizontal content-bias, then callers
     * should pass in a width value that the preferred height should be based on.
     * If the node has either a vertical or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a horizontal content-bias should honor the height
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the height parameter (which will likely be -1).
     *
     * @see #getContentBias()
     * @see #autosize()
     *
     * @param width the width that should be used if preferred height depends on it
     * @return the preferred height that the node should be resized to during layout
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double prefHeight(double width) {
        final double result = getLayoutBounds().getHeight();
        return Double.isNaN(result) || result &lt; 0 ? 0 : result;
    }

    /**
     * Returns the node's maximum width for use in layout calculations.
     * If the node is resizable, its parent should not resize its width any
     * larger than this value.  A value of Double.MAX_VALUE indicates the
     * parent may expand the node's width beyond its preferred without limits.
     * &lt;p&gt;
     * If the node is not resizable, returns its layoutBounds width.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a vertical content-bias, then callers
     * should pass in a height value that the maximum width should be based on.
     * If the node has either a horizontal or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a vertical content-bias should honor the height
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the height parameter (which will likely be -1).
     * &lt;p&gt;
     * If Node's {@link #minWidth(double)} is greater, it should take precedence
     * over the {@code maxWidth}. This means the Node should never be resized below {@code minWidth}.
     *
     * @see #isResizable()
     * @see #getContentBias()
     *
     * @param height the height that should be used if maximum width depends on it
     * @return the maximum width that the node should be resized to during layout
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double maxWidth(double height) {
        return prefWidth(height);
    }

    /**
     * Returns the node's maximum height for use in layout calculations.
     * If the node is resizable, its parent should not resize its height any
     * larger than this value.  A value of Double.MAX_VALUE indicates the
     * parent may expand the node's height beyond its preferred without limits.
     * &lt;p&gt;
     * If the node is not resizable, returns its layoutBounds height.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a horizontal content-bias, then callers
     * should pass in a width value that the maximum height should be based on.
     * If the node has either a vertical or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a horizontal content-bias should honor the width
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the width parameter (which will likely be -1).
     * &lt;p&gt;
     * If Node's {@link #minHeight(double)} is greater, it should take precedence
     * over the {@code maxHeight}.  This means the Node should never be resized below {@code minHeight}.
     *
     * @see #isResizable()
     * @see #getContentBias()
     *
     * @param width the width that should be used if maximum height depends on it
     * @return the maximum height that the node should be resized to during layout
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double maxHeight(double width) {
        return prefHeight(width);
    }

    /**
     * If the node is resizable, will set its layout bounds to the specified
     * width and height.   If the node is not resizable, this method is a no-op.
     * &lt;p&gt;
     * This method should generally only be called by parent nodes from their
     * layoutChildren() methods.   All Parent classes will automatically resize
     * resizable children, so resizing done directly by the application will be
     * overridden by the node's parent, unless the child is unmanaged.
     * &lt;p&gt;
     * Parents are responsible for ensuring the width and height values fall
     * within the resizable node's preferred range.  The autosize() method may
     * be used if the parent just needs to resize the node to its preferred size.
     *
     * @see #isResizable()
     * @see #getContentBias()
     * @see #autosize()
     * @see #minWidth(double)
     * @see #minHeight(double)
     * @see #prefWidth(double)
     * @see #prefHeight(double)
     * @see #maxWidth(double)
     * @see #maxHeight(double)
     * @see #getLayoutBounds()
     *
     * @param width the target layout bounds width
     * @param height the target layout bounds height
     */
    public void resize(double width, double height) {
    }

    /**
     * If the node is resizable, will set its layout bounds to its current preferred
     * width and height. If the node is not resizable, this method is a no-op.
     * &lt;p&gt;
     * This method automatically queries the node's content-bias and if it's
     * horizontal, will pass in the node's preferred width to get the preferred
     * height; if vertical, will pass in the node's preferred height to get the width,
     * and if null, will compute the preferred width/height independently.
     * &lt;/p&gt;
     *
     * @see #isResizable()
     * @see #getContentBias()
     *
     */
    public final void autosize() {
        if (isResizable()) {
            Orientation contentBias = getContentBias();
            double w, h;
            if (contentBias == null) {
                w = boundedSize(prefWidth(-1), minWidth(-1), maxWidth(-1));
                h = boundedSize(prefHeight(-1), minHeight(-1), maxHeight(-1));
            } else if (contentBias == Orientation.HORIZONTAL) {
                w = boundedSize(prefWidth(-1), minWidth(-1), maxWidth(-1));
                h = boundedSize(prefHeight(w), minHeight(w), maxHeight(w));
            } else { // bias == VERTICAL
                h = boundedSize(prefHeight(-1), minHeight(-1), maxHeight(-1));
                w = boundedSize(prefWidth(h), minWidth(h), maxWidth(h));
            }
            resize(w,h);
        }
    }

    double boundedSize(double value, double min, double max) {
        // if max &lt; value, return max
        // if min &gt; value, return min
        // if min &gt; max, return min
        return Math.min(Math.max(value, min), Math.max(min,max));
    }

    /**
     * If the node is resizable, will set its layout bounds to the specified
     * width and height.   If the node is not resizable, the resize step is skipped.
     * &lt;p&gt;
     * Once the node has been resized (if resizable) then sets the node's layoutX
     * and layoutY translation properties in order to relocate it to x,y in the
     * parent's coordinate space.
     * &lt;p&gt;
     * This method should generally only be called by parent nodes from their
     * layoutChildren() methods.   All Parent classes will automatically resize
     * resizable children, so resizing done directly by the application will be
     * overridden by the node's parent, unless the child is unmanaged.
     * &lt;p&gt;
     * Parents are responsible for ensuring the width and height values fall
     * within the resizable node's preferred range.  The autosize() and relocate()
     * methods may be used if the parent just needs to resize the node to its
     * preferred size and reposition it.
     *
     * @see #isResizable()
     * @see #getContentBias()
     * @see #autosize()
     * @see #minWidth(double)
     * @see #minHeight(double)
     * @see #prefWidth(double)
     * @see #prefHeight(double)
     * @see #maxWidth(double)
     * @see #maxHeight(double)
     *
     * @param x the target x coordinate location
     * @param y the target y coordinate location
     * @param width the target layout bounds width
     * @param height the target layout bounds height
     *
     */
    public void resizeRelocate(double x, double y, double width, double height) {
        resize(width, height);
        relocate(x,y);
    }

    /**
     * This is a special value that might be returned by {@link #getBaselineOffset()}.
     * This means that the Parent (layout Pane) of this Node should use the height of this Node as a baseline.
     */
    public static final double BASELINE_OFFSET_SAME_AS_HEIGHT = Double.NEGATIVE_INFINITY;

    /**
     * The 'alphabetic' (or 'roman') baseline offset from the node's layoutBounds.minY location
     * that should be used when this node is being vertically aligned by baseline with
     * other nodes.  By default this returns {@link #BASELINE_OFFSET_SAME_AS_HEIGHT} for resizable Nodes
     * and layoutBounds height for non-resizable.  Subclasses
     * which contain text should override this method to return their actual text baseline offset.
     *
     * @return offset of text baseline from layoutBounds.minY for non-resizable Nodes or {@link #BASELINE_OFFSET_SAME_AS_HEIGHT} otherwise
     */
    public double getBaselineOffset() {
        if (isResizable()) {
            return BASELINE_OFFSET_SAME_AS_HEIGHT;
        } else {
            return getLayoutBounds().getHeight();
        }
    }

    /**
     * Returns the area of this {@code Node} projected onto the
     * physical screen in pixel units.
     * @return the area of this {@code Node} projected onto the physical screen
     * @since JavaFX 8.0
     */
    public double computeAreaInScreen() {
        return doComputeAreaInScreen();
    }

    /*
     * Help application or utility to implement LOD support by returning the
     * projected area of a Node in pixel unit. The projected area is not clipped.
     *
     * For perspective camera, this method first exams node's bounds against
     * camera's clipping plane to cut off those out of viewing frustrum. After
     * computing areaInScreen, it applies a tight viewing frustrum check using
     * canonical view volume.
     *
     * The result of areaInScreen comes from the product of
     * (projViewTx x localToSceneTransform x localBounds).
     *
     * Returns 0 for those fall outside viewing frustrum.
     */
    private double doComputeAreaInScreen() {
        Scene tmpScene = getScene();
        if (tmpScene != null) {
            Bounds bounds = getBoundsInLocal();
            Camera camera = tmpScene.getEffectiveCamera();
            boolean isPerspective = camera instanceof PerspectiveCamera ? true : false;
            Transform localToSceneTx = getLocalToSceneTransform();
            Affine3D tempTx = TempState.getInstance().tempTx;
            BaseBounds localBounds = new BoxBounds((float) bounds.getMinX(),
                                                   (float) bounds.getMinY(),
                                                   (float) bounds.getMinZ(),
                                                   (float) bounds.getMaxX(),
                                                   (float) bounds.getMaxY(),
                                                   (float) bounds.getMaxZ());

            // NOTE: Viewing frustrum check on camera's clipping plane is now only
            // for perspective camera.
            // TODO: Need to hook up parallel camera's nearClip and farClip.
            if (isPerspective) {
                Transform cameraL2STx = camera.getLocalToSceneTransform();

                // If camera transform only contains translate, compare in scene
                // coordinate. Otherwise, compare in camera coordinate.
                if (cameraL2STx.getMxx() == 1.0
                        &amp;&amp; cameraL2STx.getMxy() == 0.0
                        &amp;&amp; cameraL2STx.getMxz() == 0.0
                        &amp;&amp; cameraL2STx.getMyx() == 0.0
                        &amp;&amp; cameraL2STx.getMyy() == 1.0
                        &amp;&amp; cameraL2STx.getMyz() == 0.0
                        &amp;&amp; cameraL2STx.getMzx() == 0.0
                        &amp;&amp; cameraL2STx.getMzy() == 0.0
                        &amp;&amp; cameraL2STx.getMzz() == 1.0) {

                    double minZ, maxZ;

                    // If node transform only contains translate, only convert
                    // minZ and maxZ to scene coordinate. Otherwise, convert
                    // node bounds to scene coordinate.
                    if (localToSceneTx.getMxx() == 1.0
                            &amp;&amp; localToSceneTx.getMxy() == 0.0
                            &amp;&amp; localToSceneTx.getMxz() == 0.0
                            &amp;&amp; localToSceneTx.getMyx() == 0.0
                            &amp;&amp; localToSceneTx.getMyy() == 1.0
                            &amp;&amp; localToSceneTx.getMyz() == 0.0
                            &amp;&amp; localToSceneTx.getMzx() == 0.0
                            &amp;&amp; localToSceneTx.getMzy() == 0.0
                            &amp;&amp; localToSceneTx.getMzz() == 1.0) {

                        Vec3d tempV3D = TempState.getInstance().vec3d;
                        tempV3D.set(0, 0, bounds.getMinZ());
                        localToScene(tempV3D);
                        minZ = tempV3D.z;

                        tempV3D.set(0, 0, bounds.getMaxZ());
                        localToScene(tempV3D);
                        maxZ = tempV3D.z;
                    } else {
                        Bounds nodeInSceneBounds = localToScene(bounds);
                        minZ = nodeInSceneBounds.getMinZ();
                        maxZ = nodeInSceneBounds.getMaxZ();
                    }

                    if (minZ &gt; camera.getFarClipInScene()
                            || maxZ &lt; camera.getNearClipInScene()) {
                        return 0;
                    }

                } else {
                    BaseBounds nodeInCameraBounds = new BoxBounds();

                    // We need to set tempTx to identity since it is a recycled transform.
                    // This is because TransformHelper.apply() is a matrix concatenation operation.
                    tempTx.setToIdentity();
                    TransformHelper.apply(localToSceneTx, tempTx);

                    // Convert node from local coordinate to camera coordinate
                    tempTx.preConcatenate(camera.getSceneToLocalTransform());
                    tempTx.transform(localBounds, nodeInCameraBounds);

                    // Compare in camera coordinate
                    if (nodeInCameraBounds.getMinZ() &gt; camera.getFarClip()
                            || nodeInCameraBounds.getMaxZ() &lt; camera.getNearClip()) {
                        return 0;
                    }
                }
            }

            GeneralTransform3D projViewTx = TempState.getInstance().projViewTx;
            projViewTx.set(camera.getProjViewTransform());

            // We need to set tempTx to identity since it is a recycled transform.
            // This is because TransformHelper.apply() is a matrix concatenation operation.
            tempTx.setToIdentity();
            TransformHelper.apply(localToSceneTx, tempTx);

            // The product of projViewTx * localToSceneTransform
            GeneralTransform3D tx = projViewTx.mul(tempTx);

            // Transform localBounds to projected bounds
            localBounds = tx.transform(localBounds, localBounds);
            double area = localBounds.getWidth() * localBounds.getHeight();

            // Use canonical view volume to check whether object is outside the
            // viewing frustrum
            if (isPerspective) {
                localBounds.intersectWith(-1, -1, 0, 1, 1, 1);
                area = (localBounds.getWidth() &lt; 0 || localBounds.getHeight() &lt; 0) ? 0 : area;
            }
            return area * (camera.getViewWidth() / 2 * camera.getViewHeight() / 2);
        }
        return 0;
    }

    /* *************************************************************************
     *                                                                         *
     * Bounds related APIs                                                     *
     *                                                                         *
     **************************************************************************/

    public final Bounds getBoundsInParent() {
        return boundsInParentProperty().get();
    }

    /**
     * The rectangular bounds of this {@code Node} which include its transforms.
     * {@code boundsInParent} is calculated by
     * taking the local bounds (defined by {@link #boundsInLocalProperty boundsInLocal}) and applying
     * the transform created by setting the following additional variables
     * &lt;ol&gt;
     * &lt;li&gt;{@link #getTransforms transforms} ObservableList&lt;/li&gt;
     * &lt;li&gt;{@link #scaleXProperty scaleX}, {@link #scaleYProperty scaleY}, {@link #scaleZProperty scaleZ}&lt;/li&gt;
     * &lt;li&gt;{@link #rotateProperty rotate}&lt;/li&gt;
     * &lt;li&gt;{@link #layoutXProperty layoutX}, {@link #layoutYProperty layoutY}&lt;/li&gt;
     * &lt;li&gt;{@link #translateXProperty translateX}, {@link #translateYProperty translateY},
     * {@link #translateZProperty translateZ}&lt;/li&gt;
     * &lt;/ol&gt;
     * &lt;p&gt;
     * The resulting bounds will be conceptually in the coordinate space of the
     * {@code Node}'s parent, however the node need not have a parent to calculate
     * these bounds.
     * &lt;p&gt;
     * Note that this method does not take the node's visibility into account;
     * the computation is based on the geometry of this {@code Node} only.
     * &lt;p&gt;
     * This property will always have a non-null value.
     * &lt;p&gt;
     * Note that {@code boundsInParent} is automatically recomputed whenever the
     * geometry of a node changes, or when any of the following the change:
     * transforms {@code ObservableList}, any of the translate, layout or scale
     * variables, or the rotate variable. For this reason, it is an error
     * to bind any of these values in a node to an expression that depends upon
     * this variable. For example, the x or y variables of a shape, or
     * {@code translateX}, {@code translateY} should never be bound to
     * {@code boundsInParent} for the purpose of positioning the node.
     * @return the boundsInParent for this {@code Node}
     */
    public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInParentProperty() {
        return getMiscProperties().boundsInParentProperty();
    }

    private void invalidateBoundsInParent() {
        if (miscProperties != null) {
            miscProperties.invalidateBoundsInParent();
        }
    }

    public final Bounds getBoundsInLocal() {
        return boundsInLocalProperty().get();
    }

    /**
     * The rectangular bounds of this {@code Node} in the node's
     * untransformed local coordinate space.  For nodes that extend
     * {@link javafx.scene.shape.Shape}, the local bounds will also include
     * space required for a non-zero stroke that may fall outside the shape's
     * geometry that is defined by position and size attributes.
     * The local bounds will also include any clipping set with {@link #clipProperty clip}
     * as well as effects set with {@link #effectProperty effect}.
     *
     * &lt;p&gt;
     * Note that this method does not take the node's visibility into account;
     * the computation is based on the geometry of this {@code Node} only.
     * &lt;p&gt;
     * This property will always have a non-null value.
     * &lt;p&gt;
     * Note that boundsInLocal is automatically recomputed whenever the
     * geometry of a node changes. For this reason, it is an error to bind any
     * of these values in a node to an expression that depends upon this variable.
     * For example, the x or y variables of a shape should never be bound
     * to boundsInLocal for the purpose of positioning the node.
     * @return the boundsInLocal for this {@code Node}
     */
    public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInLocalProperty() {
        return getMiscProperties().boundsInLocalProperty();
    }

    private void invalidateBoundsInLocal() {
        if (miscProperties != null) {
            miscProperties.invalidateBoundsInLocal();
        }
    }

    /**
     * The rectangular bounds that should be used for layout calculations for
     * this node. {@code layoutBounds} may differ from the visual bounds
     * of the node and is computed differently depending on the node type.
     * &lt;p&gt;
     * If the node type is resizable ({@link javafx.scene.layout.Region Region},
     * {@link javafx.scene.control.Control Control}, or {@link javafx.scene.web.WebView WebView})
     * then the layoutBounds will always be {@code 0,0 width x height}.
     * If the node type is not resizable ({@link javafx.scene.shape.Shape Shape},
     * {@link javafx.scene.text.Text Text}, or {@link Group}), then the {@code layoutBounds}
     * are computed based on the node's geometric properties and does not include the
     * node's clip, effect, or transforms.  See individual class documentation
     * for details.
     * &lt;p&gt;
     * Note that the {@link #layoutXProperty layoutX}, {@link #layoutYProperty layoutY},
     * {@link #translateXProperty translateX}, and {@link #translateYProperty translateY}
     * variables are not included in the layoutBounds.
     * This is important because layout code must first determine the current
     * size and location of the node (using {@code layoutBounds}) and then set
     * {@code layoutX} and {@code layoutY} to adjust the translation of the
     * node so that it will have the desired layout position.
     * &lt;p&gt;
     * Because the computation of layoutBounds is often tied to a node's
     * geometric variables, it is an error to bind any such variables to an
     * expression that depends upon {@code layoutBounds}. For example, the
     * x or y variables of a shape should never be bound to {@code layoutBounds}
     * for the purpose of positioning the node.
     * &lt;p&gt;
     * Note that for 3D shapes, the layout bounds is actually a rectangular box
     * with X, Y, and Z values, although only X and Y are used in layout calculations.
     * &lt;p&gt;
     * The {@code layoutBounds} will never be null.
     *
     */
    private LazyBoundsProperty layoutBounds = new LazyBoundsProperty() {
        @Override
        protected Bounds computeBounds() {
            return NodeHelper.computeLayoutBounds(Node.this);
        }

        @Override
        public Object getBean() {
            return Node.this;
        }

        @Override
        public String getName() {
            return &quot;layoutBounds&quot;;
        }
    };

    public final Bounds getLayoutBounds() {
        return layoutBoundsProperty().get();
    }

    public final ReadOnlyObjectProperty&lt;Bounds&gt; layoutBoundsProperty() {
        return layoutBounds;
    }

    /*
     *                  Bounds And Transforms Computation
     *
     *  This section of the code is responsible for computing and caching
     *  various bounds and transforms. For optimal performance and minimal
     *  recomputation of bounds (which can be quite expensive), we cache
     *  values on two different levels. We expose two public immutable
     *  Bounds boundsInParent objects and boundsInLocal. Because they are
     *  immutable and because they may change quite frequently (especially
     *  in the case of a Parent whose children are animated), it is
     *  important that the system does not rely on these variables, because
     *  doing so would produce a large amount of garbage. Rather, these
     *  variables are provided solely for the convenience of application
     *  developers and, being lazily bound, should generally be created at
     *  most once per frame.
     *
     *  The second level of caching are within local Bounds2D variables.
     *  These variables, txBounds and geomBounds, are mutable and as such
     *  can be cached and updated as frequently as necessary without creating
     *  excessive garbage. However, since the computation of bounds is still
     *  expensive, it is desirable to cache both the geometric bounds and
     *  the &quot;complete&quot; transformed bounds (essentially, boundsInParent).
     *  Cached txBounds is particularly useful when computing the geometric
     *  bounds of a Parent since it would not require complete or partial
     *  recomputation of each child.
     *
     *  Finally, we cache the complete transform for this node which converts
     *  its coord system from local to parent coords. This is useful both for
     *  minimizing bounds recomputations in the case of the geometry having
     *  changed but the transform not having changed, and also because the tx
     *  is required for several different computations (for example, it must
     *  be computed once during state synchronization with the PG peer, and
     *  must also be computed when the pivot point changes, and also when
     *  deriving the txBounds of the Node).
     *
     *  As with any caching system, a subtle and non-trivial amount of code
     *  is devoted to invalidating the bounds / transforms at appropriate
     *  times and in appropriate places to make sure bounds / transforms
     *  are recomputed at all necessary times.
     *
     *  There are three computeXXX functions. One is for computing the
     *  boundsInParent, the second for computing boundsInLocal, and the
     *  third for computing the default layout bounds (which, by default,
     *  is based on the geometric bounds). These functions are all prefixed
     *  with &quot;compute&quot; because they create and return new immutable
     *  Bounds objects.
     *
     *  There are three getXXXBounds functions. One is for returning the
     *  complete transformed bounds. The second is for returning the
     *  local bounds. The last is for returning the geometric bounds. These
     *  functions are all prefixed with &quot;get&quot; because they may well return
     *  a cached value, or may actually compute the bounds if necessary. These
     *  functions all have the same signature. They take a Bounds2D and
     *  BaseTransform, and return a Bounds2D (the same as they took). These
     *  functions essentially populate the supplied bounds2D with the
     *  appropriate bounds information, leveraging cached bounds if possible.
     *
     *  There is a single NodeHelper.computeGeomBoundsImpl function which is abstract.
     *  This must be implemented in each subclass, and is responsible for
     *  computing the actual geometric bounds for the Node. For example, Parent
     *  is written such that this function is the union of the transformed
     *  bounds of each child. Rectangle is written such that this takes into
     *  account the size and stroke. Text is written such that it is computed
     *  based on the actual glyphs.
     *
     *  There are two updateXXX functions, updateGeomBounds and updateTxBounds.
     *  These functions are for ensuring that geomBounds and txBounds are
     *  valid. They only execute in the case of the cached value being invalid,
     *  so the function call is very cheap in cases where the cached bounds
     *  values are still valid.
     */

    /**
     * An affine transform that holds the computed local-to-parent transform.
     * This is the concatenation of all transforms in this node, including all
     * of the convenience transforms.
     */
    private BaseTransform localToParentTx = BaseTransform.IDENTITY_TRANSFORM;

    /**
     * This flag is used to indicate that localToParentTx is dirty and needs
     * to be recomputed.
     */
    private boolean transformDirty = true;

    /**
     * The cached transformed bounds. This is never null, but is frequently set
     * to be invalid whenever the bounds for the node have changed. These are
     * &quot;complete&quot; bounds, that is, with transforms and effect and clip applied.
     * Note that this is equivalent to boundsInParent
     */
    private BaseBounds txBounds = new RectBounds();

    /**
     * The cached bounds. This is never null, but is frequently set to be
     * invalid whenever the bounds for the node have changed. These are the
     * &quot;content&quot; bounds, that is, without transforms or effects applied.
     */
    private BaseBounds geomBounds = new RectBounds();

    /**
     * The cached local bounds (without transforms, with clip and effects).
     * If there is neither clip nor effect
     * local bounds are equal to geom bounds, so in this case we don't keep
     * the extra instance and set null to this variable.
     */
    private BaseBounds localBounds = null;

    /**
     * This special flag is used only by Parent to flag whether or not
     * the *parent* has processed the fact that bounds have changed for this
     * child Node. We need some way of flagging this on a per-node basis to
     * enable the significant performance optimizations and fast paths that
     * are in the Parent code.
     * &lt;p&gt;
     * To reduce confusion, although this variable is defined on Node, it
     * really belongs to the Parent of the node and should *only* be modified
     * by the parent.
     */
    boolean boundsChanged;

    /*
     * Returns geometric bounds, but may be over-ridden by a subclass.
     */
    private Bounds doComputeLayoutBounds() {
        BaseBounds tempBounds = TempState.getInstance().bounds;
        tempBounds = getGeomBounds(tempBounds,
                                   BaseTransform.IDENTITY_TRANSFORM);
        return new BoundingBox(tempBounds.getMinX(),
                               tempBounds.getMinY(),
                               tempBounds.getMinZ(),
                               tempBounds.getWidth(),
                               tempBounds.getHeight(),
                               tempBounds.getDepth());
    }

    /*
     * Subclasses may customize the layoutBounds by means of overriding the
     * NodeHelper.computeLayoutBoundsImpl method. If the layout bounds need to be
     * recomputed, the subclass must notify the Node implementation of this
     * fact so that appropriate notifications and internal state can be
     * kept in sync. Subclasses must call NodeHelper.layoutBoundsChanged to
     * let Node know that the layout bounds are invalid and need to be
     * recomputed.
     */
    final void layoutBoundsChanged() {
        if (!layoutBounds.valid) {
            return;
        }
        layoutBounds.invalidate();
        if ((nodeTransformation != null &amp;&amp; nodeTransformation.hasScaleOrRotate()) || hasMirroring()) {
            // if either the scale or rotate convenience variables are used,
            // then we need a valid pivot point. Since the layoutBounds
            // affects the pivot we need to invalidate the transform
            NodeHelper.transformsChanged(this);
        }
    }

    /**
     * Loads the given bounds object with the transformed bounds relative to,
     * and based on, the given transform. That is, this is the local bounds
     * with the local-to-parent transform applied.
     *
     * We *never* pass null in as a bounds. This method will
     * NOT take a null bounds object. The returned value may be
     * the same bounds object passed in, or it may be a new object.
     * The reason for this object promotion is in the case of needing
     * to promote from a RectBounds to a BoxBounds (3D).
     */
    BaseBounds getTransformedBounds(BaseBounds bounds, BaseTransform tx) {
        updateLocalToParentTransform();
        if (tx.isTranslateOrIdentity()) {
            updateTxBounds();
            bounds = bounds.deriveWithNewBounds(txBounds);
            if (!tx.isIdentity()) {
                final double translateX = tx.getMxt();
                final double translateY = tx.getMyt();
                final double translateZ = tx.getMzt();
                bounds = bounds.deriveWithNewBounds(
                                    (float) (bounds.getMinX() + translateX),
                                    (float) (bounds.getMinY() + translateY),
                                    (float) (bounds.getMinZ() + translateZ),
                                    (float) (bounds.getMaxX() + translateX),
                                    (float) (bounds.getMaxY() + translateY),
                                    (float) (bounds.getMaxZ() + translateZ));
            }
            return bounds;
        } else if (localToParentTx.isIdentity()) {
            return getLocalBounds(bounds, tx);
        } else {
            double mxx = tx.getMxx();
            double mxy = tx.getMxy();
            double mxz = tx.getMxz();
            double mxt = tx.getMxt();
            double myx = tx.getMyx();
            double myy = tx.getMyy();
            double myz = tx.getMyz();
            double myt = tx.getMyt();
            double mzx = tx.getMzx();
            double mzy = tx.getMzy();
            double mzz = tx.getMzz();
            double mzt = tx.getMzt();
            BaseTransform boundsTx = tx.deriveWithConcatenation(localToParentTx);
            bounds = getLocalBounds(bounds, boundsTx);
            if (boundsTx == tx) {
                tx.restoreTransform(mxx, mxy, mxz, mxt,
                                    myx, myy, myz, myt,
                                    mzx, mzy, mzz, mzt);
            }
            return bounds;
        }
    }

    /**
     * Loads the given bounds object with the local bounds relative to,
     * and based on, the given transform. That is, these are the geometric
     * bounds + clip and effect.
     *
     * We *never* pass null in as a bounds. This method will
     * NOT take a null bounds object. The returned value may be
     * the same bounds object passed in, or it may be a new object.
     * The reason for this object promotion is in the case of needing
     * to promote from a RectBounds to a BoxBounds (3D).
     */
    BaseBounds getLocalBounds(BaseBounds bounds, BaseTransform tx) {
        if (getEffect() == null &amp;&amp; getClip() == null) {
            return getGeomBounds(bounds, tx);
        }

        if (tx.isTranslateOrIdentity()) {
            // we can take a fast path since we know tx is either a simple
            // translation or is identity
            updateLocalBounds();
            bounds = bounds.deriveWithNewBounds(localBounds);
            if (!tx.isIdentity()) {
                double translateX = tx.getMxt();
                double translateY = tx.getMyt();
                double translateZ = tx.getMzt();
                bounds = bounds.deriveWithNewBounds((float) (bounds.getMinX() + translateX),
                        (float) (bounds.getMinY() + translateY),
                        (float) (bounds.getMinZ() + translateZ),
                        (float) (bounds.getMaxX() + translateX),
                        (float) (bounds.getMaxY() + translateY),
                        (float) (bounds.getMaxZ() + translateZ));
            }
            return bounds;
        } else if (tx.is2D()
                &amp;&amp; (tx.getType()
                &amp; ~(BaseTransform.TYPE_UNIFORM_SCALE | BaseTransform.TYPE_TRANSLATION
                | BaseTransform.TYPE_FLIP | BaseTransform.TYPE_QUADRANT_ROTATION)) != 0) {
            // this is a non-uniform scale / non-quadrant rotate / skew transform
            return computeLocalBounds(bounds, tx);
        } else {
            // 3D transformations and
            // selected 2D transformations (uniform transform, flip, quadrant rotation).
            // These 2D transformation will yield tight bounds when applied on the pre-computed
            // geomBounds
            // Note: Transforming the local bounds into a 3D space will yield a bounds
            // that isn't as tight as transforming its geometry and compute it bounds.
            updateLocalBounds();
            return tx.transform(localBounds, bounds);
        }
    }

    /**
     * Loads the given bounds object with the geometric bounds relative to,
     * and based on, the given transform.
     *
     * We *never* pass null in as a bounds. This method will
     * NOT take a null bounds object. The returned value may be
     * the same bounds object passed in, or it may be a new object.
     * The reason for this object promotion is in the case of needing
     * to promote from a RectBounds to a BoxBounds (3D).
     */
    BaseBounds getGeomBounds(BaseBounds bounds, BaseTransform tx) {
        if (tx.isTranslateOrIdentity()) {
            // we can take a fast path since we know tx is either a simple
            // translation or is identity
            updateGeomBounds();
            bounds = bounds.deriveWithNewBounds(geomBounds);
            if (!tx.isIdentity()) {
                double translateX = tx.getMxt();
                double translateY = tx.getMyt();
                double translateZ = tx.getMzt();
                bounds = bounds.deriveWithNewBounds((float) (bounds.getMinX() + translateX),
                        (float) (bounds.getMinY() + translateY),
                        (float) (bounds.getMinZ() + translateZ),
                        (float) (bounds.getMaxX() + translateX),
                        (float) (bounds.getMaxY() + translateY),
                        (float) (bounds.getMaxZ() + translateZ));
            }
            return bounds;
        } else if (tx.is2D()
                &amp;&amp; (tx.getType()
                &amp; ~(BaseTransform.TYPE_UNIFORM_SCALE | BaseTransform.TYPE_TRANSLATION
                | BaseTransform.TYPE_FLIP | BaseTransform.TYPE_QUADRANT_ROTATION)) != 0) {
            // this is a non-uniform scale / non-quadrant rotate / skew transform
            return NodeHelper.computeGeomBounds(this, bounds, tx);
        } else {
            // 3D transformations and
            // selected 2D transformations (unifrom transform, flip, quadrant rotation).
            // These 2D transformation will yield tight bounds when applied on the pre-computed
            // geomBounds
            // Note: Transforming the local geomBounds into a 3D space will yield a bounds
            // that isn't as tight as transforming its geometry and compute it bounds.
            updateGeomBounds();
            return tx.transform(geomBounds, bounds);
        }
    }

    /**
     * If necessary, recomputes the cached geom bounds. If the bounds are not
     * invalid, then this method is a no-op.
     */
    void updateGeomBounds() {
        if (geomBoundsInvalid) {
            geomBounds = NodeHelper.computeGeomBounds(this, geomBounds, BaseTransform.IDENTITY_TRANSFORM);
            geomBoundsInvalid = false;
        }
    }

    /**
     * Computes the local bounds of this Node.
     */
    private BaseBounds computeLocalBounds(BaseBounds bounds, BaseTransform tx) {
        // We either get the bounds of the effect (if it isn't null)
        // or we get the geom bounds (if effect is null). We will then
        // intersect this with the clip.
        if (getEffect() != null) {
            BaseBounds b = EffectHelper.getBounds(getEffect(), bounds, tx, this, boundsAccessor);
            bounds = bounds.deriveWithNewBounds(b);
        } else {
            bounds = getGeomBounds(bounds, tx);
        }
        // intersect with the clip. Take care with &quot;bounds&quot; as it may
        // actually be TEMP_BOUNDS, so we save off state
        if (getClip() != null
                // FIXME: All 3D picking is currently ignored by rendering.
                // Until this is fixed or defined differently (RT-28510),
                // we follow this behavior.
                &amp;&amp; !(this instanceof Shape3D) &amp;&amp; !(getClip() instanceof Shape3D)) {
            double x1 = bounds.getMinX();
            double y1 = bounds.getMinY();
            double x2 = bounds.getMaxX();
            double y2 = bounds.getMaxY();
            double z1 = bounds.getMinZ();
            double z2 = bounds.getMaxZ();
            bounds = getClip().getTransformedBounds(bounds, tx);
            bounds.intersectWith((float)x1, (float)y1, (float)z1,
                    (float)x2, (float)y2, (float)z2);
        }
        return bounds;
    }


    /**
     * If necessary, recomputes the cached local bounds. If the bounds are not
     * invalid, then this method is a no-op.
     */
    private void updateLocalBounds() {
        if (localBoundsInvalid) {
            if (getClip() != null || getEffect() != null) {
                localBounds = computeLocalBounds(
                        localBounds == null ? new RectBounds() : localBounds,
                        BaseTransform.IDENTITY_TRANSFORM);
            } else {
                localBounds = null;
            }
            localBoundsInvalid = false;
        }
    }

    /**
     * If necessary, recomputes the cached transformed bounds.
     * If the cached transformed bounds are not invalid, then
     * this method is a no-op.
     */
    void updateTxBounds() {
        if (txBoundsInvalid) {
            updateLocalToParentTransform();
            txBounds = getLocalBounds(txBounds, localToParentTx);
            txBoundsInvalid = false;
        }
    }

    /*
     *                   Bounds Invalidation And Notification
     *
     *  The goal of this section is to efficiently propagate bounds
     *  invalidation through the scenegraph while also being semantically
     *  correct.
     *
     *  The code path for invalidation of layout bounds is somewhat confusing
     *  primarily due to performance enhancements and the desire to reduce the
     *  number of requestLayout() calls that are performed when layout bounds
     *  change. Before diving into layout bounds, I will first describe how
     *  normal bounds invalidation occurs.
     *
     *  When a node's geometry changes (for example, if the width of a
     *  Rectangle is changed) then the Node must call NodeHelper.geomChanged().
     *  Invoking this function will eventually clear all cached bounds and
     *  notify to each parent up the tree that their bounds may have changed.
     *
     *  After invalidating geomBounds (and after kicking off layout bounds
     *  notification), NodeHelper.geomChanged calls localBoundsChanged(). It should
     *  be noted that NodeHelper.geomChanged should only be called when the geometry
     *  of the node has changed such that it may result in the geom bounds
     *  actually changing.
     *
     *  localBoundsChanged() simply invalidates boundsInLocal and then calls
     *  transformedBoundsChanged().
     *
     *  transformedBoundsChanged() is responsible for invalidating
     *  boundsInParent and txBounds. If the Node is not visible, then there is
     *  no need to notify the parent of the bounds change because the parent's
     *  bounds do not include invisible nodes. If the node is visible, then
     *  it must tell the parent that this child node's bounds have changed.
     *  It is up to the parent to eventually invoke its own NodeHelper.geomChanged
     *  function. If instead of a parent this node has a clipParent, then the
     *  clipParent's localBoundsChanged() is called instead.
     *
     *  There are a few other ways in which we enter the invalidate steps
     *  beyond just the geometry changes. If the visibility of a Node changes,
     *  its own bounds are not affected but its parent's bounds are. So a
     *  special call to parent.childVisibilityChanged is made so the parent
     *  can react accordingly.
     *
     *  If a transform is changed (layoutX, layoutY, rotate, transforms, etc)
     *  then the transform must be invalidated. When a transform is invalidated,
     *  it must also invalidate the txBounds by invoking
     *  transformedBoundsChanged, which will in turn notify the parent as
     *  before.
     *
     *  If an effect is changed or replaced then the local bounds must be
     *  invalidated, as well as the transformedBounds and the parent notified
     *  of the change in bounds.
     *
     *  layoutBound is somewhat unique in that it can be redefined in
     *  subclasses. By default, the layoutBounds is the geomBounds, and so
     *  whenever the geomBounds() function is called the layoutBounds
     *  must be invalidated. However in subclasses, especially Resizables,
     *  the layout bounds may not be defined to be the same as the geometric
     *  bounds. This is both useful and provides a very nice performance
     *  optimization for regions and controls. In this case, subclasses
     *  need some way to interpose themselves such that a call to
     *  NodeHelper.geomChanged() *does not* invalidate the layout bounds.
     *
     *  This interposition happens by providing the
     *  NodeHelper.notifyLayoutBoundsChanged function. The default implementation
     *  simply invalidates boundsInLocal. Subclasses (such as Region and
     *  Control) can override this function so that it does not invalidate
     *  the layout bounds.
     *
     *  An on invalidate trigger on layoutBounds handles kicking off the rest
     *  of the invalidate process for layoutBounds. Because the layout bounds
     *  define the pivot point, if scaleX, scaleY, or rotate contain
     *  non-identity values then whenever the layoutBounds change the
     *  transformed bounds also change. Finally, if this node's parent is
     *  a Region and if the Node is being managed by the Region, then
     *  we must call requestLayout on the Region whenever the layout bounds
     *  have changed.
     */

    /*
     * Invoked by subclasses whenever their geometric bounds have changed.
     * Because the default layout bounds is based on the node geometry, this
     * function will invoke NodeHelper.notifyLayoutBoundsChanged. The default
     * implementation of NodeHelper.notifyLayoutBoundsChanged() will simply invalidate
     * layoutBounds. Resizable subclasses will want to override this function
     * in most cases to be a no-op.
     *
     * This function will also invalidate the cached geom bounds, and then
     * invoke localBoundsChanged() which will eventually end up invoking a
     * chain of functions up the tree to ensure that each parent of this
     * Node is notified that its bounds may have also changed.
     *
     * This function should be treated as though it were final. It is not
     * intended to be overridden by subclasses.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doGeomChanged() {
        if (geomBoundsInvalid) {
            // GeomBoundsInvalid is false when node geometry changed and
            // the untransformed node bounds haven't been recalculated yet.
            // Most of the time, the recalculation of layout and transformed
            // node bounds don't require validation of untransformed bounds
            // and so we can not skip the following notifications.
            NodeHelper.notifyLayoutBoundsChanged(this);
            transformedBoundsChanged();
            return;
        }
        geomBounds.makeEmpty();
        geomBoundsInvalid = true;
        NodeHelper.markDirty(this, DirtyBits.NODE_BOUNDS);
        NodeHelper.notifyLayoutBoundsChanged(this);
        localBoundsChanged();
    }

    private boolean geomBoundsInvalid = true;
    private boolean localBoundsInvalid = true;
    private boolean txBoundsInvalid = true;

    /**
     * Responds to changes in the local bounds by invalidating boundsInLocal
     * and notifying this node that its transformed bounds have changed.
     */
    void localBoundsChanged() {
        localBoundsInvalid = true;
        invalidateBoundsInLocal();
        transformedBoundsChanged();
    }

    /**
     * Responds to changes in the transformed bounds by invalidating txBounds
     * and boundsInParent. If this Node is not visible, then we have no need
     * to walk further up the tree but can instead simply invalidate state.
     * Otherwise, this function will notify parents (either the parent or the
     * clipParent) that this child Node's bounds have changed.
     */
    void transformedBoundsChanged() {
        if (!txBoundsInvalid) {
            txBounds.makeEmpty();
            txBoundsInvalid = true;
            invalidateBoundsInParent();
            NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORMED_BOUNDS);
        }
        if (isVisible()) {
            notifyParentOfBoundsChange();
        }
    }

    /*
     * Invoked by geomChanged(). Since layoutBounds is by default based
     * on the geometric bounds, the default implementation of this function will
     * invalidate the layoutBounds. Resizable Node subclasses generally base
     * layoutBounds on the width/height instead of the geometric bounds, and so
     * will generally want to override this function to be a no-op.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doNotifyLayoutBoundsChanged() {
        layoutBoundsChanged();
        // notify the parent
        // Group instanceof check a little hoaky, but it allows us to disable
        // unnecessary layout for the case of a non-resizable within a group
        Parent p = getParent();

        // Need to propagate layout if parent isn't part of performing layout
        if (isManaged() &amp;&amp; (p != null) &amp;&amp; !(p instanceof Group &amp;&amp; !isResizable())
                &amp;&amp; !p.isPerformingLayout()) {
            // Force its parent to fix the layout since it is a managed child.
            p.requestLayout(true);
        }
    }

    /**
     * Notifies both the real parent and the clip parent (if they exist) that
     * the bounds of the child has changed. Note that since FX doesn't throw
     * NPE's, things actually are faster if we don't check twice for Null
     * (we check once, the compiler checks again)
     */
    void notifyParentOfBoundsChange() {
        // let the parent know which node has changed and the parent will
        // deal with marking itself invalid correctly
        Parent p = getParent();
        if (p != null) {
            p.childBoundsChanged(this);
        }
        // since the clip is used to compute the local bounds (and not the
        // geom bounds), we just need to notify that local bounds on the
        // clip parent have changed
        if (clipParent != null) {
            clipParent.localBoundsChanged();
        }
    }

    /***************************************************************************
     *                                                                         *
     * Geometry and coordinate system related APIs. For example, methods       *
     * related to containment, intersection, coordinate space conversion, etc. *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns {@code true} if the given point (specified in the local
     * coordinate space of this {@code Node}) is contained within the shape of
     * this {@code Node}. Note that this method does not take visibility into
     * account; the test is based on the geometry of this {@code Node} only.
     * @param localX the x coordinate of the point in Node's space
     * @param localY the y coordinate of the point in Node's space
     * @return the result of contains for this {@code Node}
     */
    public boolean contains(double localX, double localY) {
        if (containsBounds(localX, localY)) {
            return (isPickOnBounds() || NodeHelper.computeContains(this, localX, localY));
        }
        return false;
    }

    /*
     * This method only does the contains check based on the bounds, clip and
     * effect of this node, excluding its shape (or geometry).
     *
     * Returns true if the given point (specified in the local
     * coordinate space of this {@code Node}) is contained within the bounds,
     * clip and effect of this node.
     */
    private boolean containsBounds(double localX, double localY) {
        final TempState tempState = TempState.getInstance();
        BaseBounds tempBounds = tempState.bounds;

        // first, we do a quick test to see if the point is contained in
        // our local bounds. If so, then we will go the next step and check
        // the clip, effect, and geometry for containment.
        tempBounds = getLocalBounds(tempBounds,
                                    BaseTransform.IDENTITY_TRANSFORM);
        if (tempBounds.contains((float)localX, (float)localY)) {
            // if the clip is defined, then check it for containment, being
            // sure to convert from this node's local coordinate system
            // to the local coordinate system of the clip node
            if (getClip() != null) {
                tempState.point.x = (float)localX;
                tempState.point.y = (float)localY;
                try {
                    getClip().parentToLocal(tempState.point);
                } catch (NoninvertibleTransformException e) {
                    return false;
                }
                if (!getClip().contains(tempState.point.x, tempState.point.y)) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Returns {@code true} if the given point (specified in the local
     * coordinate space of this {@code Node}) is contained within the shape of
     * this {@code Node}. Note that this method does not take visibility into
     * account; the test is based on the geometry of this {@code Node} only.
     * @param localPoint the 2D point in Node's space
     * @return the result of contains for this {@code Node}
     */
    public boolean contains(Point2D localPoint) {
        return contains(localPoint.getX(), localPoint.getY());
    }

    /**
     * Returns {@code true} if the given rectangle (specified in the local
     * coordinate space of this {@code Node}) intersects the shape of this
     * {@code Node}. Note that this method does not take visibility into
     * account; the test is based on the geometry of this {@code Node} only.
     * The default behavior of this function is simply to check if the
     * given coordinates intersect with the local bounds.
     * @param localX the x coordinate of a rectangle in Node's space
     * @param localY the y coordinate of a rectangle in Node's space
     * @param localWidth the width of a rectangle in Node's space
     * @param localHeight the height of a rectangle in Node's space
     * @return the result of intersects for this {@code Node}
     */
    public boolean intersects(double localX, double localY, double localWidth, double localHeight) {
        BaseBounds tempBounds = TempState.getInstance().bounds;
        tempBounds = getLocalBounds(tempBounds,
                                    BaseTransform.IDENTITY_TRANSFORM);
        return tempBounds.intersects((float)localX,
                                     (float)localY,
                                     (float)localWidth,
                                     (float)localHeight);
    }

    /**
     * Returns {@code true} if the given bounds (specified in the local
     * coordinate space of this {@code Node}) intersects the shape of this
     * {@code Node}. Note that this method does not take visibility into
     * account; the test is based on the geometry of this {@code Node} only.
     * The default behavior of this function is simply to check if the
     * given coordinates intersect with the local bounds.
     * @param localBounds the bounds
     * @return the result of intersects for this {@code Node}
     */
    public boolean intersects(Bounds localBounds) {
        return intersects(localBounds.getMinX(), localBounds.getMinY(), localBounds.getWidth(), localBounds.getHeight());
    }

    /**
     * Transforms a point from the coordinate space of the {@link javafx.stage.Screen}
     * into the local coordinate space of this {@code Node}.
     * @param screenX x coordinate of a point on a Screen
     * @param screenY y coordinate of a point on a Screen
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     * @since JavaFX 8.0
     */
    public Point2D screenToLocal(double screenX, double screenY) {
        Scene scene = getScene();
        if (scene == null) return null;
        Window window = scene.getWindow();
        if (window == null) return null;

        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;

        tempPt.setLocation((float)(screenX - scene.getX() - window.getX()),
                           (float)(screenY - scene.getY() - window.getY()));

        final SubScene subScene = getSubScene();
        if (subScene != null) {
            final Point2D ssCoord = SceneUtils.sceneToSubScenePlane(subScene,
                    new Point2D(tempPt.x, tempPt.y));
            if (ssCoord == null) {
                return null;
            }
            tempPt.setLocation((float) ssCoord.getX(), (float) ssCoord.getY());
        }

        final Point3D ppIntersect =
                scene.getEffectiveCamera().pickProjectPlane(tempPt.x, tempPt.y);
        tempPt.setLocation((float) ppIntersect.getX(), (float) ppIntersect.getY());

        try {
            sceneToLocal(tempPt);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
        return new Point2D(tempPt.x, tempPt.y);
    }

    /**
     * Transforms a point from the coordinate space of the {@link javafx.stage.Screen}
     * into the local coordinate space of this {@code Node}.
     * @param screenPoint a point on a Screen
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     * @since JavaFX 8.0
     */
    public Point2D screenToLocal(Point2D screenPoint) {
        return screenToLocal(screenPoint.getX(), screenPoint.getY());
    }

    /**
     * Transforms a rectangle from the coordinate space of the
     * {@link javafx.stage.Screen} into the local coordinate space of this
     * {@code Node}. Returns reasonable result only in 2D space.
     * @param screenBounds bounds on a Screen
     * @return bounds in the local Node'space or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     * @since JavaFX 8.0
     */
    public Bounds screenToLocal(Bounds screenBounds) {
        final Point2D p1 = screenToLocal(screenBounds.getMinX(), screenBounds.getMinY());
        final Point2D p2 = screenToLocal(screenBounds.getMinX(), screenBounds.getMaxY());
        final Point2D p3 = screenToLocal(screenBounds.getMaxX(), screenBounds.getMinY());
        final Point2D p4 = screenToLocal(screenBounds.getMaxX(), screenBounds.getMaxY());

        return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
    }


    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #sceneToLocal(double, double)}.
     *
     * @param x the x coordinate
     * @param y the y coordinate
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return local coordinates of the point
     * @since JavaFX 8u40
     */
    public Point2D sceneToLocal(double x, double y, boolean rootScene) {
        if (!rootScene) {
            return sceneToLocal(x, y);
        }
        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;

        tempPt.setLocation((float)(x), (float)y);

        final SubScene subScene = getSubScene();
        if (subScene != null) {
            final Point2D ssCoord = SceneUtils.sceneToSubScenePlane(subScene,
                    new Point2D(tempPt.x, tempPt.y));
            if (ssCoord == null) {
                return null;
            }
            tempPt.setLocation((float) ssCoord.getX(), (float) ssCoord.getY());
        }

        try {
            sceneToLocal(tempPt);
            return new Point2D(tempPt.x, tempPt.y);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
    }

    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #sceneToLocal(javafx.geometry.Point2D)}.
     *
     * @param point the point
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return local coordinates of the point
     * @since JavaFX 8u40
     */
    public Point2D sceneToLocal(Point2D point, boolean rootScene) {
        return sceneToLocal(point.getX(), point.getY(), rootScene);
    }

    /**
     * Transforms a bounds from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #sceneToLocal(javafx.geometry.Bounds)}.
     * &lt;p&gt;
     *     Since 3D bounds cannot be converted with {@code rootScene} set to {@code true}, trying to convert 3D bounds will yield {@code null}.
     * &lt;/p&gt;
     * @param bounds the bounds
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return local coordinates of the bounds
     * @since JavaFX 8u40
     */
    public Bounds sceneToLocal(Bounds bounds, boolean rootScene) {
        if (!rootScene) {
            return sceneToLocal(bounds);
        }
        if (bounds.getMinZ() != 0 || bounds.getMaxZ() != 0) {
            return null;
        }
        final Point2D p1 = sceneToLocal(bounds.getMinX(), bounds.getMinY(), true);
        final Point2D p2 = sceneToLocal(bounds.getMinX(), bounds.getMaxY(), true);
        final Point2D p3 = sceneToLocal(bounds.getMaxX(), bounds.getMinY(), true);
        final Point2D p4 = sceneToLocal(bounds.getMaxX(), bounds.getMaxY(), true);

        return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
    }

    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     *
     * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     *
     * @param sceneX x coordinate of a point on a Scene
     * @param sceneY y coordinate of a point on a Scene
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     */
    public Point2D sceneToLocal(double sceneX, double sceneY) {
        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;
        tempPt.setLocation((float)sceneX, (float)sceneY);
        try {
            sceneToLocal(tempPt);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
        return new Point2D(tempPt.x, tempPt.y);
    }

    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     *
     * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     *
     * @param scenePoint a point on a Scene
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     */
    public Point2D sceneToLocal(Point2D scenePoint) {
        return sceneToLocal(scenePoint.getX(), scenePoint.getY());
    }

    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     *
     * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     *
     * @param scenePoint a point on a Scene
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     * @since JavaFX 8.0
     */
    public Point3D sceneToLocal(Point3D scenePoint) {
        return sceneToLocal(scenePoint.getX(), scenePoint.getY(), scenePoint.getZ());
    }

    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     *
     * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     *
     * @param sceneX x coordinate of a point on a Scene
     * @param sceneY y coordinate of a point on a Scene
     * @param sceneZ z coordinate of a point on a Scene
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     * @since JavaFX 8.0
     */
    public Point3D sceneToLocal(double sceneX, double sceneY, double sceneZ) {
        try {
            return sceneToLocal0(sceneX, sceneY, sceneZ);
        } catch (NoninvertibleTransformException ex) {
            return null;
        }
    }

    /**
     * Internal method to transform a point from scene to local coordinates.
     */
    private Point3D sceneToLocal0(double x, double y, double z) throws NoninvertibleTransformException {
        final com.sun.javafx.geom.Vec3d tempV3D =
                TempState.getInstance().vec3d;
        tempV3D.set(x, y, z);
        sceneToLocal(tempV3D);
        return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
    }

    /**
     * Transforms a rectangle from the coordinate space of the
     * scene into the local coordinate space of this
     * {@code Node}.
     *
     * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     *
     * @param sceneBounds bounds on a Scene
     * @return bounds in the local Node'space or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     */
    public Bounds sceneToLocal(Bounds sceneBounds) {
        // Do a quick update of localToParentTransform so that we can determine
        // if this tx is 2D transform
        updateLocalToParentTransform();
        if (localToParentTx.is2D() &amp;&amp; (sceneBounds.getMinZ() == 0) &amp;&amp; (sceneBounds.getMaxZ() == 0)) {
            Point2D p1 = sceneToLocal(sceneBounds.getMinX(), sceneBounds.getMinY());
            Point2D p2 = sceneToLocal(sceneBounds.getMaxX(), sceneBounds.getMinY());
            Point2D p3 = sceneToLocal(sceneBounds.getMaxX(), sceneBounds.getMaxY());
            Point2D p4 = sceneToLocal(sceneBounds.getMinX(), sceneBounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        try {
            Point3D p1 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMinY(), sceneBounds.getMinZ());
            Point3D p2 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMinY(), sceneBounds.getMaxZ());
            Point3D p3 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMaxY(), sceneBounds.getMinZ());
            Point3D p4 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMaxY(), sceneBounds.getMaxZ());
            Point3D p5 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMaxY(), sceneBounds.getMinZ());
            Point3D p6 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMaxY(), sceneBounds.getMaxZ());
            Point3D p7 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMinY(), sceneBounds.getMinZ());
            Point3D p8 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMinY(), sceneBounds.getMaxZ());
            return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its {@link javafx.stage.Screen}.
     * @param localX x coordinate of a point in Node's space
     * @param localY y coordinate of a point in Node's space
     * @return screen coordinates of the point or null if Node is not in a {@link Window}
     * @since JavaFX 8.0
     */
    public Point2D localToScreen(double localX, double localY) {
        return localToScreen(localX, localY, 0.0);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its {@link javafx.stage.Screen}.
     * @param localPoint a point in Node's space
     * @return screen coordinates of the point or null if Node is not in a {@link Window}
     * @since JavaFX 8.0
     */
    public Point2D localToScreen(Point2D localPoint) {
        return localToScreen(localPoint.getX(), localPoint.getY());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its {@link javafx.stage.Screen}.
     * @param localX x coordinate of a point in Node's space
     * @param localY y coordinate of a point in Node's space
     * @param localZ z coordinate of a point in Node's space
     * @return screen coordinates of the point or null if Node is not in a {@link Window}
     * @since JavaFX 8.0
     */
    public Point2D localToScreen(double localX, double localY, double localZ) {
        Scene scene = getScene();
        if (scene == null) return null;
        Window window = scene.getWindow();
        if (window == null) return null;

        Point3D pt = localToScene(localX, localY, localZ);
        final SubScene subScene = getSubScene();
        if (subScene != null) {
            pt = SceneUtils.subSceneToScene(subScene, pt);
        }
        final Point2D projection = CameraHelper.project(
                SceneHelper.getEffectiveCamera(getScene()), pt);

        return new Point2D(projection.getX() + scene.getX() + window.getX(),
                           projection.getY() + scene.getY() + window.getY());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its {@link javafx.stage.Screen}.
     * @param localPoint a point in Node's space
     * @return screen coordinates of the point or null if Node is not in a {@link Window}
     * @since JavaFX 8.0
     */
    public Point2D localToScreen(Point3D localPoint) {
        return localToScreen(localPoint.getX(), localPoint.getY(), localPoint.getZ());
    }

    /**
     * Transforms a bounds from the local coordinate space of this
     * {@code Node} into the coordinate space of its {@link javafx.stage.Screen}.
     * @param localBounds bounds in Node's space
     * @return the bounds in screen coordinates or null if Node is not in a {@link Window}
     * @since JavaFX 8.0
     */
    public Bounds localToScreen(Bounds localBounds) {
        final Point2D p1 = localToScreen(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
        final Point2D p2 = localToScreen(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
        final Point2D p3 = localToScreen(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
        final Point2D p4 = localToScreen(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
        final Point2D p5 = localToScreen(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
        final Point2D p6 = localToScreen(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
        final Point2D p7 = localToScreen(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
        final Point2D p8 = localToScreen(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());

        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     * @param localX x coordinate of a point in Node's space
     * @param localY y coordinate of a point in Node's space
     * @return scene coordinates of the point or null if Node is not in a {@link Window}
     */
    public Point2D localToScene(double localX, double localY) {
        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;
        tempPt.setLocation((float)localX, (float)localY);
        localToScene(tempPt);
        return new Point2D(tempPt.x, tempPt.y);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     * @param localPoint a point in Node's space
     * @return scene coordinates of the point or null if Node is not in a {@link Window}
     */
    public Point2D localToScene(Point2D localPoint) {
        return localToScene(localPoint.getX(), localPoint.getY());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     * @param localPoint a 3D point in Node's space
     * @return the transformed 3D point in Scene's space
     * @see #localToScene(javafx.geometry.Point3D, boolean)
     * @since JavaFX 8.0
     */
    public Point3D localToScene(Point3D localPoint) {
        return localToScene(localPoint.getX(), localPoint.getY(), localPoint.getZ());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     * @param x the x coordinate of a point in Node's space
     * @param y the y coordinate of a point in Node's space
     * @param z the z coordinate of a point in Node's space
     * @return the transformed 3D point in Scene's space
     * @see #localToScene(double, double, double, boolean)
     * @since JavaFX 8.0
     */
    public Point3D localToScene(double x, double y, double z) {
        final com.sun.javafx.geom.Vec3d tempV3D =
                TempState.getInstance().vec3d;
        tempV3D.set(x, y, z);
        localToScene(tempV3D);
        return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #localToScene(javafx.geometry.Point3D)}.
     *
     * @param localPoint the point in local coordinates
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return transformed point
     *
     * @see #localToScene(javafx.geometry.Point3D)
     * @since JavaFX 8u40
     */
    public Point3D localToScene(Point3D localPoint, boolean rootScene) {
        Point3D pt = localToScene(localPoint);
        if (rootScene) {
            final SubScene subScene = getSubScene();
            if (subScene != null) {
                pt = SceneUtils.subSceneToScene(subScene, pt);
            }
        }
        return pt;
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #localToScene(double, double, double)}.
     *
     * @param x the x coordinate of the point in local coordinates
     * @param y the y coordinate of the point in local coordinates
     * @param z the z coordinate of the point in local coordinates
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return transformed point
     *
     * @see #localToScene(double, double, double)
     * @since JavaFX 8u40
     */
    public Point3D localToScene(double x, double y, double z, boolean rootScene) {
        return localToScene(new Point3D(x, y, z), rootScene);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #localToScene(javafx.geometry.Point2D)}.
     *
     * @param localPoint the point in local coordinates
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return transformed point
     *
     * @see #localToScene(javafx.geometry.Point2D)
     * @since JavaFX 8u40
     */
    public Point2D localToScene(Point2D localPoint, boolean rootScene) {
        if (!rootScene) {
            return localToScene(localPoint);
        }
        Point3D pt = localToScene(localPoint.getX(), localPoint.getY(), 0, rootScene);
        return new Point2D(pt.getX(), pt.getY());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #localToScene(double, double)}.
     *
     * @param x the x coordinate of the point in local coordinates
     * @param y the y coordinate of the point in local coordinates
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return transformed point
     *
     * @see #localToScene(double, double)
     * @since JavaFX 8u40
     */
    public Point2D localToScene(double x, double y, boolean rootScene) {
        return localToScene(new Point2D(x, y), rootScene);
    }

    /**
     * Transforms a bounds from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * result bounds are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #localToScene(javafx.geometry.Bounds)}.
     *
     * @param localBounds the bounds in local coordinates
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return transformed bounds
     *
     * @see #localToScene(javafx.geometry.Bounds)
     * @since JavaFX 8u40
     */
    public Bounds localToScene(Bounds localBounds, boolean rootScene) {
        if (!rootScene) {
            return localToScene(localBounds);
        }
        Point3D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ(), true);
        Point3D p2 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ(), true);
        Point3D p3 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ(), true);
        Point3D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ(), true);
        Point3D p5 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ(), true);
        Point3D p6 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ(), true);
        Point3D p7 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ(), true);
        Point3D p8 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ(), true);
        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
    }

    /**
     * Transforms a bounds from the local coordinate space of this
     * {@code Node} into the coordinate space of its scene.
     * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     * @param localBounds bounds in Node's space
     * @return the bounds in the scene coordinates or null if Node is not in a {@link Window}
     * @see #localToScene(javafx.geometry.Bounds, boolean)
     */
    public Bounds localToScene(Bounds localBounds) {
        // Do a quick update of localToParentTransform so that we can determine
        // if this tx is 2D transform
        updateLocalToParentTransform();
        if (localToParentTx.is2D() &amp;&amp; (localBounds.getMinZ() == 0) &amp;&amp; (localBounds.getMaxZ() == 0)) {
            Point2D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY());
            Point2D p2 = localToScene(localBounds.getMaxX(), localBounds.getMinY());
            Point2D p3 = localToScene(localBounds.getMaxX(), localBounds.getMaxY());
            Point2D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        Point3D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
        Point3D p2 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
        Point3D p3 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
        Point3D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
        Point3D p5 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
        Point3D p6 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
        Point3D p7 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
        Point3D p8 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());
        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);

    }

    /**
     * Transforms a point from the coordinate space of the parent into the
     * local coordinate space of this {@code Node}.
     * @param parentX the x coordinate in Parent's space
     * @param parentY the y coordinate in Parent's space
     * @return the transformed 2D point in Node's space
     */
    public Point2D parentToLocal(double parentX, double parentY) {
        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;
        tempPt.setLocation((float)parentX, (float)parentY);
        try {
            parentToLocal(tempPt);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
        return new Point2D(tempPt.x, tempPt.y);
    }

    /**
     * Transforms a point from the coordinate space of the parent into the
     * local coordinate space of this {@code Node}.
     * @param parentPoint the 2D point in Parent's space
     * @return the transformed 2D point in Node's space
     */
    public Point2D parentToLocal(Point2D parentPoint) {
        return parentToLocal(parentPoint.getX(), parentPoint.getY());
    }

    /**
     * Transforms a point from the coordinate space of the parent into the
     * local coordinate space of this {@code Node}.
     * @param parentPoint parentPoint the 3D point in Parent's space
     * @return the transformed 3D point in Node's space
     * @since JavaFX 8.0
     */
    public Point3D parentToLocal(Point3D parentPoint) {
        return parentToLocal(parentPoint.getX(), parentPoint.getY(), parentPoint.getZ());
    }

    /**
     * Transforms a point from the coordinate space of the parent into the
     * local coordinate space of this {@code Node}.
     * @param parentX the x coordinate in Parent's space
     * @param parentY the y coordinate in Parent's space
     * @param parentZ the z coordinate in Parent's space
     * @return the transformed 3D point in Node's space
     * @since JavaFX 8.0
     */
    public Point3D parentToLocal(double parentX, double parentY, double parentZ) {
        final com.sun.javafx.geom.Vec3d tempV3D =
                TempState.getInstance().vec3d;
        tempV3D.set(parentX, parentY, parentZ);
        try {
            parentToLocal(tempV3D);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
        return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
    }

    /**
     * Transforms a rectangle from the coordinate space of the parent into the
     * local coordinate space of this {@code Node}.
     * @param parentBounds the bounds in Parent's space
     * @return the transformed bounds in Node's space
     */
    public Bounds parentToLocal(Bounds parentBounds) {
        // Do a quick update of localToParentTransform so that we can determine
        // if this tx is 2D transform
        updateLocalToParentTransform();
        if (localToParentTx.is2D() &amp;&amp; (parentBounds.getMinZ() == 0) &amp;&amp; (parentBounds.getMaxZ() == 0)) {
            Point2D p1 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY());
            Point2D p2 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY());
            Point2D p3 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY());
            Point2D p4 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        Point3D p1 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY(), parentBounds.getMinZ());
        Point3D p2 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY(), parentBounds.getMaxZ());
        Point3D p3 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY(), parentBounds.getMinZ());
        Point3D p4 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY(), parentBounds.getMaxZ());
        Point3D p5 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY(), parentBounds.getMinZ());
        Point3D p6 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY(), parentBounds.getMaxZ());
        Point3D p7 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY(), parentBounds.getMinZ());
        Point3D p8 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY(), parentBounds.getMaxZ());
        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its parent.
     * @param localX the x coordinate of the point in Node's space
     * @param localY the y coordinate of the point in Node's space
     * @return the transformed 2D point in Parent's space
     */
    public Point2D localToParent(double localX, double localY) {
        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;
        tempPt.setLocation((float)localX, (float)localY);
        localToParent(tempPt);
        return new Point2D(tempPt.x, tempPt.y);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its parent.
     * @param localPoint the 2D point in Node's space
     * @return the transformed 2D point in Parent's space
     */
    public Point2D localToParent(Point2D localPoint) {
        return localToParent(localPoint.getX(), localPoint.getY());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its parent.
     * @param localPoint the 3D point in Node's space
     * @return the transformed 3D point in Parent's space
     * @since JavaFX 8.0
     */
    public Point3D localToParent(Point3D localPoint) {
        return localToParent(localPoint.getX(), localPoint.getY(), localPoint.getZ());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its parent.
     * @param x the x coordinate of the point in Node's space
     * @param y the y coordinate of the point in Node's space
     * @param z the z coordinate of the point in Node's space
     * @return the transformed 3D point in Parent's space
     * @since JavaFX 8.0
     */
    public Point3D localToParent(double x, double y, double z) {
        final com.sun.javafx.geom.Vec3d tempV3D =
                TempState.getInstance().vec3d;
        tempV3D.set(x, y, z);
        localToParent(tempV3D);
        return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
    }

    /**
     * Transforms a bounds from the local coordinate space of this
     * {@code Node} into the coordinate space of its parent.
     * @param localBounds the bounds in Node's space
     * @return the transformed bounds in Parent's space
     */
    public Bounds localToParent(Bounds localBounds) {
        // Do a quick update of localToParentTransform so that we can determine
        // if this tx is 2D transform
        updateLocalToParentTransform();
        if (localToParentTx.is2D() &amp;&amp; (localBounds.getMinZ() == 0) &amp;&amp; (localBounds.getMaxZ() == 0)) {
            Point2D p1 = localToParent(localBounds.getMinX(), localBounds.getMinY());
            Point2D p2 = localToParent(localBounds.getMaxX(), localBounds.getMinY());
            Point2D p3 = localToParent(localBounds.getMaxX(), localBounds.getMaxY());
            Point2D p4 = localToParent(localBounds.getMinX(), localBounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        Point3D p1 = localToParent(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
        Point3D p2 = localToParent(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
        Point3D p3 = localToParent(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
        Point3D p4 = localToParent(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
        Point3D p5 = localToParent(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
        Point3D p6 = localToParent(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
        Point3D p7 = localToParent(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
        Point3D p8 = localToParent(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());
        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
    }

    /**
     * Copy the localToParent transform into specified transform.
     */
    BaseTransform getLocalToParentTransform(BaseTransform tx) {
        updateLocalToParentTransform();
        tx.setTransform(localToParentTx);
        return tx;
    }

    /*
     * Currently used only by PathTransition
     */
    final BaseTransform getLeafTransform() {
        return getLocalToParentTransform(TempState.getInstance().leafTx);
    }

    /*
     * Invoked whenever the transforms[] ObservableList changes, or by the transforms
     * in that ObservableList whenever they are changed.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doTransformsChanged() {
        if (!transformDirty) {
            NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORM);
            transformDirty = true;
            transformedBoundsChanged();
        }
        invalidateLocalToParentTransform();
        invalidateLocalToSceneTransform();
    }

    final double getPivotX() {
        final Bounds bounds = getLayoutBounds();
        return bounds.getMinX() + bounds.getWidth()/2;
    }

    final double getPivotY() {
        final Bounds bounds = getLayoutBounds();
        return bounds.getMinY() + bounds.getHeight()/2;
    }

    final double getPivotZ() {
        final Bounds bounds = getLayoutBounds();
        return bounds.getMinZ() + bounds.getDepth()/2;
    }

    /**
     * This helper function will update the transform matrix on the peer based
     * on the &quot;complete&quot; transform for this node.
     */
    void updateLocalToParentTransform() {
        if (transformDirty) {
            localToParentTx.setToIdentity();

            boolean mirror = false;
            double mirroringCenter = 0;
            if (hasMirroring()) {
                final Scene sceneValue = getScene();
                if ((sceneValue != null) &amp;&amp; (sceneValue.getRoot() == this)) {
                    // handle scene mirroring in this branch
                    // (must be the last transformation)
                    mirroringCenter = sceneValue.getWidth() / 2;
                    if (mirroringCenter == 0.0) {
                        mirroringCenter = getPivotX();
                    }

                    localToParentTx = localToParentTx.deriveWithTranslation(
                            mirroringCenter, 0.0);
                    localToParentTx = localToParentTx.deriveWithScale(
                            -1.0, 1.0, 1.0);
                    localToParentTx = localToParentTx.deriveWithTranslation(
                            -mirroringCenter, 0.0);
                } else {
                    // mirror later
                    mirror = true;
                    mirroringCenter = getPivotX();
                }
            }

            if (getScaleX() != 1 || getScaleY() != 1 || getScaleZ() != 1 || getRotate() != 0) {
                // recompute pivotX, pivotY and pivotZ
                double pivotX = getPivotX();
                double pivotY = getPivotY();
                double pivotZ = getPivotZ();

                localToParentTx = localToParentTx.deriveWithTranslation(
                        getTranslateX() + getLayoutX() + pivotX,
                        getTranslateY() + getLayoutY() + pivotY,
                        getTranslateZ() + pivotZ);
                localToParentTx = localToParentTx.deriveWithRotation(
                        Math.toRadians(getRotate()), getRotationAxis().getX(),
                        getRotationAxis().getY(), getRotationAxis().getZ());
                localToParentTx = localToParentTx.deriveWithScale(
                        getScaleX(), getScaleY(), getScaleZ());
                localToParentTx = localToParentTx.deriveWithTranslation(
                        -pivotX, -pivotY, -pivotZ);
            } else {
                localToParentTx = localToParentTx.deriveWithTranslation(
                        getTranslateX() + getLayoutX(),
                        getTranslateY() + getLayoutY(),
                        getTranslateZ());
            }

            if (hasTransforms()) {
                for (Transform t : getTransforms()) {
                    localToParentTx = TransformHelper.derive(t, localToParentTx);
                }
            }

            // Check to see whether the node requires mirroring
            if (mirror) {
                localToParentTx = localToParentTx.deriveWithTranslation(
                        mirroringCenter, 0);
                localToParentTx = localToParentTx.deriveWithScale(
                        -1.0, 1.0, 1.0);
                localToParentTx = localToParentTx.deriveWithTranslation(
                        -mirroringCenter, 0);
            }

            transformDirty = false;
        }
    }

    /**
     * Transforms in place the specified point from parent coords to local
     * coords. Made package private for the sake of testing.
     */
    void parentToLocal(com.sun.javafx.geom.Point2D pt) throws NoninvertibleTransformException {
        updateLocalToParentTransform();
        localToParentTx.inverseTransform(pt, pt);
    }

    void parentToLocal(com.sun.javafx.geom.Vec3d pt) throws NoninvertibleTransformException {
        updateLocalToParentTransform();
        localToParentTx.inverseTransform(pt, pt);
    }

    void sceneToLocal(com.sun.javafx.geom.Point2D pt) throws NoninvertibleTransformException {
        if (getParent() != null) {
            getParent().sceneToLocal(pt);
        }
        parentToLocal(pt);
    }

    void sceneToLocal(com.sun.javafx.geom.Vec3d pt) throws NoninvertibleTransformException {
        if (getParent() != null) {
            getParent().sceneToLocal(pt);
        }
        parentToLocal(pt);
    }

    void localToScene(com.sun.javafx.geom.Point2D pt) {
        localToParent(pt);
        if (getParent() != null) {
            getParent().localToScene(pt);
        }
    }

    void localToScene(com.sun.javafx.geom.Vec3d pt) {
        localToParent(pt);
        if (getParent() != null) {
            getParent().localToScene(pt);
        }
    }

    /***************************************************************************
     *                                                                         *
     * Mouse event related APIs                                                *
     *                                                                         *
     **************************************************************************/

    /**
     * Transforms in place the specified point from local coords to parent
     * coords. Made package private for the sake of testing.
     */
    void localToParent(com.sun.javafx.geom.Point2D pt) {
        updateLocalToParentTransform();
        localToParentTx.transform(pt, pt);
    }

    void localToParent(com.sun.javafx.geom.Vec3d pt) {
        updateLocalToParentTransform();
        localToParentTx.transform(pt, pt);
    }

    /*
     * Finds a top-most child node that contains the given local coordinates.
     *
     * The result argument is used for storing the picking result.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doPickNodeLocal(PickRay localPickRay, PickResultChooser result) {
        intersects(localPickRay, result);
    }

    /*
     * Finds a top-most child node that intersects the given ray.
     *
     * The result argument is used for storing the picking result.
     */
    final void pickNode(PickRay pickRay, PickResultChooser result) {

        // In some conditions we can omit picking this node or subgraph
        if (!isVisible() || isDisable() || isMouseTransparent()) {
            return;
        }

        final Vec3d o = pickRay.getOriginNoClone();
        final double ox = o.x;
        final double oy = o.y;
        final double oz = o.z;
        final Vec3d d = pickRay.getDirectionNoClone();
        final double dx = d.x;
        final double dy = d.y;
        final double dz = d.z;

        updateLocalToParentTransform();
        try {
            localToParentTx.inverseTransform(o, o);
            localToParentTx.inverseDeltaTransform(d, d);

            // Delegate to a function which can be overridden by subclasses which
            // actually does the pick. The implementation is markedly different
            // for leaf nodes vs. parent nodes vs. region nodes.
            NodeHelper.pickNodeLocal(this, pickRay, result);
        } catch (NoninvertibleTransformException e) {
            // in this case we just don't pick anything
        }

        pickRay.setOrigin(ox, oy, oz);
        pickRay.setDirection(dx, dy, dz);
    }

    /*
     * Returns {@code true} if the given ray (start, dir), specified in the
     * local coordinate space of this {@code Node}, intersects the
     * shape of this {@code Node}. Note that this method does not take visibility
     * into account; the test is based on the geometry of this {@code Node} only.
     * &lt;p&gt;
     * The pickResult is updated if the found intersection is closer than
     * the currently held one.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     */
    final boolean intersects(PickRay pickRay, PickResultChooser pickResult) {
        double boundsDistance = intersectsBounds(pickRay);
        if (!Double.isNaN(boundsDistance)) {
            if (isPickOnBounds()) {
                if (pickResult != null) {
                    pickResult.offer(this, boundsDistance, PickResultChooser.computePoint(pickRay, boundsDistance));
                }
                return true;
            } else {
                return NodeHelper.computeIntersects(this, pickRay, pickResult);
            }
        }
        return false;
    }

    /*
     * Computes the intersection of the pickRay with this node.
     * The pickResult argument is updated if the found intersection
     * is closer than the passed one. On the other hand, the return value
     * specifies whether the intersection exists, regardless of its comparison
     * with the given pickResult.
     */
    private boolean doComputeIntersects(PickRay pickRay, PickResultChooser pickResult) {
        double origZ = pickRay.getOriginNoClone().z;
        double dirZ = pickRay.getDirectionNoClone().z;
        // Handle the case where pickRay is almost parallel to the Z-plane
        if (almostZero(dirZ)) {
            return false;
        }
        double t = -origZ / dirZ;
        if (t &lt; pickRay.getNearClip() || t &gt; pickRay.getFarClip()) {
            return false;
        }
        double x = pickRay.getOriginNoClone().x + (pickRay.getDirectionNoClone().x * t);
        double y = pickRay.getOriginNoClone().y + (pickRay.getDirectionNoClone().y * t);

        if (contains((float) x, (float) y)) {
            if (pickResult != null) {
                pickResult.offer(this, t, PickResultChooser.computePoint(pickRay, t));
            }
            return true;
        }
        return false;
    }

    /*
     * Computes the intersection of the pickRay with the bounds of this node.
     * The return value is the distance between the camera and the intersection
     * point, measured in pickRay direction magnitudes. If there is
     * no intersection, it returns NaN.
     *
     * @param pickRay The pick ray
     * @return Distance of the intersection point, a NaN if there
     *         is no intersection
     */
    final double intersectsBounds(PickRay pickRay) {

        final Vec3d dir = pickRay.getDirectionNoClone();
        double tmin, tmax;

        final Vec3d origin = pickRay.getOriginNoClone();
        final double originX = origin.x;
        final double originY = origin.y;
        final double originZ = origin.z;

        final TempState tempState = TempState.getInstance();
        BaseBounds tempBounds = tempState.bounds;

        tempBounds = getLocalBounds(tempBounds,
                                    BaseTransform.IDENTITY_TRANSFORM);

        if (dir.x == 0.0 &amp;&amp; dir.y == 0.0) {
            // fast path for the usual 2D picking

            if (dir.z == 0.0) {
                return Double.NaN;
            }

            if (originX &lt; tempBounds.getMinX() ||
                    originX &gt; tempBounds.getMaxX() ||
                    originY &lt; tempBounds.getMinY() ||
                    originY &gt; tempBounds.getMaxY()) {
                return Double.NaN;
            }

            final double invDirZ = 1.0 / dir.z;
            final boolean signZ = invDirZ &lt; 0.0;

            final double minZ = tempBounds.getMinZ();
            final double maxZ = tempBounds.getMaxZ();
            tmin = ((signZ ? maxZ : minZ) - originZ) * invDirZ;
            tmax = ((signZ ? minZ : maxZ) - originZ) * invDirZ;

        } else if (tempBounds.getDepth() == 0.0) {
            // fast path for 3D picking of 2D bounds

            if (almostZero(dir.z)) {
                return Double.NaN;
            }

            final double t = (tempBounds.getMinZ() - originZ) / dir.z;
            final double x = originX + (dir.x * t);
            final double y = originY + (dir.y * t);

            if (x &lt; tempBounds.getMinX() ||
                    x &gt; tempBounds.getMaxX() ||
                    y &lt; tempBounds.getMinY() ||
                    y &gt; tempBounds.getMaxY()) {
                return Double.NaN;
            }

            tmin = tmax = t;

        } else {

            final double invDirX = dir.x == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.x);
            final double invDirY = dir.y == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.y);
            final double invDirZ = dir.z == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.z);
            final boolean signX = invDirX &lt; 0.0;
            final boolean signY = invDirY &lt; 0.0;
            final boolean signZ = invDirZ &lt; 0.0;
            final double minX = tempBounds.getMinX();
            final double minY = tempBounds.getMinY();
            final double maxX = tempBounds.getMaxX();
            final double maxY = tempBounds.getMaxY();

            tmin = Double.NEGATIVE_INFINITY;
            tmax = Double.POSITIVE_INFINITY;
            if (Double.isInfinite(invDirX)) {
                if (minX &lt;= originX &amp;&amp; maxX &gt;= originX) {
                    // move on, we are inside for the whole length
                } else {
                    return Double.NaN;
                }
            } else {
                tmin = ((signX ? maxX : minX) - originX) * invDirX;
                tmax = ((signX ? minX : maxX) - originX) * invDirX;
            }

            if (Double.isInfinite(invDirY)) {
                if (minY &lt;= originY &amp;&amp; maxY &gt;= originY) {
                    // move on, we are inside for the whole length
                } else {
                    return Double.NaN;
                }
            } else {
                final double tymin = ((signY ? maxY : minY) - originY) * invDirY;
                final double tymax = ((signY ? minY : maxY) - originY) * invDirY;

                if ((tmin &gt; tymax) || (tymin &gt; tmax)) {
                    return Double.NaN;
                }
                if (tymin &gt; tmin) {
                    tmin = tymin;
                }
                if (tymax &lt; tmax) {
                    tmax = tymax;
                }
            }

            final double minZ = tempBounds.getMinZ();
            final double maxZ = tempBounds.getMaxZ();
            if (Double.isInfinite(invDirZ)) {
                if (minZ &lt;= originZ &amp;&amp; maxZ &gt;= originZ) {
                    // move on, we are inside for the whole length
                } else {
                    return Double.NaN;
                }
            } else {
                final double tzmin = ((signZ ? maxZ : minZ) - originZ) * invDirZ;
                final double tzmax = ((signZ ? minZ : maxZ) - originZ) * invDirZ;

                if ((tmin &gt; tzmax) || (tzmin &gt; tmax)) {
                    return Double.NaN;
                }
                if (tzmin &gt; tmin) {
                    tmin = tzmin;
                }
                if (tzmax &lt; tmax) {
                    tmax = tzmax;
                }
            }
        }

        // For clip we use following semantics: pick the node normally
        // if there is an intersection with the clip node. We don't consider
        // clip node distance.
        Node clip = getClip();
        if (clip != null
                // FIXME: All 3D picking is currently ignored by rendering.
                // Until this is fixed or defined differently (RT-28510),
                // we follow this behavior.
                &amp;&amp; !(this instanceof Shape3D) &amp;&amp; !(clip instanceof Shape3D)) {
            final double dirX = dir.x;
            final double dirY = dir.y;
            final double dirZ = dir.z;

            clip.updateLocalToParentTransform();

            boolean hitClip = true;
            try {
                clip.localToParentTx.inverseTransform(origin, origin);
                clip.localToParentTx.inverseDeltaTransform(dir, dir);
            } catch (NoninvertibleTransformException e) {
                hitClip = false;
            }
            hitClip = hitClip &amp;&amp; clip.intersects(pickRay, null);
            pickRay.setOrigin(originX, originY, originZ);
            pickRay.setDirection(dirX, dirY, dirZ);

            if (!hitClip) {
                return Double.NaN;
            }
        }

        if (Double.isInfinite(tmin) || Double.isNaN(tmin)) {
            // We've got a nonsense pick ray or bounds.
            return Double.NaN;
        }

        final double minDistance = pickRay.getNearClip();
        final double maxDistance = pickRay.getFarClip();
        if (tmin &lt; minDistance) {
            if (tmax &gt;= minDistance) {
                // we are inside bounds
                return 0.0;
            } else {
                return Double.NaN;
            }
        } else if (tmin &gt; maxDistance) {
            return Double.NaN;
        }

        return tmin;
    }


    // Good to find a home for commonly use util. code such as EPS.
    // and almostZero. This code currently defined in multiple places,
    // such as Affine3D and GeneralTransform3D.
    private static final double EPSILON_ABSOLUTE = 1.0e-5;

    static boolean almostZero(double a) {
        return ((a &lt; EPSILON_ABSOLUTE) &amp;&amp; (a &gt; -EPSILON_ABSOLUTE));
    }

    /***************************************************************************
     *                                                                         *
     *                      viewOrder property handling                        *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines the rendering and picking order of this {@code Node} within its
     * parent.
     * &lt;p&gt;
     * This property is used to alter the rendering and picking order of a node
     * within its parent without reordering the parent's {@code children} list.
     * For example, this can be used as a more efficient way to implement
     * transparency sorting. To do this, an application can assign the viewOrder
     * value of each node to the computed distance between that node and the
     * viewer.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The parent will traverse its {@code children} in decreasing
     * {@code viewOrder} order. This means that a child with a lower
     * {@code viewOrder} will be in front of a child with a higher
     * {@code viewOrder}. If two children have the same {@code viewOrder}, the
     * parent will traverse them in the order they appear in the parent's
     * {@code children} list.
     * &lt;/p&gt;
     * &lt;p&gt;
     * However, {@code viewOrder} does not alter the layout and focus traversal
     * order of this Node within its parent. A parent always traverses its
     * {@code children} list in order when doing layout or focus traversal.
     * &lt;/p&gt;
     *
     * @return the view order for this {@code Node}
     * @defaultValue 0.0
     *
     * @since 9
     */
    public final DoubleProperty viewOrderProperty() {
        return getMiscProperties().viewOrderProperty();
    }

    public final void setViewOrder(double value) {
        viewOrderProperty().set(value);
    }

    public final double getViewOrder() {
        return (miscProperties == null) ? DEFAULT_VIEW_ORDER
                : miscProperties.getViewOrder();
    }

    /***************************************************************************
     *                                                                         *
     *                             Transformations                             *
     *                                                                         *
     **************************************************************************/
    /**
     * Defines the ObservableList of {@link javafx.scene.transform.Transform} objects
     * to be applied to this {@code Node}. This ObservableList of transforms is applied
     * before {@link #translateXProperty translateX}, {@link #translateYProperty translateY}, {@link #scaleXProperty scaleX}, and
     * {@link #scaleYProperty scaleY}, {@link #rotateProperty rotate} transforms.
     *
     * @return the transforms for this {@code Node}
     * @defaultValue empty
     */
    public final ObservableList&lt;Transform&gt; getTransforms() {
        return transformsProperty();
    }

    private ObservableList&lt;Transform&gt; transformsProperty() {
        return getNodeTransformation().getTransforms();
    }

    public final void setTranslateX(double value) {
        translateXProperty().set(value);
    }

    public final double getTranslateX() {
        return (nodeTransformation == null)
                ? DEFAULT_TRANSLATE_X
                : nodeTransformation.getTranslateX();
    }

    /**
     * Defines the x coordinate of the translation that is added to this {@code Node}'s
     * transform.
     * &lt;p&gt;
     * The node's final translation will be computed as {@link #layoutXProperty layoutX} + {@code translateX},
     * where {@code layoutX} establishes the node's stable position and {@code translateX}
     * optionally makes dynamic adjustments to that position.
     *&lt;p&gt;
     * This variable can be used to alter the location of a node without disturbing
     * its {@link #layoutBoundsProperty layoutBounds}, which makes it useful for animating a node's location.
     *
     * @return the translateX for this {@code Node}
     * @defaultValue 0
     */
    public final DoubleProperty translateXProperty() {
        return getNodeTransformation().translateXProperty();
    }

    public final void setTranslateY(double value) {
        translateYProperty().set(value);
    }

    public final double getTranslateY() {
        return (nodeTransformation == null)
                ? DEFAULT_TRANSLATE_Y
                : nodeTransformation.getTranslateY();
    }

    /**
     * Defines the y coordinate of the translation that is added to this {@code Node}'s
     * transform.
     * &lt;p&gt;
     * The node's final translation will be computed as {@link #layoutYProperty layoutY} + {@code translateY},
     * where {@code layoutY} establishes the node's stable position and {@code translateY}
     * optionally makes dynamic adjustments to that position.
     * &lt;p&gt;
     * This variable can be used to alter the location of a node without disturbing
     * its {@link #layoutBoundsProperty layoutBounds}, which makes it useful for animating a node's location.
     *
     * @return the translateY for this {@code Node}
     * @defaultValue 0
     */
    public final DoubleProperty translateYProperty() {
        return getNodeTransformation().translateYProperty();
    }

    public final void setTranslateZ(double value) {
        translateZProperty().set(value);
    }

    public final double getTranslateZ() {
        return (nodeTransformation == null)
                ? DEFAULT_TRANSLATE_Z
                : nodeTransformation.getTranslateZ();
    }

    /**
     * Defines the Z coordinate of the translation that is added to the
     * transformed coordinates of this {@code Node}.  This value will be added
     * to any translation defined by the {@code transforms} ObservableList and
     * {@code layoutZ}.
     * &lt;p&gt;
     * This variable can be used to alter the location of a Node without
     * disturbing its layout bounds, which makes it useful for animating a
     * node's location.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @return the translateZ for this {@code Node}
     * @defaultValue 0
     */
    public final DoubleProperty translateZProperty() {
        return getNodeTransformation().translateZProperty();
    }

    public final void setScaleX(double value) {
        scaleXProperty().set(value);
    }

    public final double getScaleX() {
        return (nodeTransformation == null) ? DEFAULT_SCALE_X
                                            : nodeTransformation.getScaleX();
    }

    /**
     * Defines the factor by which coordinates are scaled about the center of the
     * object along the X axis of this {@code Node}. This is used to stretch or
     * shrink the node either manually or by using an animation.
     * &lt;p&gt;
     * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
     * default, which makes it ideal for scaling the entire node after
     * all effects and transforms have been taken into account.
     * &lt;p&gt;
     * The pivot point about which the scale occurs is the center of the
     * untransformed {@link #layoutBoundsProperty layoutBounds}.
     *
     * @return the scaleX for this {@code Node}
     * @defaultValue 1.0
     */
    public final DoubleProperty scaleXProperty() {
        return getNodeTransformation().scaleXProperty();
    }

    public final void setScaleY(double value) {
        scaleYProperty().set(value);
    }

    public final double getScaleY() {
        return (nodeTransformation == null) ? DEFAULT_SCALE_Y
                                            : nodeTransformation.getScaleY();
    }

    /**
     * Defines the factor by which coordinates are scaled about the center of the
     * object along the Y axis of this {@code Node}. This is used to stretch or
     * shrink the node either manually or by using an animation.
     * &lt;p&gt;
     * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
     * default, which makes it ideal for scaling the entire node after
     * all effects and transforms have been taken into account.
     * &lt;p&gt;
     * The pivot point about which the scale occurs is the center of the
     * untransformed {@link #layoutBoundsProperty layoutBounds}.
     *
     * @return the scaleY for this {@code Node}
     * @defaultValue 1.0
     */
    public final DoubleProperty scaleYProperty() {
        return getNodeTransformation().scaleYProperty();
    }

    public final void setScaleZ(double value) {
        scaleZProperty().set(value);
    }

    public final double getScaleZ() {
        return (nodeTransformation == null) ? DEFAULT_SCALE_Z
                                            : nodeTransformation.getScaleZ();
    }

    /**
     * Defines the factor by which coordinates are scaled about the center of the
     * object along the Z axis of this {@code Node}. This is used to stretch or
     * shrink the node either manually or by using an animation.
     * &lt;p&gt;
     * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
     * default, which makes it ideal for scaling the entire node after
     * all effects and transforms have been taken into account.
     * &lt;p&gt;
     * The pivot point about which the scale occurs is the center of the
     * rectangular bounds formed by taking {@link #boundsInLocalProperty boundsInLocal} and applying
     * all the transforms in the {@link #getTransforms transforms} ObservableList.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @return the scaleZ for this {@code Node}
     * @defaultValue 1.0
     */
    public final DoubleProperty scaleZProperty() {
        return getNodeTransformation().scaleZProperty();
    }

    public final void setRotate(double value) {
        rotateProperty().set(value);
    }

    public final double getRotate() {
        return (nodeTransformation == null) ? DEFAULT_ROTATE
                                            : nodeTransformation.getRotate();
    }

    /**
     * Defines the angle of rotation about the {@code Node}'s center, measured in
     * degrees. This is used to rotate the {@code Node}.
     * &lt;p&gt;
     * This rotation factor is not included in {@link #layoutBoundsProperty layoutBounds} by
     * default, which makes it ideal for rotating the entire node after
     * all effects and transforms have been taken into account.
     * &lt;p&gt;
     * The pivot point about which the rotation occurs is the center of the
     * untransformed {@link #layoutBoundsProperty layoutBounds}.
     * &lt;p&gt;
     * Note that because the pivot point is computed as the center of this
     * {@code Node}'s layout bounds, any change to the layout bounds will cause
     * the pivot point to change, which can move the object. For a leaf node,
     * any change to the geometry will cause the layout bounds to change.
     * For a group node, any change to any of its children, including a
     * change in a child's geometry, clip, effect, position, orientation, or
     * scale, will cause the group's layout bounds to change. If this movement
     * of the pivot point is not
     * desired, applications should instead use the Node's {@link #getTransforms transforms}
     * ObservableList, and add a {@link javafx.scene.transform.Rotate} transform,
     * which has a user-specifiable pivot point.
     *
     * @return the rotate for this {@code Node}
     * @defaultValue 0.0
     */
    public final DoubleProperty rotateProperty() {
        return getNodeTransformation().rotateProperty();
    }

    public final void setRotationAxis(Point3D value) {
        rotationAxisProperty().set(value);
    }

    public final Point3D getRotationAxis() {
        return (nodeTransformation == null)
                ? DEFAULT_ROTATION_AXIS
                : nodeTransformation.getRotationAxis();
    }

    /**
     * Defines the axis of rotation of this {@code Node}.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @return the rotationAxis for this {@code Node}
     * @defaultValue Rotate.Z_AXIS
     */
    public final ObjectProperty&lt;Point3D&gt; rotationAxisProperty() {
        return getNodeTransformation().rotationAxisProperty();
    }

    /**
     * An affine transform that holds the computed local-to-parent transform.
     * This is the concatenation of all transforms in this node, including all
     * of the convenience transforms.
     * @return the localToParent transform for this {@code Node}
     * @since JavaFX 2.2
     */
    public final ReadOnlyObjectProperty&lt;Transform&gt; localToParentTransformProperty() {
        return getNodeTransformation().localToParentTransformProperty();
    }

    private void invalidateLocalToParentTransform() {
        if (nodeTransformation != null) {
            nodeTransformation.invalidateLocalToParentTransform();
        }
    }

    public final Transform getLocalToParentTransform() {
        return localToParentTransformProperty().get();
    }

    /**
     * An affine transform that holds the computed local-to-scene transform.
     * This is the concatenation of all transforms in this node's parents and
     * in this node, including all of the convenience transforms up to the root.
     * If this node is in a {@link javafx.scene.SubScene}, this property represents
     * transforms up to the subscene, not the root scene.
     *
     * &lt;p&gt;
     * Note that when you register a listener or a binding to this property,
     * it needs to listen for invalidation on all its parents to the root node.
     * This means that registering a listener on this
     * property on many nodes may negatively affect performance of
     * transformation changes in their common parents.
     * &lt;/p&gt;
     *
     * @return the localToScene transform for this {@code Node}
     * @since JavaFX 2.2
     */
    public final ReadOnlyObjectProperty&lt;Transform&gt; localToSceneTransformProperty() {
        return getNodeTransformation().localToSceneTransformProperty();
    }

    private void invalidateLocalToSceneTransform() {
        if (nodeTransformation != null) {
            nodeTransformation.invalidateLocalToSceneTransform();
        }
    }

    public final Transform getLocalToSceneTransform() {
        return localToSceneTransformProperty().get();
    }

    private NodeTransformation nodeTransformation;

    private NodeTransformation getNodeTransformation() {
        if (nodeTransformation == null) {
            nodeTransformation = new NodeTransformation();
        }

        return nodeTransformation;
    }

    private boolean hasTransforms() {
        return (nodeTransformation != null)
                &amp;&amp; nodeTransformation.hasTransforms();
    }

    // for tests only
    Transform getCurrentLocalToSceneTransformState() {
        if (nodeTransformation == null ||
                nodeTransformation.localToSceneTransform == null) {
            return null;
        }

        return nodeTransformation.localToSceneTransform.transform;
    }

    private static final double DEFAULT_TRANSLATE_X = 0;
    private static final double DEFAULT_TRANSLATE_Y = 0;
    private static final double DEFAULT_TRANSLATE_Z = 0;
    private static final double DEFAULT_SCALE_X = 1;
    private static final double DEFAULT_SCALE_Y = 1;
    private static final double DEFAULT_SCALE_Z = 1;
    private static final double DEFAULT_ROTATE = 0;
    private static final Point3D DEFAULT_ROTATION_AXIS = Rotate.Z_AXIS;

    private final class NodeTransformation {
        private DoubleProperty translateX;
        private DoubleProperty translateY;
        private DoubleProperty translateZ;
        private DoubleProperty scaleX;
        private DoubleProperty scaleY;
        private DoubleProperty scaleZ;
        private DoubleProperty rotate;
        private ObjectProperty&lt;Point3D&gt; rotationAxis;
        private ObservableList&lt;Transform&gt; transforms;
        private LazyTransformProperty localToParentTransform;
        private LazyTransformProperty localToSceneTransform;
        private int listenerReasons = 0;
        private InvalidationListener localToSceneInvLstnr;

        private InvalidationListener getLocalToSceneInvalidationListener() {
            if (localToSceneInvLstnr == null) {
                localToSceneInvLstnr = observable -&gt; invalidateLocalToSceneTransform();
            }
            return localToSceneInvLstnr;
        }

        public void incListenerReasons() {
            if (listenerReasons == 0) {
                Node n = Node.this.getParent();
                if (n != null) {
                    n.localToSceneTransformProperty().addListener(
                            getLocalToSceneInvalidationListener());
                }
            }
            listenerReasons++;
        }

        public void decListenerReasons() {
            listenerReasons--;
            if (listenerReasons == 0) {
                Node n = Node.this.getParent();
                if (n != null) {
                    n.localToSceneTransformProperty().removeListener(
                            getLocalToSceneInvalidationListener());
                }
                if (localToSceneTransform != null) {
                    localToSceneTransform.validityUnknown();
                }
            }
        }

        public final Transform getLocalToParentTransform() {
            return localToParentTransformProperty().get();
        }

        public final ReadOnlyObjectProperty&lt;Transform&gt; localToParentTransformProperty() {
            if (localToParentTransform == null) {
                localToParentTransform = new LazyTransformProperty() {
                    @Override
                    protected Transform computeTransform(Transform reuse) {
                        updateLocalToParentTransform();
                        return TransformUtils.immutableTransform(reuse,
                                localToParentTx.getMxx(), localToParentTx.getMxy(), localToParentTx.getMxz(), localToParentTx.getMxt(),
                                localToParentTx.getMyx(), localToParentTx.getMyy(), localToParentTx.getMyz(), localToParentTx.getMyt(),
                                localToParentTx.getMzx(), localToParentTx.getMzy(), localToParentTx.getMzz(), localToParentTx.getMzt());
                    }

                    @Override
                    protected boolean validityKnown() {
                        return true;
                    }

                    @Override
                    protected int computeValidity() {
                        return valid;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;localToParentTransform&quot;;
                    }
                };
            }

            return localToParentTransform;
        }

        public void invalidateLocalToParentTransform() {
            if (localToParentTransform != null) {
                localToParentTransform.invalidate();
            }
        }

        public final Transform getLocalToSceneTransform() {
            return localToSceneTransformProperty().get();
        }

        class LocalToSceneTransformProperty extends LazyTransformProperty {
            // need this to track number of listeners
            private List localToSceneListeners;
            // stamps to watch for parent changes when the listeners
            // are not present
            private long stamp, parentStamp;

            @Override
            protected Transform computeTransform(Transform reuse) {
                stamp++;
                updateLocalToParentTransform();

                Node parentNode = Node.this.getParent();
                if (parentNode != null) {
                    final LocalToSceneTransformProperty parentProperty =
                            (LocalToSceneTransformProperty) parentNode.localToSceneTransformProperty();
                    final Transform parentTransform = parentProperty.getInternalValue();

                    parentStamp = parentProperty.stamp;

                    return TransformUtils.immutableTransform(reuse,
                            parentTransform,
                            ((LazyTransformProperty) localToParentTransformProperty()).getInternalValue());
                } else {
                    return TransformUtils.immutableTransform(reuse,
                            ((LazyTransformProperty) localToParentTransformProperty()).getInternalValue());
                }
            }

            @Override
            public Object getBean() {
                return Node.this;
            }

            @Override
            public String getName() {
                return &quot;localToSceneTransform&quot;;
            }

            @Override
            protected boolean validityKnown() {
                return listenerReasons &gt; 0;
            }

            @Override
            protected int computeValidity() {
                if (valid != VALIDITY_UNKNOWN) {
                    return valid;
                }

                Node n = (Node) getBean();
                Node parent = n.getParent();

                if (parent != null) {
                    final LocalToSceneTransformProperty parentProperty =
                            (LocalToSceneTransformProperty) parent.localToSceneTransformProperty();

                    if (parentStamp != parentProperty.stamp) {
                        valid = INVALID;
                        return INVALID;
                    }

                    int parentValid = parentProperty.computeValidity();
                    if (parentValid == INVALID) {
                        valid = INVALID;
                    }
                    return parentValid;
                }

                // Validity unknown for root means it is valid
                return VALID;
            }

            @Override
            public void addListener(InvalidationListener listener) {
                incListenerReasons();
                if (localToSceneListeners == null) {
                    localToSceneListeners = new LinkedList&lt;Object&gt;();
                }
                localToSceneListeners.add(listener);
                super.addListener(listener);
            }

            @Override
            public void addListener(ChangeListener&lt;? super Transform&gt; listener) {
                incListenerReasons();
                if (localToSceneListeners == null) {
                    localToSceneListeners = new LinkedList&lt;Object&gt;();
                }
                localToSceneListeners.add(listener);
                super.addListener(listener);
            }

            @Override
            public void removeListener(InvalidationListener listener) {
                if (localToSceneListeners != null &amp;&amp;
                        localToSceneListeners.remove(listener)) {
                    decListenerReasons();
                }
                super.removeListener(listener);
            }

            @Override
            public void removeListener(ChangeListener&lt;? super Transform&gt; listener) {
                if (localToSceneListeners != null &amp;&amp;
                        localToSceneListeners.remove(listener)) {
                    decListenerReasons();
                }
                super.removeListener(listener);
            }
        }

        public final ReadOnlyObjectProperty&lt;Transform&gt; localToSceneTransformProperty() {
            if (localToSceneTransform == null) {
                localToSceneTransform = new LocalToSceneTransformProperty();
            }

            return localToSceneTransform;
        }

        public void invalidateLocalToSceneTransform() {
            if (localToSceneTransform != null) {
                localToSceneTransform.invalidate();
            }
        }

        public double getTranslateX() {
            return (translateX == null) ? DEFAULT_TRANSLATE_X
                                        : translateX.get();
        }

        public final DoubleProperty translateXProperty() {
            if (translateX == null) {
                translateX = new StyleableDoubleProperty(DEFAULT_TRANSLATE_X) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.TRANSLATE_X;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;translateX&quot;;
                    }
                };
            }
            return translateX;
        }

        public double getTranslateY() {
            return (translateY == null) ? DEFAULT_TRANSLATE_Y : translateY.get();
        }

        public final DoubleProperty translateYProperty() {
            if (translateY == null) {
                translateY = new StyleableDoubleProperty(DEFAULT_TRANSLATE_Y) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.TRANSLATE_Y;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;translateY&quot;;
                    }
                };
            }
            return translateY;
        }

        public double getTranslateZ() {
            return (translateZ == null) ? DEFAULT_TRANSLATE_Z : translateZ.get();
        }

        public final DoubleProperty translateZProperty() {
            if (translateZ == null) {
                translateZ = new StyleableDoubleProperty(DEFAULT_TRANSLATE_Z) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.TRANSLATE_Z;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;translateZ&quot;;
                    }
                };
            }
            return translateZ;
        }

        public double getScaleX() {
            return (scaleX == null) ? DEFAULT_SCALE_X : scaleX.get();
        }

        public final DoubleProperty scaleXProperty() {
            if (scaleX == null) {
                scaleX = new StyleableDoubleProperty(DEFAULT_SCALE_X) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.SCALE_X;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;scaleX&quot;;
                    }
                };
            }
            return scaleX;
        }

        public double getScaleY() {
            return (scaleY == null) ? DEFAULT_SCALE_Y : scaleY.get();
        }

        public final DoubleProperty scaleYProperty() {
            if (scaleY == null) {
                scaleY = new StyleableDoubleProperty(DEFAULT_SCALE_Y) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.SCALE_Y;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;scaleY&quot;;
                    }
                };
            }
            return scaleY;
        }

        public double getScaleZ() {
            return (scaleZ == null) ? DEFAULT_SCALE_Z : scaleZ.get();
        }

        public final DoubleProperty scaleZProperty() {
            if (scaleZ == null) {
                scaleZ = new StyleableDoubleProperty(DEFAULT_SCALE_Z) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.SCALE_Z;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;scaleZ&quot;;
                    }
                };
            }
            return scaleZ;
        }

        public double getRotate() {
            return (rotate == null) ? DEFAULT_ROTATE : rotate.get();
        }

        public final DoubleProperty rotateProperty() {
            if (rotate == null) {
                rotate = new StyleableDoubleProperty(DEFAULT_ROTATE) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.ROTATE;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;rotate&quot;;
                    }
                };
            }
            return rotate;
        }

        public Point3D getRotationAxis() {
            return (rotationAxis == null) ? DEFAULT_ROTATION_AXIS
                                          : rotationAxis.get();
        }

        public final ObjectProperty&lt;Point3D&gt; rotationAxisProperty() {
            if (rotationAxis == null) {
                rotationAxis = new ObjectPropertyBase&lt;Point3D&gt;(
                                           DEFAULT_ROTATION_AXIS) {
                    @Override
                    protected void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;rotationAxis&quot;;
                    }
                };
            }
            return rotationAxis;
        }

        public ObservableList&lt;Transform&gt; getTransforms() {
            if (transforms == null) {
                transforms = new TrackableObservableList&lt;Transform&gt;() {
                    @Override
                    protected void onChanged(Change&lt;Transform&gt; c) {
                        while (c.next()) {
                            for (Transform t : c.getRemoved()) {
                                TransformHelper.remove(t, Node.this);
                            }
                            for (Transform t : c.getAddedSubList()) {
                                TransformHelper.add(t, Node.this);
                            }
                        }

                        NodeHelper.transformsChanged(Node.this);
                    }
                };
            }

            return transforms;
        }

        public boolean canSetTranslateX() {
            return (translateX == null) || !translateX.isBound();
        }

        public boolean canSetTranslateY() {
            return (translateY == null) || !translateY.isBound();
        }

        public boolean canSetTranslateZ() {
            return (translateZ == null) || !translateZ.isBound();
        }

        public boolean canSetScaleX() {
            return (scaleX == null) || !scaleX.isBound();
        }

        public boolean canSetScaleY() {
            return (scaleY == null) || !scaleY.isBound();
        }

        public boolean canSetScaleZ() {
            return (scaleZ == null) || !scaleZ.isBound();
        }

        public boolean canSetRotate() {
            return (rotate == null) || !rotate.isBound();
        }

        public boolean hasTransforms() {
            return (transforms != null &amp;&amp; !transforms.isEmpty());
        }

        public boolean hasScaleOrRotate() {
            if (scaleX != null &amp;&amp; scaleX.get() != DEFAULT_SCALE_X) {
                return true;
            }
            if (scaleY != null &amp;&amp; scaleY.get() != DEFAULT_SCALE_Y) {
                return true;
            }
            if (scaleZ != null &amp;&amp; scaleZ.get() != DEFAULT_SCALE_Z) {
                return true;
            }
            if (rotate != null &amp;&amp; rotate.get() != DEFAULT_ROTATE) {
                return true;
            }
            return false;
        }

    }

    ////////////////////////////
    //  Private Implementation
    ////////////////////////////

    /***************************************************************************
     *                                                                         *
     *                        Event Handler Properties                         *
     *                                                                         *
     **************************************************************************/

    private EventHandlerProperties eventHandlerProperties;

    private EventHandlerProperties getEventHandlerProperties() {
        if (eventHandlerProperties == null) {
            eventHandlerProperties =
                    new EventHandlerProperties(
                        getInternalEventDispatcher().getEventHandlerManager(),
                        this);
        }

        return eventHandlerProperties;
    }

    /***************************************************************************
     *                                                                         *
     *                       Component Orientation Properties                  *
     *                                                                         *
     **************************************************************************/

    private ObjectProperty&lt;NodeOrientation&gt; nodeOrientation;
    private EffectiveOrientationProperty effectiveNodeOrientationProperty;

    private static final byte EFFECTIVE_ORIENTATION_LTR = 0;
    private static final byte EFFECTIVE_ORIENTATION_RTL = 1;
    private static final byte EFFECTIVE_ORIENTATION_MASK = 1;
    private static final byte AUTOMATIC_ORIENTATION_LTR = 0;
    private static final byte AUTOMATIC_ORIENTATION_RTL = 2;
    private static final byte AUTOMATIC_ORIENTATION_MASK = 2;

    private byte resolvedNodeOrientation =
            EFFECTIVE_ORIENTATION_LTR | AUTOMATIC_ORIENTATION_LTR;

    public final void setNodeOrientation(NodeOrientation orientation) {
        nodeOrientationProperty().set(orientation);
    }

    public final NodeOrientation getNodeOrientation() {
        return nodeOrientation == null ? NodeOrientation.INHERIT : nodeOrientation.get();
    }
    /**
     * Property holding NodeOrientation.
     * &lt;p&gt;
     * Node orientation describes the flow of visual data within a node.
     * In the English speaking world, visual data normally flows from
     * left-to-right. In an Arabic or Hebrew world, visual data flows
     * from right-to-left.  This is consistent with the reading order
     * of text in both worlds.  The default value is left-to-right.
     * &lt;/p&gt;
     *
     * @return NodeOrientation
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;NodeOrientation&gt; nodeOrientationProperty() {
        if (nodeOrientation == null) {
            nodeOrientation = new StyleableObjectProperty&lt;NodeOrientation&gt;(NodeOrientation.INHERIT) {
                @Override
                protected void invalidated() {
                    nodeResolvedOrientationInvalidated();
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;nodeOrientation&quot;;
                }

                @Override
                public CssMetaData getCssMetaData() {
                    //TODO - not supported
                    throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
                }

            };
        }
        return nodeOrientation;
    }

    public final NodeOrientation getEffectiveNodeOrientation() {
        return (getEffectiveOrientation(resolvedNodeOrientation)
                    == EFFECTIVE_ORIENTATION_LTR)
                       ? NodeOrientation.LEFT_TO_RIGHT
                       : NodeOrientation.RIGHT_TO_LEFT;
    }

    /**
     * The effective orientation of a node resolves the inheritance of
     * node orientation, returning either left-to-right or right-to-left.
     * @return the node orientation for this {@code Node}
     * @since JavaFX 8.0
     */
    public final ReadOnlyObjectProperty&lt;NodeOrientation&gt;
            effectiveNodeOrientationProperty() {
        if (effectiveNodeOrientationProperty == null) {
            effectiveNodeOrientationProperty =
                    new EffectiveOrientationProperty();
        }

        return effectiveNodeOrientationProperty;
    }

    /**
     * Determines whether a node should be mirrored when node orientation
     * is right-to-left.
     * &lt;p&gt;
     * When a node is mirrored, the origin is automatically moved to the
     * top right corner causing the node to layout children and draw from
     * right to left using a mirroring transformation.  Some nodes may wish
     * to draw from right to left without using a transformation.  These
     * nodes will will answer {@code false} and implement right-to-left
     * orientation without using the automatic transformation.
     * &lt;/p&gt;
     * @return true if this {@code Node} should be mirrored
     * @since JavaFX 8.0
     */
    public boolean usesMirroring() {
        return true;
    }

    final void parentResolvedOrientationInvalidated() {
        if (getNodeOrientation() == NodeOrientation.INHERIT) {
            nodeResolvedOrientationInvalidated();
        } else {
            // mirroring changed
            NodeHelper.transformsChanged(this);
        }
    }

    final void nodeResolvedOrientationInvalidated() {
        final byte oldResolvedNodeOrientation =
                resolvedNodeOrientation;

        resolvedNodeOrientation =
                (byte) (calcEffectiveNodeOrientation()
                            | calcAutomaticNodeOrientation());

        if ((effectiveNodeOrientationProperty != null)
                &amp;&amp; (getEffectiveOrientation(resolvedNodeOrientation)
                        != getEffectiveOrientation(
                               oldResolvedNodeOrientation))) {
            effectiveNodeOrientationProperty.invalidate();
        }

        // mirroring changed
        NodeHelper.transformsChanged(this);

        if (resolvedNodeOrientation != oldResolvedNodeOrientation) {
            nodeResolvedOrientationChanged();
        }
    }

    void nodeResolvedOrientationChanged() {
        // overriden in Parent
    }

    private Node getMirroringOrientationParent() {
        Node parentValue = getParent();
        while (parentValue != null) {
            if (parentValue.usesMirroring()) {
                return parentValue;
            }
            parentValue = parentValue.getParent();
        }

        final Node subSceneValue = getSubScene();
        if (subSceneValue != null) {
            return subSceneValue;
        }

        return null;
    }

    private Node getOrientationParent() {
        final Node parentValue = getParent();
        if (parentValue != null) {
            return parentValue;
        }

        final Node subSceneValue = getSubScene();
        if (subSceneValue != null) {
            return subSceneValue;
        }

        return null;
    }

    private byte calcEffectiveNodeOrientation() {
        final NodeOrientation nodeOrientationValue = getNodeOrientation();
        if (nodeOrientationValue != NodeOrientation.INHERIT) {
            return (nodeOrientationValue == NodeOrientation.LEFT_TO_RIGHT)
                       ? EFFECTIVE_ORIENTATION_LTR
                       : EFFECTIVE_ORIENTATION_RTL;
        }

        final Node parentValue = getOrientationParent();
        if (parentValue != null) {
            return getEffectiveOrientation(parentValue.resolvedNodeOrientation);
        }

        final Scene sceneValue = getScene();
        if (sceneValue != null) {
            return (sceneValue.getEffectiveNodeOrientation()
                        == NodeOrientation.LEFT_TO_RIGHT)
                           ? EFFECTIVE_ORIENTATION_LTR
                           : EFFECTIVE_ORIENTATION_RTL;
        }

        return EFFECTIVE_ORIENTATION_LTR;
    }

    private byte calcAutomaticNodeOrientation() {
        if (!usesMirroring()) {
            return AUTOMATIC_ORIENTATION_LTR;
        }

        final NodeOrientation nodeOrientationValue = getNodeOrientation();
        if (nodeOrientationValue != NodeOrientation.INHERIT) {
            return (nodeOrientationValue == NodeOrientation.LEFT_TO_RIGHT)
                       ? AUTOMATIC_ORIENTATION_LTR
                       : AUTOMATIC_ORIENTATION_RTL;
        }

        final Node parentValue = getMirroringOrientationParent();
        if (parentValue != null) {
            // automatic node orientation is inherited
            return getAutomaticOrientation(parentValue.resolvedNodeOrientation);
        }

        final Scene sceneValue = getScene();
        if (sceneValue != null) {
            return (sceneValue.getEffectiveNodeOrientation()
                        == NodeOrientation.LEFT_TO_RIGHT)
                           ? AUTOMATIC_ORIENTATION_LTR
                           : AUTOMATIC_ORIENTATION_RTL;
        }

        return AUTOMATIC_ORIENTATION_LTR;
    }

    // Return true if the node needs to be mirrored.
    // A node has mirroring if the orientation differs from the parent
    // package private for testing
    final boolean hasMirroring() {
        final Node parentValue = getOrientationParent();

        final byte thisOrientation =
                getAutomaticOrientation(resolvedNodeOrientation);
        final byte parentOrientation =
                (parentValue != null)
                    ? getAutomaticOrientation(
                          parentValue.resolvedNodeOrientation)
                    : AUTOMATIC_ORIENTATION_LTR;

        return thisOrientation != parentOrientation;
    }

    private static byte getEffectiveOrientation(
            final byte resolvedNodeOrientation) {
        return (byte) (resolvedNodeOrientation &amp; EFFECTIVE_ORIENTATION_MASK);
    }

    private static byte getAutomaticOrientation(
            final byte resolvedNodeOrientation) {
        return (byte) (resolvedNodeOrientation &amp; AUTOMATIC_ORIENTATION_MASK);
    }

    private final class EffectiveOrientationProperty
            extends ReadOnlyObjectPropertyBase&lt;NodeOrientation&gt; {
        @Override
        public NodeOrientation get() {
            return getEffectiveNodeOrientation();
        }

        @Override
        public Object getBean() {
            return Node.this;
        }

        @Override
        public String getName() {
            return &quot;effectiveNodeOrientation&quot;;
        }

        public void invalidate() {
            fireValueChangedEvent();
        }
    }

    /***************************************************************************
     *                                                                         *
     *                       Misc Seldom Used Properties                       *
     *                                                                         *
     **************************************************************************/

    private MiscProperties miscProperties;

    private MiscProperties getMiscProperties() {
        if (miscProperties == null) {
            miscProperties = new MiscProperties();
        }

        return miscProperties;
    }

    private static final double DEFAULT_VIEW_ORDER = 0;
    private static final boolean DEFAULT_CACHE = false;
    private static final CacheHint DEFAULT_CACHE_HINT = CacheHint.DEFAULT;
    private static final Node DEFAULT_CLIP = null;
    private static final Cursor DEFAULT_CURSOR = null;
    private static final DepthTest DEFAULT_DEPTH_TEST = DepthTest.INHERIT;
    private static final boolean DEFAULT_DISABLE = false;
    private static final Effect DEFAULT_EFFECT = null;
    private static final InputMethodRequests DEFAULT_INPUT_METHOD_REQUESTS =
            null;
    private static final boolean DEFAULT_MOUSE_TRANSPARENT = false;

    private final class MiscProperties {
        private LazyBoundsProperty boundsInParent;
        private LazyBoundsProperty boundsInLocal;
        private BooleanProperty cache;
        private ObjectProperty&lt;CacheHint&gt; cacheHint;
        private ObjectProperty&lt;Node&gt; clip;
        private ObjectProperty&lt;Cursor&gt; cursor;
        private ObjectProperty&lt;DepthTest&gt; depthTest;
        private BooleanProperty disable;
        private ObjectProperty&lt;Effect&gt; effect;
        private ObjectProperty&lt;InputMethodRequests&gt; inputMethodRequests;
        private BooleanProperty mouseTransparent;
        private DoubleProperty viewOrder;

        public double getViewOrder() {
            return (viewOrder == null) ? DEFAULT_VIEW_ORDER : viewOrder.get();
        }

        public final DoubleProperty viewOrderProperty() {
            if (viewOrder == null) {
                viewOrder = new StyleableDoubleProperty(DEFAULT_VIEW_ORDER) {
                    @Override
                    public void invalidated() {
                        Parent p = getParent();
                        if (p != null) {
                            // Parent will be responsible to update sorted children list
                            p.markViewOrderChildrenDirty();
                        }
                        NodeHelper.markDirty(Node.this, DirtyBits.NODE_VIEW_ORDER);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.VIEW_ORDER;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;viewOrder&quot;;
                    }
                };
            }
            return viewOrder;
        }

        public final Bounds getBoundsInParent() {
            return boundsInParentProperty().get();
        }

        public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInParentProperty() {
            if (boundsInParent == null) {
                boundsInParent = new LazyBoundsProperty() {
                    /**
                     * Computes the bounds including the clip, effects, and all
                     * transforms. This function is essentially how to compute
                     * the boundsInParent. Optimizations are made to compute as
                     * little as possible and create as little trash as
                     * possible.
                     */
                    @Override
                    protected Bounds computeBounds() {
                        BaseBounds tempBounds = TempState.getInstance().bounds;
                        tempBounds = getTransformedBounds(
                                             tempBounds,
                                             BaseTransform.IDENTITY_TRANSFORM);
                        return new BoundingBox(tempBounds.getMinX(),
                                               tempBounds.getMinY(),
                                               tempBounds.getMinZ(),
                                               tempBounds.getWidth(),
                                               tempBounds.getHeight(),
                                               tempBounds.getDepth());
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;boundsInParent&quot;;
                    }
                };
            }

            return boundsInParent;
        }

        public void invalidateBoundsInParent() {
            if (boundsInParent != null) {
                boundsInParent.invalidate();
            }
        }

        public final Bounds getBoundsInLocal() {
            return boundsInLocalProperty().get();
        }

        public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInLocalProperty() {
            if (boundsInLocal == null) {
                boundsInLocal = new LazyBoundsProperty() {
                    @Override
                    protected Bounds computeBounds() {
                        BaseBounds tempBounds = TempState.getInstance().bounds;
                        tempBounds = getLocalBounds(
                                             tempBounds,
                                             BaseTransform.IDENTITY_TRANSFORM);
                        return new BoundingBox(tempBounds.getMinX(),
                                               tempBounds.getMinY(),
                                               tempBounds.getMinZ(),
                                               tempBounds.getWidth(),
                                               tempBounds.getHeight(),
                                               tempBounds.getDepth());
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;boundsInLocal&quot;;
                    }
                };
            }

            return boundsInLocal;
        }

        public void invalidateBoundsInLocal() {
            if (boundsInLocal != null) {
                boundsInLocal.invalidate();
            }
        }

        public final boolean isCache() {
            return (cache == null) ? DEFAULT_CACHE
                                   : cache.get();
        }

        public final BooleanProperty cacheProperty() {
            if (cache == null) {
                cache = new BooleanPropertyBase(DEFAULT_CACHE) {
                    @Override
                    protected void invalidated() {
                        NodeHelper.markDirty(Node.this, DirtyBits.NODE_CACHE);
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;cache&quot;;
                    }
                };
            }
            return cache;
        }

        public final CacheHint getCacheHint() {
            return (cacheHint == null) ? DEFAULT_CACHE_HINT
                                       : cacheHint.get();
        }

        public final ObjectProperty&lt;CacheHint&gt; cacheHintProperty() {
            if (cacheHint == null) {
                cacheHint = new ObjectPropertyBase&lt;CacheHint&gt;(DEFAULT_CACHE_HINT) {
                    @Override
                    protected void invalidated() {
                        NodeHelper.markDirty(Node.this, DirtyBits.NODE_CACHE);
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;cacheHint&quot;;
                    }
                };
            }
            return cacheHint;
        }

        public final Node getClip() {
            return (clip == null) ? DEFAULT_CLIP : clip.get();
        }

        public final ObjectProperty&lt;Node&gt; clipProperty() {
            if (clip == null) {
                clip = new ObjectPropertyBase&lt;Node&gt;(DEFAULT_CLIP) {

                    //temp variables used when clip was invalid to rollback to
                    // last value
                    private Node oldClip;

                    @Override
                    protected void invalidated() {
                        final Node newClip = get();
                        if ((newClip != null)
                                &amp;&amp; ((newClip.isConnected()
                                           &amp;&amp; newClip.clipParent != Node.this)
                                       || wouldCreateCycle(Node.this,
                                                           newClip))) {
                            // Assigning this node to clip is illegal.
                            // Roll back to the previous state and throw an
                            // exception.
                            final String cause =
                                    newClip.isConnected()
                                        &amp;&amp; (newClip.clipParent != Node.this)
                                            ? &quot;node already connected&quot;
                                            : &quot;cycle detected&quot;;

                            if (isBound()) {
                                unbind();
                                set(oldClip);
                                throw new IllegalArgumentException(
                                        &quot;Node's clip set to incorrect value &quot;
                                            + &quot; through binding&quot;
                                            + &quot; (&quot; + cause + &quot;, node  = &quot;
                                                   + Node.this + &quot;, clip = &quot;
                                                   + clip + &quot;).&quot;
                                            + &quot; Binding has been removed.&quot;);
                            } else {
                                set(oldClip);
                                throw new IllegalArgumentException(
                                        &quot;Node's clip set to incorrect value&quot;
                                            + &quot; (&quot; + cause + &quot;, node  = &quot;
                                                   + Node.this + &quot;, clip = &quot;
                                                   + clip + &quot;).&quot;);
                            }
                        } else {
                            if (oldClip != null) {
                                oldClip.clipParent = null;
                                oldClip.setScenes(null, null);
                                oldClip.updateTreeVisible(false);
                            }

                            if (newClip != null) {
                                newClip.clipParent = Node.this;
                                newClip.setScenes(getScene(), getSubScene());
                                newClip.updateTreeVisible(true);
                            }

                            NodeHelper.markDirty(Node.this, DirtyBits.NODE_CLIP);

                            // the local bounds have (probably) changed
                            localBoundsChanged();

                            oldClip = newClip;
                        }
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;clip&quot;;
                    }
                };
            }
            return clip;
        }

        public final Cursor getCursor() {
            return (cursor == null) ? DEFAULT_CURSOR : cursor.get();
        }

        public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
            if (cursor == null) {
                cursor = new StyleableObjectProperty&lt;Cursor&gt;(DEFAULT_CURSOR) {

                    @Override
                    protected void invalidated() {
                        final Scene sceneValue = getScene();
                        if (sceneValue != null) {
                            sceneValue.markCursorDirty();
                        }
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.CURSOR;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;cursor&quot;;
                    }

                };
            }
            return cursor;
        }

        public final DepthTest getDepthTest() {
            return (depthTest == null) ? DEFAULT_DEPTH_TEST
                                       : depthTest.get();
        }

        public final ObjectProperty&lt;DepthTest&gt; depthTestProperty() {
            if (depthTest == null) {
                depthTest = new ObjectPropertyBase&lt;DepthTest&gt;(DEFAULT_DEPTH_TEST) {
                    @Override protected void invalidated() {
                        computeDerivedDepthTest();
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;depthTest&quot;;
                    }
                };
            }
            return depthTest;
        }

        public final boolean isDisable() {
            return (disable == null) ? DEFAULT_DISABLE : disable.get();
        }

        public final BooleanProperty disableProperty() {
            if (disable == null) {
                disable = new BooleanPropertyBase(DEFAULT_DISABLE) {
                    @Override
                    protected void invalidated() {
                        updateDisabled();
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;disable&quot;;
                    }
                };
            }
            return disable;
        }

        public final Effect getEffect() {
            return (effect == null) ? DEFAULT_EFFECT : effect.get();
        }

        public final ObjectProperty&lt;Effect&gt; effectProperty() {
            if (effect == null) {
                effect = new StyleableObjectProperty&lt;Effect&gt;(DEFAULT_EFFECT) {
                    private Effect oldEffect = null;
                    private int oldBits;

                    private final AbstractNotifyListener effectChangeListener =
                            new AbstractNotifyListener() {

                        @Override
                        public void invalidated(Observable valueModel) {
                            int newBits = ((IntegerProperty) valueModel).get();
                            int changedBits = newBits ^ oldBits;
                            oldBits = newBits;
                            if (EffectDirtyBits.isSet(
                                    changedBits,
                                    EffectDirtyBits.EFFECT_DIRTY)
                                &amp;&amp; EffectDirtyBits.isSet(
                                       newBits,
                                       EffectDirtyBits.EFFECT_DIRTY)) {
                                NodeHelper.markDirty(Node.this, DirtyBits.EFFECT_EFFECT);
                            }
                            if (EffectDirtyBits.isSet(
                                    changedBits,
                                    EffectDirtyBits.BOUNDS_CHANGED)) {
                                localBoundsChanged();
                            }
                        }
                    };

                    @Override
                    protected void invalidated() {
                        Effect _effect = get();
                        if (oldEffect != null) {
                            EffectHelper.effectDirtyProperty(oldEffect).removeListener(
                                    effectChangeListener.getWeakListener());
                        }
                        oldEffect = _effect;
                        if (_effect != null) {
                            EffectHelper.effectDirtyProperty(_effect)
                                   .addListener(
                                       effectChangeListener.getWeakListener());
                            if (EffectHelper.isEffectDirty(_effect)) {
                                NodeHelper.markDirty(Node.this, DirtyBits.EFFECT_EFFECT);
                            }
                            oldBits = EffectHelper.effectDirtyProperty(_effect).get();
                        }

                        NodeHelper.markDirty(Node.this, DirtyBits.NODE_EFFECT);
                        // bounds may have changed regardless whether
                        // the dirty flag on effect is set
                        localBoundsChanged();
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.EFFECT;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;effect&quot;;
                    }
                };
            }
            return effect;
        }

        public final InputMethodRequests getInputMethodRequests() {
            return (inputMethodRequests == null) ? DEFAULT_INPUT_METHOD_REQUESTS
                                                 : inputMethodRequests.get();
        }

        public ObjectProperty&lt;InputMethodRequests&gt;
                inputMethodRequestsProperty() {
            if (inputMethodRequests == null) {
                inputMethodRequests =
                        new SimpleObjectProperty&lt;InputMethodRequests&gt;(
                                Node.this,
                                &quot;inputMethodRequests&quot;,
                                DEFAULT_INPUT_METHOD_REQUESTS);
            }
            return inputMethodRequests;
        }

        public final boolean isMouseTransparent() {
            return (mouseTransparent == null) ? DEFAULT_MOUSE_TRANSPARENT
                                              : mouseTransparent.get();
        }

        public final BooleanProperty mouseTransparentProperty() {
            if (mouseTransparent == null) {
                mouseTransparent =
                        new SimpleBooleanProperty(
                                Node.this,
                                &quot;mouseTransparent&quot;,
                                DEFAULT_MOUSE_TRANSPARENT);
            }
            return mouseTransparent;
        }

        public boolean canSetCursor() {
            return (cursor == null) || !cursor.isBound();
        }

        public boolean canSetEffect() {
            return (effect == null) || !effect.isBound();
        }
    }

    /* *************************************************************************
     *                                                                         *
     *                             Mouse Handling                              *
     *                                                                         *
     **************************************************************************/

    public final void setMouseTransparent(boolean value) {
        mouseTransparentProperty().set(value);
    }

    public final boolean isMouseTransparent() {
        return (miscProperties == null) ? DEFAULT_MOUSE_TRANSPARENT
                                        : miscProperties.isMouseTransparent();
    }

    /**
     * If {@code true}, this node (together with all its children) is completely
     * transparent to mouse events. When choosing target for mouse event, nodes
     * with {@code mouseTransparent} set to {@code true} and their subtrees
     * won't be taken into account.
     * @return is this {@code Node} (together with all its children) is completely
     * transparent to mouse events.
     */
    public final BooleanProperty mouseTransparentProperty() {
        return getMiscProperties().mouseTransparentProperty();
    }

    /**
     * Whether or not this {@code Node} is being hovered over. Typically this is
     * due to the mouse being over the node, though it could be due to a pen
     * hovering on a graphics tablet or other form of input.
     *
     * &lt;p&gt;Note that current implementation of hover relies on mouse enter and
     * exit events to determine whether this Node is in the hover state; this
     * means that this feature is currently supported only on systems that
     * have a mouse. Future implementations may provide alternative means of
     * supporting hover.
     *
     * @defaultValue false
     */
    private ReadOnlyBooleanWrapper hover;

    protected final void setHover(boolean value) {
        hoverPropertyImpl().set(value);
    }

    public final boolean isHover() {
        return hover == null ? false : hover.get();
    }

    public final ReadOnlyBooleanProperty hoverProperty() {
        return hoverPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyBooleanWrapper hoverPropertyImpl() {
        if (hover == null) {
            hover = new ReadOnlyBooleanWrapper() {

                @Override
                protected void invalidated() {
                    PlatformLogger logger = Logging.getInputLogger();
                    if (logger.isLoggable(Level.FINER)) {
                        logger.finer(this + &quot; hover=&quot; + get());
                    }
                    pseudoClassStateChanged(HOVER_PSEUDOCLASS_STATE, get());
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;hover&quot;;
                }
            };
        }
        return hover;
    }

    /**
     * Whether or not the {@code Node} is pressed. Typically this is true when
     * the primary mouse button is down, though subclasses may define other
     * mouse button state or key state to cause the node to be &quot;pressed&quot;.
     *
     * @defaultValue false
     */
    private ReadOnlyBooleanWrapper pressed;

    protected final void setPressed(boolean value) {
        pressedPropertyImpl().set(value);
    }

    public final boolean isPressed() {
        return pressed == null ? false : pressed.get();
    }

    public final ReadOnlyBooleanProperty pressedProperty() {
        return pressedPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyBooleanWrapper pressedPropertyImpl() {
        if (pressed == null) {
            pressed = new ReadOnlyBooleanWrapper() {

                @Override
                protected void invalidated() {
                    PlatformLogger logger = Logging.getInputLogger();
                    if (logger.isLoggable(Level.FINER)) {
                        logger.finer(this + &quot; pressed=&quot; + get());
                    }
                    pseudoClassStateChanged(PRESSED_PSEUDOCLASS_STATE, get());
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;pressed&quot;;
                }
            };
        }
        return pressed;
    }

    public final void setOnContextMenuRequested(
            EventHandler&lt;? super ContextMenuEvent&gt; value) {
        onContextMenuRequestedProperty().set(value);
    }

    public final EventHandler&lt;? super ContextMenuEvent&gt; getOnContextMenuRequested() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.onContextMenuRequested();
    }

    /**
     * Defines a function to be called when a context menu
     * has been requested on this {@code Node}.
     * @return the event handler that is called when a context menu has been
     * requested on this {@code Node}
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt;
            onContextMenuRequestedProperty() {
        return getEventHandlerProperties().onContextMenuRequestedProperty();
    }

    public final void setOnMouseClicked(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseClickedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseClicked() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseClicked();
    }

    /**
     * Defines a function to be called when a mouse button has been clicked
     * (pressed and released) on this {@code Node}.
     * @return the event handler that is called when a mouse button has been
     * clicked (pressed and released) on this {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseClickedProperty() {
        return getEventHandlerProperties().onMouseClickedProperty();
    }

    public final void setOnMouseDragged(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseDraggedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseDragged() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseDragged();
    }

    /**
     * Defines a function to be called when a mouse button is pressed
     * on this {@code Node} and then dragged.
     * @return the event handler that is called when a mouse button is pressed
     * on this {@code Node} and then dragged
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseDraggedProperty() {
        return getEventHandlerProperties().onMouseDraggedProperty();
    }

    public final void setOnMouseEntered(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseEntered() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseEntered();
    }

    /**
     * Defines a function to be called when the mouse enters this {@code Node}.
     * @return the event handler that is called when a mouse enters this
     * {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseEnteredProperty() {
        return getEventHandlerProperties().onMouseEnteredProperty();
    }

    public final void setOnMouseExited(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseExitedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseExited() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseExited();
    }

    /**
     * Defines a function to be called when the mouse exits this {@code Node}.
     * @return the event handler that is called when a mouse exits this
     * {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseExitedProperty() {
        return getEventHandlerProperties().onMouseExitedProperty();
    }

    public final void setOnMouseMoved(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseMovedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseMoved() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseMoved();
    }

    /**
     * Defines a function to be called when mouse cursor moves within
     * this {@code Node} but no buttons have been pushed.
     * @return the event handler that is called when a mouse cursor moves
     * within this {@code Node} but no buttons have been pushed
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseMovedProperty() {
        return getEventHandlerProperties().onMouseMovedProperty();
    }

    public final void setOnMousePressed(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMousePressedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMousePressed() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMousePressed();
    }

    /**
     * Defines a function to be called when a mouse button
     * has been pressed on this {@code Node}.
     * @return the event handler that is called when a mouse button has been
     * pressed on this {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMousePressedProperty() {
        return getEventHandlerProperties().onMousePressedProperty();
    }

    public final void setOnMouseReleased(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseReleased() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseReleased();
    }

    /**
     * Defines a function to be called when a mouse button
     * has been released on this {@code Node}.
     * @return the event handler that is called when a mouse button has been
     * released on this {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseReleasedProperty() {
        return getEventHandlerProperties().onMouseReleasedProperty();
    }

    public final void setOnDragDetected(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onDragDetectedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnDragDetected() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragDetected();
    }

    /**
     * Defines a function to be called when drag gesture has been
     * detected. This is the right place to start drag and drop operation.
     * @return the event handler that is called when drag gesture has been
     * detected
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onDragDetectedProperty() {
        return getEventHandlerProperties().onDragDetectedProperty();
    }

    public final void setOnMouseDragOver(
            EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragOverProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragOver() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseDragOver();
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * progresses within this {@code Node}.
     * @return the event handler that is called when a full press-drag-release
     * gesture progresses within this {@code Node}
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
            onMouseDragOverProperty() {
        return getEventHandlerProperties().onMouseDragOverProperty();
    }

    public final void setOnMouseDragReleased(
            EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragReleased() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseDragReleased();
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * ends (by releasing mouse button) within this {@code Node}.
     * @return the event handler that is called when a full press-drag-release
     * gesture ends (by releasing mouse button) within this {@code Node}
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
            onMouseDragReleasedProperty() {
        return getEventHandlerProperties().onMouseDragReleasedProperty();
    }

    public final void setOnMouseDragEntered(
            EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragEntered() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseDragEntered();
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * enters this {@code Node}.
     * @return the event handler that is called when a full press-drag-release
     * gesture enters this {@code Node}
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
            onMouseDragEnteredProperty() {
        return getEventHandlerProperties().onMouseDragEnteredProperty();
    }

    public final void setOnMouseDragExited(
            EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragExitedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragExited() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseDragExited();
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * leaves this {@code Node}.
     * @return the event handler that is called when a full press-drag-release
     * gesture leaves this {@code Node}
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
            onMouseDragExitedProperty() {
        return getEventHandlerProperties().onMouseDragExitedProperty();
    }


    /* *************************************************************************
     *                                                                         *
     *                           Gestures Handling                             *
     *                                                                         *
     **************************************************************************/

    public final void setOnScrollStarted(
            EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollStartedProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollStarted() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnScrollStarted();
    }

    /**
     * Defines a function to be called when a scrolling gesture is detected.
     * @return the event handler that is called when a scrolling gesture is
     * detected
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
            onScrollStartedProperty() {
        return getEventHandlerProperties().onScrollStartedProperty();
    }

    public final void setOnScroll(
            EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScroll() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnScroll();
    }

    /**
     * Defines a function to be called when user performs a scrolling action.
     * @return the event handler that is called when user performs a scrolling
     * action
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
            onScrollProperty() {
        return getEventHandlerProperties().onScrollProperty();
    }

    public final void setOnScrollFinished(
            EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollFinished() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnScrollFinished();
    }

    /**
     * Defines a function to be called when a scrolling gesture ends.
     * @return the event handler that is called when a scrolling gesture ends
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
            onScrollFinishedProperty() {
        return getEventHandlerProperties().onScrollFinishedProperty();
    }

    public final void setOnRotationStarted(
            EventHandler&lt;? super RotateEvent&gt; value) {
        onRotationStartedProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotationStarted() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnRotationStarted();
    }

    /**
     * Defines a function to be called when a rotation gesture is detected.
     * @return the event handler that is called when a rotation gesture is
     * detected
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
            onRotationStartedProperty() {
        return getEventHandlerProperties().onRotationStartedProperty();
    }

    public final void setOnRotate(
            EventHandler&lt;? super RotateEvent&gt; value) {
        onRotateProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotate() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnRotate();
    }

    /**
     * Defines a function to be called when user performs a rotation action.
     * @return the event handler that is called when user performs a rotation
     * action
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
            onRotateProperty() {
        return getEventHandlerProperties().onRotateProperty();
    }

    public final void setOnRotationFinished(
            EventHandler&lt;? super RotateEvent&gt; value) {
        onRotationFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotationFinished() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnRotationFinished();
    }

    /**
     * Defines a function to be called when a rotation gesture ends.
     * @return the event handler that is called when a rotation gesture ends
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
            onRotationFinishedProperty() {
        return getEventHandlerProperties().onRotationFinishedProperty();
    }

    public final void setOnZoomStarted(
            EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomStartedProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomStarted() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnZoomStarted();
    }

    /**
     * Defines a function to be called when a zooming gesture is detected.
     * @return the event handler that is called when a zooming gesture is
     * detected
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
            onZoomStartedProperty() {
        return getEventHandlerProperties().onZoomStartedProperty();
    }

    public final void setOnZoom(
            EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoom() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnZoom();
    }

    /**
     * Defines a function to be called when user performs a zooming action.
     * @return the event handler that is called when user performs a zooming
     * action
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
            onZoomProperty() {
        return getEventHandlerProperties().onZoomProperty();
    }

    public final void setOnZoomFinished(
            EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomFinished() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnZoomFinished();
    }

    /**
     * Defines a function to be called when a zooming gesture ends.
     * @return the event handler that is called when a zooming gesture ends
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
            onZoomFinishedProperty() {
        return getEventHandlerProperties().onZoomFinishedProperty();
    }

    public final void setOnSwipeUp(
            EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeUpProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeUp() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnSwipeUp();
    }

    /**
     * Defines a function to be called when an upward swipe gesture
     * centered over this node happens.
     * @return the event handler that is called when an upward swipe gesture
     * centered over this node happens
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
            onSwipeUpProperty() {
        return getEventHandlerProperties().onSwipeUpProperty();
    }

    public final void setOnSwipeDown(
            EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeDownProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeDown() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnSwipeDown();
    }

    /**
     * Defines a function to be called when a downward swipe gesture
     * centered over this node happens.
     * @return the event handler that is called when a downward swipe gesture
     * centered over this node happens
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
            onSwipeDownProperty() {
        return getEventHandlerProperties().onSwipeDownProperty();
    }

    public final void setOnSwipeLeft(
            EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeLeftProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeLeft() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnSwipeLeft();
    }

    /**
     * Defines a function to be called when a leftward swipe gesture
     * centered over this node happens.
     * @return the event handler that is called when a leftward swipe gesture
     * centered over this node happens
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
            onSwipeLeftProperty() {
        return getEventHandlerProperties().onSwipeLeftProperty();
    }

    public final void setOnSwipeRight(
            EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeRightProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeRight() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnSwipeRight();
    }

    /**
     * Defines a function to be called when an rightward swipe gesture
     * centered over this node happens.
     * @return the event handler that is called when an rightward swipe gesture
     * centered over this node happens
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
            onSwipeRightProperty() {
        return getEventHandlerProperties().onSwipeRightProperty();
    }


    /* *************************************************************************
     *                                                                         *
     *                             Touch Handling                              *
     *                                                                         *
     **************************************************************************/

    public final void setOnTouchPressed(
            EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchPressedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchPressed() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnTouchPressed();
    }

    /**
     * Defines a function to be called when a new touch point is pressed.
     * @return the event handler that is called when a new touch point is pressed
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
            onTouchPressedProperty() {
        return getEventHandlerProperties().onTouchPressedProperty();
    }

    public final void setOnTouchMoved(
            EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchMovedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchMoved() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnTouchMoved();
    }

    /**
     * Defines a function to be called when a touch point is moved.
     * @return the event handler that is called when a touch point is moved
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
            onTouchMovedProperty() {
        return getEventHandlerProperties().onTouchMovedProperty();
    }

    public final void setOnTouchReleased(
            EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchReleased() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnTouchReleased();
    }

    /**
     * Defines a function to be called when a touch point is released.
     * @return the event handler that is called when a touch point is released
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
            onTouchReleasedProperty() {
        return getEventHandlerProperties().onTouchReleasedProperty();
    }

    public final void setOnTouchStationary(
            EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchStationaryProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchStationary() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnTouchStationary();
    }

    /**
     * Defines a function to be called when a touch point stays pressed and
     * still.
     * @return the event handler that is called when a touch point stays pressed
     * and still
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
            onTouchStationaryProperty() {
        return getEventHandlerProperties().onTouchStationaryProperty();
    }

    /* *************************************************************************
     *                                                                         *
     *                           Keyboard Handling                             *
     *                                                                         *
     **************************************************************************/

    public final void setOnKeyPressed(
            EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyPressedProperty().set(value);
    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyPressed() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnKeyPressed();
    }

    /**
     * Defines a function to be called when this {@code Node} or its child
     * {@code Node} has input focus and a key has been pressed. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     * @return the event handler that is called when this {@code Node} or its
     * child {@code Node} has input focus and a key has been pressed
     */
    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
            onKeyPressedProperty() {
        return getEventHandlerProperties().onKeyPressedProperty();
    }

    public final void setOnKeyReleased(
            EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyReleased() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnKeyReleased();
    }

    /**
     * Defines a function to be called when this {@code Node} or its child
     * {@code Node} has input focus and a key has been released. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     * @return the event handler that is called when this {@code Node} or its
     * child {@code Node} has input focus and a key has been released
     */
    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
            onKeyReleasedProperty() {
        return getEventHandlerProperties().onKeyReleasedProperty();
    }

    public final void setOnKeyTyped(
            EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyTypedProperty().set(value);
    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyTyped() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnKeyTyped();
    }

    /**
     * Defines a function to be called when this {@code Node} or its child
     * {@code Node} has input focus and a key has been typed. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     * @return the event handler that is called when this {@code Node} or its
     * child {@code Node} has input focus and a key has been typed
     */
    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
            onKeyTypedProperty() {
        return getEventHandlerProperties().onKeyTypedProperty();
    }

    /* *************************************************************************
     *                                                                         *
     *                           Input Method Handling                         *
     *                                                                         *
     **************************************************************************/

    public final void setOnInputMethodTextChanged(
            EventHandler&lt;? super InputMethodEvent&gt; value) {
        onInputMethodTextChangedProperty().set(value);
    }

    public final EventHandler&lt;? super InputMethodEvent&gt;
            getOnInputMethodTextChanged() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnInputMethodTextChanged();
    }

    /**
     * Defines a function to be called when this {@code Node}
     * has input focus and the input method text has changed.  If this
     * function is not defined in this {@code Node}, then it
     * receives the result string of the input method composition as a
     * series of {@code onKeyTyped} function calls.
     * &lt;p&gt;
     * When the {@code Node} loses the input focus, the JavaFX runtime
     * automatically commits the existing composed text if any.
     * &lt;/p&gt;
     * @return the event handler that is called when this {@code Node} has input
     * focus and the input method text has changed
     */
    public final ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt;
            onInputMethodTextChangedProperty() {
        return getEventHandlerProperties().onInputMethodTextChangedProperty();
    }

    public final void setInputMethodRequests(InputMethodRequests value) {
        inputMethodRequestsProperty().set(value);
    }

    public final InputMethodRequests getInputMethodRequests() {
        return (miscProperties == null)
                       ? DEFAULT_INPUT_METHOD_REQUESTS
                       : miscProperties.getInputMethodRequests();
    }

    /**
     * Property holding InputMethodRequests.
     *
     * @return InputMethodRequestsProperty
     */
    public final ObjectProperty&lt;InputMethodRequests&gt; inputMethodRequestsProperty() {
        return getMiscProperties().inputMethodRequestsProperty();
    }

    /***************************************************************************
     *                                                                         *
     *                             Focus Traversal                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Special boolean property which allows for atomic focus change.
     * Focus change means defocusing the old focus owner and focusing a new
     * one. With a usual property, defocusing the old node fires the value
     * changed event and user code can react with something that breaks
     * focusability of the new node, or even remove the new node from the scene.
     * This leads to various error states. This property allows for setting
     * the state without firing the event. The focus change first sets both
     * properties and then fires both events. This makes the focus change look
     * like an atomic operation - when the old node is notified to loose focus,
     * the new node is already focused.
     */
    final class FocusedProperty extends ReadOnlyBooleanPropertyBase {
        private boolean value;
        private boolean valid = true;
        private boolean needsChangeEvent = false;

        public void store(final boolean value) {
            if (value != this.value) {
                this.value = value;
                markInvalid();
            }
        }

        public void notifyListeners() {
            if (needsChangeEvent) {
                fireValueChangedEvent();
                needsChangeEvent = false;
            }
        }

        private void markInvalid() {
            if (valid) {
                valid = false;

                pseudoClassStateChanged(FOCUSED_PSEUDOCLASS_STATE, get());
                PlatformLogger logger = Logging.getFocusLogger();
                if (logger.isLoggable(Level.FINE)) {
                    logger.fine(this + &quot; focused=&quot; + get());
                }

                needsChangeEvent = true;

                notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUSED);
            }
        }

        @Override
        public boolean get() {
            valid = true;
            return value;
        }

        @Override
        public Object getBean() {
            return Node.this;
        }

        @Override
        public String getName() {
            return &quot;focused&quot;;
        }
    }

    /**
     * Indicates whether this {@code Node} currently has the input focus.
     * To have the input focus, a node must be the {@code Scene}'s focus
     * owner, and the scene must be in a {@code Stage} that is visible
     * and active. See {@link #requestFocus()} for more information.
     *
     * @see #requestFocus()
     * @defaultValue false
     */
    private FocusedProperty focused;

    protected final void setFocused(boolean value) {
        FocusedProperty fp = focusedPropertyImpl();
        if (fp.value != value) {
            fp.store(value);
            fp.notifyListeners();
        }
    }

    public final boolean isFocused() {
        return focused == null ? false : focused.get();
    }

    public final ReadOnlyBooleanProperty focusedProperty() {
        return focusedPropertyImpl();
    }

    private FocusedProperty focusedPropertyImpl() {
        if (focused == null) {
            focused = new FocusedProperty();
        }
        return focused;
    }

    /**
     * Specifies whether this {@code Node} should be a part of focus traversal
     * cycle. When this property is {@code true} focus can be moved to this
     * {@code Node} and from this {@code Node} using regular focus traversal
     * keys. On a desktop such keys are usually {@code TAB} for moving focus
     * forward and {@code SHIFT+TAB} for moving focus backward.
     *
     * When a {@code Scene} is created, the system gives focus to a
     * {@code Node} whose {@code focusTraversable} variable is true
     * and that is eligible to receive the focus,
     * unless the focus had been set explicitly via a call
     * to {@link #requestFocus()}.
     *
     * @see #requestFocus()
     * @defaultValue false
     */
    private BooleanProperty focusTraversable;

    public final void setFocusTraversable(boolean value) {
        focusTraversableProperty().set(value);
    }
    public final boolean isFocusTraversable() {
        return focusTraversable == null ? false : focusTraversable.get();
    }

    public final BooleanProperty focusTraversableProperty() {
        if (focusTraversable == null) {
            focusTraversable = new StyleableBooleanProperty(false) {

                @Override
                public void invalidated() {
                    Scene _scene = getScene();
                    if (_scene != null) {
                        if (get()) {
                            _scene.initializeInternalEventDispatcher();
                        }
                        focusSetDirty(_scene);
                    }
                }

                @Override
                public CssMetaData getCssMetaData() {
                    return StyleableProperties.FOCUS_TRAVERSABLE;
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;focusTraversable&quot;;
                }
            };
        }
        return focusTraversable;
    }

    /**
     * Called when something has changed on this node that *may* have made the
     * scene's focus dirty. This covers the cases where this node is the focus
     * owner and it may have lost eligibility, or it's traversable and it may
     * have gained eligibility. Note that we do not want to use disabled
     * or treeVisible here, as this function is called from their
     * &quot;on invalidate&quot; triggers, and using them will cause them to be
     * revalidated. The pulse will revalidate everything and make the final
     * determination.
     */
    private void focusSetDirty(Scene s) {
        if (s != null &amp;&amp;
            (this == s.getFocusOwner() || isFocusTraversable())) {
                s.setFocusDirty(true);
        }
    }

    /**
     * Requests that this {@code Node} get the input focus, and that this
     * {@code Node}'s top-level ancestor become the focused window. To be
     * eligible to receive the focus, the node must be part of a scene, it and
     * all of its ancestors must be visible, and it must not be disabled.
     * If this node is eligible, this function will cause it to become this
     * {@code Scene}'s &quot;focus owner&quot;. Each scene has at most one focus owner
     * node. The focus owner will not actually have the input focus, however,
     * unless the scene belongs to a {@code Stage} that is both visible
     * and active.
     */
    public void requestFocus() {
        if (getScene() != null) {
            getScene().requestFocus(this);
        }
    }

    /**
     * Traverses from this node in the direction indicated. Note that this
     * node need not actually have the focus, nor need it be focusTraversable.
     * However, the node must be part of a scene, otherwise this request
     * is ignored.
     */
    final boolean traverse(Direction dir) {
        if (getScene() == null) {
            return false;
        }
        return getScene().traverse(this, dir);
    }

    ////////////////////////////
    //  Private Implementation
    ////////////////////////////

     /**
      * Returns a string representation for the object.
      * @return a string representation for the object.
      */
    @Override
    public String toString() {
        String klassName = getClass().getName();
        String simpleName = klassName.substring(klassName.lastIndexOf('.')+1);
        StringBuilder sbuf = new StringBuilder(simpleName);
        boolean hasId = id != null &amp;&amp; !&quot;&quot;.equals(getId());
        boolean hasStyleClass = !getStyleClass().isEmpty();

        if (!hasId) {
            sbuf.append('@');
            sbuf.append(Integer.toHexString(hashCode()));
        } else {
            sbuf.append(&quot;[id=&quot;);
            sbuf.append(getId());
            if (!hasStyleClass) sbuf.append(&quot;]&quot;);
        }
        if (hasStyleClass) {
            if (!hasId) sbuf.append('[');
            else sbuf.append(&quot;, &quot;);
            sbuf.append(&quot;styleClass=&quot;);
            sbuf.append(getStyleClass());
            sbuf.append(&quot;]&quot;);
        }
        return sbuf.toString();
    }

    private void preprocessMouseEvent(MouseEvent e) {
        final EventType&lt;?&gt; eventType = e.getEventType();
        if (eventType == MouseEvent.MOUSE_PRESSED) {
            for (Node n = this; n != null; n = n.getParent()) {
                n.setPressed(e.isPrimaryButtonDown());
            }
            return;
        }
        if (eventType == MouseEvent.MOUSE_RELEASED) {
            for (Node n = this; n != null; n = n.getParent()) {
                n.setPressed(e.isPrimaryButtonDown());
            }
            return;
        }

        if (e.getTarget() == this) {
            // the mouse event types are translated only when the node uses
            // its internal event dispatcher, so both entered / exited variants
            // are possible here

            if ((eventType == MouseEvent.MOUSE_ENTERED)
                    || (eventType == MouseEvent.MOUSE_ENTERED_TARGET)) {
                setHover(true);
                return;
            }

            if ((eventType == MouseEvent.MOUSE_EXITED)
                    || (eventType == MouseEvent.MOUSE_EXITED_TARGET)) {
                setHover(false);
                return;
            }
        }
    }

    void markDirtyLayoutBranch() {
        Parent p = getParent();
        while (p != null &amp;&amp; p.layoutFlag == LayoutFlags.CLEAN) {
            p.setLayoutFlag(LayoutFlags.DIRTY_BRANCH);
            if (p.isSceneRoot()) {
                Toolkit.getToolkit().requestNextPulse();
                if (getSubScene() != null) {
                    getSubScene().setDirtyLayout(p);
                }
            }
            p = p.getParent();
        }

    }

    private boolean isWindowShowing() {
        Scene s = getScene();
        if (s == null) return false;
        Window w = s.getWindow();
        return w != null &amp;&amp; w.isShowing();
    }

    private void updateTreeShowing() {
        setTreeShowing(isTreeVisible() &amp;&amp; isWindowShowing());
    }

    private boolean treeShowing;
    private TreeShowingPropertyReadOnly treeShowingRO;

    final void setTreeShowing(boolean value) {
        if (treeShowing != value) {
            treeShowing = value;
            ((TreeShowingPropertyReadOnly) treeShowingProperty()).invalidate();
        }
    }

    final boolean isTreeShowing() {
        return treeShowingProperty().get();
    }

    final BooleanExpression treeShowingProperty() {
        if (treeShowingRO == null) {
            treeShowingRO = new TreeShowingPropertyReadOnly();
        }
        return treeShowingRO;
    }

    class TreeShowingPropertyReadOnly extends BooleanExpression {

        private ExpressionHelper&lt;Boolean&gt; helper;
        private boolean valid;

        @Override
        public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        protected void invalidate() {
            if (valid) {
                valid = false;
                ExpressionHelper.fireValueChangedEvent(helper);
            }
        }

        @Override
        public boolean get() {
            valid = true;
            return Node.this.treeShowing;
        }

    }

    private void updateTreeVisible(boolean parentChanged) {
        boolean isTreeVisible = isVisible();
        final Node parentNode = getParent() != null ? getParent() :
                    clipParent != null ? clipParent :
                    getSubScene() != null ? getSubScene() : null;
        if (isTreeVisible) {
            isTreeVisible = parentNode == null || parentNode.isTreeVisible();
        }
        // When the parent has changed to visible and we have unsynchronized visibility,
        // we have to synchronize, because the rendering will now pass through the newly-visible parent
        // Otherwise an invisible Node might get rendered
        if (parentChanged &amp;&amp; parentNode != null &amp;&amp; parentNode.isTreeVisible()
                &amp;&amp; isDirty(DirtyBits.NODE_VISIBLE)) {
            addToSceneDirtyList();
        }
        setTreeVisible(isTreeVisible);

        updateTreeShowing();
    }

    private boolean treeVisible;
    private TreeVisiblePropertyReadOnly treeVisibleRO;

    final void setTreeVisible(boolean value) {
        if (treeVisible != value) {
            treeVisible = value;
            updateCanReceiveFocus();
            focusSetDirty(getScene());
            if (getClip() != null) {
                getClip().updateTreeVisible(true);
            }
            if (treeVisible &amp;&amp; !isDirtyEmpty()) {
                addToSceneDirtyList();
            }
            ((TreeVisiblePropertyReadOnly) treeVisibleProperty()).invalidate();
            if (Node.this instanceof SubScene) {
                Node subSceneRoot = ((SubScene)Node.this).getRoot();
                if (subSceneRoot != null) {
                    // SubScene.getRoot() is only null if it's constructor
                    // has not finished.
                    subSceneRoot.setTreeVisible(value &amp;&amp; subSceneRoot.isVisible());
                }
            }
        }
    }

    final boolean isTreeVisible() {
        return treeVisibleProperty().get();
    }

    final BooleanExpression treeVisibleProperty() {
        if (treeVisibleRO == null) {
            treeVisibleRO = new TreeVisiblePropertyReadOnly();
        }
        return treeVisibleRO;
    }

    class TreeVisiblePropertyReadOnly extends BooleanExpression {

        private ExpressionHelper&lt;Boolean&gt; helper;
        private boolean valid;

        @Override
        public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        protected void invalidate() {
            if (valid) {
                valid = false;
                ExpressionHelper.fireValueChangedEvent(helper);
            }
        }

        @Override
        public boolean get() {
            valid = true;
            return Node.this.treeVisible;
        }

    }

    private boolean canReceiveFocus = false;

    private void setCanReceiveFocus(boolean value) {
        canReceiveFocus = value;
    }

    final boolean isCanReceiveFocus() {
        return canReceiveFocus;
    }

    private void updateCanReceiveFocus() {
        setCanReceiveFocus(getScene() != null
          &amp;&amp; !isDisabled()
          &amp;&amp; isTreeVisible());
    }

    // for indenting messages based on scene-graph depth
    String indent() {
        String indent = &quot;&quot;;
        Parent p = this.getParent();
        while (p != null) {
            indent += &quot;  &quot;;
            p = p.getParent();
        }
        return indent;
    }

    /*
     * Should we underline the mnemonic character?
     */
    private BooleanProperty showMnemonics;

    final void setShowMnemonics(boolean value) {
        showMnemonicsProperty().set(value);
    }

    final boolean isShowMnemonics() {
        return showMnemonics == null ? false : showMnemonics.get();
    }

    final BooleanProperty showMnemonicsProperty() {
        if (showMnemonics == null) {
            showMnemonics = new BooleanPropertyBase(false) {

                @Override
                protected void invalidated() {
                    pseudoClassStateChanged(SHOW_MNEMONICS_PSEUDOCLASS_STATE, get());
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;showMnemonics&quot;;
                }
            };
        }
        return showMnemonics;
    }


    /**
     * References a node that is a labelFor this node.
     * Accessible via a NodeAccessor. See Label.labelFor for details.
     */
    private Node labeledBy = null;


    /***************************************************************************
     *                                                                         *
     *                         Event Dispatch                                  *
     *                                                                         *
     **************************************************************************/

    // PENDING_DOC_REVIEW
    /**
     * Specifies the event dispatcher for this node. The default event
     * dispatcher sends the received events to the registered event handlers and
     * filters. When replacing the value with a new {@code EventDispatcher},
     * the new dispatcher should forward events to the replaced dispatcher
     * to maintain the node's default event handling behavior.
     */
    private ObjectProperty&lt;EventDispatcher&gt; eventDispatcher;

    public final void setEventDispatcher(EventDispatcher value) {
        eventDispatcherProperty().set(value);
    }

    public final EventDispatcher getEventDispatcher() {
        return eventDispatcherProperty().get();
    }

    public final ObjectProperty&lt;EventDispatcher&gt; eventDispatcherProperty() {
        initializeInternalEventDispatcher();
        return eventDispatcher;
    }

    private NodeEventDispatcher internalEventDispatcher;

    // PENDING_DOC_REVIEW
    /**
     * Registers an event handler to this node. The handler is called when the
     * node receives an {@code Event} of the specified type during the bubbling
     * phase of event delivery.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the type of the events to receive by the handler
     * @param eventHandler the handler to register
     * @throws NullPointerException if the event type or handler is null
     */
    public final &lt;T extends Event&gt; void addEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .addEventHandler(eventType, eventHandler);
    }

    // PENDING_DOC_REVIEW
    /**
     * Unregisters a previously registered event handler from this node. One
     * handler might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the handler.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type from which to unregister
     * @param eventHandler the handler to unregister
     * @throws NullPointerException if the event type or handler is null
     */
    public final &lt;T extends Event&gt; void removeEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher()
                .getEventHandlerManager()
                .removeEventHandler(eventType, eventHandler);
    }

    // PENDING_DOC_REVIEW
    /**
     * Registers an event filter to this node. The filter is called when the
     * node receives an {@code Event} of the specified type during the capturing
     * phase of event delivery.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the type of the events to receive by the filter
     * @param eventFilter the filter to register
     * @throws NullPointerException if the event type or filter is null
     */
    public final &lt;T extends Event&gt; void addEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .addEventFilter(eventType, eventFilter);
    }

    // PENDING_DOC_REVIEW
    /**
     * Unregisters a previously registered event filter from this node. One
     * filter might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the filter.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the event type from which to unregister
     * @param eventFilter the filter to unregister
     * @throws NullPointerException if the event type or filter is null
     */
    public final &lt;T extends Event&gt; void removeEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .removeEventFilter(eventType, eventFilter);
    }

    /**
     * Sets the handler to use for this event type. There can only be one such handler
     * specified at a time. This handler is guaranteed to be called as the last, after
     * handlers added using {@link #addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}.
     * This is used for registering the user-defined onFoo event handlers.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type to associate with the given eventHandler
     * @param eventHandler the handler to register, or null to unregister
     * @throws NullPointerException if the event type is null
     */
    protected final &lt;T extends Event&gt; void setEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .setEventHandler(eventType, eventHandler);
    }

    private NodeEventDispatcher getInternalEventDispatcher() {
        initializeInternalEventDispatcher();
        return internalEventDispatcher;
    }

    private void initializeInternalEventDispatcher() {
        if (internalEventDispatcher == null) {
            internalEventDispatcher = createInternalEventDispatcher();
            eventDispatcher = new SimpleObjectProperty&lt;EventDispatcher&gt;(
                                          Node.this,
                                          &quot;eventDispatcher&quot;,
                                          internalEventDispatcher);
        }
    }

    private NodeEventDispatcher createInternalEventDispatcher() {
        return new NodeEventDispatcher(this);
    }

    /**
     * Event dispatcher for invoking preprocessing of mouse events
     */
    private EventDispatcher preprocessMouseEventDispatcher;

    // PENDING_DOC_REVIEW
    /**
     * Construct an event dispatch chain for this node. The event dispatch chain
     * contains all event dispatchers from the stage to this node.
     *
     * @param tail the initial chain to build from
     * @return the resulting event dispatch chain for this node
     */
    @Override
    public EventDispatchChain buildEventDispatchChain(
            EventDispatchChain tail) {

        if (preprocessMouseEventDispatcher == null) {
            preprocessMouseEventDispatcher = (event, tail1) -&gt; {
                event = tail1.dispatchEvent(event);
                if (event instanceof MouseEvent) {
                    preprocessMouseEvent((MouseEvent) event);
                }

                return event;
            };
        }

        tail = tail.prepend(preprocessMouseEventDispatcher);

        // prepend all event dispatchers from this node to the root
        Node curNode = this;
        do {
            if (curNode.eventDispatcher != null) {
                final EventDispatcher eventDispatcherValue =
                        curNode.eventDispatcher.get();
                if (eventDispatcherValue != null) {
                    tail = tail.prepend(eventDispatcherValue);
                }
            }
            final Node curParent = curNode.getParent();
            curNode = curParent != null ? curParent : curNode.getSubScene();
        } while (curNode != null);

        if (getScene() != null) {
            // prepend scene's dispatch chain
            tail = getScene().buildEventDispatchChain(tail);
        }

        return tail;
    }

    // PENDING_DOC_REVIEW
    /**
     * Fires the specified event. By default the event will travel through the
     * hierarchy from the stage to this node. Any event filter encountered will
     * be notified and can consume the event. If not consumed by the filters,
     * the event handlers on this node are notified. If these don't consume the
     * event either, the event will travel back the same path it arrived to
     * this node. All event handlers encountered are called and can consume the
     * event.
     * &lt;p&gt;
     * This method must be called on the FX user thread.
     *
     * @param event the event to fire
     */
    public final void fireEvent(Event event) {

        /* Log input events.  We do a coarse filter for at least the FINE
         * level and then granularize from there.
         */
        if (event instanceof InputEvent) {
            PlatformLogger logger = Logging.getInputLogger();
            if (logger.isLoggable(Level.FINE)) {
                EventType eventType = event.getEventType();
                if (eventType == MouseEvent.MOUSE_ENTERED ||
                    eventType == MouseEvent.MOUSE_EXITED) {
                    logger.finer(event.toString());
                } else if (eventType == MouseEvent.MOUSE_MOVED ||
                           eventType == MouseEvent.MOUSE_DRAGGED) {
                    logger.finest(event.toString());
                } else {
                    logger.fine(event.toString());
                }
            }
        }

        Event.fireEvent(this, event);
    }

    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/


    /**
     * {@inheritDoc}
     * @return {@code getClass().getName()} without the package name
     * @since JavaFX 8.0
     */
    @Override
    public String getTypeSelector() {

        final Class&lt;?&gt; clazz = getClass();
        final Package pkg = clazz.getPackage();

        // package could be null. not likely, but could be.
        int plen = 0;
        if (pkg != null) {
            plen = pkg.getName().length();
        }

        final int clen = clazz.getName().length();
        final int pos = (0 &lt; plen &amp;&amp; plen &lt; clen) ? plen + 1 : 0;

        return clazz.getName().substring(pos);
    }

    /**
     * {@inheritDoc}
     * @return {@code getParent()}
     * @since JavaFX 8.0
     */
    @Override
    public Styleable getStyleableParent() {
        return getParent();
    }


    /**
     * Returns the initial focus traversable state of this node, for use
     * by the JavaFX CSS engine to correctly set its initial value. This method
     * can be overridden by subclasses in instances where focus traversable should
     * initially be true (as the default implementation of this method is to return
     * false).
     *
     * @return the initial focus traversable state for this {@code Node}.
     * @since 9
     */
    protected Boolean getInitialFocusTraversable() {
        return Boolean.FALSE;
    }

    /**
     * Returns the initial cursor state of this node, for use
     * by the JavaFX CSS engine to correctly set its initial value. This method
     * can be overridden by subclasses in instances where the cursor should
     * initially be non-null (as the default implementation of this method is to return
     * null).
     *
     * @return the initial cursor state for this {@code Node}.
     * @since 9
     */
    protected Cursor getInitialCursor() {
        return null;
    }

     /**
      * Super-lazy instantiation pattern from Bill Pugh.
      */
     private static class StyleableProperties {

        private static final CssMetaData&lt;Node,Cursor&gt; CURSOR =
            new CssMetaData&lt;Node,Cursor&gt;(&quot;-fx-cursor&quot;, CursorConverter.getInstance()) {

                @Override
                public boolean isSettable(Node node) {
                    return node.miscProperties == null || node.miscProperties.canSetCursor();
                }

                @Override
                public StyleableProperty&lt;Cursor&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Cursor&gt;)node.cursorProperty();
                }

                @Override
                public Cursor getInitialValue(Node node) {
                    // Most controls default focusTraversable to true.
                    // Give a way to have them return the correct default value.
                    return node.getInitialCursor();
                }

            };
        private static final CssMetaData&lt;Node,Effect&gt; EFFECT =
            new CssMetaData&lt;Node,Effect&gt;(&quot;-fx-effect&quot;, EffectConverter.getInstance()) {

                @Override
                public boolean isSettable(Node node) {
                    return node.miscProperties == null || node.miscProperties.canSetEffect();
                }

                @Override
                public StyleableProperty&lt;Effect&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Effect&gt;)node.effectProperty();
                }
            };
        private static final CssMetaData&lt;Node,Boolean&gt; FOCUS_TRAVERSABLE =
            new CssMetaData&lt;Node,Boolean&gt;(&quot;-fx-focus-traversable&quot;,
                BooleanConverter.getInstance(), Boolean.FALSE) {

                @Override
                public boolean isSettable(Node node) {
                    return node.focusTraversable == null || !node.focusTraversable.isBound();
                }

                @Override
                public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Boolean&gt;)node.focusTraversableProperty();
                }

                @Override
                public Boolean getInitialValue(Node node) {
                    // Most controls default focusTraversable to true.
                    // Give a way to have them return the correct default value.
                    return node.getInitialFocusTraversable();
                }

            };
        private static final CssMetaData&lt;Node,Number&gt; OPACITY =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-opacity&quot;,
                SizeConverter.getInstance(), 1.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.opacity == null || !node.opacity.isBound();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.opacityProperty();
                }
            };
        private static final CssMetaData&lt;Node,BlendMode&gt; BLEND_MODE =
            new CssMetaData&lt;Node,BlendMode&gt;(&quot;-fx-blend-mode&quot;, new EnumConverter&lt;BlendMode&gt;(BlendMode.class)) {

                @Override
                public boolean isSettable(Node node) {
                    return node.blendMode == null || !node.blendMode.isBound();
                }

                @Override
                public StyleableProperty&lt;BlendMode&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;BlendMode&gt;)node.blendModeProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; ROTATE =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-rotate&quot;,
                SizeConverter.getInstance(), 0.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.rotate == null
                        || node.nodeTransformation.canSetRotate();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.rotateProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; SCALE_X =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-x&quot;,
                SizeConverter.getInstance(), 1.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.scaleX == null
                        || node.nodeTransformation.canSetScaleX();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.scaleXProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; SCALE_Y =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-y&quot;,
                SizeConverter.getInstance(), 1.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.scaleY == null
                        || node.nodeTransformation.canSetScaleY();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.scaleYProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; SCALE_Z =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-z&quot;,
                SizeConverter.getInstance(), 1.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.scaleZ == null
                        || node.nodeTransformation.canSetScaleZ();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.scaleZProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_X =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-x&quot;,
                SizeConverter.getInstance(), 0.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.translateX == null
                        || node.nodeTransformation.canSetTranslateX();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.translateXProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_Y =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-y&quot;,
                SizeConverter.getInstance(), 0.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.translateY == null
                        || node.nodeTransformation.canSetTranslateY();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.translateYProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_Z =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-z&quot;,
                SizeConverter.getInstance(), 0.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.translateZ == null
                        || node.nodeTransformation.canSetTranslateZ();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.translateZProperty();
                }
            };
         private static final CssMetaData&lt;Node, Number&gt; VIEW_ORDER
                 = new CssMetaData&lt;Node, Number&gt;(&quot;-fx-view-order&quot;,
                         SizeConverter.getInstance(), 0.0) {

                     @Override
                     public boolean isSettable(Node node) {
                         return node.miscProperties == null
                         || node.miscProperties.viewOrder == null
                         || !node.miscProperties.viewOrder.isBound();
                     }

                     @Override
                     public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                         return (StyleableProperty&lt;Number&gt;) node.viewOrderProperty();
                     }
                 };
        private static final CssMetaData&lt;Node,Boolean&gt; VISIBILITY =
            new CssMetaData&lt;Node,Boolean&gt;(&quot;visibility&quot;,
                new StyleConverter&lt;String,Boolean&gt;() {

                    @Override
<A NAME="30"></A>                    // [ visible | hidden | collapse | inherit ]
                    public Boolean convert(ParsedValue&lt;String, Boolean&gt; value, Font font) {
                        final String sval = value != null ? value.getValue() : null;
                        return <FONT color="#f9966b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#30',2,'match52-top.html#30',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;visible&quot;.equalsIgnoreCase(sval);
                    }

                },
                Boolean.TRUE) {

                @Override
                public boolean isSettable(Node node) {</B></FONT>
                    return node.visible == null || !node.visible.isBound();
                }

                @Override
                public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Boolean&gt;)node.visibleProperty();
                }
            };

         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;

         static {

             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                     new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;();
             styleables.add(CURSOR);
             styleables.add(EFFECT);
             styleables.add(FOCUS_TRAVERSABLE);
             styleables.add(OPACITY);
             styleables.add(BLEND_MODE);
             styleables.add(ROTATE);
             styleables.add(SCALE_X);
             styleables.add(SCALE_Y);
             styleables.add(SCALE_Z);
             styleables.add(VIEW_ORDER);
             styleables.add(TRANSLATE_X);
             styleables.add(TRANSLATE_Y);
             styleables.add(TRANSLATE_Z);
             styleables.add(VISIBILITY);
             STYLEABLES = Collections.unmodifiableList(styleables);

         }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        //
        // Super-lazy instantiation pattern from Bill Pugh. StyleableProperties
        // is referenced no earlier (and therefore loaded no earlier by the
        // class loader) than the moment that  getClassCssMetaData() is called.
        // This avoids loading the CssMetaData instances until the point at
        // which CSS needs the data.
        //
        return StyleableProperties.STYLEABLES;
    }

    /**
     * This method should delegate to {@link Node#getClassCssMetaData()} so that
     * a Node's CssMetaData can be accessed without the need for reflection.
     *
     * @return The CssMetaData associated with this node, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */

    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    /*
     * @return  The Styles that match this CSS property for the given Node. The
     * list is sorted by descending specificity.
     */
    // SB-dependency: RT-21096 has been filed to track this
    static List&lt;Style&gt; getMatchingStyles(CssMetaData cssMetaData, Styleable styleable) {
         return CssStyleHelper.getMatchingStyles(styleable, cssMetaData);
    }

    final ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; getStyleMap() {
         ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; map =
                 (ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;)getProperties().get(&quot;STYLEMAP&quot;);
         Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; ret = CssStyleHelper.getMatchingStyles(map, this);
         if (ret != null) {
             if (ret instanceof ObservableMap) return (ObservableMap)ret;
             return FXCollections.observableMap(ret);
         }
         return FXCollections.&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;emptyObservableMap();
     }

     /*
      * RT-17293
      */
     // SB-dependency: RT-21096 has been filed to track this
     final void setStyleMap(ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; styleMap) {
         if (styleMap != null) getProperties().put(&quot;STYLEMAP&quot;, styleMap);
         else getProperties().remove(&quot;STYLEMAP&quot;);
     }

    /*
     * Find CSS styles that were used to style this Node in its current pseudo-class state. The map will contain the styles from this node and,
     * if the node is a Parent, its children. The node corresponding to an entry in the Map can be obtained by casting a StyleableProperty key to a
     * javafx.beans.property.Property and calling getBean(). The List contains only those styles used to style the property and will contain
     * styles used to resolve lookup values.
     *
     * @param styleMap A Map to be populated with the styles. If null, a new Map will be allocated.
     * @return The Map populated with matching styles.
     */
    // SB-dependency: RT-21096 has been filed to track this
    Map&lt;StyleableProperty&lt;?&gt;,List&lt;Style&gt;&gt; findStyles(Map&lt;StyleableProperty&lt;?&gt;,List&lt;Style&gt;&gt; styleMap) {

        Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; ret = CssStyleHelper.getMatchingStyles(styleMap, this);
        return (ret != null) ? ret : Collections.&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;emptyMap();
    }

    /**
     * Flags used to indicate in which way this node is dirty (or whether it
     * is clean) and what must happen during the next CSS cycle on the
     * scenegraph.
     */
    CssFlags cssFlag = CssFlags.CLEAN;

    /**
     * Needed for testing.
     */
    final CssFlags getCSSFlags() { return cssFlag; }

    /**
     * Called when a CSS pseudo-class change would cause styles to be reapplied.
     */
    private void requestCssStateTransition() {
        // If there is no scene, then we cannot make it dirty, so we'll leave
        // the flag alone
        if (getScene() == null) return;
        // Don't bother doing anything if the cssFlag is not CLEAN.
        // If the flag indicates a DIRTY_BRANCH, the flag needs to be changed
        // to UPDATE to ensure that NodeHelper.processCSS is called on the node.
        if (cssFlag == CssFlags.CLEAN || cssFlag == CssFlags.DIRTY_BRANCH) {
            cssFlag = CssFlags.UPDATE;
            notifyParentsOfInvalidatedCSS();
        }
    }

    /**
     * Used to specify that a pseudo-class of this Node has changed. If the
     * pseudo-class is used in a CSS selector that matches this Node, CSS will
     * be reapplied. Typically, this method is called from the {@code invalidated}
     * method of a property that is used as a pseudo-class. For example:
     * &lt;pre&gt;&lt;code&gt;
     *
     *     private static final PseudoClass MY_PSEUDO_CLASS_STATE = PseudoClass.getPseudoClass(&quot;my-state&quot;);
     *
     *     BooleanProperty myPseudoClassState = new BooleanPropertyBase(false) {
     *
     *           {@literal @}Override public void invalidated() {
     *                pseudoClassStateChanged(MY_PSEUDO_CLASS_STATE, get());
     *           }
     *
     *           {@literal @}Override public Object getBean() {
     *               return MyControl.this;
     *           }
     *
     *           {@literal @}Override public String getName() {
     *               return &quot;myPseudoClassState&quot;;
     *           }
     *       };
     * &lt;/code&gt;&lt;/pre&gt;
     * @param pseudoClass the pseudo-class that has changed state
     * @param active whether or not the state is active
     * @since JavaFX 8.0
     */
    public final void pseudoClassStateChanged(PseudoClass pseudoClass, boolean active) {

        final boolean modified = active
                ? pseudoClassStates.add(pseudoClass)
                : pseudoClassStates.remove(pseudoClass);

        if (modified &amp;&amp; styleHelper != null) {
            final boolean isTransition = styleHelper.pseudoClassStateChanged(pseudoClass);
            if (isTransition) {
                requestCssStateTransition();
            }
        }
   }

    // package so that StyleHelper can get at it
    final ObservableSet&lt;PseudoClass&gt; pseudoClassStates = new PseudoClassState();
    /**
     * @return The active pseudo-class states of this Node, wrapped in an unmodifiable ObservableSet
     * @since JavaFX 8.0
     */
    public final ObservableSet&lt;PseudoClass&gt; getPseudoClassStates() {

        return FXCollections.unmodifiableObservableSet(pseudoClassStates);

    }

    // Walks up the tree telling each parent that the pseudo class state of
    // this node has changed.
    final void notifyParentsOfInvalidatedCSS() {
        SubScene subScene = getSubScene();
        Parent root = (subScene != null) ?
                subScene.getRoot() : getScene().getRoot();

        if (!root.isDirty(DirtyBits.NODE_CSS)) {
            // Ensure that Scene.root is marked as dirty. If the scene isn't
            // dirty, nothing will get repainted. This bit is cleared from
            // Scene in doCSSPass().
            NodeHelper.markDirty(root, DirtyBits.NODE_CSS);
            if (subScene != null) {
                // If the node is part of a subscene, then we must ensure that
                // the we not only mark subScene.root dirty, but continue and
                // call subScene.notifyParentsOfInvalidatedCSS() until
                // Scene.root gets marked dirty, via the recursive call:
                subScene.cssFlag = CssFlags.UPDATE;
                subScene.notifyParentsOfInvalidatedCSS();
            }
        }
        Parent _parent = getParent();
        while (_parent != null) {
            if (_parent.cssFlag == CssFlags.CLEAN) {
                _parent.cssFlag = CssFlags.DIRTY_BRANCH;
                _parent = _parent.getParent();
            } else {
                _parent = null;
            }
        }
    }

    final void reapplyCSS() {

        if (getScene() == null) return;

        if (cssFlag == CssFlags.REAPPLY) return;

        // RT-36838 - don't reapply CSS in the middle of an update
        if (cssFlag == CssFlags.UPDATE) {
            cssFlag = CssFlags.REAPPLY;
            notifyParentsOfInvalidatedCSS();
            return;
        }

        reapplyCss();

        //
        // One idiom employed by developers is to, during the layout pass,
        // add or remove nodes from the scene. For example, a ScrollPane
        // might add scroll bars to itself if it determines during layout
        // that it needs them, or a ListView might add cells to itself if
        // it determines that it needs to. In such situations we must
        // apply the CSS immediately and not add it to the scene's queue
        // for deferred action.
        //
        if (getParent() != null &amp;&amp; getParent().isPerformingLayout()) {
            NodeHelper.processCSS(this);
        } else {
            notifyParentsOfInvalidatedCSS();
        }

    }

    //
    // This method &quot;reapplies&quot; CSS to this node and all of its children. Reapplying CSS
    // means that new style maps are calculated for the node. The process of reapplying
    // CSS may reset the CSS properties of a node to their initial state, but the _new_
    // styles are not applied as part of this process.
    //
    // There is no check of the CSS state of a child since reapply takes precedence
    // over other CSS states.
    //
    private void reapplyCss() {

        // Hang on to current styleHelper so we can know whether
        // createStyleHelper returned the same styleHelper
        final CssStyleHelper oldStyleHelper = styleHelper;

        // CSS state is &quot;REAPPLY&quot;
        cssFlag = CssFlags.REAPPLY;

        styleHelper = CssStyleHelper.createStyleHelper(this);

        // REAPPLY to my children, too.
        if (this instanceof Parent) {

            // minor optimization to avoid calling createStyleHelper on children
            // when we know there will not be any change in the style maps.
            final boolean visitChildren =
                    // If we don't have a styleHelper, then we should visit the children of this parent
                    // since there might be styles that depend on being a child of this parent.
                    // In other words, we have .a &gt; .b { blah: blort; }, but no styles for &quot;.a&quot; itself.
                    styleHelper == null ||
                    // if the styleHelper changed, then we definitely need to visit the children
                    // since the new styles may have an effect on the children's styles calculated values.
                    (oldStyleHelper != styleHelper) ||
                    // If our parent is null, then we're the root of a scene or sub-scene, most likely,
                    // and we'll visit children because elsewhere the code depends on root.reapplyCSS()
                    // to force css to be reapplied (whether it needs to be or not).
                    (getParent() == null) ||
                    // If our parent's cssFlag is other than clean, then the parent may have just had
                    // CSS reapplied. If the parent just had CSS reapplied, then some of its styles
                    // may affect my children's styles.
                    (getParent().cssFlag != CssFlags.CLEAN);

            if (visitChildren) {

                List&lt;Node&gt; children = ((Parent) this).getChildren();
                for (int n = 0, nMax = children.size(); n &lt; nMax; n++) {
                    Node child = children.get(n);
                    child.reapplyCss();
                }
            }

        } else if (this instanceof SubScene) {

            // SubScene root is a Parent, but reapplyCss is a private method in Node
            final Node subSceneRoot = ((SubScene)this).getRoot();
            if (subSceneRoot != null) {
                subSceneRoot.reapplyCss();
            }

        } else if (styleHelper == null) {
            //
            // If this is not a Parent and there is no styleHelper, then the CSS state is &quot;CLEAN&quot;
            // since there are no styles to apply or children to update.
            //
            cssFlag = CssFlags.CLEAN;
            return;
        }

        cssFlag = CssFlags.UPDATE;

    }

    void processCSS() {
        switch (cssFlag) {
            case CLEAN:
                break;
            case DIRTY_BRANCH:
            {
                Parent me = (Parent)this;
                // clear the flag first in case the flag is set to something
                // other than clean by downstream processing.
                me.cssFlag = CssFlags.CLEAN;
                List&lt;Node&gt; children = me.getChildren();
                for (int i=0, max=children.size(); i&lt;max; i++) {
                    children.get(i).processCSS();
                }
                break;
            }
            case REAPPLY:
            case UPDATE:
            default:
                NodeHelper.processCSS(this);
        }
    }

    /**
     * If required, apply styles to this Node and its children, if any. This method does not normally need to
     * be invoked directly but may be used in conjunction with {@link Parent#layout()} to size a Node before the
     * next pulse, or if the {@link #getScene() Scene} is not in a {@link javafx.stage.Stage}.
     * &lt;p&gt;Provided that the Node&amp;#39;s {@link #getScene() Scene} is not null, CSS is applied to this Node regardless
     * of whether this Node&amp;#39;s CSS state is clean. CSS styles are applied from the top-most parent
     * of this Node whose CSS state is other than clean, which may affect the styling of other nodes.
     * This method is a no-op if the Node is not in a Scene. The Scene does not have to be in a Stage.&lt;/p&gt;
     * &lt;p&gt;This method does not invoke the {@link Parent#layout()} method. Typically, the caller will use the
     * following sequence of operations.&lt;/p&gt;
     * &lt;pre&gt;{@code
     *     parentNode.applyCss();
     *     parentNode.layout();
     * }&lt;/pre&gt;
     * &lt;p&gt;As a more complete example, the following code uses {@code applyCss()} and {@code layout()} to find
     * the width and height of the Button before the Stage has been shown. If either the call to {@code applyCss()}
     * or the call to {@code layout()} is commented out, the calls to {@code getWidth()} and {@code getHeight()}
     * will return zero (until some time after the Stage is shown). &lt;/p&gt;
     * &lt;pre&gt;&lt;code&gt;
     * {@literal @}Override
     * public void start(Stage stage) throws Exception {
     *
     *    Group root = new Group();
     *    Scene scene = new Scene(root);
     *
     *    Button button = new Button(&quot;Hello World&quot;);
     *    root.getChildren().add(button);
     *
     *    root.applyCss();
     *    root.layout();
     *
     *    double width = button.getWidth();
     *    double height = button.getHeight();
     *
     *    System.out.println(width + &quot;, &quot; + height);
     *
     *    stage.setScene(scene);
     *    stage.show();
     * }
     * &lt;/code&gt;&lt;/pre&gt;
     * @since JavaFX 8.0
     */
    public final void applyCss() {

        if (getScene() == null) {
            return;
        }

        // update, unless reapply
        if (cssFlag != CssFlags.REAPPLY) cssFlag = CssFlags.UPDATE;

        //
        // RT-28394 - need to see if any ancestor has a flag UPDATE
        // If so, process css from the top-most CssFlags.UPDATE node
        // since my ancestor's styles may affect mine.
        //
        // If the scene-graph root isn't NODE_CSS dirty, then all my
        // ancestor flags should be CLEAN and I can skip this lookup.
        //
        Node topMost = this;

        final boolean dirtyRoot = getScene().getRoot().isDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
        if (dirtyRoot) {

            Node _parent = getParent();
            while (_parent != null) {
                if (_parent.cssFlag == CssFlags.UPDATE || _parent.cssFlag == CssFlags.REAPPLY) {
                    topMost = _parent;
                }
                _parent = _parent.getParent();
            }

            // Note: this code used to mark the parent nodes with DIRTY_BRANCH,
            // but that isn't necessary since UPDATE will apply css to all of
            // a Parent's children.

            // If we're at the root of the scene-graph, make sure the NODE_CSS
            // dirty bit is cleared (see Scene#doCSSPass())
            if (topMost == getScene().getRoot()) {
                getScene().getRoot().clearDirty(DirtyBits.NODE_CSS);
            }
        }

        topMost.processCSS();

    }

    /*
     * If invoked, will update styles from here on down. This method should not be called directly. If
     * overridden, the overriding method must at some point call {@code super.processCSSImpl} to ensure that
     * this Node's CSS state is properly updated.
     *
     * Note that the difference between this method and {@link #applyCss()} is that this method
     * updates styles for this node on down; whereas, {@code applyCss()} looks for the top-most ancestor that needs
     * CSS update and apply styles from that node on down.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doProcessCSS() {

        // Nothing to do...
        if (cssFlag == CssFlags.CLEAN) return;

        // if REAPPLY was deferred, process it now...
        if (cssFlag == CssFlags.REAPPLY) {
            reapplyCss();
        }

        // Clear the flag first in case the flag is set to something
        // other than clean by downstream processing.
        cssFlag = CssFlags.CLEAN;

        // Transition to the new state and apply styles
        if (styleHelper != null &amp;&amp; getScene() != null) {
            styleHelper.transitionToState(this);
        }
    }


    /**
     * A StyleHelper for this node.
     * A StyleHelper contains all the css styles for this node
     * and knows how to apply them when our state changes.
     */
    CssStyleHelper styleHelper;

    private static final PseudoClass HOVER_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;hover&quot;);
    private static final PseudoClass PRESSED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;pressed&quot;);
    private static final PseudoClass DISABLED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;disabled&quot;);
    private static final PseudoClass FOCUSED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;focused&quot;);
    private static final PseudoClass SHOW_MNEMONICS_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;show-mnemonics&quot;);

    private static abstract class LazyTransformProperty
            extends ReadOnlyObjectProperty&lt;Transform&gt; {

        protected static final int VALID = 0;
        protected static final int INVALID = 1;
        protected static final int VALIDITY_UNKNOWN = 2;
        protected int valid = INVALID;

        private ExpressionHelper&lt;Transform&gt; helper;

        private Transform transform;
        private boolean canReuse = false;

        @Override
        public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public void addListener(ChangeListener&lt;? super Transform&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(ChangeListener&lt;? super Transform&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        protected Transform getInternalValue() {
            if (valid == INVALID ||
                    (valid == VALIDITY_UNKNOWN &amp;&amp; computeValidity() == INVALID)) {
                transform = computeTransform(canReuse ? transform : null);
                canReuse = true;
                valid = validityKnown() ? VALID : VALIDITY_UNKNOWN;
            }

            return transform;
        }

        @Override
        public Transform get() {
            transform = getInternalValue();
            canReuse = false;
            return transform;
        }

        public void validityUnknown() {
            if (valid == VALID) {
                valid = VALIDITY_UNKNOWN;
            }
        }

        public void invalidate() {
            if (valid != INVALID) {
                valid = INVALID;
                ExpressionHelper.fireValueChangedEvent(helper);
            }
        }

        protected abstract boolean validityKnown();
        protected abstract int computeValidity();
        protected abstract Transform computeTransform(Transform reuse);
    }

    private static abstract class LazyBoundsProperty
            extends ReadOnlyObjectProperty&lt;Bounds&gt; {
        private ExpressionHelper&lt;Bounds&gt; helper;
        private boolean valid;

        private Bounds bounds;

        @Override
        public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public void addListener(ChangeListener&lt;? super Bounds&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(ChangeListener&lt;? super Bounds&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public Bounds get() {
            if (!valid) {
                bounds = computeBounds();
                valid = true;
            }

            return bounds;
        }

        public void invalidate() {
            if (valid) {
                valid = false;
                ExpressionHelper.fireValueChangedEvent(helper);
            }
        }

        protected abstract Bounds computeBounds();
    }

    private static final BoundsAccessor boundsAccessor = (bounds, tx, node) -&gt; node.getGeomBounds(bounds, tx);

    /**
     * The accessible role for this {@code Node}.
     * &lt;p&gt;
     * The screen reader uses the role of a node to determine the
     * attributes and actions that are supported.
     *
     * @defaultValue {@link AccessibleRole#NODE}
     * @see AccessibleRole
     *
     * @since JavaFX 8u40
     */
    private ObjectProperty&lt;AccessibleRole&gt; accessibleRole;

    public final void setAccessibleRole(AccessibleRole value) {
        if (value == null) value = AccessibleRole.NODE;
        accessibleRoleProperty().set(value);
    }

    public final AccessibleRole getAccessibleRole() {
        if (accessibleRole == null) return AccessibleRole.NODE;
        return accessibleRoleProperty().get();
    }

    public final ObjectProperty&lt;AccessibleRole&gt; accessibleRoleProperty() {
        if (accessibleRole == null) {
            accessibleRole = new SimpleObjectProperty&lt;AccessibleRole&gt;(this, &quot;accessibleRole&quot;, AccessibleRole.NODE);
        }
        return accessibleRole;
    }

    public final void setAccessibleRoleDescription(String value) {
        accessibleRoleDescriptionProperty().set(value);
    }

    public final String getAccessibleRoleDescription() {
        if (accessibilityProperties == null) return null;
        if (accessibilityProperties.accessibleRoleDescription == null) return null;
        return accessibleRoleDescriptionProperty().get();
    }

    /**
     * The role description of this {@code Node}.
     * &lt;p&gt;
     * Normally, when a role is provided for a node, the screen reader
     * speaks the role as well as the contents of the node.  When this
     * value is set, it is possible to override the default.  This is
     * useful because the set of roles is predefined.  For example,
     * it is possible to set the role of a node to be a button, but
     * have the role description be arbitrary text.
     *
     * @return the role description of this {@code Node}.
     * @defaultValue null
     *
     * @since JavaFX 8u40
     */
    public final ObjectProperty&lt;String&gt; accessibleRoleDescriptionProperty() {
        return getAccessibilityProperties().getAccessibleRoleDescription();
    }

    public final void setAccessibleText(String value) {
        accessibleTextProperty().set(value);
    }

    public final String getAccessibleText() {
        if (accessibilityProperties == null) return null;
        if (accessibilityProperties.accessibleText == null) return null;
        return accessibleTextProperty().get();
    }

    /**
     * The accessible text for this {@code Node}.
     * &lt;p&gt;
     * This property is used to set the text that the screen
     * reader will speak.  If a node normally speaks text,
     * that text is overriden.  For example, a button
     * usually speaks using the text in the control but will
     * no longer do this when this value is set.
     *
     * @return accessible text for this {@code Node}.
     * @defaultValue null
     *
     * @since JavaFX 8u40
     */
    public final ObjectProperty&lt;String&gt; accessibleTextProperty() {
        return getAccessibilityProperties().getAccessibleText();
    }

    public final void setAccessibleHelp(String value) {
        accessibleHelpProperty().set(value);
    }

    public final String getAccessibleHelp() {
        if (accessibilityProperties == null) return null;
        if (accessibilityProperties.accessibleHelp == null) return null;
        return accessibleHelpProperty().get();
    }

    /**
     * The accessible help text for this {@code Node}.
     * &lt;p&gt;
     * The help text provides a more detailed description of the
     * accessible text for a node.  By default, if the node has
     * a tool tip, this text is used.
     *
     * @return the accessible help text for this {@code Node}.
     * @defaultValue null
     *
     * @since JavaFX 8u40
     */
    public final ObjectProperty&lt;String&gt; accessibleHelpProperty() {
        return getAccessibilityProperties().getAccessibleHelp();
    }

    AccessibilityProperties accessibilityProperties;
    private AccessibilityProperties getAccessibilityProperties() {
        if (accessibilityProperties == null) {
            accessibilityProperties = new AccessibilityProperties();
        }
        return accessibilityProperties;
    }

    private class AccessibilityProperties {
        ObjectProperty&lt;String&gt; accessibleRoleDescription;
        ObjectProperty&lt;String&gt; getAccessibleRoleDescription() {
            if (accessibleRoleDescription == null) {
                accessibleRoleDescription = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleRoleDescription&quot;, null);
            }
            return accessibleRoleDescription;
        }
        ObjectProperty&lt;String&gt; accessibleText;
        ObjectProperty&lt;String&gt; getAccessibleText() {
            if (accessibleText == null) {
                accessibleText = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleText&quot;, null);
            }
            return accessibleText;
        }
        ObjectProperty&lt;String&gt; accessibleHelp;
        ObjectProperty&lt;String&gt; getAccessibleHelp() {
            if (accessibleHelp == null) {
                accessibleHelp = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleHelp&quot;, null);
            }
            return accessibleHelp;
        }
    }

    /**
     * This method is called by the assistive technology to request
     * the value for an attribute.
     * &lt;p&gt;
     * This method is commonly overridden by subclasses to implement
     * attributes that are required for a specific role.&lt;br&gt;
     * If a particular attribute is not handled, the superclass implementation
     * must be called.
     * &lt;/p&gt;
     *
     * @param attribute the requested attribute
     * @param parameters optional list of parameters
     * @return the value for the requested attribute
     *
     * @see AccessibleAttribute
     *
     * @since JavaFX 8u40
     */
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case ROLE: return getAccessibleRole();
            case ROLE_DESCRIPTION: return getAccessibleRoleDescription();
            case TEXT: return getAccessibleText();
            case HELP: return getAccessibleHelp();
            case PARENT: return getParent();
            case SCENE: return getScene();
            case BOUNDS: return localToScreen(getBoundsInLocal());
            case DISABLED: return isDisabled();
            case FOCUSED: return isFocused();
            case VISIBLE: return isVisible();
            case LABELED_BY: return labeledBy;
            default: return null;
        }
    }

    /**
     * This method is called by the assistive technology to request the action
     * indicated by the argument should be executed.
     * &lt;p&gt;
     * This method is commonly overridden by subclasses to implement
     * action that are required for a specific role.&lt;br&gt;
     * If a particular action is not handled, the superclass implementation
     * must be called.
     * &lt;/p&gt;
     *
     * @param action the action to execute
     * @param parameters optional list of parameters
     *
     * @see AccessibleAction
     *
     * @since JavaFX 8u40
     */
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case REQUEST_FOCUS:
                if (isFocusTraversable()) {
                    requestFocus();
<A NAME="19"></A>                }
                break;
            case SHOW_MENU: {
                Bounds b = <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#19',2,'match52-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getBoundsInLocal();
                Point2D pt = localToScreen(b.getMaxX(), b.getMaxY());
                ContextMenuEvent event =
                    new ContextMenuEvent(ContextMenuEvent.CONTEXT_MENU_REQUESTED,
                    b.getMaxX(), b.getMaxY(), pt.getX(), pt.getY</B></FONT>(),
                    false, new PickResult(this, b.getMaxX(), b.getMaxY()));
                Event.fireEvent(this, event);
                break;
            }
            default:
        }
    }

    /**
     * This method is called by the application to notify the assistive
     * technology that the value for an attribute has changed.
     *
     * @param attributes the attribute whose value has changed
     *
     * @see AccessibleAttribute
     *
     * @since JavaFX 8u40
     */
    public final void notifyAccessibleAttributeChanged(AccessibleAttribute attributes) {
        if (accessible == null) {
            Scene scene = getScene();
            if (scene != null) {
                accessible = scene.removeAccessible(this);
            }
        }
        if (accessible != null) {
            accessible.sendNotification(attributes);
        }
    }

    Accessible accessible;
    Accessible getAccessible() {
        if (accessible == null) {
            Scene scene = getScene();
            /* It is possible the node was reparented and getAccessible()
             * is called before the pulse. Try to recycle the accessible
             * before creating a new one.
             * Note: this code relies that an accessible can never be on
             * more than one Scene#accMap. Thus, the only way
             * scene#removeAccessible() returns non-null is if the node
             * old scene and new scene are the same object.
             */
            if (scene != null) {
                accessible = scene.removeAccessible(this);
            }
        }
        if (accessible == null) {
            accessible = Application.GetApplication().createAccessible();
            accessible.setEventHandler(new Accessible.EventHandler() {
                @SuppressWarnings(&quot;deprecation&quot;)
                @Override public AccessControlContext getAccessControlContext() {
                    Scene scene = getScene();
                    if (scene == null) {
                        /* This can happen during the release process of an accessible object. */
                        throw new RuntimeException(&quot;Accessbility requested for node not on a scene&quot;);
                    }
                    if (scene.getPeer() != null) {
                        return scene.getPeer().getAccessControlContext();
                    } else {
                        /* In some rare cases the accessible for a Node is needed
                         * before its scene is made visible. For example, the screen reader
                         * might ask a Menu for its ContextMenu before the ContextMenu
                         * is made visible. That is a problem because the Window for the
                         * ContextMenu is only created immediately before the first time
                         * it is shown.
                         */
                        return scene.acc;
                    }
                }
                @Override public Object getAttribute(AccessibleAttribute attribute, Object... parameters) {
                    return queryAccessibleAttribute(attribute, parameters);
                }
                @Override public void executeAction(AccessibleAction action, Object... parameters) {
                    executeAccessibleAction(action, parameters);
                }
                @Override public String toString() {
                    String klassName = Node.this.getClass().getName();
                    return klassName.substring(klassName.lastIndexOf('.')+1);
                }
            });
        }
        return accessible;
    }

    void releaseAccessible() {
        Accessible acc = this.accessible;
        if (acc != null) {
            accessible = null;
            acc.dispose();
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/Scene.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene;

import com.sun.glass.ui.Application;
import com.sun.glass.ui.Accessible;
import com.sun.javafx.util.Logging;
import com.sun.javafx.util.Utils;
import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.collections.TrackableObservableList;
import com.sun.javafx.css.StyleManager;
import com.sun.javafx.cursor.CursorFrame;
import com.sun.javafx.event.EventQueue;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.perf.PerformanceTracker;
import com.sun.javafx.scene.CssFlags;
import com.sun.javafx.scene.LayoutFlags;
import com.sun.javafx.scene.SceneEventDispatcher;
import com.sun.javafx.scene.SceneHelper;
import com.sun.javafx.scene.input.DragboardHelper;
import com.sun.javafx.scene.input.ExtendedInputMethodRequests;
import com.sun.javafx.scene.input.InputEventUtils;
import com.sun.javafx.scene.input.PickResultChooser;
import com.sun.javafx.scene.traversal.Direction;
import com.sun.javafx.scene.traversal.SceneTraversalEngine;
import com.sun.javafx.scene.traversal.TopMostTraversalEngine;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGLightBase;
import com.sun.javafx.tk.*;
import com.sun.prism.impl.PrismSettings;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.ConditionalFeature;
import javafx.application.Platform;
import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.NamedArg;
import javafx.beans.property.*;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener.Change;
import javafx.collections.ObservableList;
import javafx.collections.ObservableMap;
import javafx.css.CssMetaData;
import javafx.css.StyleableObjectProperty;
import javafx.event.*;
import javafx.geometry.*;
import javafx.scene.image.WritableImage;
import javafx.scene.input.*;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.stage.PopupWindow;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;
import javafx.util.Callback;
import javafx.util.Duration;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;

import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

import com.sun.javafx.logging.PulseLogger;

import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.stage.WindowHelper;
import com.sun.javafx.scene.input.ClipboardHelper;
import com.sun.javafx.scene.input.TouchPointHelper;
import java.lang.ref.WeakReference;

/**
 * The JavaFX {@code Scene} class is the container for all content in a scene graph.
 * The background of the scene is filled as specified by the {@code fill} property.
 * &lt;p&gt;
 * The application must specify the root {@code Node} for the scene graph by setting
 * the {@code root} property.   If a {@code Group} is used as the root, the
 * contents of the scene graph will be clipped by the scene's width and height and
 * changes to the scene's size (if user resizes the stage) will not alter the
 * layout of the scene graph.    If a resizable node (layout {@code Region} or
 * {@code Control} is set as the root, then the root's size will track the
 * scene's size, causing the contents to be relayed out as necessary.
 * &lt;p&gt;
 * The scene's size may be initialized by the application during construction.
 * If no size is specified, the scene will automatically compute its initial
 * size based on the preferred size of its content. If only one dimension is specified,
 * the other dimension is computed using the specified dimension, respecting content bias
 * of a root.
 * &lt;p&gt;
 * An application may request depth buffer support or scene anti-aliasing
 * support at the creation of a {@code Scene}. A scene with only 2D shapes and
 * without any 3D transforms does not need a depth buffer nor scene
 * anti-aliasing support. A scene containing 3D shapes or 2D shapes with 3D
 * transforms may use depth buffer support for proper depth sorted rendering; to
 * avoid depth fighting (also known as Z fighting), disable depth testing on 2D
 * shapes that have no 3D transforms. See
 * {@link Node#depthTestProperty() depthTest} for more information. A scene with
 * 3D shapes may enable scene anti-aliasing to improve its rendering quality.
 * &lt;p&gt;
 * The depthBuffer and antiAliasing flags are conditional features. With the
 * respective default values of: false and {@code SceneAntialiasing.DISABLED}.
 * See {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 * for more information.
 * &lt;p&gt;
 * A default headlight will be added to a scene that contains one or more
 * {@code Shape3D} nodes, but no light nodes. This light source is a
 * {@code Color.WHITE} {@code PointLight} placed at the camera position.
 *
 * &lt;p&gt;
 * A {@code Scene} may be created and modified on any thread until it is attached
 * to a {@link Window} that is {@link Window#isShowing() showing}.
 * After that, it must be modified only on the JavaFX Application Thread.
 * Note that {@code Scene} is not thread-safe; modifying a {@code Scene} on
 * multiple threads at the same time will lead to unpredictable results and
 * must be avoided.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The JavaFX Application Thread is created as part of the startup process for
 * the JavaFX runtime. See the {@link javafx.application.Application} class and
 * the {@link Platform#startup(Runnable)} method for more information.
 * &lt;/p&gt;
 *
 * &lt;p&gt;Example:&lt;/p&gt;
 *
 * &lt;pre&gt;
import javafx.scene.*;
import javafx.scene.paint.*;
import javafx.scene.shape.*;

Group root = new Group();
Scene s = new Scene(root, 300, 300, Color.BLACK);

Rectangle r = new Rectangle(25,25,250,250);
r.setFill(Color.BLUE);

root.getChildren().add(r);
 * &lt;/pre&gt;
 *
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;root&quot;)
public class Scene implements EventTarget {

    private double widthSetByUser = -1.0;
    private double heightSetByUser = -1.0;
    private boolean sizeInitialized = false;
    private final boolean depthBuffer;
    private final SceneAntialiasing antiAliasing;

    private int dirtyBits;

    final AccessControlContext acc = AccessController.getContext();

    private Camera defaultCamera;

    /**
     * A node that is temporarily responsible for the FOCUS_NODE
     * accessibility attribute. E.g. a currently active MenuBar.
     */
    private Node transientFocusContainer;

    //Neither width nor height are initialized and will be calculated according to content when this Scene
    //is shown for the first time.
//    public Scene() {
//        //this(-1, -1, (Parent) new Group());
//        this(-1, -1, (Parent)null);
//    }

    /**
     * Creates a Scene for a specific root Node.
     *
     * @param root The root node of the scene graph
     *
     * @throws NullPointerException if root is null
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root) {
        this(root, -1, -1, Color.WHITE, false, SceneAntialiasing.DISABLED);
    }

//Public constructor initializing public-init properties
//When width &lt; 0, and or height &lt; 0 is passed, then width and/or height are understood as unitialized
//Unitialized dimension is calculated when Scene is shown for the first time.
//    public Scene(
//            @Default(&quot;-1&quot;) double width,
//            @Default(&quot;-1&quot;) double height) {
//        //this(width, height, (Parent)new Group());
//        this(width, height, (Parent)null);
//    }
//
//    public Scene(double width, double height, Paint fill) {
//        //this(width, height, (Parent) new Group());
//        this(width, height, (Parent)null);
//        setFill(fill);
//    }

    /**
     * Creates a Scene for a specific root Node with a specific size.
     *
     * @param root The root node of the scene graph
     * @param width The width of the scene
     * @param height The height of the scene
     *
     * @throws NullPointerException if root is null
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height) {
        this(root, width, height, Color.WHITE, false, SceneAntialiasing.DISABLED);
    }

    /**
     * Creates a Scene for a specific root Node with a fill.
     *
     * @param root The parent
     * @param fill The fill
     *
     * @throws NullPointerException if root is null
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
        this(root, -1, -1, fill, false, SceneAntialiasing.DISABLED);
    }

    /**
     * Creates a Scene for a specific root Node with a specific size and fill.
     *
     * @param root The root node of the scene graph
     * @param width The width of the scene
     * @param height The height of the scene
     * @param fill The fill
     *
     * @throws NullPointerException if root is null
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height,
            @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
        this(root, width, height, fill, false, SceneAntialiasing.DISABLED);
    }

    /**
     * Constructs a scene consisting of a root, with a dimension of width and
     * height, and specifies whether a depth buffer is created for this scene.
     * &lt;p&gt;
     * A scene with only 2D shapes and without any 3D transforms does not need a
     * depth buffer. A scene containing 3D shapes or 2D shapes with 3D
     * transforms may use depth buffer support for proper depth sorted
     * rendering; to avoid depth fighting (also known as Z fighting), disable
     * depth testing on 2D shapes that have no 3D transforms. See
     * {@link Node#depthTestProperty() depthTest} for more information.
     *
     * @param root The root node of the scene graph
     * @param width The width of the scene
     * @param height The height of the scene
     * @param depthBuffer The depth buffer flag
     * &lt;p&gt;
     * The depthBuffer flag is a conditional feature and its default value is
     * false. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @throws NullPointerException if root is null
     *
     * @see javafx.scene.Node#setDepthTest(DepthTest)
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height, @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer) {
        this(root, width, height, Color.WHITE, depthBuffer, SceneAntialiasing.DISABLED);
    }

    /**
     * Constructs a scene consisting of a root, with a dimension of width and
     * height, specifies whether a depth buffer is created for this scene and
     * specifies whether scene anti-aliasing is requested.
     * &lt;p&gt;
     * A scene with only 2D shapes and without any 3D transforms does not need a
     * depth buffer nor scene anti-aliasing support. A scene containing 3D
     * shapes or 2D shapes with 3D transforms may use depth buffer support for
     * proper depth sorted rendering; to avoid depth fighting (also known as Z
     * fighting), disable depth testing on 2D shapes that have no 3D transforms.
     * See {@link Node#depthTestProperty() depthTest} for more information. A
     * scene with 3D shapes may enable scene anti-aliasing to improve its
     * rendering quality.
     *
     * @param root The root node of the scene graph
     * @param width The width of the scene
     * @param height The height of the scene
     * @param depthBuffer The depth buffer flag
     * @param antiAliasing The scene anti-aliasing attribute. A value of
     * {@code null} is treated as DISABLED.
     * &lt;p&gt;
     * The depthBuffer and antiAliasing are conditional features. With the
     * respective default values of: false and {@code SceneAntialiasing.DISABLED}. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @throws NullPointerException if root is null
     *
     * @see javafx.scene.Node#setDepthTest(DepthTest)
     * @since JavaFX 8.0
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height,
            @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer,
            @NamedArg(value=&quot;antiAliasing&quot;, defaultValue=&quot;DISABLED&quot;) SceneAntialiasing antiAliasing) {
        this(root, width, height, Color.WHITE, depthBuffer, antiAliasing);

        if (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED &amp;&amp;
                !Toolkit.getToolkit().isMSAASupported())
        {
            String logname = Scene.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;System can't support &quot;
                + &quot;antiAliasing&quot;);
        }
    }

    private Scene(Parent root, double width, double height, Paint fill,
            boolean depthBuffer, SceneAntialiasing antiAliasing) {
        this.depthBuffer = depthBuffer;
        this.antiAliasing = antiAliasing;
        if (root == null) {
            throw new NullPointerException(&quot;Root cannot be null&quot;);
        }

        if ((depthBuffer || (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED))
                &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
            String logname = Scene.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;System can't support &quot;
                    + &quot;ConditionalFeature.SCENE3D&quot;);
        }

        init();
        setRoot(root);
        init(width, height);
        setFill(fill);
    }

    static {
            PerformanceTracker.setSceneAccessor(new PerformanceTracker.SceneAccessor() {
                public void setPerfTracker(Scene scene, PerformanceTracker tracker) {
                    synchronized (trackerMonitor) {
                        scene.tracker = tracker;
                    }
                }
                public PerformanceTracker getPerfTracker(Scene scene) {
                    synchronized (trackerMonitor) {
                        return scene.tracker;
                    }
                }
            });
            SceneHelper.setSceneAccessor(
                    new SceneHelper.SceneAccessor() {
                        @Override
                        public void enableInputMethodEvents(Scene scene, boolean enable) {
                            scene.enableInputMethodEvents(enable);
                        }

                        @Override
                        public void processKeyEvent(Scene scene, KeyEvent e) {
                            scene.processKeyEvent(e);
                        }

                        @Override
                        public void processMouseEvent(Scene scene, MouseEvent e) {
                            scene.processMouseEvent(e);
                        }

                        @Override
                        public void preferredSize(Scene scene) {
                            scene.preferredSize();
                        }

                        @Override
                        public void disposePeer(Scene scene) {
                            scene.disposePeer();
                        }

                        @Override
                        public void initPeer(Scene scene) {
                            scene.initPeer();
                        }

                        @Override
                        public void setWindow(Scene scene, Window window) {
                            scene.setWindow(window);
                        }

                        @Override
                        public TKScene getPeer(Scene scene) {
                            return scene.getPeer();
                        }

                        @Override
                        public void setAllowPGAccess(boolean flag) {
                            Scene.setAllowPGAccess(flag);
                        }

                        @Override
                        public void parentEffectiveOrientationInvalidated(
                                final Scene scene) {
                            scene.parentEffectiveOrientationInvalidated();
                        }

                        @Override
                        public Camera getEffectiveCamera(Scene scene) {
                            return scene.getEffectiveCamera();
                        }

                        @Override
                        public Scene createPopupScene(Parent root) {
                            return new Scene(root) {
                                       @Override
                                       void doLayoutPass() {
                                           resizeRootToPreferredSize(getRoot());
                                           super.doLayoutPass();
                                       }

                                       @Override
                                       void resizeRootOnSceneSizeChange(
                                               double newWidth,
                                               double newHeight) {
                                           // don't resize
                                       }
                                   };
                        }

                        @Override
                        public void setTransientFocusContainer(Scene scene, Node node) {
                            if (scene != null) {
                                scene.transientFocusContainer = node;
                            }
                        }

                        @Override
                        public Accessible getAccessible(Scene scene) {
                            return scene.getAccessible();
                        }
                    });
        }

        // Reserve space for 30 nodes in the dirtyNodes set.
        private static final int MIN_DIRTY_CAPACITY = 30;

        // For debugging
        private static boolean inSynchronizer = false;
        private static boolean inMousePick = false;
        private static boolean allowPGAccess = false;
        private static int pgAccessCount = 0;

        /**
         * Used for debugging purposes. Returns true if we are in either the
         * mouse event code (picking) or the synchronizer, or if the scene is
         * not yet initialized,
         *
         */
        static boolean isPGAccessAllowed() {
            return inSynchronizer || inMousePick || allowPGAccess;
        }

        static void setAllowPGAccess(boolean flag) {
            if (Utils.assertionEnabled()) {
                if (flag) {
                    pgAccessCount++;
                    allowPGAccess = true;
                }
                else {
                    if (pgAccessCount &lt;= 0) {
                        throw new java.lang.AssertionError(&quot;*** pgAccessCount underflow&quot;);
                    }
                    if (--pgAccessCount == 0) {
                        allowPGAccess = false;
                    }
                }
            }
        }

        /**
         * If true, use the platform's drag gesture detection
         * else use Scene-level detection as per DnDGesture.process(MouseEvent, List)
         */
        private static final boolean PLATFORM_DRAG_GESTURE_INITIATION = false;

    /**
     * Set of dirty nodes; processed once per frame by the synchronizer.
     * When a node's state changes such that it becomes &quot;dirty&quot; with respect
     * to the graphics stack and requires synchronization, then that node
     * is added to this list. Note that if state on the Node changes, but it
     * was already dirty, then the Node doesn't add itself again.
     * &lt;p&gt;
     * Because at initialization time every node in the scene graph is dirty,
     * we have a special state and special code path during initialization
     * that does not involve adding each node to the dirtyNodes list. When
     * dirtyNodes is null, that means this Scene has not yet been synchronized.
     * A good default size is then created for the dirtyNodes list.
     * &lt;p&gt;
     * We double-buffer the set so that we can add new nodes to the
     * set while processing the existing set. This avoids our having to
     * take a snapshot of the set (e.g., with toArray()) and reduces garbage.
     */
    private Node[] dirtyNodes;
    private int dirtyNodesSize;

    /**
     * Add the specified node to this scene's dirty list. Called by the
     * markDirty method in Node or when the Node's scene changes.
     */
    void addToDirtyList(Node n) {
        if (dirtyNodes == null || dirtyNodesSize == 0) {
            if (peer != null) {
                Toolkit.getToolkit().requestNextPulse();
            }
        }

        if (dirtyNodes != null) {
            if (dirtyNodesSize == dirtyNodes.length) {
                Node[] tmp = new Node[dirtyNodesSize + (dirtyNodesSize &gt;&gt; 1)];
                System.arraycopy(dirtyNodes, 0, tmp, 0, dirtyNodesSize);
                dirtyNodes = tmp;
            }
            dirtyNodes[dirtyNodesSize++] = n;
        }
    }

    private void doCSSPass() {
        final Parent sceneRoot = getRoot();
        //
        // RT-17547: when the tree is synchronized, the dirty bits are
        // are cleared but the cssFlag might still be something other than
        // clean.
        //
        // Before RT-17547, the code checked the dirty bit. But this is
        // superfluous since the dirty bit will be set if the flag is not clean,
        // but the flag will never be anything other than clean if the dirty
        // bit is not set. The dirty bit is still needed, however, since setting
        // it ensures a pulse if no other dirty bits have been set.
        //
        // For the purpose of showing the change, the dirty bit
        // check code was commented out and not removed.
        //
//        if (sceneRoot.isDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS)) {
        if (sceneRoot.cssFlag != CssFlags.CLEAN) {
            // The dirty bit isn't checked but we must ensure it is cleared.
            // The cssFlag is set to clean in either Node.processCSS or
            // NodeHelper.processCSS
            sceneRoot.clearDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
            sceneRoot.processCSS();
        }
    }

    void doLayoutPass() {
        final Parent r = getRoot();
        if (r != null) {
            r.layout();
        }
    }

    /**
     * The peer of this scene
     */
    private TKScene peer;

    /*
     * Get Scene's peer
     */
    TKScene getPeer() {
        return peer;
    }

    /**
     * The scene pulse listener that gets called on toolkit pulses
     */
    ScenePulseListener scenePulseListener = new ScenePulseListener();

    private List&lt;Runnable&gt; preLayoutPulseListeners;
    private List&lt;Runnable&gt; postLayoutPulseListeners;

    /**
     * Adds a new scene pre layout pulse listener to this scene. Every time a pulse occurs,
     * this listener will be called on the JavaFX Application Thread directly
     * &lt;strong&gt;before&lt;/strong&gt; the CSS and layout passes, and also before
     * any rendering is done for
     * this frame. This scene pulse listener is suitable for knowing when a
     * scenegraph pulse is happening and also for modifying the scenegraph
     * (as it is called before CSS and layout, so any changes made will be properly
     * styled and positioned).
     *
     * This method must be called on the JavaFX Application thread.
     *
     * @param r The Runnable to be called when the pulse occurs.
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     *
     * @throws NullPointerException if the provided Runnable is null.
     *
     * @since 9
     */
    public final void addPreLayoutPulseListener(Runnable r) {
        Toolkit.getToolkit().checkFxUserThread();

        if (r == null) {
            throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
        }
        if (preLayoutPulseListeners == null) {
            preLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
        }
        preLayoutPulseListeners.add(r);
    }

    /**
     * Removes a previously registered scene pre layout pulse listener from listening to
     * pulses in this scene. This method does nothing if the specified Runnable is
     * not already in the list.
     *
     * This method must be called on the JavaFX Application thread.
     *
     * @param r The Runnable that should no longer be called when the pulse
     * occurs for this scene.
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     *
     * @since 9
     */
    public final void removePreLayoutPulseListener(Runnable r) {
        Toolkit.getToolkit().checkFxUserThread();

        if (preLayoutPulseListeners == null) {
            return;
        }
        preLayoutPulseListeners.remove(r);
    }

    /**
     * Adds a new scene post layout pulse listener to this scene. Every time a pulse occurs,
     * this listener will be called on the JavaFX Application Thread directly
     * &lt;strong&gt;after&lt;/strong&gt; the CSS and layout passes, but before any rendering is done for
     * this frame. This scene pulse listener is suitable for knowing when a
     * scenegraph pulse is happening, but it is not suited to use cases related
     * to modifying the scenegraph (as it is called after CSS and layout, so
     * any changes will possibly be incorrect until the next pulse is run).
     * An alternative (and better) solution for situations where a scenegraph
     * modification is required to happen is to use either the
     * {@link #addPreLayoutPulseListener(Runnable)} API or the the
     * {@link javafx.animation.AnimationTimer} API.
     *
     * This method must be called on the JavaFX Application thread.
     *
     * @param r The Runnable to be called when the pulse occurs.
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     *
     * @throws NullPointerException if the provided Runnable is null.
     *
     * @since 9
     */
    public final void addPostLayoutPulseListener(Runnable r) {
        Toolkit.getToolkit().checkFxUserThread();

        if (r == null) {
            throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
        }
        if (postLayoutPulseListeners == null) {
            postLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
        }
        postLayoutPulseListeners.add(r);
    }

    /**
     * Removes a previously registered scene post layout pulse listener from listening to
     * pulses in this scene. This method does nothing if the specified Runnable is
     * not already in the list.
     *
     * This method must be called on the JavaFX Application thread.
     *
     * @param r The Runnable that should no longer be called when the pulse
     * occurs for this scene.
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     *
     * @since 9
     */
    public final void removePostLayoutPulseListener(Runnable r) {
        Toolkit.getToolkit().checkFxUserThread();

        if (postLayoutPulseListeners == null) {
            return;
        }
        postLayoutPulseListeners.remove(r);
    }

    /**
     * Return the defined {@code SceneAntialiasing} for this {@code Scene}.
     * &lt;p&gt;
     * Note: this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * and {@link javafx.scene.SceneAntialiasing SceneAntialiasing}
     * for more information.
     * @return the SceneAntialiasing for this scene
     * @since JavaFX 8.0
     */
    public final SceneAntialiasing getAntiAliasing() {
        return antiAliasing;
    }

    private boolean getAntiAliasingInternal() {
        return (antiAliasing != null &amp;&amp;
                Toolkit.getToolkit().isMSAASupported() &amp;&amp;
                Platform.isSupported(ConditionalFeature.SCENE3D)) ?
                antiAliasing != SceneAntialiasing.DISABLED : false;
    }

    /**
     * The {@code Window} for this {@code Scene}
     */
    private ReadOnlyObjectWrapper&lt;Window&gt; window;

    void setWindow(Window value) {
        windowPropertyImpl().set(value);
    }

    public final Window getWindow() {
        return window == null ? null : window.get();
    }

    public final ReadOnlyObjectProperty&lt;Window&gt; windowProperty() {
        return windowPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyObjectWrapper&lt;Window&gt; windowPropertyImpl() {
        if (window == null) {
            window = new ReadOnlyObjectWrapper&lt;Window&gt;() {
                private Window oldWindow;

                @Override protected void invalidated() {
                    final Window newWindow = get();
                    getKeyHandler().windowForSceneChanged(oldWindow, newWindow);
                    if (oldWindow != null) {
                        disposePeer();
                    }
                    if (newWindow != null) {
                        initPeer();
                    }
                    parentEffectiveOrientationInvalidated();

                    oldWindow = newWindow;
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;window&quot;;
                }
            };
        }
        return window;
    }

    void initPeer() {
        assert peer == null;

        Window window = getWindow();
        // initPeer() is only called from Window, either when the window
        // is being shown, or the window scene is being changed. In any case
        // this scene's window cannot be null.
        assert window != null;

        TKStage windowPeer = WindowHelper.getPeer(window);
        if (windowPeer == null) {
            // This is fine, the window is not visible. initPeer() will
            // be called again later, when the window is being shown.
            return;
        }

        final boolean isTransparentWindowsSupported = Platform.isSupported(ConditionalFeature.TRANSPARENT_WINDOW);
        if (!isTransparentWindowsSupported) {
            PlatformImpl.addNoTransparencyStylesheetToScene(this);
        }

        PerformanceTracker.logEvent(&quot;Scene.initPeer started&quot;);

        setAllowPGAccess(true);

        Toolkit tk = Toolkit.getToolkit();
        peer = windowPeer.createTKScene(isDepthBufferInternal(), getAntiAliasingInternal(), acc);
        PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene created&quot;);
        peer.setTKSceneListener(new ScenePeerListener());
        peer.setTKScenePaintListener(new ScenePeerPaintListener());
        PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene set&quot;);
        peer.setRoot(getRoot().getPeer());
        peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
        NodeHelper.updatePeer(getEffectiveCamera());
        peer.setCamera((NGCamera) getEffectiveCamera().getPeer());
        peer.markDirty();
        PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene initialized&quot;);

        setAllowPGAccess(false);

        tk.addSceneTkPulseListener(scenePulseListener);
        // listen to dnd gestures coming from the platform
        if (PLATFORM_DRAG_GESTURE_INITIATION) {
            if (dragGestureListener == null) {
                dragGestureListener = new DragGestureListener();
            }
            tk.registerDragGestureListener(peer, EnumSet.allOf(TransferMode.class), dragGestureListener);
        }
        tk.enableDrop(peer, new DropTargetListener());
        tk.installInputMethodRequests(peer, new InputMethodRequestsDelegate());

        PerformanceTracker.logEvent(&quot;Scene.initPeer finished&quot;);
    }

    public void disposePeer() {
        if (peer == null) {
            // This is fine, the window is either not shown yet and there is no
            // need in disposing scene peer, or is hidden and disposePeer()
            // has already been called.
            return;
        }

        PerformanceTracker.logEvent(&quot;Scene.disposePeer started&quot;);

        Toolkit tk = Toolkit.getToolkit();
        tk.removeSceneTkPulseListener(scenePulseListener);
        if (accessible != null) {
            disposeAccessibles();
            Node root = getRoot();
            if (root != null) root.releaseAccessible();
            accessible.dispose();
            accessible = null;
        }
        peer.dispose();
        peer = null;

        PerformanceTracker.logEvent(&quot;Scene.disposePeer finished&quot;);
    }

    DnDGesture dndGesture = null;
    DragGestureListener dragGestureListener;
    /**
     * The horizontal location of this {@code Scene} on the {@code Window}.
     */
    private ReadOnlyDoubleWrapper x;

    private final void setX(double value) {
        xPropertyImpl().set(value);
    }

    public final double getX() {
        return x == null ? 0.0 : x.get();
    }

    public final ReadOnlyDoubleProperty xProperty() {
        return xPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyDoubleWrapper xPropertyImpl() {
        if (x == null) {
            x = new ReadOnlyDoubleWrapper(this, &quot;x&quot;);
        }
        return x;
    }

    /**
     * The vertical location of this {@code Scene} on the {@code Window}.
     */
    private ReadOnlyDoubleWrapper y;

    private final void setY(double value) {
        yPropertyImpl().set(value);
    }

    public final double getY() {
        return y == null ? 0.0 : y.get();
    }

    public final ReadOnlyDoubleProperty yProperty() {
        return yPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyDoubleWrapper yPropertyImpl() {
        if (y == null) {
            y = new ReadOnlyDoubleWrapper(this, &quot;y&quot;);
        }
        return y;
    }

    /**
     * The width of this {@code Scene}
     */
    private ReadOnlyDoubleWrapper width;

    private final void setWidth(double value) {
        widthPropertyImpl().set(value);
    }

    public final double getWidth() {
        return width == null ? 0.0 : width.get();
    }

    public final ReadOnlyDoubleProperty widthProperty() {
        return widthPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyDoubleWrapper widthPropertyImpl() {
        if (width == null) {
            width = new ReadOnlyDoubleWrapper() {

                @Override
                protected void invalidated() {
                    final Parent _root = getRoot();
                    //TODO - use a better method to update mirroring
                    if (_root.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
                        NodeHelper.transformsChanged(_root);
                    }
                    if (_root.isResizable()) {
                        resizeRootOnSceneSizeChange(get() - _root.getLayoutX() - _root.getTranslateX(), _root.getLayoutBounds().getHeight());
                    }

                    getEffectiveCamera().setViewWidth(get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;width&quot;;
                }
            };
        }
        return width;
    }

    /**
     * The height of this {@code Scene}
     */
    private ReadOnlyDoubleWrapper height;

    private final void setHeight(double value) {
        heightPropertyImpl().set(value);
    }

    public final double getHeight() {
        return height == null ? 0.0 : height.get();
    }

    public final ReadOnlyDoubleProperty heightProperty() {
        return heightPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyDoubleWrapper heightPropertyImpl() {
        if (height == null) {
            height = new ReadOnlyDoubleWrapper() {

                @Override
                protected void invalidated() {
                    final Parent _root = getRoot();
                    if (_root.isResizable()) {
                        resizeRootOnSceneSizeChange(_root.getLayoutBounds().getWidth(), get() - _root.getLayoutY() - _root.getTranslateY());
                    }

                    getEffectiveCamera().setViewHeight(get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;height&quot;;
                }
            };
        }
        return height;
    }

    void resizeRootOnSceneSizeChange(double newWidth, double newHeight) {
        getRoot().resize(newWidth, newHeight);
    }

    // Reusable target wrapper (to avoid creating new one for each picking)
    private TargetWrapper tmpTargetWrapper = new TargetWrapper();

    /**
     * Specifies the type of camera use for rendering this {@code Scene}.
     * If {@code camera} is null, a parallel camera is used for rendering.
     * It is illegal to set a camera that belongs to other {@code Scene}
     * or {@code SubScene}.
     * &lt;p&gt;
     * Note: this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @defaultValue null
     */
    private ObjectProperty&lt;Camera&gt; camera;

    public final void setCamera(Camera value) {
        cameraProperty().set(value);
    }

    public final Camera getCamera() {
        return camera == null ? null : camera.get();
    }

    public final ObjectProperty&lt;Camera&gt; cameraProperty() {
        if (camera == null) {
            camera = new ObjectPropertyBase&lt;Camera&gt;() {
                Camera oldCamera = null;

                @Override
                protected void invalidated() {
                    Camera _value = get();
                    if (_value != null) {
                        if (_value instanceof PerspectiveCamera
                                &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
                            String logname = Scene.class.getName();
                            PlatformLogger.getLogger(logname).warning(&quot;System can't support &quot;
                                    + &quot;ConditionalFeature.SCENE3D&quot;);
                        }
                        // Illegal value if it belongs to other scene or any subscene
                        if ((_value.getScene() != null &amp;&amp; _value.getScene() != Scene.this)
                                || _value.getSubScene() != null) {
                            throw new IllegalArgumentException(_value
                                    + &quot;is already part of other scene or subscene&quot;);
                        }
                        // throws exception if the camera already has a different owner
                        _value.setOwnerScene(Scene.this);
                        _value.setViewWidth(getWidth());
                        _value.setViewHeight(getHeight());
                    }
                    if (oldCamera != null &amp;&amp; oldCamera != _value) {
                        oldCamera.setOwnerScene(null);
                    }
                    oldCamera = _value;
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;camera&quot;;
                }
            };
        }
        return camera;
    }

    Camera getEffectiveCamera() {
        final Camera cam = getCamera();
        if (cam == null
                || (cam instanceof PerspectiveCamera
                &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D))) {
            if (defaultCamera == null) {
                defaultCamera = new ParallelCamera();
                defaultCamera.setOwnerScene(this);
                defaultCamera.setViewWidth(getWidth());
                defaultCamera.setViewHeight(getHeight());
            }
            return defaultCamera;
        }

        return cam;
    }

    // Used by the camera
    void markCameraDirty() {
        markDirty(DirtyBits.CAMERA_DIRTY);
        setNeedsRepaint();
    }

    void markCursorDirty() {
        markDirty(DirtyBits.CURSOR_DIRTY);
    }

    /**
     * Defines the background fill of this {@code Scene}. Both a {@code null}
     * value meaning 'paint no background' and a {@link javafx.scene.paint.Paint}
     * with transparency are supported. The default fill of the Scene is
     * {@link Color#WHITE}, but it is more commonly the case that the initial
     * color shown to users is the background fill of the
     * {@link #rootProperty() root node} of the {@code Scene}, as it typically is
     * stretched to take up all available space in the {@code Scene}. The
     * root node of the {@code Scene} is given the CSS style class 'root', and
     * the default user agent stylesheets that ship with JavaFX (presently
     * Caspian and Modena) apply styling on to this root style class. In the
     * case of Caspian this does not impact the background fill color of the
     * root node, but in the case of Modena the default fill is set to be a
     * light gray color.
     *
     * @defaultValue WHITE
     */
    private ObjectProperty&lt;Paint&gt; fill;

    public final void setFill(Paint value) {
        fillProperty().set(value);
    }

    public final Paint getFill() {
        return fill == null ? Color.WHITE : fill.get();
    }

    public final ObjectProperty&lt;Paint&gt; fillProperty() {
        if (fill == null) {
            fill = new ObjectPropertyBase&lt;Paint&gt;(Color.WHITE) {

                @Override
                protected void invalidated() {
                    markDirty(DirtyBits.FILL_DIRTY);
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;fill&quot;;
                }
            };
        }
        return fill;
    }

    /**
     * Defines the root {@code Node} of the scene graph.
     * If a {@code Group} is used as the root, the
     * contents of the scene graph will be clipped by the scene's width and height and
     * changes to the scene's size (if user resizes the stage) will not alter the
     * layout of the scene graph.    If a resizable node (layout {@code Region} or
     * {@code Control}) is set as the root, then the root's size will track the
     * scene's size, causing the contents to be relayed out as necessary.
     *
     * Scene doesn't accept null root.
     *
     */
    private ObjectProperty&lt;Parent&gt; root;

    public final void setRoot(Parent value) {
        rootProperty().set(value);
    }

    public final Parent getRoot() {
        return root == null ? null : root.get();
    }

    Parent oldRoot;
    public final ObjectProperty&lt;Parent&gt; rootProperty() {
        if (root == null) {
            root = new ObjectPropertyBase&lt;Parent&gt;() {

                private void forceUnbind() {
                    System.err.println(&quot;Unbinding illegal root.&quot;);
                    unbind();
                }

                @Override
                protected void invalidated() {
                    Parent _value = get();

                    if (_value == null) {
                        if (isBound()) forceUnbind();
                        throw new NullPointerException(&quot;Scene's root cannot be null&quot;);
                    }

                    if (_value.getParent() != null) {
                        if (isBound()) forceUnbind();
                        throw new IllegalArgumentException(_value +
                                &quot;is already inside a scene-graph and cannot be set as root&quot;);
                    }
                    if (_value.getClipParent() != null) {
                        if (isBound()) forceUnbind();
                        throw new IllegalArgumentException(_value +
                                &quot;is set as a clip on another node, so cannot be set as root&quot;);
                    }
                    if (_value.getScene() != null &amp;&amp; _value.getScene().getRoot() == _value &amp;&amp; _value.getScene() != Scene.this) {
                        if (isBound()) forceUnbind();
                        throw new IllegalArgumentException(_value +
                                &quot;is already set as root of another scene&quot;);
                    }

                    if (oldRoot != null) {
                        oldRoot.setScenes(null, null);
                    }
                    oldRoot = _value;
                    _value.getStyleClass().add(0, &quot;root&quot;);
                    _value.setScenes(Scene.this, null);
                    markDirty(DirtyBits.ROOT_DIRTY);
                    _value.resize(getWidth(), getHeight()); // maybe no-op if root is not resizable
                    _value.requestLayout();
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;root&quot;;
                }
            };
        }
        return root;
    }

    void setNeedsRepaint() {
        if (this.peer != null) {
            peer.entireSceneNeedsRepaint();
        }
    }

    // Process CSS and layout and sync the scene prior to the snapshot
    // operation of the given node for this scene (currently the node
    // is unused but could possibly be used in the future to optimize this)
    void doCSSLayoutSyncForSnapshot(Node node) {
        if (!sizeInitialized) {
            preferredSize();
        } else {
            doCSSPass();
        }

        // we do not need pulse in the snapshot code
        // because this scene can be stage-less
        doLayoutPass();

        getRoot().updateBounds();
        if (peer != null) {
            peer.waitForRenderingToComplete();
            peer.waitForSynchronization();
            try {
                // Run the synchronizer while holding the render lock
                scenePulseListener.synchronizeSceneNodes();
            } finally {
                peer.releaseSynchronization(false);
            }
        } else {
            scenePulseListener.synchronizeSceneNodes();
        }

    }

    // Shared method for Scene.snapshot and Node.snapshot. It is static because
    // we might be doing a Node snapshot with a null scene
    static WritableImage doSnapshot(Scene scene,
            double x, double y, double w, double h,
            Node root, BaseTransform transform, boolean depthBuffer,
            Paint fill, Camera camera, WritableImage wimg) {

        Toolkit tk = Toolkit.getToolkit();
        Toolkit.ImageRenderingContext context = new Toolkit.ImageRenderingContext();

        int xMin = (int)Math.floor(x);
        int yMin = (int)Math.floor(y);
        int xMax = (int)Math.ceil(x + w);
        int yMax = (int)Math.ceil(y + h);
        int width = Math.max(xMax - xMin, 1);
        int height = Math.max(yMax - yMin, 1);
        if (wimg == null) {
            wimg = new WritableImage(width, height);
        } else {
            width = (int)wimg.getWidth();
            height = (int)wimg.getHeight();
        }

        setAllowPGAccess(true);
        context.x = xMin;
        context.y = yMin;
        context.width = width;
        context.height = height;
        context.transform = transform;
        context.depthBuffer = depthBuffer;
        context.root = root.getPeer();
        context.platformPaint = fill == null ? null : tk.getPaint(fill);
        double cameraViewWidth = 1.0;
        double cameraViewHeight = 1.0;
        if (camera != null) {
            // temporarily adjust camera viewport to the snapshot size
            cameraViewWidth = camera.getViewWidth();
            cameraViewHeight = camera.getViewHeight();
            camera.setViewWidth(width);
            camera.setViewHeight(height);
            NodeHelper.updatePeer(camera);
            context.camera = camera.getPeer();
        } else {
            context.camera = null;
        }

        // Grab the lights from the scene
        context.lights = null;
        if (scene != null &amp;&amp; !scene.lights.isEmpty()) {
            context.lights = new NGLightBase[scene.lights.size()];
            for (int i = 0; i &lt; scene.lights.size(); i++) {
                context.lights[i] = scene.lights.get(i).getPeer();
            }
        }

        Toolkit.WritableImageAccessor accessor = Toolkit.getWritableImageAccessor();
        context.platformImage = accessor.getTkImageLoader(wimg);
        setAllowPGAccess(false);
        Object tkImage = tk.renderToImage(context);
        accessor.loadTkImage(wimg, tkImage);

        if (camera != null) {
            setAllowPGAccess(true);
            camera.setViewWidth(cameraViewWidth);
            camera.setViewHeight(cameraViewHeight);
            NodeHelper.updatePeer(camera);
            setAllowPGAccess(false);
        }

        // if this scene belongs to some stage
        // we need to mark the entire scene as dirty
        // because dirty logic is buggy
        if (scene != null &amp;&amp; scene.peer != null) {
            scene.setNeedsRepaint();
        }

        return wimg;
    }

    /**
     * Implementation method for snapshot
     */
    private WritableImage doSnapshot(WritableImage img) {
        // TODO: no need to do CSS, layout or sync in the deferred case,
        // if this scene is attached to a visible stage
        doCSSLayoutSyncForSnapshot(getRoot());

        double w = getWidth();
        double h = getHeight();
        BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;

        return doSnapshot(this, 0, 0, w, h,
                getRoot(), transform, isDepthBufferInternal(),
                getFill(), getEffectiveCamera(), img);
    }

    // Pulse listener used to run all deferred (async) snapshot requests
    private static TKPulseListener snapshotPulseListener = null;

    private static List&lt;Runnable&gt; snapshotRunnableListA;
    private static List&lt;Runnable&gt; snapshotRunnableListB;
    private static List&lt;Runnable&gt; snapshotRunnableList;

    static void addSnapshotRunnable(final Runnable runnable) {
        Toolkit.getToolkit().checkFxUserThread();

        if (snapshotPulseListener == null) {
            snapshotRunnableListA = new ArrayList&lt;Runnable&gt;();
            snapshotRunnableListB = new ArrayList&lt;Runnable&gt;();
            snapshotRunnableList = snapshotRunnableListA;

            snapshotPulseListener = () -&gt; {
                if (snapshotRunnableList.size() &gt; 0) {
                    List&lt;Runnable&gt; runnables = snapshotRunnableList;
                    if (snapshotRunnableList == snapshotRunnableListA) {
                        snapshotRunnableList = snapshotRunnableListB;
                    } else {
                        snapshotRunnableList = snapshotRunnableListA;
                    }
                    for (Runnable r : runnables) {
                        try {
                            r.run();
                        } catch (Throwable th) {
                            System.err.println(&quot;Exception in snapshot runnable&quot;);
                            th.printStackTrace(System.err);
                        }
                    }
                    runnables.clear();
                }
            };

            // Add listener that will be called after all of the scenes have
            // had layout and CSS processing, and have been synced
            Toolkit.getToolkit().addPostSceneTkPulseListener(snapshotPulseListener);
        }

        final AccessControlContext acc = AccessController.getContext();
        snapshotRunnableList.add(() -&gt; {
            AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                runnable.run();
                return null;
            }, acc);
        });
        Toolkit.getToolkit().requestNextPulse();
    }

    /**
     * Takes a snapshot of this scene and returns the rendered image when
     * it is ready.
     * CSS and layout processing will be done for the scene prior to
     * rendering it.
     * The entire destination image is cleared using the fill {@code Paint}
     * of this scene. The nodes in the scene are then rendered to the image.
     * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
     * If the image is smaller than the size of the scene, then the rendering
     * will be clipped by the image.
     *
     * &lt;p&gt;
     * When taking a snapshot of a scene that is being animated, either
     * explicitly by the application or implicitly (such as chart animation),
     * the snapshot will be rendered based on the state of the scene graph at
     * the moment the snapshot is taken and will not reflect any subsequent
     * animation changes.
     * &lt;/p&gt;
     *
     * @param image the writable image that will be used to hold the rendered scene.
     * It may be null in which case a new WritableImage will be constructed.
     * If the image is non-null, the scene will be rendered into the
     * existing image.
     * In this case, the width and height of the image determine the area
     * that is rendered instead of the width and height of the scene.
     *
     * @throws IllegalStateException if this method is called on a thread
     *     other than the JavaFX Application Thread.
     *
     * @return the rendered image
     * @since JavaFX 2.2
     */
    public WritableImage snapshot(WritableImage image) {
        Toolkit.getToolkit().checkFxUserThread();

        return doSnapshot(image);
    }

    /**
     * Takes a snapshot of this scene at the next frame and calls the
     * specified callback method when the image is ready.
     * CSS and layout processing will be done for the scene prior to
     * rendering it.
     * The entire destination image is cleared using the fill {@code Paint}
     * of this scene. The nodes in the scene are then rendered to the image.
     * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
     * If the image is smaller than the size of the scene, then the rendering
     * will be clipped by the image.
     *
     * &lt;p&gt;
     * This is an asynchronous call, which means that other
     * events or animation might be processed before the scene is rendered.
     * If any such events modify a node in the scene that modification will
     * be reflected in the rendered image (as it will also be reflected in
     * the frame rendered to the Stage).
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * When taking a snapshot of a scene that is being animated, either
     * explicitly by the application or implicitly (such as chart animation),
     * the snapshot will be rendered based on the state of the scene graph at
     * the moment the snapshot is taken and will not reflect any subsequent
     * animation changes.
     * &lt;/p&gt;
     *
     * @param callback a class whose call method will be called when the image
     * is ready. The SnapshotResult that is passed into the call method of
     * the callback will contain the rendered image and the source scene
     * that was rendered. The callback parameter must not be null.
     *
     * @param image the writable image that will be used to hold the rendered scene.
     * It may be null in which case a new WritableImage will be constructed.
     * If the image is non-null, the scene will be rendered into the
     * existing image.
     * In this case, the width and height of the image determine the area
     * that is rendered instead of the width and height of the scene.
     *
     * @throws IllegalStateException if this method is called on a thread
     *     other than the JavaFX Application Thread.
     *
     * @throws NullPointerException if the callback parameter is null.
     * @since JavaFX 2.2
     */
    public void snapshot(Callback&lt;SnapshotResult, Void&gt; callback, WritableImage image) {
        Toolkit.getToolkit().checkFxUserThread();
        if (callback == null) {
            throw new NullPointerException(&quot;The callback must not be null&quot;);
        }

        final Callback&lt;SnapshotResult, Void&gt; theCallback = callback;
        final WritableImage theImage = image;

        // Create a deferred runnable that will be run from a pulse listener
        // that is called after all of the scenes have been synced but before
        // any of them have been rendered.
        final Runnable snapshotRunnable = () -&gt; {
            WritableImage img = doSnapshot(theImage);
//                System.err.println(&quot;Calling snapshot callback&quot;);
            SnapshotResult result = new SnapshotResult(img, Scene.this, null);
            try {
                Void v = theCallback.call(result);
            } catch (Throwable th) {
                System.err.println(&quot;Exception in snapshot callback&quot;);
                th.printStackTrace(System.err);
            }
        };
//        System.err.println(&quot;Schedule a snapshot in the future&quot;);
        addSnapshotRunnable(snapshotRunnable);
    }

    /**
     * Defines the mouse cursor for this {@code Scene}.
     */
    private ObjectProperty&lt;Cursor&gt; cursor;

    public final void setCursor(Cursor value) {
        cursorProperty().set(value);
    }

    public final Cursor getCursor() {
        return cursor == null ? null : cursor.get();
    }

    public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
        if (cursor == null) {
            cursor = new ObjectPropertyBase&lt;Cursor&gt;() {
                         @Override
                         protected void invalidated() {
                             markCursorDirty();
                         }

                         @Override
                         public Object getBean() {
                             return Scene.this;
                         }

                         @Override
                         public String getName() {
                             return &quot;cursor&quot;;
                         }
                     };
        }
        return cursor;
    }

    /**
     * Looks for any node within the scene graph based on the specified CSS selector.
     * If more than one node matches the specified selector, this function
     * returns the first of them.
     * If no nodes are found with this id, then null is returned.
     *
     * @param selector The css selector to look up
     * @return the {@code Node} in the scene which matches the CSS {@code selector},
     * or {@code null} if none is found.
     */
     public Node lookup(String selector) {
         return getRoot().lookup(selector);
     }
    /**
     * A ObservableList of string URLs linking to the stylesheets to use with this scene's
     * contents. For additional information about using CSS with the
     * scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
     * Guide&lt;/a&gt;.
     */
    private final ObservableList&lt;String&gt; stylesheets  = new TrackableObservableList&lt;String&gt;() {
        @Override
        protected void onChanged(Change&lt;String&gt; c) {
            StyleManager.getInstance().stylesheetsChanged(Scene.this, c);
            // RT-9784 - if stylesheet is removed, reset styled properties to
            // their initial value.
            c.reset();
            while(c.next()) {
                if (c.wasRemoved() == false) {
                    continue;
                }
                break; // no point in resetting more than once...
            }
            getRoot().reapplyCSS();
        }
    };

    /**
     * Gets an observable list of string URLs linking to the stylesheets to use
     * with this scene's contents.
     * &lt;p&gt;
     * The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
     * does not have a [scheme:] component, the URL is considered to be the [path] component only.
     * Any leading '/' character of the [path] is ignored and the [path] is treated as a path relative to
     * the root of the application's classpath.
     * &lt;/p&gt;
     * &lt;pre&gt;&lt;code&gt;
     *
     * package com.example.javafx.app;
     *
     * import javafx.application.Application;
     * import javafx.scene.Group;
     * import javafx.scene.Scene;
     * import javafx.stage.Stage;
     *
     * public class MyApp extends Application {
     *
     *     {@literal @}Override public void start(Stage stage) {
     *         Scene scene = new Scene(new Group());
     *         scene.getStylesheets().add(&quot;/com/example/javafx/app/mystyles.css&quot;);
     *         stage.setScene(scene);
     *         stage.show();
     *     }
     *
     *     public static void main(String[] args) {
     *         launch(args);
     *     }
     * }
     * &lt;/code&gt;&lt;/pre&gt;
     * For additional information about using CSS with the scene graph,
     * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     *
     * @return the list of stylesheets to use with this scene
     */
    public final ObservableList&lt;String&gt; getStylesheets() { return stylesheets; }

    private ObjectProperty&lt;String&gt; userAgentStylesheet = null;

    /**
     * @return the userAgentStylesheet property.
     * @see #getUserAgentStylesheet()
     * @see #setUserAgentStylesheet(String)
     * @since  JavaFX 8u20
     */
    public final ObjectProperty&lt;String&gt; userAgentStylesheetProperty() {
        if (userAgentStylesheet == null) {
            userAgentStylesheet = new SimpleObjectProperty&lt;String&gt;(Scene.this, &quot;userAgentStylesheet&quot;, null) {
                @Override protected void invalidated() {
                    StyleManager.getInstance().forget(Scene.this);
                    getRoot().reapplyCSS();
                }
            };
        }
        return userAgentStylesheet;
    }

    /**
     * Get the URL of the user-agent stylesheet that will be used by this Scene. If the URL has not been set,
     * the platform-default user-agent stylesheet will be used.
     * &lt;p&gt;
     * For additional information about using CSS with the scene graph,
     * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     * &lt;/p&gt;
     * @return The URL of the user-agent stylesheet that will be used by this Scene,
     * or null if has not been set.
     * @since  JavaFX 8u20
     */
    public final String getUserAgentStylesheet() {
        return userAgentStylesheet == null ? null : userAgentStylesheet.get();
    }

    /**
     * Set the URL of the user-agent stylesheet that will be used by this Scene in place of the
     * the platform-default user-agent stylesheet. If the URL does not resolve to a valid location,
     * the platform-default user-agent stylesheet will be used.
     * &lt;p&gt;
     * For additional information about using CSS with the scene graph,
     * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     * &lt;/p&gt;
     * @param url The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
     * does not have a [scheme:] component, the URL is considered to be the [path] component only.
     * Any leading '/' character of the [path] is ignored and the [path] is treated as a path relative to
     * the root of the application's classpath.
     * @since  JavaFX 8u20
     */
    public final void setUserAgentStylesheet(String url) {
        userAgentStylesheetProperty().set(url);
    }

    /**
     * Retrieves the depth buffer attribute for this scene.
     * @return the depth buffer attribute.
     */
    public final boolean isDepthBuffer() {
        return depthBuffer;
    }

    boolean isDepthBufferInternal() {
        if (!Platform.isSupported(ConditionalFeature.SCENE3D)) {
            return false;
        }
        return depthBuffer;
    }

    private void init(double width, double height) {
        if (width &gt;= 0) {
            widthSetByUser = width;
            setWidth((float)width);
        }
        if (height &gt;= 0) {
            heightSetByUser = height;
            setHeight((float)height);
        }
        sizeInitialized = (widthSetByUser &gt;= 0 &amp;&amp; heightSetByUser &gt;= 0);
    }

    private void init() {
        if (PerformanceTracker.isLoggingEnabled()) {
            PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;]&quot;);
        }
        mouseHandler = new MouseHandler();
        clickGenerator = new ClickGenerator();

        if (PerformanceTracker.isLoggingEnabled()) {
            PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;] - finished&quot;);
        }
    }

    void preferredSize() {
        final Parent root = getRoot();

        // one or the other isn't initialized, need to perform layout in
        // order to ensure we can properly measure the preferred size of the
        // scene
        doCSSPass();

        resizeRootToPreferredSize(root);
        doLayoutPass();

        if (widthSetByUser &lt; 0) {
            setWidth(root.isResizable()? root.getLayoutX() + root.getTranslateX() + root.getLayoutBounds().getWidth() :
                            root.getBoundsInParent().getMaxX());
        } else {
            setWidth(widthSetByUser);
        }

        if (heightSetByUser &lt; 0) {
            setHeight(root.isResizable()? root.getLayoutY() + root.getTranslateY() + root.getLayoutBounds().getHeight() :
                            root.getBoundsInParent().getMaxY());
        } else {
            setHeight(heightSetByUser);
        }

        sizeInitialized = (getWidth() &gt; 0) &amp;&amp; (getHeight() &gt; 0);

        PerformanceTracker.logEvent(&quot;Scene preferred bounds computation complete&quot;);
    }

    final void resizeRootToPreferredSize(Parent root) {
        final double preferredWidth;
        final double preferredHeight;

        final Orientation contentBias = root.getContentBias();
        if (contentBias == null) {
            preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
            preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
        } else if (contentBias == Orientation.HORIZONTAL) {
            // height depends on width
            preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
            preferredHeight = getPreferredHeight(root, heightSetByUser,
                                                       preferredWidth);
        } else /* if (contentBias == Orientation.VERTICAL) */ {
            // width depends on height
            preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
            preferredWidth = getPreferredWidth(root, widthSetByUser,
                                                     preferredHeight);
        }

        root.resize(preferredWidth, preferredHeight);
    }

    private static double getPreferredWidth(Parent root,
                                            double forcedWidth,
                                            double height) {
        if (forcedWidth &gt;= 0) {
            return forcedWidth;
        }
        final double normalizedHeight = (height &gt;= 0) ? height : -1;
        return root.boundedSize(root.prefWidth(normalizedHeight),
                                root.minWidth(normalizedHeight),
                                root.maxWidth(normalizedHeight));
    }

    private static double getPreferredHeight(Parent root,
                                             double forcedHeight,
                                             double width) {
        if (forcedHeight &gt;= 0) {
            return forcedHeight;
        }
        final double normalizedWidth = (width &gt;= 0) ? width : -1;
        return root.boundedSize(root.prefHeight(normalizedWidth),
                                root.minHeight(normalizedWidth),
                                root.maxHeight(normalizedWidth));
    }

    private PerformanceTracker tracker;
    private static final Object trackerMonitor = new Object();

    // mouse events handling
    private MouseHandler mouseHandler;
    private ClickGenerator clickGenerator;

    // gesture events handling
    private Point2D cursorScreenPos;
    private Point2D cursorScenePos;

    private static class TouchGesture {
        WeakReference&lt;EventTarget&gt; target;
        Point2D sceneCoords;
        Point2D screenCoords;
        boolean finished;
    }

    private final TouchGesture scrollGesture = new TouchGesture();
    private final TouchGesture zoomGesture = new TouchGesture();
    private final TouchGesture rotateGesture = new TouchGesture();
    private final TouchGesture swipeGesture = new TouchGesture();

    // touch events handling
    private TouchMap touchMap = new TouchMap();
    private TouchEvent nextTouchEvent = null;
    private TouchPoint[] touchPoints = null;
    private int touchEventSetId = 0;
    private int touchPointIndex = 0;
    private Map&lt;Integer, EventTarget&gt; touchTargets =
            new HashMap&lt;Integer, EventTarget&gt;();

    void processMouseEvent(MouseEvent e) {
        mouseHandler.process(e, false);
    }

    private void processMenuEvent(double x2, double y2, double xAbs, double yAbs, boolean isKeyboardTrigger) {
        EventTarget eventTarget = null;
        Scene.inMousePick = true;
        if (isKeyboardTrigger) {
            Node sceneFocusOwner = getFocusOwner();

            // for keyboard triggers set coordinates inside focus owner
            final double xOffset = xAbs - x2;
            final double yOffset = yAbs - y2;
            if (sceneFocusOwner != null) {
                final Bounds bounds = sceneFocusOwner.localToScene(
                        sceneFocusOwner.getBoundsInLocal());
                x2 = bounds.getMinX() + bounds.getWidth() / 4;
                y2 = bounds.getMinY() + bounds.getHeight() / 2;
                eventTarget = sceneFocusOwner;
            } else {
                x2 = Scene.this.getWidth() / 4;
                y2 = Scene.this.getWidth() / 2;
                eventTarget = Scene.this;
            }

            xAbs = x2 + xOffset;
            yAbs = y2 + yOffset;
        }

        final PickResult res = pick(x2, y2);

        if (!isKeyboardTrigger) {
            eventTarget = res.getIntersectedNode();
            if (eventTarget == null) {
                eventTarget = this;
            }
        }

        if (eventTarget != null) {
            ContextMenuEvent context = new ContextMenuEvent(ContextMenuEvent.CONTEXT_MENU_REQUESTED,
                    x2, y2, xAbs, yAbs, isKeyboardTrigger, res);
            Event.fireEvent(eventTarget, context);
        }
        Scene.inMousePick = false;
    }

    private void processGestureEvent(GestureEvent e, TouchGesture gesture) {
        EventTarget pickedTarget = null;

        if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
                e.getEventType() == RotateEvent.ROTATION_STARTED ||
                e.getEventType() == ScrollEvent.SCROLL_STARTED) {
            gesture.target = null;
            gesture.finished = false;
        }

        if (gesture.target != null &amp;&amp; (!gesture.finished || e.isInertia())) {
            pickedTarget = gesture.target.get();
        } else {
            pickedTarget = e.getPickResult().getIntersectedNode();
            if (pickedTarget == null) {
                pickedTarget = this;
            }
        }

        if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
                e.getEventType() == RotateEvent.ROTATION_STARTED ||
                e.getEventType() == ScrollEvent.SCROLL_STARTED) {
            gesture.target = new WeakReference&lt;&gt;(pickedTarget);
        }
        if (e.getEventType() != ZoomEvent.ZOOM_FINISHED &amp;&amp;
                e.getEventType() != RotateEvent.ROTATION_FINISHED &amp;&amp;
                e.getEventType() != ScrollEvent.SCROLL_FINISHED &amp;&amp;
                !e.isInertia()) {
            gesture.sceneCoords = new Point2D(e.getSceneX(), e.getSceneY());
            gesture.screenCoords = new Point2D(e.getScreenX(), e.getScreenY());
        }

        if (pickedTarget != null) {
            Event.fireEvent(pickedTarget, e);
        }

        if (e.getEventType() == ZoomEvent.ZOOM_FINISHED ||
                e.getEventType() == RotateEvent.ROTATION_FINISHED ||
                e.getEventType() == ScrollEvent.SCROLL_FINISHED) {
            gesture.finished = true;
        }
    }

    private void processTouchEvent(TouchEvent e, TouchPoint[] touchPoints) {
        inMousePick = true;
        touchEventSetId++;

        List&lt;TouchPoint&gt; touchList = Arrays.asList(touchPoints);

        // fire all the events
        for (TouchPoint tp : touchPoints) {
            if (tp.getTarget() != null) {
                EventType&lt;TouchEvent&gt; type = null;
                switch (tp.getState()) {
                    case MOVED:
                        type = TouchEvent.TOUCH_MOVED;
                        break;
                    case PRESSED:
                        type = TouchEvent.TOUCH_PRESSED;
                        break;
                    case RELEASED:
                        type = TouchEvent.TOUCH_RELEASED;
                        break;
                    case STATIONARY:
                        type = TouchEvent.TOUCH_STATIONARY;
                        break;
                }

                for (TouchPoint t : touchPoints) {
                    TouchPointHelper.reset(t);
                }

                TouchEvent te = new TouchEvent(type, tp, touchList,
                        touchEventSetId, e.isShiftDown(), e.isControlDown(),
                        e.isAltDown(), e.isMetaDown());

                Event.fireEvent(tp.getTarget(), te);
            }
        }

        // process grabbing
        for (TouchPoint tp : touchPoints) {
            EventTarget grabbed = tp.getGrabbed();
            if (grabbed != null) {
                touchTargets.put(tp.getId(), grabbed);
            };

            if (grabbed == null || tp.getState() == TouchPoint.State.RELEASED) {
                touchTargets.remove(tp.getId());
            }
        }

        inMousePick = false;
    }

    /**
     * Note: The only user of this method is in unit test: PickAndContainTest.
     */
    Node test_pick(double x, double y) {
        inMousePick = true;
        PickResult result = mouseHandler.pickNode(new PickRay(x, y, 1,
                Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY));
        inMousePick = false;
        if (result != null) {
            return result.getIntersectedNode();
        }
        return null;
    }

    private PickResult pick(final double x, final double y) {
        pick(tmpTargetWrapper, x, y);
        return tmpTargetWrapper.getResult();
    }

    private boolean isInScene(double x, double y) {
        if (x &lt; 0 || y &lt; 0 || x &gt; getWidth() || y &gt; getHeight())  {
            return false;
        }

        Window w = getWindow();
        if (w instanceof Stage
                &amp;&amp; ((Stage) w).getStyle() == StageStyle.TRANSPARENT
                &amp;&amp; getFill() == null) {
            return false;
        }

        return true;
    }

    private void pick(TargetWrapper target, final double x, final double y) {
        final PickRay pickRay = getEffectiveCamera().computePickRay(
                x, y, null);

        final double mag = pickRay.getDirectionNoClone().length();
        pickRay.getDirectionNoClone().normalize();
        final PickResult res = mouseHandler.pickNode(pickRay);
        if (res != null) {
            target.setNodeResult(res);
        } else {
            //TODO: is this the intersection with projection plane?
            Vec3d o = pickRay.getOriginNoClone();
            Vec3d d = pickRay.getDirectionNoClone();
            target.setSceneResult(new PickResult(
                    null, new Point3D(
                    o.x + mag * d.x,
                    o.y + mag * d.y,
                    o.z + mag * d.z),
                    mag),
                    isInScene(x, y) ? this : null);
        }
    }

    /***************************************************************************
     *                                                                         *
     * Key Events and Focus Traversal                                          *
     *                                                                         *
     **************************************************************************/

    /*
     * We cannot initialize keyHandler in init because some of the triggers
     * access it before the init block.
     * No clue why def keyHandler = bind lazy {KeyHandler{scene:this};}
     * does not compile.
     */
    private KeyHandler keyHandler = null;
    private KeyHandler getKeyHandler() {
        if (keyHandler == null) {
            keyHandler = new KeyHandler();
        }
        return keyHandler;
    }
    /**
     * Set to true if something has happened to the focused node that makes
     * it no longer eligible to have the focus.
     *
     */
    private boolean focusDirty = true;

    final void setFocusDirty(boolean value) {
        if (!focusDirty) {
            Toolkit.getToolkit().requestNextPulse();
        }
        focusDirty = value;
    }

    final boolean isFocusDirty() {
        return focusDirty;
    }

    private TopMostTraversalEngine traversalEngine = new SceneTraversalEngine(this);

    /**
     * Traverses focus from the given node in the given direction.
     */
    boolean traverse(Node node, Direction dir) {
        if (node.getSubScene() != null) {
            return node.getSubScene().traverse(node, dir);
        }
        return traversalEngine.trav(node, dir) != null;
    }

    /**
     * Moves the focus to a reasonable initial location. Called when a scene's
     * focus is dirty and there's no current owner, or if the owner has been
     * removed from the scene.
     */
    private void focusInitial() {
        traversalEngine.traverseToFirst();
    }

    /**
     * Moves the focus to a reasonble location &quot;near&quot; the given node.
     * Called when the focused node is no longer eligible to have
     * the focus because it has become invisible or disabled. This
     * function assumes that it is still a member of the same scene.
     */
    private void focusIneligible(Node node) {
        traverse(node, Direction.NEXT);
    }

    public void processKeyEvent(KeyEvent e) {
        if (dndGesture != null) {
            if (!dndGesture.processKey(e)) {
                dndGesture = null;
            }
        }

        getKeyHandler().process(e);
    }

    void requestFocus(Node node) {
        getKeyHandler().requestFocus(node);
    }

    private Node oldFocusOwner;

    /**
      * The scene's current focus owner node. This node's &quot;focused&quot;
      * variable might be false if this scene has no window, or if the
      * window is inactive (window.focused == false).
      * @since JavaFX 2.2
      */
    private ReadOnlyObjectWrapper&lt;Node&gt; focusOwner = new ReadOnlyObjectWrapper&lt;Node&gt;(this, &quot;focusOwner&quot;) {

        @Override
        protected void invalidated() {
            if (oldFocusOwner != null) {
                ((Node.FocusedProperty) oldFocusOwner.focusedProperty()).store(false);
            }
            Node value = get();
            if (value != null) {
                ((Node.FocusedProperty) value.focusedProperty()).store(keyHandler.windowFocused);
                if (value != oldFocusOwner) {
                    value.getScene().enableInputMethodEvents(
                            value.getInputMethodRequests() != null
                            &amp;&amp; value.getOnInputMethodTextChanged() != null);
                }
            }
            // for the rest of the method we need to update the oldFocusOwner
            // and use a local copy of it because the user handlers can cause
            // recurrent calls of requestFocus
            Node localOldOwner = oldFocusOwner;
            oldFocusOwner = value;
            if (localOldOwner != null) {
                ((Node.FocusedProperty) localOldOwner.focusedProperty()).notifyListeners();
            }
            if (value != null) {
                ((Node.FocusedProperty) value.focusedProperty()).notifyListeners();
            }
            PlatformLogger logger = Logging.getFocusLogger();
            if (logger.isLoggable(Level.FINE)) {
                if (value == get()) {
                    logger.fine(&quot;Changed focus from &quot;
                            + localOldOwner + &quot; to &quot; + value);
                } else {
                    logger.fine(&quot;Changing focus from &quot;
                            + localOldOwner + &quot; to &quot; + value
                            + &quot; canceled by nested requestFocus&quot;);
                }
            }
            if (accessible != null) {
                accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
            }
        }
    };

    public final Node getFocusOwner() {
        return focusOwner.get();
    }

    public final ReadOnlyObjectProperty&lt;Node&gt; focusOwnerProperty() {
        return focusOwner.getReadOnlyProperty();
    }

    // For testing.
    void focusCleanup() {
        scenePulseListener.focusCleanup();
    }

    private void processInputMethodEvent(InputMethodEvent e) {
        Node node = getFocusOwner();
        if (node != null) {
            node.fireEvent(e);
        }
    }

    public void enableInputMethodEvents(boolean enable) {
       if (peer != null) {
           peer.enableInputMethodEvents(enable);
       }
    }

    /**
     * Returns true if this scene is quiescent, i.e. it has no activity
     * pending on it such as CSS processing or layout requests.
     *
     * Intended to be used for tests only
     *
     * @return boolean indicating whether the scene is quiescent
     */
    boolean isQuiescent() {
        final Parent r = getRoot();
        return !isFocusDirty()
               &amp;&amp; (r == null || (r.cssFlag == CssFlags.CLEAN &amp;&amp;
                r.layoutFlag == LayoutFlags.CLEAN));
    }

    /**
     * A listener for pulses, used for testing. If non-null, this is called at
     * the very end of ScenePulseListener.pulse().
     *
     * Intended to be used for tests only
     */
    Runnable testPulseListener = null;

    /**
     * Set the specified dirty bit and mark the peer as dirty
     */
    private void markDirty(DirtyBits dirtyBit) {
        setDirty(dirtyBit);
        if (peer != null) {
            Toolkit.getToolkit().requestNextPulse();
        }
    }

    /**
     * Set the specified dirty bit
     */
    private void setDirty(DirtyBits dirtyBit) {
        dirtyBits |= dirtyBit.getMask();
    }

    /**
     * Test the specified dirty bit
     */
    private boolean isDirty(DirtyBits dirtyBit) {
        return ((dirtyBits &amp; dirtyBit.getMask()) != 0);
    }

    /**
     * Test whether the dirty bits are empty
     */
    private boolean isDirtyEmpty() {
        return dirtyBits == 0;
    }

    /**
     * Clear all dirty bits
     */
    private void clearDirty() {
        dirtyBits = 0;
    }

    private enum DirtyBits {
        FILL_DIRTY,
        ROOT_DIRTY,
        CAMERA_DIRTY,
        LIGHTS_DIRTY,
        CURSOR_DIRTY;

        private int mask;

        private DirtyBits() {
            mask = 1 &lt;&lt; ordinal();
        }

        public final int getMask() { return mask; }
    }

    private List&lt;LightBase&gt; lights = new ArrayList&lt;&gt;();

    // @param light must not be null
    final void addLight(LightBase light) {
        if (!lights.contains(light)) {
            lights.add(light);
            markDirty(DirtyBits.LIGHTS_DIRTY);
        }
    }

    final void removeLight(LightBase light) {
        if (lights.remove(light)) {
            markDirty(DirtyBits.LIGHTS_DIRTY);
        }
    }

    /**
     * PG Light synchronizer.
     */
    private void syncLights() {
        if (!isDirty(DirtyBits.LIGHTS_DIRTY)) {
            return;
        }
        inSynchronizer = true;
        NGLightBase peerLights[] = peer.getLights();
        if (!lights.isEmpty() || (peerLights != null)) {
            if (lights.isEmpty()) {
                peer.setLights(null);
            } else {
                if (peerLights == null || peerLights.length &lt; lights.size()) {
                    peerLights = new NGLightBase[lights.size()];
                }
                int i = 0;
                for (; i &lt; lights.size(); i++) {
                    peerLights[i] = lights.get(i).getPeer();
                }
                // Clear the rest of the list
                while (i &lt; peerLights.length &amp;&amp; peerLights[i] != null) {
                    peerLights[i++] = null;
                }
                peer.setLights(peerLights);
            }
        }
        inSynchronizer = false;
    }

    //INNER CLASSES

    /*******************************************************************************
     *                                                                             *
     * Scene Pulse Listener                                                        *
     *                                                                             *
     ******************************************************************************/

    class ScenePulseListener implements TKPulseListener {

        private boolean firstPulse = true;

        /**
         * PG synchronizer. Called once per frame from the pulse listener.
         * This function calls the synchronizePGNode method on each node in
         * the dirty list.
         */
        private void synchronizeSceneNodes() {
            Toolkit.getToolkit().checkFxUserThread();

            Scene.inSynchronizer = true;

            // if dirtyNodes is null then that means this Scene has not yet been
            // synchronized, and so we will simply synchronize every node in the
            // scene and then create the dirty nodes array list
            if (Scene.this.dirtyNodes == null) {
                // must do this recursively
                syncAll(getRoot());
                dirtyNodes = new Node[MIN_DIRTY_CAPACITY];

            } else {
                // This is not the first time this scene has been synchronized,
                // so we will only synchronize those nodes that need it
                for (int i = 0 ; i &lt; dirtyNodesSize; ++i) {
                    Node node = dirtyNodes[i];
                    dirtyNodes[i] = null;
                    if (node.getScene() == Scene.this) {
                            node.syncPeer();
                        }
                    }
                dirtyNodesSize = 0;
            }

            Scene.inSynchronizer = false;
        }

        /**
         * Recursive function for synchronizing every node in the scenegraph.
         * The return value is the number of nodes in the graph.
         */
        private int syncAll(Node node) {
            node.syncPeer();
            int size = 1;
            if (node instanceof Parent) {
                Parent p = (Parent) node;
                final int childrenCount = p.getChildren().size();

                for (int i = 0; i &lt; childrenCount; i++) {
                    Node n = p.getChildren().get(i);
                    if (n != null) {
                        size += syncAll(n);
                    }
                }
            } else if (node instanceof SubScene) {
                SubScene subScene = (SubScene)node;
                size += syncAll(subScene.getRoot());
            }
            if (node.getClip() != null) {
                size += syncAll(node.getClip());
            }

            return size;
        }

        private void synchronizeSceneProperties() {
            inSynchronizer = true;
            if (isDirty(DirtyBits.ROOT_DIRTY)) {
                peer.setRoot(getRoot().getPeer());
            }

            if (isDirty(DirtyBits.FILL_DIRTY)) {
                Toolkit tk = Toolkit.getToolkit();
                peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
            }

            // new camera was set on the scene or old camera changed
            final Camera cam = getEffectiveCamera();
            if (isDirty(DirtyBits.CAMERA_DIRTY)) {
                NodeHelper.updatePeer(cam);
                peer.setCamera((NGCamera) cam.getPeer());
            }

            if (isDirty(DirtyBits.CURSOR_DIRTY)) {
                mouseHandler.updateCursor(getCursor());
                mouseHandler.updateCursorFrame();
            }

            clearDirty();
            inSynchronizer = false;
        }

        /**
         * The focus is considered dirty if something happened to
         * the scene graph that may require the focus to be moved.
         * This must handle cases where (a) the focus owner may have
         * become ineligible to have the focus, and (b) where the focus
         * owner is null and a node may have become traversable and eligible.
         */
        private void focusCleanup() {
            if (Scene.this.isFocusDirty()) {
                final Node oldOwner = Scene.this.getFocusOwner();
                if (oldOwner == null) {
                    Scene.this.focusInitial();
                } else if (oldOwner.getScene() != Scene.this) {
                    Scene.this.requestFocus(null);
                    Scene.this.focusInitial();
                } else if (!oldOwner.isCanReceiveFocus()) {
                    Scene.this.requestFocus(null);
                    Scene.this.focusIneligible(oldOwner);
                }
                Scene.this.setFocusDirty(false);
            }
        }

        @Override
        public void pulse() {
            if (Scene.this.tracker != null) {
                Scene.this.tracker.pulse();
            }
            if (firstPulse) {
                PerformanceTracker.logEvent(&quot;Scene - first repaint&quot;);
            }

            focusCleanup();

            disposeAccessibles();

            // run any scene pre pulse listeners immediately _before_ css / layout,
            // and before scene synchronization
            if (preLayoutPulseListeners != null) {
                for (Runnable r : preLayoutPulseListeners) {
                    r.run();
                }
            }

            if (PULSE_LOGGING_ENABLED) {
                PulseLogger.newPhase(&quot;CSS Pass&quot;);
            }
            Scene.this.doCSSPass();

            if (PULSE_LOGGING_ENABLED) {
                PulseLogger.newPhase(&quot;Layout Pass&quot;);
            }
            Scene.this.doLayoutPass();

            // run any scene post pulse listeners immediately _after_ css / layout,
            // and before scene synchronization
            if (postLayoutPulseListeners != null) {
                for (Runnable r : postLayoutPulseListeners) {
                    r.run();
                }
            }

            boolean dirty = dirtyNodes == null || dirtyNodesSize != 0 || !isDirtyEmpty();
            if (dirty) {
                if (PULSE_LOGGING_ENABLED) {
                    PulseLogger.newPhase(&quot;Update bounds&quot;);
                }
                getRoot().updateBounds();
                if (peer != null) {
                    try {
                        if (PULSE_LOGGING_ENABLED) {
                            PulseLogger.newPhase(&quot;Waiting for previous rendering&quot;);
                        }
                        peer.waitForRenderingToComplete();
                        peer.waitForSynchronization();
                        // synchronize scene properties
                        if (PULSE_LOGGING_ENABLED) {
                            PulseLogger.newPhase(&quot;Copy state to render graph&quot;);
                        }
                        syncLights();
                        synchronizeSceneProperties();
                        // Run the synchronizer
                        synchronizeSceneNodes();
                        Scene.this.mouseHandler.pulse();
                        // Tell the scene peer that it needs to repaint
                        peer.markDirty();
                    } finally {
                        peer.releaseSynchronization(true);
                    }
                } else {
                    if (PULSE_LOGGING_ENABLED) {
                        PulseLogger.newPhase(&quot;Synchronize with null peer&quot;);
                    }
                    synchronizeSceneNodes();
                    Scene.this.mouseHandler.pulse();
                }

                if (Scene.this.getRoot().cssFlag != CssFlags.CLEAN) {
                    NodeHelper.markDirty(Scene.this.getRoot(),
                            com.sun.javafx.scene.DirtyBits.NODE_CSS);
                }
            }

            // required for image cursor created from animated image
            Scene.this.mouseHandler.updateCursorFrame();

            if (firstPulse) {
                if (PerformanceTracker.isLoggingEnabled()) {
                    PerformanceTracker.logEvent(&quot;Scene - first repaint - layout complete&quot;);
                    if (PrismSettings.perfLogFirstPaintFlush) {
                        PerformanceTracker.outputLog();
                    }
                    if (PrismSettings.perfLogFirstPaintExit) {
                        System.exit(0);
                    }
                }
                firstPulse = false;
            }

            if (testPulseListener != null) {
                testPulseListener.run();
            }
        }
    }

    /*******************************************************************************
     *                                                                             *
     * Scene Peer Listener                                                         *
     *                                                                             *
     ******************************************************************************/

    class ScenePeerListener implements TKSceneListener {
        @Override
        public void changedLocation(float x, float y) {
            if (x != Scene.this.getX()) {
                Scene.this.setX(x);
            }
            if (y != Scene.this.getY()) {
                Scene.this.setY(y);
            }
        }

        @Override
        public void changedSize(float w, float h) {
            if (w != Scene.this.getWidth()) Scene.this.setWidth(w);
            if (h != Scene.this.getHeight()) Scene.this.setHeight(h);
        }

        @Override
        public void mouseEvent(EventType&lt;MouseEvent&gt; type, double x, double y, double screenX, double screenY,
                               MouseButton button, boolean popupTrigger, boolean synthesized,
                               boolean shiftDown, boolean controlDown, boolean altDown, boolean metaDown,
                               boolean primaryDown, boolean middleDown, boolean secondaryDown)
        {
            MouseEvent mouseEvent = new MouseEvent(type, x, y, screenX, screenY, button,
                    0, // click count will be adjusted by clickGenerator later anyway
                    shiftDown, controlDown, altDown, metaDown,
                    primaryDown, middleDown, secondaryDown, synthesized, popupTrigger, false, null);
            processMouseEvent(mouseEvent);
        }


        @Override
        public void keyEvent(KeyEvent keyEvent)
        {
            processKeyEvent(keyEvent);
        }

        @Override
        public void inputMethodEvent(EventType&lt;InputMethodEvent&gt; type,
                                     ObservableList&lt;InputMethodTextRun&gt; composed, String committed,
                                     int caretPosition)
        {
            InputMethodEvent inputMethodEvent = new InputMethodEvent(
               type, composed, committed, caretPosition);
            processInputMethodEvent(inputMethodEvent);
        }

        public void menuEvent(double x, double y, double xAbs, double yAbs,
                boolean isKeyboardTrigger) {
            Scene.this.processMenuEvent(x, y, xAbs,yAbs, isKeyboardTrigger);
        }

        @Override
        public void scrollEvent(
                EventType&lt;ScrollEvent&gt; eventType,
                double scrollX, double scrollY,
                double totalScrollX, double totalScrollY,
                double xMultiplier, double yMultiplier,
                int touchCount,
                int scrollTextX, int scrollTextY,
                int defaultTextX, int defaultTextY,
                double x, double y, double screenX, double screenY,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown,
                boolean _direct, boolean _inertia) {

            ScrollEvent.HorizontalTextScrollUnits xUnits = scrollTextX &gt; 0 ?
                    ScrollEvent.HorizontalTextScrollUnits.CHARACTERS :
                    ScrollEvent.HorizontalTextScrollUnits.NONE;

            double xText = scrollTextX &lt; 0 ? 0 : scrollTextX * scrollX;

            ScrollEvent.VerticalTextScrollUnits yUnits = scrollTextY &gt; 0 ?
                    ScrollEvent.VerticalTextScrollUnits.LINES :
                    (scrollTextY &lt; 0 ?
                        ScrollEvent.VerticalTextScrollUnits.PAGES :
                        ScrollEvent.VerticalTextScrollUnits.NONE);

            double yText = scrollTextY &lt; 0 ? scrollY : scrollTextY * scrollY;

            xMultiplier = defaultTextX &gt; 0 &amp;&amp; scrollTextX &gt;= 0
                    ? Math.round(xMultiplier * scrollTextX / defaultTextX)
                    : xMultiplier;

            yMultiplier = defaultTextY &gt; 0 &amp;&amp; scrollTextY &gt;= 0
                    ? Math.round(yMultiplier * scrollTextY / defaultTextY)
                    : yMultiplier;

            if (eventType == ScrollEvent.SCROLL_FINISHED) {
                x = scrollGesture.sceneCoords.getX();
                y = scrollGesture.sceneCoords.getY();
                screenX = scrollGesture.screenCoords.getX();
                screenY = scrollGesture.screenCoords.getY();
            } else if (Double.isNaN(x) || Double.isNaN(y) ||
                    Double.isNaN(screenX) || Double.isNaN(screenY)) {
                if (cursorScenePos == null || cursorScreenPos == null) {
                    return;
                }
                x = cursorScenePos.getX();
                y = cursorScenePos.getY();
                screenX = cursorScreenPos.getX();
                screenY = cursorScreenPos.getY();
            }

            inMousePick = true;
            Scene.this.processGestureEvent(new ScrollEvent(
                    eventType,
                    x, y, screenX, screenY,
                    _shiftDown, _controlDown, _altDown, _metaDown,
                    _direct, _inertia,
                    scrollX * xMultiplier, scrollY * yMultiplier,
                    totalScrollX * xMultiplier, totalScrollY * yMultiplier,
                    xMultiplier, yMultiplier,
                    xUnits, xText, yUnits, yText, touchCount, pick(x, y)),
                    scrollGesture);
            inMousePick = false;
        }

        @Override
        public void zoomEvent(
                EventType&lt;ZoomEvent&gt; eventType,
                double zoomFactor, double totalZoomFactor,
                double x, double y, double screenX, double screenY,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown,
                boolean _direct, boolean _inertia) {

            if (eventType == ZoomEvent.ZOOM_FINISHED) {
                x = zoomGesture.sceneCoords.getX();
                y = zoomGesture.sceneCoords.getY();
                screenX = zoomGesture.screenCoords.getX();
                screenY = zoomGesture.screenCoords.getY();
            } else if (Double.isNaN(x) || Double.isNaN(y) ||
                    Double.isNaN(screenX) || Double.isNaN(screenY)) {
                if (cursorScenePos == null || cursorScreenPos == null) {
                    return;
                }
                x = cursorScenePos.getX();
                y = cursorScenePos.getY();
                screenX = cursorScreenPos.getX();
                screenY = cursorScreenPos.getY();
            }

            inMousePick = true;
            Scene.this.processGestureEvent(new ZoomEvent(eventType,
                    x, y, screenX, screenY,
                    _shiftDown, _controlDown, _altDown, _metaDown,
                    _direct, _inertia,
                    zoomFactor, totalZoomFactor, pick(x, y)),
                    zoomGesture);
            inMousePick = false;
        }

        @Override
        public void rotateEvent(
                EventType&lt;RotateEvent&gt; eventType, double angle, double totalAngle,
                double x, double y, double screenX, double screenY,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown,
                boolean _direct, boolean _inertia) {

            if (eventType == RotateEvent.ROTATION_FINISHED) {
                x = rotateGesture.sceneCoords.getX();
                y = rotateGesture.sceneCoords.getY();
                screenX = rotateGesture.screenCoords.getX();
                screenY = rotateGesture.screenCoords.getY();
            } else if (Double.isNaN(x) || Double.isNaN(y) ||
                    Double.isNaN(screenX) || Double.isNaN(screenY)) {
                if (cursorScenePos == null || cursorScreenPos == null) {
                    return;
                }
                x = cursorScenePos.getX();
                y = cursorScenePos.getY();
                screenX = cursorScreenPos.getX();
                screenY = cursorScreenPos.getY();
            }

            inMousePick = true;
            Scene.this.processGestureEvent(new RotateEvent(
                    eventType, x, y, screenX, screenY,
                    _shiftDown, _controlDown, _altDown, _metaDown,
                    _direct, _inertia, angle, totalAngle, pick(x, y)),
                    rotateGesture);
            inMousePick = false;

        }

        @Override
        public void swipeEvent(
                EventType&lt;SwipeEvent&gt; eventType, int touchCount,
                double x, double y, double screenX, double screenY,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown, boolean _direct) {

            if (Double.isNaN(x) || Double.isNaN(y) ||
                    Double.isNaN(screenX) || Double.isNaN(screenY)) {
                if (cursorScenePos == null || cursorScreenPos == null) {
                    return;
                }
                x = cursorScenePos.getX();
                y = cursorScenePos.getY();
                screenX = cursorScreenPos.getX();
                screenY = cursorScreenPos.getY();
            }

            inMousePick = true;
            Scene.this.processGestureEvent(new SwipeEvent(
                    eventType, x, y, screenX, screenY,
                    _shiftDown, _controlDown, _altDown, _metaDown, _direct,
                    touchCount, pick(x, y)),
                    swipeGesture);
            inMousePick = false;
        }

        @Override
        public void touchEventBegin(
                long time, int touchCount, boolean isDirect,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown) {

            if (!isDirect) {
                nextTouchEvent = null;
                return;
            }
            nextTouchEvent = new TouchEvent(
                    TouchEvent.ANY, null, null, 0,
                    _shiftDown, _controlDown, _altDown, _metaDown);
            if (touchPoints == null || touchPoints.length != touchCount) {
                touchPoints = new TouchPoint[touchCount];
            }
            touchPointIndex = 0;
        }

        @Override
        public void touchEventNext(
                TouchPoint.State state, long touchId,
                double x, double y, double screenX, double screenY) {

            inMousePick = true;
            if (nextTouchEvent == null) {
                // ignore indirect touch events
                return;
            }
            touchPointIndex++;
            int id = (state == TouchPoint.State.PRESSED
                    ? touchMap.add(touchId) :  touchMap.get(touchId));
            if (state == TouchPoint.State.RELEASED) {
                touchMap.remove(touchId);
            }
            int order = touchMap.getOrder(id);

            if (order &gt;= touchPoints.length) {
                throw new RuntimeException(&quot;Too many touch points reported&quot;);
            }

            // pick target
            boolean isGrabbed = false;
            PickResult pickRes = pick(x, y);
            EventTarget pickedTarget = touchTargets.get(id);
            if (pickedTarget == null) {
                pickedTarget = pickRes.getIntersectedNode();
                if (pickedTarget == null) {
                    pickedTarget = Scene.this;
                }
            } else {
                isGrabbed = true;
            }

            TouchPoint tp = new TouchPoint(id, state,
                    x, y, screenX, screenY, pickedTarget, pickRes);

            touchPoints[order] = tp;

            if (isGrabbed) {
                tp.grab(pickedTarget);
            }
            if (tp.getState() == TouchPoint.State.PRESSED) {
                tp.grab(pickedTarget);
                touchTargets.put(tp.getId(), pickedTarget);
            } else if (tp.getState() == TouchPoint.State.RELEASED) {
                touchTargets.remove(tp.getId());
            }
            inMousePick = false;
        }

        @Override
        public void touchEventEnd() {
            if (nextTouchEvent == null) {
                // ignore indirect touch events
                return;
            }

            if (touchPointIndex != touchPoints.length) {
                throw new RuntimeException(&quot;Wrong number of touch points reported&quot;);
            }

            Scene.this.processTouchEvent(nextTouchEvent, touchPoints);

            if (touchMap.cleanup()) {
                // gesture finished
                touchEventSetId = 0;
            }
        }

        @Override
        public Accessible getSceneAccessible() {
            return getAccessible();
        }
    }

    private class ScenePeerPaintListener implements TKScenePaintListener {
        @Override
        public void frameRendered() {
            // must use tracker with synchronization since this method is called on render thread
            synchronized (trackerMonitor) {
                if (Scene.this.tracker != null) {
                    Scene.this.tracker.frameRendered();
                }
            }
        }
    }

    /*******************************************************************************
     *                                                                             *
     * Drag and Drop                                                               *
     *                                                                             *
     ******************************************************************************/

    class DropTargetListener implements TKDropTargetListener {

        /*
         * This function is called when an drag operation enters a valid drop target.
         * This may be from either an internal or external dnd operation.
         */
        @Override
        public TransferMode dragEnter(double x, double y, double screenX, double screenY,
                                      TransferMode transferMode, TKClipboard dragboard)
        {
            if (dndGesture == null) {
                dndGesture = new DnDGesture();
            }
            Dragboard db = DragboardHelper.createDragboard(dragboard);
            dndGesture.dragboard = db;
            DragEvent dragEvent =
                    new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                            transferMode, null, null, pick(x, y));
            return dndGesture.processTargetEnterOver(dragEvent);
        }

        @Override
        public TransferMode dragOver(double x, double y, double screenX, double screenY,
                                     TransferMode transferMode)
        {
            if (Scene.this.dndGesture == null) {
                System.err.println(&quot;GOT A dragOver when dndGesture is null!&quot;);
                return null;
            } else {
                if (dndGesture.dragboard == null) {
                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragOver&quot;);
                }
                DragEvent dragEvent =
                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                                transferMode, null, null, pick(x, y));
                return dndGesture.processTargetEnterOver(dragEvent);
            }
        }

        @Override
        public void dragExit(double x, double y, double screenX, double screenY) {
            if (dndGesture == null) {
                System.err.println(&quot;GOT A dragExit when dndGesture is null!&quot;);
            } else {
                if (dndGesture.dragboard == null) {
                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragExit&quot;);
                }
                DragEvent dragEvent =
                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                                null, null, null, pick(x, y));
                dndGesture.processTargetExit(dragEvent);
                if (dndGesture.source == null) {
                    dndGesture.dragboard = null;
                    dndGesture = null;
                }
            }
        }


        @Override
        public TransferMode drop(double x, double y, double screenX, double screenY,
                                  TransferMode transferMode)
        {
            if (dndGesture == null) {
                System.err.println(&quot;GOT A drop when dndGesture is null!&quot;);
                return null;
            } else {
                if (dndGesture.dragboard == null) {
                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDrop&quot;);
                }
                DragEvent dragEvent =
                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                                transferMode, null, null, pick(x, y));
                // Data dropped to the app can be accessed without restriction
                DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);

                TransferMode tm;
                try {
                    tm = dndGesture.processTargetDrop(dragEvent);
                } finally {
                    DragboardHelper.setDataAccessRestriction(
                            dndGesture.dragboard, true);
                }

                if (dndGesture.source == null) {
                    dndGesture.dragboard = null;
                    dndGesture = null;
                }
                return tm;
            }
        }
    }

    class DragGestureListener implements TKDragGestureListener {

       @Override
       public void dragGestureRecognized(double x, double y, double screenX, double screenY,
                                         int button, TKClipboard dragboard)
       {
           Dragboard db = DragboardHelper.createDragboard(dragboard);
           dndGesture = new DnDGesture();
           dndGesture.dragboard = db;
           // TODO: support mouse buttons in DragEvent
           DragEvent dragEvent = new DragEvent(DragEvent.ANY, db, x, y, screenX, screenY,
                   null, null, null, pick(x, y));
           dndGesture.processRecognized(dragEvent);
           dndGesture = null;
        }
    }

    /**
     * A Drag and Drop gesture has a lifespan that lasts from mouse
     * PRESSED event to mouse RELEASED event.
     */
    class DnDGesture {
        private final double hysteresisSizeX =
                Toolkit.getToolkit().getMultiClickMaxX();
        private final double hysteresisSizeY =
                Toolkit.getToolkit().getMultiClickMaxY();

        private EventTarget source = null;
        private Set&lt;TransferMode&gt; sourceTransferModes = null;
        private TransferMode acceptedTransferMode = null;
        private Dragboard dragboard = null;
        private EventTarget potentialTarget = null;
        private EventTarget target = null;
        private DragDetectedState dragDetected = DragDetectedState.NOT_YET;
        private double pressedX;
        private double pressedY;
        private List&lt;EventTarget&gt; currentTargets = new ArrayList&lt;EventTarget&gt;();
        private List&lt;EventTarget&gt; newTargets = new ArrayList&lt;EventTarget&gt;();
        private EventTarget fullPDRSource = null;

        /**
         * Fires event on a given target or on scene if the node is null
         */
        private void fireEvent(EventTarget target, Event e) {
            if (target != null) {
                Event.fireEvent(target, e);
            }
        }

        /**
         * Called when DRAG_DETECTED event is going to be processed by
         * application
         */
        private void processingDragDetected() {
            dragDetected = DragDetectedState.PROCESSING;
        }

        /**
         * Called after DRAG_DETECTED event has been processed by application
         */
        private void dragDetectedProcessed() {
            dragDetected = DragDetectedState.DONE;
            final boolean hasContent = (dragboard != null) &amp;&amp; (ClipboardHelper.contentPut(dragboard));
            if (hasContent) {
                /* start DnD */
                Toolkit.getToolkit().startDrag(Scene.this.peer,
                                                sourceTransferModes,
                                                new DragSourceListener(),
                                                dragboard);
            } else if (fullPDRSource != null) {
                /* start PDR */
                Scene.this.mouseHandler.enterFullPDR(fullPDRSource);
            }

            fullPDRSource = null;
        }

        /**
         * Sets the default dragDetect value
         */
        private void processDragDetection(MouseEvent mouseEvent) {

            if (dragDetected != DragDetectedState.NOT_YET) {
                mouseEvent.setDragDetect(false);
                return;
            }

            if (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED) {
                pressedX = mouseEvent.getSceneX();
                pressedY = mouseEvent.getSceneY();

                mouseEvent.setDragDetect(false);

            } else if (mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) {

                double deltaX = Math.abs(mouseEvent.getSceneX() - pressedX);
                double deltaY = Math.abs(mouseEvent.getSceneY() - pressedY);
                mouseEvent.setDragDetect(deltaX &gt; hysteresisSizeX ||
                                         deltaY &gt; hysteresisSizeY);

            }
        }

        /**
         * This function is useful for drag gesture recognition from
         * within this Scene (as opposed to in the TK implementation... by the platform)
         */
        private boolean process(MouseEvent mouseEvent, EventTarget target) {
            boolean continueProcessing = true;
            if (!PLATFORM_DRAG_GESTURE_INITIATION) {

                if (dragDetected != DragDetectedState.DONE &amp;&amp;
                        (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED ||
                        mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) &amp;&amp;
                        mouseEvent.isDragDetect()) {

                    processingDragDetected();

                    if (target != null) {
                        final MouseEvent detectedEvent = mouseEvent.copyFor(
                                mouseEvent.getSource(), target,
                                MouseEvent.DRAG_DETECTED);

                        try {
                            fireEvent(target, detectedEvent);
                        } finally {
                            // Putting data to dragboard finished, restrict access to them
                            if (dragboard != null) {
                                DragboardHelper.setDataAccessRestriction(
                                        dragboard, true);
                            }
                        }
                    }

                    dragDetectedProcessed();
                }

                if (mouseEvent.getEventType() == MouseEvent.MOUSE_RELEASED) {
                    continueProcessing = false;
                }
            }
            return continueProcessing;
        }

        /*
         * Called when a drag source is recognized. This occurs at the very start of
         * the publicly visible drag and drop API, as it is responsible for calling
         * the Node.onDragSourceRecognized function.
         */
        private boolean processRecognized(DragEvent de) {
            MouseEvent me = new MouseEvent(
                    MouseEvent.DRAG_DETECTED, de.getX(), de.getY(),
                    de.getSceneX(), de.getScreenY(), MouseButton.PRIMARY, 1,
                    false, false, false, false, false, true, false, false, false,
                    false, de.getPickResult());

            processingDragDetected();

            final EventTarget target = de.getPickResult().getIntersectedNode();
            try {
                fireEvent(target != null ? target : Scene.this, me);
            } finally {
                // Putting data to dragboard finished, restrict access to them
                if (dragboard != null) {
                    DragboardHelper.setDataAccessRestriction(
                            dragboard, true);
                }
            }

            dragDetectedProcessed();

            final boolean hasContent = dragboard != null
                    &amp;&amp; !dragboard.getContentTypes().isEmpty();
            return hasContent;
        }

        private void processDropEnd(DragEvent de) {
            if (source == null) {
                System.out.println(&quot;Scene.DnDGesture.processDropEnd() - UNEXPECTD - source is NULL&quot;);
                return;
            }

            de = new DragEvent(de.getSource(), source, DragEvent.DRAG_DONE,
                    de.getDragboard(), de.getSceneX(), de.getSceneY(),
                    de.getScreenX(), de.getScreenY(),
                    de.getTransferMode(), source, target, de.getPickResult());

            Event.fireEvent(source, de);

            tmpTargetWrapper.clear();
            handleExitEnter(de, tmpTargetWrapper);

            // at this point the drag and drop operation is completely over, so we
            // can tell the toolkit that it can clean up if needs be.
            Toolkit.getToolkit().stopDrag(dragboard);
        }

        private TransferMode processTargetEnterOver(DragEvent de) {
            pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
            final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();

            if (dragboard == null) {
<A NAME="27"></A>                dragboard = createDragboard(de, false);
            }

            <FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#27',2,'match52-top.html#27',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>de = new DragEvent(de.getSource(), pickedTarget, de.getEventType(),
                    dragboard, de.getSceneX(), de.getSceneY(),
                    de.getScreenX(), de.getScreenY(),
                    de.getTransferMode(), source, potentialTarget, de.getPickResult());

            handleExitEnter(de, tmpTargetWrapper);

            de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_OVER,
                    de.getDragboard(), de.getSceneX</B></FONT>(), de.getSceneY(),
                    de.getScreenX(), de.getScreenY(),
                    de.getTransferMode(), source, potentialTarget, de.getPickResult());

            fireEvent(pickedTarget, de);

            Object acceptingObject = de.getAcceptingObject();
            potentialTarget = acceptingObject instanceof EventTarget
                    ? (EventTarget) acceptingObject : null;
            acceptedTransferMode = de.getAcceptedTransferMode();
            return acceptedTransferMode;
        }

        private void processTargetActionChanged(DragEvent de) {
            // Do we want DRAG_TRANSFER_MODE_CHANGED event?
//            final Node pickedNode = Scene.this.mouseHandler.pickNode(de.getX(), de.getY());
//            if (pickedNode != null &amp;&amp; pickedNode.isTreeVisible()) {
//                de = DragEvent.copy(de.getSource(), pickedNode, source,
//                        pickedNode, de, DragEvent.DRAG_TRANSFER_MODE_CHANGED);
//
//                if (dragboard == null) {
//                    dragboard = createDragboard(de);
//                }
//                dragboard = de.getPlatformDragboard();
//
//                fireEvent(pickedNode, de);
//            }
        }

        private void processTargetExit(DragEvent de) {
            if (dragboard == null) {
                // dragboard should have been created in processTargetEnterOver()
                throw new NullPointerException(&quot;dragboard is null in processTargetExit()&quot;);
            }

            if (currentTargets.size() &gt; 0) {
                potentialTarget = null;
                tmpTargetWrapper.clear();
                handleExitEnter(de, tmpTargetWrapper);
            }
        }

        private TransferMode processTargetDrop(DragEvent de) {
            pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
            final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();

            de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_DROPPED,
                    de.getDragboard(), de.getSceneX(), de.getSceneY(),
                    de.getScreenX(), de.getScreenY(),
                    acceptedTransferMode, source, potentialTarget, de.getPickResult());

            if (dragboard == null) {
                // dragboard should have been created in processTargetEnterOver()
                throw new NullPointerException(&quot;dragboard is null in processTargetDrop()&quot;);
            }

            handleExitEnter(de, tmpTargetWrapper);

            fireEvent(pickedTarget, de);

            Object acceptingObject = de.getAcceptingObject();
            potentialTarget = acceptingObject instanceof EventTarget
                    ? (EventTarget) acceptingObject : null;
            target = potentialTarget;

            TransferMode result = de.isDropCompleted() ?
                de.getAcceptedTransferMode() : null;

            tmpTargetWrapper.clear();
            handleExitEnter(de, tmpTargetWrapper);

            return result;
        }

        private void handleExitEnter(DragEvent e, TargetWrapper target) {
            EventTarget currentTarget =
                    currentTargets.size() &gt; 0 ? currentTargets.get(0) : null;

            if (target.getEventTarget() != currentTarget) {

                target.fillHierarchy(newTargets);

                int i = currentTargets.size() - 1;
                int j = newTargets.size() - 1;

                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentTargets.get(i) == newTargets.get(j)) {
                    i--;
                    j--;
                }

                for (; i &gt;= 0; i--) {
                    EventTarget t = currentTargets.get(i);
                    if (potentialTarget == t) {
                        potentialTarget = null;
                    }
                    e = e.copyFor(e.getSource(), t, source,
                            potentialTarget, DragEvent.DRAG_EXITED_TARGET);
                    Event.fireEvent(t, e);
                }

                potentialTarget = null;
                for (; j &gt;= 0; j--) {
                    EventTarget t = newTargets.get(j);
                    e = e.copyFor(e.getSource(), t, source,
                            potentialTarget, DragEvent.DRAG_ENTERED_TARGET);
                    Object acceptingObject = e.getAcceptingObject();
                    if (acceptingObject instanceof EventTarget) {
                        potentialTarget = (EventTarget) acceptingObject;
                    }
                    Event.fireEvent(t, e);
                }

                currentTargets.clear();
                currentTargets.addAll(newTargets);
                newTargets.clear();
            }
        }

//        function getIntendedTransferMode(e:MouseEvent):TransferMode {
//            return if (e.altDown) TransferMode.COPY else TransferMode.MOVE;
//        }

        /*
         * Function that hooks into the key processing code in Scene to handle the
         * situation where a drag and drop event is taking place and the user presses
         * the escape key to cancel the drag and drop operation.
         */
        private boolean processKey(KeyEvent e) {
            //note: this seems not to be called, the DnD cancelation is provided by platform
            if ((e.getEventType() == KeyEvent.KEY_PRESSED) &amp;&amp; (e.getCode() == KeyCode.ESCAPE)) {

                // cancel drag and drop
                DragEvent de = new DragEvent(
                        source, source, DragEvent.DRAG_DONE, dragboard, 0, 0, 0, 0,
                        null, source, null, null);
                if (source != null) {
                    Event.fireEvent(source, de);
                }

                tmpTargetWrapper.clear();
                handleExitEnter(de, tmpTargetWrapper);

                return false;
            }
            return true;
        }

        /*
         * This starts the drag gesture running, creating the dragboard used for
         * the remainder of this drag and drop operation.
         */
        private Dragboard startDrag(EventTarget source, Set&lt;TransferMode&gt; t) {
            if (dragDetected != DragDetectedState.PROCESSING) {
                throw new IllegalStateException(&quot;Cannot start drag and drop &quot;
                        + &quot;outside of DRAG_DETECTED event handler&quot;);
            }

            if (t.isEmpty()) {
                dragboard = null;
            } else if (dragboard == null) {
                dragboard = createDragboard(null, true);
            }

            // The app can see what it puts to dragboard without restriction
            DragboardHelper.setDataAccessRestriction(dragboard, false);

            this.source = source;
            potentialTarget = source;
            sourceTransferModes = t;
            return dragboard;
        }

        /*
         * This starts the full PDR gesture.
         */
        private void startFullPDR(EventTarget source) {
            fullPDRSource = source;
        }

        private Dragboard createDragboard(final DragEvent de, boolean isDragSource) {
            Dragboard dragboard = null;
            if (de != null) {
                dragboard = de.getDragboard();
                if (dragboard != null) {
                    return dragboard;
                }
            }
            TKClipboard dragboardPeer = peer.createDragboard(isDragSource);
            return DragboardHelper.createDragboard(dragboardPeer);
        }
    }

    /**
     * State of a drag gesture with regards to DRAG_DETECTED event.
     */
    private enum DragDetectedState {
        NOT_YET,
        PROCESSING,
        DONE
    }

    class DragSourceListener implements TKDragSourceListener {

        @Override
        public void dragDropEnd(double x, double y, double screenX, double screenY,
                                TransferMode transferMode)
        {
            if (dndGesture != null) {
                if (dndGesture.dragboard == null) {
                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDropEnd&quot;);
                }
                DragEvent dragEvent =
                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                        transferMode, null, null, null);

                // DRAG_DONE event is delivered to gesture source, it can access
                // its own data without restriction
                DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);
                try {
                    dndGesture.processDropEnd(dragEvent);
                } finally {
                    DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, true);
                }
                dndGesture = null;
            }
        }
    }

    /*******************************************************************************
     *                                                                             *
     * Mouse Event Handling                                                        *
     *                                                                             *
     ******************************************************************************/

    static class ClickCounter {
        Toolkit toolkit = Toolkit.getToolkit();
        private int count;
        private boolean out;
        private boolean still;
        private Timeline timeout;
        private double pressedX, pressedY;

        private void inc() { count++; }
        private int get() { return count; }
        private boolean isStill() { return still; }

        private void clear() {
            count = 0;
            stopTimeout();
        }

        private void out() {
            out = true;
            stopTimeout();
        }

        private void applyOut() {
            if (out) clear();
            out = false;
        }

        private void moved(double x, double y) {
            if (Math.abs(x - pressedX) &gt; toolkit.getMultiClickMaxX() ||
                    Math.abs(y - pressedY) &gt; toolkit.getMultiClickMaxY()) {
                out();
                still = false;
            }
        }

        private void start(double x, double y) {
            pressedX = x;
            pressedY = y;
            out = false;

            if (timeout != null) {
                timeout.stop();
            }
            timeout = new Timeline();
            timeout.getKeyFrames().add(
                    new KeyFrame(new Duration(toolkit.getMultiClickTime()),
                            event -&gt; {
                                out = true;
                                timeout = null;
                            }
                    ));
            timeout.play();
            still = true;
        }

        private void stopTimeout() {
            if (timeout != null) {
                timeout.stop();
                timeout = null;
            }
        }
    }

    static class ClickGenerator {
        private ClickCounter lastPress = null;

        private Map&lt;MouseButton, ClickCounter&gt; counters =
                new EnumMap&lt;MouseButton, ClickCounter&gt;(MouseButton.class);
        private List&lt;EventTarget&gt; pressedTargets = new ArrayList&lt;EventTarget&gt;();
        private List&lt;EventTarget&gt; releasedTargets = new ArrayList&lt;EventTarget&gt;();

        public ClickGenerator() {
            for (MouseButton mb : MouseButton.values()) {
                if (mb != MouseButton.NONE) {
                    counters.put(mb, new ClickCounter());
                }
            }
        }

        private MouseEvent preProcess(MouseEvent e) {
            for (ClickCounter cc : counters.values()) {
                cc.moved(e.getSceneX(), e.getSceneY());
            }

            ClickCounter cc = counters.get(e.getButton());
            boolean still = lastPress != null ? lastPress.isStill() : false;

            if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {

                if (! e.isPrimaryButtonDown()) { counters.get(MouseButton.PRIMARY).clear(); }
                if (! e.isSecondaryButtonDown()) { counters.get(MouseButton.SECONDARY).clear(); }
                if (! e.isMiddleButtonDown()) { counters.get(MouseButton.MIDDLE).clear(); }

                cc.applyOut();
                cc.inc();
                cc.start(e.getSceneX(), e.getSceneY());
                lastPress = cc;
            }

            return new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
                    e.getScreenX(), e.getScreenY(), e.getButton(),
                    cc != null &amp;&amp; e.getEventType() != MouseEvent.MOUSE_MOVED ? cc.get() : 0,
                    e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
                    e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
                    e.isSynthesized(), e.isPopupTrigger(), still, e.getPickResult());
        }

        private void postProcess(MouseEvent e, TargetWrapper target, TargetWrapper pickedTarget) {

            if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
                ClickCounter cc = counters.get(e.getButton());

                target.fillHierarchy(pressedTargets);
                pickedTarget.fillHierarchy(releasedTargets);
                int i = pressedTargets.size() - 1;
                int j = releasedTargets.size() - 1;

                EventTarget clickedTarget = null;
                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; pressedTargets.get(i) == releasedTargets.get(j)) {
                    clickedTarget = pressedTargets.get(i);
                    i--;
                    j--;
                }

                pressedTargets.clear();
                releasedTargets.clear();

                if (clickedTarget != null &amp;&amp; lastPress != null) {
                    MouseEvent click = new MouseEvent(null, clickedTarget,
                            MouseEvent.MOUSE_CLICKED, e.getSceneX(), e.getSceneY(),
                            e.getScreenX(), e.getScreenY(), e.getButton(),
                            cc.get(),
                            e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
                            e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
                            e.isSynthesized(), e.isPopupTrigger(), lastPress.isStill(), e.getPickResult());
                    Event.fireEvent(clickedTarget, click);
                }
            }
        }
    }

    /**
     * Generates mouse exited event for a node which is going to be removed
     * and its children, where appropriate.
     * @param removing Node which is going to be removed
     */
    void generateMouseExited(Node removing) {
        mouseHandler.handleNodeRemoval(removing);
    }

    class MouseHandler {
        private TargetWrapper pdrEventTarget = new TargetWrapper(); // pdr - press-drag-release
        private boolean pdrInProgress = false;
        private boolean fullPDREntered = false;

        private EventTarget currentEventTarget = null;
        private MouseEvent lastEvent;
        private boolean hover = false;

        private boolean primaryButtonDown = false;
        private boolean secondaryButtonDown = false;
        private boolean middleButtonDown = false;

        private EventTarget fullPDRSource = null;
        private TargetWrapper fullPDRTmpTargetWrapper = new TargetWrapper();

        /* lists needed for enter/exit events generation */
        private final List&lt;EventTarget&gt; pdrEventTargets = new ArrayList&lt;EventTarget&gt;();
        private final List&lt;EventTarget&gt; currentEventTargets = new ArrayList&lt;EventTarget&gt;();
        private final List&lt;EventTarget&gt; newEventTargets = new ArrayList&lt;EventTarget&gt;();

        private final List&lt;EventTarget&gt; fullPDRCurrentEventTargets = new ArrayList&lt;EventTarget&gt;();
        private final List&lt;EventTarget&gt; fullPDRNewEventTargets = new ArrayList&lt;EventTarget&gt;();
        private EventTarget fullPDRCurrentTarget = null;

        private Cursor currCursor;
        private CursorFrame currCursorFrame;
        private EventQueue queue = new EventQueue();

        private Runnable pickProcess = new Runnable() {

            @Override
            public void run() {
                // Make sure this is run only if the peer is still alive
                // and there is an event to deliver
                if (Scene.this.peer != null &amp;&amp; lastEvent != null) {
                    process(lastEvent, true);
                }
            }
        };

        private void pulse() {
            if (hover &amp;&amp; lastEvent != null) {
                //Shouldn't run user code directly. User can call stage.showAndWait() and block the pulse.
                Platform.runLater(pickProcess);
            }
        }

        private void clearPDREventTargets() {
            pdrInProgress = false;
            currentEventTarget = currentEventTargets.size() &gt; 0
                    ? currentEventTargets.get(0) : null;
            pdrEventTarget.clear();
        }

        public void enterFullPDR(EventTarget gestureSource) {
            fullPDREntered = true;
            fullPDRSource = gestureSource;
            fullPDRCurrentTarget = null;
            fullPDRCurrentEventTargets.clear();
        }

        public void exitFullPDR(MouseEvent e) {
            if (!fullPDREntered) {
                return;
            }
            fullPDREntered = false;
            for (int i = fullPDRCurrentEventTargets.size() - 1; i &gt;= 0; i--) {
                EventTarget entered = fullPDRCurrentEventTargets.get(i);
                Event.fireEvent(entered, MouseEvent.copyForMouseDragEvent(e,
                        entered, entered,
                        MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
                        fullPDRSource, e.getPickResult()));
            }
            fullPDRSource = null;
            fullPDRCurrentEventTargets.clear();
            fullPDRCurrentTarget = null;
        }

        private void handleNodeRemoval(Node removing) {
            if (lastEvent == null) {
                // this can happen only if everything has been exited anyway
                return;
            }


            if (currentEventTargets.contains(removing)) {
                int i = 0;
                EventTarget trg = null;
                while(trg != removing) {
                    trg = currentEventTargets.get(i++);

                    queue.postEvent(lastEvent.copyFor(trg, trg,
                            MouseEvent.MOUSE_EXITED_TARGET));
                }
                currentEventTargets.subList(0, i).clear();
            }

            if (fullPDREntered &amp;&amp; fullPDRCurrentEventTargets.contains(removing)) {
                int i = 0;
                EventTarget trg = null;
                while (trg != removing) {
                    trg = fullPDRCurrentEventTargets.get(i++);

                    queue.postEvent(
                            MouseEvent.copyForMouseDragEvent(lastEvent, trg, trg,
                            MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
                            fullPDRSource, lastEvent.getPickResult()));
                }

                fullPDRCurrentEventTargets.subList(0, i).clear();
            }

            queue.fire();

            if (pdrInProgress &amp;&amp; pdrEventTargets.contains(removing)) {
                int i = 0;
                EventTarget trg = null;
                while (trg != removing) {
                    trg = pdrEventTargets.get(i++);

                    // trg.setHover(false) - already taken care of
                    // by the code above which sent a mouse exited event
                    ((Node) trg).setPressed(false);
                }
                pdrEventTargets.subList(0, i).clear();

                trg = pdrEventTargets.get(0);
                final PickResult res = pdrEventTarget.getResult();
                if (trg instanceof Node) {
                    pdrEventTarget.setNodeResult(new PickResult((Node) trg,
                            res.getIntersectedPoint(), res.getIntersectedDistance()));
                } else {
                    pdrEventTarget.setSceneResult(new PickResult(null,
                            res.getIntersectedPoint(), res.getIntersectedDistance()),
                            (Scene) trg);
                }
            }
        }

        private void handleEnterExit(MouseEvent e, TargetWrapper pickedTarget) {
            if (pickedTarget.getEventTarget() != currentEventTarget ||
                    e.getEventType() == MouseEvent.MOUSE_EXITED) {

                if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
                    newEventTargets.clear();
                } else {
                    pickedTarget.fillHierarchy(newEventTargets);
                }

                int newTargetsSize = newEventTargets.size();
                int i = currentEventTargets.size() - 1;
                int j = newTargetsSize - 1;
                int k = pdrEventTargets.size() - 1;

                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentEventTargets.get(i) == newEventTargets.get(j)) {
                    i--;
                    j--;
                    k--;
                }

                final int memk = k;
                for (; i &gt;= 0; i--, k--) {
                    final EventTarget exitedEventTarget = currentEventTargets.get(i);
                    if (pdrInProgress &amp;&amp;
                            (k &lt; 0 || exitedEventTarget != pdrEventTargets.get(k))) {
                         break;
                    }
                    queue.postEvent(e.copyFor(
                            exitedEventTarget, exitedEventTarget,
                            MouseEvent.MOUSE_EXITED_TARGET));
                }

                k = memk;
                for (; j &gt;= 0; j--, k--) {
                    final EventTarget enteredEventTarget = newEventTargets.get(j);
                    if (pdrInProgress &amp;&amp;
                            (k &lt; 0 || enteredEventTarget != pdrEventTargets.get(k))) {
                        break;
                    }
                    queue.postEvent(e.copyFor(
                            enteredEventTarget, enteredEventTarget,
                            MouseEvent.MOUSE_ENTERED_TARGET));
                }

                currentEventTarget = pickedTarget.getEventTarget();
                currentEventTargets.clear();
                for (j++; j &lt; newTargetsSize; j++) {
                    currentEventTargets.add(newEventTargets.get(j));
                }
            }
            queue.fire();
        }

        private void process(MouseEvent e, boolean onPulse) {
            Toolkit.getToolkit().checkFxUserThread();
            Scene.inMousePick = true;

            cursorScreenPos = new Point2D(e.getScreenX(), e.getScreenY());
            cursorScenePos = new Point2D(e.getSceneX(), e.getSceneY());

            boolean gestureStarted = false;
            if (!onPulse) {
                if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {
                    if (!(primaryButtonDown || secondaryButtonDown || middleButtonDown)) {
                        //old gesture ended and new one started
                        gestureStarted = true;
                        if (!PLATFORM_DRAG_GESTURE_INITIATION) {
                            Scene.this.dndGesture = new DnDGesture();
                        }
                        clearPDREventTargets();
                    }
                } else if (e.getEventType() == MouseEvent.MOUSE_MOVED) {
                    // gesture ended
                    clearPDREventTargets();
                } else if (e.getEventType() == MouseEvent.MOUSE_ENTERED) {
                    hover = true;
                } else if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
                    hover = false;
                }

                primaryButtonDown = e.isPrimaryButtonDown();
                secondaryButtonDown = e.isSecondaryButtonDown();
                middleButtonDown = e.isMiddleButtonDown();
            }

            pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
            PickResult res = tmpTargetWrapper.getResult();
            if (res != null) {
                e = new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
                    e.getScreenX(), e.getScreenY(), e.getButton(), e.getClickCount(),
                    e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
                    e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
                    e.isSynthesized(), e.isPopupTrigger(), e.isStillSincePress(), res);
            }

            if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
                tmpTargetWrapper.clear();
            }

            TargetWrapper target;
            if (pdrInProgress) {
                target = pdrEventTarget;
            } else {
                target = tmpTargetWrapper;
            }

            if (gestureStarted) {
                pdrEventTarget.copy(target);
                pdrEventTarget.fillHierarchy(pdrEventTargets);
            }

            if (!onPulse) {
                e = clickGenerator.preProcess(e);
            }

            // enter/exit handling
            handleEnterExit(e, tmpTargetWrapper);

            //deliver event to the target node
            if (Scene.this.dndGesture != null) {
                Scene.this.dndGesture.processDragDetection(e);
            }

            if (fullPDREntered &amp;&amp; e.getEventType() == MouseEvent.MOUSE_RELEASED) {
                processFullPDR(e, onPulse);
            }

            if (target.getEventTarget() != null) {
                if (e.getEventType() != MouseEvent.MOUSE_ENTERED
                        &amp;&amp; e.getEventType() != MouseEvent.MOUSE_EXITED
                        &amp;&amp; !onPulse) {
                    Event.fireEvent(target.getEventTarget(), e);
                }
            }

            if (fullPDREntered &amp;&amp; e.getEventType() != MouseEvent.MOUSE_RELEASED) {
                processFullPDR(e, onPulse);
            }

            if (!onPulse) {
                clickGenerator.postProcess(e, target, tmpTargetWrapper);
            }

            // handle drag and drop

            if (!PLATFORM_DRAG_GESTURE_INITIATION &amp;&amp; !onPulse) {
                if (Scene.this.dndGesture != null) {
                    if (!Scene.this.dndGesture.process(e, target.getEventTarget())) {
                        dndGesture = null;
                    }
                }
            }

            Cursor cursor = target.getCursor();
            if (e.getEventType() != MouseEvent.MOUSE_EXITED) {
                if (cursor == null &amp;&amp; hover) {
                    cursor = Scene.this.getCursor();
                }

                updateCursor(cursor);
                updateCursorFrame();
            }

            if (gestureStarted) {
                pdrInProgress = true;
            }

            if (pdrInProgress &amp;&amp;
                    !(primaryButtonDown || secondaryButtonDown || middleButtonDown)) {
                clearPDREventTargets();
                exitFullPDR(e);
                // we need to do new picking in case the originally picked node
                // was moved or removed by the event handlers
                pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
                handleEnterExit(e, tmpTargetWrapper);
            }

            lastEvent = e.getEventType() == MouseEvent.MOUSE_EXITED ? null : e;
            Scene.inMousePick = false;
        }

        private void processFullPDR(MouseEvent e, boolean onPulse) {

            pick(fullPDRTmpTargetWrapper, e.getSceneX(), e.getSceneY());
            final PickResult result = fullPDRTmpTargetWrapper.getResult();

            final EventTarget eventTarget = fullPDRTmpTargetWrapper.getEventTarget();

            // enter/exit handling
            if (eventTarget != fullPDRCurrentTarget) {

                fullPDRTmpTargetWrapper.fillHierarchy(fullPDRNewEventTargets);

                int newTargetsSize = fullPDRNewEventTargets.size();
                int i = fullPDRCurrentEventTargets.size() - 1;
                int j = newTargetsSize - 1;

                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp;
                        fullPDRCurrentEventTargets.get(i) == fullPDRNewEventTargets.get(j)) {
                    i--;
                    j--;
                }

                for (; i &gt;= 0; i--) {
                    final EventTarget exitedEventTarget = fullPDRCurrentEventTargets.get(i);
                    Event.fireEvent(exitedEventTarget, MouseEvent.copyForMouseDragEvent(e,
                            exitedEventTarget, exitedEventTarget,
                            MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
                            fullPDRSource, result));
                }

                for (; j &gt;= 0; j--) {
                    final EventTarget enteredEventTarget = fullPDRNewEventTargets.get(j);
                    Event.fireEvent(enteredEventTarget, MouseEvent.copyForMouseDragEvent(e,
                            enteredEventTarget, enteredEventTarget,
                            MouseDragEvent.MOUSE_DRAG_ENTERED_TARGET,
                            fullPDRSource, result));
                }

                fullPDRCurrentTarget = eventTarget;
                fullPDRCurrentEventTargets.clear();
                fullPDRCurrentEventTargets.addAll(fullPDRNewEventTargets);
                fullPDRNewEventTargets.clear();
            }
            // done enter/exit handling

            // event delivery
            if (eventTarget != null &amp;&amp; !onPulse) {
                if (e.getEventType() == MouseEvent.MOUSE_DRAGGED) {
                    Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
                            eventTarget, eventTarget,
                            MouseDragEvent.MOUSE_DRAG_OVER,
                            fullPDRSource, result));
                }
                if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
                    Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
                            eventTarget, eventTarget,
                            MouseDragEvent.MOUSE_DRAG_RELEASED,
                            fullPDRSource, result));
                }
            }
        }

        private void updateCursor(Cursor newCursor) {
            if (currCursor != newCursor) {
                if (currCursor != null) {
                    currCursor.deactivate();
                }

                if (newCursor != null) {
                    newCursor.activate();
                }

                currCursor = newCursor;
            }
        }

        public void updateCursorFrame() {
            final CursorFrame newCursorFrame =
                    (currCursor != null)
                           ? currCursor.getCurrentFrame()
                           : Cursor.DEFAULT.getCurrentFrame();
            if (currCursorFrame != newCursorFrame) {
                if (Scene.this.peer != null) {
                    Scene.this.peer.setCursor(newCursorFrame);
                }

                currCursorFrame = newCursorFrame;
            }
        }

        private PickResult pickNode(PickRay pickRay) {
            PickResultChooser r = new PickResultChooser();
            Scene.this.getRoot().pickNode(pickRay, r);
            return r.toPickResult();
        }
    }

    /*******************************************************************************
     *                                                                             *
     * Key Event Handling                                                          *
     *                                                                             *
     ******************************************************************************/

    class KeyHandler {
        private void setFocusOwner(final Node value) {
            // Cancel IM composition if there is one in progress.
            // This needs to be done before the focus owner is switched as it
            // generates event that needs to be delivered to the old focus owner.
            if (oldFocusOwner != null) {
                final Scene s = oldFocusOwner.getScene();
                if (s != null) {
                    final TKScene peer = s.getPeer();
                    if (peer != null) {
                        peer.finishInputMethodComposition();
                    }
                }
            }
            focusOwner.set(value);
        }

        private boolean windowFocused;
        protected boolean isWindowFocused() { return windowFocused; }
        protected void setWindowFocused(boolean value) {
            windowFocused = value;
            if (getFocusOwner() != null) {
                getFocusOwner().setFocused(windowFocused);
            }
            if (windowFocused) {
                if (accessible != null) {
                    accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
                }
            }
        }

        private void windowForSceneChanged(Window oldWindow, Window window) {
            if (oldWindow != null) {
                oldWindow.focusedProperty().removeListener(sceneWindowFocusedListener);
            }

            if (window != null) {
                window.focusedProperty().addListener(sceneWindowFocusedListener);
                setWindowFocused(window.isFocused());
            } else {
                setWindowFocused(false);
            }
        }

        private final InvalidationListener sceneWindowFocusedListener = valueModel -&gt; setWindowFocused(((ReadOnlyBooleanProperty)valueModel).get());

        private void process(KeyEvent e) {
            final Node sceneFocusOwner = getFocusOwner();
            final EventTarget eventTarget =
                    (sceneFocusOwner != null &amp;&amp; sceneFocusOwner.getScene() == Scene.this) ? sceneFocusOwner
                                              : Scene.this;

            // send the key event to the current focus owner or to scene if
            // the focus owner is not set
            Event.fireEvent(eventTarget, e);
        }

        private void requestFocus(Node node) {
            if (getFocusOwner() == node || (node != null &amp;&amp; !node.isCanReceiveFocus())) {
                return;
            }
            setFocusOwner(node);
        }
    }
    /***************************************************************************
     *                                                                         *
     *                         Event Dispatch                                  *
     *                                                                         *
     **************************************************************************/
    // PENDING_DOC_REVIEW
    /**
     * Specifies the event dispatcher for this scene. When replacing the value
     * with a new {@code EventDispatcher}, the new dispatcher should forward
     * events to the replaced dispatcher to keep the scene's default event
     * handling behavior.
     */
    private ObjectProperty&lt;EventDispatcher&gt; eventDispatcher;

    public final void setEventDispatcher(EventDispatcher value) {
        eventDispatcherProperty().set(value);
    }

    public final EventDispatcher getEventDispatcher() {
        return eventDispatcherProperty().get();
    }

    public final ObjectProperty&lt;EventDispatcher&gt;
            eventDispatcherProperty() {
        initializeInternalEventDispatcher();
        return eventDispatcher;
    }

    private SceneEventDispatcher internalEventDispatcher;

    // Delegates requests from platform input method to the focused
    // node's one, if any.
    class InputMethodRequestsDelegate implements ExtendedInputMethodRequests {
        @Override
        public Point2D getTextLocation(int offset) {
            InputMethodRequests requests = getClientRequests();
            if (requests != null) {
                return requests.getTextLocation(offset);
            } else {
                return new Point2D(0, 0);
            }
        }

        @Override
        public int getLocationOffset(int x, int y) {
            InputMethodRequests requests = getClientRequests();
            if (requests != null) {
                return requests.getLocationOffset(x, y);
            } else {
                return 0;
            }
        }

        @Override
        public void cancelLatestCommittedText() {
            InputMethodRequests requests = getClientRequests();
            if (requests != null) {
                requests.cancelLatestCommittedText();
            }
        }

        @Override
        public String getSelectedText() {
            InputMethodRequests requests = getClientRequests();
            if (requests != null) {
                return requests.getSelectedText();
            }
            return null;
        }

        @Override
        public int getInsertPositionOffset() {
            InputMethodRequests requests = getClientRequests();
            if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
                return ((ExtendedInputMethodRequests)requests).getInsertPositionOffset();
            }
            return 0;
        }

        @Override
        public String getCommittedText(int begin, int end) {
            InputMethodRequests requests = getClientRequests();
            if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
                return ((ExtendedInputMethodRequests)requests).getCommittedText(begin, end);
            }
            return null;
        }

        @Override
        public int getCommittedTextLength() {
            InputMethodRequests requests = getClientRequests();
            if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
                return ((ExtendedInputMethodRequests)requests).getCommittedTextLength();
            }
            return 0;
        }

        private InputMethodRequests getClientRequests() {
            Node focusOwner = getFocusOwner();
            if (focusOwner != null) {
                return focusOwner.getInputMethodRequests();
            }
            return null;
        }
    }

    // PENDING_DOC_REVIEW
    /**
     * Registers an event handler to this scene. The handler is called when the
     * scene receives an {@code Event} of the specified type during the bubbling
     * phase of event delivery.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the type of the events to receive by the handler
     * @param eventHandler the handler to register
     * @throws NullPointerException if the event type or handler is null
     */
    public final &lt;T extends Event&gt; void addEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .addEventHandler(eventType, eventHandler);
    }

    // PENDING_DOC_REVIEW
    /**
     * Unregisters a previously registered event handler from this scene. One
     * handler might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the handler.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type from which to unregister
     * @param eventHandler the handler to unregister
     * @throws NullPointerException if the event type or handler is null
     */
    public final &lt;T extends Event&gt; void removeEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .removeEventHandler(eventType,
                                                        eventHandler);
    }

    // PENDING_DOC_REVIEW
    /**
     * Registers an event filter to this scene. The filter is called when the
     * scene receives an {@code Event} of the specified type during the
     * capturing phase of event delivery.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the type of the events to receive by the filter
     * @param eventFilter the filter to register
     * @throws NullPointerException if the event type or filter is null
     */
    public final &lt;T extends Event&gt; void addEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .addEventFilter(eventType, eventFilter);
    }

    // PENDING_DOC_REVIEW
    /**
     * Unregisters a previously registered event filter from this scene. One
     * filter might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the filter.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the event type from which to unregister
     * @param eventFilter the filter to unregister
     * @throws NullPointerException if the event type or filter is null
     */
    public final &lt;T extends Event&gt; void removeEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .removeEventFilter(eventType, eventFilter);
    }

    /**
     * Sets the handler to use for this event type. There can only be one such
     * handler specified at a time. This handler is guaranteed to be called
     * first. This is used for registering the user-defined onFoo event
     * handlers.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type to associate with the given eventHandler
     * @param eventHandler the handler to register, or null to unregister
     * @throws NullPointerException if the event type is null
     */
    protected final &lt;T extends Event&gt; void setEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .setEventHandler(eventType, eventHandler);
    }

    private SceneEventDispatcher getInternalEventDispatcher() {
        initializeInternalEventDispatcher();
        return internalEventDispatcher;
    }

    final void initializeInternalEventDispatcher() {
        if (internalEventDispatcher == null) {
            internalEventDispatcher = createInternalEventDispatcher();
            eventDispatcher = new SimpleObjectProperty&lt;EventDispatcher&gt;(
                                          this,
                                          &quot;eventDispatcher&quot;,
                                          internalEventDispatcher);
        }
    }

    private SceneEventDispatcher createInternalEventDispatcher() {
        return new SceneEventDispatcher(this);
    }

    /**
     * Registers the specified mnemonic.
     *
     * @param m The mnemonic
     */
    public void addMnemonic(Mnemonic m) {
        getInternalEventDispatcher().getKeyboardShortcutsHandler()
                                    .addMnemonic(m);
    }


    /**
     * Unregisters the specified mnemonic.
     *
     * @param m The mnemonic
     */
    public void removeMnemonic(Mnemonic m) {
        getInternalEventDispatcher().getKeyboardShortcutsHandler()
                                    .removeMnemonic(m);
    }

    final void clearNodeMnemonics(Node node) {
        getInternalEventDispatcher().getKeyboardShortcutsHandler()
                .clearNodeMnemonics(node);
    }


    /**
     * Gets the list of mnemonics for this {@code Scene}.
     *
     * @return the list of mnemonics
     */
    public ObservableMap&lt;KeyCombination, ObservableList&lt;Mnemonic&gt;&gt; getMnemonics() {
        return getInternalEventDispatcher().getKeyboardShortcutsHandler()
                                           .getMnemonics();
    }

    /**
     * Gets the list of accelerators for this {@code Scene}.
     *
     * @return the list of accelerators
     */
    public ObservableMap&lt;KeyCombination, Runnable&gt; getAccelerators() {
        return getInternalEventDispatcher().getKeyboardShortcutsHandler()
                                           .getAccelerators();
    }

    // PENDING_DOC_REVIEW
    /**
     * Construct an event dispatch chain for this scene. The event dispatch
     * chain contains all event dispatchers from the stage to this scene.
     *
     * @param tail the initial chain to build from
     * @return the resulting event dispatch chain for this scene
     */
    @Override
    public EventDispatchChain buildEventDispatchChain(
            EventDispatchChain tail) {
        if (eventDispatcher != null) {
            final EventDispatcher eventDispatcherValue = eventDispatcher.get();
            if (eventDispatcherValue != null) {
                tail = tail.prepend(eventDispatcherValue);
            }
        }

        if (getWindow() != null) {
            tail = getWindow().buildEventDispatchChain(tail);
        }

        return tail;
    }

    /***************************************************************************
     *                                                                         *
     *                             Context Menus                               *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when a mouse button has been clicked
     * (pressed and released) on this {@code Scene}.
     * @since JavaFX 2.1
     */

    private ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequested;

    public final void setOnContextMenuRequested(EventHandler&lt;? super ContextMenuEvent&gt; value) {
        onContextMenuRequestedProperty().set(value);
    }

    public final EventHandler&lt;? super ContextMenuEvent&gt; getOnContextMenuRequested() {
        return onContextMenuRequested == null ? null : onContextMenuRequested.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequestedProperty() {
        if (onContextMenuRequested == null) {
            onContextMenuRequested = new ObjectPropertyBase&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ContextMenuEvent.CONTEXT_MENU_REQUESTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onContextMenuRequested&quot;;
                }
            };
        }
        return onContextMenuRequested;
    }

    /***************************************************************************
     *                                                                         *
     *                             Mouse Handling                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when a mouse button has been clicked
     * (pressed and released) on this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClicked;

    public final void setOnMouseClicked(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseClickedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseClicked() {
        return onMouseClicked == null ? null : onMouseClicked.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClickedProperty() {
        if (onMouseClicked == null) {
            onMouseClicked = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_CLICKED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseClicked&quot;;
                }
            };
        }
        return onMouseClicked;
    }

    /**
     * Defines a function to be called when a mouse button is pressed
     * on this {@code Scene} and then dragged.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDragged;

    public final void setOnMouseDragged(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseDraggedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseDragged() {
        return onMouseDragged == null ? null : onMouseDragged.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDraggedProperty() {
        if (onMouseDragged == null) {
            onMouseDragged = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_DRAGGED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragged&quot;;
                }
            };
        }
        return onMouseDragged;
    }

    /**
     * Defines a function to be called when the mouse enters this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEntered;

    public final void setOnMouseEntered(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseEntered() {
        return onMouseEntered == null ? null : onMouseEntered.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEnteredProperty() {
        if (onMouseEntered == null) {
            onMouseEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_ENTERED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseEntered&quot;;
                }
            };
        }
        return onMouseEntered;
    }

    /**
     * Defines a function to be called when the mouse exits this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExited;

    public final void setOnMouseExited(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseExitedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseExited() {
        return onMouseExited == null ? null : onMouseExited.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExitedProperty() {
        if (onMouseExited == null) {
            onMouseExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_EXITED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseExited&quot;;
                }
            };
        }
        return onMouseExited;
    }

    /**
     * Defines a function to be called when mouse cursor moves within
     * this {@code Scene} but no buttons have been pushed.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMoved;

    public final void setOnMouseMoved(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseMovedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseMoved() {
        return onMouseMoved == null ? null : onMouseMoved.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMovedProperty() {
        if (onMouseMoved == null) {
            onMouseMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_MOVED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseMoved&quot;;
                }
            };
        }
        return onMouseMoved;
    }

    /**
     * Defines a function to be called when a mouse button
     * has been pressed on this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressed;

    public final void setOnMousePressed(EventHandler&lt;? super MouseEvent&gt; value) {
        onMousePressedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMousePressed() {
        return onMousePressed == null ? null : onMousePressed.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressedProperty() {
        if (onMousePressed == null) {
            onMousePressed = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_PRESSED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMousePressed&quot;;
                }
            };
        }
        return onMousePressed;
    }

    /**
     * Defines a function to be called when a mouse button
     * has been released on this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleased;

    public final void setOnMouseReleased(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseReleased() {
        return onMouseReleased == null ? null : onMouseReleased.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleasedProperty() {
        if (onMouseReleased == null) {
            onMouseReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_RELEASED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseReleased&quot;;
                }
            };
        }
        return onMouseReleased;
    }

    /**
     * Defines a function to be called when drag gesture has been
     * detected. This is the right place to start drag and drop operation.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetected;

    public final void setOnDragDetected(EventHandler&lt;? super MouseEvent&gt; value) {
        onDragDetectedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnDragDetected() {
        return onDragDetected == null ? null : onDragDetected.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetectedProperty() {
        if (onDragDetected == null) {
            onDragDetected = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.DRAG_DETECTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragDetected&quot;;
                }
            };
        }
        return onDragDetected;
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * progresses within this {@code Scene}.
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOver;

    public final void setOnMouseDragOver(EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragOverProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragOver() {
        return onMouseDragOver == null ? null : onMouseDragOver.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOverProperty() {
        if (onMouseDragOver == null) {
            onMouseDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseDragEvent.MOUSE_DRAG_OVER, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragOver&quot;;
                }
            };
        }
        return onMouseDragOver;
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * ends within this {@code Scene}.
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleased;

    public final void setOnMouseDragReleased(EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragReleased() {
        return onMouseDragReleased == null ? null : onMouseDragReleased.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleasedProperty() {
        if (onMouseDragReleased == null) {
            onMouseDragReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseDragEvent.MOUSE_DRAG_RELEASED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragReleased&quot;;
                }
            };
        }
        return onMouseDragReleased;
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * enters this {@code Scene}.
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEntered;

    public final void setOnMouseDragEntered(EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragEntered() {
        return onMouseDragEntered == null ? null : onMouseDragEntered.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEnteredProperty() {
        if (onMouseDragEntered == null) {
            onMouseDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseDragEvent.MOUSE_DRAG_ENTERED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragEntered&quot;;
                }
            };
        }
        return onMouseDragEntered;
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * exits this {@code Scene}.
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExited;

    public final void setOnMouseDragExited(EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragExitedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragExited() {
        return onMouseDragExited == null ? null : onMouseDragExited.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExitedProperty() {
        if (onMouseDragExited == null) {
            onMouseDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseDragEvent.MOUSE_DRAG_EXITED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragExited&quot;;
                }
            };
        }
        return onMouseDragExited;
    }


    /***************************************************************************
     *                                                                         *
     *                           Gestures Handling                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when a scrolling gesture is detected.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStarted;

    public final void setOnScrollStarted(EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollStartedProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollStarted() {
        return onScrollStarted == null ? null : onScrollStarted.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStartedProperty() {
        if (onScrollStarted == null) {
            onScrollStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ScrollEvent.SCROLL_STARTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onScrollStarted&quot;;
                }
            };
        }
        return onScrollStarted;
    }

    /**
     * Defines a function to be called when user performs a scrolling action.
     */
    private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScroll;

    public final void setOnScroll(EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScroll() {
        return onScroll == null ? null : onScroll.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollProperty() {
        if (onScroll == null) {
            onScroll = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ScrollEvent.SCROLL, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onScroll&quot;;
                }
            };
        }
        return onScroll;
    }

    /**
     * Defines a function to be called when a scrolling gesture ends.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinished;

    public final void setOnScrollFinished(EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollFinished() {
        return onScrollFinished == null ? null : onScrollFinished.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinishedProperty() {
        if (onScrollFinished == null) {
            onScrollFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ScrollEvent.SCROLL_FINISHED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onScrollFinished&quot;;
                }
            };
        }
        return onScrollFinished;
    }

    /**
     * Defines a function to be called when a rotating gesture is detected.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStarted;

    public final void setOnRotationStarted(EventHandler&lt;? super RotateEvent&gt; value) {
        onRotationStartedProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotationStarted() {
        return onRotationStarted == null ? null : onRotationStarted.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStartedProperty() {
        if (onRotationStarted == null) {
            onRotationStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(RotateEvent.ROTATION_STARTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onRotationStarted&quot;;
                }
            };
        }
        return onRotationStarted;
    }

    /**
     * Defines a function to be called when user performs a rotating action.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotate;

    public final void setOnRotate(EventHandler&lt;? super RotateEvent&gt; value) {
        onRotateProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotate() {
        return onRotate == null ? null : onRotate.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotateProperty() {
        if (onRotate == null) {
            onRotate = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(RotateEvent.ROTATE, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onRotate&quot;;
                }
            };
        }
        return onRotate;
    }

    /**
     * Defines a function to be called when a rotating gesture ends.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinished;

    public final void setOnRotationFinished(EventHandler&lt;? super RotateEvent&gt; value) {
        onRotationFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotationFinished() {
        return onRotationFinished == null ? null : onRotationFinished.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinishedProperty() {
        if (onRotationFinished == null) {
            onRotationFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(RotateEvent.ROTATION_FINISHED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onRotationFinished&quot;;
                }
            };
        }
        return onRotationFinished;
    }

    /**
     * Defines a function to be called when a zooming gesture is detected.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStarted;

    public final void setOnZoomStarted(EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomStartedProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomStarted() {
        return onZoomStarted == null ? null : onZoomStarted.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStartedProperty() {
        if (onZoomStarted == null) {
            onZoomStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ZoomEvent.ZOOM_STARTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onZoomStarted&quot;;
                }
            };
        }
        return onZoomStarted;
    }

    /**
     * Defines a function to be called when user performs a zooming action.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoom;

    public final void setOnZoom(EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoom() {
        return onZoom == null ? null : onZoom.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomProperty() {
        if (onZoom == null) {
            onZoom = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ZoomEvent.ZOOM, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onZoom&quot;;
                }
            };
        }
        return onZoom;
    }

    /**
     * Defines a function to be called when a zooming gesture ends.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinished;

    public final void setOnZoomFinished(EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomFinished() {
        return onZoomFinished == null ? null : onZoomFinished.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinishedProperty() {
        if (onZoomFinished == null) {
            onZoomFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ZoomEvent.ZOOM_FINISHED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onZoomFinished&quot;;
                }
            };
        }
        return onZoomFinished;
    }

    /**
     * Defines a function to be called when an upward swipe gesture
     * happens in this scene.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUp;

    public final void setOnSwipeUp(EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeUpProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeUp() {
        return onSwipeUp == null ? null : onSwipeUp.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUpProperty() {
        if (onSwipeUp == null) {
            onSwipeUp = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(SwipeEvent.SWIPE_UP, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onSwipeUp&quot;;
                }
            };
        }
        return onSwipeUp;
    }

    /**
     * Defines a function to be called when an downward swipe gesture
     * happens in this scene.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDown;

    public final void setOnSwipeDown(EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeDownProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeDown() {
        return onSwipeDown == null ? null : onSwipeDown.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDownProperty() {
        if (onSwipeDown == null) {
            onSwipeDown = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(SwipeEvent.SWIPE_DOWN, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onSwipeDown&quot;;
                }
            };
        }
        return onSwipeDown;
    }

    /**
     * Defines a function to be called when an leftward swipe gesture
     * happens in this scene.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeft;

    public final void setOnSwipeLeft(EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeLeftProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeLeft() {
        return onSwipeLeft == null ? null : onSwipeLeft.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeftProperty() {
        if (onSwipeLeft == null) {
            onSwipeLeft = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(SwipeEvent.SWIPE_LEFT, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onSwipeLeft&quot;;
                }
            };
        }
        return onSwipeLeft;
    }

    /**
     * Defines a function to be called when an rightward swipe gesture
     * happens in this scene.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRight;

    public final void setOnSwipeRight(EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeRightProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeRight() {
        return onSwipeRight == null ? null : onSwipeRight.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRightProperty() {
        if (onSwipeRight == null) {
            onSwipeRight = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(SwipeEvent.SWIPE_RIGHT, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onSwipeRight&quot;;
                }
            };
        }
        return onSwipeRight;
    }

    /***************************************************************************
     *                                                                         *
     *                            Touch Handling                               *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when a new touch point is pressed.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressed;

    public final void setOnTouchPressed(EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchPressedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchPressed() {
        return onTouchPressed == null ? null : onTouchPressed.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressedProperty() {
        if (onTouchPressed == null) {
            onTouchPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(TouchEvent.TOUCH_PRESSED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onTouchPressed&quot;;
                }
            };
        }
        return onTouchPressed;
    }

    /**
     * Defines a function to be called when a touch point is moved.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMoved;

    public final void setOnTouchMoved(EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchMovedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchMoved() {
        return onTouchMoved == null ? null : onTouchMoved.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMovedProperty() {
        if (onTouchMoved == null) {
            onTouchMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(TouchEvent.TOUCH_MOVED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onTouchMoved&quot;;
                }
            };
        }
        return onTouchMoved;
    }

    /**
     * Defines a function to be called when a new touch point is pressed.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleased;

    public final void setOnTouchReleased(EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchReleased() {
        return onTouchReleased == null ? null : onTouchReleased.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleasedProperty() {
        if (onTouchReleased == null) {
            onTouchReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(TouchEvent.TOUCH_RELEASED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onTouchReleased&quot;;
                }
            };
        }
        return onTouchReleased;
    }

    /**
     * Defines a function to be called when a touch point stays pressed and
     * still.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationary;

    public final void setOnTouchStationary(EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchStationaryProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchStationary() {
        return onTouchStationary == null ? null : onTouchStationary.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationaryProperty() {
        if (onTouchStationary == null) {
            onTouchStationary = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(TouchEvent.TOUCH_STATIONARY, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onTouchStationary&quot;;
                }
            };
        }
        return onTouchStationary;
    }

    /*
     * This class provides reordering and ID mapping of particular touch points.
     * Platform may report arbitrary touch point IDs and they may be reused
     * during one gesture. This class keeps track of it and provides
     * sequentially sorted IDs, unique in scope of a gesture.
     *
     * Some platforms report always small numbers, these take fast paths through
     * the algorithm, directly indexing an array. Bigger numbers take a slow
     * path using a hash map.
     *
     * The algorithm performance was measured and it doesn't impose
     * any significant slowdown on the event delivery.
     */
    private static class TouchMap {
        private static final int FAST_THRESHOLD = 10;
        int[] fastMap = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        Map&lt;Long, Integer&gt; slowMap = new HashMap&lt;Long, Integer&gt;();
        List&lt;Integer&gt; order = new LinkedList&lt;Integer&gt;();
        List&lt;Long&gt; removed = new ArrayList&lt;Long&gt;(10);
        int counter = 0;
        int active = 0;

        public int add(long id) {
            counter++;
            active++;
            if (id &lt; FAST_THRESHOLD) {
                fastMap[(int) id] = counter;
            } else {
                slowMap.put(id, counter);
            }
            order.add(counter);
            return counter;
        }

        public void remove(long id) {
            // book the removal - it needs to be done after all touch points
            // of an event are processed - see cleanup()
            removed.add(id);
        }

        public int get(long id) {
            if (id &lt; FAST_THRESHOLD) {
                int result = fastMap[(int) id];
                if (result == 0) {
                    throw new RuntimeException(&quot;Platform reported wrong &quot;
                            + &quot;touch point ID&quot;);
                }
                return result;
            } else {
                try {
                    return slowMap.get(id);
                } catch (NullPointerException e) {
                    throw new RuntimeException(&quot;Platform reported wrong &quot;
                            + &quot;touch point ID&quot;);
                }
            }
        }

        public int getOrder(int id) {
            return order.indexOf(id);
        }

        // returns true if gesture finished (no finger is touched)
        public boolean cleanup() {
            for (long id : removed) {
                active--;
                order.remove(Integer.valueOf(get(id)));
                if (id &lt; FAST_THRESHOLD) {
                    fastMap[(int) id] = 0;
                } else {
                    slowMap.remove(id);
                }
                if (active == 0) {
                    // gesture finished
                    counter = 0;
                }
            }
            removed.clear();
            return active == 0;
        }
    }


    /***************************************************************************
     *                                                                         *
     *                         Drag and Drop Handling                          *
     *                                                                         *
     **************************************************************************/

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEntered;

    public final void setOnDragEntered(EventHandler&lt;? super DragEvent&gt; value) {
        onDragEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragEntered() {
        return onDragEntered == null ? null : onDragEntered.get();
    }

    /**
     * Defines a function to be called when drag gesture
     * enters this {@code Scene}.
     * @return function to be called when drag gesture enters this scene
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEnteredProperty() {
        if (onDragEntered == null) {
            onDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_ENTERED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragEntered&quot;;
                }
            };
        }
        return onDragEntered;
    }

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExited;

    public final void setOnDragExited(EventHandler&lt;? super DragEvent&gt; value) {
        onDragExitedProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragExited() {
        return onDragExited == null ? null : onDragExited.get();
    }

    /**
     * Defines a function to be called when drag gesture
     * exits this {@code Scene}.
     * @return the function to be called when drag gesture exits this scene
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExitedProperty() {
        if (onDragExited == null) {
            onDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_EXITED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragExited&quot;;
                }
            };
        }
        return onDragExited;
    }

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOver;

    public final void setOnDragOver(EventHandler&lt;? super DragEvent&gt; value) {
        onDragOverProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragOver() {
        return onDragOver == null ? null : onDragOver.get();
    }

    /**
     * Defines a function to be called when drag gesture progresses
     * within this {@code Scene}.
     * @return the function to be called when drag gesture progresses within
     * this scene
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOverProperty() {
        if (onDragOver == null) {
            onDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_OVER, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragOver&quot;;
                }
            };
        }
        return onDragOver;
    }

    // Do we want DRAG_TRANSFER_MODE_CHANGED event?
//    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChanged;
//
//    public final void setOnDragTransferModeChanged(EventHandler&lt;? super DragEvent&gt; value) {
//        onDragTransferModeChangedProperty().set(value);
//    }
//
//    public final EventHandler&lt;? super DragEvent&gt; getOnDragTransferModeChanged() {
//        return onDragTransferModeChanged == null ? null : onDragTransferModeChanged.get();
//    }
//
//    /**
//     * Defines a function to be called this {@code Scene} if it is a potential
//     * drag-and-drop target when the user takes action to change the intended
//     * {@code TransferMode}.
//     * The user can change the intended {@link TransferMode} by holding down
//     * or releasing key modifiers.
//     */
//    public ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChangedProperty() {
//        if (onDragTransferModeChanged == null) {
//            onDragTransferModeChanged = new SimpleObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
//
//                @Override
//                protected void invalidated() {
//                    setEventHandler(DragEvent.DRAG_TRANSFER_MODE_CHANGED, get());
//                }
//            };
//        }
//        return onDragTransferModeChanged;
//    }

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDropped;

    public final void setOnDragDropped(EventHandler&lt;? super DragEvent&gt; value) {
        onDragDroppedProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragDropped() {
        return onDragDropped == null ? null : onDragDropped.get();
    }

    /**
     * Defines a function to be called when the mouse button is released
     * on this {@code Scene} during drag and drop gesture. Transfer of data from
     * the {@link DragEvent}'s {@link DragEvent#getDragboard() dragboard} should
     * happen in this function.
     * @return the function to be called when the mouse button is released on
     * this scene during drag and drop gesture
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDroppedProperty() {
        if (onDragDropped == null) {
            onDragDropped = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_DROPPED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragDropped&quot;;
                }
            };
        }
        return onDragDropped;
    }

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDone;

    public final void setOnDragDone(EventHandler&lt;? super DragEvent&gt; value) {
        onDragDoneProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragDone() {
        return onDragDone == null ? null : onDragDone.get();
    }

    /**
     * Defines a function to be called when this {@code Scene} is a
     * drag and drop gesture source after its data has
     * been dropped on a drop target. The {@code transferMode} of the
     * event shows what just happened at the drop target.
     * If {@code transferMode} has the value {@code MOVE}, then the source can
     * clear out its data. Clearing the source's data gives the appropriate
     * appearance to a user that the data has been moved by the drag and drop
     * gesture. A {@code transferMode} that has the value {@code NONE}
     * indicates that no data was transferred during the drag and drop gesture.
     * Positional data for the {@code DragEvent} is invalid.  Valid positional
     * data for the {@code DragEvent} is presented in the
     * {@link #onDragDroppedProperty() onDragDropped} event handler.
     * @return the function to be called when this scene is a drag and drop
     * gesture source after its data has been dropped on a drop target
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDoneProperty() {
        if (onDragDone == null) {
            onDragDone = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_DONE, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragDone&quot;;
                }
            };
        }
        return onDragDone;
    }

    /**
     * Confirms a potential drag and drop gesture that is recognized over this
     * {@code Scene}.
     * Can be called only from a DRAG_DETECTED event handler. The returned
     * {@link Dragboard} is used to transfer data during
     * the drag and drop gesture. Placing this {@code Scene}'s data on the
     * {@link Dragboard} also identifies this {@code Scene} as the source of
     * the drag and drop gesture.
     * More detail about drag and drop gestures is described in the overivew
     * of {@link DragEvent}.
     *
     * @see DragEvent
     * @param transferModes The supported {@code TransferMode}(s) of this {@code Node}
     * @return A {@code Dragboard} to place this {@code Scene}'s data on
     * @throws IllegalStateException if drag and drop cannot be started at this
     * moment (it's called outside of {@code DRAG_DETECTED} event handling).
     */
    public Dragboard startDragAndDrop(TransferMode... transferModes) {
        return startDragAndDrop(this, transferModes);
    }

    /**
     * Starts a full press-drag-release gesture with this scene as gesture
     * source. This method can be called only from a {@code DRAG_DETECTED} mouse
     * event handler. More detail about dragging gestures can be found
     * in the overview of {@link MouseEvent} and {@link MouseDragEvent}.
     *
     * @see MouseEvent
     * @see MouseDragEvent
     * @throws IllegalStateException if the full press-drag-release gesture
     * cannot be started at this moment (it's called outside of
     * {@code DRAG_DETECTED} event handling).
     * @since JavaFX 2.1
     */
    public void startFullDrag() {
        startFullDrag(this);
    }


    Dragboard startDragAndDrop(EventTarget source, TransferMode... transferModes) {
        Toolkit.getToolkit().checkFxUserThread();
        if (dndGesture == null ||
            (dndGesture.dragDetected != DragDetectedState.PROCESSING))
        {
            throw new IllegalStateException(&quot;Cannot start drag and drop &quot; +
                    &quot;outside of DRAG_DETECTED event handler&quot;);
        }

        Set&lt;TransferMode&gt; set = EnumSet.noneOf(TransferMode.class);
        for (TransferMode tm : InputEventUtils.safeTransferModes(transferModes)) {
            set.add(tm);
        }
        return dndGesture.startDrag(source, set);
    }

    void startFullDrag(EventTarget source) {
        Toolkit.getToolkit().checkFxUserThread();
        if (dndGesture.dragDetected != DragDetectedState.PROCESSING) {
            throw new IllegalStateException(&quot;Cannot start full drag &quot; +
                    &quot;outside of DRAG_DETECTED event handler&quot;);
        }

        if (dndGesture != null) {
            dndGesture.startFullPDR(source);
            return;
        }

        throw new IllegalStateException(&quot;Cannot start full drag when &quot;
                + &quot;mouse button is not pressed&quot;);
    }

    /***************************************************************************
     *                                                                         *
     *                           Keyboard Handling                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when some {@code Node} of this
     * {@code Scene} has input focus and a key has been pressed. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     */
    private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressed;

    public final void setOnKeyPressed(EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyPressedProperty().set(value);
    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyPressed() {
        return onKeyPressed == null ? null : onKeyPressed.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressedProperty() {
        if (onKeyPressed == null) {
            onKeyPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(KeyEvent.KEY_PRESSED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onKeyPressed&quot;;
                }
            };
        }
        return onKeyPressed;
    }

    /**
     * Defines a function to be called when some {@code Node} of this
     * {@code Scene} has input focus and a key has been released. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     */
    private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleased;

    public final void setOnKeyReleased(EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyReleased() {
        return onKeyReleased == null ? null : onKeyReleased.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleasedProperty() {
        if (onKeyReleased == null) {
            onKeyReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(KeyEvent.KEY_RELEASED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onKeyReleased&quot;;
                }
            };
        }
        return onKeyReleased;
    }

    /**
     * Defines a function to be called when some {@code Node} of this
     * {@code Scene} has input focus and a key has been typed. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     */
    private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTyped;

    public final void setOnKeyTyped(
            EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyTypedProperty().set( value);

    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyTyped(
            ) {
        return onKeyTyped == null ? null : onKeyTyped.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTypedProperty(
    ) {
        if (onKeyTyped == null) {
            onKeyTyped = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(KeyEvent.KEY_TYPED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onKeyTyped&quot;;
                }
            };
        }
        return onKeyTyped;
    }

    /***************************************************************************
     *                                                                         *
     *                           Input Method Handling                         *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when this {@code Node}
     * has input focus and the input method text has changed.  If this
     * function is not defined in this {@code Node}, then it
     * receives the result string of the input method composition as a
     * series of {@code onKeyTyped} function calls.
     * &lt;p&gt;
     * When the {@code Node} loses the input focus, the JavaFX runtime
     * automatically commits the existing composed text if any.
     */
    private ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChanged;

    public final void setOnInputMethodTextChanged(
            EventHandler&lt;? super InputMethodEvent&gt; value) {
        onInputMethodTextChangedProperty().set( value);
    }

    public final EventHandler&lt;? super InputMethodEvent&gt; getOnInputMethodTextChanged() {
        return onInputMethodTextChanged == null ? null : onInputMethodTextChanged.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChangedProperty() {
        if (onInputMethodTextChanged == null) {
            onInputMethodTextChanged = new ObjectPropertyBase&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(InputMethodEvent.INPUT_METHOD_TEXT_CHANGED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onInputMethodTextChanged&quot;;
                }
            };
        }
        return onInputMethodTextChanged;
    }

    /*
     * This class represents a picked target - either node, or scne, or null.
     * It provides functionality needed for the targets and covers the fact
     * that they are different kinds of animals.
     */
    private static class TargetWrapper {
        private Scene scene;
        private Node node;
        private PickResult result;

        /**
         * Fills the list with the target and all its parents (including scene)
         */
        public void fillHierarchy(final List&lt;EventTarget&gt; list) {
            list.clear();
            Node n = node;
            while(n != null) {
                list.add(n);
                final Parent p = n.getParent();
                n = p != null ? p : n.getSubScene();
            }

            if (scene != null) {
                list.add(scene);
            }
        }

        public EventTarget getEventTarget() {
            return node != null ? node : scene;
        }

        public Cursor getCursor() {
            Cursor cursor = null;
            if (node != null) {
                cursor = node.getCursor();
                Node n = node.getParent();
                while (cursor == null &amp;&amp; n != null) {
                    cursor = n.getCursor();

                    final Parent p = n.getParent();
                    n = p != null ? p : n.getSubScene();
                }
            }
            return cursor;
        }

        public void clear() {
            set(null, null);
            result = null;
        }

        public void setNodeResult(PickResult result) {
            if (result != null) {
                this.result = result;
                final Node n = result.getIntersectedNode();
                set(n, n.getScene());
            }
        }

        // Pass null scene if the mouse is outside of the window content
        public void setSceneResult(PickResult result, Scene scene) {
            if (result != null) {
                this.result = result;
                set(null, scene);
            }
        }

        public PickResult getResult() {
            return result;
        }

        public void copy(TargetWrapper tw) {
            node = tw.node;
            scene = tw.scene;
            result = tw.result;
        }

        private void set(Node n, Scene s) {
            node = n;
            scene = s;
        }
    }

    /*************************************************************************
    *                                                                        *
    *                                                                        *
    *                                                                        *
    *************************************************************************/

    private static final Object USER_DATA_KEY = new Object();
    // A map containing a set of properties for this scene
    private ObservableMap&lt;Object, Object&gt; properties;

    /**
      * Returns an observable map of properties on this node for use primarily
      * by application developers.
      *
      * @return an observable map of properties on this node for use primarily
      * by application developers
      *
      * @since JavaFX 8u40
      */
     public final ObservableMap&lt;Object, Object&gt; getProperties() {
        if (properties == null) {
            properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
        }
        return properties;
    }

    /**
     * Tests if Scene has properties.
     * @return true if node has properties.
     *
     * @since JavaFX 8u40
     */
     public boolean hasProperties() {
        return properties != null &amp;&amp; !properties.isEmpty();
    }

    /**
     * Convenience method for setting a single Object property that can be
     * retrieved at a later date. This is functionally equivalent to calling
     * the getProperties().put(Object key, Object value) method. This can later
     * be retrieved by calling {@link Scene#getUserData()}.
     *
     * @param value The value to be stored - this can later be retrieved by calling
     *          {@link Scene#getUserData()}.
     *
     * @since JavaFX 8u40
     */
    public void setUserData(Object value) {
        getProperties().put(USER_DATA_KEY, value);
    }

    /**
     * Returns a previously set Object property, or null if no such property
     * has been set using the {@link Scene#setUserData(java.lang.Object)} method.
     *
     * @return The Object that was previously set, or null if no property
     *          has been set or if null was set.
     *
     * @since JavaFX 8u40
     */
    public Object getUserData() {
        return getProperties().get(USER_DATA_KEY);
    }

    /***************************************************************************
     *                                                                         *
     *                       Component Orientation Properties                  *
     *                                                                         *
     **************************************************************************/

    private static final NodeOrientation defaultNodeOrientation =
        AccessController.doPrivileged(
                (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.scene.nodeOrientation.RTL&quot;)) ? NodeOrientation.RIGHT_TO_LEFT : NodeOrientation.INHERIT;



    private ObjectProperty&lt;NodeOrientation&gt; nodeOrientation;
    private EffectiveOrientationProperty effectiveNodeOrientationProperty;

    private NodeOrientation effectiveNodeOrientation;

    public final void setNodeOrientation(NodeOrientation orientation) {
        nodeOrientationProperty().set(orientation);
    }

    public final NodeOrientation getNodeOrientation() {
        return nodeOrientation == null ? defaultNodeOrientation : nodeOrientation.get();
    }

    /**
     * Property holding NodeOrientation.
     * &lt;p&gt;
     * Node orientation describes the flow of visual data within a node.
     * In the English speaking world, visual data normally flows from
     * left-to-right. In an Arabic or Hebrew world, visual data flows
     * from right-to-left.  This is consistent with the reading order
     * of text in both worlds.  The default value is left-to-right.
     * &lt;/p&gt;
     *
     * @return NodeOrientation
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;NodeOrientation&gt; nodeOrientationProperty() {
        if (nodeOrientation == null) {
            nodeOrientation = new StyleableObjectProperty&lt;NodeOrientation&gt;(defaultNodeOrientation) {
                @Override
                protected void invalidated() {
                    sceneEffectiveOrientationInvalidated();
                    getRoot().applyCss();
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;nodeOrientation&quot;;
                }

                @Override
                public CssMetaData getCssMetaData() {
                    //TODO - not yet supported
                    throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
                }
            };
        }
        return nodeOrientation;
    }

    public final NodeOrientation getEffectiveNodeOrientation() {
        if (effectiveNodeOrientation == null) {
            effectiveNodeOrientation = calcEffectiveNodeOrientation();
        }

        return effectiveNodeOrientation;
    }

    /**
     * The effective node orientation of a scene resolves the inheritance of
     * node orientation, returning either left-to-right or right-to-left.
     * @return the effective node orientation of this scene
     * @since JavaFX 8.0
     */
    public final ReadOnlyObjectProperty&lt;NodeOrientation&gt;
            effectiveNodeOrientationProperty() {
        if (effectiveNodeOrientationProperty == null) {
            effectiveNodeOrientationProperty =
                    new EffectiveOrientationProperty();
        }

        return effectiveNodeOrientationProperty;
    }

    private void parentEffectiveOrientationInvalidated() {
        if (getNodeOrientation() == NodeOrientation.INHERIT) {
            sceneEffectiveOrientationInvalidated();
        }
    }

    private void sceneEffectiveOrientationInvalidated() {
        effectiveNodeOrientation = null;

        if (effectiveNodeOrientationProperty != null) {
            effectiveNodeOrientationProperty.invalidate();
        }

        getRoot().parentResolvedOrientationInvalidated();
    }

    private NodeOrientation calcEffectiveNodeOrientation() {
        NodeOrientation orientation = getNodeOrientation();
        if (orientation == NodeOrientation.INHERIT) {
            Window window = getWindow();
            if (window != null) {
                Window parent = null;
                if (window instanceof Stage) {
                    parent = ((Stage)window).getOwner();
                } else {
                    if (window instanceof PopupWindow) {
                        parent = ((PopupWindow)window).getOwnerWindow();
                    }
                }
                if (parent != null) {
                    Scene scene = parent.getScene();
                    if (scene != null) return scene.getEffectiveNodeOrientation();
                }
            }
            return NodeOrientation.LEFT_TO_RIGHT;
        }
        return orientation;
    }

    private final class EffectiveOrientationProperty
            extends ReadOnlyObjectPropertyBase&lt;NodeOrientation&gt; {
        @Override
        public NodeOrientation get() {
            return getEffectiveNodeOrientation();
        }

        @Override
        public Object getBean() {
            return Scene.this;
        }

        @Override
        public String getName() {
            return &quot;effectiveNodeOrientation&quot;;
        }

        public void invalidate() {
            fireValueChangedEvent();
        }
    }

    private Map&lt;Node, Accessible&gt; accMap;
    Accessible removeAccessible(Node node) {
        if (accMap == null) return null;
        return accMap.remove(node);
    }

    void addAccessible(Node node, Accessible acc) {
        if (accMap == null) {
            accMap = new HashMap&lt;Node, Accessible&gt;();
        }
        accMap.put(node, acc);
    }

    private void disposeAccessibles() {
        if (accMap != null) {
            for (Map.Entry&lt;Node, Accessible&gt; entry : accMap.entrySet()) {
                Node node = entry.getKey();
                Accessible acc = entry.getValue();
                if (node.accessible != null) {
                    /* This node has already been initialized to another scene.
                     * Note an accessible can be returned to the node before the
                     * pulse if getAccessible() is called. In which case it must
                     * already being removed from accMap.
                     */
                    if (node.accessible == acc) {
                        System.err.println(&quot;[A11y] 'node.accessible == acc' should never happen.&quot;);
                    }
                    if (node.getScene() == this) {
                        System.err.println(&quot;[A11y] 'node.getScene() == this' should never happen.&quot;);
                    }
                    acc.dispose();
                } else {
                    if (node.getScene() == this) {
                        node.accessible = acc;
                    } else {
                        acc.dispose();
                    }
                }
            }
            accMap.clear();
        }
    }

    private Accessible accessible;
    Accessible getAccessible() {
        /*
         * The accessible for the Scene should never be
         * requested when the peer is not set.
         * This can only happen in a error case where a
         * descender of this Scene was not disposed and
         * it still being used by the AT client and trying
         * to reach to the top level window.
         */
        if (peer == null) return null;
        if (accessible == null) {
            accessible = Application.GetApplication().createAccessible();
            accessible.setEventHandler(new Accessible.EventHandler() {
                @Override public AccessControlContext getAccessControlContext() {
                    return getPeer().getAccessControlContext();
                }

                @Override public Object getAttribute(AccessibleAttribute attribute,
                                                     Object... parameters) {
                    switch (attribute) {
                        case CHILDREN: {
                            Parent root = getRoot();
                            if (root != null) {
                                return FXCollections.observableArrayList(root);
                            }
                            break;
                        }
                        case TEXT: {
                            Window w = getWindow();
                            if (w instanceof Stage) {
                                return ((Stage)w).getTitle();
                            }
                            break;
                        }
                        case NODE_AT_POINT: {
                            Window window = getWindow();
                            /* is this screen to scene translation correct ? not considering camera ? */
                            Point2D pt = (Point2D)parameters[0];
                            PickResult res = pick(pt.getX() - getX() - window.getX(), pt.getY() - getY() - window.getY());
                            if (res != null) {
                                Node node = res.getIntersectedNode();
                                if (node != null) return node;
                            }
                            return getRoot();//not sure
                        }
                        case ROLE: return AccessibleRole.PARENT;
                        case SCENE: return Scene.this;
                        case FOCUS_NODE: {
                            if (transientFocusContainer != null) {
                                return transientFocusContainer.queryAccessibleAttribute(AccessibleAttribute.FOCUS_NODE);
                            }
                            return getFocusOwner();
                        }
                        default:
                    }
                    return super.getAttribute(attribute, parameters);
                }
            });
            PlatformImpl.accessibilityActiveProperty().set(true);
        }
        return accessible;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.media/com/sun/media/jfxmedia/MediaError.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.jfxmedia;

import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;

public enum MediaError {

    ERROR_BASE_MEDIA(0x00000100),
    ERROR_BASE_MANAGER(0x00000200),
    ERROR_BASE_PIPELINE(0x00000300),
    ERROR_BASE_FACTORY(0x00000400),
    ERROR_BASE_LOCATOR(0x00000500),
    ERROR_BASE_REGISTRY(0x00000600),
    ERROR_BASE_GSTREAMER(0x00000800),
    ERROR_BASE_SYSTEM(0x00000A00),
    ERROR_BASE_FUNCTION(0x00000B00),
    ERROR_BASE_JNI(0x00000C00),       // JNI upcall from native into Java
<A NAME="16"></A>    ERROR_BASE_OSX(0x00000D00),

    WARNING_BASE_JFXMEDIA(0x00100000),
    <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#16',2,'match52-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>WARNING_BASE_GSTREAMER(0x00800000),
    WARNING_BASE_GLIB(0x00900000),

    ERROR_MASK_BASE(0x00000F00),
    WARNING_MASK_BASE(0x00F00000),

    ERROR_NONE(0x0),

    ERROR_MANAGER_NULL(ERROR_BASE_MANAGER.code()+0x0001),
    ERROR_MANAGER_CREATION(ERROR_BASE_MANAGER.code()+0x0002),</B></FONT>
    ERROR_MANAGER_ENGINEINIT_FAIL(ERROR_BASE_MANAGER.code()+0x0003),
    ERROR_MANAGER_RUNLOOP_FAIL(ERROR_BASE_MANAGER.code()+0x0004),
    ERROR_MANAGER_LOGGER_INIT(ERROR_BASE_MANAGER.code()+0x0005),

    ERROR_MEDIA_NULL(ERROR_BASE_MEDIA.code()+0x0001),
    ERROR_MEDIA_CREATION(ERROR_BASE_MEDIA.code()+0x0002),
    ERROR_MEDIA_UNKNOWN_PIXEL_FORMAT(ERROR_BASE_MEDIA.code()+0x0003),
    ERROR_MEDIA_INVALID(ERROR_BASE_MEDIA.code()+0x0004),
    ERROR_MEDIA_MARKER_NAME_NULL(ERROR_BASE_MEDIA.code()+0x0005),
    ERROR_MEDIA_MARKER_TIME_NEGATIVE(ERROR_BASE_MEDIA.code()+0x0006),
    ERROR_MEDIA_MARKER_MAP_NULL(ERROR_BASE_MEDIA.code()+0x0007),
    ERROR_MEDIA_VIDEO_FORMAT_UNSUPPORTED(ERROR_BASE_MEDIA.code()+0x0008),
    ERROR_MEDIA_AUDIO_FORMAT_UNSUPPORTED(ERROR_BASE_MEDIA.code()+0x0009),
    ERROR_MEDIA_MP3_FORMAT_UNSUPPORTED(ERROR_BASE_MEDIA.code()+0x000A),
    ERROR_MEDIA_AAC_FORMAT_UNSUPPORTED(ERROR_BASE_MEDIA.code()+0x000B),
    ERROR_MEDIA_H264_FORMAT_UNSUPPORTED(ERROR_BASE_MEDIA.code()+0x000C),
    ERROR_MEDIA_HLS_FORMAT_UNSUPPORTED(ERROR_BASE_MEDIA.code()+0x000D),
    ERROR_MEDIA_CORRUPTED(ERROR_BASE_MEDIA.code()+0x000E),

    ERROR_PIPELINE_NULL(ERROR_BASE_PIPELINE.code()+0x0001),
    ERROR_PIPELINE_CREATION(ERROR_BASE_PIPELINE.code()+0x0002),
    ERROR_PIPELINE_NO_FRAME_QUEUE(ERROR_BASE_PIPELINE.code()+0x0003),

    ERROR_FACTORY_NULL(ERROR_BASE_FACTORY.code()+0x0001),
    ERROR_FACTORY_CONTAINER_CREATION(ERROR_BASE_FACTORY.code()+0x0002),
    ERROR_FACTORY_INVALID_URI(ERROR_BASE_FACTORY.code()+0x0003),

    ERROR_LOCATOR_NULL(ERROR_BASE_LOCATOR.code()+0x0001),
    ERROR_LOCATOR_UNSUPPORTED_TYPE(ERROR_BASE_LOCATOR.code()+0x0002),
    ERROR_LOCATOR_UNSUPPORTED_MEDIA_FORMAT(ERROR_BASE_LOCATOR.code()+0x0003),
    ERROR_LOCATOR_CONNECTION_LOST(ERROR_BASE_LOCATOR.code()+0x0004),
    ERROR_LOCATOR_CONTENT_TYPE_NULL(ERROR_BASE_LOCATOR.code()+0x0005),

    ERROR_REGISTRY_NULL(ERROR_BASE_REGISTRY.code()+0x0001),
    ERROR_REGISTRY_PLUGIN_ALREADY_EXIST(ERROR_BASE_REGISTRY.code()+0x0002),
    ERROR_REGISTRY_PLUGIN_PATH(ERROR_BASE_REGISTRY.code()+0x0003),
    ERROR_REGISTRY_NO_MATCHING_RECIPE(ERROR_BASE_REGISTRY.code()+0x0004),

    ERROR_GSTREAMER_ERROR(ERROR_BASE_GSTREAMER.code()+0x0001),
    ERROR_GSTREAMER_PIPELINE_CREATION(ERROR_BASE_GSTREAMER.code()+0x0002),
    ERROR_GSTREAMER_AUDIO_DECODER_SINK_PAD(ERROR_BASE_GSTREAMER.code()+0x0003),
    ERROR_GSTREAMER_AUDIO_DECODER_SRC_PAD(ERROR_BASE_GSTREAMER.code()+0x0004),
    ERROR_GSTREAMER_AUDIO_SINK_SINK_PAD(ERROR_BASE_GSTREAMER.code()+0x0005),
    ERROR_GSTREAMER_VIDEO_DECODER_SINK_PAD(ERROR_BASE_GSTREAMER.code()+0x0006),
    ERROR_GSTREAMER_PIPELINE_STATE_CHANGE(ERROR_BASE_GSTREAMER.code()+0x0007),
    ERROR_GSTREAMER_PIPELINE_SEEK(ERROR_BASE_GSTREAMER.code()+0x0008),
    ERROR_GSTREAMER_PIPELINE_QUERY_LENGTH(ERROR_BASE_GSTREAMER.code()+0x0009),
    ERROR_GSTREAMER_PIPELINE_QUERY_POS(ERROR_BASE_GSTREAMER.code()+0x000A),
    ERROR_GSTREAMER_PIPELINE_METADATA_TYPE(ERROR_BASE_GSTREAMER.code()+0x000B),
    ERROR_GSTREAMER_AUDIO_SINK_CREATE(ERROR_BASE_GSTREAMER.code()+0x000C),
    ERROR_GSTREAMER_GET_BUFFER_SRC_PAD(ERROR_BASE_GSTREAMER.code()+0x000D),
    ERROR_GSTREAMER_CREATE_GHOST_PAD(ERROR_BASE_GSTREAMER.code()+0x000E),
    ERROR_GSTREAMER_ELEMENT_ADD_PAD(ERROR_BASE_GSTREAMER.code()+0x000F),
    ERROR_GSTREAMER_UNSUPPORTED_PROTOCOL(ERROR_BASE_GSTREAMER.code()+0x0010),
    ERROR_GSTREAMER_SOURCEFILE_NONEXISTENT(ERROR_BASE_GSTREAMER.code()+0x0020),
    ERROR_GSTREAMER_SOURCEFILE_NONREGULAR(ERROR_BASE_GSTREAMER.code()+0x0030),
    ERROR_GSTREAMER_ELEMENT_LINK(ERROR_BASE_GSTREAMER.code()+0x0040),
    ERROR_GSTREAMER_ELEMENT_LINK_AUDIO_BIN(ERROR_BASE_GSTREAMER.code()+0x0050),
    ERROR_GSTREAMER_ELEMENT_LINK_VIDEO_BIN(ERROR_BASE_GSTREAMER.code()+0x0060),
    ERROR_GSTREAMER_ELEMENT_CREATE(ERROR_BASE_GSTREAMER.code()+0x0070),
    ERROR_GSTREAMER_VIDEO_SINK_CREATE(ERROR_BASE_GSTREAMER.code()+0x0080),
    ERROR_GSTREAMER_BIN_CREATE(ERROR_BASE_GSTREAMER.code()+0x0090),
    ERROR_GSTREAMER_BIN_ADD_ELEMENT(ERROR_BASE_GSTREAMER.code()+0x00A0),
    ERROR_GSTREAMER_ELEMENT_GET_PAD(ERROR_BASE_GSTREAMER.code()+0x00B0),
    ERROR_GSTREAMER_MAIN_LOOP_CREATE(ERROR_BASE_GSTREAMER.code()+0x00C0),
    ERROR_GSTREAMER_BUS_SOURCE_ATTACH(ERROR_BASE_GSTREAMER.code()+0x00C1),
    ERROR_GSTREAMER_PIPELINE_SET_RATE_ZERO(ERROR_BASE_GSTREAMER.code()+0x00D0),
    ERROR_GSTREAMER_VIDEO_SINK_SINK_PAD(ERROR_BASE_GSTREAMER.code()+0x00E0),

    ERROR_NOT_IMPLEMENTED(ERROR_BASE_SYSTEM.code()+0x0001),
    ERROR_MEMORY_ALLOCATION(ERROR_BASE_SYSTEM.code()+0x0002),
    ERROR_OS_UNSUPPORTED(ERROR_BASE_SYSTEM.code()+0x0003),
    ERROR_PLATFORM_UNSUPPORTED(ERROR_BASE_SYSTEM.code()+0x0004),

    ERROR_FUNCTION_PARAM(ERROR_BASE_FUNCTION.code()+0x0001),
    ERROR_FUNCTION_PARAM_NULL(ERROR_BASE_FUNCTION.code()+0x0002),

    ERROR_JNI_SEND_PLAYER_MEDIA_ERROR_EVENT(ERROR_BASE_JNI.code()+0x0001),
    ERROR_JNI_SEND_PLAYER_HALT_EVENT(ERROR_BASE_JNI.code()+0x0002),
    ERROR_JNI_SEND_PLAYER_STATE_EVENT(ERROR_BASE_JNI.code()+0x0003),
    ERROR_JNI_SEND_NEW_FRAME_EVENT(ERROR_BASE_JNI.code()+0x0004),
    ERROR_JNI_SEND_FRAME_SIZE_CHANGED_EVENT(ERROR_BASE_JNI.code()+0x0005),
    ERROR_JNI_SEND_END_OF_MEDIA_EVENT(ERROR_BASE_JNI.code()+0x0006),
    ERROR_JNI_SEND_AUDIO_TRACK_EVENT(ERROR_BASE_JNI.code()+0x0007),
    ERROR_JNI_SEND_VIDEO_TRACK_EVENT(ERROR_BASE_JNI.code()+0x0008),
    ERROR_JNI_SEND_METADATA_EVENT(ERROR_BASE_JNI.code()+0x0009),
    ERROR_JNI_SEND_MARKER_EVENT(ERROR_BASE_JNI.code()+0x000A),
    ERROR_JNI_SEND_BUFFER_PROGRESS_EVENT(ERROR_BASE_JNI.code()+0x000B),
    ERROR_JNI_SEND_STOP_REACHED_EVENT(ERROR_BASE_JNI.code()+0x000C),
    ERROR_JNI_SEND_DURATION_UPDATE_EVENT(ERROR_BASE_JNI.code()+0x000D),
    ERROR_JNI_SEND_AUDIO_SPECTRUM_EVENT(ERROR_BASE_JNI.code()+0x000E),

    ERROR_OSX_INIT(ERROR_BASE_OSX.code() + 0x0001),

    WARNING_JFXMEDIA_BALANCE(WARNING_BASE_JFXMEDIA.code() + 0x0001),

    WARNING_GSTREAMER_WARNING(WARNING_BASE_GSTREAMER.code()+0x0001),
    WARNING_GSTREAMER_PIPELINE_ERROR(WARNING_BASE_GSTREAMER.code()+0x0002),
    WARNING_GSTREAMER_PIPELINE_WARNING(WARNING_BASE_GSTREAMER.code()+0x0003),
    WARNING_GSTREAMER_PIPELINE_STATE_EVENT(WARNING_BASE_GSTREAMER.code()+0x0004),
    WARNING_GSTREAMER_PIPELINE_FRAME_SIZE(WARNING_BASE_GSTREAMER.code()+0x0005),
    WARNING_GSTREAMER_INVALID_FRAME(WARNING_BASE_GSTREAMER.code()+0x0006),
    WARNING_GSTREAMER_PIPELINE_INFO_ERROR(WARNING_BASE_GSTREAMER.code()+0x0007),
    WARNING_GSTREAMER_AUDIO_BUFFER_FIELD(WARNING_BASE_GSTREAMER.code()+0x0008);

    private static ResourceBundle bundle;
    private static final Map&lt;Integer, MediaError&gt; map = new HashMap&lt;Integer, MediaError&gt;();

    static {
        try {
            bundle = ResourceBundle.getBundle(&quot;MediaErrors&quot;, Locale.getDefault());
        } catch(MissingResourceException e) {
            bundle = null;
        }

        for (MediaError error : MediaError.values()) {
            map.put(error.code(), error);
        }
    }

    private int    code;
    private String description;

    private MediaError(int code) {
        this.code = code;
    }

    public int code() {
        return code;
    }

    public String description() {
        if (description == null) {
            String errorName = name();
            if (bundle != null) {
                try {
                    description = bundle.getString(errorName);
                } catch (MissingResourceException e) {
                    description = errorName;
                }
            } else {
                description = errorName;
            }
        }
        return description;
    }

    public static MediaError getFromCode(int code) {
        return map.get(code);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.media/com/sun/media/jfxmedia/locator/HLSConnectionHolder.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.media.jfxmedia.locator;

import com.sun.media.jfxmedia.MediaError;
import com.sun.media.jfxmediaimpl.MediaUtils;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.*;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;

final class HLSConnectionHolder extends ConnectionHolder {

    private URLConnection urlConnection = null;
    private PlaylistThread playlistThread = new PlaylistThread();
    private VariantPlaylist variantPlaylist = null;
    private Playlist currentPlaylist = null;
    private int mediaFileIndex = -1;
    private CountDownLatch readySignal = new CountDownLatch(1);
    private Semaphore liveSemaphore = new Semaphore(0);
    private boolean isPlaylistClosed = false;
    private boolean isBitrateAdjustable = false;
    private long startTime = -1;
    private static final long HLS_VALUE_FLOAT_MULTIPLIER = 1000;
    private static final int HLS_PROP_GET_DURATION = 1;
    private static final int HLS_PROP_GET_HLS_MODE = 2;
    private static final int HLS_PROP_GET_MIMETYPE = 3;
    private static final int HLS_VALUE_MIMETYPE_MP2T = 1;
    private static final int HLS_VALUE_MIMETYPE_MP3 = 2;
    private static final String CHARSET_UTF_8 = &quot;UTF-8&quot;;
    private static final String CHARSET_US_ASCII = &quot;US-ASCII&quot;;

    HLSConnectionHolder(URI uri) throws IOException {
        playlistThread.setPlaylistURI(uri);
        init();
    }

    private void init() {
        playlistThread.putState(PlaylistThread.STATE_INIT);
        playlistThread.start();
    }

    @Override
    public int readNextBlock() throws IOException {
        if (isBitrateAdjustable &amp;&amp; startTime == -1) {
            startTime = System.currentTimeMillis();
        }

        int read = super.readNextBlock();
        if (isBitrateAdjustable &amp;&amp; read == -1) {
            long readTime = System.currentTimeMillis() - startTime;
            startTime = -1;
            adjustBitrate(readTime);
        }

        return read;
    }

    int readBlock(long position, int size) throws IOException {
        throw new IOException();
    }

    boolean needBuffer() {
        return true;
    }

    boolean isSeekable() {
        return true;
    }

    boolean isRandomAccess() {
        return false; // Only by segments
    }

    public long seek(long position) {
        try {
            readySignal.await();
        } catch (Exception e) {
            return -1;
        }

        return (long) (currentPlaylist.seek(position) * HLS_VALUE_FLOAT_MULTIPLIER);
    }

    @Override
    public void closeConnection() {
        currentPlaylist.close();
        super.closeConnection();
        resetConnection();
        playlistThread.putState(PlaylistThread.STATE_EXIT);
    }

    @Override
    int property(int prop, int value) {
        try {
            readySignal.await();
        } catch (Exception e) {
            return -1;
        }

        if (prop == HLS_PROP_GET_DURATION) {
            return (int) (currentPlaylist.getDuration() * HLS_VALUE_FLOAT_MULTIPLIER);
        } else if (prop == HLS_PROP_GET_HLS_MODE) {
            return 1;
        } else if (prop == HLS_PROP_GET_MIMETYPE) {
            return currentPlaylist.getMimeType();
        }

        return -1;
    }

    @Override
    int getStreamSize() {
        try {
            readySignal.await();
        } catch (Exception e) {
            return -1;
        }

        return loadNextSegment();
    }

    private void resetConnection() {
        super.closeConnection();

        Locator.closeConnection(urlConnection);
        urlConnection = null;
    }

    // Returns -1 EOS or critical error
    // Returns positive size of segment if no isssues.
    // Returns negative size of segment if discontinuity.
    private int loadNextSegment() {
        resetConnection();

        String mediaFile = currentPlaylist.getNextMediaFile();
        if (mediaFile == null) {
            return -1;
        }

        try {
            URI uri = new URI(mediaFile);
            urlConnection = uri.toURL().openConnection();
            channel = openChannel();
        } catch (Exception e) {
            return -1;
        }

        if (currentPlaylist.isCurrentMediaFileDiscontinuity()) {
            return (-1 * urlConnection.getContentLength());
        } else {
            return urlConnection.getContentLength();
        }
    }

    private ReadableByteChannel openChannel() throws IOException {
        return Channels.newChannel(urlConnection.getInputStream());
    }

    private void adjustBitrate(long readTime) {
        int avgBitrate = (int)(((long) urlConnection.getContentLength() * 8 * 1000) / readTime);

        Playlist playlist = variantPlaylist.getPlaylistBasedOnBitrate(avgBitrate);
        if (playlist != null &amp;&amp; playlist != currentPlaylist) {
            if (currentPlaylist.isLive()) {
                playlist.update(currentPlaylist.getNextMediaFile());
                playlistThread.setReloadPlaylist(playlist);
            }

            playlist.setForceDiscontinuity(true);
            currentPlaylist = playlist;
        }
    }

    private static String stripParameters(String mediaFile) {
        int qp = mediaFile.indexOf('?');
        if (qp &gt; 0) {
            mediaFile = mediaFile.substring(0, qp); // Strip all possible http parameters.
        }
        return mediaFile;
    }

    private class PlaylistThread extends Thread {

        public static final int STATE_INIT = 0;
        public static final int STATE_EXIT = 1;
        public static final int STATE_RELOAD_PLAYLIST = 2;
        private BlockingQueue&lt;Integer&gt; stateQueue = new LinkedBlockingQueue&lt;Integer&gt;();
        private URI playlistURI = null;
        private Playlist reloadPlaylist = null;
        private final Object reloadLock = new Object();
        private volatile boolean stopped = false;

        private PlaylistThread() {
            setName(&quot;JFXMedia HLS Playlist Thread&quot;);
            setDaemon(true);
        }

        private void setPlaylistURI(URI playlistURI) {
            this.playlistURI = playlistURI;
        }

        private void setReloadPlaylist(Playlist playlist) {
            synchronized(reloadLock) {
                reloadPlaylist = playlist;
            }
        }

        @Override
        public void run() {
            while (!stopped) {
                try {
                    int state = stateQueue.take();
                    switch (state) {
                        case STATE_INIT:
                            stateInit();
                            break;
                        case STATE_EXIT:
                            stopped = true;
                            break;
                        case STATE_RELOAD_PLAYLIST:
                            stateReloadPlaylist();
                            break;
                        default:
                            break;
                    }
                } catch (Exception e) {
                }
            }
        }

        private void putState(int state) {
            if (stateQueue != null) {
                try {
                    stateQueue.put(state);
                } catch (InterruptedException ex) {
                }
            }
        }

        private void stateInit() {
            if (playlistURI == null) {
                return;
            }

            PlaylistParser parser = new PlaylistParser();
            parser.load(playlistURI);

            if (parser.isVariantPlaylist()) {
                variantPlaylist = new VariantPlaylist(playlistURI);

                while (parser.hasNext()) {
                    variantPlaylist.addPlaylistInfo(parser.getString(), parser.getInteger());
                }
            } else {
                if (currentPlaylist == null) {
                    currentPlaylist = new Playlist(parser.isLivePlaylist(), parser.getTargetDuration());
                    currentPlaylist.setPlaylistURI(playlistURI);
                }

                if (currentPlaylist.setSequenceNumber(parser.getSequenceNumber())) {
                    while (parser.hasNext()) {
                        currentPlaylist.addMediaFile(parser.getString(), parser.getDouble(), parser.getBoolean());
                    }
                }

                if (variantPlaylist != null) {
                    variantPlaylist.addPlaylist(currentPlaylist);
                }
            }

            // Update variant playlists
            if (variantPlaylist != null) {
                while (variantPlaylist.hasNext()) {
                    try {
                        currentPlaylist = new Playlist(variantPlaylist.getPlaylistURI());
                        currentPlaylist.update(null);
                        variantPlaylist.addPlaylist(currentPlaylist);
                    } catch (URISyntaxException e) {
                    } catch (MalformedURLException e) {
                    }
                }
            }

            // Always start with first data playlist
            if (variantPlaylist != null) {
                currentPlaylist = variantPlaylist.getPlaylist(0);
                isBitrateAdjustable = true;
            }

            // Start reloading live playlist
            if (currentPlaylist.isLive()) {
                setReloadPlaylist(currentPlaylist);
                putState(STATE_RELOAD_PLAYLIST);
            }

            readySignal.countDown();
        }

        private void stateReloadPlaylist() {
            try {
                long timeout;
                synchronized(reloadLock) {
                    timeout = reloadPlaylist.getTargetDuration() / 2;
                }
                Thread.sleep(timeout);
            } catch (InterruptedException ex) {
                return;
            }

            synchronized(reloadLock) {
                reloadPlaylist.update(null);
<A NAME="25"></A>            }

            putState(STATE_RELOAD_PLAYLIST);
        <FONT color="#87f717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#25',2,'match52-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
    }

    private static class PlaylistParser {

        private boolean isFirstLine = true;
        private boolean isLineMediaFileURI = false;
        private boolean isEndList = false;
        private boolean isLinePlaylistURI = false;
        private boolean isVariantPlaylist = false;
        private boolean isDiscontinuity = false;
        private int targetDuration = 0;
        private int sequenceNumber = 0;
        private int dataListIndex = -1;
        private List&lt;String&gt; dataListString = new ArrayList&lt;String&gt;();
        private List&lt;Integer&gt; dataListInteger = new ArrayList&lt;Integer&gt;();
        private List&lt;Double&gt; dataListDouble = new ArrayList&lt;Double&gt;()</B></FONT>;
        private List&lt;Boolean&gt; dataListBoolean = new ArrayList&lt;Boolean&gt;();

        private void load(URI uri) {
            HttpURLConnection connection = null;
            BufferedReader reader = null;
            try {
                connection = (HttpURLConnection) uri.toURL().openConnection();
                connection.setRequestMethod(&quot;GET&quot;);

                if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {
                    MediaUtils.error(this, MediaError.ERROR_LOCATOR_CONNECTION_LOST.code(), &quot;HTTP responce code: &quot; + connection.getResponseCode(), null);
                }

                Charset charset = getCharset(uri.toURL().toExternalForm(), connection.getContentType());
                if (charset != null) {
                    reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), charset));
                }

                if (reader != null) {
                    boolean result;
                    do {
                        result = parseLine(reader.readLine());
                    } while (result);
                }
            } catch (MalformedURLException e) {
            } catch (IOException e) {
            } finally {
                if (reader != null) {
                    try {
                        reader.close();
                    } catch (IOException e) {}

                    Locator.closeConnection(connection);
                }
            }
        }

        private boolean isVariantPlaylist() {
            return isVariantPlaylist;
        }

        private boolean isLivePlaylist() {
            return !isEndList;
        }

        private int getTargetDuration() {
            return targetDuration;
        }

        private int getSequenceNumber() {
            return sequenceNumber;
        }

        private boolean hasNext() {
            dataListIndex++;
            if (dataListString.size() &gt; dataListIndex || dataListInteger.size() &gt; dataListIndex || dataListDouble.size() &gt; dataListIndex || dataListBoolean.size() &gt; dataListIndex) {
                return true;
            } else {
                return false;
            }
        }

        private String getString() {
            return dataListString.get(dataListIndex);
        }

        private Integer getInteger() {
            return dataListInteger.get(dataListIndex);
        }

        private Double getDouble() {
            return dataListDouble.get(dataListIndex);
        }

        private Boolean getBoolean() {
            return dataListBoolean.get(dataListIndex);
        }

        private boolean parseLine(String line) {
            if (line == null) {
                return false;
            }

            // First line of playlist must be &quot;#EXTM3U&quot;
            if (isFirstLine) {
                if (line.compareTo(&quot;#EXTM3U&quot;) != 0) {
                    return false;
                }

                isFirstLine = false;
                return true;
            }

            // Ignore blank lines and comments
            if (line.isEmpty() || (line.startsWith(&quot;#&quot;) &amp;&amp; !line.startsWith(&quot;#EXT&quot;))) {
                return true;
            }

            if (line.startsWith(&quot;#EXTINF&quot;)) { // #EXTINF
                //#EXTINF:&lt;duration&gt;,&lt;title&gt;
                String[] s1 = line.split(&quot;:&quot;);
                if (s1.length == 2 &amp;&amp; s1[1].length() &gt; 0) {
                    String[] s2 = s1[1].split(&quot;,&quot;);
                    if (s2.length &gt;= 1) { // We have duration
                        dataListDouble.add(Double.parseDouble(s2[0]));
                    }
                }

                isLineMediaFileURI = true;
            } else if (line.startsWith(&quot;#EXT-X-TARGETDURATION&quot;)) {
                // #EXT-X-TARGETDURATION:&lt;s&gt;
                String[] s1 = line.split(&quot;:&quot;);
                if (s1.length == 2 &amp;&amp; s1[1].length() &gt; 0) {
                    targetDuration = Integer.parseInt(s1[1]);
                }
            } else if (line.startsWith(&quot;#EXT-X-MEDIA-SEQUENCE&quot;)) {
                // #EXT-X-MEDIA-SEQUENCE:&lt;number&gt;
                String[] s1 = line.split(&quot;:&quot;);
                if (s1.length == 2 &amp;&amp; s1[1].length() &gt; 0) {
                    sequenceNumber = Integer.parseInt(s1[1]);
                }
            } else if (line.startsWith(&quot;#EXT-X-STREAM-INF&quot;)) {
                // #EXT-X-STREAM-INF:&lt;attribute-list&gt;
                isVariantPlaylist = true;

                int bitrate = 0;
                String[] s1 = line.split(&quot;:&quot;);
                if (s1.length == 2 &amp;&amp; s1[1].length() &gt; 0) {
                    String[] s2 = s1[1].split(&quot;,&quot;);
                    if (s2.length &gt; 0) {
                        for (int i = 0; i &lt; s2.length; i++) {
                            s2[i] = s2[i].trim();
                            if (s2[i].startsWith(&quot;BANDWIDTH&quot;)) {
                                String[] s3 = s2[i].split(&quot;=&quot;);
                                if (s3.length == 2 &amp;&amp; s3[1].length() &gt; 0) {
                                    bitrate = Integer.parseInt(s3[1]);
                                }
                            }
                        }
                    }
                }

                if (bitrate &lt; 1) {
                    return false;
                }

                dataListInteger.add(bitrate);

                isLinePlaylistURI = true; // Next line will be URI to playlist
            } else if (line.startsWith(&quot;#EXT-X-ENDLIST&quot;)) { // #EXT-X-ENDLIST
                isEndList = true;
            } else if (line.startsWith(&quot;#EXT-X-DISCONTINUITY&quot;)) { // #EXT-X-DISCONTINUITY
                isDiscontinuity = true;
            } else if (isLinePlaylistURI) {
                isLinePlaylistURI = false;
                dataListString.add(line);
            } else if (isLineMediaFileURI) {
                isLineMediaFileURI = false;
                dataListString.add(line);
                dataListBoolean.add(isDiscontinuity);
                isDiscontinuity = false;
            }

            return true;
        }

        private Charset getCharset(String url, String mimeType) {
            if ((url != null &amp;&amp; stripParameters(url).endsWith(&quot;.m3u8&quot;)) || (mimeType != null &amp;&amp; mimeType.equals(&quot;application/vnd.apple.mpegurl&quot;))) {
                if (Charset.isSupported(CHARSET_UTF_8)) {
                    return Charset.forName(CHARSET_UTF_8);
                }
            } else if ((url != null &amp;&amp; stripParameters(url).endsWith(&quot;.m3u&quot;)) || (mimeType != null &amp;&amp; mimeType.equals(&quot;audio/mpegurl&quot;))) {
                if (Charset.isSupported(CHARSET_US_ASCII)) {
                    return Charset.forName(CHARSET_US_ASCII);
                }
            }

            return null;
        }
    }

    private static class VariantPlaylist {

        private URI playlistURI = null;
        private int infoIndex = -1;
        private List&lt;String&gt; playlistsLocations = new ArrayList&lt;String&gt;();
        private List&lt;Integer&gt; playlistsBitrates = new ArrayList&lt;Integer&gt;();
        private List&lt;Playlist&gt; playlists = new ArrayList&lt;Playlist&gt;();
        private String mediaFileExtension = null; // Will be set to media file extension of first playlist

        private VariantPlaylist(URI uri) {
            playlistURI = uri;
        }

        private void addPlaylistInfo(String location, int bitrate) {
            playlistsLocations.add(location);
            playlistsBitrates.add(bitrate);
        }

        private void addPlaylist(Playlist playlist) {
            if (mediaFileExtension == null) {
                mediaFileExtension = playlist.getMediaFileExtension();
            } else {
                if (!mediaFileExtension.equals(playlist.getMediaFileExtension())) {
                    playlistsLocations.remove(infoIndex);
                    playlistsBitrates.remove(infoIndex);
                    infoIndex--;
                    return; // Ignore playlist with different media type
                }
            }
            playlists.add(playlist);
        }

        private Playlist getPlaylist(int index) {
            if (playlists.size() &gt; index) {
                return playlists.get(index);
            } else {
                return null;
            }
        }

        private boolean hasNext() {
            infoIndex++;
            if (playlistsLocations.size() &gt; infoIndex &amp;&amp; playlistsBitrates.size() &gt; infoIndex) {
                return true;
            } else {
                return false;
            }
        }

        private URI getPlaylistURI() throws URISyntaxException, MalformedURLException {
            String location = playlistsLocations.get(infoIndex);
            if (location.startsWith(&quot;http://&quot;) || location.startsWith(&quot;https://&quot;)) {
                return new URI(location);
            } else {
                return new URI(playlistURI.toURL().toString().substring(0, playlistURI.toURL().toString().lastIndexOf(&quot;/&quot;) + 1) + location);
            }
        }

        private Playlist getPlaylistBasedOnBitrate(int bitrate) {
            int playlistIndex = -1;
            int playlistBitrate = 0;

            // Get bitrate that less then requested bitrate, but most closed to it
            for (int i = 0; i &lt; playlistsBitrates.size(); i++) {
                int b = playlistsBitrates.get(i);
                if (b &lt; bitrate) {
                    if (playlistIndex != -1) {
                        if (b &gt; playlistBitrate) {
                            playlistBitrate = b;
                            playlistIndex = i;
                        }
                    } else {
                        playlistIndex = i;
                    }
                }
            }

            // If we did not find one (stall), then get the lowest bitrate possible
            if (playlistIndex == -1) {
                for (int i = 0; i &lt; playlistsBitrates.size(); i++) {
                    int b = playlistsBitrates.get(i);
                    if (b &lt; playlistBitrate || playlistIndex == -1) {
                        playlistBitrate = b;
                        playlistIndex = i;
                    }
                }
            }

            // Just in case
            if (playlistIndex &lt; 0 || playlistIndex &gt;= playlists.size()) {
                return null;
             } else {
                return playlists.get(playlistIndex);
            }
        }
    }

    private class Playlist {

        private boolean isLive = false;
        private volatile boolean isLiveWaiting = false;
        private volatile boolean isLiveStop = false;
        private long targetDuration = 0;
        private URI playlistURI = null;
        private final Object lock = new Object();
        private List&lt;String&gt; mediaFiles = new ArrayList&lt;String&gt;();
        private List&lt;Double&gt; mediaFilesStartTimes = new ArrayList&lt;Double&gt;();
        private List&lt;Boolean&gt; mediaFilesDiscontinuities = new ArrayList&lt;Boolean&gt;();
        private boolean needBaseURI = true;
        private String baseURI = null;
        private double duration = 0.0;
        private int sequenceNumber = -1;
        private int sequenceNumberStart = -1;
        private boolean sequenceNumberUpdated = false;
        private boolean forceDiscontinuity = false;

        private Playlist(boolean isLive, int targetDuration) {
            this.isLive = isLive;
            this.targetDuration = targetDuration * 1000;

            if (isLive) {
                duration = -1.0;
            }
        }

        private Playlist(URI uri) {
            playlistURI = uri;
        }

        private void update(String nextMediaFile) {
            PlaylistParser parser = new PlaylistParser();
            parser.load(playlistURI);

            isLive = parser.isLivePlaylist();
            targetDuration = parser.getTargetDuration() * 1000;

            if (isLive) {
                duration = -1.0;
            }

            if (setSequenceNumber(parser.getSequenceNumber())) {
                while (parser.hasNext()) {
                    addMediaFile(parser.getString(), parser.getDouble(), parser.getBoolean());
                }
            }

            if (nextMediaFile != null) {
                synchronized (lock) {
                    for (int i = 0; i &lt; mediaFiles.size(); i++) {
                        String mediaFile = mediaFiles.get(i);
                        if (nextMediaFile.endsWith(mediaFile)) {
                            mediaFileIndex = i - 1;
                            break;
                        }
                    }
                }
            }
        }

        private boolean isLive() {
            return isLive;
        }

        private long getTargetDuration() {
            return targetDuration;
        }

        private void setPlaylistURI(URI uri) {
            playlistURI = uri;
        }

        private void addMediaFile(String URI, double duration, boolean isDiscontinuity) {
            synchronized (lock) {

                if (needBaseURI) {
                    setBaseURI(playlistURI.toString(), URI);
                }

                if (isLive) {
                    if (sequenceNumberUpdated) {
                        int index = mediaFiles.indexOf(URI);
                        if (index != -1) {
                            for (int i = 0; i &lt; index; i++) {
                                mediaFiles.remove(0);
                                mediaFilesDiscontinuities.remove(0);
                                if (mediaFileIndex == -1) {
                                    forceDiscontinuity = true;
                                }
                                if (mediaFileIndex &gt;= 0) {
                                    mediaFileIndex--;
                                }
                            }
                        }
                        sequenceNumberUpdated = false;
                    }

                    if (mediaFiles.contains(URI)) {
                        return; // Nothing to add
                    }
                }

                mediaFiles.add(URI);
                mediaFilesDiscontinuities.add(isDiscontinuity);

                if (isLive) {
                    if (isLiveWaiting) {
                        liveSemaphore.release();
                    }
                } else {
                    mediaFilesStartTimes.add(this.duration);
                    this.duration += duration;
                }
            }
        }

        private String getNextMediaFile() {
            if (isLive) {
                synchronized (lock) {
                    isLiveWaiting = ((mediaFileIndex + 1) &gt;= mediaFiles.size());
                }
                if (isLiveWaiting) {
                    try {
                        liveSemaphore.acquire();
                        isLiveWaiting = false;
                        if (isLiveStop) {
                            isLiveStop = false;
                            return null;
                        }
                    } catch (InterruptedException e) {
                        isLiveWaiting = false;
                        return null;
                    }
                }
                if (isPlaylistClosed) {
                    return null;
                }
            }

            synchronized (lock) {
                mediaFileIndex++;
                if ((mediaFileIndex) &lt; mediaFiles.size()) {
                    if (baseURI != null) {
                        return baseURI + mediaFiles.get(mediaFileIndex);
                    } else {
                        return mediaFiles.get(mediaFileIndex);
                    }
                } else {
                    return null;
                }
            }
        }

        private double getDuration() {
            return duration;
        }

        private void setForceDiscontinuity(boolean value) {
            forceDiscontinuity = value;
        }

        private boolean isCurrentMediaFileDiscontinuity() {
            if (forceDiscontinuity) {
                forceDiscontinuity = false;
                return true;
            } else {
                return mediaFilesDiscontinuities.get(mediaFileIndex);
            }
        }

        private double seek(long time) {
            synchronized (lock) {
                if (isLive) {
                    if (time == 0) {
                        mediaFileIndex = -1;
                        if (isLiveWaiting) {
                            isLiveStop = true;
                            liveSemaphore.release();
                        }
                        return 0;
                    }
                } else {
                    time += targetDuration / 2000;

                    int mediaFileStartTimeSize = mediaFilesStartTimes.size();

                    for (int index = 0; index &lt; mediaFileStartTimeSize; index++) {
                        if (time &gt;= mediaFilesStartTimes.get(index)) {
                            if (index + 1 &lt; mediaFileStartTimeSize) {
                                if (time &lt; mediaFilesStartTimes.get(index + 1)) {
                                    mediaFileIndex = index - 1; // Seek will load segment and increment mediaFileIndex
                                    return mediaFilesStartTimes.get(index);
                                }
                            } else {
                                if ((time - targetDuration / 2000) &lt; duration) {
                                    mediaFileIndex = index - 1; // Seek will load segment and increment mediaFileIndex
                                    return mediaFilesStartTimes.get(index);
                                } else if (Double.compare(time - targetDuration / 2000, duration) == 0) {
                                    return duration;
                                }
                            }
                        }
                    }
                }
            }

            return -1;
        }

        private int getMimeType() {
            synchronized (lock) {
                if (mediaFiles.size() &gt; 0) {
                    if (stripParameters(mediaFiles.get(0)).endsWith(&quot;.ts&quot;)) {
                        return HLS_VALUE_MIMETYPE_MP2T;
                    } else if (stripParameters(mediaFiles.get(0)).endsWith(&quot;.mp3&quot;)) {
                        return HLS_VALUE_MIMETYPE_MP3;
                    }
                }
            }

            return -1;
        }

        private String getMediaFileExtension() {
            synchronized (lock) {
                if (mediaFiles.size() &gt; 0) {
                    String mediaFile = stripParameters(mediaFiles.get(0));
                    int index = mediaFile.lastIndexOf(&quot;.&quot;);
                    if (index != -1) {
                        return mediaFile.substring(index);
                    }
                }
            }

            return null;
        }

        private boolean setSequenceNumber(int value) {
            if (sequenceNumberStart == -1) {
                sequenceNumberStart = value;
            } else if (sequenceNumber != value) {
                sequenceNumberUpdated = true;
                sequenceNumber = value;
            } else {
                return false;
            }

            return true;
        }

        private void close() {
            if (isLive) {
                isPlaylistClosed = true;
                liveSemaphore.release();
            }
        }

        private void setBaseURI(String playlistURI, String URI) {
            if (!URI.startsWith(&quot;http://&quot;) &amp;&amp; !URI.startsWith(&quot;https://&quot;)) {
                baseURI = playlistURI.substring(0, playlistURI.lastIndexOf(&quot;/&quot;) + 1);
            }
            needBaseURI = false;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.media/com/sun/media/jfxmediaimpl/NativeMediaPlayer.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.jfxmediaimpl;

import java.lang.annotation.Native;
import com.sun.media.jfxmedia.Media;
import com.sun.media.jfxmedia.MediaError;
import com.sun.media.jfxmedia.MediaException;
import com.sun.media.jfxmedia.MediaPlayer;
import com.sun.media.jfxmedia.control.VideoRenderControl;
import com.sun.media.jfxmedia.effects.AudioEqualizer;
import com.sun.media.jfxmedia.effects.AudioSpectrum;
import com.sun.media.jfxmedia.events.AudioSpectrumEvent;
import com.sun.media.jfxmedia.events.AudioSpectrumListener;
import com.sun.media.jfxmedia.events.BufferListener;
import com.sun.media.jfxmedia.events.BufferProgressEvent;
import com.sun.media.jfxmedia.events.MarkerEvent;
import com.sun.media.jfxmedia.events.MarkerListener;
import com.sun.media.jfxmedia.events.MediaErrorListener;
import com.sun.media.jfxmedia.events.NewFrameEvent;
import com.sun.media.jfxmedia.events.PlayerEvent;
import com.sun.media.jfxmedia.events.PlayerStateEvent;
import com.sun.media.jfxmedia.events.PlayerStateEvent.PlayerState;
import com.sun.media.jfxmedia.events.PlayerStateListener;
import com.sun.media.jfxmedia.events.PlayerTimeListener;
import com.sun.media.jfxmedia.events.VideoFrameRateListener;
import com.sun.media.jfxmedia.events.VideoRendererListener;
import com.sun.media.jfxmedia.events.VideoTrackSizeListener;
import com.sun.media.jfxmedia.logging.Logger;
import com.sun.media.jfxmedia.track.AudioTrack;
import com.sun.media.jfxmedia.track.SubtitleTrack;
import com.sun.media.jfxmedia.track.Track;
import com.sun.media.jfxmedia.track.Track.Encoding;
import com.sun.media.jfxmedia.track.VideoResolution;
import com.sun.media.jfxmedia.track.VideoTrack;
import java.lang.ref.WeakReference;
import java.util.*;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Base implementation of a
 * &lt;code&gt;MediaPlayer&lt;/code&gt;.
 */
public abstract class NativeMediaPlayer implements MediaPlayer, MarkerStateListener {
    //***** Event IDs for PlayerStateEvent.  IDs sent from native JNI layer.

    @Native public final static int eventPlayerUnknown = 100;
    @Native public final static int eventPlayerReady = 101;
    @Native public final static int eventPlayerPlaying = 102;
    @Native public final static int eventPlayerPaused = 103;
    @Native public final static int eventPlayerStopped = 104;
    @Native public final static int eventPlayerStalled = 105;
    @Native public final static int eventPlayerFinished = 106;
    @Native public final static int eventPlayerError = 107;
    // Nominal video frames per second.
    @Native private static final int NOMINAL_VIDEO_FPS = 30;
    // Nanoseconds per second.
    @Native public static final long ONE_SECOND = 1000000000L;

    /**
     * The
     * &lt;code&gt;Media&lt;/code&gt; corresponding to the media source.
     */
    private NativeMedia media;
    private VideoRenderControl videoRenderControl;
    private final List&lt;WeakReference&lt;MediaErrorListener&gt;&gt; errorListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;PlayerStateListener&gt;&gt; playerStateListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; playerTimeListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; videoTrackSizeListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;VideoRendererListener&gt;&gt; videoUpdateListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; videoFrameRateListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;MarkerListener&gt;&gt; markerListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;BufferListener&gt;&gt; bufferListeners = new ArrayList&lt;&gt;();
    private final List&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; audioSpectrumListeners = new ArrayList&lt;&gt;();
    private final List&lt;PlayerStateEvent&gt; cachedStateEvents = new ArrayList&lt;&gt;();
    private final List&lt;PlayerTimeEvent&gt; cachedTimeEvents = new ArrayList&lt;&gt;();
    private final List&lt;BufferProgressEvent&gt; cachedBufferEvents = new ArrayList&lt;&gt;();
    private final List&lt;MediaErrorEvent&gt; cachedErrorEvents = new ArrayList&lt;&gt;();
    private boolean isFirstFrame = true;
    private NewFrameEvent firstFrameEvent = null;
    private double firstFrameTime;
    private final Object firstFrameLock = new Object();
    private EventQueueThread eventLoop = new EventQueueThread();
    private int frameWidth = -1;
    private int frameHeight = -1;
    private final AtomicBoolean isMediaPulseEnabled = new AtomicBoolean(false);
    private final Lock mediaPulseLock = new ReentrantLock();
    private Timer mediaPulseTimer;
    private final Lock markerLock = new ReentrantLock();
    private boolean checkSeek = false;
    private double timeBeforeSeek = 0.0;
    private double timeAfterSeek = 0.0;
    private double previousTime = 0.0;
    private double firedMarkerTime = -1.0;
    private double startTime = 0.0;
    private double stopTime = Double.POSITIVE_INFINITY;
    private boolean isStartTimeUpdated = false;
    private boolean isStopTimeSet = false;

    // --- Begin decoded frame rate fields
    private double encodedFrameRate = 0.0;
    private boolean recomputeFrameRate = true;
    private double previousFrameTime;
    private long numFramesSincePlaying;
    private double meanFrameDuration;
    private double decodedFrameRate;
    // --- End decoded frame rate fields
    private PlayerState playerState = PlayerState.UNKNOWN;
    private final Lock disposeLock = new ReentrantLock();
    private boolean isDisposed = false;
    private Runnable onDispose;

    //**************************************************************************
    //***** Constructors
    //**************************************************************************
    /**
     * Construct a NativeMediaPlayer for the referenced clip.
     *
     * @param clip Media object
     * @throws IllegalArgumentException if
     * &lt;code&gt;clip&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     */
    protected NativeMediaPlayer(NativeMedia clip) {
        if (clip == null) {
            throw new IllegalArgumentException(&quot;clip == null!&quot;);
        }
        media = clip;
        videoRenderControl = new VideoRenderer();
    }

    /**
     * Initialization method which must be called after construction to
     * initialize the internal state of the player. This method should be
     * invoked directly after the player is constructed.
     */
    protected void init() {
        media.addMarkerStateListener(this);
        eventLoop.start();
    }

    /**
     * Set a callback to invoke when the player is disposed.
     *
     * @param onDispose object on which to invoke {@link Runnable#run()} in
     * {@link #dispose()}.
     */
    void setOnDispose(Runnable onDispose) {
        disposeLock.lock();
        try {
            if (!isDisposed) {
                this.onDispose = onDispose;
            }
        } finally {
            disposeLock.unlock();
        }
    }

    /**
     * Event to be posted to any registered {@link MediaErrorListener}s.
     */
    private static class WarningEvent extends PlayerEvent {

        private final Object source;
        private final String message;

        WarningEvent(Object source, String message) {
            this.source = source;
            this.message = message;
        }

        public Object getSource() {
            return source;
        }

        public String getMessage() {
            return message;
        }
    }

    /**
     * Event to be posted to any registered (@link MediaErrorListener)s
     */
    public static class MediaErrorEvent extends PlayerEvent {

        private final Object source;
        private final MediaError error;

        public MediaErrorEvent(Object source, MediaError error) {
            this.source = source;
            this.error = error;
        }

        public Object getSource() {
            return source;
        }

        public String getMessage() {
            return error.description();
        }

        public int getErrorCode() {
            return error.code();
        }
    }

    private static class PlayerTimeEvent extends PlayerEvent {

        private final double time;

        public PlayerTimeEvent(double time) {
            this.time = time;
        }

        public double getTime() {
            return time;
        }
    }

    /**
     * Event to be posted to any registered {@link PlayerStateListener}s.
     */
    private static class TrackEvent extends PlayerEvent {

        private final Track track;

        TrackEvent(Track track) {
            this.track = track;
        }

        public Track getTrack() {
            return this.track;
        }
    }

    /**
     * Event to be posted to any registered {@link VideoTrackSizeListener}s.
     */
    private static class FrameSizeChangedEvent extends PlayerEvent {

        private final int width;
        private final int height;

        public FrameSizeChangedEvent(int width, int height) {
            if (width &gt; 0) {
                this.width = width;
            } else {
                this.width = 0;
            }

            if (height &gt; 0) {
                this.height = height;
            } else {
                this.height = 0;
            }
        }

        public int getWidth() {
            return width;
        }

        public int getHeight() {
            return height;
        }
    }

    /**
     * Helper class which managers {@link VideoRendererListener}s. This allows
     * any registered listeners, specifically AWT and Prism, to receive video
     * frames.
     */
    private class VideoRenderer implements VideoRenderControl {

        /**
         * adds the listener to the player's videoUpdate. The listener will be
         * called whenever a new frame of video is ready to be painted or
         * fetched by getData()
         *
         * @param listener the object which provides the VideoUpdateListener
         * callback interface
         */
        @Override
        public void addVideoRendererListener(VideoRendererListener listener) {
            if (listener != null) {
                synchronized (firstFrameLock) {
                    // If the first frame is cached, post it to the listener
                    // directly. The lock is obtained first so the cached
                    // frame is not cleared between the non-null test and
                    // posting the event.
                    if (firstFrameEvent != null) {
                        listener.videoFrameUpdated(firstFrameEvent);
                    }
                }
                videoUpdateListeners.add(new WeakReference&lt;&gt;(listener));
            }
        }

        /**
         * removes the listener from the player.
         *
         * @param listener to be removed from the player
         */
        @Override
        public void removeVideoRendererListener(VideoRendererListener listener) {
            if (listener != null) {
                for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
                    VideoRendererListener l = it.next().get();
                    if (l == null || l == listener) {
                        it.remove();
                    }
                }
            }
        }

        @Override
        public void addVideoFrameRateListener(VideoFrameRateListener listener) {
            if (listener != null) {
                videoFrameRateListeners.add(new WeakReference&lt;&gt;(listener));
            }
        }

        @Override
        public void removeVideoFrameRateListener(VideoFrameRateListener listener) {
            if (listener != null) {
                for (ListIterator&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; it = videoFrameRateListeners.listIterator(); it.hasNext();) {
                    VideoFrameRateListener l = it.next().get();
                    if (l == null || l == listener) {
                        it.remove();
                    }
                }
            }
        }

        @Override
        public int getFrameWidth() {
            return frameWidth;
        }

        @Override
        public int getFrameHeight() {
            return frameHeight;
        }
    }

    //***** EventQueueThread Helper Class -- Provides event handling.
    /**
     * Thread for media player event processing. The thread maintains an
     * internal queue of
     * &lt;code&gt;PlayerEvent&lt;/code&gt;s to which callers post using
     * &lt;code&gt;postEvent()&lt;/code&gt;. The thread blocks until an event becomes
     * available on the queue, and then removes the event from the queue and
     * posts it to any registered listeners appropriate to the type of event.
     */
    private class EventQueueThread extends Thread {

        private final BlockingQueue&lt;PlayerEvent&gt; eventQueue =
                new LinkedBlockingQueue&lt;&gt;();
        private volatile boolean stopped = false;

        EventQueueThread() {
            setName(&quot;JFXMedia Player EventQueueThread&quot;);
            setDaemon(true);
        }

        @Override
        public void run() {
            while (!stopped) {
                try {
                    // trying to take an event from the queue.
                    // this method will block until an event becomes available.
                    PlayerEvent evt = eventQueue.take();

                    if (!stopped) {
                        if (evt instanceof NewFrameEvent) {
                            try {
                                HandleRendererEvents((NewFrameEvent) evt);
                            } catch (Throwable t) {
                                if (Logger.canLog(Logger.ERROR)) {
                                    Logger.logMsg(Logger.ERROR, &quot;Caught exception in HandleRendererEvents: &quot; + t.toString());
                                }
                            }
                        } else if (evt instanceof PlayerStateEvent) {
                            HandleStateEvents((PlayerStateEvent) evt);
                        } else if (evt instanceof FrameSizeChangedEvent) {
                            HandleFrameSizeChangedEvents((FrameSizeChangedEvent) evt);
                        } else if (evt instanceof TrackEvent) {
                            HandleTrackEvents((TrackEvent) evt);
                        } else if (evt instanceof MarkerEvent) {
                            HandleMarkerEvents((MarkerEvent) evt);
                        } else if (evt instanceof WarningEvent) {
                            HandleWarningEvents((WarningEvent) evt);
                        } else if (evt instanceof PlayerTimeEvent) {
                            HandlePlayerTimeEvents((PlayerTimeEvent) evt);
                        } else if (evt instanceof BufferProgressEvent) {
                            HandleBufferEvents((BufferProgressEvent) evt);
                        } else if (evt instanceof AudioSpectrumEvent) {
                            HandleAudioSpectrumEvents((AudioSpectrumEvent) evt);
                        } else if (evt instanceof MediaErrorEvent) {
                            HandleErrorEvents((MediaErrorEvent) evt);
                        }
                    }
                } catch (Exception e) {
                    // eventQueue.take() can throw InterruptedException,
                    // also in rare case it can throw wrong
                    // IllegalMonitorStateException
                    // so we catch Exception
                    // nothing to do, restart the loop unless it was properly stopped.
                }
            }

            eventQueue.clear();
        }

        private void HandleRendererEvents(NewFrameEvent evt) {
            if (isFirstFrame) {
                // Cache first frame. Frames are delivered time-sequentially
                // so there should be no thread contention problem here.
                isFirstFrame = false;
                synchronized (firstFrameLock) {
                    firstFrameEvent = evt;
                    firstFrameTime = firstFrameEvent.getFrameData().getTimestamp();
                    firstFrameEvent.getFrameData().holdFrame(); // hold as long as we cache it, else we'll crash
                }
            } else if (firstFrameEvent != null
                    &amp;&amp; firstFrameTime != evt.getFrameData().getTimestamp()) {
                // If this branch is entered then it cannot be the first frame.
                // This means that the player must be in the PLAYING state as
                // the first frame will arrive upon completion of prerolling.
                // When playing, listeners should receive the current frame,
                // not the first frame in the stream.

                // Clear the cached first frame. Obtain the lock first to avoid
                // a race condition with a listener newly being added.
                synchronized (firstFrameLock) {
                    firstFrameEvent.getFrameData().releaseFrame();
                    firstFrameEvent = null;
                }
            }

            // notify videoUpdateListeners
            for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
                VideoRendererListener l = it.next().get();
                if (l != null) {
                    l.videoFrameUpdated(evt);
                } else {
                    it.remove();
                }
            }
            // done with the frame, we can release our hold now
            evt.getFrameData().releaseFrame();

            if (!videoFrameRateListeners.isEmpty()) {
                // Decoded frame rate calculations.
                double currentFrameTime = System.nanoTime() / (double) ONE_SECOND;

                if (recomputeFrameRate) {
                    // First frame in new computation sequence.
                    recomputeFrameRate = false;
                    previousFrameTime = currentFrameTime;
                    numFramesSincePlaying = 1;
                } else {
                    boolean fireFrameRateEvent = false;

                    if (numFramesSincePlaying == 1) {
                        // Second frame. Estimate the initial frame rate and
                        // set event flag.
                        meanFrameDuration = currentFrameTime - previousFrameTime;
                        if (meanFrameDuration &gt; 0.0) {
                            decodedFrameRate = 1.0 / meanFrameDuration;
                            fireFrameRateEvent = true;
                        }
                    } else {
                        // Update decoded frame rate estimate using a moving
                        // average over encodedFrameRate frames.
                        double previousMeanFrameDuration = meanFrameDuration;

                        // Determine moving average length.
                        int movingAverageLength = encodedFrameRate != 0.0
                                ? ((int) (encodedFrameRate + 0.5)) : NOMINAL_VIDEO_FPS;

                        // Claculate number of frames in current average.
                        long numFrames = numFramesSincePlaying &lt; movingAverageLength
                                ? numFramesSincePlaying : movingAverageLength;

                        // Update the mean frame duration.
                        meanFrameDuration = ((numFrames - 1) * previousMeanFrameDuration
                                + currentFrameTime - previousFrameTime) / numFrames;

                        // If mean frame duration changed by more than 0.5 set
                        // event flag.
                        if (meanFrameDuration &gt; 0.0
                                &amp;&amp; Math.abs(decodedFrameRate - 1.0 / meanFrameDuration) &gt; 0.5) {
                            decodedFrameRate = 1.0 / meanFrameDuration;
                            fireFrameRateEvent = true;
                        }
                    }

                    if (fireFrameRateEvent) {
                        // Fire event.
                        for (ListIterator&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; it = videoFrameRateListeners.listIterator(); it.hasNext();) {
                            VideoFrameRateListener l = it.next().get();
                            if (l != null) {
                                l.onFrameRateChanged(decodedFrameRate);
                            } else {
                                it.remove();
                            }
                        }
                    }

                    // Update running values.
                    previousFrameTime = currentFrameTime;
                    numFramesSincePlaying++;
                }
            }
        }

        private void HandleStateEvents(PlayerStateEvent evt) {
            playerState = evt.getState();

            recomputeFrameRate = PlayerState.PLAYING == evt.getState();

            switch (playerState) {
                case READY:
                    onNativeInit();
                    sendFakeBufferProgressEvent();
                    break;
                case PLAYING:
                    isMediaPulseEnabled.set(true);
                    break;
                case STOPPED:
                case FINISHED:
                    // Force a time update here to catch the time going to
                    // zero for STOPPED and any trailing markers for FINISHED.
                    doMediaPulseTask();
                case PAUSED:
                case STALLED:
                case HALTED:
                    isMediaPulseEnabled.set(false);
                    break;
                default:
                    break;
            }

            synchronized (cachedStateEvents) {
                if (playerStateListeners.isEmpty()) {
                    // Cache event for processing when first listener registers.
                    cachedStateEvents.add(evt);
                    return;
                }
            }

            for (ListIterator&lt;WeakReference&lt;PlayerStateListener&gt;&gt; it = playerStateListeners.listIterator(); it.hasNext();) {
                PlayerStateListener listener = it.next().get();
                if (listener != null) {
                    switch (playerState) {
                        case READY:
                            onNativeInit();
                            sendFakeBufferProgressEvent();
                            listener.onReady(evt);
                            break;

                        case PLAYING:
                            listener.onPlaying(evt);
                            break;

                        case PAUSED:
                            listener.onPause(evt);
                            break;

                        case STOPPED:
                            listener.onStop(evt);
                            break;

                        case STALLED:
                            listener.onStall(evt);
                            break;

                        case FINISHED:
                            listener.onFinish(evt);
                            break;

                        case HALTED:
                            listener.onHalt(evt);
                            break;

                        default:
                            break;
                    }
                } else {
                    it.remove();
                }
            }
        }

        private void HandlePlayerTimeEvents(PlayerTimeEvent evt) {
            synchronized (cachedTimeEvents) {
                if (playerTimeListeners.isEmpty()) {
                    // Cache event for processing when first listener registers.
                    cachedTimeEvents.add(evt);
                    return;
                }
            }

            for (ListIterator&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; it = playerTimeListeners.listIterator(); it.hasNext();) {
                PlayerTimeListener listener = it.next().get();
                if (listener != null) {
                    listener.onDurationChanged(evt.getTime());
                } else {
                    it.remove();
                }
            }
        }

        private void HandleFrameSizeChangedEvents(FrameSizeChangedEvent evt) {
            frameWidth = evt.getWidth();
            frameHeight = evt.getHeight();
            Logger.logMsg(Logger.DEBUG, &quot;** Frame size changed (&quot; + frameWidth + &quot;, &quot; + frameHeight + &quot;)&quot;);
            for (ListIterator&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; it = videoTrackSizeListeners.listIterator(); it.hasNext();) {
                VideoTrackSizeListener listener = it.next().get();
                if (listener != null) {
                    listener.onSizeChanged(frameWidth, frameHeight);
                } else {
                    it.remove();
                }
            }
        }

        private void HandleTrackEvents(TrackEvent evt) {
            media.addTrack(evt.getTrack());

            if (evt.getTrack() instanceof VideoTrack) {
                encodedFrameRate = ((VideoTrack) evt.getTrack()).getEncodedFrameRate();
            }
        }

        private void HandleMarkerEvents(MarkerEvent evt) {
            for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
                MarkerListener listener = it.next().get();
                if (listener != null) {
                    listener.onMarker(evt);
                } else {
                    it.remove();
                }
            }
        }

        private void HandleWarningEvents(WarningEvent evt) {
            Logger.logMsg(Logger.WARNING, evt.getSource() + evt.getMessage());
        }

        private void HandleErrorEvents(MediaErrorEvent evt) {
            Logger.logMsg(Logger.ERROR, evt.getMessage());

            synchronized (cachedErrorEvents) {
                if (errorListeners.isEmpty()) {
                    // cache error events until at least one listener is added
                    cachedErrorEvents.add(evt);
                    return;
                }
            }

            for (ListIterator&lt;WeakReference&lt;MediaErrorListener&gt;&gt; it = errorListeners.listIterator(); it.hasNext();) {
                MediaErrorListener l = it.next().get();
                if (l != null) {
                    l.onError(evt.getSource(), evt.getErrorCode(), evt.getMessage());
                } else {
                    it.remove();
                }
            }
        }

        private void HandleBufferEvents(BufferProgressEvent evt) {
            synchronized (cachedBufferEvents) {
                if (bufferListeners.isEmpty()) {
                    // Cache event for processing when first listener registers.
                    cachedBufferEvents.add(evt);
                    return;
                }
            }

            for (ListIterator&lt;WeakReference&lt;BufferListener&gt;&gt; it = bufferListeners.listIterator(); it.hasNext();) {
                BufferListener listener = it.next().get();
                if (listener != null) {
                    listener.onBufferProgress(evt);
                } else {
                    it.remove();
                }
            }
        }

        private void HandleAudioSpectrumEvents(AudioSpectrumEvent evt) {
            for (ListIterator&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; it = audioSpectrumListeners.listIterator(); it.hasNext();) {
                AudioSpectrumListener listener = it.next().get();
                if (listener != null) {
                    listener.onAudioSpectrumEvent(evt);
                } else {
                    it.remove();
                }
            }
        }

        /**
         * Puts an event to the EventQuery.
         */
        public void postEvent(PlayerEvent event) {
            if (eventQueue != null) {
                eventQueue.offer(event);
            }
        }

        /**
         * Signals the thread to terminate.
         */
        public void terminateLoop() {
            stopped = true;
            // put an event to unblock eventQueue.take()
            try {
                eventQueue.put(new PlayerEvent());
            } catch(InterruptedException ex) {}
        }

        private void sendFakeBufferProgressEvent() {
            // Send fake 100% buffer progress event for HLS or !http protcol
            String contentType = media.getLocator().getContentType();
            String protocol = media.getLocator().getProtocol();
            if ((contentType != null &amp;&amp; (contentType.equals(MediaUtils.CONTENT_TYPE_M3U) || contentType.equals(MediaUtils.CONTENT_TYPE_M3U8)))
                    || (protocol != null &amp;&amp; !protocol.equals(&quot;http&quot;) &amp;&amp; !protocol.equals(&quot;https&quot;))) {
                HandleBufferEvents(new BufferProgressEvent(getDuration(), 0, 1, 1));
            }
        }
    }

    /**
     * Internal function to get called when the native player is ready.
     */
    private synchronized void onNativeInit() {
        try {
            playerInit();
        } catch (MediaException me) {
            sendPlayerMediaErrorEvent(me.getMediaError().code());
        }
    }

    //**************************************************************************
    //***** MediaPlayer implementation
    //**************************************************************************
    //***** Listener (un)registration.
    @Override
    public void addMediaErrorListener(MediaErrorListener listener) {
        if (listener != null) {
            this.errorListeners.add(new WeakReference&lt;&gt;(listener));

            synchronized (cachedErrorEvents) {
                if (!cachedErrorEvents.isEmpty() &amp;&amp; !errorListeners.isEmpty()) {
                    cachedErrorEvents.stream().forEach((evt) -&gt; {
                        sendPlayerEvent(evt);
                    });
                    cachedErrorEvents.clear();
                }
            }
        }
    }

    @Override
    public void removeMediaErrorListener(MediaErrorListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;MediaErrorListener&gt;&gt; it = errorListeners.listIterator(); it.hasNext();) {
                MediaErrorListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addMediaPlayerListener(PlayerStateListener listener) {
        if (listener != null) {
            synchronized (cachedStateEvents) {
                if (!cachedStateEvents.isEmpty() &amp;&amp; playerStateListeners.isEmpty()) {
                    // Forward all cached state events to first listener to register.
                    Iterator&lt;PlayerStateEvent&gt; events = cachedStateEvents.iterator();
                    while (events.hasNext()) {
                        PlayerStateEvent evt = events.next();
                        switch (evt.getState()) {
                            case READY:
                                listener.onReady(evt);
                                break;
                            case PLAYING:
                                listener.onPlaying(evt);
                                break;
                            case PAUSED:
                                listener.onPause(evt);
                                break;
                            case STOPPED:
                                listener.onStop(evt);
                                break;
                            case STALLED:
                                listener.onStall(evt);
                                break;
                            case FINISHED:
                                listener.onFinish(evt);
                                break;
                            case HALTED:
                                listener.onHalt(evt);
                                break;
                            default:
                                break;
                        }
                    }

                    // Clear state event cache.
                    cachedStateEvents.clear();
                }

                playerStateListeners.add(new WeakReference(listener));
            }
        }
    }

    @Override
    public void removeMediaPlayerListener(PlayerStateListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;PlayerStateListener&gt;&gt; it = playerStateListeners.listIterator(); it.hasNext();) {
                PlayerStateListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addMediaTimeListener(PlayerTimeListener listener) {
        if (listener != null) {
            synchronized (cachedTimeEvents) {
                if (!cachedTimeEvents.isEmpty() &amp;&amp; playerTimeListeners.isEmpty()) {
                    // Forward all cached time events to first listener to register.
                    Iterator&lt;PlayerTimeEvent&gt; events = cachedTimeEvents.iterator();
                    while (events.hasNext()) {
                        PlayerTimeEvent evt = events.next();
                        listener.onDurationChanged(evt.getTime());
                    }

                    // Clear time event cache.
                    cachedTimeEvents.clear();
                } else {
                    // Let listener to know about duration
                    double duration = getDuration();
                    if (duration != Double.POSITIVE_INFINITY) {
                        listener.onDurationChanged(duration);
                    }
                }

                playerTimeListeners.add(new WeakReference(listener));
            }
        }
    }

    @Override
    public void removeMediaTimeListener(PlayerTimeListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; it = playerTimeListeners.listIterator(); it.hasNext();) {
                PlayerTimeListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addVideoTrackSizeListener(VideoTrackSizeListener listener) {
        if (listener != null) {
            if (frameWidth != -1 &amp;&amp; frameHeight != -1) {
                listener.onSizeChanged(frameWidth, frameHeight);
            }
            videoTrackSizeListeners.add(new WeakReference(listener));
        }
    }

    @Override
    public void removeVideoTrackSizeListener(VideoTrackSizeListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; it = videoTrackSizeListeners.listIterator(); it.hasNext();) {
                VideoTrackSizeListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addMarkerListener(MarkerListener listener) {
        if (listener != null) {
            markerListeners.add(new WeakReference(listener));
        }
    }

    @Override
    public void removeMarkerListener(MarkerListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
                MarkerListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addBufferListener(BufferListener listener) {
        if (listener != null) {
            synchronized (cachedBufferEvents) {
                if (!cachedBufferEvents.isEmpty() &amp;&amp; bufferListeners.isEmpty()) {
                    cachedBufferEvents.stream().forEach((evt) -&gt; {
                        listener.onBufferProgress(evt);
                    });
                    // Clear buffer event cache.
                    cachedBufferEvents.clear();
                }

                bufferListeners.add(new WeakReference(listener));
            }
        }
    }

    @Override
    public void removeBufferListener(BufferListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;BufferListener&gt;&gt; it = bufferListeners.listIterator(); it.hasNext();) {
                BufferListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    @Override
    public void addAudioSpectrumListener(AudioSpectrumListener listener) {
        if (listener != null) {
            audioSpectrumListeners.add(new WeakReference(listener));
        }
    }

    @Override
    public void removeAudioSpectrumListener(AudioSpectrumListener listener) {
        if (listener != null) {
            for (ListIterator&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; it = audioSpectrumListeners.listIterator(); it.hasNext();) {
                AudioSpectrumListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
                }
            }
        }
    }

    //***** Control functions
    @Override
    public VideoRenderControl getVideoRenderControl() {
        return videoRenderControl;
    }

    @Override
    public Media getMedia() {
        return media;
    }

    @Override
    public void setAudioSyncDelay(long delay) {
        try {
            playerSetAudioSyncDelay(delay);
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public long getAudioSyncDelay() {
        try {
            return playerGetAudioSyncDelay();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return 0;
    }

    @Override
    public void play() {
        try {
            if (isStartTimeUpdated) {
                playerSeek(startTime);
            }
            isMediaPulseEnabled.set(true);
            playerPlay();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public void stop() {
        try {
            playerStop();
            playerSeek(startTime);
        } catch (MediaException me) {
//            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
            MediaUtils.warning(this, &quot;stop() failed!&quot;);
        }
    }

    @Override
    public void pause() {
        try {
            playerPause();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public float getRate() {
        try {
            return playerGetRate();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return 0;
    }
<A NAME="15"></A>
    //***** Public properties
    @Override
    public void setRate(<FONT color="#3bb9ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#15',2,'match52-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>float rate) {
        try {
            playerSetRate(rate);
        } catch (MediaException me) {
//            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
            MediaUtils.warning(this, &quot;setRate(&quot; + rate + &quot;) failed!&quot;);
        }
    }</B></FONT>

    @Override
    public double getPresentationTime() {
        try {
            return playerGetPresentationTime();
        } catch (MediaException me) {
//            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return -1.0;
    }

    @Override
    public float getVolume() {
        try {
            return playerGetVolume();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return 0;
    }

    @Override
    public void setVolume(float vol) {
        if (vol &lt; 0.0F) {
            vol = 0.0F;
        } else if (vol &gt; 1.0F) {
            vol = 1.0F;
        }

        try {
            playerSetVolume(vol);
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public boolean getMute() {
        try {
            return playerGetMute();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return false;
    }

    /**
     * Enables/disable mute. If mute is enabled then disabled, the previous
     * volume goes into effect.
     */
    @Override
    public void setMute(boolean enable) {
        try {
            playerSetMute(enable);
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public float getBalance() {
        try {
            return playerGetBalance();
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return 0;
    }

    @Override
    public void setBalance(float bal) {
        if (bal &lt; -1.0F) {
            bal = -1.0F;
        } else if (bal &gt; 1.0F) {
            bal = 1.0F;
        }

        try {
            playerSetBalance(bal);
        } catch (MediaException me) {
            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
    }

    @Override
    public abstract AudioEqualizer getEqualizer();

    @Override
    public abstract AudioSpectrum getAudioSpectrum();

    @Override
    public double getDuration() {
        try {
            return playerGetDuration();
        } catch (MediaException me) {
//            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
        }
        return Double.POSITIVE_INFINITY;
    }

    /**
     * Gets the time within the duration of the media to start playing.
     */
    @Override
    public double getStartTime() {
        return startTime;
    }

    /**
     * Sets the start time within the media to play.
     */
    @Override
    public void setStartTime(double startTime) {
        try {
            markerLock.lock();
            this.startTime = startTime;
            if (playerState != PlayerState.PLAYING &amp;&amp; playerState != PlayerState.FINISHED &amp;&amp; playerState != PlayerState.STOPPED) {
                playerSeek(startTime);
            } else if (playerState == PlayerState.STOPPED) {
                isStartTimeUpdated = true;
            }
        } finally {
            markerLock.unlock();
        }
    }

    /**
     * Gets the time within the duration of the media to stop playing.
     */
    @Override
    public double getStopTime() {
        return stopTime;
    }

    /**
     * Sets the stop time within the media to stop playback.
     */
    @Override
    public void setStopTime(double stopTime) {
        try {
            markerLock.lock();
            this.stopTime = stopTime;
            isStopTimeSet = true;
            createMediaPulse();
        } finally {
            markerLock.unlock();
        }
    }

    @Override
    public void seek(double streamTime) {
        if (playerState == PlayerState.STOPPED) {
            return; // No seek in stopped state
        }

        if (streamTime &lt; 0.0) {
            streamTime = 0.0;
        } else {
            double duration = getDuration();
            if (duration &gt;= 0.0 &amp;&amp; streamTime &gt; duration) {
                streamTime = duration;
            }
        }

        if (!isMediaPulseEnabled.get()) {
            if ((playerState == PlayerState.PLAYING
                    || playerState == PlayerState.PAUSED
                    || playerState == PlayerState.FINISHED)
                    &amp;&amp; getStartTime() &lt;= streamTime &amp;&amp; streamTime &lt;= getStopTime()) {
                isMediaPulseEnabled.set(true);
            }
        }

        markerLock.lock();
        try {
            timeBeforeSeek = getPresentationTime();
            timeAfterSeek = streamTime;
            checkSeek = timeBeforeSeek != timeAfterSeek;
            previousTime = streamTime;
            firedMarkerTime = -1.0;
//            System.out.println(&quot;seek @ &quot;+System.currentTimeMillis());
//            System.out.println(&quot;seek to &quot;+streamTime+&quot; previousTime &quot;+previousTime);

            try {
                playerSeek(streamTime);
            } catch (MediaException me) {
                //sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
                MediaUtils.warning(this, &quot;seek(&quot; + streamTime + &quot;) failed!&quot;);
            }
        } finally {
            markerLock.unlock();
        }
    }

    protected abstract long playerGetAudioSyncDelay() throws MediaException;

    protected abstract void playerSetAudioSyncDelay(long delay) throws MediaException;

    protected abstract void playerPlay() throws MediaException;

    protected abstract void playerStop() throws MediaException;

    protected abstract void playerPause() throws MediaException;

    protected abstract void playerFinish() throws MediaException;

    protected abstract float playerGetRate() throws MediaException;

    protected abstract void playerSetRate(float rate) throws MediaException;

    protected abstract double playerGetPresentationTime() throws MediaException;

    protected abstract boolean playerGetMute() throws MediaException;

    protected abstract void playerSetMute(boolean state) throws MediaException;

    protected abstract float playerGetVolume() throws MediaException;

    protected abstract void playerSetVolume(float volume) throws MediaException;

    protected abstract float playerGetBalance() throws MediaException;

    protected abstract void playerSetBalance(float balance) throws MediaException;

    protected abstract double playerGetDuration() throws MediaException;

    protected abstract void playerSeek(double streamTime) throws MediaException;

    protected abstract void playerInit() throws MediaException;

    protected abstract void playerDispose();

    /**
     * Retrieves the current {@link PlayerState state} of the player.
     *
     * @return the current player state.
     */
    @Override
    public PlayerState getState() {
        return playerState;
    }

    @Override
    final public void dispose() {
        disposeLock.lock();
        try {
            if (!isDisposed) {
                // Terminate event firing
                destroyMediaPulse();

                if (eventLoop != null) {
                    eventLoop.terminateLoop();
                    eventLoop = null;
                }

                synchronized (firstFrameLock) {
                    if (firstFrameEvent != null) {
                        firstFrameEvent.getFrameData().releaseFrame();
                        firstFrameEvent = null;
                    }
                }

                // Terminate native layer
                playerDispose();

                // Dispose media object and clear reference
                if (media != null) {
                    media.dispose();
                    media = null;
                }

                if (videoUpdateListeners != null) {
                    for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
                        VideoRendererListener l = it.next().get();
                        if (l != null) {
                            l.releaseVideoFrames();
                        } else {
                            it.remove();
                        }
                    }

                    videoUpdateListeners.clear();
                }

                if (playerStateListeners != null) {
                    playerStateListeners.clear();
                }

                if (videoTrackSizeListeners != null) {
                    videoTrackSizeListeners.clear();
                }

                if (videoFrameRateListeners != null) {
                    videoFrameRateListeners.clear();
                }

                if (cachedStateEvents != null) {
                    cachedStateEvents.clear();
                }

                if (cachedTimeEvents != null) {
                    cachedTimeEvents.clear();
                }

                if (cachedBufferEvents != null) {
                    cachedBufferEvents.clear();
                }

                if (errorListeners != null) {
                    errorListeners.clear();
                }

                if (playerTimeListeners != null) {
                    playerTimeListeners.clear();
                }

                if (markerListeners != null) {
                    markerListeners.clear();
                }

                if (bufferListeners != null) {
                    bufferListeners.clear();
                }

                if (audioSpectrumListeners != null) {
                    audioSpectrumListeners.clear();
                }

                if (videoRenderControl != null) {
                    videoRenderControl = null;
                }

                if (onDispose != null) {
                    onDispose.run();
                }

                isDisposed = true;
            }
        } finally {
            disposeLock.unlock();
        }
    }

    //**************************************************************************
    //***** Non-JNI methods called by the native layer. These methods are called
    //***** from the native layer via the invocation API. Their purpose is to
    //***** dispatch certain events to the Java layer. Each of these methods
    //***** posts an event on the &lt;code&gt;EventQueueThread&lt;/code&gt; which in turn
    //***** forwards the event to any registered listeners.
    //**************************************************************************
    protected void sendWarning(int warningCode, String warningMessage) {
        if (eventLoop != null) {
            String message = String.format(MediaUtils.NATIVE_MEDIA_WARNING_FORMAT,
                    warningCode);
            if (warningMessage != null) {
                message += &quot;: &quot; + warningMessage;
            }
            eventLoop.postEvent(new WarningEvent(this, message));
        }
    }

    protected void sendPlayerEvent(PlayerEvent evt) {
        if (eventLoop != null) {
            eventLoop.postEvent(evt);
        }
    }

    protected void sendPlayerHaltEvent(String message, double time) {
        // Log the error.  Since these are most likely playback engine message (e.g. GStreamer or PacketVideo),
        // it makes no sense to propogate it above.
        Logger.logMsg(Logger.ERROR, message);

        if (eventLoop != null) {
            eventLoop.postEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.HALTED, time, message));
        }
    }

    protected void sendPlayerMediaErrorEvent(int errorCode) {
        sendPlayerEvent(new MediaErrorEvent(this, MediaError.getFromCode(errorCode)));
    }

    protected void sendPlayerStateEvent(int eventID, double time) {
        switch (eventID) {
            case eventPlayerReady:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.READY, time));
                break;
            case eventPlayerPlaying:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.PLAYING, time));
                break;
            case eventPlayerPaused:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.PAUSED, time));
                break;
            case eventPlayerStopped:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.STOPPED, time));
                break;
            case eventPlayerStalled:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.STALLED, time));
                break;
            case eventPlayerFinished:
                sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.FINISHED, time));
                break;
            default:
                break;
        }
    }

    protected void sendNewFrameEvent(long nativeRef) {
        NativeVideoBuffer newFrameData = NativeVideoBuffer.createVideoBuffer(nativeRef);
        // createVideoBuffer puts a hold on the frame
        // we need to keep that hold until the event thread can process this event
        sendPlayerEvent(new NewFrameEvent(newFrameData));
    }

    protected void sendFrameSizeChangedEvent(int width, int height) {
        sendPlayerEvent(new FrameSizeChangedEvent(width, height));
    }

    protected void sendAudioTrack(boolean enabled, long trackID, String name, int encoding,
            String language, int numChannels,
            int channelMask, float sampleRate) {
        Locale locale = null;
        if (!language.equals(&quot;und&quot;)) {
            locale = new Locale(language);
        }

        Track track = new AudioTrack(enabled, trackID, name,
                locale, Encoding.toEncoding(encoding),
                numChannels, channelMask, sampleRate);

        TrackEvent evt = new TrackEvent(track);

        sendPlayerEvent(evt);
    }

    protected void sendVideoTrack(boolean enabled, long trackID, String name, int encoding,
            int width, int height, float frameRate,
            boolean hasAlphaChannel) {
        // No locale (currently) for video, so pass null
        Track track = new VideoTrack(enabled, trackID, name, null,
                Encoding.toEncoding(encoding),
                new VideoResolution(width, height), frameRate, hasAlphaChannel);

        TrackEvent evt = new TrackEvent(track);

        sendPlayerEvent(evt);
    }

    protected void sendSubtitleTrack(boolean enabled, long trackID, String name,
            int encoding, String language)
    {
        Locale locale = null;
        if (null != language) {
            locale = new Locale(language);
        }
        Track track = new SubtitleTrack(enabled, trackID, name, locale,
                Encoding.toEncoding(encoding));

        sendPlayerEvent(new TrackEvent(track));
    }

    protected void sendMarkerEvent(String name, double time) {
        sendPlayerEvent(new MarkerEvent(name, time));
    }

    protected void sendDurationUpdateEvent(double duration) {
        sendPlayerEvent(new PlayerTimeEvent(duration));
    }

    protected void sendBufferProgressEvent(double clipDuration, long bufferStart, long bufferStop, long bufferPosition) {
        sendPlayerEvent(new BufferProgressEvent(clipDuration, bufferStart, bufferStop, bufferPosition));
    }

    protected void sendAudioSpectrumEvent(double timestamp, double duration) {
        sendPlayerEvent(new AudioSpectrumEvent(getAudioSpectrum(), timestamp, duration));
    }

    @Override
    public void markerStateChanged(boolean hasMarkers) {
        if (hasMarkers) {
            markerLock.lock();
            try {
                previousTime = getPresentationTime();
            } finally {
                markerLock.unlock();
            }
            createMediaPulse();
        } else {
            if (!isStopTimeSet) {
                destroyMediaPulse();
            }
        }
    }

    private void createMediaPulse() {
        mediaPulseLock.lock();
        try {
            if (mediaPulseTimer == null) {
                mediaPulseTimer = new Timer(true);
                mediaPulseTimer.scheduleAtFixedRate(new MediaPulseTask(this), 0, 40 /*
                         * period ms
                         */);
            }
        } finally {
            mediaPulseLock.unlock();
        }
    }

    private void destroyMediaPulse() {
        mediaPulseLock.lock();
        try {
            if (mediaPulseTimer != null) {
                mediaPulseTimer.cancel();
                mediaPulseTimer = null;
            }
        } finally {
            mediaPulseLock.unlock();
        }
    }

    boolean doMediaPulseTask() {
        if (this.isMediaPulseEnabled.get()) {
            disposeLock.lock();

            if (isDisposed) {
                disposeLock.unlock();
                return false;
            }

            double thisTime = getPresentationTime();

            markerLock.lock();

            try {
                //System.out.println(&quot;Media pulse @ pts &quot;+thisTime+&quot; previous &quot;+previousTime);

                if (checkSeek) {
                    if (timeAfterSeek &gt; timeBeforeSeek) {
                        // Forward seek
                        if (thisTime &gt;= timeAfterSeek) {
//                        System.out.println(&quot;bail 1&quot;);
                            checkSeek = false;
                        } else {
                            return true;
                        }
                    } else if (timeAfterSeek &lt; timeBeforeSeek) {
                        // Backward seek
                        if (thisTime &gt;= timeBeforeSeek) {
//                        System.out.println(&quot;bail 2&quot;);
                            return true;
                        } else {
                            checkSeek = false;
                        }
                    }
                }

                Map.Entry&lt;Double, String&gt; marker = media.getNextMarker(previousTime, true);
//                System.out.println(&quot;marker &quot;+marker);
//                System.out.println(&quot;Checking: &quot; + previousTime + &quot; &quot; + thisTime + &quot; &quot;
//                        + getStartTime() + &quot; &quot; + getStopTime() + &quot; &quot;
//                        + marker.getKey());

                while (marker != null) {
                    double nextMarkerTime = marker.getKey();
                    if (nextMarkerTime &gt; thisTime) {
                        break;
                    } else if (nextMarkerTime != firedMarkerTime
                            &amp;&amp; nextMarkerTime &gt;= previousTime
                            &amp;&amp; nextMarkerTime &gt;= getStartTime()
                            &amp;&amp; nextMarkerTime &lt;= getStopTime()) {
//                            System.out.println(&quot;Firing: &quot;+previousTime+&quot; &quot;+thisTime+&quot; &quot;+
//                                    getStartTime()+&quot; &quot;+getStopTime()+&quot; &quot;+
//                                    nextMarkerTime);
                        MarkerEvent evt = new MarkerEvent(marker.getValue(), nextMarkerTime);
                        for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
                            MarkerListener listener = it.next().get();
                            if (listener != null) {
                                listener.onMarker(evt);
                            } else {
                                it.remove();
                            }
                        }
                        firedMarkerTime = nextMarkerTime;
                    }
                    marker = media.getNextMarker(nextMarkerTime, false);
                }

                previousTime = thisTime;

                // Do stopTime
                if (isStopTimeSet &amp;&amp; thisTime &gt;= stopTime) {
                    playerFinish();
                }
            } finally {
                disposeLock.unlock();
                markerLock.unlock();
            }
        }

        return true;
    }

    /* Audio EQ and spectrum creation, used by sub-classes */
    protected AudioEqualizer createNativeAudioEqualizer(long nativeRef) {
        return new NativeAudioEqualizer(nativeRef);
    }

    protected AudioSpectrum createNativeAudioSpectrum(long nativeRef) {
        return new NativeAudioSpectrum(nativeRef);
    }
}

class MediaPulseTask extends TimerTask {

    WeakReference&lt;NativeMediaPlayer&gt; playerRef;

    MediaPulseTask(NativeMediaPlayer player) {
        playerRef = new WeakReference&lt;&gt;(player);
    }

    @Override
    public void run() {
        final NativeMediaPlayer player = playerRef.get();
        if (player != null) {
            if (!player.doMediaPulseTask()) {
                cancel(); // Stop if doMediaPulseTask() returns false. False means doMediaPulseTask() cannot continue (like after dispose).cy
            }
        } else {
            cancel();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/javafx/webkit/theme/RenderThemeImpl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.webkit.theme;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.collections.FXCollections;
import javafx.geometry.Orientation;
import javafx.scene.control.Button;
import javafx.scene.control.CheckBox;
import javafx.scene.control.ChoiceBox;
import javafx.scene.control.Control;
import javafx.scene.control.ProgressBar;
import javafx.scene.control.RadioButton;
import javafx.scene.control.SkinBase;
import javafx.scene.control.Slider;
import javafx.scene.control.TextField;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.Region;
import java.lang.ref.WeakReference;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.LinkedHashMap;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;
import com.sun.javafx.webkit.Accessor;
import com.sun.webkit.LoadListenerClient;
import com.sun.webkit.graphics.Ref;
import com.sun.webkit.graphics.RenderTheme;
import com.sun.webkit.graphics.WCGraphicsContext;
import com.sun.webkit.graphics.WCSize;
import javafx.application.Application;

public final class RenderThemeImpl extends RenderTheme {
    private final static PlatformLogger log = PlatformLogger.getLogger(RenderThemeImpl.class.getName());

    enum WidgetType {
        TEXTFIELD      (0),
        BUTTON         (1),
        CHECKBOX       (2),
        RADIOBUTTON    (3),
        MENULIST       (4),
        MENULISTBUTTON (5),
        SLIDER         (6),
        PROGRESSBAR    (7),
        METER          (8),
        SCROLLBAR      (9);

        private static final HashMap&lt;Integer, WidgetType&gt; map = new HashMap&lt;Integer, WidgetType&gt;();
        private final int value;

        private WidgetType(int value) { this.value = value; }

        static { for (WidgetType v: values()) map.put(v.value, v); }

        private static WidgetType convert(int index) { return map.get(index); }
    };

    private Accessor accessor;
    private boolean isDefault; // indicates if the instance is used in non-page context

    private Pool&lt;FormControl&gt; pool;

    /**
     * A pool of controls.
     * Based on a hash map where a control is the value and its ID is the key.
     * The pool size is limited. When a new control is added to the pool and
     * the limit is reached, a control which is used most rarely is removed.
     */
    static final class Pool&lt;T extends Widget&gt; {
        private static final int INITIAL_CAPACITY = 100;

        private int capacity = INITIAL_CAPACITY;

        // A map of control IDs used to track the rate of accociated controls
        // based on their &quot;popularity&quot;.
        // Maps an ID to an updateContentCycleID corresponding to the cycle
        // at which the control was added to the pool.
        private final LinkedHashMap&lt;Long, Integer&gt; ids = new LinkedHashMap&lt;&gt;();

        // A map b/w the IDs and associated controls.
        // The {@code ids} map is kept in sync with the set of keys.
        private final Map&lt;Long, WeakReference&lt;T&gt;&gt; pool = new HashMap&lt;&gt;();

        private final Notifier&lt;T&gt; notifier;
        private final String type; // used for logging

        /**
         * An interface used to notify the implementor of removal
         * of a control from the pool.
         */
        interface Notifier&lt;T&gt; {
            public void notifyRemoved(T control);
        }

        Pool(Notifier&lt;T&gt; notifier, Class&lt;T&gt; type) {
            this.notifier = notifier;
            this.type = type.getSimpleName();
        }

        T get(long id) {
            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;type: {0}, size: {1}, id: 0x{2}&quot;,
                        new Object[] {type, pool.size(), Long.toHexString(id)});
            }
            assert ids.size() == pool.size();

            WeakReference&lt;T&gt; controlRef = pool.get(id);
            if (controlRef == null) {
                return null;
            }

            T control = controlRef.get();
            if (control == null) {
                return null;
            }

            // &quot;Bubble&quot; the id.
            Integer value = ids.remove(Long.valueOf(id));
            ids.put(id, value);

            return control;
        }

        void put(long id, T control, int updateContentCycleID) {
            if (log.isLoggable(Level.FINEST)) {
                log.finest(&quot;size: {0}, id: 0x{1}, control: {2}&quot;,
                        new Object[] {pool.size(), Long.toHexString(id), control.getType()});
            }
            if (ids.size() &gt;= capacity) {
                // Pull a control from the bottom of the map, least used.
                Long _id = ids.keySet().iterator().next();
                Integer cycleID = ids.get(_id);
                // Remove that &quot;unpopular&quot; control in case it wasn't added
                // during the current update cycle.
                if (cycleID != updateContentCycleID) {
                    ids.remove(_id);
                    T _control = pool.remove(_id).get();
                    if (_control != null) {
                        notifier.notifyRemoved(_control);
                    }
                // Otherwise, double the pool capacity.
                } else {
                    capacity = Math.min(capacity, (int)Math.ceil(Integer.MAX_VALUE/2)) * 2;
                }
            }
            ids.put(id, updateContentCycleID);
            pool.put(id, new WeakReference&lt;T&gt;(control));
        }

        void clear() {
            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;size: &quot; + pool.size() + &quot;, controls: &quot; + pool.values());
            }
            if (pool.size() == 0) {
                return;
            }
            ids.clear();
            for (WeakReference&lt;T&gt; controlRef : pool.values()) {
                T control = controlRef.get();
                if (control != null) {
                    notifier.notifyRemoved(control);
                }
            }
            pool.clear();
            capacity = INITIAL_CAPACITY;
        }
    }

    static class ViewListener implements InvalidationListener {
        private final Pool pool;
        private final Accessor accessor;
        private LoadListenerClient loadListener;

        ViewListener(Pool pool, Accessor accessor) {
            this.pool = pool;
            this.accessor = accessor;
        }

        @Override public void invalidated(Observable ov) {
            pool.clear(); // clear the pool when WebView changes

            // Add the LoadListenerClient when the page is available.
            if (accessor.getPage() != null &amp;&amp; loadListener == null) {
                loadListener = new LoadListenerClient() {
                    @Override
                    public void dispatchLoadEvent(long frame, int state, String url,
                                                  String contentType, double progress, int errorCode)
                    {
                        if (state == LoadListenerClient.PAGE_STARTED) {
                            // An html page with new content is being loaded.
                            // Clear the controls associated with the previous html page.
                            pool.clear();
                        }
                    }
                    @Override
                    public void dispatchResourceLoadEvent(long frame, int state, String url,
                                                          String contentType, double progress,
                                                          int errorCode) {}
                };
                accessor.getPage().addLoadListenerClient(loadListener);
            }
        }
    }

    public RenderThemeImpl(final Accessor accessor) {
        this.accessor = accessor;
        pool = new Pool&lt;FormControl&gt;(fc -&gt; {
            // Remove the control from WebView when it's removed from the pool.
            accessor.removeChild(fc.asControl());
        }, FormControl.class);
        accessor.addViewListener(new ViewListener(pool, accessor));
    }

    public RenderThemeImpl() {
        isDefault = true;
    }

    private void ensureNotDefault() {
        if (isDefault) {
            throw new IllegalStateException(&quot;the method should not be called in this context&quot;);
        }
    }

    @Override
    protected Ref createWidget(
        long id,
        int widgetIndex,
        int state,
        int w, int h,
        int bgColor,
        ByteBuffer extParams)
    {
        ensureNotDefault();

        FormControl fc = pool.get(id);
        WidgetType type = WidgetType.convert(widgetIndex);

        if (fc == null || fc.getType() != type) {
            if (fc  != null) {
                // Remove the unmatching control.
                accessor.removeChild(fc.asControl());
            }
            switch (type) {
                case TEXTFIELD:
                    fc = new FormTextField();
                    break;
                case BUTTON:
                    fc = new FormButton();
                    break;
                case CHECKBOX:
                    fc = new FormCheckBox();
                    break;
                case RADIOBUTTON:
                    fc = new FormRadioButton();
                    break;
                case MENULIST:
                    fc = new FormMenuList();
                    break;
                case MENULISTBUTTON:
                    fc = new FormMenuListButton();
                    break;
                case SLIDER:
                    fc = new FormSlider();
                    break;
                case PROGRESSBAR:
                    fc = new FormProgressBar(WidgetType.PROGRESSBAR);
                    break;
                case METER:
                    fc = new FormProgressBar(WidgetType.METER);
                    break;
                default:
                    log.severe(&quot;unknown widget index: {0}&quot;, widgetIndex);
                    return null;
            }
            fc.asControl().setFocusTraversable(false);
            pool.put(id, fc, accessor.getPage().getUpdateContentCycleID()); // put or replace the entry
            accessor.addChild(fc.asControl());
        }

        fc.setState(state);
        Control ctrl = fc.asControl();
        if (ctrl.getWidth() != w || ctrl.getHeight() != h) {
            ctrl.resize(w, h);
        }
        if (ctrl.isManaged()) {
            ctrl.setManaged(false);
        }

        if (extParams != null) {
            if (type == WidgetType.SLIDER) {
                Slider slider = (Slider)ctrl;
                extParams.order(ByteOrder.nativeOrder());
                slider.setOrientation(extParams.getInt()==0
                    ? Orientation.HORIZONTAL
                    : Orientation.VERTICAL);
                slider.setMax(extParams.getFloat());
                slider.setMin(extParams.getFloat());
                slider.setValue(extParams.getFloat());
            } else if (type == WidgetType.PROGRESSBAR) {
                ProgressBar progress = (ProgressBar)ctrl;
                extParams.order(ByteOrder.nativeOrder());
                progress.setProgress(extParams.getInt() == 1
                        ? extParams.getFloat()
                        : progress.INDETERMINATE_PROGRESS);
            } else if (type == WidgetType.METER) {
                ProgressBar progress = (ProgressBar) ctrl;
                extParams.order(ByteOrder.nativeOrder());
                progress.setProgress(extParams.getFloat());
                progress.setStyle(getMeterStyle(extParams.getInt()));
            }
        }
        return new FormControlRef(fc);
    }

    private String getMeterStyle(int region) {
        // see GaugeRegion in HTMLMeterElement.h
        switch (region) {
            case 1: // GaugeRegionSuboptimal
                return &quot;-fx-accent: yellow&quot;;
            case 2: // GaugeRegionEvenLessGood
                return &quot;-fx-accent: red&quot;;
            default: // GaugeRegionOptimum
                return &quot;-fx-accent: green&quot;;
        }
    }

    @Override
    public void drawWidget(
        WCGraphicsContext g,
        final Ref widget,
        int x, int y)
    {
        ensureNotDefault();

        FormControl fcontrol = ((FormControlRef) widget).asFormControl();
        if (fcontrol != null) {
            Control control = fcontrol.asControl();
            if (control != null) {
                g.saveState();
                g.translate(x, y);
                Renderer.getRenderer().render(control, g);
                g.restoreState();
            }
        }
    }

    @Override
    public WCSize getWidgetSize(Ref widget) {
        ensureNotDefault();

        FormControl fcontrol = ((FormControlRef)widget).asFormControl();
        if (fcontrol != null) {
            Control control = fcontrol.asControl();
            return new WCSize((float)control.getWidth(), (float)control.getHeight());
        }
        return new WCSize(0, 0);
    }

    @Override
    protected int getRadioButtonSize() {
        String style = Application.getUserAgentStylesheet();
        if (Application.STYLESHEET_MODENA.equalsIgnoreCase(style)) {
            return 20; // 18 + 2; size + focus outline
        } else if (Application.STYLESHEET_CASPIAN.equalsIgnoreCase(style)) {
            return 19; // 16 + 3; size + focus outline
        }
        return 20;
    }

    // TODO: get theme value
    @Override
    protected int getSelectionColor(int index) {
        switch (index) {
            case BACKGROUND: return 0xff0093ff;
            case FOREGROUND: return 0xffffffff;
            default: return 0;
        }
    }

    private static boolean hasState(int state, int mask) {
        return (state &amp; mask) != 0;
    }

    private static final class FormControlRef extends Ref {
        private final WeakReference&lt;FormControl&gt; fcRef;

        private FormControlRef(FormControl fc) {
            this.fcRef = new WeakReference&lt;FormControl&gt;(fc);
        }

        private FormControl asFormControl() {
            return fcRef.get();
        }
    }

    interface Widget {
        public WidgetType getType();
    }

    private interface FormControl extends Widget {
        public Control asControl();
        public void setState(int state);
    }

    private static final class FormButton extends Button implements FormControl {

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
            setPressed(hasState(state, RenderTheme.PRESSED));
            if (isPressed()) arm(); else disarm();
        }

        @Override public WidgetType getType() { return WidgetType.BUTTON; };
    }

    private static final class FormTextField extends TextField implements FormControl {

        private FormTextField() {
            setStyle(&quot;-fx-display-caret: false&quot;);
        }

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setEditable(hasState(state, RenderTheme.READ_ONLY));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
        }

        @Override public WidgetType getType() { return WidgetType.TEXTFIELD; };
    }

    private static final class FormCheckBox extends CheckBox implements FormControl {

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
            setSelected(hasState(state, RenderTheme.CHECKED));
        }

        @Override public WidgetType getType() { return WidgetType.CHECKBOX; };
    }

    private static final class FormRadioButton extends RadioButton implements FormControl {

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
            setSelected(hasState(state, RenderTheme.CHECKED));
        }

        @Override public WidgetType getType() { return WidgetType.RADIOBUTTON; };
    }

    private static final class FormSlider extends Slider implements FormControl {

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
        }

        @Override public WidgetType getType() { return WidgetType.SLIDER; };
    }

    private static final class FormProgressBar extends ProgressBar implements FormControl {
        private final WidgetType type;

        private FormProgressBar(WidgetType type) {
            this.type = type;
        }

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
        }

        @Override public WidgetType getType() { return type; };
    }

    private static final class FormMenuList extends ChoiceBox implements FormControl {

        private FormMenuList() {
            // Adding a dummy item to please ChoiceBox.
            List&lt;String&gt; l = new ArrayList&lt;String&gt;();
            l.add(&quot;&quot;);
            setItems(FXCollections.observableList(l));
        }

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
        }

        @Override public WidgetType getType() { return WidgetType.MENULIST; };
    }

    private static final class FormMenuListButton extends Button implements FormControl {

        private static final int MAX_WIDTH = 20;
        private static final int MIN_WIDTH = 16;

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setHover(hasState(state, RenderTheme.HOVERED));
            setPressed(hasState(state, RenderTheme.PRESSED));
            if (isPressed()) arm(); else disarm();
        }

        private FormMenuListButton() {
            setSkin(new Skin());
            setFocusTraversable(false);
            getStyleClass().add(&quot;form-select-button&quot;);
        }

        /**
         * @param height is the height of the FormMenuList widget
         * @param width is passed equal to height
         */
        @Override public void resize(double width, double height) {
            width = height &gt; MAX_WIDTH ? MAX_WIDTH : height &lt; MIN_WIDTH ? MIN_WIDTH : height;

            super.resize(width, height);

            // [x] is originally aligned with the right edge of
            // the menulist control, and here we adjust it
            setTranslateX(-width);
        }
<A NAME="32"></A>
        private final class Skin extends SkinBase {
            Skin() {
                <FONT color="#82cafa"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52-0.html#32',2,'match52-top.html#32',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>super(FormMenuListButton.this);

                Region arrow = new Region();
                arrow.getStyleClass().add(&quot;arrow&quot;);
                arrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
                BorderPane pane = new BorderPane();
                pane.setCenter(arrow);
                getChildren().add(pane);
            }
        }</B></FONT>

        @Override public WidgetType getType() { return WidgetType.MENULISTBUTTON; };
    }
}
</PRE>

</BODY>
</HTML>
