<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>daihoangquoc_</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.base/javafx/beans/property/ReadOnlyMapPropertyBase.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.beans.property;

import com.sun.javafx.binding.MapExpressionHelper;
import javafx.beans.InvalidationListener;
import javafx.beans.value.ChangeListener;
import javafx.collections.MapChangeListener;
import javafx.collections.ObservableMap;

/**
 * Base class for all readonly properties wrapping an {@link javafx.collections.ObservableMap}.
 * This class provides a default implementation to attach listener.
 *
 * @see ReadOnlyMapProperty
 * @since JavaFX 2.1
 */
public abstract class ReadOnlyMapPropertyBase&lt;K, V&gt; extends ReadOnlyMapProperty&lt;K, V&gt; {

    private MapExpressionHelper&lt;K, V&gt; helper;

    @Override
    public void addListener(InvalidationListener listener) {
        helper = MapExpressionHelper.addListener(helper, this, listener);
    }

    @Override
    public void removeListener(InvalidationListener listener) {
        helper = MapExpressionHelper.removeListener(helper, listener);
    }

    @Override
    public void addListener(ChangeListener&lt;? super ObservableMap&lt;K, V&gt;&gt; listener) {
        helper = MapExpressionHelper.addListener(helper, this, listener);
    }

    @Override
    public void removeListener(ChangeListener&lt;? super ObservableMap&lt;K, V&gt;&gt; listener) {
        helper = MapExpressionHelper.removeListener(helper, listener);
    }

    @Override
    public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
        helper = MapExpressionHelper.addListener(helper, this, listener);
    }

    @Override
    public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
        helper = MapExpressionHelper.removeListener(helper, listener);
    }

    /**
     * This method needs to be called if the reference to the
     * {@link javafx.collections.ObservableList} changes.
     *
     * It sends notifications to all attached
     * {@link javafx.beans.InvalidationListener InvalidationListeners},
     * {@link javafx.beans.value.ChangeListener ChangeListeners}, and
     * {@link javafx.collections.ListChangeListener}.
     *
<A NAME="56"></A>     * This method needs to be called, if the value of this property changes.
     */
    protected void fireValueChangedEvent() {
        <FONT color="#52d017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#56',2,'match37-top.html#56',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>MapExpressionHelper.fireValueChangedEvent(helper);
    }

    /**
     * This method needs to be called if the content of the referenced
     * {@link javafx.collections.ObservableList} changes.
     *
     * Sends notifications to all attached
     * {@link javafx.beans.InvalidationListener InvalidationListeners},
     * {@link javafx.beans.value.ChangeListener ChangeListeners}, and
     * {@link javafx.collections.ListChangeListener}.
     *
     * This method is called when the content of the list changes.
     *
     * @param change the change that needs to be propagated
     */
    protected void fireValueChangedEvent(MapChangeListener.Change&lt;? extends K, ? extends V&gt; change) {
        MapExpressionHelper.fireValueChangedEvent(helper, change);
    }



}</B></FONT>
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.base/javafx/beans/property/adapter/JavaBeanBooleanProperty.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.beans.property.adapter;

import com.sun.javafx.binding.ExpressionHelper;
import com.sun.javafx.property.MethodHelper;
import com.sun.javafx.property.adapter.Disposer;
import com.sun.javafx.property.adapter.PropertyDescriptor;
import javafx.beans.InvalidationListener;
import javafx.beans.property.BooleanProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.UndeclaredThrowableException;

import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;

/**
 * A {@code JavaBeanBooleanProperty} provides an adapter between a regular
 * Java Bean property of type {@code boolean} or {@code Boolean} and a JavaFX
 * {@code BooleanProperty}. It cannot be created directly, but a
 * {@link JavaBeanBooleanPropertyBuilder} has to be used.
 * &lt;p&gt;
 * As a minimum, the Java Bean class must implement a getter and a setter for the
 * property.
 * The class, as well as the getter and a setter methods, must be declared public.
 * If the getter of an instance of this class is called, the property of
 * the Java Bean is returned. If the setter is called, the value will be passed
 * to the Java Bean property. If the Java Bean property is bound (i.e. it supports
 * PropertyChangeListeners), this {@code JavaBeanBooleanProperty} will be
 * aware of changes in the Java Bean. Otherwise it can be notified about
 * changes by calling {@link #fireValueChangedEvent()}. If the Java Bean property
 * is also constrained (i.e. it supports VetoableChangeListeners), this
 * {@code JavaBeanBooleanProperty} will reject changes, if it is bound to an
 * {@link javafx.beans.value.ObservableValue ObservableValue&amp;lt;Boolean&amp;gt;}.
 * &lt;/p&gt;
 * &lt;p&gt;&lt;b&gt;Deploying an Application as a Module&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;
 * If the Java Bean class is in a named module, then it must be reflectively
 * accessible to the {@code javafx.base} module.
 * A class is reflectively accessible if the module
 * {@link Module#isOpen(String,Module) opens} the containing package to at
 * least the {@code javafx.base} module.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For example, if {@code com.foo.MyBeanClass} is in the {@code foo.app} module,
 * the {@code module-info.java} might
 * look like this:
 * &lt;/p&gt;
 *
&lt;pre&gt;{@code module foo.app {
    opens com.foo to javafx.base;
}}&lt;/pre&gt;
 *
 * &lt;p&gt;
 * Alternatively, a class is reflectively accessible if the module
 * {@link Module#isExported(String) exports} the containing package
 * unconditionally.
 * &lt;/p&gt;
 *
 * @see javafx.beans.property.BooleanProperty
 * @see JavaBeanBooleanPropertyBuilder
 * @since JavaFX 2.1
 */
public final class JavaBeanBooleanProperty extends BooleanProperty implements JavaBeanProperty&lt;Boolean&gt; {

    private final PropertyDescriptor descriptor;
    private final PropertyDescriptor.Listener&lt;Boolean&gt; listener;

    private ObservableValue&lt;? extends Boolean&gt; observable = null;
    private ExpressionHelper&lt;Boolean&gt; helper = null;

    private final AccessControlContext acc = AccessController.getContext();

    JavaBeanBooleanProperty(PropertyDescriptor descriptor, Object bean) {
        this.descriptor = descriptor;
        this.listener = descriptor.new Listener&lt;Boolean&gt;(bean, this);
        descriptor.addListener(listener);
        Disposer.addRecord(this, new DescriptorListenerCleaner(descriptor, listener));
    }

    /**
     * {@inheritDoc}
     *
     * @throws UndeclaredThrowableException if calling the getter of the Java Bean
     * property throws an {@code IllegalAccessException} or an
     * {@code InvocationTargetException}.
     */
    @Override
    public boolean get() {
        return AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; {
            try {
                return (Boolean)MethodHelper.invoke(descriptor.getGetter(), getBean(), (Object[])null);
            } catch (IllegalAccessException e) {
                throw new UndeclaredThrowableException(e);
            } catch (InvocationTargetException e) {
                throw new UndeclaredThrowableException(e);
            }
        }, acc);
    }

    /**
     * {@inheritDoc}
     *
     * @throws UndeclaredThrowableException if calling the getter of the Java Bean
     * property throws an {@code IllegalAccessException} or an
     * {@code InvocationTargetException}.
     */
    @Override
    public void set(final boolean value) {
        if (isBound()) {
            throw new RuntimeException(&quot;A bound value cannot be set.&quot;);
        }

        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            try {
                MethodHelper.invoke(descriptor.getSetter(), getBean(), new Object[] {value});
                ExpressionHelper.fireValueChangedEvent(helper);
            } catch (IllegalAccessException e) {
                throw new UndeclaredThrowableException(e);
            } catch (InvocationTargetException e) {
                throw new UndeclaredThrowableException(e);
            }
            return null;
        }, acc);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void bind(ObservableValue&lt;? extends Boolean&gt; observable) {
        if (observable == null) {
            throw new NullPointerException(&quot;Cannot bind to null&quot;);
        }

        if (!observable.equals(this.observable)) {
            unbind();
            set(observable.getValue());
            this.observable = observable;
            this.observable.addListener(listener);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void unbind() {
        if (observable != null) {
            observable.removeListener(listener);
            observable = null;
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isBound() {
        return observable != null;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Object getBean() {
        return listener.getBean();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String getName() {
        return descriptor.getName();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
        helper = ExpressionHelper.addListener(helper, this, listener);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
        helper = ExpressionHelper.removeListener(helper, listener);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void addListener(InvalidationListener listener) {
        helper = ExpressionHelper.addListener(helper, this, listener);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void removeListener(InvalidationListener listener) {
        helper = ExpressionHelper.removeListener(helper, listener);
    }

<A NAME="30"></A>    /**
     * {@inheritDoc}
     */
    <FONT color="#f9966b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#30',2,'match37-top.html#30',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override
    public void fireValueChangedEvent() {
        ExpressionHelper.fireValueChangedEvent(helper);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void dispose() {
        descriptor.removeListener(listener);

    }

    /**
     * Returns a string representation of this {@code JavaBeanBooleanProperty} object.
     * @return a string representation of this {@code JavaBeanBooleanProperty} object.
     */
    @Override
    public String toString() {
        final Object bean = getBean();
        final String name = getName</B></FONT>();
        final StringBuilder result = new StringBuilder(&quot;BooleanProperty [&quot;);
        if (bean != null) {
            result.append(&quot;bean: &quot;).append(bean).append(&quot;, &quot;);
        }
        if ((name != null) &amp;&amp; (!name.equals(&quot;&quot;))) {
            result.append(&quot;name: &quot;).append(name).append(&quot;, &quot;);
        }
        if (isBound()) {
            result.append(&quot;bound, &quot;);
        }
        result.append(&quot;value: &quot;).append(get());
        result.append(&quot;]&quot;);
        return result.toString();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/GlobalMenuAdapter.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.collections.ListChangeListener;
import javafx.collections.ListChangeListener.Change;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.scene.control.CheckMenuItem;
import javafx.scene.control.CustomMenuItem;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.RadioMenuItem;
import javafx.scene.control.SeparatorMenuItem;

import java.util.List;

import com.sun.javafx.menu.CheckMenuItemBase;
import com.sun.javafx.menu.CustomMenuItemBase;
import com.sun.javafx.menu.MenuBase;
import com.sun.javafx.menu.MenuItemBase;
import com.sun.javafx.menu.RadioMenuItemBase;
import com.sun.javafx.menu.SeparatorMenuItemBase;

import com.sun.javafx.collections.TrackableObservableList;

public class GlobalMenuAdapter extends Menu implements MenuBase {
    private Menu menu;

    public static MenuBase adapt(Menu menu) {
        return new GlobalMenuAdapter(menu);
    }

    private final ObservableList&lt;MenuItemBase&gt; items = new TrackableObservableList&lt;MenuItemBase&gt;() {
        @Override protected void onChanged(Change&lt;MenuItemBase&gt; c) {
        }
    };

    private GlobalMenuAdapter(final Menu menu) {
        super(menu.getText());

        this.menu = menu;

        bindMenuItemProperties(this, menu);

        menu.showingProperty().addListener(property -&gt; {
            if (menu.isShowing() &amp;&amp; !isShowing()) {
                show();
            } else if (!menu.isShowing() &amp;&amp; isShowing()) {
                hide();
            }
        });
        showingProperty().addListener(property -&gt; {
            if (isShowing() &amp;&amp; !menu.isShowing()) {
                menu.show();
            } else if (!isShowing() &amp;&amp; menu.isShowing()) {
                menu.hide();
            }
        });

//        EventHandler&lt;Event&gt; showHideHandler = new EventHandler&lt;Event&gt;() {
//            public void handle(Event ev) {
//                Event.fireEvent(menu, new Event(ev.getEventType()));
//            }
//        };

        menu.getItems().addListener(new ListChangeListener&lt;MenuItem&gt;() {
            @Override public void onChanged(Change&lt;? extends MenuItem&gt; change) {
                while (change.next()) {
                    int from = change.getFrom();
                    int to = change.getTo();
                    List&lt;? extends MenuItem&gt; removed = change.getRemoved();
                    for (int i = from + removed.size() - 1; i &gt;= from ; i--) {
                        items.remove(i);
                        getItems().remove(i);
                    }
                    for (int i = from; i &lt; to; i++) {
                        MenuItem item = change.getList().get(i);
                        insertItem(item, i);
                    }
                }
<A NAME="51"></A>            }
        });

        for (MenuItem menuItem : menu.getItems()) <FONT color="#b38481"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#51',2,'match37-top.html#51',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
            insertItem(menuItem, items.size());
        }
    }

    private void insertItem(MenuItem menuItem, int pos) {
        MenuItemBase mib</B></FONT>;

        if (menuItem instanceof Menu) {
            mib = new GlobalMenuAdapter((Menu)menuItem);
        } else if (menuItem instanceof CheckMenuItem) {
            mib = new CheckMenuItemAdapter((CheckMenuItem)menuItem);
        } else if (menuItem instanceof RadioMenuItem) {
            mib = new RadioMenuItemAdapter((RadioMenuItem)menuItem);
        } else if (menuItem instanceof SeparatorMenuItem) {
            mib = new SeparatorMenuItemAdapter((SeparatorMenuItem)menuItem);
        } else if (menuItem instanceof CustomMenuItem) {
            mib = new CustomMenuItemAdapter((CustomMenuItem)menuItem);
        } else {
            mib = new MenuItemAdapter(menuItem);
        }

        items.add(pos, mib);
        getItems().add(pos, (MenuItem)mib);
    }

    public final ObservableList&lt;MenuItemBase&gt; getItemsBase() {
        return items;
    }


    private static void bindMenuItemProperties(MenuItem adapter, final MenuItem menuItem) {
        adapter.idProperty().bind(menuItem.idProperty());
        adapter.textProperty().bind(menuItem.textProperty());
        adapter.graphicProperty().bind(menuItem.graphicProperty());
        adapter.disableProperty().bind(menuItem.disableProperty());
        adapter.visibleProperty().bind(menuItem.visibleProperty());
        adapter.acceleratorProperty().bind(menuItem.acceleratorProperty());
        adapter.mnemonicParsingProperty().bind(menuItem.mnemonicParsingProperty());

        adapter.setOnAction(ev -&gt; {
            menuItem.fire();
        });
    }

    @Override
    public void fireValidation() {
        if (menu.getOnMenuValidation() != null) {
            Event.fireEvent(menu, new Event(GlobalMenuAdapter.MENU_VALIDATION_EVENT));
        }
        Menu target = (Menu)menu.getParentMenu();
        if(target != null &amp;&amp; target.getOnMenuValidation() != null) {
            Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
        }
    }


    private static class MenuItemAdapter extends MenuItem implements MenuItemBase {
        private MenuItem menuItem;

        private MenuItemAdapter(final MenuItem menuItem) {
            super(menuItem.getText());

            this.menuItem = menuItem;

            bindMenuItemProperties(this, menuItem);
        }

        @Override
        public void fireValidation() {
            if (menuItem.getOnMenuValidation() != null) {
                Event.fireEvent(menuItem, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
            Menu target = (Menu)menuItem.getParentMenu();
            if(target.getOnMenuValidation() != null) {
                Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
        }
    }

    private static class CheckMenuItemAdapter extends CheckMenuItem implements CheckMenuItemBase {
        private CheckMenuItem menuItem;

        private CheckMenuItemAdapter(final CheckMenuItem menuItem) {
            super(menuItem.getText());
            this.menuItem = menuItem;

            bindMenuItemProperties(this, menuItem);

            selectedProperty().bindBidirectional(menuItem.selectedProperty());
        }

        @Override
        public void fireValidation() {
            if (getOnMenuValidation() != null) {
                Event.fireEvent(menuItem, new Event(CheckMenuItemAdapter.MENU_VALIDATION_EVENT));
            }
            Menu target = (Menu)menuItem.getParentMenu();
            if(target.getOnMenuValidation() != null) {
                Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
        }
    }

    private static class RadioMenuItemAdapter extends RadioMenuItem implements RadioMenuItemBase {
        private RadioMenuItem menuItem;

        private RadioMenuItemAdapter(final RadioMenuItem menuItem) {
            super(menuItem.getText());

            this.menuItem = menuItem;

            bindMenuItemProperties(this, menuItem);

            selectedProperty().bindBidirectional(menuItem.selectedProperty());
        }

        @Override
        public void fireValidation() {
            if (getOnMenuValidation() != null) {
                Event.fireEvent(menuItem, new Event(RadioMenuItemAdapter.MENU_VALIDATION_EVENT));
            }
            Menu target = (Menu)menuItem.getParentMenu();
            if(target.getOnMenuValidation() != null) {
                Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
        }
    }

    private static class SeparatorMenuItemAdapter extends SeparatorMenuItem implements SeparatorMenuItemBase {
        private SeparatorMenuItem menuItem;

        private SeparatorMenuItemAdapter(final SeparatorMenuItem menuItem) {
            this.menuItem = menuItem;

            bindMenuItemProperties(this, menuItem);
        }

        @Override
        public void fireValidation() {
            if (getOnMenuValidation() != null) {
                Event.fireEvent(menuItem, new Event(SeparatorMenuItemAdapter.MENU_VALIDATION_EVENT));
            }
            Menu target = (Menu)menuItem.getParentMenu();
            if(target.getOnMenuValidation() != null) {
                Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
        }
    }

    private static class CustomMenuItemAdapter extends CustomMenuItem implements CustomMenuItemBase {
        private CustomMenuItem menuItem;

        private CustomMenuItemAdapter(final CustomMenuItem menuItem) {
            this.menuItem = menuItem;

            bindMenuItemProperties(this, menuItem);
        }

        @Override
        public void fireValidation() {
            if (getOnMenuValidation() != null) {
                Event.fireEvent(menuItem, new Event(CustomMenuItemAdapter.MENU_VALIDATION_EVENT));
            }
            Menu target = (Menu)menuItem.getParentMenu();
            if(target.getOnMenuValidation() != null) {
                Event.fireEvent(target, new Event(MenuItem.MENU_VALIDATION_EVENT));
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/VirtualScrollBar.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import com.sun.javafx.util.Utils;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.scene.control.IndexedCell;
import javafx.scene.control.ScrollBar;
import javafx.scene.control.skin.VirtualFlow;

/**
 * This custom ScrollBar is used to map the increment &amp; decrement features
 * to pixel based scrolling rather than thumb/track based scrolling, if the
 * &quot;virtual&quot; attribute is true.
 */
public class VirtualScrollBar extends ScrollBar {

    /**************************************************************************
     *
     * Private fields
     *
     **************************************************************************/

    private final VirtualFlow flow;

    private boolean adjusting;



    /**************************************************************************
     *
     * Constructors
     *
     **************************************************************************/

    /**
     * Creates a new VirtualScrollBar, for use by the VirtualFlow control.
     */
    public VirtualScrollBar(final VirtualFlow flow) {
        this.flow = flow;

        super.valueProperty().addListener(valueModel -&gt; {
            if (isVirtual()/* &amp;&amp; oldValue != newValue*/) {
                if (adjusting) {
                    // no-op
                } else {
                    flow.setPosition(getValue());
                }
            }
        });
    }



    /**************************************************************************
     *
     * Properties
     *
     **************************************************************************/

    // --- virtual
    private BooleanProperty virtual = new SimpleBooleanProperty(this, &quot;virtual&quot;);
    public final void setVirtual(boolean value) {
        virtual.set(value);
    }

    public final boolean isVirtual() {
        return virtual.get();
    }

    public final BooleanProperty virtualProperty() {
        return virtual;
    }


    /**************************************************************************
     *
     * Public API
     *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void decrement() {
        if (isVirtual()) {
<A NAME="35"></A>            flow.scrollPixels(-10);
        } else {
            super.decrement();
        <FONT color="#41a317"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#35',2,'match37-top.html#35',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
    }

    /** {@inheritDoc} */
    @Override public void increment() {
        if (isVirtual</B></FONT>()) {
            flow.scrollPixels(10);
        } else {
            super.increment();
        }
    }

    // this method is called when the user clicks in the scrollbar track, so
    // we special-case it to allow for page-up and page-down clicking to work
    // as expected.
    /** {@inheritDoc} */
    @Override public void adjustValue(double pos) {
        if (isVirtual()) {
            adjusting = true;
            double oldValue = flow.getPosition();

            double newValue = ((getMax() - getMin()) * Utils.clamp(0, pos, 1))+getMin();
            if (newValue &lt; oldValue) {
                IndexedCell cell = flow.getFirstVisibleCell();
                if (cell == null) return;
                flow.scrollToBottom(cell);
            } else if (newValue &gt; oldValue) {
                IndexedCell cell = flow.getLastVisibleCell();
                if (cell == null) return;
                flow.scrollToTop(cell);
            }

            adjusting = false;
        } else {
            super.adjustValue(pos);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/TextInputControlBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.PlatformUtil;
import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.skin.FXVK;

import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.scene.control.skin.TextInputControlSkin;
import javafx.application.ConditionalFeature;
import javafx.beans.InvalidationListener;
import javafx.collections.ObservableList;
import javafx.geometry.NodeOrientation;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.IndexRange;
import javafx.scene.control.MenuItem;
import javafx.scene.control.PasswordField;
import javafx.scene.control.SeparatorMenuItem;
import javafx.scene.control.TextInputControl;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.Clipboard;
import com.sun.javafx.scene.control.inputmap.InputMap;
import com.sun.javafx.scene.control.inputmap.KeyBinding;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;

import java.text.Bidi;
import java.util.function.Predicate;

import static com.sun.javafx.PlatformUtil.isLinux;
import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;
import static com.sun.javafx.scene.control.inputmap.KeyBinding.OptionalBoolean;
import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;
import static javafx.scene.control.skin.TextInputControlSkin.TextUnit;
import static javafx.scene.control.skin.TextInputControlSkin.Direction;
import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;
import static com.sun.javafx.scene.control.inputmap.InputMap.MouseMapping;
import static javafx.scene.input.KeyCode.*;
import static javafx.scene.input.KeyEvent.*;

/**
 * All of the &quot;button&quot; types (CheckBox, RadioButton, ToggleButton, and Button)
 * and also maybe some other types like hyperlinks operate on the &quot;armed&quot;
 * selection strategy, just like JButton. This behavior class encapsulates that
 * logic in a way that can be reused and extended by each of the individual
 * class behaviors.
 *
 */
public abstract class TextInputControlBehavior&lt;T extends TextInputControl&gt; extends BehaviorBase&lt;T&gt; {

    /**
     * Specifies whether we ought to show handles. We should do it on touch platforms, but not
     * iOS (and maybe not Android either?)
     */
    static final boolean SHOW_HANDLES = Properties.IS_TOUCH_SUPPORTED &amp;&amp; !PlatformUtil.isIOS();

    public static final String DISABLE_FORWARD_TO_PARENT = &quot;TextInputControlBehavior.disableForwardToParent&quot;;

    /**************************************************************************
     * Fields                                                                 *
     *************************************************************************/

    final T textInputControl;

    protected ContextMenu contextMenu;

    private InvalidationListener textListener = observable -&gt; invalidateBidi();

    private final InputMap&lt;T&gt; inputMap;




    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    public TextInputControlBehavior(T c) {
        super(c);

        this.textInputControl = c;

        textInputControl.textProperty().addListener(textListener);

        // create a map for text input-specific mappings (this reuses the default
        // InputMap installed on the control, if it is non-null, allowing us to pick up any user-specified mappings)
        inputMap = createInputMap();

        // some of the mappings are only valid when the control is editable, or
        // only on certain platforms, so we create the following predicates that filters out the mapping when the
        // control is not in the correct state / on the correct platform
        final Predicate&lt;KeyEvent&gt; validWhenEditable = e -&gt; !c.isEditable();
        final Predicate&lt;KeyEvent&gt; validOnWindows = e -&gt; !PlatformUtil.isWindows();
        final Predicate&lt;KeyEvent&gt; validOnLinux = e -&gt; !PlatformUtil.isLinux();

        KeyMapping cancelEditMapping;
        KeyMapping consumeMostPressedEventsMapping;

        // create a child input map for mappings which are applicable on all
        // platforms, and regardless of editing state
        addDefaultMapping(inputMap,
                // caret movement
                keyMapping(RIGHT, e -&gt; nextCharacterVisually(true)),
                keyMapping(LEFT, e -&gt; nextCharacterVisually(false)),
                keyMapping(UP, e -&gt; c.home()),
                keyMapping(HOME, e -&gt; c.home()),
                keyMapping(DOWN, e -&gt; c.end()),
                keyMapping(END, e -&gt; c.end()),
                keyMapping(ENTER, this::fire),

                keyMapping(new KeyBinding(HOME).shortcut(), e -&gt; c.home()),
                keyMapping(new KeyBinding(END).shortcut(), e -&gt; c.end()),

                // deletion (only applies when control is editable)
                keyMapping(new KeyBinding(BACK_SPACE), e -&gt; deletePreviousChar(), validWhenEditable),
                keyMapping(new KeyBinding(BACK_SPACE).shift(), e -&gt; deletePreviousChar(), validWhenEditable),
                keyMapping(new KeyBinding(DELETE), e -&gt; deleteNextChar(), validWhenEditable),

                // cut (only applies when control is editable)
                keyMapping(new KeyBinding(X).shortcut(), e -&gt; cut(), validWhenEditable),
                keyMapping(new KeyBinding(CUT), e -&gt; cut(), validWhenEditable),

                // copy
                keyMapping(new KeyBinding(C).shortcut(), e -&gt; c.copy()),
                keyMapping(new KeyBinding(INSERT).shortcut(), e -&gt; c.copy()),
                keyMapping(COPY, e -&gt; c.copy()),

                // paste (only applies when control is editable)
                keyMapping(new KeyBinding(V).shortcut(), e -&gt; paste(), validWhenEditable),
                keyMapping(new KeyBinding(PASTE), e -&gt; paste(), validWhenEditable),
                keyMapping(new KeyBinding(INSERT).shift(), e -&gt; paste(), validWhenEditable),

                // selection
                keyMapping(new KeyBinding(RIGHT).shift(), e -&gt; selectRight()),
                keyMapping(new KeyBinding(LEFT).shift(), e -&gt; selectLeft()),
                keyMapping(new KeyBinding(UP).shift(), e -&gt; selectHome()),
                keyMapping(new KeyBinding(DOWN).shift(), e -&gt; selectEnd()),
                keyMapping(new KeyBinding(HOME).shortcut().shift(), e -&gt; selectHome()),
                keyMapping(new KeyBinding(END).shortcut().shift(), e -&gt; selectEnd()),
                keyMapping(new KeyBinding(A).shortcut(), e -&gt; c.selectAll()),

                // Traversal Bindings
                new KeyMapping(new KeyBinding(TAB), FocusTraversalInputMap::traverseNext),
                new KeyMapping(new KeyBinding(TAB).shift(), FocusTraversalInputMap::traversePrevious),
                new KeyMapping(new KeyBinding(TAB).ctrl(), FocusTraversalInputMap::traverseNext),
                new KeyMapping(new KeyBinding(TAB).ctrl().shift(), FocusTraversalInputMap::traversePrevious),

                // The following keys are forwarded to the parent container
                cancelEditMapping = new KeyMapping(ESCAPE, this::cancelEdit),

                keyMapping(new KeyBinding(Z).shortcut(), e -&gt; undo()),

                // character input.
                // Any other key press first goes to normal text input
                // Note this is KEY_TYPED because otherwise the character is not available in the event.
                keyMapping(new KeyBinding(null, KEY_TYPED)
                                    .alt(OptionalBoolean.ANY)
                                    .shift(OptionalBoolean.ANY)
                                    .ctrl(OptionalBoolean.ANY)
                                    .meta(OptionalBoolean.ANY),
                           this::defaultKeyTyped),

                // However, we want to consume other key press / release events too, for
                // things that would have been handled by the InputCharacter normally
                consumeMostPressedEventsMapping =
                    keyMapping(new KeyBinding(null, KEY_PRESSED).shift(OptionalBoolean.ANY),
                               e -&gt; { if (!e.getCode().isFunctionKey()) e.consume(); }),

                // VK
                new KeyMapping(new KeyBinding(DIGIT9).ctrl().shift(), e -&gt; {
                    FXVK.toggleUseVK(textInputControl);
                }, p -&gt; !PlatformImpl.isSupported(ConditionalFeature.VIRTUAL_KEYBOARD)),

                // mouse and context menu mappings
                new MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed),
                new MouseMapping(MouseEvent.MOUSE_DRAGGED, this::mouseDragged),
                new MouseMapping(MouseEvent.MOUSE_RELEASED, this::mouseReleased),
                new InputMap.Mapping&lt;ContextMenuEvent&gt;(ContextMenuEvent.CONTEXT_MENU_REQUESTED, this::contextMenuRequested) {
                    @Override public int getSpecificity(Event event) {
                        return 1;
                    }
                }
        );

        cancelEditMapping.setAutoConsume(false);
        consumeMostPressedEventsMapping.setAutoConsume(false);

        // mac os specific mappings
        InputMap&lt;T&gt; macOsInputMap = new InputMap&lt;&gt;(c);
        macOsInputMap.setInterceptor(e -&gt; !PlatformUtil.isMac());
        macOsInputMap.getMappings().addAll(
            // Mac OS specific mappings
            keyMapping(new KeyBinding(HOME).shift(), e -&gt; selectHomeExtend()),
            keyMapping(new KeyBinding(END).shift(), e -&gt; selectEndExtend()),
            keyMapping(new KeyBinding(LEFT).shortcut(), e -&gt; c.home()),
            keyMapping(new KeyBinding(RIGHT).shortcut(), e -&gt; c.end()),
            keyMapping(new KeyBinding(LEFT).alt(), e -&gt; leftWord()),
            keyMapping(new KeyBinding(RIGHT).alt(), e -&gt; rightWord()),
            keyMapping(new KeyBinding(DELETE).alt(), e -&gt; deleteNextWord()),
            keyMapping(new KeyBinding(BACK_SPACE).alt(), e -&gt; deletePreviousWord()),
            keyMapping(new KeyBinding(BACK_SPACE).shortcut(), e -&gt; deleteFromLineStart()),
            keyMapping(new KeyBinding(Z).shortcut().shift(), e -&gt; redo()),
            keyMapping(new KeyBinding(LEFT).shortcut().shift(), e -&gt; selectHomeExtend()),
            keyMapping(new KeyBinding(RIGHT).shortcut().shift(), e -&gt; selectEndExtend()),

            // Mac OS specific selection mappings
            keyMapping(new KeyBinding(LEFT).shift().alt(), e -&gt; selectLeftWord()),
            keyMapping(new KeyBinding(RIGHT).shift().alt(), e -&gt; selectRightWord())
        );
        addDefaultChildMap(inputMap, macOsInputMap);

        // windows / linux specific mappings
        InputMap&lt;T&gt; nonMacOsInputMap = new InputMap&lt;&gt;(c);
        nonMacOsInputMap.setInterceptor(e -&gt; PlatformUtil.isMac());
        nonMacOsInputMap.getMappings().addAll(
            keyMapping(new KeyBinding(HOME).shift(), e -&gt; selectHome()),
            keyMapping(new KeyBinding(END).shift(), e -&gt; selectEnd()),
            keyMapping(new KeyBinding(LEFT).ctrl(), e -&gt; leftWord()),
            keyMapping(new KeyBinding(RIGHT).ctrl(), e -&gt; rightWord()),
            keyMapping(new KeyBinding(H).ctrl(), e -&gt; deletePreviousChar()),
            keyMapping(new KeyBinding(DELETE).ctrl(), e -&gt; deleteNextWord()),
            keyMapping(new KeyBinding(BACK_SPACE).ctrl(), e -&gt; deletePreviousWord()),
            keyMapping(new KeyBinding(BACK_SLASH).ctrl(), e -&gt; c.deselect()),
            keyMapping(new KeyBinding(Y).ctrl(), e -&gt; redo(), validOnWindows),
            keyMapping(new KeyBinding(Z).ctrl().shift(), e -&gt; redo(), validOnLinux),
            keyMapping(new KeyBinding(LEFT).ctrl().shift(), e -&gt; selectLeftWord()),
            keyMapping(new KeyBinding(RIGHT).ctrl().shift(), e -&gt; selectRightWord())
        );
        addDefaultChildMap(inputMap, nonMacOsInputMap);

        addKeyPadMappings(inputMap);

        textInputControl.textProperty().addListener(textListener);

        contextMenu = new ContextMenu();
}

    @Override public InputMap&lt;T&gt; getInputMap() {
        return inputMap;
    }

    /**
     * Bind keypad arrow keys to the same as the regular arrow keys.
     */
    protected void addKeyPadMappings(InputMap&lt;T&gt; map) {
        // First create a temporary map for the keypad mappings
        InputMap&lt;T&gt; tmpMap = new InputMap&lt;&gt;(getNode());
        for (Object o : map.getMappings()) {
            if (o instanceof KeyMapping) {
                KeyMapping mapping = (KeyMapping)o;
                KeyBinding kb = (KeyBinding)mapping.getMappingKey();
                if (kb.getCode() != null) {
                    KeyCode newCode = null;
                    switch (kb.getCode()) {
                        case LEFT:  newCode = KP_LEFT;  break;
                        case RIGHT: newCode = KP_RIGHT; break;
                        case UP:    newCode = KP_UP;    break;
                        case DOWN:  newCode = KP_DOWN;  break;
                        default:
                    }
                    if (newCode != null) {
                        KeyBinding newkb = new KeyBinding(newCode).shift(kb.getShift())
                                                                  .ctrl(kb.getCtrl())
                                                                  .alt(kb.getAlt())
                                                                  .meta(kb.getMeta());
                        tmpMap.getMappings().add(new KeyMapping(newkb, mapping.getEventHandler()));
                    }
                }
            }
        }
        // Install mappings
        for (Object o : tmpMap.getMappings()) {
            map.getMappings().add((KeyMapping)o);
        }

        // Recursive call for child maps
        for (Object o : map.getChildInputMaps()) {
            addKeyPadMappings((InputMap&lt;T&gt;)o);
        }
    }


    /**
     * Wraps the event handler to pause caret blinking when
     * processing the key event.
     */
    protected KeyMapping keyMapping(final KeyCode keyCode, final EventHandler&lt;KeyEvent&gt; eventHandler) {
        return keyMapping(new KeyBinding(keyCode), eventHandler);
    }

    protected KeyMapping keyMapping(KeyBinding keyBinding, final EventHandler&lt;KeyEvent&gt; eventHandler) {
        return keyMapping(keyBinding, eventHandler, null);
    }

    protected KeyMapping keyMapping(KeyBinding keyBinding, final EventHandler&lt;KeyEvent&gt; eventHandler,
                                    Predicate&lt;KeyEvent&gt; interceptor) {
        return new KeyMapping(keyBinding,
                              e -&gt; {
                                  setCaretAnimating(false);
                                  eventHandler.handle(e);
                                  setCaretAnimating(true);
                              },
                              interceptor);
    }





    /**************************************************************************
     * Disposal methods                                                       *
     *************************************************************************/

    @Override public void dispose() {
        textInputControl.textProperty().removeListener(textListener);
        super.dispose();
    }

    /**************************************************************************
     * Abstract methods                                                       *
     *************************************************************************/

    protected abstract void deleteChar(boolean previous);
    protected abstract void replaceText(int start, int end, String txt);
    protected abstract void setCaretAnimating(boolean play);
    protected abstract void deleteFromLineStart();

    protected abstract void mousePressed(MouseEvent e);
    protected abstract void mouseDragged(MouseEvent e);
    protected abstract void mouseReleased(MouseEvent e);
    protected abstract void contextMenuRequested(ContextMenuEvent e);

    /**************************************************************************
     * Key handling implementation                                            *
     *************************************************************************/

    /**
     * The default handler for a key typed event, which is called when none of
     * the other key bindings match. This is the method which handles basic
     * text entry.
     * @param event not null
     */
    private void defaultKeyTyped(KeyEvent event) {
        final TextInputControl textInput = getNode();
        // I'm not sure this case can actually ever happen, maybe this
        // should be an assert instead?
        if (!textInput.isEditable() || textInput.isDisabled()) return;

        // Sometimes we get events with no key character, in which case
        // we need to bail.
        String character = event.getCharacter();
        if (character.length() == 0) return;

        // Filter out control keys except control+Alt on PC or Alt on Mac
        if (event.isControlDown() || event.isAltDown() || (isMac() &amp;&amp; event.isMetaDown())) {
            if (!((event.isControlDown() || isMac()) &amp;&amp; event.isAltDown())) return;
        }

        setEditing(true);

        // Ignore characters in the control range and the ASCII delete
        // character as well as meta key presses
        if (character.charAt(0) &gt; 0x1F
                &amp;&amp; character.charAt(0) != 0x7F
                &amp;&amp; !event.isMetaDown()) { // Not sure about this one
            final IndexRange selection = textInput.getSelection();
            final int start = selection.getStart();
            final int end = selection.getEnd();

            replaceText(start, end, character);
        }

        setEditing(false);
    }

    private Bidi bidi = null;
    private Boolean mixed = null;
    private Boolean rtlText = null;

    private void invalidateBidi() {
        bidi = null;
        mixed = null;
        rtlText = null;
    }

    private Bidi getBidi() {
        if (bidi == null) {
            bidi = new Bidi(textInputControl.textProperty().getValueSafe(),
                    (textInputControl.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT)
                            ? Bidi.DIRECTION_RIGHT_TO_LEFT
                            : Bidi.DIRECTION_LEFT_TO_RIGHT);
        }
        return bidi;
    }

    protected boolean isMixed() {
        if (mixed == null) {
            mixed = getBidi().isMixed();
        }
        return mixed;
    }

    protected boolean isRTLText() {
        if (rtlText == null) {
            Bidi bidi = getBidi();
            rtlText =
                    (bidi.isRightToLeft() ||
                            (isMixed() &amp;&amp;
                                    textInputControl.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT));
        }
        return rtlText;
    }

    private void nextCharacterVisually(boolean moveRight) {
        if (isMixed()) {
            TextInputControlSkin&lt;?&gt; skin = (TextInputControlSkin&lt;?&gt;)textInputControl.getSkin();
            skin.moveCaret(TextUnit.CHARACTER, moveRight ? Direction.RIGHT : Direction.LEFT, false);
        } else if (moveRight != isRTLText()) {
            textInputControl.forward();
        } else {
            textInputControl.backward();
        }
    }

    private void selectLeft() {
        if (isRTLText()) {
            textInputControl.selectForward();
        } else {
            textInputControl.selectBackward();
        }
    }

    private void selectRight() {
        if (isRTLText()) {
            textInputControl.selectBackward();
        } else {
            textInputControl.selectForward();
        }
    }

    private void deletePreviousChar() {
        setEditing(true);
        deleteChar(true);
        setEditing(false);
    }

    private void deleteNextChar() {
        setEditing(true);
        deleteChar(false);
        setEditing(false);
    }

    protected void deletePreviousWord() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
        int end = textInputControl.getCaretPosition();

        if (end &gt; 0) {
            textInputControl.previousWord();
            int start = textInputControl.getCaretPosition();
            replaceText(start, end, &quot;&quot;);
        }
        setEditing(false);
    }

    protected void deleteNextWord() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
        int start = textInputControl.getCaretPosition();

        if (start &lt; textInputControl.getLength()) {
            nextWord();
            int end = textInputControl.getCaretPosition();
            replaceText(start, end, &quot;&quot;);
        }
        setEditing(false);
    }

    public void deleteSelection() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
        IndexRange selection = textInputControl.getSelection();

        if (selection.getLength() &gt; 0) {
            deleteChar(false);
        }
        setEditing(false);
    }

    public void cut() {
        setEditing(true);
        getNode().cut();
        setEditing(false);
    }

    public void paste() {
        setEditing(true);
        getNode().paste();
        setEditing(false);
    }

    public void undo() {
        setEditing(true);
        getNode().undo();
        setEditing(false);
    }

    public void redo() {
        setEditing(true);
        getNode().redo();
        setEditing(false);
    }

    protected void selectPreviousWord() {
        getNode().selectPreviousWord();
    }

    public void selectNextWord() {
        TextInputControl textInputControl = getNode();
        if (isMac() || isLinux()) {
            textInputControl.selectEndOfNextWord();
        } else {
            textInputControl.selectNextWord();
        }
    }

    private void selectLeftWord() {
        if (isRTLText()) {
            selectNextWord();
        } else {
            selectPreviousWord();
        }
    }

    private void selectRightWord() {
        if (isRTLText()) {
            selectPreviousWord();
        } else {
            selectNextWord();
        }
    }

    protected void selectWord() {
        final TextInputControl textInputControl = getNode();
        textInputControl.previousWord();
        if (isWindows()) {
            textInputControl.selectNextWord();
        } else {
            textInputControl.selectEndOfNextWord();
        }
        if (SHOW_HANDLES &amp;&amp; contextMenu.isShowing()) {
            populateContextMenu();
        }
    }
<A NAME="10"></A>
    protected void selectAll() {
        getNode().selectAll();
        if (SHOW_HANDLES &amp;&amp; <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#10',2,'match37-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>contextMenu.isShowing()) {
            populateContextMenu();
        }
    }

    protected void previousWord() {
        getNode().previousWord();
    }

    protected void nextWord() {</B></FONT>
        TextInputControl textInputControl = getNode();
        if (isMac() || isLinux()) {
            textInputControl.endOfNextWord();
        } else {
            textInputControl.nextWord();
        }
    }

    private void leftWord() {
        if (isRTLText()) {
            nextWord();
        } else {
            previousWord();
        }
    }

    private void rightWord() {
        if (isRTLText()) {
            previousWord();
        } else {
            nextWord();
        }
    }

    protected void fire(KeyEvent event) { } // TODO move to TextFieldBehavior
    protected void cancelEdit(KeyEvent event) { forwardToParent(event);} // not autoconsumed

    protected void forwardToParent(KeyEvent event) {
        // fix for JDK-8145515
        if (getNode().getProperties().containsKey(DISABLE_FORWARD_TO_PARENT)) {
            return;
        }

        if (getNode().getParent() != null) {
            getNode().getParent().fireEvent(event);
        }
    }

    protected void selectHome() {
        getNode().selectHome();
    }

    protected void selectEnd() {
        getNode().selectEnd();
    }

    protected void selectHomeExtend() {
        getNode().extendSelection(0);
    }

    protected void selectEndExtend() {
        TextInputControl textInputControl = getNode();
        textInputControl.extendSelection(textInputControl.getLength());
    }

    private boolean editing = false;
    protected void setEditing(boolean b) {
        editing = b;
    }
    public boolean isEditing() {
        return editing;
    }

    protected void populateContextMenu() {
        TextInputControl textInputControl = getNode();
        boolean editable = textInputControl.isEditable();
        boolean hasText = (textInputControl.getLength() &gt; 0);
        boolean hasSelection = (textInputControl.getSelection().getLength() &gt; 0);
        boolean allSelected = (textInputControl.getSelection().getLength() == textInputControl.getLength());
        boolean maskText = (textInputControl instanceof PasswordField); // (maskText(&quot;A&quot;) != &quot;A&quot;);
        ObservableList&lt;MenuItem&gt; items = contextMenu.getItems();

        if (SHOW_HANDLES) {
            items.clear();
            if (!maskText &amp;&amp; hasSelection) {
                if (editable) {
                    items.add(cutMI);
                }
                items.add(copyMI);
            }
            if (editable &amp;&amp; Clipboard.getSystemClipboard().hasString()) {
                items.add(pasteMI);
            }
            if (hasText &amp;&amp; !allSelected) {
                if (!hasSelection &amp;&amp; !(textInputControl instanceof PasswordField)) {
                    items.add(selectWordMI);
                }
                items.add(selectAllMI);
            }
            selectWordMI.getProperties().put(&quot;refreshMenu&quot;, Boolean.TRUE);
            selectAllMI.getProperties().put(&quot;refreshMenu&quot;, Boolean.TRUE);
        } else {
            if (editable) {
                items.setAll(undoMI, redoMI, cutMI, copyMI, pasteMI, deleteMI,
                        separatorMI, selectAllMI);
            } else {
                items.setAll(copyMI, separatorMI, selectAllMI);
            }
            undoMI.setDisable(!getNode().isUndoable());
            redoMI.setDisable(!getNode().isRedoable());
            cutMI.setDisable(maskText || !hasSelection);
            copyMI.setDisable(maskText || !hasSelection);
            pasteMI.setDisable(!Clipboard.getSystemClipboard().hasString());
            deleteMI.setDisable(!hasSelection);
        }
    }

    private static class ContextMenuItem extends MenuItem {
        ContextMenuItem(final String action, EventHandler&lt;ActionEvent&gt; onAction) {
            super(getString(&quot;TextInputControl.menu.&quot; + action));
            setOnAction(onAction);
        }
    }

    private final MenuItem undoMI   = new ContextMenuItem(&quot;Undo&quot;, e -&gt; undo());
    private final MenuItem redoMI   = new ContextMenuItem(&quot;Redo&quot;, e -&gt; redo());
    private final MenuItem cutMI    = new ContextMenuItem(&quot;Cut&quot;, e -&gt; cut());
    private final MenuItem copyMI   = new ContextMenuItem(&quot;Copy&quot;, e -&gt; getNode().copy());
    private final MenuItem pasteMI  = new ContextMenuItem(&quot;Paste&quot;, e -&gt; paste());
    private final MenuItem deleteMI = new ContextMenuItem(&quot;DeleteSelection&quot;, e -&gt; deleteSelection());
    private final MenuItem selectWordMI = new ContextMenuItem(&quot;SelectWord&quot;, e -&gt; selectWord());
    private final MenuItem selectAllMI = new ContextMenuItem(&quot;SelectAll&quot;, e -&gt; selectAll());
    private final MenuItem separatorMI = new SeparatorMenuItem();

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/inputmap/InputMap.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.javafx.scene.control.inputmap;

import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.scene.Node;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.util.Pair;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * InputMap is a class that is set on a given {@link Node}. When the Node receives
 * an input event from the system, it passes this event in to the InputMap where
 * the InputMap can check all installed
 * {@link InputMap.Mapping mappings} to see if there is any
 * suitable mapping, and if so, fire the provided {@link EventHandler}.
 *
 * @param &lt;N&gt; The type of the Node that the InputMap is installed in.
 * @since 9
 */
public class InputMap&lt;N extends Node&gt; implements EventHandler&lt;Event&gt; {

    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private final N node;

    private final ObservableList&lt;InputMap&lt;N&gt;&gt; childInputMaps;

    private final ObservableList&lt;Mapping&lt;?&gt;&gt; mappings;

//    private final ObservableList&lt;Predicate&lt;? extends Event&gt;&gt; interceptors;

    private final Map&lt;EventType&lt;?&gt;, List&lt;EventHandler&lt;? super Event&gt;&gt;&gt; installedEventHandlers;

    private final Map&lt;EventType, List&lt;Mapping&gt;&gt; eventTypeMappings;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates the new InputMap instance which is related specifically to the
     * given Node.
     * @param node The Node for which this InputMap is attached.
     */
    public InputMap(N node) {
        if (node == null) {
            throw new IllegalArgumentException(&quot;Node can not be null&quot;);
        }

        this.node = node;
        this.eventTypeMappings = new HashMap&lt;&gt;();
        this.installedEventHandlers = new HashMap&lt;&gt;();
//        this.interceptors = FXCollections.observableArrayList();

        // listeners
        this.mappings = FXCollections.observableArrayList();
        mappings.addListener((ListChangeListener&lt;Mapping&lt;?&gt;&gt;) c -&gt; {
            while (c.next()) {
                // TODO handle mapping removal
                if (c.wasRemoved()) {
                    for (Mapping&lt;?&gt; mapping : c.getRemoved()) {
                        removeMapping(mapping);
                    }
                }

                if (c.wasAdded()) {
                    List&lt;Mapping&lt;?&gt;&gt; toRemove = new ArrayList&lt;&gt;();
                    for (Mapping&lt;?&gt; mapping : c.getAddedSubList()) {
                        if (mapping == null) {
                            toRemove.add(null);
                        } else {
                            addMapping(mapping);
                        }
                    }

                    if (!toRemove.isEmpty()) {
                        getMappings().removeAll(toRemove);
                        throw new IllegalArgumentException(&quot;Null mappings not permitted&quot;);
                    }
                }
            }
        });

        childInputMaps = FXCollections.observableArrayList();
        childInputMaps.addListener((ListChangeListener&lt;InputMap&lt;N&gt;&gt;) c -&gt; {
            while (c.next()) {
                if (c.wasRemoved()) {
                    for (InputMap&lt;N&gt; map : c.getRemoved()) {
                        map.setParentInputMap(null);
                    }
                }

                if (c.wasAdded()) {
                    List&lt;InputMap&lt;N&gt;&gt; toRemove = new ArrayList&lt;&gt;();
                    for (InputMap&lt;N&gt; map : c.getAddedSubList()) {
                        // we check that the child input map maps to the same node
                        // as this input map
                        if (map.getNode() != getNode()) {
                            toRemove.add(map);
                        } else {
                            map.setParentInputMap(this);
                        }
                    }

                    if (!toRemove.isEmpty()) {
                        getChildInputMaps().removeAll(toRemove);
                        throw new IllegalArgumentException(&quot;Child InputMap intances need to share a common Node object&quot;);
                    }
                }
            }
        });
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- parent behavior - for now this is an private property
    private ReadOnlyObjectWrapper&lt;InputMap&lt;N&gt;&gt; parentInputMap = new ReadOnlyObjectWrapper&lt;InputMap&lt;N&gt;&gt;(this, &quot;parentInputMap&quot;) {
        @Override protected void invalidated() {
            // whenever the parent InputMap changes, we uninstall all mappings and
            // then reprocess them so that they are installed in the correct root.
            reprocessAllMappings();
        }
    };
    private final void setParentInputMap(InputMap&lt;N&gt; value) { parentInputMap.set(value); }
    private final InputMap&lt;N&gt; getParentInputMap() {return parentInputMap.get(); }
    private final ReadOnlyObjectProperty&lt;InputMap&lt;N&gt;&gt; parentInputMapProperty() { return parentInputMap.getReadOnlyProperty(); }


    // --- interceptor
    /**
     * The role of the interceptor is to block the InputMap on which it is
     * set from executing any mappings (contained within itself, or within a
     * {@link #getChildInputMaps() child InputMap}, whenever the interceptor
     * returns true. The interceptor is called every time an input event is received,
     * and is allowed to reason on the given input event
     * before returning a boolean value, where boolean true means block
     * execution, and boolean false means to allow execution.
     */
    private ObjectProperty&lt;Predicate&lt;? extends Event&gt;&gt; interceptor = new SimpleObjectProperty&lt;&gt;(this, &quot;interceptor&quot;);
    public final Predicate&lt;? extends Event&gt; getInterceptor() {
        return interceptor.get();
    }
    public final void setInterceptor(Predicate&lt;? extends Event&gt; value) {
        interceptor.set(value);
    }
    public final ObjectProperty&lt;Predicate&lt;? extends Event&gt;&gt; interceptorProperty() {
        return interceptor;
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * The Node for which this InputMap is attached.
     */
    public final N getNode() {
        return node;
    }

    /**
     * A mutable list of input mappings. Each will be considered whenever an
     * input event is being looked up, and one of which may be used to handle
     * the input event, based on the specifificity returned by each mapping
     * (that is, the mapping with the highest specificity wins).
     */
    public ObservableList&lt;Mapping&lt;?&gt;&gt; getMappings() {
        return mappings;
    }

    /**
     * A mutable list of child InputMaps. An InputMap may have child input maps,
     * as this allows for easy addition
     * of mappings that are state-specific. For example, if a Node can be in two
     * different states, and the input mappings are different for each, then it
     * makes sense to have one root (and empty) InputMap, with two children
     * input maps, where each is populated with the specific input mappings for
     * one of the two states. To prevent the wrong input map from being considered,
     * it is simply a matter of setting an appropriate
     * {@link #interceptorProperty() interceptor} on each map, so that they are only
     * considered in one of the two states.
     */
    public ObservableList&lt;InputMap&lt;N&gt;&gt; getChildInputMaps() {
        return childInputMaps;
    }

    /**
     * Disposes all child InputMaps, removes all event handlers from the Node,
     * and clears the mappings list.
     */
    public void dispose() {
        for (InputMap&lt;N&gt; childInputMap : getChildInputMaps()) {
            childInputMap.dispose();
        }

        // uninstall event handlers
        removeAllEventHandlers();

        // clear out all mappings
        getMappings().clear();
    }

    /** {@inheritDoc} */
    @Override public void handle(Event e) {
        if (e == null || e.isConsumed()) return;

        List&lt;Mapping&lt;?&gt;&gt; mappings = lookup(e, true);
        for (Mapping&lt;?&gt; mapping : mappings) {
            EventHandler eventHandler = mapping.getEventHandler();
            if (eventHandler != null) {
                eventHandler.handle(e);
            }

            if (mapping.isAutoConsume()) {
                e.consume();
            }

            if (e.isConsumed()) {
                break;
            }

            // If we are here, the event has not been consumed, so we continue
            // looping through our list of matches. Refer to the documentation in
            // lookup(Event) for more details on the list ordering.
        }
    }

    /**
     * Looks up the most specific mapping given the input, ignoring all
     * interceptors. The valid values that can be passed into this method is
     * based on the values returned by the {@link Mapping#getMappingKey()}
     * method. Based on the subclasses of Mapping that ship with JavaFX, the
     * valid values are therefore:
     *
     * &lt;ul&gt;
     *     &lt;li&gt;&lt;strong&gt;KeyMapping:&lt;/strong&gt; A valid {@link KeyBinding}.&lt;/li&gt;
     *     &lt;li&gt;&lt;strong&gt;MouseMapping:&lt;/strong&gt; A valid {@link MouseEvent} event
     *     type (e.g. {@code MouseEvent.MOUSE_PRESSED}).&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * For other Mapping subclasses, refer to their javadoc, and specifically
     * what is returned by {@link Mapping#getMappingKey()},
     *
     * @param mappingKey
     * @return
     */
    // TODO return all mappings, or just the first one?
    public Optional&lt;Mapping&lt;?&gt;&gt; lookupMapping(Object mappingKey) {
        if (mappingKey == null) {
            return Optional.empty();
        }

        List&lt;Mapping&lt;?&gt;&gt; mappings = lookupMappingKey(mappingKey);

        // descend into our child input maps as well
        for (int i = 0; i &lt; getChildInputMaps().size(); i++) {
            InputMap&lt;N&gt; childInputMap = getChildInputMaps().get(i);

            List&lt;Mapping&lt;?&gt;&gt; childMappings = childInputMap.lookupMappingKey(mappingKey);
            mappings.addAll(0, childMappings);
        }

        return mappings.size() &gt; 0 ? Optional.of(mappings.get(0)) : Optional.empty();
    }




    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private List&lt;Mapping&lt;?&gt;&gt; lookupMappingKey(Object mappingKey) {
        return getMappings().stream()
                .filter(mapping -&gt; !mapping.isDisabled())
                .filter(mapping -&gt; mappingKey.equals(mapping.getMappingKey()))
                .collect(Collectors.toList());
    }

    /*
     * Returns a List of Mapping instances, in priority order (from highest priority
     * to lowest priority). All mappings in the list have the same value specificity,
     * so are ranked based on the input map (with the leaf input maps taking
     * precedence over parent / root input maps).
     */
    private List&lt;Mapping&lt;?&gt;&gt; lookup(Event event, boolean testInterceptors) {
        // firstly we look at ourselves to see if we have a mapping, assuming our
        // interceptors are valid
        if (testInterceptors) {
            boolean interceptorsApplies = testInterceptor(event, getInterceptor());

            if (interceptorsApplies) {
                return Collections.emptyList();
            }
        }

        List&lt;Mapping&lt;?&gt;&gt; mappings = new ArrayList&lt;&gt;();

        int minSpecificity = 0;
        List&lt;Pair&lt;Integer, Mapping&lt;?&gt;&gt;&gt; results = lookupMappingAndSpecificity(event, minSpecificity);
        if (! results.isEmpty()) {
            minSpecificity = results.get(0).getKey();
            mappings.addAll(results.stream().map(pair -&gt; pair.getValue()).collect(Collectors.toList()));
        }

        // but we always descend into our child input maps as well, to see if there
        // is a more specific mapping there. If there is a mapping of equal
        // specificity, we take the child mapping over the parent mapping.
        for (int i = 0; i &lt; getChildInputMaps().size(); i++) {
            InputMap childInputMap = getChildInputMaps().get(i);
            minSpecificity = scanRecursively(childInputMap, event, testInterceptors, minSpecificity, mappings);
        }

        return mappings;
    }

    private int scanRecursively(InputMap&lt;?&gt; inputMap, Event event, boolean testInterceptors, int minSpecificity, List&lt;Mapping&lt;?&gt;&gt; mappings) {
        // test if the childInputMap should be considered
        if (testInterceptors) {
            boolean interceptorsApplies = testInterceptor(event, inputMap.getInterceptor());
            if (interceptorsApplies) {
                return minSpecificity;
            }
        }

        // look at the given InputMap
        List&lt;Pair&lt;Integer, Mapping&lt;?&gt;&gt;&gt; childResults = inputMap.lookupMappingAndSpecificity(event, minSpecificity);
        if (!childResults.isEmpty()) {
            int specificity = childResults.get(0).getKey();
            List&lt;Mapping&lt;?&gt;&gt; childMappings = childResults.stream()
                    .map(pair -&gt; pair.getValue())
                    .collect(Collectors.toList());
            if (specificity == minSpecificity) {
                mappings.addAll(0, childMappings);
            } else if (specificity &gt; minSpecificity) {
                mappings.clear();
                minSpecificity = specificity;
                mappings.addAll(childMappings);
            }
        }

        // now look at the children of this input map, if any exist
        for (int i = 0; i &lt; inputMap.getChildInputMaps().size(); i++) {
            minSpecificity = scanRecursively(inputMap.getChildInputMaps().get(i), event, testInterceptors, minSpecificity, mappings);
        }

        return minSpecificity;
    }

    private InputMap&lt;N&gt; getRootInputMap() {
        InputMap&lt;N&gt; rootInputMap = this;
        while (true) {
            if (rootInputMap == null) break;
            InputMap&lt;N&gt; parentInputMap = rootInputMap.getParentInputMap();
            if (parentInputMap == null) break;
            rootInputMap = parentInputMap;
        }
        return rootInputMap;
    }

    private void addMapping(Mapping&lt;?&gt; mapping) {
        InputMap&lt;N&gt; rootInputMap = getRootInputMap();

        // we want to track the event handlers we install, so that we can clean
        // up in the dispose() method (and also so that we don't duplicate
        // event handlers for a single event type). Because this is all handled
        // in the root InputMap, we firstly find it, and then we defer to it.
        rootInputMap.addEventHandler(mapping.eventType);

        // we maintain a separate map of all mappings, which maps from the
        // mapping event type into a list of mappings. This allows for easier
        // iteration in the lookup methods.
        EventType&lt;?&gt; et = mapping.getEventType();
        List&lt;Mapping&gt; _eventTypeMappings = this.eventTypeMappings.computeIfAbsent(et, f -&gt; new ArrayList&lt;&gt;());
        _eventTypeMappings.add(mapping);
    }

    private void removeMapping(Mapping&lt;?&gt; mapping) {
        EventType&lt;?&gt; et = mapping.getEventType();
        if (this.eventTypeMappings.containsKey(et)) {
            List&lt;?&gt; _eventTypeMappings = this.eventTypeMappings.get(et);
            _eventTypeMappings.remove(mapping);

            // TODO remove the event handler in the root if there are no more mappings of this type
            // anywhere in the input map tree
        }
    }

    private void addEventHandler(EventType et) {
        List&lt;EventHandler&lt;? super Event&gt;&gt; eventHandlers =
                installedEventHandlers.computeIfAbsent(et, f -&gt; new ArrayList&lt;&gt;());

        final EventHandler&lt;? super Event&gt; eventHandler = this::handle;

        if (eventHandlers.isEmpty()) {
//            System.out.println(&quot;Added event handler for type &quot; + et);
            node.addEventHandler(et, eventHandler);
        }

        // We need to store these event handlers so we can dispose cleanly.
        eventHandlers.add(eventHandler);
    }

    private void removeAllEventHandlers() {
        for (EventType&lt;?&gt; et : installedEventHandlers.keySet()) {
            List&lt;EventHandler&lt;? super Event&gt;&gt; handlers = installedEventHandlers.get(et);
            for (EventHandler&lt;? super Event&gt; handler : handlers) {
//                System.out.println(&quot;Removed event handler for type &quot; + et);
                node.removeEventHandler(et, handler);
            }
        }
    }

    private void reprocessAllMappings() {
        removeAllEventHandlers();
        this.mappings.stream().forEach(this::addMapping);

        // now do the same for all children
        for (InputMap&lt;N&gt; child : getChildInputMaps()) {
            child.reprocessAllMappings();
        }
    }

    private List&lt;Pair&lt;Integer, Mapping&lt;?&gt;&gt;&gt; lookupMappingAndSpecificity(final Event event, final int minSpecificity) {
        int _minSpecificity = minSpecificity;

        List&lt;Mapping&gt; mappings = this.eventTypeMappings.getOrDefault(event.getEventType(), Collections.emptyList());
        List&lt;Pair&lt;Integer, Mapping&lt;?&gt;&gt;&gt; result = new ArrayList&lt;&gt;();
        for (Mapping mapping : mappings) {
            if (mapping.isDisabled()) continue;

            // test if mapping has an interceptor that will block this event.
            // Interceptors return true if the interception should occur.
            boolean interceptorsApplies = testInterceptor(event, mapping.getInterceptor());
            if (interceptorsApplies) {
                continue;
            }

            int specificity = mapping.getSpecificity(event);
            if (specificity &gt; 0 &amp;&amp; specificity == _minSpecificity) {
                result.add(new Pair&lt;&gt;(specificity, mapping));
            } else if (specificity &gt; _minSpecificity) {
                result.clear();
                result.add(new Pair&lt;&gt;(specificity, mapping));
                _minSpecificity = specificity;
            }
        }

        return result;
    }

    // Interceptors return true if the interception should occur.
    private boolean testInterceptor(Event e, Predicate interceptor) {
        return interceptor != null &amp;&amp; interceptor.test(e);
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    /**
     * Abstract base class for all input mappings as used by the
     * {@link InputMap} class.
     *
     * @param &lt;T&gt; The type of {@link Event} the mapping represents.
     */
    public static abstract class Mapping&lt;T extends Event&gt; {

        /***********************************************************************
         *                                                                     *
         * Private fields                                                      *
         *                                                                     *
         **********************************************************************/
        private final EventType&lt;T&gt; eventType;
        private final EventHandler&lt;T&gt; eventHandler;



        /***********************************************************************
         *                                                                     *
         * Constructors                                                        *
         *                                                                     *
         **********************************************************************/

        /**
         * Creates a new Mapping instance.
         *
         * @param eventType The {@link EventType} that is being listened for.
         * @param eventHandler The {@link EventHandler} to fire when the mapping
         *                     is selected as the most-specific mapping.
         */
        public Mapping(final EventType&lt;T&gt; eventType, final EventHandler&lt;T&gt; eventHandler) {
            this.eventType = eventType;
            this.eventHandler = eventHandler;
        }



        /***********************************************************************
         *                                                                     *
         * Abstract methods                                                    *
         *                                                                     *
         **********************************************************************/

        /**
         * This method must be implemented by all mapping implementations such
         * that it returns an integer value representing how closely the mapping
         * matches the given {@link Event}. The higher the number, the greater
         * the match. This allows the InputMap to determine
         * which mapping is most specific, and to therefore fire the appropriate
         * mapping {@link Mapping#getEventHandler() EventHandler}.
         *
         * @param event The {@link Event} that needs to be assessed for its
         *              specificity.
         * @return An integer indicating how close of a match the mapping is to
         *          the given Event. The higher the number, the greater the match.
         */
        public abstract int getSpecificity(Event event);



        /***********************************************************************
         *                                                                     *
         * Properties                                                          *
         *                                                                     *
         **********************************************************************/

        // --- disabled
        /**
         * By default all mappings are enabled (so this disabled property is set
         * to false by default). In some cases it is useful to be able to disable
         * a mapping until it is applicable. In these cases, users may simply
         * toggle the disabled property until desired.
         *
         * &lt;p&gt;When the disabled property is true, the mapping will not be
         * considered when input events are received, even if it is the most
         * specific mapping available.&lt;/p&gt;
         */
        private BooleanProperty disabled = new SimpleBooleanProperty(this, &quot;disabled&quot;, false);
        public final void setDisabled(boolean value) { disabled.set(value); }
        public final boolean isDisabled() {return disabled.get(); }
        public final BooleanProperty disabledProperty() { return disabled; }


        // --- auto consume
        /**
         * By default mappings are set to 'auto consume' their specified event
         * handler. This means that the event handler will not propagate further,
         * but in some cases this is not desirable - sometimes it is preferred
         * that the event continue to 'bubble up' to parent nodes so that they
         * may also benefit from receiving this event. In these cases, it is
         * important that this autoConsume property be changed from the default
         * boolean true to instead be boolean false.
<A NAME="8"></A>         */
        private BooleanProperty autoConsume = new SimpleBooleanProperty(this, &quot;autoConsume&quot;, true);
        public final void setAutoConsume(boolean value) { autoConsume.set(value); }
        public final boolean isAutoConsume() {<FONT color="#bce954"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#8',2,'match37-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return autoConsume.get(); }
        public final BooleanProperty autoConsumeProperty() { return autoConsume; }



        /***********************************************************************
         *                                                                     *
         * Public API                                                          *
         *                                                                     *
         **********************************************************************/

        /**
         * The {@link EventType} that is being listened for.
         */
        public final EventType&lt;T&gt; getEventType() {
            return eventType;
        }

        /**
         * The {@link EventHandler} that will be fired should this mapping be
         * the most-specific mapping for a given input, and should it not be
         * blocked by an interceptor (either at a
         * {@link InputMap#interceptorProperty() input map} level or a
         * {@link Mapping#interceptorProperty() mapping} level).
         */
        public final EventHandler&lt;T&gt; getEventHandler() {</B></FONT>
            return eventHandler;
        }


        // --- interceptor
        /**
         * The role of the interceptor is to block the mapping on which it is
         * set from executing, whenever the interceptor returns true. The
         * interceptor is called every time the mapping is the best match for
         * a given input event, and is allowed to reason on the given input event
         * before returning a boolean value, where boolean true means block
         * execution, and boolean false means to allow execution.
         */
        private ObjectProperty&lt;Predicate&lt;? extends Event&gt;&gt; interceptor = new SimpleObjectProperty&lt;&gt;(this, &quot;interceptor&quot;);
        public final Predicate&lt;? extends Event&gt; getInterceptor() {
            return interceptor.get();
        }
        public final void setInterceptor(Predicate&lt;? extends Event&gt; value) {
            interceptor.set(value);
        }
        public final ObjectProperty&lt;Predicate&lt;? extends Event&gt;&gt; interceptorProperty() {
            return interceptor;
        }

        /**
         *
         * @return
         */
        public Object getMappingKey() {
            return eventType;
        }

        /** {@inheritDoc} */
        @Override public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Mapping)) return false;

            Mapping that = (Mapping) o;

            if (eventType != null ? !eventType.equals(that.getEventType()) : that.getEventType() != null)  return false;

            return true;
        }

        /** {@inheritDoc} */
        @Override public int hashCode() {
            return eventType != null ? eventType.hashCode() : 0;
        }
    }

    /**
     * The KeyMapping class provides API to specify
     * {@link InputMap.Mapping mappings} related to key input.
     */
    public static class KeyMapping extends Mapping&lt;KeyEvent&gt; {

        /***********************************************************************
         *                                                                     *
         * Private fields                                                      *
         *                                                                     *
         **********************************************************************/
        private final KeyBinding keyBinding;



        /***********************************************************************
         *                                                                     *
         * Constructors                                                        *
         *                                                                     *
         **********************************************************************/

        /**
         * Creates a new KeyMapping instance that will fire when the given
         * {@link KeyCode} is entered into the application by the user, and this
         * will result in the given {@link EventHandler} being fired.
         *
         * @param keyCode The {@link KeyCode} to listen for.
         * @param eventHandler The {@link EventHandler} to fire when the
         *           {@link KeyCode} is observed.
         */
        public KeyMapping(final KeyCode keyCode, final EventHandler&lt;KeyEvent&gt; eventHandler) {
            this(new KeyBinding(keyCode), eventHandler);
        }

        /**
         * Creates a new KeyMapping instance that will fire when the given
         * {@link KeyCode} is entered into the application by the user, and this
         * will result in the given {@link EventHandler} being fired. The
         * eventType argument can be one of the following:
         *
         * &lt;ul&gt;
         *     &lt;li&gt;{@link KeyEvent#ANY}&lt;/li&gt;
         *     &lt;li&gt;{@link KeyEvent#KEY_PRESSED}&lt;/li&gt;
         *     &lt;li&gt;{@link KeyEvent#KEY_TYPED}&lt;/li&gt;
         *     &lt;li&gt;{@link KeyEvent#KEY_RELEASED}&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * @param keyCode The {@link KeyCode} to listen for.
         * @param eventType The type of {@link KeyEvent} to listen for.
         * @param eventHandler The {@link EventHandler} to fire when the
         *           {@link KeyCode} is observed.
         */
        public KeyMapping(final KeyCode keyCode, final EventType&lt;KeyEvent&gt; eventType, final EventHandler&lt;KeyEvent&gt; eventHandler) {
            this(new KeyBinding(keyCode, eventType), eventHandler);
        }

        /**
         * Creates a new KeyMapping instance that will fire when the given
         * {@link KeyBinding} is entered into the application by the user, and this
         * will result in the given {@link EventHandler} being fired.
         *
         * @param keyBinding The {@link KeyBinding} to listen for.
         * @param eventHandler The {@link EventHandler} to fire when the
         *           {@link KeyBinding} is observed.
         */
        public KeyMapping(KeyBinding keyBinding, final EventHandler&lt;KeyEvent&gt; eventHandler) {
            this(keyBinding, eventHandler, null);
        }

        /**
         * Creates a new KeyMapping instance that will fire when the given
         * {@link KeyBinding} is entered into the application by the user, and this
         * will result in the given {@link EventHandler} being fired, as long as the
         * given interceptor is not true.
         *
         * @param keyBinding The {@link KeyBinding} to listen for.
         * @param eventHandler The {@link EventHandler} to fire when the
         *           {@link KeyBinding} is observed.
         * @param interceptor A {@link Predicate} that, if true, will prevent the
         *            {@link EventHandler} from being fired.
         */
        public KeyMapping(KeyBinding keyBinding, final EventHandler&lt;KeyEvent&gt; eventHandler, Predicate&lt;KeyEvent&gt; interceptor) {
            super(keyBinding == null ? null : keyBinding.getType(), eventHandler);
            if (keyBinding == null) {
                throw new IllegalArgumentException(&quot;KeyMapping keyBinding constructor argument can not be null&quot;);
            }
            this.keyBinding = keyBinding;
            setInterceptor(interceptor);
        }



        /***********************************************************************
         *                                                                     *
         * Public API                                                          *
         *                                                                     *
         **********************************************************************/

        /** {@inheritDoc} */
        @Override public Object getMappingKey() {
            return keyBinding;
        }

        /** {@inheritDoc} */
        @Override public int getSpecificity(Event e) {
            if (isDisabled()) return 0;
            if (!(e instanceof KeyEvent)) return 0;
            return keyBinding.getSpecificity((KeyEvent)e);
        }

        /** {@inheritDoc} */
        @Override public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof KeyMapping)) return false;
            if (!super.equals(o)) return false;

            KeyMapping that = (KeyMapping) o;

            // we know keyBinding is non-null here
            return keyBinding.equals(that.keyBinding);
        }

        /** {@inheritDoc} */
        @Override public int hashCode() {
            return Objects.hash(keyBinding);
        }
    }



    /**
     * The MouseMapping class provides API to specify
     * {@link InputMap.Mapping mappings} related to mouse input.
     */
    public static class MouseMapping extends Mapping&lt;MouseEvent&gt; {

        /***********************************************************************
         *                                                                     *
         * Constructors                                                        *
         *                                                                     *
         **********************************************************************/

        /**
         * Creates a new KeyMapping instance that will fire when the given
         * {@link KeyCode} is entered into the application by the user, and this
         * will result in the given {@link EventHandler} being fired. The
         * eventType argument can be any of the {@link MouseEvent} event types,
         * but typically it is one of the following:
         *
         * &lt;ul&gt;
         *     &lt;li&gt;{@link MouseEvent#ANY}&lt;/li&gt;
         *     &lt;li&gt;{@link MouseEvent#MOUSE_PRESSED}&lt;/li&gt;
         *     &lt;li&gt;{@link MouseEvent#MOUSE_CLICKED}&lt;/li&gt;
         *     &lt;li&gt;{@link MouseEvent#MOUSE_RELEASED}&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * @param eventType The type of {@link MouseEvent} to listen for.
         * @param eventHandler The {@link EventHandler} to fire when the
         *           {@link MouseEvent} is observed.
         */
        public MouseMapping(final EventType&lt;MouseEvent&gt; eventType, final EventHandler&lt;MouseEvent&gt; eventHandler) {
            super(eventType, eventHandler);
            if (eventType == null) {
                throw new IllegalArgumentException(&quot;MouseMapping eventType constructor argument can not be null&quot;);
            }
        }



        /***********************************************************************
         *                                                                     *
         * Public API                                                          *
         *                                                                     *
         **********************************************************************/

        /** {@inheritDoc} */
        @Override public int getSpecificity(Event e) {
            if (isDisabled()) return 0;
            if (!(e instanceof MouseEvent)) return 0;
            EventType&lt;MouseEvent&gt; et = getEventType();

            // FIXME naive
            int s = 0;
            if (e.getEventType() == MouseEvent.MOUSE_CLICKED &amp;&amp; et != MouseEvent.MOUSE_CLICKED) return 0; else s++;
            if (e.getEventType() == MouseEvent.MOUSE_DRAGGED &amp;&amp; et != MouseEvent.MOUSE_DRAGGED) return 0; else s++;
            if (e.getEventType() == MouseEvent.MOUSE_ENTERED &amp;&amp; et != MouseEvent.MOUSE_ENTERED) return 0; else s++;
            if (e.getEventType() == MouseEvent.MOUSE_ENTERED_TARGET &amp;&amp; et != MouseEvent.MOUSE_ENTERED_TARGET) return 0; else s++;
            if (e.getEventType() == MouseEvent.MOUSE_EXITED &amp;&amp; et != MouseEvent.MOUSE_EXITED) return 0; else s++;
            if (e.getEventType() == MouseEvent.MOUSE_EXITED_TARGET &amp;&amp; et != MouseEvent.MOUSE_EXITED_TARGET) return 0; else s++;
            if (e.getEventType() == MouseEvent.MOUSE_MOVED &amp;&amp; et != MouseEvent.MOUSE_MOVED) return 0; else s++;
            if (e.getEventType() == MouseEvent.MOUSE_PRESSED &amp;&amp; et != MouseEvent.MOUSE_PRESSED) return 0; else s++;
            if (e.getEventType() == MouseEvent.MOUSE_RELEASED &amp;&amp; et != MouseEvent.MOUSE_RELEASED) return 0; else s++;

            // TODO handle further checks

            return s;
        }
    }

    /**
     * Convenience class that can act as an keyboard input interceptor, either at a
     * {@link InputMap#interceptorProperty() input map} level or a
     * {@link Mapping#interceptorProperty() mapping} level.
     *
     * @see InputMap#interceptorProperty()
     * @see Mapping#interceptorProperty()
     */
    public static class KeyMappingInterceptor implements Predicate&lt;Event&gt; {

        private final KeyBinding keyBinding;

        /**
         * Creates a new KeyMappingInterceptor, which will block execution of
         * event handlers (either at a
         * {@link InputMap#interceptorProperty() input map} level or a
         * {@link Mapping#interceptorProperty() mapping} level), where the input
         * received is equal to the given {@link KeyBinding}.
         *
         * @param keyBinding The {@link KeyBinding} for which mapping execution
         *                   should be blocked.
         */
        public KeyMappingInterceptor(KeyBinding keyBinding) {
            this.keyBinding = keyBinding;
        }

        /**  {@inheritDoc} */
        public boolean test(Event event) {
            if (!(event instanceof KeyEvent)) return false;
            return KeyBinding.toKeyBinding((KeyEvent)event).equals(keyBinding);
        }
    }

    /**
     * Convenience class that can act as a mouse input interceptor, either at a
     * {@link InputMap#interceptorProperty() input map} level or a
     * {@link Mapping#interceptorProperty() mapping} level.
     *
     * @see InputMap#interceptorProperty()
     * @see Mapping#interceptorProperty()
     */
    public static class MouseMappingInterceptor implements Predicate&lt;Event&gt; {

        private final EventType&lt;MouseEvent&gt; eventType;

        /**
         * Creates a new MouseMappingInterceptor, which will block execution of
         * event handlers (either at a
         * {@link InputMap#interceptorProperty() input map} level or a
         * {@link Mapping#interceptorProperty() mapping} level), where the input
         * received is equal to the given {@link EventType}.
         *
         * @param eventType The {@link EventType} for which mapping execution
         *                  should be blocked (typically one of
         *                  {@link MouseEvent#MOUSE_PRESSED},
         *                  {@link MouseEvent#MOUSE_CLICKED}, or
         *                  {@link MouseEvent#MOUSE_RELEASED}).
         */
        public MouseMappingInterceptor(EventType&lt;MouseEvent&gt; eventType) {
            this.eventType = eventType;
        }

        /**  {@inheritDoc} */
        public boolean test(Event event) {
            if (!(event instanceof MouseEvent)) return false;
            return event.getEventType() == this.eventType;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/skin/FXVKSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.skin;

import javafx.animation.Animation;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.geometry.VPos;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.SkinBase;
import javafx.scene.control.TextInputControl;
import javafx.scene.control.TextField;
import javafx.scene.control.TextArea;
import javafx.scene.control.ComboBoxBase;
import javafx.scene.Scene;
import javafx.scene.control.skin.TextAreaSkin;
import javafx.scene.input.InputEvent;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.layout.Region;
import javafx.scene.text.Text;
import javafx.stage.Popup;
import javafx.stage.Window;
import javafx.util.Duration;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.HashMap;
import static javafx.scene.input.MouseEvent.MOUSE_PRESSED;
import static javafx.scene.input.TouchEvent.TOUCH_PRESSED;
import static javafx.scene.layout.Region.USE_PREF_SIZE;
import java.security.AccessController;
import java.security.PrivilegedAction;


public class FXVKSkin extends SkinBase&lt;FXVK&gt; {

    private static final int GAP = 6;

    private List&lt;List&lt;Key&gt;&gt; currentBoard;
    private static HashMap&lt;String, List&lt;List&lt;Key&gt;&gt;&gt; boardMap = new HashMap&lt;String, List&lt;List&lt;Key&gt;&gt;&gt;();
    private int numCols;

    private boolean capsDown = false;
    private boolean shiftDown = false;
    private boolean isSymbol = false;
    long lastTime = -1L;

    void clearShift() {
        if (shiftDown &amp;&amp; !capsDown) {
            shiftDown = false;
            updateKeys();
        }
        lastTime = -1L;
    }

    void pressShift() {
        long time = System.currentTimeMillis();

        //potential for a shift lock
        if (shiftDown &amp;&amp; !capsDown) {
            if (lastTime &gt; 0L &amp;&amp; time - lastTime &lt; 400L) {
                //set caps lock
                shiftDown = false;
                capsDown =  true;
            } else {
                //set normal
                shiftDown = false;
                capsDown =  false;
            }
        } else if (!shiftDown &amp;&amp; !capsDown) {
            // set shift
            shiftDown=true;
        } else {
            //set to normal
            shiftDown = false;
            capsDown =  false;
        }

        updateKeys();
        lastTime = time;
    }

    void clearSymbolABC() {
        isSymbol = false;
        updateKeys();
    }

    void pressSymbolABC() {
        isSymbol = !isSymbol;
        updateKeys();
    }

    void clearStateKeys() {
        capsDown = false;
        shiftDown = false;
        isSymbol = false;
        lastTime = -1L;
        updateKeys();
    }

    private void updateKeys() {
        for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {
                key.update(capsDown, shiftDown, isSymbol);
            }
        }
    }

    private static Popup vkPopup;
    private static Popup secondaryPopup;
    private static FXVK primaryVK;

    private static Timeline slideInTimeline = new Timeline();
    private static Timeline slideOutTimeline = new Timeline();
    private static boolean hideAfterSlideOut = false;

    private static FXVK secondaryVK;
    private static Timeline secondaryVKDelay;
    private static CharKey secondaryVKKey;
    private static TextInputKey repeatKey;

    private static Timeline repeatInitialDelay;
    private static Timeline repeatSubsequentDelay;

    // key repeat initial delay (ms)
    private static double KEY_REPEAT_DELAY = 400;
    private static double KEY_REPEAT_DELAY_MIN = 100;
    private static double KEY_REPEAT_DELAY_MAX = 1000;

    // key repeat rate (cps)
    private static double KEY_REPEAT_RATE = 25;
    private static double KEY_REPEAT_RATE_MIN = 2;
    private static double KEY_REPEAT_RATE_MAX = 50;

    private Node attachedNode;
    private String vkType = null;

    FXVK fxvk;

    static final double VK_HEIGHT = 243;
    static final double VK_SLIDE_MILLIS = 250;
    static final double PREF_PORTRAIT_KEY_WIDTH = 40;
    static final double PREF_KEY_HEIGHT = 56;

    static boolean vkAdjustWindow = false;
    static boolean vkLookup = false;

    static {
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            String s = System.getProperty(&quot;com.sun.javafx.vk.adjustwindow&quot;);
            if (s != null) {
                vkAdjustWindow = Boolean.valueOf(s);
            }
            s = System.getProperty(&quot;com.sun.javafx.sqe.vk.lookup&quot;);
            if (s != null) {
                vkLookup = Boolean.valueOf(s);
            }
            s = System.getProperty(&quot;com.sun.javafx.virtualKeyboard.backspaceRepeatDelay&quot;);
            if (s != null) {
                Double delay = Double.valueOf(s);
                KEY_REPEAT_DELAY = Math.min(Math.max(delay, KEY_REPEAT_DELAY_MIN), KEY_REPEAT_DELAY_MAX);
            }
            s = System.getProperty(&quot;com.sun.javafx.virtualKeyboard.backspaceRepeatRate&quot;);
            if (s != null) {
                Double rate = Double.valueOf(s);
                if (rate &lt;= 0) {
                    //disable key repeat
                    KEY_REPEAT_RATE = 0;
                } else {
                    KEY_REPEAT_RATE = Math.min(Math.max(rate, KEY_REPEAT_RATE_MIN), KEY_REPEAT_RATE_MAX);
                }
            }
            return null;
        });
    }

    // Proxy for read-only Window.yProperty() so we can animate.
    private static DoubleProperty winY = new SimpleDoubleProperty();
    static {
        winY.addListener(valueModel -&gt; {
            if (vkPopup != null) {
                vkPopup.setY(winY.get());
            }
        });
    }

    private static void startSlideIn() {
        slideOutTimeline.stop();
        slideInTimeline.playFromStart();
    }

    private static void startSlideOut(boolean doHide) {
        hideAfterSlideOut = doHide;
        slideInTimeline.stop();
        slideOutTimeline.playFromStart();
    }

    private void adjustWindowPosition(final Node node) {
        if ( !(node instanceof TextInputControl) ) {
            return;
        }

        // attached node y position in window coordinates
        double inputControlMinY = node.localToScene(0.0, 0.0).getY() + node.getScene().getY();
        double inputControlHeight = ((TextInputControl) node).getHeight();
        double inputControlMaxY = inputControlMinY + inputControlHeight;

        double screenHeight =
            com.sun.javafx.util.Utils.getScreen(node).getBounds().getHeight();
        double visibleAreaMaxY = screenHeight - VK_HEIGHT;

        double inputLineCenterY = 0.0;
        double inputLineBottomY = 0.0;
        double newWindowYPos = 0.0;
        double screenTopOffset = 10.0;

        if (node instanceof TextField) {
            inputLineCenterY = inputControlMinY + inputControlHeight / 2;
            inputLineBottomY = inputControlMaxY;
            //check for combo box
            Parent parent = attachedNode.getParent();
            if (parent instanceof ComboBoxBase) {
                //combo box
                // position near screen top
                newWindowYPos = Math.min(screenTopOffset - inputControlMinY, 0);
            } else {
                // position at center of visible screen area
                newWindowYPos = Math.min(visibleAreaMaxY / 2 - inputLineCenterY, 0);
            }
        } else if (node instanceof TextArea) {
            TextAreaSkin textAreaSkin = (TextAreaSkin)((TextArea)node).getSkin();
            Bounds caretBounds = textAreaSkin.getCaretBounds();
            double caretMinY = caretBounds.getMinY();
            double caretMaxY = caretBounds.getMaxY();
            inputLineCenterY = inputControlMinY + ( caretMinY + caretMaxY ) / 2;
            inputLineBottomY = inputControlMinY + caretMaxY;

            if (inputControlHeight &lt; visibleAreaMaxY) {
                // position at center of visible screen area
                newWindowYPos = visibleAreaMaxY / 2 - (inputControlMinY + inputControlHeight / 2);
            } else {
                // position the line containing the caret at center of visible screen area
                newWindowYPos = visibleAreaMaxY / 2 - inputLineCenterY;
            }
            newWindowYPos = Math.min(newWindowYPos, 0);

        } else {
            inputLineCenterY = inputControlMinY + inputControlHeight / 2;
            inputLineBottomY = inputControlMaxY;
            // position at center of visible screen area
            newWindowYPos = Math.min(visibleAreaMaxY / 2 - inputLineCenterY, 0);
        }

        Window w = node.getScene().getWindow();
        if (origWindowYPos + inputLineBottomY &gt; visibleAreaMaxY) {
            w.setY(newWindowYPos);
        } else {
            w.setY(origWindowYPos);
        }
    }

    private void saveWindowPosition(final Node node) {
        Window w = node.getScene().getWindow();
        origWindowYPos = w.getY();
    }

    private void restoreWindowPosition(final Node node) {
        if (node != null) {
            Scene scene = node.getScene();
            if (scene != null) {
                Window window = scene.getWindow();
                if (window != null) {
                    window.setY(origWindowYPos);
                }
            }
        }
    }

    EventHandler&lt;InputEvent&gt; unHideEventHandler;

    private boolean isVKHidden = false;
    private Double origWindowYPos = null;

    private void registerUnhideHandler(final Node node) {
        if (unHideEventHandler == null) {
            unHideEventHandler = event -&gt; {
                if (attachedNode != null &amp;&amp; isVKHidden) {
                    double screenHeight = com.sun.javafx.util.Utils.getScreen(attachedNode).getBounds().getHeight();
                    if (fxvk.getHeight() &gt; 0 &amp;&amp; (vkPopup.getY() &gt; screenHeight - fxvk.getHeight())) {
                        if (slideInTimeline.getStatus() != Animation.Status.RUNNING) {
                            startSlideIn();
                            if (vkAdjustWindow) {
                                adjustWindowPosition(attachedNode);
                            }
                        }
                    }
                }
                isVKHidden = false;
            };
        }
        node.addEventHandler(TOUCH_PRESSED, unHideEventHandler);
        node.addEventHandler(MOUSE_PRESSED, unHideEventHandler);
    }

    private void unRegisterUnhideHandler(Node node) {
        if (unHideEventHandler != null) {
            node.removeEventHandler(TOUCH_PRESSED, unHideEventHandler);
            node.removeEventHandler(MOUSE_PRESSED, unHideEventHandler);
        }
    }

    private String getNodeVKType(Node node) {
        Integer vkType = (Integer)node.getProperties().get(FXVK.VK_TYPE_PROP_KEY);
        String typeStr = null;
        if (vkType != null) {
            Object typeValue = FXVK.VK_TYPE_NAMES[vkType];
            if (typeValue instanceof String) {
                typeStr = ((String)typeValue).toLowerCase(Locale.ROOT);
            }
        }
        return (typeStr != null ? typeStr : &quot;text&quot;);
    }

    private void updateKeyboardType(Node node) {
        String oldType = vkType;
        vkType = getNodeVKType(node);
        //VK type changed, rebuild
        if ( oldType == null || !vkType.equals(oldType) ) {
            rebuildPrimaryVK(vkType);
        }
    }

    private void closeSecondaryVK() {
        if (secondaryVK != null) {
            secondaryVK.setAttachedNode(null);
            secondaryPopup.hide();
        }
    }

    private void setupPrimaryVK() {
        fxvk.setFocusTraversable(false);
        fxvk.setVisible(true);

        // init popup window and slide animations
        if (vkPopup == null) {
            vkPopup = new Popup();
            vkPopup.setAutoFix(false);
        }
        vkPopup.getContent().setAll(fxvk);

        double screenHeight =
            com.sun.javafx.util.Utils.getScreen(fxvk).getBounds().getHeight();
        double width = com.sun.javafx.util.Utils.getScreen(fxvk).getBounds().getWidth();

        //Setup VK slide animations
        slideInTimeline.getKeyFrames().setAll(
            new KeyFrame(Duration.millis(VK_SLIDE_MILLIS),
                         new KeyValue(winY, screenHeight - VK_HEIGHT,
                                      Interpolator.EASE_BOTH)));
        slideOutTimeline.getKeyFrames().setAll(
            new KeyFrame(Duration.millis(VK_SLIDE_MILLIS),
                    event -&gt; {
                        if (hideAfterSlideOut &amp;&amp; vkPopup.isShowing()) {
                            vkPopup.hide();
                        }
                    },
                new KeyValue(winY, screenHeight, Interpolator.EASE_BOTH)));

        //Set VK size
        fxvk.setPrefWidth(width);
        fxvk.setMinWidth(USE_PREF_SIZE);
        fxvk.setMaxWidth(USE_PREF_SIZE);

        fxvk.setPrefHeight(VK_HEIGHT);
        fxvk.setMinHeight(USE_PREF_SIZE);


        //set up long-press triger for secondary VK
        if (secondaryVKDelay == null) {
            secondaryVKDelay = new Timeline();
        }
        KeyFrame kf = new KeyFrame(Duration.millis(500), event -&gt; {
            if (secondaryVKKey != null) {
                showSecondaryVK(secondaryVKKey);
            }
        });
        secondaryVKDelay.getKeyFrames().setAll(kf);

        //Setup key repeat animations
        if (KEY_REPEAT_RATE &gt; 0) {
            repeatInitialDelay = new Timeline(new KeyFrame(
                    Duration.millis(KEY_REPEAT_DELAY),
                    event -&gt; {
                        //fire current key
                        repeatKey.sendKeyEvents();
                        //Start repeat animation
                        repeatSubsequentDelay.playFromStart();
                    }
            ));
            repeatSubsequentDelay = new Timeline(new KeyFrame(
                    Duration.millis(1000.0 / KEY_REPEAT_RATE),
                    event -&gt; {
                        //fire current key
                        repeatKey.sendKeyEvents();
                    }
            ));
            repeatSubsequentDelay.setCycleCount(Animation.INDEFINITE);
        }
    }

    void prerender(Node node) {
        if (fxvk != primaryVK) {
            return;
        }

        //Preload all boards
        loadBoard(&quot;text&quot;);
        loadBoard(&quot;numeric&quot;);
        loadBoard(&quot;url&quot;);
        loadBoard(&quot;email&quot;);

        updateKeyboardType(node);
        fxvk.setVisible(true);

        if (!vkPopup.isShowing()) {
            Rectangle2D screenBounds =
                com.sun.javafx.util.Utils.getScreen(node).getBounds();

            vkPopup.setX((screenBounds.getWidth() - fxvk.prefWidth(-1)) / 2);
            winY.set(screenBounds.getHeight());
            vkPopup.show(node.getScene().getWindow());
        }
    }

    public FXVKSkin(final FXVK fxvk) {
        super(fxvk);
        this.fxvk = fxvk;
        if (fxvk == FXVK.vk) {
            primaryVK = fxvk;
        }

        if (fxvk == primaryVK) {
            setupPrimaryVK();
        }

        fxvk.attachedNodeProperty().addListener(new InvalidationListener() {
            @Override public void invalidated(Observable valueModel) {
                Node oldNode = attachedNode;
                attachedNode = fxvk.getAttachedNode();
                if (fxvk != primaryVK) {
                    return;
                }

                closeSecondaryVK();

                if (attachedNode != null) {
                    if (oldNode != null) {
                        unRegisterUnhideHandler(oldNode);
                    }
                    registerUnhideHandler(attachedNode);
                    updateKeyboardType(attachedNode);

                    //owner window has changed so hide VK and show with new owner
                    if (oldNode == null || oldNode.getScene() == null || oldNode.getScene().getWindow() != attachedNode.getScene().getWindow()) {
                        if (vkPopup.isShowing()) {
                            vkPopup.hide();
                        } else {
                        }
                    }

                    if (!vkPopup.isShowing()) {
                        Rectangle2D screenBounds =
                            com.sun.javafx.util.Utils.getScreen(attachedNode).getBounds();

                        vkPopup.setX((screenBounds.getWidth() - fxvk.prefWidth(-1)) / 2);
                        if (oldNode == null || isVKHidden) {
                            //position off screen
                            winY.set(screenBounds.getHeight());
                        } else {
                            //position on screen (no slide in)
                            winY.set(screenBounds.getHeight() - VK_HEIGHT);
                        }
                        vkPopup.show(attachedNode.getScene().getWindow());
                    }

                    if (oldNode == null || isVKHidden) {
                        startSlideIn();
                    }

                    if (vkAdjustWindow) {
                        //update previous window position only if moving from non-input control node or window has changed.
                        if (oldNode == null || oldNode.getScene() == null
                            || oldNode.getScene().getWindow() != attachedNode.getScene().getWindow()) {
                            saveWindowPosition(attachedNode);
                        }
                        // Move window containing input node
                        adjustWindowPosition(attachedNode);
                    }
                } else { // attachedNode == null
                    if (oldNode != null) {
                        unRegisterUnhideHandler(oldNode);
                    }
                    startSlideOut(true);
                    // Restore window position
                    if (vkAdjustWindow) {
                        restoreWindowPosition(oldNode);
                    }
                }
                isVKHidden = false;
            }
        });
    }

    /**
     * builds secondary (long-press) VK
     */
    private void rebuildSecondaryVK() {
        if (secondaryVK.chars == null) {
        } else {
            int nKeys = secondaryVK.chars.length;
            int nRows = (int)Math.floor(Math.sqrt(Math.max(1, nKeys - 2)));
            int nKeysPerRow = (int)Math.ceil(nKeys / (double)nRows);

            Key tmpKey;
            List&lt;List&lt;Key&gt;&gt; rows = new ArrayList&lt;List&lt;Key&gt;&gt;(2);

            for (int i = 0; i &lt; nRows; i++) {
                int start = i * nKeysPerRow;
                int end = Math.min(start + nKeysPerRow, nKeys);
                if (start &gt;= end)
                    break;

                List&lt;Key&gt; keys = new ArrayList&lt;Key&gt;(nKeysPerRow);
                for (int j = start; j &lt; end; j++) {
                    tmpKey = new CharKey(secondaryVK.chars[j], null, null);
                    tmpKey.col= (j - start) * 2;
                    tmpKey.colSpan = 2;
                    for (String sc : tmpKey.getStyleClass()) {
                        tmpKey.text.getStyleClass().add(sc + &quot;-text&quot;);
                        tmpKey.altText.getStyleClass().add(sc + &quot;-alttext&quot;);
                        tmpKey.icon.getStyleClass().add(sc + &quot;-icon&quot;);
                    }
                    if (secondaryVK.chars[j] != null &amp;&amp; secondaryVK.chars[j].length() &gt; 1) {
                        tmpKey.text.getStyleClass().add(&quot;multi-char-text&quot;);
                    }
                    keys.add(tmpKey);
                }
                rows.add(keys);
            }
            currentBoard = rows;

            getChildren().clear();
            numCols = 0;
            for (List&lt;Key&gt; row : currentBoard) {
                for (Key key : row) {
                    numCols = Math.max(numCols, key.col + key.colSpan);
                }
                getChildren().addAll(row);
            }
        }
    }

    /**
     * builds primary VK based on the keyboard
     * type set on the VirtualKeyboard.
     */
    private void rebuildPrimaryVK(String type) {
        currentBoard = loadBoard(type);

        //Clear all state keys and updates current board
        clearStateKeys();

        getChildren().clear();
        numCols = 0;
        for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {
                numCols = Math.max(numCols, key.col + key.colSpan);
            }
            getChildren().addAll(row);
        }
    }

    // This skin is designed such that it gives equal widths to all columns. So
    // the pref width is just some hard-coded value (although I could have maybe
    // done it based on the pref width of a text node with the right font).
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return leftInset + (56 * numCols) + rightInset;
    }

    // Pref height is just some value. This isn't overly important.
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return topInset + (80 * 5) + bottomInset;
    }

    // Lays the buttons comprising the current keyboard out.
    @Override
    protected void layoutChildren(double contentX, double contentY, double contentWidth, double contentHeight) {
        // I have fixed width columns, all the same.
        int numRows = currentBoard.size();
        final double colWidth = ((contentWidth - ((numCols - 1) * GAP)) / numCols);
        double rowHeight = ((contentHeight - ((numRows - 1) * GAP)) / numRows);
        double rowY = contentY;
        for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {
                double startX = contentX + (key.col * (colWidth + GAP));
                double width = (key.colSpan * (colWidth + GAP)) - GAP;
                key.resizeRelocate((int)(startX + .5), (int)(rowY + .5),
                                   width, rowHeight);
            }
            rowY += rowHeight + GAP;
        }
    }


    /**
     * A Key on the virtual keyboard. This is simply a Region. Some information
     * about the key relative to other keys on the layout is given by the col
     * and colSpan fields.
     */
    private class Key extends Region {
        int col = 0;
        int colSpan = 1;
        protected final Text text;
        protected final Text altText;
        protected final Region icon;

        protected Key() {
            icon = new Region();
            text = new Text();
            text.setTextOrigin(VPos.TOP);
            altText = new Text();
            altText.setTextOrigin(VPos.TOP);
            getChildren().setAll(text, altText, icon);
            getStyleClass().setAll(&quot;key&quot;);
            addEventHandler(MouseEvent.MOUSE_PRESSED, event -&gt; {
                if (event.getButton() == MouseButton.PRIMARY)
                    press();
            });
            addEventHandler(MouseEvent.MOUSE_RELEASED, event -&gt; {
                if (event.getButton() == MouseButton.PRIMARY)
                    release();
            });
        }
        protected void press() { }
        protected void release() {
            clearShift();
        }

        public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) { }

        @Override protected void layoutChildren() {
            final double left = snappedLeftInset();
            final double top = snappedTopInset();
            final double width = getWidth() - left - snappedRightInset();
            final double height = getHeight() - top - snappedBottomInset();

            text.setVisible(icon.getBackground() == null);
            double contentPrefWidth = text.prefWidth(-1);
            double contentPrefHeight = text.prefHeight(-1);
            text.resizeRelocate(
                    (int) (left + ((width - contentPrefWidth) / 2) + .5),
                    (int) (top + ((height - contentPrefHeight) / 2) + .5),
                    (int) contentPrefWidth,
                    (int) contentPrefHeight);

            altText.setVisible(icon.getBackground() == null &amp;&amp; altText.getText().length() &gt; 0);
            contentPrefWidth = altText.prefWidth(-1);
            contentPrefHeight = altText.prefHeight(-1);
            altText.resizeRelocate(
                    (int) left + (width - contentPrefWidth) + .5,
                    (int) (top + ((height - contentPrefHeight) / 2) + .5 - height/2),
                    (int) contentPrefWidth,
                    (int) contentPrefHeight);

            icon.resizeRelocate(left-8, top-8, width+16, height+16);
        }

    }

    /**
     * Any key on the keyboard which will send a KeyEvent to the client. This
     * class just maintains the state and logic for firing an event, using the
     * &quot;chars&quot; and &quot;code&quot; as the values sent in the event. A subclass must set
     * these appropriately.
     */
    private class TextInputKey extends Key {
        String chars = &quot;&quot;;

        protected void press() {
        }
        protected void release() {
            if (fxvk != secondaryVK &amp;&amp; secondaryPopup != null &amp;&amp; secondaryPopup.isShowing()) {
                return;
            }
            sendKeyEvents();
            if (fxvk == secondaryVK) {
                showSecondaryVK(null);
            }
            super.release();
        }

        protected void sendKeyEvents() {
            Node target = fxvk.getAttachedNode();
            if (target instanceof EventTarget) {
                if (chars != null) {
                    target.fireEvent(new KeyEvent(KeyEvent.KEY_TYPED, chars, &quot;&quot;, KeyCode.UNDEFINED, shiftDown, false, false, false));
                }
            }
        }
    }

    /**
     * A key which has a letter, a number or symbol on it
     *
     */
    private class CharKey extends TextInputKey {
        private final String letterChars;
        private final String altChars;
        private final String[] moreChars;

        private CharKey(String letter, String alt, String[] moreChars, String id) {
            this.letterChars = letter;
            this.altChars = alt;
            this.moreChars = moreChars;
            this.chars = this.letterChars;

            text.setText(this.chars);
            altText.setText(this.altChars);
            if (vkLookup) {
                setId((id != null ? id : chars).replaceAll(&quot;\\.&quot;, &quot;&quot;));
            }
        }

        private CharKey(String letter, String alt, String[] moreChars) {
            this(letter, alt, moreChars, null);
        }

        protected void press() {
            super.press();
            if (letterChars.equals(altChars) &amp;&amp; moreChars == null) {
                return;
            }
            if (fxvk == primaryVK) {
                showSecondaryVK(null);
                secondaryVKKey = CharKey.this;
                secondaryVKDelay.playFromStart();
            }
        }

        protected void release() {
            super.release();
            if (letterChars.equals(altChars) &amp;&amp; moreChars == null) {
                return;
            }
            if (fxvk == primaryVK) {
                secondaryVKDelay.stop();
            }
        }

        @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
            if (isSymbol) {
                chars = altChars;
                text.setText(chars);
                if (moreChars != null &amp;&amp; moreChars.length &gt; 0 &amp;&amp; !Character.isLetter(moreChars[0].charAt(0))) {
                    altText.setText(moreChars[0]);
                } else {
                    altText.setText(null);
                }
            } else {
                chars = (capsDown || shiftDown) ? letterChars.toUpperCase() : letterChars.toLowerCase();
                text.setText(chars);
                altText.setText(altChars);
            }
        }
    }

    /**
     * One of several TextInputKeys which have super powers, such as &quot;Tab&quot; and
     * &quot;Return&quot; and &quot;Backspace&quot;. These keys still send events to the client,
     * but may also have additional state related functionality on the keyboard
     * such as the &quot;Shift&quot; key.
     */
    private class SuperKey extends TextInputKey {
        private SuperKey(String letter, String code) {
            this.chars = code;
            text.setText(letter);
            getStyleClass().add(&quot;special&quot;);
            if (vkLookup) {
                setId(letter);
            }
        }
    }

    /**
     * Some keys actually do need to use KeyCode for pressed / released events,
     * and BackSpace is one of them.
     */
    private class KeyCodeKey extends SuperKey {
        private KeyCode code;

        private KeyCodeKey(String letter, String c, KeyCode code) {
            super(letter, c);
            this.code = code;
            if (vkLookup) {
                setId(letter);
            }
        }

        protected void sendKeyEvents() {
            Node target = fxvk.getAttachedNode();
            if (target instanceof EventTarget) {
                target.fireEvent(new KeyEvent(KeyEvent.KEY_PRESSED, KeyEvent.CHAR_UNDEFINED, chars, code, shiftDown, false, false, false));
                target.fireEvent(new KeyEvent(KeyEvent.KEY_TYPED, chars, &quot;&quot;, KeyCode.UNDEFINED, shiftDown, false, false, false));
                target.fireEvent(new KeyEvent(KeyEvent.KEY_RELEASED, KeyEvent.CHAR_UNDEFINED, chars, code, shiftDown, false, false, false));
            }
        }
    }

    /**
     * These keys only manipulate the state of the keyboard and never
     * send key events to the client. For example, &quot;Hide&quot;, &quot;Caps Lock&quot;,
     * etc are all KeyboardStateKeys.
     */
    private class KeyboardStateKey extends Key {
        private final String defaultText;
        private final String toggledText;

        private KeyboardStateKey(String defaultText, String toggledText, String id) {
            this.defaultText = defaultText;
            this.toggledText = toggledText;
            text.setText(this.defaultText);
            if (vkLookup &amp;&amp; id != null) {
                setId(id);
            }
            getStyleClass().add(&quot;special&quot;);
        }

        @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
            //change icon

            if (isSymbol) {
                text.setText(this.toggledText);
            } else {
                text.setText(this.defaultText);
            }
        }
    }

    private void showSecondaryVK(final CharKey key) {
        if (key != null) {
            final Node textInput = primaryVK.getAttachedNode();

            if (secondaryVK == null) {
                secondaryVK = new FXVK();
                //secondaryVK.getStyleClass().addAll(&quot;fxvk-secondary&quot;, &quot;fxvk-portrait&quot;);
                secondaryVK.setSkin(new FXVKSkin(secondaryVK));
                secondaryVK.getStyleClass().setAll(&quot;fxvk-secondary&quot;);
                secondaryPopup = new Popup();
                secondaryPopup.setAutoHide(true);
                secondaryPopup.getContent().add(secondaryVK);
            }

            secondaryVK.chars=null;
            ArrayList&lt;String&gt; secondaryList = new ArrayList&lt;String&gt;();

            // Add primary character
            if (!isSymbol) {
                if (key.letterChars != null &amp;&amp; key.letterChars.length() &gt; 0) {
                    if (shiftDown || capsDown) {
                        secondaryList.add(key.letterChars.toUpperCase());
                    } else {
                        secondaryList.add(key.letterChars);
                    }
                }
            }

            // Add secondary character
            if (key.altChars != null &amp;&amp; key.altChars.length() &gt; 0) {
                if (shiftDown || capsDown) {
                    secondaryList.add(key.altChars.toUpperCase());
                } else {
                    secondaryList.add(key.altChars);
                }
            }

            // Add more letters
            if (key.moreChars != null &amp;&amp; key.moreChars.length &gt; 0) {
                if (isSymbol) {
                    //Add non-letters
                    for (String ch : key.moreChars) {
                        if (!Character.isLetter(ch.charAt(0))) {
                            secondaryList.add(ch);
                        }
                    }
                 } else {
                    //Add letters
                    for (String ch : key.moreChars) {
                        if (Character.isLetter(ch.charAt(0))) {
                            if (shiftDown || capsDown) {
                                secondaryList.add(ch.toUpperCase());
                            } else {
                                secondaryList.add(ch);
                            }
                        }
                    }
                }
            }

            boolean isMultiChar = false;
            for (String s : secondaryList) {
                if (s.length() &gt; 1 ) {
                    isMultiChar = true;
                }
            }

            secondaryVK.chars = secondaryList.toArray(new String[secondaryList.size()]);

            if (secondaryVK.chars.length &gt; 1) {
                if (secondaryVK.getSkin() != null) {
                    ((FXVKSkin)secondaryVK.getSkin()).rebuildSecondaryVK();
                }

                secondaryVK.setAttachedNode(textInput);
                FXVKSkin primarySkin = (FXVKSkin)primaryVK.getSkin();
                FXVKSkin secondarySkin = (FXVKSkin)secondaryVK.getSkin();
                //Insets insets = secondarySkin.getInsets();
                int nKeys = secondaryVK.chars.length;
                int nRows = (int)Math.floor(Math.sqrt(Math.max(1, nKeys - 2)));
                int nKeysPerRow = (int)Math.ceil(nKeys / (double)nRows);

                final double w = snappedLeftInset() + snappedRightInset() +
                                 nKeysPerRow * PREF_PORTRAIT_KEY_WIDTH * (isMultiChar ? 2 : 1) + (nKeysPerRow - 1) * GAP;
                final double h = snappedTopInset() + snappedBottomInset() +
                                 nRows * PREF_KEY_HEIGHT + (nRows-1) * GAP;

                secondaryVK.setPrefWidth(w);
                secondaryVK.setMinWidth(USE_PREF_SIZE);
                secondaryVK.setPrefHeight(h);
                secondaryVK.setMinHeight(USE_PREF_SIZE);
                Platform.runLater(() -&gt; {
                    // Position popup on screen
                    Point2D nodePoint =
                        com.sun.javafx.util.Utils.pointRelativeTo(key, w, h, HPos.CENTER, VPos.TOP,
                                                             5, -3, true);
                    double x = nodePoint.getX();
                    double y = nodePoint.getY();
                    Scene scene = key.getScene();
                    x = Math.min(x, scene.getWindow().getX() + scene.getWidth() - w);
                    secondaryPopup.show(key.getScene().getWindow(), x, y);
                });
            }
        } else {
            closeSecondaryVK();
        }
    }


    private List&lt;List&lt;Key&gt;&gt; loadBoard(String type) {
        List&lt;List&lt;Key&gt;&gt; tmpBoard = boardMap.get(type);
        if (tmpBoard != null) {
            return tmpBoard;
        }

        String boardFileName = type.substring(0,1).toUpperCase() + type.substring(1).toLowerCase() + &quot;Board.txt&quot;;
        try {
            tmpBoard = new ArrayList&lt;List&lt;Key&gt;&gt;(5);
            List&lt;Key&gt; keys = new ArrayList&lt;Key&gt;(20);

            InputStream boardFile = FXVKSkin.class.getResourceAsStream(boardFileName);
            BufferedReader reader = new BufferedReader(new InputStreamReader(boardFile, &quot;UTF-8&quot;));
            String line;
            // A pointer to the current column. This will be incremented for every string
            // of text, or space.
            int c = 0;
            // The col at which the key will be placed
            int col = 0;
            // The number of columns that the key will span
            int colSpan = 1;
            // Whether the &quot;chars&quot; is an identifier, like $shift or $SymbolBoard, etc.
            boolean identifier = false;
            // The textual content of the Key
            List&lt;String&gt; charsList = new ArrayList&lt;String&gt;(10);

            while ((line = reader.readLine()) != null) {
                if (line.length() == 0 || line.charAt(0) == '#') {
                    continue;
                }
                // A single line represents a single row of buttons
                for (int i=0; i&lt;line.length(); i++) {
                    char ch = line.charAt(i);

                    // Process the char
                    if (ch == ' ') {
                        c++;
                    } else if (ch == '[') {
                        // Start of a key
                        col = c;
                        charsList = new ArrayList&lt;String&gt;(10);
                        identifier = false;
                    } else if (ch == ']') {
                        String chars = &quot;&quot;;
                        String alt = null;
                        String[] moreChars = null;

                        for (int idx = 0; idx &lt; charsList.size(); idx++) {
                            charsList.set(idx, FXVKCharEntities.get(charsList.get(idx)));
                        }

                        int listSize = charsList.size();
                        if (listSize &gt; 0) {
                            chars = charsList.get(0);
                            if (listSize &gt; 1) {
                                alt = charsList.get(1);
                                if (listSize &gt; 2) {
                                    moreChars = charsList.subList(2, listSize).toArray(new String[listSize - 2]);
                                }
                            }
                        }

                        // End of a key
                        colSpan = c - col;
                        Key key;
                        if (identifier) {
                            if (&quot;$shift&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;&quot;, null, &quot;shift&quot;) {
                                    @Override protected void release() {
                                        pressShift();
                                    }

                                    @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
                                        if (isSymbol) {
                                            this.setDisable(true);
                                            this.setVisible(false);
                                        } else {
                                            if (capsDown) {
                                                icon.getStyleClass().remove(&quot;shift-icon&quot;);
                                                icon.getStyleClass().add(&quot;capslock-icon&quot;);
                                            } else {
                                                icon.getStyleClass().remove(&quot;capslock-icon&quot;);
                                                icon.getStyleClass().add(&quot;shift-icon&quot;);
                                            }
                                            this.setDisable(false);
                                            this.setVisible(true);
                                        }
                                    }
                                };
                                key.getStyleClass().add(&quot;shift&quot;);

                            } else if (&quot;$SymbolABC&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;!#123&quot;, &quot;ABC&quot;, &quot;symbol&quot;) {
                                    @Override protected void release() {
                                        pressSymbolABC();
                                    }
                                };
                            } else if (&quot;$backspace&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;backspace&quot;, &quot;\b&quot;, KeyCode.BACK_SPACE) {
                                    @Override protected void press() {
                                        if (KEY_REPEAT_RATE &gt; 0) {
                                            clearShift();
                                            sendKeyEvents();
                                            repeatKey = this;
                                            repeatInitialDelay.playFromStart();
                                        } else {
                                            super.press();
                                        }
                                    }
                                    @Override protected void release() {
                                        if (KEY_REPEAT_RATE &gt; 0) {
                                            repeatInitialDelay.stop();
                                            repeatSubsequentDelay.stop();
                                        } else {
                                            super.release();
                                        }
                                    }
                                };
                                key.getStyleClass().add(&quot;backspace&quot;);
                            } else if (&quot;$enter&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;enter&quot;, &quot;\n&quot;, KeyCode.ENTER);
                                key.getStyleClass().add(&quot;enter&quot;);
                            } else if (&quot;$tab&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;tab&quot;, &quot;\t&quot;, KeyCode.TAB);
                            } else if (&quot;$space&quot;.equals(chars)) {
                                key = new CharKey(&quot; &quot;, &quot; &quot;, null, &quot;space&quot;);
                            } else if (&quot;$clear&quot;.equals(chars)) {
                                key = new SuperKey(&quot;clear&quot;, &quot;&quot;);
                            } else if (&quot;$.org&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.org&quot;, &quot;.org&quot;);
                            } else if (&quot;$.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.com&quot;, &quot;.com&quot;);
                            } else if (&quot;$.net&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.net&quot;, &quot;.net&quot;);
                            } else if (&quot;$oracle.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;oracle.com&quot;, &quot;oracle.com&quot;);
                            } else if (&quot;$gmail.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;gmail.com&quot;, &quot;gmail.com&quot;);
<A NAME="23"></A>                            } else if (&quot;$hide&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;hide&quot;, null, &quot;hide&quot;) {
                                    @Override protected void release() {
                                        <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#23',2,'match37-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>isVKHidden = true;
                                        startSlideOut(false);
                                        // Restore window position
                                        if (vkAdjustWindow) {
                                            restoreWindowPosition(attachedNode);
                                        }
                                    }
                                }</B></FONT>;
                                key.getStyleClass().add(&quot;hide&quot;);
                            } else if (&quot;$undo&quot;.equals(chars)) {
                                key = new SuperKey(&quot;undo&quot;, &quot;&quot;);
                            } else if (&quot;$redo&quot;.equals(chars)) {
                                key = new SuperKey(&quot;redo&quot;, &quot;&quot;);
                            } else {
                                //Unknown Key
                                key = null;
                            }
                        } else {
                            key = new CharKey(chars, alt, moreChars);
                        }
                        if (key != null) {
                            key.col = col;
                            key.colSpan = colSpan;
                            for (String sc : key.getStyleClass()) {
                                key.text.getStyleClass().add(sc + &quot;-text&quot;);
                                key.altText.getStyleClass().add(sc + &quot;-alttext&quot;);
                                key.icon.getStyleClass().add(sc + &quot;-icon&quot;);
                            }
                            if (chars != null &amp;&amp; chars.length() &gt; 1) {
                                key.text.getStyleClass().add(&quot;multi-char-text&quot;);
                            }
                            if (alt != null &amp;&amp; alt.length() &gt; 1) {
                                key.altText.getStyleClass().add(&quot;multi-char-text&quot;);
                            }

                            keys.add(key);
                        }
                    } else {
                        // Normal textual characters. Read all the way up to the
                        // next ] or space
                        for (int j=i; j&lt;line.length(); j++) {
                            char c2 = line.charAt(j);
                            boolean e = false;
                            if (c2 == '\\') {
                                j++;
                                i++;
                                e = true;
                                c2 = line.charAt(j);
                            }

                            if (c2 == '$' &amp;&amp; !e) {
                                identifier = true;
                            }

                            if (c2 == '|' &amp;&amp; !e) {
                                charsList.add(line.substring(i, j));
                                i = j + 1;
                            } else if ((c2 == ']' || c2 == ' ') &amp;&amp; !e) {
                                charsList.add(line.substring(i, j));
                                i = j-1;
                                break;
                            }
                        }
                        c++;
                    }
                }

                c = 0;
                col = 0;
                tmpBoard.add(keys);
                keys = new ArrayList&lt;Key&gt;(20);
            }
            reader.close();
            boardMap.put(type, tmpBoard);
            return tmpBoard;
        } catch (Exception e) {
            e.printStackTrace();
            return Collections.emptyList();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/Axis.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;

import com.sun.javafx.scene.NodeHelper;
import javafx.css.Styleable;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableObjectProperty;

import javafx.css.converter.BooleanConverter;
import javafx.css.converter.EnumConverter;
import javafx.css.converter.PaintConverter;
import javafx.css.converter.SizeConverter;

import java.util.*;

import javafx.animation.FadeTransition;
import javafx.beans.binding.DoubleExpression;
import javafx.beans.binding.ObjectExpression;
import javafx.beans.binding.StringExpression;
import javafx.beans.property.*;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.css.FontCssMetaData;
import javafx.css.StyleableProperty;
import javafx.geometry.Bounds;
import javafx.geometry.Dimension2D;
import javafx.geometry.Orientation;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.scene.control.Label;
import javafx.scene.layout.Region;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.scene.shape.LineTo;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.Path;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.scene.transform.Rotate;
import javafx.scene.transform.Translate;
import javafx.util.Duration;


/**
 * Base class for all axes in JavaFX that represents an axis drawn on a chart area.
 * It holds properties for axis auto ranging, ticks and labels along the axis.
 * &lt;p&gt;
 * Some examples of concrete subclasses include {@link NumberAxis} whose axis plots data
 * in numbers and {@link CategoryAxis} whose values / ticks represent string
 * categories along its axis.
 * @since JavaFX 2.0
 */
public abstract class Axis&lt;T&gt; extends Region {

    // -------------- PRIVATE FIELDS -----------------------------------------------------------------------------------

    Text measure = new Text();
    private Orientation effectiveOrientation;
    private double effectiveTickLabelRotation = Double.NaN;
    private Label axisLabel = new Label();
    private final Path tickMarkPath = new Path();
    private double oldLength = 0;
    /** True when the current range invalid and all dependent calculations need to be updated */
    boolean rangeValid = false;
    boolean measureInvalid = false;
    boolean tickLabelsVisibleInvalid = false;

    private BitSet labelsToSkip = new BitSet();

    // -------------- PUBLIC PROPERTIES --------------------------------------------------------------------------------

    private final ObservableList&lt;TickMark&lt;T&gt;&gt; tickMarks = FXCollections.observableArrayList();
    private final ObservableList&lt;TickMark&lt;T&gt;&gt; unmodifiableTickMarks = FXCollections.unmodifiableObservableList(tickMarks);
    /**
     * Unmodifiable observable list of tickmarks, each TickMark directly representing a tickmark on this axis. This is updated
     * whenever the displayed tickmarks changes.
     *
     * @return Unmodifiable observable list of TickMarks on this axis
     */
    public ObservableList&lt;TickMark&lt;T&gt;&gt; getTickMarks() { return unmodifiableTickMarks; }

    /** The side of the plot which this axis is being drawn on */
    private ObjectProperty&lt;Side&gt; side = new StyleableObjectProperty&lt;Side&gt;(){
        @Override protected void invalidated() {
            // cause refreshTickMarks
            Side edge = get();
            pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, edge == Side.TOP);
            pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, edge == Side.RIGHT);
            pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, edge == Side.BOTTOM);
            pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, edge == Side.LEFT);
            requestAxisLayout();
        }

        @Override
        public CssMetaData&lt;Axis&lt;?&gt;,Side&gt; getCssMetaData() {
            return StyleableProperties.SIDE;
        }

        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;side&quot;;
        }
    };
    public final Side getSide() { return side.get(); }
    public final void setSide(Side value) { side.set(value); }
    public final ObjectProperty&lt;Side&gt; sideProperty() { return side; }

    final void setEffectiveOrientation(Orientation orientation) {
        effectiveOrientation = orientation;
    }

    final Side getEffectiveSide() {
        final Side side = getSide();
        if (side == null || (side.isVertical() &amp;&amp; effectiveOrientation == Orientation.HORIZONTAL)
                || side.isHorizontal() &amp;&amp; effectiveOrientation == Orientation.VERTICAL) {
            // Means side == null &amp;&amp; effectiveOrientation == null produces Side.BOTTOM
            return effectiveOrientation == Orientation.VERTICAL ? Side.LEFT : Side.BOTTOM;
        }
        return side;
    }

    /** The axis label */
    private ObjectProperty&lt;String&gt; label = new ObjectPropertyBase&lt;String&gt;() {
        @Override protected void invalidated() {
            axisLabel.setText(get());
            requestAxisLayout();
        }

        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;label&quot;;
        }
    };
    public final String getLabel() { return label.get(); }
    public final void setLabel(String value) { label.set(value); }
    public final ObjectProperty&lt;String&gt; labelProperty() { return label; }

    /** true if tick marks should be displayed */
    private BooleanProperty tickMarkVisible = new StyleableBooleanProperty(true) {
        @Override protected void invalidated() {
            tickMarkPath.setVisible(get());
            requestAxisLayout();
        }

        @Override
        public CssMetaData&lt;Axis&lt;?&gt;,Boolean&gt; getCssMetaData() {
            return StyleableProperties.TICK_MARK_VISIBLE;
        }
        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;tickMarkVisible&quot;;
        }
    };
    public final boolean isTickMarkVisible() { return tickMarkVisible.get(); }
    public final void setTickMarkVisible(boolean value) { tickMarkVisible.set(value); }
    public final BooleanProperty tickMarkVisibleProperty() { return tickMarkVisible; }

    /** true if tick mark labels should be displayed */
    private BooleanProperty tickLabelsVisible = new StyleableBooleanProperty(true) {
        @Override protected void invalidated() {
            // update textNode visibility for each tick
            for (TickMark&lt;T&gt; tick : tickMarks) {
                tick.setTextVisible(get());
            }
            tickLabelsVisibleInvalid = true;
            requestAxisLayout();
        }

        @Override
        public CssMetaData&lt;Axis&lt;?&gt;,Boolean&gt; getCssMetaData() {
            return StyleableProperties.TICK_LABELS_VISIBLE;
        }

        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;tickLabelsVisible&quot;;
        }
    };
    public final boolean isTickLabelsVisible() { return tickLabelsVisible.get(); }
    public final void setTickLabelsVisible(boolean value) {
        tickLabelsVisible.set(value); }
    public final BooleanProperty tickLabelsVisibleProperty() { return tickLabelsVisible; }

    /** The length of tick mark lines */
    private DoubleProperty tickLength = new StyleableDoubleProperty(8) {
        @Override protected void invalidated() {
            if (tickLength.get() &lt; 0 &amp;&amp; !tickLength.isBound()) {
                tickLength.set(0);
            }
            // this effects preferred size so request layout
            requestAxisLayout();
        }

        @Override
        public CssMetaData&lt;Axis&lt;?&gt;,Number&gt; getCssMetaData() {
            return StyleableProperties.TICK_LENGTH;
        }
        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;tickLength&quot;;
        }
    };
    public final double getTickLength() { return tickLength.get(); }
    public final void setTickLength(double value) { tickLength.set(value); }
    public final DoubleProperty tickLengthProperty() { return tickLength; }

    /** This is true when the axis determines its range from the data automatically */
    private BooleanProperty autoRanging = new BooleanPropertyBase(true) {
        @Override protected void invalidated() {
            if(get()) {
                // auto range turned on, so need to auto range now
//                autoRangeValid = false;
                requestAxisLayout();
            }
        }

        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;autoRanging&quot;;
        }
    };
    public final boolean isAutoRanging() { return autoRanging.get(); }
    public final void setAutoRanging(boolean value) { autoRanging.set(value); }
    public final BooleanProperty autoRangingProperty() { return autoRanging; }

    /** The font for all tick labels */
    private ObjectProperty&lt;Font&gt; tickLabelFont = new StyleableObjectProperty&lt;Font&gt;(Font.font(&quot;System&quot;,8)) {
        @Override protected void invalidated() {
            Font f = get();
            measure.setFont(f);
            for(TickMark&lt;T&gt; tm : getTickMarks()) {
                tm.textNode.setFont(f);
            }
            measureInvalid = true;
            requestAxisLayout();
        }

        @Override
        public CssMetaData&lt;Axis&lt;?&gt;,Font&gt; getCssMetaData() {
            return StyleableProperties.TICK_LABEL_FONT;
        }

        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;tickLabelFont&quot;;
        }
    };
    public final Font getTickLabelFont() { return tickLabelFont.get(); }
    public final void setTickLabelFont(Font value) { tickLabelFont.set(value); }
    public final ObjectProperty&lt;Font&gt; tickLabelFontProperty() { return tickLabelFont; }

    /** The fill for all tick labels */
    private ObjectProperty&lt;Paint&gt; tickLabelFill = new StyleableObjectProperty&lt;Paint&gt;(Color.BLACK) {
        @Override protected void invalidated() {
            for (TickMark&lt;T&gt; tick : tickMarks) {
                tick.textNode.setFill(getTickLabelFill());
            }
        }

        @Override
        public CssMetaData&lt;Axis&lt;?&gt;,Paint&gt; getCssMetaData() {
            return StyleableProperties.TICK_LABEL_FILL;
        }

        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;tickLabelFill&quot;;
        }
    };
    public final Paint getTickLabelFill() { return tickLabelFill.get(); }
    public final void setTickLabelFill(Paint value) { tickLabelFill.set(value); }
    public final ObjectProperty&lt;Paint&gt; tickLabelFillProperty() { return tickLabelFill; }

    /** The gap between tick labels and the tick mark lines */
    private DoubleProperty tickLabelGap = new StyleableDoubleProperty(3) {
        @Override protected void invalidated() {
           requestAxisLayout();
        }

        @Override
        public CssMetaData&lt;Axis&lt;?&gt;,Number&gt; getCssMetaData() {
            return StyleableProperties.TICK_LABEL_TICK_GAP;
        }

        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;tickLabelGap&quot;;
        }
    };
    public final double getTickLabelGap() { return tickLabelGap.get(); }
    public final void setTickLabelGap(double value) { tickLabelGap.set(value); }
    public final DoubleProperty tickLabelGapProperty() { return tickLabelGap; }

    /**
     * When true any changes to the axis and its range will be animated.
     */
    private BooleanProperty animated = new SimpleBooleanProperty(this, &quot;animated&quot;, true);

    /**
     * Indicates whether the changes to axis range will be animated or not.
     *
     * @return true if axis range changes will be animated and false otherwise
     */
    public final boolean getAnimated() { return animated.get(); }
    public final void setAnimated(boolean value) { animated.set(value); }
    public final BooleanProperty animatedProperty() { return animated; }

    /**
     * Rotation in degrees of tick mark labels from their normal horizontal.
     */
    private DoubleProperty tickLabelRotation = new DoublePropertyBase(0) {
        @Override protected void invalidated() {
            if (isAutoRanging()) {
                invalidateRange(); // NumberAxis and CategoryAxis use this property in autorange
            }
            requestAxisLayout();
        }

        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;tickLabelRotation&quot;;
        }
<A NAME="49"></A>    };
    public final double getTickLabelRotation() { return tickLabelRotation.getValue(); }
    public final void setTickLabelRotation(double value) { tickLabelRotation.setValue(value); }
    public final DoubleProperty tickLabelRotationProperty() { return tickLabelRotation; <FONT color="#8e35ef"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#49',2,'match37-top.html#49',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    // -------------- CONSTRUCTOR --------------------------------------------------------------------------------------

    /**
     * Creates and initializes a new instance of the Axis class.
     */
    public Axis() {
        getStyleClass().setAll(&quot;axis&quot;);
        axisLabel.getStyleClass().add(&quot;axis-label&quot;);
        axisLabel.setAlignment(Pos.CENTER);
        tickMarkPath.getStyleClass().add(&quot;axis-tick-mark&quot;);
        getChildren().addAll(axisLabel, tickMarkPath);
    }

    // -------------- METHODS ------------------------------------------------------------------------------------------

    /**
     * See if the current range is valid, if it is not then any range dependent calulcations need to redone on the next layout pass
     *
     * @return true if current range calculations are valid
     */
    protected final boolean isRangeValid() {</B></FONT> return rangeValid; }

    /**
     * Mark the current range invalid, this will cause anything that depends on the range to be recalculated on the
     * next layout.
     */
    protected final void invalidateRange() { rangeValid = false; }

    /**
     * This is used to check if any given animation should run. It returns true if animation is enabled and the node
     * is visible and in a scene.
     *
     * @return true if animations should happen
     */
    protected final boolean shouldAnimate(){
        return getAnimated() &amp;&amp; NodeHelper.isTreeShowing(this);
    }

    /**
     * We suppress requestLayout() calls here by doing nothing as we don't want changes to our children to cause
     * layout. If you really need to request layout then call requestAxisLayout().
     */
    @Override public void requestLayout() {}

    /**
     * Request that the axis is laid out in the next layout pass. This replaces requestLayout() as it has been
     * overridden to do nothing so that changes to children's bounds etc do not cause a layout. This was done as a
     * optimization as the Axis knows the exact minimal set of changes that really need layout to be updated. So we
     * only want to request layout then, not on any child change.
     */
    public void requestAxisLayout() {
        super.requestLayout();
    }

    /**
     * Called when data has changed and the range may not be valid any more. This is only called by the chart if
     * isAutoRanging() returns true. If we are auto ranging it will cause layout to be requested and auto ranging to
     * happen on next layout pass.
     *
     * @param data The current set of all data that needs to be plotted on this axis
     */
    public void invalidateRange(List&lt;T&gt; data) {
        invalidateRange();
        requestAxisLayout();
    }

    /**
     * This calculates the upper and lower bound based on the data provided to invalidateRange() method. This must not
     * effect the state of the axis, changing any properties of the axis. Any results of the auto-ranging should be
     * returned in the range object. This will we passed to setRange() if it has been decided to adopt this range for
     * this axis.
     *
     * @param length The length of the axis in screen coordinates
     * @return Range information, this is implementation dependent
     */
    protected abstract Object autoRange(double length);

    /**
     * Called to set the current axis range to the given range. If isAnimating() is true then this method should
     * animate the range to the new range.
     *
     * @param range A range object returned from autoRange()
     * @param animate If true animate the change in range
     */
    protected abstract void setRange(Object range, boolean animate);

    /**
     * Called to get the current axis range.
     *
     * @return A range object that can be passed to setRange() and calculateTickValues()
     */
    protected abstract Object getRange();

    /**
     * Get the display position of the zero line along this axis.
     *
     * @return display position or Double.NaN if zero is not in current range;
     */
    public abstract double getZeroPosition();

    /**
     * Get the display position along this axis for a given value.
     * If the value is not in the current range, the returned value will be an extrapolation of the display
     * position.
     *
     * If the value is not valid for this Axis and the axis cannot display such value in any range,
     * Double.NaN is returned
     *
     * @param value The data value to work out display position for
     * @return display position or Double.NaN if value not valid
     */
    public abstract double getDisplayPosition(T value);

    /**
     * Get the data value for the given display position on this axis. If the axis
     * is a CategoryAxis this will be the nearest value.
     *
     * @param  displayPosition A pixel position on this axis
     * @return the nearest data value to the given pixel position or
     *         null if not on axis;
     */
    public abstract T getValueForDisplay(double displayPosition);

    /**
     * Checks if the given value is plottable on this axis
     *
     * @param value The value to check if its on axis
     * @return true if the given value is plottable on this axis
     */
    public abstract boolean isValueOnAxis(T value);

    /**
     * All axis values must be representable by some numeric value. This gets the numeric value for a given data value.
     *
     * @param value The data value to convert
     * @return Numeric value for the given data value
     */
    public abstract double toNumericValue(T value);

    /**
     * All axis values must be representable by some numeric value. This gets the data value for a given numeric value.
     *
     * @param value The numeric value to convert
     * @return Data value for given numeric value
     */
    public abstract T toRealValue(double value);

    /**
     * Calculate a list of all the data values for each tick mark in range
     *
     * @param length The length of the axis in display units
     * @param range A range object returned from autoRange()
     * @return A list of tick marks that fit along the axis if it was the given length
     */
    protected abstract List&lt;T&gt; calculateTickValues(double length, Object range);

    /**
     * Computes the preferred height of this axis for the given width. If axis orientation
     * is horizontal, it takes into account the tick mark length, tick label gap and
     * label height.
     *
     * @return the computed preferred width for this axis
     */
    @Override protected double computePrefHeight(double width) {
        final Side side = getEffectiveSide();
        if (side.isVertical()) {
            // TODO for now we have no hard and fast answer here, I guess it should work
            // TODO out the minimum size needed to display min, max and zero tick mark labels.
            return 100;
        } else { // HORIZONTAL
            // we need to first auto range as this may/will effect tick marks
            Object range = autoRange(width);
            // calculate max tick label height
            double maxLabelHeight = 0;
            // calculate the new tick marks
            if (isTickLabelsVisible()) {
                final List&lt;T&gt; newTickValues = calculateTickValues(width, range);
                for (T value: newTickValues) {
                    maxLabelHeight = Math.max(maxLabelHeight,measureTickMarkSize(value, range).getHeight());
                }
            }
            // calculate tick mark length
            final double tickMarkLength = isTickMarkVisible() ? (getTickLength() &gt; 0) ? getTickLength() : 0 : 0;
            // calculate label height
            final double labelHeight =
                    axisLabel.getText() == null || axisLabel.getText().length() == 0 ?
                    0 : axisLabel.prefHeight(-1);
            return maxLabelHeight + getTickLabelGap() + tickMarkLength + labelHeight;
        }
    }

    /**
     * Computes the preferred width of this axis for the given height. If axis orientation
     * is vertical, it takes into account the tick mark length, tick label gap and
     * label height.
     *
     * @return the computed preferred width for this axis
     */
    @Override protected double computePrefWidth(double height) {
        final Side side = getEffectiveSide();
        if (side.isVertical()) {
            // we need to first auto range as this may/will effect tick marks
            Object range = autoRange(height);
            // calculate max tick label width
            double maxLabelWidth = 0;
            // calculate the new tick marks
            if (isTickLabelsVisible()) {
                final List&lt;T&gt; newTickValues = calculateTickValues(height,range);
                for (T value: newTickValues) {
                    maxLabelWidth = Math.max(maxLabelWidth, measureTickMarkSize(value, range).getWidth());
                }
            }
            // calculate tick mark length
            final double tickMarkLength = isTickMarkVisible() ? (getTickLength() &gt; 0) ? getTickLength() : 0 : 0;
            // calculate label height
            final double labelHeight =
                    axisLabel.getText() == null || axisLabel.getText().length() == 0 ?
                    0 : axisLabel.prefHeight(-1);
            return maxLabelWidth + getTickLabelGap() + tickMarkLength + labelHeight;
        } else  { // HORIZONTAL
            // TODO for now we have no hard and fast answer here, I guess it should work
            // TODO out the minimum size needed to display min, max and zero tick mark labels.
            return 100;
        }
    }

    /**
     * Called during layout if the tickmarks have been updated, allowing subclasses to do anything they need to
     * in reaction.
     */
    protected void tickMarksUpdated(){}

    /**
     * Invoked during the layout pass to layout this axis and all its content.
     */
    @Override protected void layoutChildren() {
        final boolean isFirstPass = oldLength == 0;
        // auto range if it is not valid
        final Side side = getEffectiveSide();
        final double length = side.isVertical() ? getHeight() : getWidth();
        boolean rangeInvalid = !isRangeValid();
        boolean lengthDiffers = oldLength != length;
        if (lengthDiffers || rangeInvalid) {
            // get range
            Object range;
            if(isAutoRanging()) {
                // auto range
                range = autoRange(length);
                // set current range to new range
                setRange(range, getAnimated() &amp;&amp; !isFirstPass &amp;&amp; NodeHelper.isTreeShowing(this) &amp;&amp; rangeInvalid);
            } else {
                range = getRange();
            }
            // calculate new tick marks
            List&lt;T&gt; newTickValues = calculateTickValues(length, range);

            // remove everything
            Iterator&lt;TickMark&lt;T&gt;&gt; tickMarkIterator = tickMarks.iterator();
            while (tickMarkIterator.hasNext()) {
                TickMark&lt;T&gt; tick = tickMarkIterator.next();
                final TickMark&lt;T&gt; tm = tick;
                if (shouldAnimate()) {
                    FadeTransition ft = new FadeTransition(Duration.millis(250),tick.textNode);
                    ft.setToValue(0);
                    ft.setOnFinished(actionEvent -&gt; {
                        getChildren().remove(tm.textNode);
                    });
                    ft.play();
                } else {
                    getChildren().remove(tm.textNode);
                }
                // we have to remove the tick mark immediately so we don't draw tick line for it or grid lines and fills
                tickMarkIterator.remove();
            }

            // add new tick marks for new values
            for(T newValue: newTickValues) {
                final TickMark&lt;T&gt; tick = new TickMark&lt;T&gt;();
                tick.setValue(newValue);
                tick.textNode.setText(getTickMarkLabel(newValue));
                tick.textNode.setFont(getTickLabelFont());
                tick.textNode.setFill(getTickLabelFill());
                tick.setTextVisible(isTickLabelsVisible());
                if (shouldAnimate()) tick.textNode.setOpacity(0);
                getChildren().add(tick.textNode);
                tickMarks.add(tick);
                if (shouldAnimate()) {
                    FadeTransition ft = new FadeTransition(Duration.millis(750),tick.textNode);
                    ft.setFromValue(0);
                    ft.setToValue(1);
                    ft.play();
                }
            }

            // call tick marks updated to inform subclasses that we have updated tick marks
            tickMarksUpdated();
            // mark all done
            oldLength = length;
            rangeValid = true;
        }

        if (lengthDiffers || rangeInvalid || measureInvalid || tickLabelsVisibleInvalid) {
            measureInvalid = false;
            tickLabelsVisibleInvalid = false;
            // RT-12272 : tick labels overlapping
            // first check if all visible labels fit, if not, retain every nth label
            labelsToSkip.clear();
            int numLabelsToSkip = 0;
            double totalLabelsSize = 0;
            double maxLabelSize = 0;
            for (TickMark&lt;T&gt; m : tickMarks) {
                m.setPosition(getDisplayPosition(m.getValue()));
                if (m.isTextVisible()) {
                    double tickSize = measureTickMarkSize(m.getValue(), side);
                    totalLabelsSize += tickSize;
                    maxLabelSize = Math.round(Math.max(maxLabelSize, tickSize));
                }
            }
            if (maxLabelSize &gt; 0 &amp;&amp; length &lt; totalLabelsSize) {
                numLabelsToSkip = ((int)(tickMarks.size() * maxLabelSize / length)) + 1;
            }

            if (numLabelsToSkip &gt; 0) {
                int tickIndex = 0;
                for (TickMark&lt;T&gt; m : tickMarks) {
                    if (m.isTextVisible()) {
                        m.setTextVisible((tickIndex++ % numLabelsToSkip) == 0);
                    }
                }
            }

            // now check if labels for bounds overlap nearby labels, this can happen due to JDK-8097501
            // use tickLabelGap to prevent sticking
            if (tickMarks.size() &gt; 2) {
                TickMark&lt;T&gt; m1 = tickMarks.get(0);
                TickMark&lt;T&gt; m2 = tickMarks.get(1);
                if (isTickLabelsOverlap(side, m1, m2, getTickLabelGap())) {
                    m2.setTextVisible(false);
                }
                m1 = tickMarks.get(tickMarks.size()-2);
                m2 = tickMarks.get(tickMarks.size()-1);
                if (isTickLabelsOverlap(side, m1, m2, getTickLabelGap())) {
                    m1.setTextVisible(false);
                }
            }
            updateTickMarks(side, length);
        }
    }

    private void updateTickMarks(Side side, double length) {
        // clear tick mark path elements as we will recreate
        tickMarkPath.getElements().clear();
        // do layout of axis label, tick mark lines and text
        final double width = getWidth();
        final double height = getHeight();
        final double tickMarkLength = (isTickMarkVisible() &amp;&amp; getTickLength() &gt; 0) ? getTickLength() : 0;
        final double effectiveLabelRotation = getEffectiveTickLabelRotation();
        if (Side.LEFT.equals(side)) {
            // offset path to make strokes snap to pixel
            tickMarkPath.setLayoutX(-0.5);
            tickMarkPath.setLayoutY(0.5);
            if (getLabel() != null) {
                axisLabel.getTransforms().setAll(new Translate(0, height), new Rotate(-90, 0, 0));
                axisLabel.setLayoutX(0);
                axisLabel.setLayoutY(0);
                //noinspection SuspiciousNameCombination
                axisLabel.resize(height, Math.ceil(axisLabel.prefHeight(width)));
            }
            for (TickMark&lt;T&gt; tick : tickMarks) {
                positionTextNode(tick.textNode, width - getTickLabelGap() - tickMarkLength,
                        tick.getPosition(), effectiveLabelRotation, side);
                updateTickMark(tick, length,
                        width - tickMarkLength, tick.getPosition(),
                        width, tick.getPosition());
            }
        } else if (Side.RIGHT.equals(side)) {
            // offset path to make strokes snap to pixel
            tickMarkPath.setLayoutX(0.5);
            tickMarkPath.setLayoutY(0.5);
            if (getLabel() != null) {
                final double axisLabelWidth = Math.ceil(axisLabel.prefHeight(width));
                axisLabel.getTransforms().setAll(new Translate(0, height), new Rotate(-90, 0, 0));
                axisLabel.setLayoutX(width-axisLabelWidth);
                axisLabel.setLayoutY(0);
                //noinspection SuspiciousNameCombination
                axisLabel.resize(height, axisLabelWidth);
            }
            for (TickMark&lt;T&gt; tick : tickMarks) {
                positionTextNode(tick.textNode, getTickLabelGap() + tickMarkLength,
                        tick.getPosition(), effectiveLabelRotation, side);
                updateTickMark(tick, length,
                        0, tick.getPosition(),
                        tickMarkLength, tick.getPosition());
            }
        } else if (Side.TOP.equals(side)) {
            // offset path to make strokes snap to pixel
            tickMarkPath.setLayoutX(0.5);
            tickMarkPath.setLayoutY(-0.5);
            if (getLabel() != null) {
                axisLabel.getTransforms().clear();
                axisLabel.setLayoutX(0);
                axisLabel.setLayoutY(0);
                axisLabel.resize(width, Math.ceil(axisLabel.prefHeight(width)));
            }
            for (TickMark&lt;T&gt; tick : tickMarks) {
                positionTextNode(tick.textNode, tick.getPosition(), height - tickMarkLength - getTickLabelGap(),
                        effectiveLabelRotation, side);
                updateTickMark(tick, length,
                        tick.getPosition(), height,
                        tick.getPosition(), height - tickMarkLength);
            }
        } else {
            // BOTTOM
            // offset path to make strokes snap to pixel
            tickMarkPath.setLayoutX(0.5);
            tickMarkPath.setLayoutY(0.5);
            if (getLabel() != null) {
                axisLabel.getTransforms().clear();
                final double labelHeight = Math.ceil(axisLabel.prefHeight(width));
                axisLabel.setLayoutX(0);
                axisLabel.setLayoutY(height - labelHeight);
                axisLabel.resize(width, labelHeight);
            }
            for (TickMark&lt;T&gt; tick : tickMarks) {
                positionTextNode(tick.textNode, tick.getPosition(), tickMarkLength + getTickLabelGap(),
                        effectiveLabelRotation, side);
                updateTickMark(tick, length,
                        tick.getPosition(), 0,
                        tick.getPosition(), tickMarkLength);
            }
        }
    }

    /**
     * Checks if two consecutive tick mark labels overlaps.
     * @param side side of the Axis
     * @param m1 first tick mark
     * @param m2 second tick mark
     * @param gap minimum space between labels
     * @return true if labels overlap
     */
    private boolean isTickLabelsOverlap(Side side, TickMark&lt;T&gt; m1, TickMark&lt;T&gt; m2, double gap) {
        if (!m1.isTextVisible() || !m2.isTextVisible()) return false;
        double m1Size = measureTickMarkSize(m1.getValue(), side);
        double m2Size = measureTickMarkSize(m2.getValue(), side);
        double m1Start = m1.getPosition() - m1Size / 2;
        double m1End = m1.getPosition() + m1Size / 2;
        double m2Start = m2.getPosition() - m2Size / 2;
        double m2End = m2.getPosition() + m2Size / 2;
        return side.isVertical() ? (m1Start - m2End) &lt;= gap : (m2Start - m1End) &lt;= gap;
    }

    /**
     * Positions a text node to one side of the given point, it X height is vertically centered on point if LEFT or
     * RIGHT and its centered horizontally if TOP ot BOTTOM.
     *
     * @param node The text node to position
     * @param posX The x position, to place text next to
     * @param posY The y position, to place text next to
     * @param angle The text rotation
     * @param side The side to place text next to position x,y at
     */
    private void positionTextNode(Text node, double posX, double posY, double angle, Side side) {
        node.setLayoutX(0);
        node.setLayoutY(0);
        node.setRotate(angle);
        final Bounds bounds = node.getBoundsInParent();
        if (Side.LEFT.equals(side)) {
            node.setLayoutX(posX-bounds.getWidth()-bounds.getMinX());
            node.setLayoutY(posY - (bounds.getHeight() / 2d) - bounds.getMinY());
        } else if (Side.RIGHT.equals(side)) {
            node.setLayoutX(posX-bounds.getMinX());
            node.setLayoutY(posY-(bounds.getHeight()/2d)-bounds.getMinY());
        } else if (Side.TOP.equals(side)) {
            node.setLayoutX(posX-(bounds.getWidth()/2d)-bounds.getMinX());
            node.setLayoutY(posY-bounds.getHeight()-bounds.getMinY());
        } else {
            node.setLayoutX(posX-(bounds.getWidth()/2d)-bounds.getMinX());
            node.setLayoutY(posY-bounds.getMinY());
        }
    }

    /**
     * Updates visibility of the text node and adds the tick mark to the path
     */
    private void updateTickMark(TickMark&lt;T&gt; tick, double length,
            double startX, double startY, double endX, double endY)
    {
        // check if position is inside bounds
        if (tick.getPosition() &gt;= 0 &amp;&amp; tick.getPosition() &lt;= Math.ceil(length)) {
            tick.textNode.setVisible(tick.isTextVisible());
            // add tick mark line
            tickMarkPath.getElements().addAll(
                    new MoveTo(startX, startY),
                    new LineTo(endX, endY)
            );
        } else {
            tick.textNode.setVisible(false);
        }
    }
    /**
     * Get the string label name for a tick mark with the given value
     *
     * @param value The value to format into a tick label string
     * @return A formatted string for the given value
     */
    protected abstract String getTickMarkLabel(T value);

    /**
     * Measure the size of the label for given tick mark value. This uses the font that is set for the tick marks
     *
     *
     * @param labelText     tick mark label text
     * @param rotation  The text rotation
     * @return size of tick mark label for given value
     */
    protected final Dimension2D measureTickMarkLabelSize(String labelText, double rotation) {
        measure.setRotate(rotation);
        measure.setText(labelText);
        Bounds bounds = measure.getBoundsInParent();
        return new Dimension2D(bounds.getWidth(), bounds.getHeight());
    }

    /**
     * Measure the size of the label for given tick mark value. This uses the font that is set for the tick marks
     *
     * @param value     tick mark value
     * @param rotation  The text rotation
     * @return size of tick mark label for given value
     */
    protected final Dimension2D measureTickMarkSize(T value, double rotation) {
        return measureTickMarkLabelSize(getTickMarkLabel(value), rotation);
    }

    /**
     * Measure the size of the label for given tick mark value. This uses the font that is set for the tick marks
     *
     * @param value tick mark value
     * @param range range to use during calculations
     * @return size of tick mark label for given value
     */
    protected Dimension2D measureTickMarkSize(T value, Object range) {
        return measureTickMarkSize(value, getEffectiveTickLabelRotation());
    }

    /**
     * Measure the size of the label for given tick mark value. This uses the font that is set for the tick marks
     *
     * @param value tick mark value
     * @param side side of this Axis
     * @return size of tick mark label for given value
     * @see #measureTickMarkSize(Object, Object)
     */
    private double measureTickMarkSize(T value, Side side) {
        Dimension2D size = measureTickMarkSize(value, getEffectiveTickLabelRotation());
        return side.isVertical() ? size.getHeight() : size.getWidth();
    }

    final double getEffectiveTickLabelRotation() {
        return !isAutoRanging() || Double.isNaN(effectiveTickLabelRotation) ? getTickLabelRotation() : effectiveTickLabelRotation;
    }

    /**
     *
     * @param rotation NaN for using the tickLabelRotationProperty()
     */
    final void setEffectiveTickLabelRotation(double rotation) {
        effectiveTickLabelRotation = rotation;
    }

    // -------------- TICKMARK INNER CLASS -----------------------------------------------------------------------------

    /**
     * TickMark represents the label text, its associated properties for each tick
     * along the Axis.
     * @since JavaFX 2.0
     */
    public static final class TickMark&lt;T&gt; {
        /**
         * The display text for tick mark
         */
        private StringProperty label = new StringPropertyBase() {
            @Override protected void invalidated() {
                textNode.setText(getValue());
            }

            @Override
            public Object getBean() {
                return TickMark.this;
            }

            @Override
            public String getName() {
                return &quot;label&quot;;
            }
        };
        public final String getLabel() { return label.get(); }
        public final void setLabel(String value) { label.set(value); }
        public final StringExpression labelProperty() { return label; }

        /**
         * The value for this tick mark in data units
         */
        private ObjectProperty&lt;T&gt; value = new SimpleObjectProperty&lt;T&gt;(this, &quot;value&quot;);
        public final T getValue() { return value.get(); }
        public final void setValue(T v) { value.set(v); }
        public final ObjectExpression&lt;T&gt; valueProperty() { return value; }

        /**
         * The display position along the axis from axis origin in display units
         */
        private DoubleProperty position = new SimpleDoubleProperty(this, &quot;position&quot;);
        public final double getPosition() { return position.get(); }
        public final void setPosition(double value) { position.set(value); }
        public final DoubleExpression positionProperty() { return position; }

        Text textNode = new Text();

        /** true if tick mark labels should be displayed */
        private BooleanProperty textVisible = new BooleanPropertyBase(true) {
            @Override protected void invalidated() {
                if(!get()) {
                    textNode.setVisible(false);
                }
            }

            @Override
            public Object getBean() {
                return TickMark.this;
            }

            @Override
            public String getName() {
                return &quot;textVisible&quot;;
            }
        };

        /**
         * Indicates whether this tick mark label text is displayed or not.
         * @return true if tick mark label text is visible and false otherwise
         */
        public final boolean isTextVisible() { return textVisible.get(); }

        /**
         * Specifies whether this tick mark label text is displayed or not.
         * @param value true if tick mark label text is visible and false otherwise
         */
        public final void setTextVisible(boolean value) { textVisible.set(value); }

        /**
         * Creates and initializes an instance of TickMark.
         */
        public TickMark() {
        }

        /**
         * Returns a string representation of this {@code TickMark} object.
         * @return a string representation of this {@code TickMark} object.
         */
        @Override public String toString() {
            return value.get().toString();
        }
    }

    // -------------- STYLESHEET HANDLING ------------------------------------------------------------------------------

    private static class StyleableProperties {
        private static final CssMetaData&lt;Axis&lt;?&gt;,Side&gt; SIDE =
            new CssMetaData&lt;Axis&lt;?&gt;,Side&gt;(&quot;-fx-side&quot;,
                new EnumConverter&lt;Side&gt;(Side.class)) {

            @Override
            public boolean isSettable(Axis&lt;?&gt; n) {
                return n.side == null || !n.side.isBound();
            }

            @SuppressWarnings(&quot;unchecked&quot;) // sideProperty() is StyleableProperty&lt;Side&gt;
            @Override
            public StyleableProperty&lt;Side&gt; getStyleableProperty(Axis&lt;?&gt; n) {
                return (StyleableProperty&lt;Side&gt;)n.sideProperty();
            }
        };

        private static final CssMetaData&lt;Axis&lt;?&gt;,Number&gt; TICK_LENGTH =
            new CssMetaData&lt;Axis&lt;?&gt;,Number&gt;(&quot;-fx-tick-length&quot;,
                SizeConverter.getInstance(), 8.0) {

            @Override
            public boolean isSettable(Axis&lt;?&gt; n) {
                return n.tickLength == null || !n.tickLength.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(Axis&lt;?&gt; n) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.tickLengthProperty();
            }
        };

        private static final CssMetaData&lt;Axis&lt;?&gt;,Font&gt; TICK_LABEL_FONT =
            new FontCssMetaData&lt;Axis&lt;?&gt;&gt;(&quot;-fx-tick-label-font&quot;,
                Font.font(&quot;system&quot;, 8.0)) {

            @Override
            public boolean isSettable(Axis&lt;?&gt; n) {
                return n.tickLabelFont == null || !n.tickLabelFont.isBound();
            }

            @SuppressWarnings(&quot;unchecked&quot;) // tickLabelFontProperty() is StyleableProperty&lt;Font&gt;
            @Override
            public StyleableProperty&lt;Font&gt; getStyleableProperty(Axis&lt;?&gt; n) {
                return (StyleableProperty&lt;Font&gt;)n.tickLabelFontProperty();
            }
        };

        private static final CssMetaData&lt;Axis&lt;?&gt;,Paint&gt; TICK_LABEL_FILL =
            new CssMetaData&lt;Axis&lt;?&gt;,Paint&gt;(&quot;-fx-tick-label-fill&quot;,
                PaintConverter.getInstance(), Color.BLACK) {

            @Override
            public boolean isSettable(Axis&lt;?&gt; n) {
                return n.tickLabelFill == null | !n.tickLabelFill.isBound();
            }

            @SuppressWarnings(&quot;unchecked&quot;) // tickLabelFillProperty() is StyleableProperty&lt;Paint&gt;
            @Override
            public StyleableProperty&lt;Paint&gt; getStyleableProperty(Axis&lt;?&gt; n) {
                return (StyleableProperty&lt;Paint&gt;)n.tickLabelFillProperty();
            }
        };

        private static final CssMetaData&lt;Axis&lt;?&gt;,Number&gt; TICK_LABEL_TICK_GAP =
            new CssMetaData&lt;Axis&lt;?&gt;,Number&gt;(&quot;-fx-tick-label-gap&quot;,
                SizeConverter.getInstance(), 3.0) {

            @Override
            public boolean isSettable(Axis&lt;?&gt; n) {
                return n.tickLabelGap == null || !n.tickLabelGap.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(Axis&lt;?&gt; n) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.tickLabelGapProperty();
            }
        };

        private static final CssMetaData&lt;Axis&lt;?&gt;,Boolean&gt; TICK_MARK_VISIBLE =
            new CssMetaData&lt;Axis&lt;?&gt;,Boolean&gt;(&quot;-fx-tick-mark-visible&quot;,
                BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(Axis&lt;?&gt; n) {
                return n.tickMarkVisible == null || !n.tickMarkVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Axis&lt;?&gt; n) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)n.tickMarkVisibleProperty();
            }
        };

        private static final CssMetaData&lt;Axis&lt;?&gt;,Boolean&gt; TICK_LABELS_VISIBLE =
            new CssMetaData&lt;Axis&lt;?&gt;,Boolean&gt;(&quot;-fx-tick-labels-visible&quot;,
                BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(Axis&lt;?&gt; n) {
                return n.tickLabelsVisible == null || !n.tickLabelsVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Axis&lt;?&gt; n) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)n.tickLabelsVisibleProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
        final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
            new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());
            styleables.add(SIDE);
            styleables.add(TICK_LENGTH);
            styleables.add(TICK_LABEL_FONT);
            styleables.add(TICK_LABEL_FILL);
            styleables.add(TICK_LABEL_TICK_GAP);
            styleables.add(TICK_MARK_VISIBLE);
            styleables.add(TICK_LABELS_VISIBLE);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    /** pseudo-class indicating this is a vertical Top side Axis. */
    private static final PseudoClass TOP_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;top&quot;);
    /** pseudo-class indicating this is a vertical Bottom side Axis. */
    private static final PseudoClass BOTTOM_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;bottom&quot;);
    /** pseudo-class indicating this is a vertical Left side Axis. */
    private static final PseudoClass LEFT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;left&quot;);
    /** pseudo-class indicating this is a vertical Right side Axis. */
    private static final PseudoClass RIGHT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;right&quot;);

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/ChoiceDialog.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javafx.scene.control;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;

import com.sun.javafx.scene.control.skin.resources.ControlResources;
import javafx.application.Platform;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.collections.ObservableList;
import javafx.geometry.Pos;
import javafx.scene.control.ButtonBar.ButtonData;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;

/**
 * A dialog that shows a list of choices to the user, from which they can pick
 * one item at most.
 *
 * @see Dialog
 * @param &lt;T&gt; The type of the items to show to the user, and the type that is returned
 *            via {@link #getResult()} when the dialog is dismissed.
 * @since JavaFX 8u40
 */
public class ChoiceDialog&lt;T&gt; extends Dialog&lt;T&gt; {

    /**************************************************************************
     *
     * Fields
     *
     **************************************************************************/

    private final GridPane grid;
    private final Label label;
    private final ComboBox&lt;T&gt; comboBox;
    private final T defaultChoice;



    /**************************************************************************
     *
     * Constructors
     *
     **************************************************************************/

    /**
     * Creates a default, empty instance of ChoiceDialog with no set items and a
     * null default choice. Users of this constructor will subsequently need to
     * call {@link #getItems()} to specify which items to show to the user.
     */
    public ChoiceDialog() {
        this((T)null, (T[])null);
    }

    /**
     * Creates a new ChoiceDialog instance with the first argument specifying the
     * default choice that should be shown to the user, and all following arguments
     * considered a varargs array of all available choices for the user. It is
     * expected that the defaultChoice be one of the elements in the choices varargs
     * array. If this is not true, then defaultChoice will be set to null and the
     * dialog will show with the initial choice set to the first item in the list
     * of choices.
     *
     * @param defaultChoice The item to display as the pre-selected choice in the dialog.
     *        This item must be contained within the choices varargs array.
     * @param choices All possible choices to present to the user.
     */
    public ChoiceDialog(T defaultChoice,  @SuppressWarnings(&quot;unchecked&quot;) T... choices) {
        this(defaultChoice,
             choices == null ? Collections.emptyList() : Arrays.asList(choices));
    }

    /**
     * Creates a new ChoiceDialog instance with the first argument specifying the
     * default choice that should be shown to the user, and the second argument
     * specifying a collection of all available choices for the user. It is
     * expected that the defaultChoice be one of the elements in the choices
     * collection. If this is not true, then defaultChoice will be set to null and the
     * dialog will show with the initial choice set to the first item in the list
     * of choices.
     *
     * @param defaultChoice The item to display as the pre-selected choice in the dialog.
     *        This item must be contained within the choices varargs array.
     * @param choices All possible choices to present to the user.
     */
    public ChoiceDialog(T defaultChoice, Collection&lt;T&gt; choices) {
        final DialogPane dialogPane = getDialogPane();

        // -- grid
        this.grid = new GridPane();
        this.grid.setHgap(10);
        this.grid.setMaxWidth(Double.MAX_VALUE);
        this.grid.setAlignment(Pos.CENTER_LEFT);

        // -- label
        label = DialogPane.createContentLabel(dialogPane.getContentText());
        label.setPrefWidth(Region.USE_COMPUTED_SIZE);
        label.textProperty().bind(dialogPane.contentTextProperty());

        dialogPane.contentTextProperty().addListener(o -&gt; updateGrid());

        setTitle(ControlResources.getString(&quot;Dialog.confirm.title&quot;));
        dialogPane.setHeaderText(ControlResources.getString(&quot;Dialog.confirm.header&quot;));
        dialogPane.getStyleClass().add(&quot;choice-dialog&quot;);
        dialogPane.getButtonTypes().addAll(ButtonType.OK, ButtonType.CANCEL);

        final double MIN_WIDTH = 150;

        comboBox = new ComboBox&lt;T&gt;();
        comboBox.setMinWidth(MIN_WIDTH);
        if (choices != null) {
            comboBox.getItems().addAll(choices);
        }
        comboBox.setMaxWidth(Double.MAX_VALUE);
        GridPane.setHgrow(comboBox, Priority.ALWAYS);
        GridPane.setFillWidth(comboBox, true);

        this.defaultChoice = comboBox.getItems().contains(defaultChoice) ? defaultChoice : null;

        if (defaultChoice == null) {
            comboBox.getSelectionModel().selectFirst();
        } else {
            comboBox.getSelectionModel().select(defaultChoice);
        }

        updateGrid();

        setResultConverter((dialogButton) -&gt; {
            ButtonData data = dialogButton == null ? null : dialogButton.getButtonData();
            return data == ButtonData.OK_DONE ? getSelectedItem() : null;
        });
    }



    /**************************************************************************
     *
     * Public API
     *
     **************************************************************************/

    /**
     * Returns the currently selected item in the dialog.
     * @return the currently selected item
     */
    public final T getSelectedItem() {
        return comboBox.getSelectionModel().getSelectedItem();
    }

    /**
     * Returns the property representing the currently selected item in the dialog.
     * @return the currently selected item property
     */
    public final ReadOnlyObjectProperty&lt;T&gt; selectedItemProperty() {
        return comboBox.getSelectionModel().selectedItemProperty();
    }

    /**
     * Sets the currently selected item in the dialog.
     * @param item The item to select in the dialog.
     */
    public final void setSelectedItem(T item) {
        comboBox.getSelectionModel().select(item);
    }

    /**
     * Returns the list of all items that will be displayed to users. This list
     * can be modified by the developer to add, remove, or reorder the items
     * to present to the user.
<A NAME="18"></A>     * @return the list of all items that will be displayed to users
     */
    public final ObservableList&lt;T&gt; getItems() {
        return <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#18',2,'match37-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>comboBox.getItems();
    }

    /**
     * Returns the default choice that was specified in the constructor.
     * @return the default choice
     */
    public final T getDefaultChoice() {
        return defaultChoice;
    }



    /**************************************************************************
     *
     * Private Implementation
     *
     **************************************************************************/

    private void updateGrid() {
        grid.getChildren().clear();

        grid.add(label, 0, 0);
        grid.add(comboBox, 1, 0);
        getDialogPane().setContent(grid);

        Platform.runLater(() -&gt; comboBox.requestFocus());
    }</B></FONT>
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/Control.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import java.lang.ref.WeakReference;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.sun.javafx.scene.control.ControlAcceleratorSupport;
import javafx.application.Application;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.ObservableList;
import javafx.css.CssParser;
import javafx.event.EventHandler;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Node;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.layout.Region;
import com.sun.javafx.application.PlatformImpl;
import javafx.css.CssMetaData;
import com.sun.javafx.css.StyleManager;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.control.ControlHelper;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableStringProperty;
import javafx.css.converter.StringConverter;
import com.sun.javafx.scene.control.Logging;
import javafx.css.Styleable;
import javafx.css.StyleableProperty;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;


/**
 * Base class for all user interface controls. A &quot;Control&quot; is a node in the
 * scene graph which can be manipulated by the user. Controls provide
 * additional variables and behaviors beyond those of Node to support
 * common user interactions in a manner which is consistent and predictable
 * for the user.
 * &lt;p&gt;
 * Additionally, controls support explicit skinning to make it easy to
 * leverage the functionality of a control while customizing its appearance.
 * &lt;p&gt;
 * See specific Control subclasses for information on how to use individual
 * types of controls.
 * &lt;p&gt; Most controls have their focusTraversable property set to true by default, however
 * read-only controls such as {@link Label} and {@link ProgressIndicator}, and some
 * controls that are containers {@link ScrollPane} and {@link ToolBar} do not.
 * Consult individual control documentation for details.
 * @since JavaFX 2.0
 */
public abstract class Control extends Region implements Skinnable {

    static {
        ControlHelper.setControlAccessor(new ControlHelper.ControlAccessor() {
            @Override
            public void doProcessCSS(Node node) {
                ((Control) node).doProcessCSS();
            }
            @Override
            public StringProperty skinClassNameProperty(Control control) {
                return control.skinClassNameProperty();
            }
        });

        // Ensures that the default application user agent stylesheet is loaded
        if (Application.getUserAgentStylesheet() == null) {
            PlatformImpl.setDefaultPlatformUserAgentStylesheet();
        }
    }

    /**
     * Utility for loading a class in a manner that will work with multiple
     * class loaders, as is typically found in OSGI modular applications.
     * In particular, this method will attempt to just load the class
     * identified by className. If that fails, it attempts to load the
     * class using the current thread's context class loader. If that fails,
     * it attempts to use the class loader of the supplied &quot;instance&quot;, and
     * if it still fails it walks up the class hierarchy of the instance
     * and attempts to use the class loader of each class in the super-type
     * hierarchy.
     *
     * @param className The name of the class we want to load
     * @param instance An optional instance used to help find the class to load
     * @return The class. Cannot return null
     * @throws ClassNotFoundException If the class cannot be found using any technique.
     */
    private static Class&lt;?&gt; loadClass(final String className, final Object instance)
            throws ClassNotFoundException
    {
        try {
            // Try just loading the class
            return Class.forName(className, false, Control.class.getClassLoader());
        } catch (ClassNotFoundException ex) {
            // RT-17525 : Use context class loader only if Class.forName fails.
            if (Thread.currentThread().getContextClassLoader() != null) {
                try {
                    final ClassLoader ccl = Thread.currentThread().getContextClassLoader();
                    return Class.forName(className, false, ccl);
                } catch (ClassNotFoundException ex2) {
                    // Do nothing, just fall through
                }
            }

            // RT-14177: Try looking up the class using the class loader of the
            //           current class, walking up the list of superclasses
            //           and checking each of them, before bailing and using
            //           the context class loader.
            if (instance != null) {
                Class&lt;?&gt; currentType = instance.getClass();
                while (currentType != null) {
                    try {
                        final ClassLoader loader = currentType.getClassLoader();
                        return Class.forName(className, false, loader);
                    } catch (ClassNotFoundException ex2) {
                        currentType = currentType.getSuperclass();
                    }
                }
            }

            // We failed to find the class using any of the above means, so we're going
            // to just throw the ClassNotFoundException that we caught earlier
            throw ex;
        }
    }

    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleableProperties;

    /**
     * A private reference directly to the SkinBase instance that is used as the
     * Skin for this Control. A Control's Skin doesn't have to be of type
     * SkinBase, although 98% of the time or greater it probably will be.
     * Because instanceof checks and reading a value from a property are
     * not cheap (on interpreters on slower hardware or mobile devices)
     * it pays to have a direct reference here to the skinBase. We simply
     * need to check this variable -- if it is not null then we know the
     * Skin is a SkinBase and this is a direct reference to it. If it is null
     * then we know the skin is not a SkinBase and we need to call getSkin().
     */
    private SkinBase&lt;?&gt; skinBase;

    /***************************************************************************
    *                                                                         *
    * Event Handlers / Listeners                                              *
    *                                                                         *
    **************************************************************************/

    /**
     * Handles context menu requests by popping up the menu.
     * Note that we use this pattern to remove some of the anonymous inner
     * classes which we'd otherwise have to create. When lambda expressions
     * are supported, we could do it that way instead (or use MethodHandles).
     */
    private final static EventHandler&lt;ContextMenuEvent&gt; contextMenuHandler = event -&gt; {
        if (event.isConsumed()) return;

        // If a context menu was shown, consume the event to prevent multiple context menus
        Object source = event.getSource();
        if (source instanceof Control) {
            Control c = (Control) source;
            if (c.getContextMenu() != null) {
                c.getContextMenu().show(c, event.getScreenX(), event.getScreenY());
                event.consume();
            }
        }
    };



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/



    // --- skin
    /**
     * Skin is responsible for rendering this {@code Control}. From the
     * perspective of the {@code Control}, the {@code Skin} is a black box.
     * It listens and responds to changes in state in a {@code Control}.
     * &lt;p&gt;
     * There is a one-to-one relationship between a {@code Control} and its
     * {@code Skin}. Every {@code Skin} maintains a back reference to the
     * {@code Control} via the {@link Skin#getSkinnable()} method.
     * &lt;p&gt;
     * A skin may be null.
     * @return the skin property for this control
     */
    @Override public final ObjectProperty&lt;Skin&lt;?&gt;&gt; skinProperty() { return skin; }
    @Override public final void setSkin(Skin&lt;?&gt; value) {
        skinProperty().set(value);
    }
    @Override public final Skin&lt;?&gt; getSkin() { return skinProperty().getValue(); }
    private ObjectProperty&lt;Skin&lt;?&gt;&gt; skin = new StyleableObjectProperty&lt;Skin&lt;?&gt;&gt;() {
        // We store a reference to the oldValue so that we can handle
        // changes in the skin properly in the case of binding. This is
        // only needed because invalidated() does not currently take
        // a reference to the old value.
        private Skin&lt;?&gt; oldValue;

        @Override
        //This code is basically a kind of optimization that prevents a Skin that is equal but not instance equal.
        //Although it's not kosher from the property perspective (bindings won't pass through set), it should not do any harm.
        //But it should be evaluated in the future.
        public void set(Skin&lt;?&gt; v) {
            if (v == null
                ? oldValue == null
                : oldValue != null &amp;&amp; v.getClass().equals(oldValue.getClass()))
                return;

            super.set(v);
        }

        @Override protected void invalidated() {
            Skin&lt;?&gt; skin = get();
            // Collect the name of the currently installed skin class. We do this
            // so that subsequent updates from CSS to the same skin class will not
            // result in reinstalling the skin
            currentSkinClassName = skin == null ? null : skin.getClass().getName();

            // if someone calls setSkin, we need to make it look like they
            // called set on skinClassName in order to keep CSS from overwriting
            // the skin.
            skinClassNameProperty().set(currentSkinClassName);


            // Dispose of the old skin
            if (oldValue != null) oldValue.dispose();

            // Get the new value, and save it off as the new oldValue
            oldValue = skin;

            // Reset skinBase to null - it will be set to the new Skin if it
            // is a SkinBase, otherwise it will remain null, as expected
            skinBase = null;

            // We have two paths, one for &quot;legacy&quot; Skins, and one for
            // any Skin which extends from SkinBase. Legacy Skins will
            // produce a single node which will be the only child of
            // the Control via the getNode() method on the Skin. A
            // SkinBase will manipulate the children of the Control
            // directly. Further, we maintain a direct reference to
            // the skinBase for more optimal updates later.
            if (skin instanceof SkinBase) {
                // record a reference of the skin, if it is a SkinBase, for
                // performance reasons
                skinBase = (SkinBase&lt;?&gt;) skin;
                // Note I do not remove any children here, because the
                // skin will have already configured all the children
                // by the time setSkin has been called. This is because
                // our Skin interface was lacking an initialize method (doh!)
                // and so the Skin constructor is where it adds listeners
                // and so forth. For SkinBase implementations, the
                // constructor is also where it will take ownership of
                // the children.
            } else {
                final Node n = getSkinNode();
                if (n != null) {
                    getChildren().setAll(n);
                } else {
                    getChildren().clear();
                }
            }

            // clear out the styleable properties so that the list is rebuilt
            // next time they are requested.
            styleableProperties = null;

            // calling NodeHelper.reapplyCSS() as the styleable properties may now
            // be different, as we will now be able to return styleable properties
            // belonging to the skin. If NodeHelper.reapplyCSS() is not called, the
            // getCssMetaData() method is never called, so the
            // skin properties are never exposed.
            NodeHelper.reapplyCSS(Control.this);

            // DEBUG: Log that we've changed the skin
            final PlatformLogger logger = Logging.getControlsLogger();
            if (logger.isLoggable(Level.FINEST)) {
                logger.finest(&quot;Stored skin[&quot; + getValue() + &quot;] on &quot; + this);
            }
        }

        // This method should be CssMetaData&lt;Control,Skin&gt; getCssMetaData(),
        // but SKIN is CssMetaData&lt;Control,String&gt;. This does not matter to
        // the CSS code which doesn't care about the actual type. Hence,
        // we'll suppress the warnings
        @Override @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtype&quot;})
        public CssMetaData getCssMetaData() {
            return StyleableProperties.SKIN;
        }

        @Override
        public Object getBean() {
            return Control.this;
        }

        @Override
        public String getName() {
            return &quot;skin&quot;;
        }
    };


    // --- tooltip
    /**
     * The ToolTip for this control.
     * @return the tool tip for this control
     */
    public final ObjectProperty&lt;Tooltip&gt; tooltipProperty() {
        if (tooltip == null) {
            tooltip = new ObjectPropertyBase&lt;Tooltip&gt;() {
                private Tooltip old = null;
                @Override protected void invalidated() {
                    Tooltip t = get();
                    // install / uninstall
                    if (t != old) {
                        if (old != null) {
                            Tooltip.uninstall(Control.this, old);
                        }
                        if (t != null) {
                            Tooltip.install(Control.this, t);
                        }
                        old = t;
                    }
                }

                @Override
                public Object getBean() {
                    return Control.this;
                }

                @Override
                public String getName() {
                    return &quot;tooltip&quot;;
                }
            };
        }
        return tooltip;
    }
    private ObjectProperty&lt;Tooltip&gt; tooltip;
    public final void setTooltip(Tooltip value) { tooltipProperty().setValue(value); }
    public final Tooltip getTooltip() { return tooltip == null ? null : tooltip.getValue(); }


    // --- context menu
    /**
     * The ContextMenu to show for this control.
     */
    private ObjectProperty&lt;ContextMenu&gt; contextMenu = new SimpleObjectProperty&lt;ContextMenu&gt;(this, &quot;contextMenu&quot;) {
        private WeakReference&lt;ContextMenu&gt; contextMenuRef;

        @Override protected void invalidated() {
            ContextMenu oldMenu = contextMenuRef == null ? null : contextMenuRef.get();
            if (oldMenu != null) {
                ControlAcceleratorSupport.removeAcceleratorsFromScene(oldMenu.getItems(), Control.this);
            }

            ContextMenu ctx = get();
            contextMenuRef = new WeakReference&lt;&gt;(ctx);

            if (ctx != null) {
                // set this flag so contextmenu show will be relative to parent window not anchor
                ctx.setShowRelativeToWindow(true); //RT-15160

                // if a context menu is set, we need to install any accelerators
                // belonging to its menu items ASAP into the scene that this
                // Control is in (if the control is not in a Scene, we will need
                // to wait until it is and then do it).
                ControlAcceleratorSupport.addAcceleratorsIntoScene(ctx.getItems(), Control.this);
            }
        }
    };
    public final ObjectProperty&lt;ContextMenu&gt; contextMenuProperty() { return contextMenu; }
    public final void setContextMenu(ContextMenu value) { contextMenu.setValue(value); }
    public final ContextMenu getContextMenu() { return contextMenu == null ? null : contextMenu.getValue(); }



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    {
        // To initialize the class helper at the begining each constructor of this class
        ControlHelper.initHelper(this);
    }
    /**
     *  Create a new Control.
     */
    protected Control() {
        // focusTraversable is styleable through css. Calling setFocusTraversable
        // makes it look to css like the user set the value and css will not
        // override. Initializing focusTraversable by calling applyStyle
        // with null for StyleOrigin ensures that css will be able to override
        // the value.
        final StyleableProperty&lt;Boolean&gt; prop = (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)focusTraversableProperty();
        prop.applyStyle(null, Boolean.TRUE);

        // we add a listener for menu request events to show the context menu
        // that may be set on the Control
        this.addEventHandler(ContextMenuEvent.CONTEXT_MENU_REQUESTED, contextMenuHandler);

        // TODO re-enable when InputMap moves back to Node / Control
//        // Most controls need an input map, so we set this to be non-null in
//        // Control to save people from running into NPEs.
//        setInputMap(new InputMap(this));
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    // Proposed dispose() API.
    // Note that there is impl code for a dispose method in TableRowSkinBase
    // and TableCell (just search for dispose())
//    public void dispose() {
//        Skin skin = getSkin();
//        if (skin != null) {
//            skin.dispose();
//        }
//    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; since all Controls are resizable.
     * @return whether this node can be resized by its parent during layout
     */
    @Override public boolean isResizable() {
        return true;
    }

    // Implementation of the Resizable interface.
    // Because only the skin can know the min, pref, and max sizes, these
    // functions are implemented to delegate to skin. If there is no skin then
    // we simply return 0 for all the values since a Control without a Skin
    // doesn't render
    /**
     * Computes the minimum allowable width of the Control, based on the provided
     * height. The minimum width is not calculated within the Control, instead
     * the calculation is delegated to the {@link Node#minWidth(double)} method
     * of the {@link Skin}. If the Skin is null, the returned value is 0.
     *
     * @param height The height of the Control, in case this value might dictate
     *      the minimum width.
     * @return A double representing the minimum width of this control.
     */
    @Override protected double computeMinWidth(final double height) {
        if (skinBase != null) {
            return skinBase.computeMinWidth(height, snappedTopInset(), snappedRightInset(), snappedBottomInset(), snappedLeftInset());
        } else {
            final Node skinNode = getSkinNode();
            return skinNode == null ? 0 : skinNode.minWidth(height);
        }
    }

    /**
     * Computes the minimum allowable height of the Control, based on the provided
     * width. The minimum height is not calculated within the Control, instead
     * the calculation is delegated to the {@link Node#minHeight(double)} method
     * of the {@link Skin}. If the Skin is null, the returned value is 0.
     *
     * @param width The width of the Control, in case this value might dictate
     *      the minimum height.
     * @return A double representing the minimum height of this control.
     */
    @Override protected double computeMinHeight(final double width) {
        if (skinBase != null) {
            return skinBase.computeMinHeight(width, snappedTopInset(), snappedRightInset(), snappedBottomInset(), snappedLeftInset());
        } else {
            final Node skinNode = getSkinNode();
            return skinNode == null ? 0 : skinNode.minHeight(width);
        }
    }

    /**
     * Computes the maximum allowable width of the Control, based on the provided
     * height. The maximum width is not calculated within the Control, instead
     * the calculation is delegated to the {@link Node#maxWidth(double)} method
     * of the {@link Skin}. If the Skin is null, the returned value is 0.
     *
     * @param height The height of the Control, in case this value might dictate
     *      the maximum width.
     * @return A double representing the maximum width of this control.
     */
    @Override protected double computeMaxWidth(double height) {
        if (skinBase != null) {
            return skinBase.computeMaxWidth(height, snappedTopInset(), snappedRightInset(), snappedBottomInset(), snappedLeftInset());
        } else {
            final Node skinNode = getSkinNode();
            return skinNode == null ? 0 : skinNode.maxWidth(height);
        }
    }

    /**
     * Computes the maximum allowable height of the Control, based on the provided
     * width. The maximum height is not calculated within the Control, instead
     * the calculation is delegated to the {@link Node#maxHeight(double)} method
     * of the {@link Skin}. If the Skin is null, the returned value is 0.
     *
     * @param width The width of the Control, in case this value might dictate
     *      the maximum height.
     * @return A double representing the maximum height of this control.
     */
    @Override protected double computeMaxHeight(double width) {
        if (skinBase != null) {
            return skinBase.computeMaxHeight(width, snappedTopInset(), snappedRightInset(), snappedBottomInset(), snappedLeftInset());
        } else {
            final Node skinNode = getSkinNode();
            return skinNode == null ? 0 : skinNode.maxHeight(width);
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height) {
        if (skinBase != null) {
            return skinBase.computePrefWidth(height, snappedTopInset(), snappedRightInset(), snappedBottomInset(), snappedLeftInset());
        } else {
            final Node skinNode = getSkinNode();
            return skinNode == null ? 0 : skinNode.prefWidth(height);
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width) {
        if (skinBase != null) {
            return skinBase.computePrefHeight(width, snappedTopInset(), snappedRightInset(), snappedBottomInset(), snappedLeftInset());
        } else {
            final Node skinNode = getSkinNode();
            return skinNode == null ? 0 : skinNode.prefHeight(width);
        }
    }

    /** {@inheritDoc} */
    @Override public double getBaselineOffset() {
        if (skinBase != null) {
            return skinBase.computeBaselineOffset(snappedTopInset(), snappedRightInset(), snappedBottomInset(), snappedLeftInset());
        } else {
            final Node skinNode = getSkinNode();
            return skinNode == null ? 0 : skinNode.getBaselineOffset();
        }
    }

    /***************************************************************************
     * Implementation of layout bounds for the Control. We want to preserve    *
     * the lazy semantics of layout bounds. So whenever the width/height       *
     * changes on the node, we end up invalidating layout bounds. We then      *
     * recompute it on demand.                                                 *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected void layoutChildren() {
        if (skinBase != null) {
            final double x = snappedLeftInset();
            final double y = snappedTopInset();
<A NAME="36"></A>            final double w = snapSizeX(getWidth()) - x - snappedRightInset();
            final double h = snapSizeY(getHeight()) - y - snappedBottomInset();
            skinBase.layoutChildren(x, y, w, h);
        } else <FONT color="#ff00ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#36',2,'match37-top.html#36',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
            Node n = getSkinNode();
            if (n != null) {
                n.resizeRelocate(0, 0, getWidth(), getHeight());
            }
        }
    }

    /***************************************************************************
     * Forward the following to the skin                                       *
     **************************************************************************/

    /**
     * Create a new instance of the default skin for this control. This is called to create a skin for the control if
     * no skin is provided via CSS {@code -fx-skin} or set explicitly in a sub-class with {@code  setSkin(...)}.
     *
     * @return  new instance of default skin for this control. If null then the control will have no skin unless one
     *          is provided by css.
     * @since JavaFX 8.0
     */
    protected Skin&lt;?&gt; createDefaultSkin() {</B></FONT>
        return null;
    }

    /***************************************************************************
     *                                                                         *
     * Package API for SkinBase                                                *
     *                                                                         *
     **************************************************************************/

    // package private for SkinBase
    ObservableList&lt;Node&gt; getControlChildren() {
        return getChildren();
    }


    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    /**
     * Gets the Skin's node, or returns null if there is no Skin.
     * Convenience method for getting the node of the skin. This is null-safe,
     * meaning if skin is null then it will return null instead of throwing
     * a NullPointerException.
     *
     * @return The Skin's node, or null.
     */
    private Node getSkinNode() {
        assert skinBase == null;
        Skin&lt;?&gt; skin = getSkin();
        return skin == null ? null : skin.getNode();
    }

    /**
     * Keeps a reference to the name of the class currently acting as the skin.
     */
    private String currentSkinClassName = null;
    private StringProperty skinClassName;

    StringProperty skinClassNameProperty() {
        if (skinClassName == null) {
            skinClassName = new StyleableStringProperty() {

                @Override
                public void set(String v) {
                    // do not allow the skin to be set to null through CSS
                    if (v == null || v.isEmpty() || v.equals(get())) return;
                    super.set(v);
                }

                @Override
                public void invalidated() {

                    if (get() != null) {
                        if (!get().equals(currentSkinClassName)) {
                            loadSkinClass(Control.this, skinClassName.get());
                        }
                        // Note: CSS should not set skin to null
                    }
                }

                @Override
                public Object getBean() {
                    return Control.this;
                }

                @Override
                public String getName() {
                    return &quot;skinClassName&quot;;
                }

                @Override
                public CssMetaData&lt;Control,String&gt; getCssMetaData() {
                    return StyleableProperties.SKIN;
                }

            };
        }
        return skinClassName;
    }

    static void loadSkinClass(final Skinnable control, final String skinClassName) {
        if (skinClassName == null || skinClassName.isEmpty()) {
            final String msg =
                &quot;Empty -fx-skin property specified for control &quot; + control;
            final List&lt;CssParser.ParseError&gt; errors = StyleManager.getErrors();
            if (errors != null) {
                CssParser.ParseError error = new CssParser.ParseError(msg);
                errors.add(error); // RT-19884
            }
            Logging.getControlsLogger().severe(msg);
            return;
        }

        try {
            final Class&lt;?&gt; skinClass = Control.loadClass(skinClassName, control);
            if (!Skin.class.isAssignableFrom(skinClass)) {
                final String msg =
                    &quot;'&quot; + skinClassName + &quot;' is not a valid Skin class for control &quot; + control;
                final List&lt;CssParser.ParseError&gt; errors = StyleManager.getErrors();
                if (errors != null) {
                    CssParser.ParseError error = new CssParser.ParseError(msg);
                    errors.add(error); // RT-19884
                }
                Logging.getControlsLogger().severe(msg);
                return;
            }
            Constructor&lt;?&gt;[] constructors = skinClass.getConstructors();
            Constructor&lt;?&gt; skinConstructor = null;
            for (Constructor&lt;?&gt; c : constructors) {
                Class&lt;?&gt;[] parameterTypes = c.getParameterTypes();
                if (parameterTypes.length == 1 &amp;&amp; Skinnable.class.isAssignableFrom(parameterTypes[0])) {
                    skinConstructor = c;
                    break;
                }
            }

            if (skinConstructor == null) {
                final String msg =
                    &quot;No valid constructor defined in '&quot; + skinClassName + &quot;' for control &quot; + control +
                        &quot;.\r\nYou must provide a constructor that accepts a single &quot;
                        + &quot;Skinnable (e.g. Control or PopupControl) parameter in &quot; + skinClassName + &quot;.&quot;;
                final List&lt;CssParser.ParseError&gt; errors = StyleManager.getErrors();
                if (errors != null) {
                    CssParser.ParseError error = new CssParser.ParseError(msg);
                    errors.add(error); // RT-19884
                }
                Logging.getControlsLogger().severe(msg);
            } else {
                Skin&lt;?&gt; skinInstance = (Skin&lt;?&gt;) skinConstructor.newInstance(control);
                // Do not call setSkin here since it has the side effect of
                // also setting the skinClassName!
                control.skinProperty().set(skinInstance);
            }
        } catch (InvocationTargetException e) {
            final String msg =
                &quot;Failed to load skin '&quot; + skinClassName + &quot;' for control &quot; + control;
            final List&lt;CssParser.ParseError&gt; errors = StyleManager.getErrors();
            if (errors != null) {
                CssParser.ParseError error = new CssParser.ParseError(msg + &quot; :&quot; + e.getLocalizedMessage());
                errors.add(error); // RT-19884
            }
            Logging.getControlsLogger().severe(msg, e.getCause());
        } catch (Exception e) {
            final String msg =
                &quot;Failed to load skin '&quot; + skinClassName + &quot;' for control &quot; + control;
            final List&lt;CssParser.ParseError&gt; errors = StyleManager.getErrors();
            if (errors != null) {
                CssParser.ParseError error = new CssParser.ParseError(msg + &quot; :&quot; + e.getLocalizedMessage());
                errors.add(error); // RT-19884
            }
            Logging.getControlsLogger().severe(msg, e);
        }
    }

    /***************************************************************************
     *                                                                         *
     * StyleSheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static class StyleableProperties {
        private static final CssMetaData&lt;Control,String&gt; SKIN =
            new CssMetaData&lt;Control,String&gt;(&quot;-fx-skin&quot;,
                StringConverter.getInstance()) {

            @Override
            public boolean isSettable(Control n) {
                return (n.skin == null || !n.skin.isBound());
            }

            @Override
            public StyleableProperty&lt;String&gt; getStyleableProperty(Control n) {
                return (StyleableProperty&lt;String&gt;)(WritableValue&lt;String&gt;)n.skinClassNameProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());
            styleables.add(SKIN);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * This method returns a {@link List} containing all {@link CssMetaData} for
     * both this Control (returned from {@link #getControlCssMetaData()} and its
     * {@link Skin}, assuming the {@link #skinProperty() skin property} is a
     * {@link SkinBase}.
     *
     * &lt;p&gt;Developers who wish to provide custom CssMetaData are therefore
     * encouraged to override {@link Control#getControlCssMetaData()} or
     * {@link SkinBase#getCssMetaData()}, depending on where the CssMetaData
     * resides.
     * @since JavaFX 8.0
     */
    @Override
    public final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        if (styleableProperties == null) {

            // RT-29162: make sure properties only show up once in the list
            java.util.Map&lt;String, CssMetaData&lt;? extends Styleable, ?&gt;&gt; map =
                new java.util.HashMap&lt;String, CssMetaData&lt;? extends Styleable, ?&gt;&gt;();

            List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; list =  getControlCssMetaData();

            for (int n=0, nMax = list != null ? list.size() : 0; n&lt;nMax; n++) {

                CssMetaData&lt;? extends Styleable, ?&gt; metaData = list.get(n);
                if (metaData == null) continue;

                map.put(metaData.getProperty(), metaData);
            }

            //
            // if both control and skin base have the same property, use the
            // one from skin base since it may be a specialization of the
            // property in the control. For instance, Label has -fx-font and
            // so does LabeledText which is Label's skin.
            //
            list =  skinBase != null ? skinBase.getCssMetaData() : null;

            for (int n=0, nMax = list != null ? list.size() : 0; n&lt;nMax; n++) {

                CssMetaData&lt;? extends Styleable, ?&gt; metaData = list.get(n);
                if (metaData == null) continue;

                map.put(metaData.getProperty(), metaData);
            }

            styleableProperties = new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;();
            styleableProperties.addAll(map.values());
        }
        return styleableProperties;
    }

    /**
     * @return unmodifiable list of the controls css styleable properties
     * @since JavaFX 8.0
     */
    protected List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
        return getClassCssMetaData();
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean skinCreationLocked = false;
    private void doProcessCSS() {

        ControlHelper.superProcessCSS(this);

        if (getSkin() == null) {
            if (skinCreationLocked) {
                return;
            }

            try {
                skinCreationLocked = true;

                // try to create default skin
                final Skin&lt;?&gt; defaultSkin = createDefaultSkin();
                if (defaultSkin != null) {
                    skinProperty().set(defaultSkin);
                    ControlHelper.superProcessCSS(this);
                } else {
                    final String msg = &quot;The -fx-skin property has not been defined in CSS for &quot; + this +
                            &quot; and createDefaultSkin() returned null.&quot;;
                    final List&lt;CssParser.ParseError&gt; errors = StyleManager.getErrors();
                    if (errors != null) {
                        CssParser.ParseError error = new CssParser.ParseError(msg);
                        errors.add(error); // RT-19884
                    }
                    Logging.getControlsLogger().severe(msg);
                }
            } finally {
                skinCreationLocked = false;
            }
        }
    }

    /**
     * Returns the initial focus traversable state of this control, for use
     * by the JavaFX CSS engine to correctly set its initial value. By default all
     * UI controls are focus traversable, so this method is overridden in Control
     * to set the initial traversable state to true.
     *
     * @return the initial focus traversable state of this control
     * @since 9
     */
    @Override protected Boolean getInitialFocusTraversable() {
        return Boolean.TRUE;
    }


    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case HELP:
                String help = getAccessibleHelp();
                if (help != null &amp;&amp; !help.isEmpty()) return help;
                Tooltip tooltip = getTooltip();
                return tooltip == null ? &quot;&quot; : tooltip.getText();
            default:
        }
        if (skinBase != null) {
            Object result = skinBase.queryAccessibleAttribute(attribute, parameters);
            if (result != null) return result;
        }
        return super.queryAccessibleAttribute(attribute, parameters);
    }

    /** {@inheritDoc} */
    @Override
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        if (skinBase != null) {
            skinBase.executeAccessibleAction(action, parameters);
        }
        super.executeAccessibleAction(action, parameters);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/MultipleSelectionModelBase.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import com.sun.javafx.collections.NonIterableChange;
import static javafx.scene.control.SelectionMode.SINGLE;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import com.sun.javafx.scene.control.MultipleAdditionAndRemovedChange;
import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
import com.sun.javafx.scene.control.SelectedItemsReadOnlyObservableList;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.ObservableListBase;
import javafx.util.Callback;

import javafx.util.Pair;


/**
 * An abstract class that implements more of the abstract MultipleSelectionModel
 * abstract class. However, this class is package-protected and not intended
 * for public use.
 *
 * @param &lt;T&gt; The type of the underlying data model for the UI control.
 */
abstract class MultipleSelectionModelBase&lt;T&gt; extends MultipleSelectionModel&lt;T&gt; {

    /***********************************************************************
     *                                                                     *
     * Constructors                                                        *
     *                                                                     *
     **********************************************************************/

    public MultipleSelectionModelBase() {
        selectedIndexProperty().addListener(valueModel -&gt; {
            // we used to lazily retrieve the selected item, but now we just
            // do it when the selection changes. This is hardly likely to be
            // expensive, and we still lazily handle the multiple selection
            // cases over in MultipleSelectionModel.
            setSelectedItem(getModelItem(getSelectedIndex()));
        });

        selectedIndices = new SelectedIndicesList();

        selectedItems = new SelectedItemsReadOnlyObservableList&lt;T&gt;(selectedIndices, () -&gt; getItemCount()) {
            @Override protected T getModelItem(int index) {
                return MultipleSelectionModelBase.this.getModelItem(index);
            }
        };
    }



    /***********************************************************************
     *                                                                     *
     * Observable properties                                               *
     *                                                                     *
     **********************************************************************/

    /*
     * We only maintain the values of the selectedIndex and selectedIndices
     * properties. The value of the selectedItem and selectedItems properties
     * is determined on-demand. We fire the SELECTED_ITEM and SELECTED_ITEMS
     * property change events whenever the related SELECTED_INDEX or
     * SELECTED_INDICES properties change.
     *
     * This means that the cost of the ListViewSelectionModel is cheap in most
     * cases, assuming that the end-consumer isn't calling getSelectedItems
     * too aggressively. Of course, this is only an issue when the ListViewModel
     * is being populated by some remote, expensive to query data source.
     *
     * In addition, we do not provide ObservableLists for the selected indices or the
     * selected items properties, as this would allow the API consumer to add
     * observers to these ObservableLists. This would make life tougher as we would
     * then be forced to keep these ObservableLists in-sync at all times, which for
     * the selectedItems ObservableList, would require potentially a lot of work and
     * memory. Instead, we return a List, and allow for changes to these Lists
     * to be observed through the SELECTED_INDICES and SELECTED_ITEMS
     * properties.
     */


    final SelectedIndicesList selectedIndices;
    @Override public ObservableList&lt;Integer&gt; getSelectedIndices() {
        return selectedIndices;
    }

    private final ObservableListBase&lt;T&gt; selectedItems;
    @Override public ObservableList&lt;T&gt; getSelectedItems() {
        return selectedItems;
    }



    /***********************************************************************
     *                                                                     *
     * Internal field                                                      *
     *                                                                     *
     **********************************************************************/

    ListChangeListener.Change selectedItemChange;



    /***********************************************************************
     *                                                                     *
     * Public selection API                                                *
     *                                                                     *
     **********************************************************************/

    /**
     * Returns the number of items in the data model that underpins the control.
     * An example would be that a ListView selection model would likely return
     * &lt;code&gt;listView.getItems().size()&lt;/code&gt;. The valid range of selectable
     * indices is between 0 and whatever is returned by this method.
     * @return the number of items in the data model that underpins the control
     */
    protected abstract int getItemCount();

    /**
     * Returns the item at the given index. An example using ListView would be
     * &lt;code&gt;listView.getItems().get(index)&lt;/code&gt;.
     *
     * @param index The index of the item that is requested from the underlying
     *      data model.
     * @return Returns null if the index is out of bounds, or an element of type
     *      T that is related to the given index.
     */
    protected abstract T getModelItem(int index);
    protected abstract void focus(int index);
    protected abstract int getFocusedIndex();

    static class ShiftParams {
        private final int clearIndex;
        private final int setIndex;
        private final boolean selected;

        ShiftParams(int clearIndex, int setIndex, boolean selected) {
            this.clearIndex = clearIndex;
            this.setIndex = setIndex;
            this.selected = selected;
        }

        public final int getClearIndex() {
            return clearIndex;
        }

        public final int getSetIndex() {
            return setIndex;
        }

        public final boolean isSelected() {
            return selected;
        }
    }

    // package only
    void shiftSelection(int position, int shift, final Callback&lt;ShiftParams, Void&gt; callback) {
        shiftSelection(Arrays.asList(new Pair&lt;&gt;(position, shift)), callback);
    }

    void shiftSelection(List&lt;Pair&lt;Integer, Integer&gt;&gt; shifts, final Callback&lt;ShiftParams, Void&gt; callback) {
        int selectedIndicesCardinality = selectedIndices.size(); // number of true bits
        if (selectedIndicesCardinality == 0) return;

        int selectedIndicesSize = selectedIndices.bitsetSize();   // number of bits reserved

        int[] perm = new int[selectedIndicesSize];
        Arrays.fill(perm, -1);

        // sort the list so that we iterate from highest position to lowest position
        Collections.sort(shifts, (s1, s2) -&gt; Integer.compare(s2.getKey(), s1.getKey()));
        final int lowestShiftPosition = shifts.get(shifts.size() - 1).getKey();

        // make a copy of the selectedIndices before so we can compare to it afterwards
        BitSet selectedIndicesCopy = (BitSet) selectedIndices.bitset.clone();

        startAtomic();
        for (Pair&lt;Integer, Integer&gt; shift : shifts) {
            doShift(shift, callback, perm);
        }
        stopAtomic();

        // strip out all useless -1 default values from the perm array
        final int[] prunedPerm = Arrays.stream(perm).filter(value -&gt; value &gt; -1).toArray();
        final boolean hasSelectionChanged = prunedPerm.length &gt; 0;

        // This ensure that the selection remains accurate when a shift occurs.
        final int selectedIndex = getSelectedIndex();
        if (selectedIndex &gt;= lowestShiftPosition &amp;&amp; selectedIndex &gt; -1) {
            // sum up the total shift, where the position is less than or equal
            // to the previously selected index
            int totalShift = shifts.stream()
                    .filter(shift -&gt; shift.getKey() &lt;= selectedIndex)
                    .mapToInt(shift -&gt; shift.getValue())
                    .sum();

            // Fix for RT-38787: we used to not enter this block if
            // selectedIndex + shift resulted in a value less than zero, whereas
            // now we just set the newSelectionLead to zero in that instance.
            // There exists unit tests that cover this.
            final int newSelectionLead = Math.max(0, selectedIndex + totalShift);

            setSelectedIndex(newSelectionLead);

            // added the selectedIndices call for RT-30356.
            // changed to check if hasPermutated, and to call select(..) for RT-40010.
            // This forces the selection event to go through the system and fire
            // the necessary events.
            if (hasSelectionChanged) {
                selectedIndices.set(newSelectionLead, true);
            } else {
                select(newSelectionLead);
            }

            // removed due to RT-27185
//            focus(newSelectionLead);
        }

        if (hasSelectionChanged) {
            // work out what indices were removed and added
            BitSet removed = (BitSet) selectedIndicesCopy.clone();
            removed.andNot(selectedIndices.bitset);

            BitSet added = (BitSet) selectedIndices.bitset.clone();
            added.andNot(selectedIndicesCopy);

            selectedIndices.reset();
            selectedIndices.callObservers(new MultipleAdditionAndRemovedChange&lt;&gt;(
                    added.stream().boxed().collect(Collectors.toList()),
                    removed.stream().boxed().collect(Collectors.toList()),
                    selectedIndices
            ));
        }
    }

    private void doShift(Pair&lt;Integer, Integer&gt; shiftPair, final Callback&lt;ShiftParams, Void&gt; callback, int[] perm) {
        final int position = shiftPair.getKey();
        final int shift = shiftPair.getValue();

        // with no check here, we get RT-15024
        if (position &lt; 0) return;
        if (shift == 0) return;

        int idx = (int) Arrays.stream(perm).filter(value -&gt; value &gt; -1).count();

        int selectedIndicesSize = selectedIndices.bitsetSize() - idx;   // number of bits reserved

        if (shift &gt; 0) {
            for (int i = selectedIndicesSize - 1; i &gt;= position &amp;&amp; i &gt;= 0; i--) {
                boolean selected = selectedIndices.isSelected(i);

                if (callback == null) {
                    selectedIndices.clear(i);
                    selectedIndices.set(i + shift, selected);
                } else {
                    callback.call(new ShiftParams(i, i + shift, selected));
                }

                if (selected) {
                    perm[idx++] = i + 1;
                }
            }
            selectedIndices.clear(position);
        } else if (shift &lt; 0) {
            for (int i = position; i &lt; selectedIndicesSize; i++) {
                if ((i + shift) &lt; 0) continue;
                if ((i + 1 + shift) &lt; position) continue;
                boolean selected = selectedIndices.isSelected(i + 1);

                if (callback == null) {
                    selectedIndices.clear(i + 1);
                    selectedIndices.set(i + 1 + shift, selected);
                } else {
                    callback.call(new ShiftParams(i + 1, i + 1 + shift, selected));
                }

                if (selected) {
                    perm[idx++] = i;
                }
            }
        }
    }

    void startAtomic() {
        selectedIndices.startAtomic();
    }

    void stopAtomic() {
        selectedIndices.stopAtomic();
    }

    boolean isAtomic() {
        return selectedIndices.isAtomic();
    }

    @Override public void clearAndSelect(int row) {
        if (row &lt; 0 || row &gt;= getItemCount()) {
            clearSelection();
            return;
        }

        final boolean wasSelected = isSelected(row);

        // RT-33558 if this method has been called with a given row, and that
        // row is the only selected row currently, then this method becomes a no-op.
        if (wasSelected &amp;&amp; getSelectedIndices().size() == 1) {
            // before we return, we double-check that the selected item
            // is equal to the item in the given index
            if (getSelectedItem() == getModelItem(row)) {
                return;
            }
        }

        // firstly we make a copy of the selection, so that we can send out
        // the correct details in the selection change event.
        // We remove the new selection from the list seeing as it is not removed.
        BitSet selectedIndicesCopy = new BitSet();
        selectedIndicesCopy.or(selectedIndices.bitset);
        selectedIndicesCopy.clear(row);
        List&lt;Integer&gt; previousSelectedIndices = new SelectedIndicesList(selectedIndicesCopy);

        // RT-32411 We used to call quietClearSelection() here, but this
        // resulted in the selectedItems and selectedIndices lists never
        // reporting that they were empty.
        // makeAtomic toggle added to resolve RT-32618
        startAtomic();

        // then clear the current selection
        clearSelection();

        // and select the new row
        select(row);
        stopAtomic();

        // fire off a single add/remove/replace notification (rather than
        // individual remove and add notifications) - see RT-33324
        ListChangeListener.Change&lt;Integer&gt; change;

        /*
         * getFrom() documentation:
         *   If wasAdded is true, the interval contains all the values that were added.
         *   If wasPermutated is true, the interval marks the values that were permutated.
         *   If wasRemoved is true and wasAdded is false, getFrom() and getTo() should
         *   return the same number - the place where the removed elements were positioned in the list.
         */
        if (wasSelected) {
            change = ControlUtils.buildClearAndSelectChange(selectedIndices, previousSelectedIndices, row);
        } else {
            int changeIndex = Math.max(0, selectedIndices.indexOf(row));
            change = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(
                    changeIndex, changeIndex+1, previousSelectedIndices, selectedIndices);
        }

        selectedIndices.callObservers(change);
    }

    @Override public void select(int row) {
        if (row == -1) {
            clearSelection();
            return;
        }
        if (row &lt; 0 || row &gt;= getItemCount()) {
            return;
        }

        boolean isSameRow = row == getSelectedIndex();
        T currentItem = getSelectedItem();
        T newItem = getModelItem(row);
        boolean isSameItem = newItem != null &amp;&amp; newItem.equals(currentItem);
        boolean fireUpdatedItemEvent = isSameRow &amp;&amp; ! isSameItem;

        // focus must come first so that we have the anchors set appropriately
        focus(row);

        if (! selectedIndices.isSelected(row)) {
            if (getSelectionMode() == SINGLE) {
                startAtomic();
                quietClearSelection();
                stopAtomic();
            }
            selectedIndices.set(row);
        }

        setSelectedIndex(row);

        if (fireUpdatedItemEvent) {
            setSelectedItem(newItem);
        }
    }

    @Override public void select(T obj) {
//        if (getItemCount() &lt;= 0) return;

        if (obj == null &amp;&amp; getSelectionMode() == SelectionMode.SINGLE) {
            clearSelection();
            return;
        }

        // We have no option but to iterate through the model and select the
        // first occurrence of the given object. Once we find the first one, we
        // don't proceed to select any others.
        Object rowObj = null;
        for (int i = 0, max = getItemCount(); i &lt; max; i++) {
            rowObj = getModelItem(i);
            if (rowObj == null) continue;

            if (rowObj.equals(obj)) {
                if (isSelected(i)) {
                    return;
                }

                if (getSelectionMode() == SINGLE) {
                    quietClearSelection();
                }

                select(i);
                return;
            }
        }

        // if we are here, we did not find the item in the entire data model.
        // Even still, we allow for this item to be set to the give object.
        // We expect that in concrete subclasses of this class we observe the
        // data model such that we check to see if the given item exists in it,
        // whilst SelectedIndex == -1 &amp;&amp; SelectedItem != null.
        setSelectedIndex(-1);
        setSelectedItem(obj);
    }

    @Override public void selectIndices(int row, int... rows) {
        if (rows == null || rows.length == 0) {
            select(row);
            return;
        }

        /*
         * Performance optimisation - if multiple selection is disabled, only
         * process the end-most row index.
         */

        int rowCount = getItemCount();

        if (getSelectionMode() == SINGLE) {
            quietClearSelection();

            for (int i = rows.length - 1; i &gt;= 0; i--) {
                int index = rows[i];
                if (index &gt;= 0 &amp;&amp; index &lt; rowCount) {
                    selectedIndices.set(index);
                    select(index);
                    break;
                }
            }

            if (selectedIndices.isEmpty()) {
                if (row &gt; 0 &amp;&amp; row &lt; rowCount) {
                    selectedIndices.set(row);
                    select(row);
                }
            }
        } else {
            selectedIndices.set(row, rows);

            IntStream.concat(IntStream.of(row), IntStream.of(rows))
                     .filter(index -&gt; index &gt;= 0 &amp;&amp; index &lt; rowCount)
                     .reduce((first, second) -&gt; second)
                     .ifPresent(lastIndex -&gt; {
                         setSelectedIndex(lastIndex);
                         focus(lastIndex);
                         setSelectedItem(getModelItem(lastIndex));
                     });
<A NAME="46"></A>        }
    }

    <FONT color="#92c7c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#46',2,'match37-top.html#46',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override public void selectAll() {
        if (getSelectionMode() == SINGLE) return;

        if (getItemCount() &lt;= 0) return;</B></FONT>

        final int rowCount = getItemCount();
        final int focusedIndex = getFocusedIndex();

        // set all selected indices to true
        clearSelection();
        selectedIndices.set(0, rowCount, true);

        if (focusedIndex == -1) {
            setSelectedIndex(rowCount - 1);
            focus(rowCount - 1);
        } else {
            setSelectedIndex(focusedIndex);
            focus(focusedIndex);
        }
    }

    @Override public void selectFirst() {
        if (getSelectionMode() == SINGLE) {
            quietClearSelection();
        }

        if (getItemCount() &gt; 0) {
            select(0);
        }
    }

    @Override public void selectLast() {
        if (getSelectionMode() == SINGLE) {
            quietClearSelection();
        }

        int numItems = getItemCount();
        if (numItems &gt; 0 &amp;&amp; getSelectedIndex() &lt; numItems - 1) {
            select(numItems - 1);
        }
    }

    @Override public void clearSelection(int index) {
        if (index &lt; 0) return;

        // TODO shouldn't directly access like this
        // TODO might need to update focus and / or selected index/item
        boolean wasEmpty = selectedIndices.isEmpty();
        selectedIndices.clear(index);

        if (! wasEmpty &amp;&amp; selectedIndices.isEmpty()) {
            clearSelection();
        }
    }

    @Override public void clearSelection() {
        quietClearSelection();

        if (! isAtomic()) {
            setSelectedIndex(-1);
            focus(-1);
        }
    }

    private void quietClearSelection() {
        selectedIndices.clear();
    }

    @Override public boolean isSelected(int index) {
        // Note the change in semantics here - we used to check to ensure that
        // the index is less than the item count, but now simply ensure that
        // it is less than the length of the selectedIndices bitset. This helps
        // to resolve issues such as RT-26721, where isSelected(int) was being
        // called for indices that exceeded the item count, as a TreeItem (e.g.
        // the root) was being collapsed.
//        if (index &gt;= 0 &amp;&amp; index &lt; getItemCount()) {
        if (index &gt;= 0 &amp;&amp; index &lt; selectedIndices.bitsetSize()) {
            return selectedIndices.isSelected(index);
        }

        return false;
    }

    @Override public boolean isEmpty() {
        return selectedIndices.isEmpty();
    }

    @Override public void selectPrevious() {
        int focusIndex = getFocusedIndex();

        if (getSelectionMode() == SINGLE) {
            quietClearSelection();
        }

        if (focusIndex == -1) {
            select(getItemCount() - 1);
        } else if (focusIndex &gt; 0) {
            select(focusIndex - 1);
        }
    }

    @Override public void selectNext() {
        int focusIndex = getFocusedIndex();

        if (getSelectionMode() == SINGLE) {
            quietClearSelection();
        }

        if (focusIndex == -1) {
            select(0);
        } else if (focusIndex != getItemCount() -1) {
            select(focusIndex + 1);
        }
    }



    /***********************************************************************
     *                                                                     *
     * Private implementation                                              *
     *                                                                     *
     **********************************************************************/

    class SelectedIndicesList extends ReadOnlyUnbackedObservableList&lt;Integer&gt; {
        private final BitSet bitset;

        private int lastGetIndex = -1;
        private int lastGetValue = -1;

        // Fix for RT-20945 (and numerous other issues!)
        private int atomicityCount = 0;

//        @Override
//        public void callObservers(Change&lt;Integer&gt; c) {
//            throw new RuntimeException(&quot;callObservers unavailable&quot;);
//        }

        public SelectedIndicesList() {
            this(new BitSet());
        }

        public SelectedIndicesList(BitSet bitset) {
            this.bitset = bitset;
        }

        boolean isAtomic() {
            return atomicityCount &gt; 0;
        }
        void startAtomic() {
            atomicityCount++;
        }
        void stopAtomic() {
            atomicityCount = Math.max(0, atomicityCount - 1);
        }

        // Returns the selected index at the given index.
        // e.g. if our selectedIndices are [1,3,5], then an index of 2 will return 5 here.
        @Override public Integer get(int index) {
            final int itemCount = size();
            if (index &lt; 0 || index &gt;= itemCount)  {
                throw new IndexOutOfBoundsException(index + &quot; &gt;= &quot; + itemCount);
            }

            if (index == (lastGetIndex + 1) &amp;&amp; lastGetValue &lt; itemCount) {
                // we're iterating forward in order, short circuit for
                // performance reasons (RT-39776)
                lastGetIndex++;
                lastGetValue = bitset.nextSetBit(lastGetValue + 1);
                return lastGetValue;
            } else if (index == (lastGetIndex - 1) &amp;&amp; lastGetValue &gt; 0) {
                // we're iterating backward in order, short circuit for
                // performance reasons (RT-39776)
                lastGetIndex--;
                lastGetValue = bitset.previousSetBit(lastGetValue - 1);
                return lastGetValue;
            } else {
                for (lastGetIndex = 0, lastGetValue = bitset.nextSetBit(0);
                     lastGetValue &gt;= 0 || lastGetIndex == index;
                     lastGetIndex++, lastGetValue = bitset.nextSetBit(lastGetValue + 1)) {
                    if (lastGetIndex == index) {
                        return lastGetValue;
                    }
                }
            }

            return -1;
        }

        public void set(int index) {
            if (!isValidIndex(index) || isSelected(index)) {
                return;
            }

            _beginChange();
            bitset.set(index);
            int indicesIndex = indexOf(index);
            _nextAdd(indicesIndex, indicesIndex + 1);
            _endChange();
        }

        private boolean isValidIndex(int index) {
            return index &gt;= 0 &amp;&amp; index &lt; getItemCount();
        }

        public void set(int index, boolean isSet) {
            if (isSet) {
                set(index);
            } else {
                clear(index);
            }
        }

        public void set(int index, int end, boolean isSet) {
            _beginChange();
            if (isSet) {
                bitset.set(index, end, isSet);
                int indicesIndex = indexOf(index);
                int span = end - index;
                _nextAdd(indicesIndex, indicesIndex + span);
            } else {
                // TODO handle remove
                bitset.set(index, end, isSet);
            }
            _endChange();
        }

        public void set(int index, int... indices) {
            if (indices == null || indices.length == 0) {
                set(index);
            } else {
                // we reduce down to the minimal number of changes possible
                // by finding all contiguous indices, of all indices that are
                // not already selected, and which are in the valid range
                startAtomic();
                List&lt;Integer&gt; sortedNewIndices =
                        IntStream.concat(IntStream.of(index), IntStream.of(indices))
                        .distinct()
                        .filter(this::isValidIndex)
                        .filter(this::isNotSelected)
                        .sorted()
                        .boxed()
                        .peek(this::set) // we also set here, but it's atomic!
                        .collect(Collectors.toList());
                stopAtomic();

                final int size = sortedNewIndices.size();
                if (size == 0) {
                    // no-op
                } else if (size == 1) {
                    _beginChange();
                    int _index = sortedNewIndices.get(0);
                    int indicesIndex = indexOf(_index);
                    _nextAdd(indicesIndex, indicesIndex + 1);
                    _endChange();
                } else {
                    _beginChange();
                    int pos = 0;
                    int start = 0;
                    int end = 0;

                    // starting from pos, we keep going until the value is
                    // not the next value
                    int startValue = sortedNewIndices.get(pos++);
                    start = indexOf(startValue);
                    end = start + 1;
                    int endValue = startValue;
                    while (pos &lt; size) {
                        int previousEndValue = endValue;
                        endValue = sortedNewIndices.get(pos++);
                        ++end;
                        if (previousEndValue != (endValue - 1)) {
                            _nextAdd(start, end);
                            start = end;
                            continue;
                        }

                        // special case for when we get to the point where the loop is about to end
                        // and we have uncommitted changes to fire.
                        if (pos == size) {
                            _nextAdd(start, start + pos);
                        }
                    }

                    _endChange();
                }
            }
        }

        public void clear() {
            _beginChange();
            List&lt;Integer&gt; removed = bitset.stream().boxed().collect(Collectors.toList());
            bitset.clear();
            _nextRemove(0, removed);
            _endChange();
        }

        public void clear(int index) {
            if (!bitset.get(index)) return;

            _beginChange();
            bitset.clear(index);
            _nextRemove(index, index);
            _endChange();
        }

//        public void clearAndSelect(int index) {
//            if (index &lt; 0 || index &gt;= getItemCount()) {
//                clearSelection();
//                return;
//            }
//
//            final boolean wasSelected = isSelected(index);
//
//            // RT-33558 if this method has been called with a given row, and that
//            // row is the only selected row currently, then this method becomes a no-op.
//            if (wasSelected &amp;&amp; getSelectedIndices().size() == 1) {
//                // before we return, we double-check that the selected item
//                // is equal to the item in the given index
//                if (getSelectedItem() == getModelItem(index)) {
//                    return;
//                }
//            }
//
//            List&lt;Integer&gt; removed = bitset.stream().boxed().collect(Collectors.toList());
//            boolean isSelected = removed.contains(index);
//            if (isSelected) {
//                removed.remove((Object)index);
//            }
//
//            if (removed.isEmpty()) {
//                set(index);
//            }
//
//            bitset.clear();
//            bitset.set(index);
//            _beginChange();
//            if (isSelected) {
//                _nextRemove(0, removed);
//            } else {
//                _nextAdd(0, 1);
//                _nextRemove(0, removed);
//            }
//            _endChange();
//        }

        public boolean isSelected(int index) {
            return bitset.get(index);
        }

        public boolean isNotSelected(int index) {
            return !isSelected(index);
        }

        /** Returns number of true bits in BitSet */
        @Override public int size() {
            return bitset.cardinality();
        }

        /** Returns the number of bits reserved in the BitSet */
        public int bitsetSize() {
            return bitset.size();
        }

        @Override public int indexOf(Object obj) {
            reset();
            return super.indexOf(obj);
        }

        @Override public boolean contains(Object o) {
            if (o instanceof Number) {
                Number n = (Number) o;
                int index = n.intValue();

                return index &gt;= 0 &amp;&amp; index &lt; bitset.length() &amp;&amp;
                        bitset.get(index);
            }

            return false;
        }

        public void reset() {
            this.lastGetIndex = -1;
            this.lastGetValue = -1;
        }

        @Override public void _beginChange() {
            if (!isAtomic()) {
                super._beginChange();
            }
        }

        @Override public void _endChange() {
            if (!isAtomic()) {
                super._endChange();
            }
        }

        @Override public final void _nextUpdate(int pos) {
            if (!isAtomic()) {
                nextUpdate(pos);
            }
        }

        @Override public final void _nextSet(int idx, Integer old) {
            if (!isAtomic()) {
                nextSet(idx, old);
            }
        }

        @Override public final void _nextReplace(int from, int to, List&lt;? extends Integer&gt; removed) {
            if (!isAtomic()) {
                nextReplace(from, to, removed);
            }
        }

        @Override public final void _nextRemove(int idx, List&lt;? extends Integer&gt; removed) {
            if (!isAtomic()) {
                nextRemove(idx, removed);
            }
        }

        @Override public final void _nextRemove(int idx, Integer removed) {
            if (!isAtomic()) {
                nextRemove(idx, removed);
            }
        }

        @Override public final void _nextPermutation(int from, int to, int[] perm) {
            if (!isAtomic()) {
                nextPermutation(from, to, perm);
            }
        }

        @Override public final void _nextAdd(int from, int to) {
            if (!isAtomic()) {
                nextAdd(from, to);
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/ScrollBar.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.util.Utils;
import javafx.css.converter.EnumConverter;
import javafx.css.converter.SizeConverter;
import javafx.scene.control.skin.ScrollBarSkin;

import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.geometry.Orientation;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;


/**
 * Either a horizontal or vertical bar with increment and decrement buttons and
 * a &quot;thumb&quot; with which the user can interact. Typically not used alone but used
 * for building up more complicated controls such as the ScrollPane and ListView.
 * &lt;p&gt;
 * ScrollBar sets focusTraversable to false.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * This example creates a vertical ScrollBar :
 * &lt;pre&gt;&lt;code&gt;
 * import javafx.scene.control.ScrollBar;
 *
 * ScrollBar s1 = new ScrollBar();
 * s1.setOrientation(Orientation.VERTICAL);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * Implementation of ScrollBar According to JavaFX UI Control API Specification
 * @since JavaFX 2.0
 */

public class ScrollBar extends Control {

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new horizontal ScrollBar (ie getOrientation() == Orientation.HORIZONTAL).
     *
     *
     */
    public ScrollBar() {
        // TODO : we need to ensure we have a width and height
        setWidth(Properties.DEFAULT_WIDTH);
        setHeight(Properties.DEFAULT_LENGTH);
        getStyleClass().setAll(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.SCROLL_BAR);
        // focusTraversable is styleable through css. Calling setFocusTraversable
        // makes it look to css like the user set the value and css will not
        // override. Initializing focusTraversable by calling applyStyle with null
        // for StyleOrigin ensures that css will be able to override the value.
        ((StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)focusTraversableProperty()).applyStyle(null,Boolean.FALSE);

        // set pseudo-class state to horizontal
        pseudoClassStateChanged(HORIZONTAL_PSEUDOCLASS_STATE, true);

    }
    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/
    /**
     * The minimum value represented by this {@code ScrollBar}. This should be a
     * value less than or equal to {@link #maxProperty max}. Default value is 0.
     */
    private DoubleProperty min;
    public final void setMin(double value) {
        minProperty().set(value);
    }

    public final double getMin() {
        return min == null ? 0 : min.get();
    }

    public final DoubleProperty minProperty() {
        if (min == null) {
            min = new SimpleDoubleProperty(this, &quot;min&quot;);
        }
        return min;
    }
    /**
     * The maximum value represented by this {@code ScrollBar}. This should be a
     * value greater than or equal to {@link #minProperty min}. Default value is 100.
     */
    private DoubleProperty max;
    public final void setMax(double value) {
        maxProperty().set(value);
    }

    public final double getMax() {
        return max == null ? 100 : max.get();
    }

    public final DoubleProperty maxProperty() {
        if (max == null) {
            max = new SimpleDoubleProperty(this, &quot;max&quot;, 100);
        }
        return max;
    }
    /**
     * The current value represented by this {@code ScrollBar}. This value should
     * be between {@link #minProperty min} and {@link #maxProperty max}, inclusive.
     */
    private DoubleProperty value;
    public final void setValue(double value) {
        valueProperty().set(value);
    }

    public final double getValue() {
        return value == null ? 0 : value.get();
    }

    public final DoubleProperty valueProperty() {
        if (value == null) {
            value = new SimpleDoubleProperty(this, &quot;value&quot;);
        }
        return value;
    }
    /**
     * The orientation of the {@code ScrollBar} can either be {@link javafx.geometry.Orientation#HORIZONTAL HORIZONTAL}
     * or {@link javafx.geometry.Orientation#VERTICAL VERTICAL}.
     */
    private ObjectProperty&lt;Orientation&gt; orientation;
    public final void setOrientation(Orientation value) {
        orientationProperty().set(value);
    }

    public final Orientation getOrientation() {
        return orientation == null ? Orientation.HORIZONTAL : orientation.get();
    }

    public final ObjectProperty&lt;Orientation&gt; orientationProperty() {
        if (orientation == null) {
            orientation = new StyleableObjectProperty&lt;Orientation&gt;(Orientation.HORIZONTAL) {
                @Override protected void invalidated() {
                    final boolean vertical = (get() == Orientation.VERTICAL);
                    pseudoClassStateChanged(VERTICAL_PSEUDOCLASS_STATE,    vertical);
                    pseudoClassStateChanged(HORIZONTAL_PSEUDOCLASS_STATE, !vertical);
                }

                @Override
                public CssMetaData&lt;ScrollBar,Orientation&gt; getCssMetaData() {
                    return StyleableProperties.ORIENTATION;
                }

                @Override
                public Object getBean() {
                    return ScrollBar.this;
                }

                @Override
                public String getName() {
                    return &quot;orientation&quot;;
                }
            };
        }
        return orientation;
    }

    /**
     * The amount by which to adjust the ScrollBar when the {@link #increment() increment} or
     * {@link #decrement() decrement} methods are called.
     */
    private DoubleProperty unitIncrement;
    public final void setUnitIncrement(double value) {
        unitIncrementProperty().set(value);
    }

    public final double getUnitIncrement() {
        return unitIncrement == null ? 1 : unitIncrement.get();
    }

    public final DoubleProperty unitIncrementProperty() {
        if (unitIncrement == null) {
            unitIncrement = new StyleableDoubleProperty(1) {

                @Override
                public CssMetaData&lt;ScrollBar,Number&gt; getCssMetaData() {
                    return StyleableProperties.UNIT_INCREMENT;
                }

                @Override
                public Object getBean() {
                    return ScrollBar.this;
                }

                @Override
                public String getName() {
                    return &quot;unitIncrement&quot;;
                }
            };
        }
        return unitIncrement;
    }
    /**
     * The amount by which to adjust the scrollbar if the track of the bar is
     * clicked.
     */
    private DoubleProperty blockIncrement;
    public final void setBlockIncrement(double value) {
        blockIncrementProperty().set(value);
    }

    public final double getBlockIncrement() {
        return blockIncrement == null ? 10 : blockIncrement.get();
    }

    public final DoubleProperty blockIncrementProperty() {
        if (blockIncrement == null) {
            blockIncrement = new StyleableDoubleProperty(10) {

                @Override
                public CssMetaData&lt;ScrollBar,Number&gt; getCssMetaData() {
                    return StyleableProperties.BLOCK_INCREMENT;
                }

                @Override
                public Object getBean() {
                    return ScrollBar.this;
                }

                @Override
                public String getName() {
                    return &quot;blockIncrement&quot;;
                }
            };
        }
        return blockIncrement;
    }
    /**
     * Visible amount of the scrollbar's range, typically represented by
     * the size of the scroll bar's thumb.
     */
    private DoubleProperty visibleAmount;

    public final void setVisibleAmount(double value) {
        visibleAmountProperty().set(value);
    }

    public final double getVisibleAmount() {
        return visibleAmount == null ? 15 : visibleAmount.get();
    }

    public final DoubleProperty visibleAmountProperty() {
        if (visibleAmount == null) {
            visibleAmount = new SimpleDoubleProperty(this, &quot;visibleAmount&quot;);
        }
        return visibleAmount;
    }

    /***************************************************************************
     *                                                                         *
     * Methods                                                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Adjusts the {@link #valueProperty() value} property by
     * {@link #blockIncrementProperty() blockIncrement}. The {@code position} is the fractional amount
     * between the {@link #minProperty min} and {@link #maxProperty max}. For
     * example, it might be 50%. If {@code #minProperty min} were 0 and {@code #maxProperty max}
     * were 100 and {@link #valueProperty() value} were 25, then a position of .5 would indicate
     * that we should increment {@link #valueProperty() value} by
     * {@code blockIncrement}. If {@link #valueProperty() value} were 75, then a
     * position of .5 would indicate that we
     * should decrement {@link #valueProperty() value} by {@link #blockIncrementProperty blockIncrement}.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins or Behaviors. It is not common
     *       for developers or designers to access this function directly.
     * @param position the position
     */
    public void adjustValue(double position) {
        // figure out the &quot;value&quot; associated with the specified position
        double posValue = ((getMax() - getMin()) * Utils.clamp(0, position, 1))+getMin();
        double newValue;
        if (Double.compare(posValue, getValue()) != 0) {
            if (posValue &gt; getValue()) {
                newValue = getValue() + getBlockIncrement();
            }
            else {
                newValue = getValue() - getBlockIncrement();
            }

            boolean incrementing = position &gt; ((getValue() - getMin())/(getMax() - getMin()));
            if (incrementing &amp;&amp; newValue &gt; posValue) newValue = posValue;
            if (! incrementing &amp;&amp; newValue &lt; posValue) newValue = posValue;
            setValue(Utils.clamp(getMin(), newValue, getMax()));
        }
    }

    /**
     * Increments the value of the {@code ScrollBar} by the
     * {@link #unitIncrementProperty unitIncrement}
     */
    public void increment() {
        setValue(Utils.clamp(getMin(), getValue() + getUnitIncrement(), getMax()));
    }

    /**
     * Decrements the value of the {@code ScrollBar} by the
<A NAME="50"></A>     * {@link #unitIncrementProperty unitIncrement}
     */
    public void decrement() {
        <FONT color="#ff0000"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#50',2,'match37-top.html#50',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>setValue(Utils.clamp(getMin(), getValue() - getUnitIncrement(), getMax()));
    }

    private void blockIncrement() {
        adjustValue(getValue() + getBlockIncrement());
    }

    private void blockDecrement() {
        adjustValue(getValue() - getBlockIncrement());
    }

    /** {@inheritDoc} */
    @Override protect</B></FONT>ed Skin&lt;?&gt; createDefaultSkin() {
        return new ScrollBarSkin(this);
    }

    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    /**
     * Initialize the style class to 'scroll-bar'.
     *
     * This is the selector class from which CSS can be used to style
     * this control.
     */
    private static final String DEFAULT_STYLE_CLASS = &quot;scroll-bar&quot;;

    private static class StyleableProperties {
        private static final CssMetaData&lt;ScrollBar,Orientation&gt; ORIENTATION =
            new CssMetaData&lt;ScrollBar,Orientation&gt;(&quot;-fx-orientation&quot;,
                new EnumConverter&lt;Orientation&gt;(Orientation.class),
                Orientation.HORIZONTAL) {

            @Override
            public Orientation getInitialValue(ScrollBar node) {
                // A vertical ScrollBar should remain vertical
                return node.getOrientation();
            }

            @Override
            public boolean isSettable(ScrollBar n) {
                return n.orientation == null || !n.orientation.isBound();
            }

            @Override
            public StyleableProperty&lt;Orientation&gt; getStyleableProperty(ScrollBar n) {
                return (StyleableProperty&lt;Orientation&gt;)(WritableValue&lt;Orientation&gt;)n.orientationProperty();
            }
        };

        private static final CssMetaData&lt;ScrollBar,Number&gt; UNIT_INCREMENT =
            new CssMetaData&lt;ScrollBar,Number&gt;(&quot;-fx-unit-increment&quot;,
                SizeConverter.getInstance(), 1.0) {

            @Override
            public boolean isSettable(ScrollBar n) {
                return n.unitIncrement == null || !n.unitIncrement.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(ScrollBar n) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.unitIncrementProperty();
            }

        };

        private static final CssMetaData&lt;ScrollBar,Number&gt; BLOCK_INCREMENT =
            new CssMetaData&lt;ScrollBar,Number&gt;(&quot;-fx-block-increment&quot;,
                SizeConverter.getInstance(), 10.0) {

            @Override
            public boolean isSettable(ScrollBar n) {
                return n.blockIncrement == null || !n.blockIncrement.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(ScrollBar n) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.blockIncrementProperty();
            }

        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
            styleables.add(ORIENTATION);
            styleables.add(UNIT_INCREMENT);
            styleables.add(BLOCK_INCREMENT);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
        return getClassCssMetaData();
    }

    /**
     * Pseud-class indicating this is a vertical ScrollBar.
     */
    private static final PseudoClass VERTICAL_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;vertical&quot;);

    /**
     * Pseudo-class indicating this is a horizontal ScrollBar.
     */
    private static final PseudoClass HORIZONTAL_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;horizontal&quot;);

    /**
     * Returns the initial focus traversable state of this control, for use
     * by the JavaFX CSS engine to correctly set its initial value. This method
     * is overridden as by default UI controls have focus traversable set to true,
     * but that is not appropriate for this control.
     *
     * @since 9
     */
    @Override protected Boolean getInitialFocusTraversable() {
        return Boolean.FALSE;
    }



    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case VALUE: return getValue();
            case MAX_VALUE: return getMax();
            case MIN_VALUE: return getMin();
            case ORIENTATION: return getOrientation();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case INCREMENT: increment(); break;
            case DECREMENT: decrement(); break;
            case BLOCK_INCREMENT: blockIncrement(); break;
            case BLOCK_DECREMENT: blockDecrement(); break;
            case SET_VALUE: {
                Double value = (Double) parameters[0];
                if (value != null) setValue(value);
                break;
            }
            default: super.executeAccessibleAction(action, parameters);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TextInputControl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import com.sun.javafx.scene.control.FormatterAccessor;
import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.binding.IntegerBinding;
import javafx.beans.binding.StringBinding;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyBooleanWrapper;
import javafx.beans.property.ReadOnlyIntegerProperty;
import javafx.beans.property.ReadOnlyIntegerWrapper;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.ReadOnlyStringProperty;
import javafx.beans.property.ReadOnlyStringWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableStringValue;
import javafx.beans.value.ObservableValue;
import javafx.beans.value.WritableValue;
import javafx.css.CssMetaData;
import javafx.css.FontCssMetaData;
import javafx.css.PseudoClass;
import javafx.css.StyleOrigin;
import javafx.css.Styleable;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.input.Clipboard;
import javafx.scene.input.ClipboardContent;
import javafx.scene.text.Font;

import java.text.BreakIterator;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.sun.javafx.util.Utils;
import com.sun.javafx.binding.ExpressionHelper;
import com.sun.javafx.scene.NodeHelper;
import javafx.util.StringConverter;

/**
 * Abstract base class for text input controls.
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;text&quot;)
public abstract class TextInputControl extends Control {
    /**
     * Interface representing a text input's content. Since it is an ObservableStringValue,
     * you can also bind to, or observe the content.
     * @since JavaFX 2.0
     */
    protected interface Content extends ObservableStringValue {
        /**
         * Retrieves a subset of the content.
         *
         * @param start the start
         * @param end the end
         * @return a subset of the content
         */
        public String get(int start, int end);

        /**
         * Inserts a sequence of characters into the content.
         *
         * @param index the index
         * @param text the text string
         * @param notifyListeners the notify listener flag
         * @since JavaFX 2.1
         */
        public void insert(int index, String text, boolean notifyListeners);

        /**
         * Removes a sequence of characters from the content.
         *
         * @param start the start
         * @param end the end
         * @param notifyListeners the notify listener flag
         * @since JavaFX 2.1
         */
        public void delete(int start, int end, boolean notifyListeners);

        /**
         * Returns the number of characters represented by the content.
         * @return the number of characters
         */
        public int length();
    }

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TextInputControl. The content is an immutable property and
     * must be specified (as non-null) at the time of construction.
     *
     * @param content a non-null implementation of Content.
     */
    protected TextInputControl(final Content content) {
        this.content = content;

        // Add a listener so that whenever the Content is changed, we notify
        // listeners of the text property that it is invalid.
        content.addListener(observable -&gt; {
            if (content.length() &gt; 0) {
                text.textIsNull = false;
            }
            text.controlContentHasChanged();
        });

        // Bind the length to be based on the length of the text property
        length.bind(new IntegerBinding() {
            { bind(text); }
            @Override protected int computeValue() {
                String txt = text.get();
                return txt == null ? 0 : txt.length();
            }
        });

        // Bind the selected text to be based on the selection and text properties
        selectedText.bind(new StringBinding() {
            { bind(selection, text); }
            @Override protected String computeValue() {
                String txt = text.get();
                IndexRange sel = selection.get();
                if (txt == null || sel == null) return &quot;&quot;;

                int start = sel.getStart();
                int end = sel.getEnd();
                int length = txt.length();
                if (end &gt; start + length) end = length;
                if (start &gt; length-1) start = end = 0;
                return txt.substring(start, end);
            }
        });

        focusedProperty().addListener((ob, o, n) -&gt; {
            if (n) {
                if (getTextFormatter() != null) {
                    updateText(getTextFormatter());
                }
            } else {
                commitValue();
            }
        });

        // Specify the default style class
        getStyleClass().add(&quot;text-input&quot;);
    }

    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * The default font to use for text in the TextInputControl. If the TextInputControl's text is
     * rich text then this font may or may not be used depending on the font
     * information embedded in the rich text, but in any case where a default
     * font is required, this font will be used.
     * @return the font property
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;Font&gt; fontProperty() {
        if (font == null) {
            font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {


                private boolean fontSetByCss = false;

                @Override
                public void applyStyle(StyleOrigin newOrigin, Font value) {

                    //
                    // RT-20727 - if CSS is setting the font, then make sure invalidate doesn't call NodeHelper.reapplyCSS
                    //
                    try {
                        // super.applyStyle calls set which might throw if value is bound.
                        // Have to make sure fontSetByCss is reset.
                        fontSetByCss = true;
                        super.applyStyle(newOrigin, value);
                    } catch(Exception e) {
                        throw e;
                    } finally {
                        fontSetByCss = false;
                    }

                }


                @Override
                public void set(Font value) {
                    final Font oldValue = get();
                    if (value == null ? oldValue == null : value.equals(oldValue)) {
                        return;
                    }
                    super.set(value);
                }

                @Override
                protected void invalidated() {
                    // RT-20727 - if font is changed by calling setFont, then
                    // css might need to be reapplied since font size affects
                    // calculated values for styles with relative values
                    if(fontSetByCss == false) {
                        NodeHelper.reapplyCSS(TextInputControl.this);
                    }
                }

                @Override
                public CssMetaData&lt;TextInputControl,Font&gt; getCssMetaData() {
                    return StyleableProperties.FONT;
                }

                @Override
                public Object getBean() {
                    return TextInputControl.this;
                }

                @Override
                public String getName() {
                    return &quot;font&quot;;
                }
            };
        }
        return font;
    }

    private ObjectProperty&lt;Font&gt; font;
    public final void setFont(Font value) { fontProperty().setValue(value); }
    public final Font getFont() { return font == null ? Font.getDefault() : font.getValue(); }

    /**
     * The prompt text to display in the {@code TextInputControl}. If set to null or an empty string, no
     * prompt text is displayed.
     *
     * @defaultValue An empty String
     * @since JavaFX 2.2
     */
    private StringProperty promptText = new SimpleStringProperty(this, &quot;promptText&quot;, &quot;&quot;) {
        @Override protected void invalidated() {
            // Strip out newlines
            String txt = get();
            if (txt != null &amp;&amp; txt.contains(&quot;\n&quot;)) {
                txt = txt.replace(&quot;\n&quot;, &quot;&quot;);
                set(txt);
            }
        }
    };
    public final StringProperty promptTextProperty() { return promptText; }
    public final String getPromptText() { return promptText.get(); }
    public final void setPromptText(String value) { promptText.set(value); }


    /**
     * The property contains currently attached {@link TextFormatter}.
     * Since the value is part of the {@code Formatter}, changing the TextFormatter will update the text based on the new textFormatter.
     *
     * @defaultValue null
     * @since JavaFX 8u40
     */
    private final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatter = new ObjectPropertyBase&lt;TextFormatter&lt;?&gt;&gt;() {

        private TextFormatter&lt;?&gt; oldFormatter = null;

        @Override
        public Object getBean() {
            return TextInputControl.this;
        }

        @Override
        public String getName() {
            return &quot;textFormatter&quot;;
        }

        @Override
        protected void invalidated() {
            final TextFormatter&lt;?&gt; formatter = get();
            try {
                if (formatter != null) {
                    try {
                        formatter.bindToControl(f -&gt; updateText(f));
                    } catch (IllegalStateException e) {
                        if (isBound()) {
                            unbind();
                        }
                        set(null);
                        throw e;
                    }
                    if (!isFocused()) {
                        updateText(get());
                    }
                }

                if (oldFormatter != null) {
                    oldFormatter.unbindFromControl();
                }
            } finally {
                oldFormatter = formatter;
            }
        }
    };
    public final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatterProperty() { return textFormatter; }
    public final TextFormatter&lt;?&gt; getTextFormatter() { return textFormatter.get(); }
    public final void setTextFormatter(TextFormatter&lt;?&gt; value) { textFormatter.set(value); }

    private final Content content;
    /**
     * Returns the text input's content model.
     * @return the text input's content model
     */
    protected final Content getContent() {
        return content;
    }

    /**
     * The textual content of this TextInputControl.
     */
    private TextProperty text = new TextProperty();
    public final String getText() { return text.get(); }
    public final void setText(String value) { text.set(value); }
    public final StringProperty textProperty() { return text; }

    /**
     * The number of characters in the text input.
     */
    private ReadOnlyIntegerWrapper length = new ReadOnlyIntegerWrapper(this, &quot;length&quot;);
    public final int getLength() { return length.get(); }
    public final ReadOnlyIntegerProperty lengthProperty() { return length.getReadOnlyProperty(); }

    /**
     * Indicates whether this TextInputControl can be edited by the user.
     */
    private BooleanProperty editable = new SimpleBooleanProperty(this, &quot;editable&quot;, true) {
        @Override protected void invalidated() {
            pseudoClassStateChanged(PSEUDO_CLASS_READONLY, ! get());
        }
    };
    public final boolean isEditable() { return editable.getValue(); }
    public final void setEditable(boolean value) { editable.setValue(value); }
    public final BooleanProperty editableProperty() { return editable; }

    /**
     * The current selection.
     */
    private ReadOnlyObjectWrapper&lt;IndexRange&gt; selection = new ReadOnlyObjectWrapper&lt;IndexRange&gt;(this, &quot;selection&quot;, new IndexRange(0, 0));
    public final IndexRange getSelection() { return selection.getValue(); }
    public final ReadOnlyObjectProperty&lt;IndexRange&gt; selectionProperty() { return selection.getReadOnlyProperty(); }

    /**
     * Defines the characters in the TextInputControl which are selected
     */
    private ReadOnlyStringWrapper selectedText = new ReadOnlyStringWrapper(this, &quot;selectedText&quot;);
    public final String getSelectedText() { return selectedText.get(); }
    public final ReadOnlyStringProperty selectedTextProperty() { return selectedText.getReadOnlyProperty(); }

    /**
     * The &lt;code&gt;anchor&lt;/code&gt; of the text selection.
     * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
     * range. Selection must always be specified in terms of begin &amp;lt;= end, but
     * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
     * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
     * the anchor might represent the lower or upper bound of the selection.
     */
    private ReadOnlyIntegerWrapper anchor = new ReadOnlyIntegerWrapper(this, &quot;anchor&quot;, 0);
    public final int getAnchor() { return anchor.get(); }
    public final ReadOnlyIntegerProperty anchorProperty() { return anchor.getReadOnlyProperty(); }

    /**
     * The current position of the caret within the text.
     * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
     * range. Selection must always be specified in terms of begin &amp;lt;= end, but
     * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
     * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
     * the caretPosition might represent the lower or upper bound of the selection.
     */
    private ReadOnlyIntegerWrapper caretPosition = new ReadOnlyIntegerWrapper(this, &quot;caretPosition&quot;, 0);
    public final int getCaretPosition() { return caretPosition.get(); }
    public final ReadOnlyIntegerProperty caretPositionProperty() { return caretPosition.getReadOnlyProperty(); }

    private UndoRedoChange undoChangeHead = new UndoRedoChange();
    private UndoRedoChange undoChange = undoChangeHead;
    private boolean createNewUndoRecord = false;

    /**
     * The property describes if it's currently possible to undo the latest change of the content that was done.
     * @defaultValue false
     * @since JavaFX 8u40
     */
    private final ReadOnlyBooleanWrapper undoable = new ReadOnlyBooleanWrapper(this, &quot;undoable&quot;, false);
    public final boolean isUndoable() { return undoable.get(); }
    public final ReadOnlyBooleanProperty undoableProperty() { return undoable.getReadOnlyProperty(); }


    /**
     * The property describes if it's currently possible to redo the latest change of the content that was undone.
     * @defaultValue false
     * @since JavaFX 8u40
     */
    private final ReadOnlyBooleanWrapper redoable = new ReadOnlyBooleanWrapper(this, &quot;redoable&quot;, false);
    public final boolean isRedoable() { return redoable.get(); }
    public final ReadOnlyBooleanProperty redoableProperty() { return redoable.getReadOnlyProperty(); }

    /***************************************************************************
     *                                                                         *
     * Methods                                                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns a subset of the text input's content.
     *
     * @param start must be a value between 0 and end - 1.
     * @param end must be less than or equal to the length
     * @return the subset of the text input's content
     */
    public String getText(int start, int end) {
        if (start &gt; end) {
            throw new IllegalArgumentException(&quot;The start must be &lt;= the end&quot;);
        }

        if (start &lt; 0
            || end &gt; getLength()) {
            throw new IndexOutOfBoundsException();
        }

        return getContent().get(start, end);
    }

    /**
     * Appends a sequence of characters to the content.
     *
     * @param text a non null String
     */
    public void appendText(String text) {
        insertText(getLength(), text);
    }

    /**
     * Inserts a sequence of characters into the content.
     *
     * @param index The location to insert the text.
     * @param text The text to insert.
     */
    public void insertText(int index, String text) {
        replaceText(index, index, text);
    }

    /**
     * Removes a range of characters from the content.
     *
     * @param range The range of text to delete. The range object must not be null.
     *
     * @see #deleteText(int, int)
     */
    public void deleteText(IndexRange range) {
        replaceText(range, &quot;&quot;);
    }

    /**
     * Removes a range of characters from the content.
     *
     * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
     * @param end The ending index in the range, exclusive. This is one-past the last character to
     *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
     *            and &amp;lt;= the length of the text.
     */
    public void deleteText(int start, int end) {
        replaceText(start, end, &quot;&quot;);
    }

    /**
     * Replaces a range of characters with the given text.
     *
     * @param range The range of text to replace. The range object must not be null.
     * @param text The text that is to replace the range. This must not be null.
     *
     * @see #replaceText(int, int, String)
     */
    public void replaceText(IndexRange range, String text) {
        final int start = range.getStart();
        final int end = start + range.getLength();
        replaceText(start, end, text);
    }

    /**
     * Replaces a range of characters with the given text.
     *
     * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
     * @param end The ending index in the range, exclusive. This is one-past the last character to
     *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
     *            and &amp;lt;= the length of the text.
     * @param text The text that is to replace the range. This must not be null.
     */
    public void replaceText(final int start, final int end, final String text) {
        if (start &gt; end) {
            throw new IllegalArgumentException();
        }

        if (text == null) {
            throw new NullPointerException();
        }

        if (start &lt; 0
            || end &gt; getLength()) {
            throw new IndexOutOfBoundsException();
        }

        if (!this.text.isBound()) {
            final int oldLength = getLength();
            TextFormatter&lt;?&gt; formatter = getTextFormatter();
            TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, text);
            if (formatter != null &amp;&amp; formatter.getFilter() != null) {
                change = formatter.getFilter().apply(change);
                if (change == null) {
                    return;
                }
            }

            // Update the content
            updateContent(change, oldLength == 0);

        }
    }

    private void updateContent(TextFormatter.Change change, boolean forceNewUndoRecord) {
        final boolean nonEmptySelection = getSelection().getLength() &gt; 0;
        String oldText = getText(change.start, change.end);
        int adjustmentAmount = replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
        String newText = getText(change.start, change.start + change.text.length() - adjustmentAmount);
        if (newText.equals(oldText)) {
            // Undo record not required as there is no change in the text.
            return;
        }

        /*
         * A new undo record is created, if
         * 1. createNewUndoRecord is true, currently it is set to true for paste operation
         * 2. Text is selected and a character is typed
         * 3. This is the first operation to be added to undo record
         * 4. forceNewUndoRecord is true, currently it is set to true if there is no text present
         * 5. Space character is typed
         * 6. 2500 milliseconds are elapsed since the undo record was created
         * 7. Cursor position is changed and a character is typed
         * 8. A range of text is replaced programmatically using replaceText()
         * Otherwise, the last undo record is updated or discarded.
         */

        int endOfUndoChange = undoChange == undoChangeHead ? -1 : undoChange.start + undoChange.newText.length();
        boolean isNewSpaceChar = false;
        if (newText.equals(&quot; &quot;)) {
            if (!UndoRedoChange.isSpaceCharSequence()) {
                isNewSpaceChar = true;
                UndoRedoChange.setSpaceCharSequence(true);
            }
        } else {
            UndoRedoChange.setSpaceCharSequence(false);
        }
        if (createNewUndoRecord || nonEmptySelection || endOfUndoChange == -1 || forceNewUndoRecord ||
                isNewSpaceChar || UndoRedoChange.hasChangeDurationElapsed() ||
                (endOfUndoChange != change.start &amp;&amp; endOfUndoChange != change.end) || change.end - change.start &gt; 0) {
            undoChange = undoChange.add(change.start, oldText, newText);
        } else if (change.start != change.end &amp;&amp; change.text.isEmpty()) {
            // I know I am deleting, and am located at the end of the range of the current undo record
            if (undoChange.newText.length() &gt; 0) {
                undoChange.newText = undoChange.newText.substring(0, change.start - undoChange.start);
                if (undoChange.newText.isEmpty()) {
                    // throw away this undo change record
                    undoChange = undoChange.discard();
                }
            } else {
                if (change.start == endOfUndoChange) {
                    undoChange.oldText += oldText;
                } else { // end == endOfUndoChange
                    undoChange.oldText = oldText + undoChange.oldText;
                    undoChange.start--;
                }
            }
        } else {
            // I know I am adding, and am located at the end of the range of the current undo record
            undoChange.newText += newText;
        }
        updateUndoRedoState();
    }

    /**
     * Transfers the currently selected range in the text to the clipboard,
     * removing the current selection.
     */
    public void cut() {
        copy();
        IndexRange selection = getSelection();
        deleteText(selection.getStart(), selection.getEnd());
    }

    /**
     * Transfers the currently selected range in the text to the clipboard,
     * leaving the current selection.
     */
     public void copy() {
        final String selectedText = getSelectedText();
        if (selectedText.length() &gt; 0) {
            final ClipboardContent content = new ClipboardContent();
            content.putString(selectedText);
            Clipboard.getSystemClipboard().setContent(content);
        }
    }

    /**
     * Transfers the contents in the clipboard into this text,
     * replacing the current selection.  If there is no selection, the contents
     * in the clipboard is inserted at the current caret position.
     */
    public void paste() {
        final Clipboard clipboard = Clipboard.getSystemClipboard();
        if (clipboard.hasString()) {
            final String text = clipboard.getString();
            if (text != null) {
                createNewUndoRecord = true;
                try {
                    replaceSelection(text);
                } finally {
                    createNewUndoRecord = false;
                }
            }
        }
    }

    /**
     * Moves the selection backward one char in the text. This may have the
     * effect of deselecting, depending on the location of the anchor relative
     * to the caretPosition. This function effectively just moves the caretPosition.
     */
    public void selectBackward() {
        if (getCaretPosition() &gt; 0 &amp;&amp; getLength() &gt; 0) {
            // because the anchor stays put, by moving the caret to the left
            // we ensure that a selection is registered and that it is correct
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            selectRange(getAnchor(), charIterator.preceding(getCaretPosition()));
        }
    }

    /**
     * Moves the selection forward one char in the text. This may have the
     * effect of deselecting, depending on the location of the anchor relative
     * to the caretPosition. This function effectively just moves the caret forward.
     */
    public void selectForward() {
        final int textLength = getLength();
        if (textLength &gt; 0 &amp;&amp; getCaretPosition() &lt; textLength) {
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            selectRange(getAnchor(), charIterator.following(getCaretPosition()));
        }
    }

    /**
     * The break iterator instances for navigation over words and complex characters.
     */
    private BreakIterator charIterator;
    private BreakIterator wordIterator;

    /**
     * Moves the caret to the beginning of previous word. This function
<A NAME="21"></A>     * also has the effect of clearing the selection.
     */
    public void previousWord() {
        <FONT color="#00ff00"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#21',2,'match37-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>previousWord(false);
    }

    /**
     * Moves the caret to the beginning of next word. This function
     * also has the effect of clearing the selection.
     */
    public void nextWord() {
        nextWord(false);
    }

    /**
     * Moves the caret to the end of the next word. This function
     * also has the effect of clearing the selection.
     */
    public void endOfNextWord() {
        endOfNextWord(false);
    }

    /**
     * Moves the caret to the beginning of previous word. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
     * moved to the beginning of previous word.
     */
    public void selectPreviousWord() {
        previousWord(true);
    }

    /**
     * Moves the caret to the beginning of next word. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
     * moved to the beginning of next word.
     */
    public void selectNextWord() {</B></FONT>
        nextWord(true);
    }

    /**
     * Moves the caret to the end of the next word. This does not cause
     * the selection to be cleared.
     */
    public void selectEndOfNextWord() {
        endOfNextWord(true);
    }

    private void previousWord(boolean select) {
        final int textLength = getLength();
        final String text = getText();
        if (textLength &lt;= 0) {
            return;
        }

        if (wordIterator == null) {
            wordIterator = BreakIterator.getWordInstance();
        }
        wordIterator.setText(text);

        int pos = wordIterator.preceding(Utils.clamp(0, getCaretPosition(), textLength));

        // Skip the non-word region, then move/select to the beginning of the word.
        while (pos != BreakIterator.DONE &amp;&amp;
               !Character.isLetterOrDigit(text.charAt(Utils.clamp(0, pos, textLength-1)))) {
            pos = wordIterator.preceding(Utils.clamp(0, pos, textLength));
        }

        // move/select
        selectRange(select ? getAnchor() : pos, pos);
    }

    private void nextWord(boolean select) {
        final int textLength = getLength();
        final String text = getText();
        if (textLength &lt;= 0) {
            return;
        }

        if (wordIterator == null) {
            wordIterator = BreakIterator.getWordInstance();
        }
        wordIterator.setText(text);

        int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength-1));
        int current = wordIterator.next();

        // Skip whitespace characters to the beginning of next word, but
        // stop at newline. Then move the caret or select a range.
        while (current != BreakIterator.DONE) {
            for (int p=last; p&lt;=current; p++) {
                char ch = text.charAt(Utils.clamp(0, p, textLength-1));
                // Avoid using Character.isSpaceChar() and Character.isWhitespace(),
                // because they include LINE_SEPARATOR, PARAGRAPH_SEPARATOR, etc.
                if (ch != ' ' &amp;&amp; ch != '\t') {
                    if (select) {
                        selectRange(getAnchor(), p);
                    } else {
                        selectRange(p, p);
                    }
                    return;
                }
            }
            last = current;
            current = wordIterator.next();
        }

        // move/select to the end
        if (select) {
            selectRange(getAnchor(), textLength);
        } else {
            end();
        }
    }

    private void endOfNextWord(boolean select) {
        final int textLength = getLength();
        final String text = getText();
        if (textLength &lt;= 0) {
            return;
        }

        if (wordIterator == null) {
            wordIterator = BreakIterator.getWordInstance();
        }
        wordIterator.setText(text);

        int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength));
        int current = wordIterator.next();

        // skip the non-word region, then move/select to the end of the word.
        while (current != BreakIterator.DONE) {
            for (int p=last; p&lt;=current; p++) {
                if (!Character.isLetterOrDigit(text.charAt(Utils.clamp(0, p, textLength-1)))) {
                    if (select) {
                        selectRange(getAnchor(), p);
                    } else {
                        selectRange(p, p);
                    }
                    return;
                }
            }
            last = current;
            current = wordIterator.next();
        }

        // move/select to the end
        if (select) {
            selectRange(getAnchor(), textLength);
        } else {
            end();
        }
    }

    /**
     * Selects all text in the text input.
     */
    public void selectAll() {
        selectRange(0, getLength());
    }

    /**
     * Moves the caret to before the first char of the text. This function
     * also has the effect of clearing the selection.
     */
    public void home() {
        // user wants to go to start
        selectRange(0, 0);
    }

    /**
     * Moves the caret to after the last char of the text. This function
     * also has the effect of clearing the selection.
     */
    public void end() {
        // user wants to go to end
        final int textLength = getLength();
        if (textLength &gt; 0) {
            selectRange(textLength, textLength);
        }
    }

    /**
     * Moves the caret to before the first char of text. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the
     * caretPosition is moved to before the first char.
     */
    public void selectHome() {
        selectRange(getAnchor(), 0);
    }

    /**
     * Moves the caret to after the last char of text. This does not cause
     * the selection to be cleared. Rather, the anchor stays put and the
     * caretPosition is moved to after the last char.
     */
    public void selectEnd() {
        final int textLength = getLength();
        if (textLength &gt; 0) selectRange(getAnchor(), textLength);
    }

    /**
     * Deletes the character that precedes the current caret position from the
     * text if there is no selection, or deletes the selection if there is one.
     * This function returns true if the deletion succeeded, false otherwise.
     * @return true if the deletion succeeded, false otherwise
     */
    public boolean deletePreviousChar() {
        boolean failed = true;
        if (isEditable() &amp;&amp; !isDisabled()) {
            final String text = getText();
            final int dot = getCaretPosition();
            final int mark = getAnchor();
            if (dot != mark) {
                // there is a selection of text to remove
                replaceSelection(&quot;&quot;);
                failed = false;
            } else if (dot &gt; 0) {
                // The caret is not at the beginning, so remove some characters.
                // Typically you'd only be removing a single character, but
                // in some cases you must remove two depending on the unicode
                // characters
                // Note: Do not use charIterator here, because we do want to
                // break up clusters when deleting backwards.
                int p = Character.offsetByCodePoints(text, dot, -1);
                deleteText(p, dot);
                failed = false;
            }
        }
        return !failed;
    }

    /**
     * Deletes the character that follows the current caret position from the
     * text if there is no selection, or deletes the selection if there is one.
     * This function returns true if the deletion succeeded, false otherwise.
     * @return true if the deletion succeeded, false otherwise
     */
    public boolean deleteNextChar() {
        boolean failed = true;
        if (isEditable() &amp;&amp; !isDisabled()) {
            final int textLength = getLength();
            final String text = getText();
            final int dot = getCaretPosition();
            final int mark = getAnchor();
            if (dot != mark) {
                // there is a selection of text to remove
                replaceSelection(&quot;&quot;);
                failed = false;
            } else if (textLength &gt; 0 &amp;&amp; dot &lt; textLength) {
                // The caret is not at the end, so remove some characters.
                // Typically you'd only be removing a single character, but
                // in some cases you must remove two depending on the unicode
                // characters
                if (charIterator == null) {
                    charIterator = BreakIterator.getCharacterInstance();
                }
                charIterator.setText(text);
                int p = charIterator.following(dot);
                deleteText(dot, p);
                failed = false;
            }
        }
        return !failed;
    }

    /**
     * Moves the caret position forward. If there is no selection, then the
     * caret position is moved one character forward. If there is a selection,
     * then the caret position is moved to the end of the selection and
     * the selection cleared.
     */
    public void forward() {
        // user has moved caret to the right
        final int textLength = getLength();
        final int dot = getCaretPosition();
        final int mark = getAnchor();
        if (dot != mark) {
            int pos = Math.max(dot, mark);
            selectRange(pos, pos);
        } else if (dot &lt; textLength &amp;&amp; textLength &gt; 0) {
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            int pos = charIterator.following(dot);
            selectRange(pos, pos);
        }
        deselect();
    }

    /**
     * Moves the caret position backward. If there is no selection, then the
     * caret position is moved one character backward. If there is a selection,
     * then the caret position is moved to the beginning of the selection and
     * the selection cleared.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins or Behaviors. It is not common
     *       for developers or designers to access this function directly.
     */
    public void backward() {
        // user has moved caret to the left
        final int textLength = getLength();
        final int dot = getCaretPosition();
        final int mark = getAnchor();
        if (dot != mark) {
            int pos = Math.min(dot, mark);
            selectRange(pos, pos);
        } else if (dot &gt; 0 &amp;&amp; textLength &gt; 0) {
            if (charIterator == null) {
                charIterator = BreakIterator.getCharacterInstance();
            }
            charIterator.setText(getText());
            int pos = charIterator.preceding(dot);
            selectRange(pos, pos);
        }
        deselect();
    }

    /**
     * Positions the caret to the position indicated by {@code pos}. This
     * function will also clear the selection.
     * @param pos the position
     */
    public void positionCaret(int pos) {
        final int p = Utils.clamp(0, pos, getLength());
        selectRange(p, p);
    }

    /**
     * Positions the caret to the position indicated by {@code pos} and extends
     * the selection, if there is one. If there is no selection, then a
     * selection is formed where the anchor is at the current caret position
     * and the caretPosition is moved to pos.
     * @param pos the position
     */
    public void selectPositionCaret(int pos) {
        selectRange(getAnchor(), Utils.clamp(0, pos, getLength()));
    }

    /**
     * Positions the anchor and caretPosition explicitly.
     * @param anchor the anchor
     * @param caretPosition the caretPosition
     */
    public void selectRange(int anchor, int caretPosition) {
        caretPosition = Utils.clamp(0, caretPosition, getLength());
        anchor = Utils.clamp(0, anchor, getLength());

        TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), anchor, caretPosition);
        TextFormatter&lt;?&gt; formatter = getTextFormatter();
        if (formatter != null &amp;&amp; formatter.getFilter() != null) {
            change = formatter.getFilter().apply(change);
            if (change == null) {
                return;
            }
        }

        updateContent(change, false);
    }

    private void doSelectRange(int anchor, int caretPosition) {
        this.caretPosition.set(Utils.clamp(0, caretPosition, getLength()));
        this.anchor.set(Utils.clamp(0, anchor, getLength()));
        this.selection.set(IndexRange.normalize(getAnchor(), getCaretPosition()));
        notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_START);
    }

    /**
     * This function will extend the selection to include the specified pos.
     * This is different from selectPositionCaret in that it does not simply
     * move the caret. Rather, it will reposition the caret and anchor as necessary
     * to ensure that pos becomes the new caret and the far other end of the
     * selection becomes the anchor.
     * @param pos the position
     */
    public void extendSelection(int pos) {
        final int p = Utils.clamp(0, pos, getLength());
        final int dot = getCaretPosition();
        final int mark = getAnchor();
        int start = Math.min(dot, mark);
        int end = Math.max(dot, mark);
        if (p &lt; start) {
            selectRange(end, p);
        } else {
            selectRange(start, p);
        }
    }

    /**
     * Clears the text.
     */
    public void clear() {
        deselect();
        if (!text.isBound()) {
            setText(&quot;&quot;);
        }
    }

    /**
     * Clears the selection.
     */
    public void deselect() {
        // set the anchor equal to the caret position, which clears the selection
        // while also preserving the caret position
        selectRange(getCaretPosition(), getCaretPosition());
    }

    /**
     * Replaces the selection with the given replacement String. If there is
     * no selection, then the replacement text is simply inserted at the current
     * caret position. If there was a selection, then the selection is cleared
     * and the given replacement text inserted.
     * @param replacement the replacement string
     */
    public void replaceSelection(String replacement) {
        replaceText(getSelection(), replacement);
    }

    /**
     * If possible, undoes the last modification. If {@link #isUndoable()} returns
     * false, then calling this method has no effect.
     * @since JavaFX 8u40
     */
    public final void undo() {
        if (isUndoable()) {
            // Apply reverse change here
            final int start = undoChange.start;
            final String newText = undoChange.newText;
            final String oldText = undoChange.oldText;

            if (newText != null) {
                getContent().delete(start, start + newText.length(), oldText.isEmpty());
            }

            if (oldText != null) {
                getContent().insert(start, oldText, true);
                doSelectRange(start, start + oldText.length());
            } else {
                doSelectRange(start, start + newText.length());
            }

            undoChange = undoChange.prev;
        }
        updateUndoRedoState();
    }

    /**
     * If possible, redoes the last undone modification. If {@link #isRedoable()} returns
     * false, then calling this method has no effect.
     * @since JavaFX 8u40
     */
    public final void redo() {
        if (isRedoable()) {
            // Apply change here
            undoChange = undoChange.next;
            final int start = undoChange.start;
            final String newText = undoChange.newText;
            final String oldText = undoChange.oldText;

            if (oldText != null) {
                getContent().delete(start, start + oldText.length(), newText.isEmpty());
            }

            if (newText != null) {
                getContent().insert(start, newText, true);
                doSelectRange(start + newText.length(), start + newText.length());
            } else {
                doSelectRange(start, start);
            }
        }
        updateUndoRedoState();
        // else beep ?
    }

    // Used by TextArea, although there are probably other better ways of
    // doing this.
    void textUpdated() { }

    private void resetUndoRedoState() {
        undoChange = undoChangeHead;
        undoChange.next = null;
        updateUndoRedoState();
    }

    private void updateUndoRedoState() {
        undoable.set(undoChange != undoChangeHead);
        redoable.set(undoChange.next != null);
    }

    private boolean filterAndSet(String value) {
        // Send the new value through the textFormatter, if one exists.
        TextFormatter&lt;?&gt; formatter = getTextFormatter();
        int length = content.length();
        if (formatter != null &amp;&amp; formatter.getFilter() != null &amp;&amp; !text.isBound()) {
            TextFormatter.Change change = new TextFormatter.Change(
                    TextInputControl.this, getFormatterAccessor(), 0, length, value, 0, 0);
            change = formatter.getFilter().apply(change);
            if (change == null) {
                return false;
            }
            replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
        } else {
            replaceText(0, length, value, 0, 0);
        }
        return true;
    }

    /**
     * This is what is ultimately called by every code path that will update
     * the content (except for undo / redo). The input into this method has
     * already run through the textFormatter where appropriate.
     *
     * @param start            The start index into the existing text which
     *                         will be replaced by the new value
     * @param end              The end index into the existing text which will
     *                         be replaced by the new value. As with
     *                         String.replace this is a lastIndex+1 value
     * @param value            The new text value
     * @param anchor           The new selection anchor after the change is made
     * @param caretPosition    The new selection caretPosition after the change
     *                         is made.
     * @return The amount of adjustment made to the end / anchor / caretPosition to
     *         accommodate for subsequent filtering (such as the filtering of
     *         new lines by the TextField)
     */
    private int replaceText(int start, int end, String value, int anchor, int caretPosition) {
        // RT-16566: Need to take into account stripping of chars into the
        // final anchor &amp; caret position
        int length = getLength();
        int adjustmentAmount = 0;
        if (end != start) {
            getContent().delete(start, end, value.isEmpty());
            length -= (end - start);
        }
        if (value != null) {
            getContent().insert(start, value, true);
            adjustmentAmount = value.length() - (getLength() - length);
            anchor -= adjustmentAmount;
            caretPosition -= adjustmentAmount;
        }
        doSelectRange(anchor, caretPosition);
        return adjustmentAmount;
    }

    private &lt;T&gt; void updateText(TextFormatter&lt;T&gt; formatter) {
        T value = formatter.getValue();
        StringConverter&lt;T&gt; converter = formatter.getValueConverter();
        if (converter != null) {
            String text = converter.toString(value);
            if (text == null) text = &quot;&quot;;
            replaceText(0, getLength(), text, text.length(), text.length());
        }
    }

    /**
     * Commit the current text and convert it to a value.
     * @since JavaFX 8u40
     */
    public final void commitValue() {
        if (getTextFormatter() != null) {
            getTextFormatter().updateValue(getText());
        }
    }

    /**
     * If the field is currently being edited, this call will set text to the last commited value.
     * @since JavaFX 8u40
     */
    public final void cancelEdit() {
        if (getTextFormatter() != null) {
            updateText(getTextFormatter());
        }
    }

    private FormatterAccessor accessor;

    private FormatterAccessor getFormatterAccessor() {
        if (accessor == null) {
            accessor = new TextInputControlFromatterAccessor();
        }
        return accessor;
    }


    /**
     * A little utility method for stripping out unwanted characters.
     *
     * @param txt
     * @param stripNewlines
     * @param stripTabs
     * @return The string after having the unwanted characters stripped out.
     */
    static String filterInput(String txt, boolean stripNewlines, boolean stripTabs) {
        // Most of the time, when text is inserted, there are no illegal
        // characters. So we'll do a &quot;cheap&quot; check for illegal characters.
        // If we find one, we'll do a longer replace algorithm. In the
        // case of illegal characters, this may at worst be an O(2n) solution.
        // Strip out any characters that are outside the printed range
        if (containsInvalidCharacters(txt, stripNewlines, stripTabs)) {
            StringBuilder s = new StringBuilder(txt.length());
            for (int i=0; i&lt;txt.length(); i++) {
                final char c = txt.charAt(i);
                if (!isInvalidCharacter(c, stripNewlines, stripTabs)) {
                    s.append(c);
                }
            }
            txt = s.toString();
        }
        return txt;
    }

    static boolean containsInvalidCharacters(String txt, boolean newlineIllegal, boolean tabIllegal) {
        for (int i=0; i&lt;txt.length(); i++) {
            final char c = txt.charAt(i);
            if (isInvalidCharacter(c, newlineIllegal, tabIllegal)) return true;
        }
        return false;
    }

    private static boolean isInvalidCharacter(char c, boolean newlineIllegal, boolean tabIllegal) {
        if (c == 0x7F) return true;
        if (c == 0xA) return newlineIllegal;
        if (c == 0x9) return tabIllegal;
        if (c &lt; 0x20) return true;
        return false;
    }

    // It can be bound, in which case we will force it to be an eager
    // binding so that we update the content eagerly
    // It can be bidirectionally bound, which basically will just work
    // If somebody changes the content directly, it will be notified and
    // send an invalidation event.
    private class TextProperty extends StringProperty {
        // This is used only when the property is bound
        private ObservableValue&lt;? extends String&gt; observable = null;
        // Added to the observable when bound
        private InvalidationListener listener = null;
        // Used for event handling
        private ExpressionHelper&lt;String&gt; helper = null;
        // The developer my set the Text property to null. Although
        // the Content must be given an empty String, we must still
        // treat the value as though it were null, so that a subsequent
        // getText() will return null.
        private boolean textIsNull = false;

        @Override public String get() {
            // Since we force eager binding and content is always up to date,
            // we just need to get it from content and not through the binding
            return textIsNull ? null : content.get();
        }

        @Override public void set(String value) {
            if (isBound()) {
                throw new java.lang.RuntimeException(&quot;A bound value cannot be set.&quot;);
            }
            doSet(value);
            markInvalid();
        }

        /**
         * Called whenever the content on the control has changed (as determined
         * by a listener on the content).
         */
        private void controlContentHasChanged() {
            markInvalid();
            notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);
        }

        @Override public void bind(ObservableValue&lt;? extends String&gt; observable) {
            if (observable == null) {
                throw new NullPointerException(&quot;Cannot bind to null&quot;);
            }
            if (!observable.equals(this.observable)) {
                unbind();
                this.observable = observable;
                if (listener == null) {
                    listener = new Listener();
                }
                this.observable.addListener(listener);
                markInvalid();
                doSet(observable.getValue());
            }
        }

        @Override public void unbind() {
            if (observable != null) {
                doSet(observable.getValue());
                observable.removeListener(listener);
                observable = null;
            }
        }

        @Override public boolean isBound() {
            return observable != null;
        }

        @Override public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override public void addListener(ChangeListener&lt;? super String&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override public void removeListener(ChangeListener&lt;? super String&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override public Object getBean() {
            return TextInputControl.this;
        }

        @Override public String getName() {
            return &quot;text&quot;;
        }

        private void fireValueChangedEvent() {
            ExpressionHelper.fireValueChangedEvent(helper);
        }

        private void markInvalid() {
            fireValueChangedEvent();
        }

        /**
         * doSet is called whenever the setText() method was called directly
         * on the TextInputControl, or when the text property was bound,
         * unbound, or reacted to a binding invalidation. It is *not* called
         * when modifications to the content happened indirectly, such as
         * through the replaceText / replaceSelection methods.
         *
         * @param value The new value
         */
        private void doSet(String value) {
            // Guard against the null value.
            textIsNull = value == null;
            if (value == null) value = &quot;&quot;;

            if (!filterAndSet(value)) return;

            if (getTextFormatter() != null) {
                getTextFormatter().updateValue(getText());
            }

            textUpdated();

            // If the programmer has directly manipulated the text property
            // or has it bound up, then we will clear out any modifications
            // from the undo manager as we must suppose that the control is
            // being reused, for example, between forms.
            resetUndoRedoState();
        }

        private class Listener implements InvalidationListener {
            @Override
            public void invalidated(Observable valueModel) {
                // We now need to force it to be eagerly recomputed
                // because we need to push these changes to the
                // content model. Because changing the model ends
                // up calling invalidate and markInvalid, the
                // listeners will all be notified.
                doSet(observable.getValue());
            }
        }
    }

    /**
     * Used to form a linked-list of Undo / Redo changes. Each UndoRedoChange
     * records the old and new text, and the start index. It also has
     * the links to the previous and next Changes in the chain. There
     * are two special UndoRedoChange objects in this chain representing the
     * head and the tail so we can have beforeFirst and afterLast
     * behavior as necessary.
     */
    static class UndoRedoChange {
        static long prevRecordTime;
        static final long CHANGE_DURATION = 2500; // milliseconds
        static boolean spaceCharSequence = false;
        int start;
        String oldText;
        String newText;
        UndoRedoChange prev;
        UndoRedoChange next;

        UndoRedoChange() { }

        public UndoRedoChange add(int start, String oldText, String newText) {
            UndoRedoChange c = new UndoRedoChange();
            c.start = start;
            c.oldText = oldText;
            c.newText = newText;
            c.prev = this;
            next = c;
            prevRecordTime = System.currentTimeMillis();
            return c;
        }

        static boolean hasChangeDurationElapsed() {
            return (System.currentTimeMillis() - prevRecordTime &gt; CHANGE_DURATION) ;
        }

        static void setSpaceCharSequence(boolean value) {
            spaceCharSequence = value;
        }
        static boolean isSpaceCharSequence() {
            return spaceCharSequence;
        }

        public UndoRedoChange discard() {
            prev.next = next;
            return prev;
        }

        // Handy to use when debugging, just put it in undo or redo
        // method or replaceText to see what is happening to the undo
        // history as it occurs.
        void debugPrint() {
            UndoRedoChange c = this;
            System.out.print(&quot;[&quot;);
            while (c != null) {
                System.out.print(c.toString());
                if (c.next != null) System.out.print(&quot;, &quot;);
                c = c.next;
            }
            System.out.println(&quot;]&quot;);
        }

        @Override public String toString() {
            if (oldText == null &amp;&amp; newText == null) {
                return &quot;head&quot;;
            }
            if (oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
                return &quot;added '&quot; + newText + &quot;' at index &quot; + start;
            } else if (!oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
                return &quot;replaced '&quot; + oldText + &quot;' with '&quot; + newText + &quot;' at index &quot; + start;
            } else {
                return &quot;deleted '&quot; + oldText + &quot;' at index &quot; + start;
            }
        }
    }

    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/


    private static final PseudoClass PSEUDO_CLASS_READONLY
            = PseudoClass.getPseudoClass(&quot;readonly&quot;);

    private static class StyleableProperties {
        private static final FontCssMetaData&lt;TextInputControl&gt; FONT =
            new FontCssMetaData&lt;TextInputControl&gt;(&quot;-fx-font&quot;, Font.getDefault()) {

            @Override
            public boolean isSettable(TextInputControl n) {
                return n.font == null || !n.font.isBound();
            }

            @Override
            public StyleableProperty&lt;Font&gt; getStyleableProperty(TextInputControl n) {
                return (StyleableProperty&lt;Font&gt;)(WritableValue&lt;Font&gt;)n.fontProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
            styleables.add(FONT);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
        return getClassCssMetaData();
    }


    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case TEXT: {
                String accText = getAccessibleText();
                if (accText != null &amp;&amp; !accText.isEmpty()) return accText;

                String text = getText();
                if (text == null || text.isEmpty()) {
                    text = getPromptText();
                }
                return text;
            }
            case EDITABLE: return isEditable();
            case SELECTION_START: return getSelection().getStart();
            case SELECTION_END: return getSelection().getEnd();
            case CARET_OFFSET: return getCaretPosition();
            case FONT: return getFont();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case SET_TEXT: {
                String value = (String) parameters[0];
                if (value != null) setText(value);
                break;
            }
            case SET_TEXT_SELECTION: {
                Integer start = (Integer) parameters[0];
                Integer end = (Integer) parameters[1];
                if (start != null &amp;&amp; end != null) {
                    selectRange(start,  end);
                }
                break;
            }
            default: super.executeAccessibleAction(action, parameters);
        }
    }

    private class TextInputControlFromatterAccessor implements FormatterAccessor {
        @Override
        public int getTextLength() {
            return TextInputControl.this.getLength();
        }

        @Override
        public String getText(int begin, int end) {
            return TextInputControl.this.getText(begin, end);
        }

        @Override
        public int getCaret() {
            return TextInputControl.this.getCaretPosition();
        }

        @Override
        public int getAnchor() {
            return TextInputControl.this.getAnchor();
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TreeTableView.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import com.sun.javafx.collections.MappingChange;
import com.sun.javafx.collections.NonIterableChange;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.SelectedCellsMap;

import com.sun.javafx.scene.control.behavior.TableCellBehavior;
import com.sun.javafx.scene.control.behavior.TableCellBehaviorBase;
import com.sun.javafx.scene.control.behavior.TreeTableCellBehavior;
import javafx.beans.property.DoubleProperty;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;

import javafx.css.converter.SizeConverter;
import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
import com.sun.javafx.scene.control.TableColumnComparatorBase;

import javafx.css.Styleable;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableProperty;
import javafx.event.WeakEventHandler;

import javafx.scene.control.skin.TreeTableViewSkin;

import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;

import javafx.application.Platform;
import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyIntegerProperty;
import javafx.beans.property.ReadOnlyIntegerWrapper;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.WeakChangeListener;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.MapChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.layout.Region;
import javafx.util.Callback;

/**
 * The TreeTableView control is designed to visualize an unlimited number of rows
 * of data, broken out into columns. The TreeTableView control is conceptually
 * very similar to the {@link TreeView} and {@link TableView} controls,
 * and as you read on you'll come to see the APIs are largely the same.
 * However, to give a high-level overview, you'll note that the TreeTableView
 * uses the same {@link TreeItem} API as {@link TreeView},
 * and that you therefore are required to simply set the
 * {@link #rootProperty() root node} in the TreeTableView. Similarly, the
 * TreeTableView control makes use of the same TableColumn-based approach that
 * the {@link TableView} control uses, except instead of using the
 * TableView-specific {@link TableColumn} class, you should instead use the
 * TreeTableView-specific {@link TreeTableColumn} class instead. For an
 * example on how to create a TreeTableView instance, refer to the 'Creating a
 * TreeTableView' control section below.
 *
 * &lt;p&gt;As with the {@link TableView} control, the TreeTableView control has a
 * number of features, including:
 * &lt;ul&gt;
 * &lt;li&gt;Powerful {@link TreeTableColumn} API:
 *   &lt;ul&gt;
 *   &lt;li&gt;Support for {@link TreeTableColumn#cellFactoryProperty() cell factories} to
 *      easily customize {@link Cell cell} contents in both rendering and editing
 *      states.
 *   &lt;li&gt;Specification of {@link TreeTableColumn#minWidthProperty() minWidth}/
 *      {@link TreeTableColumn#prefWidthProperty() prefWidth}/
 *      {@link TreeTableColumn#maxWidthProperty() maxWidth},
 *      and also {@link TreeTableColumn#resizableProperty() fixed width columns}.
 *   &lt;li&gt;Width resizing by the user at runtime.
 *   &lt;li&gt;Column reordering by the user at runtime.
 *   &lt;li&gt;Built-in support for {@link TreeTableColumn#getColumns() column nesting}
 *   &lt;/ul&gt;
 * &lt;li&gt;Different {@link #columnResizePolicyProperty() resizing policies} to
 *      dictate what happens when the user resizes columns.
 * &lt;li&gt;Support for {@link #getSortOrder() multiple column sorting} by clicking
 *      the column header (hold down Shift keyboard key whilst clicking on a
 *      header to sort by multiple columns).
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Creating a TreeTableView&lt;/h2&gt;
 *
 * &lt;p&gt;Creating a TreeTableView is a multi-step process, and also depends on the
 * underlying data model needing to be represented. For this example we'll use
 * the TreeTableView to visualise a file system, and will therefore make use
 * of an imaginary (and vastly simplified) File class as defined below:
 *
 * &lt;pre&gt;{@code
 * public class File {
 *     private StringProperty name;
 *     public void setName(String value) { nameProperty().set(value); }
 *     public String getName() { return nameProperty().get(); }
 *     public StringProperty nameProperty() {
 *         if (name == null) name = new SimpleStringProperty(this, &quot;name&quot;);
 *         return name;
 *     }
 *
 *     private LongProperty lastModified;
 *     public void setLastModified(long value) { lastModifiedProperty().set(value); }
 *     public long getLastModified() { return lastModifiedProperty().get(); }
 *     public LongProperty lastModifiedProperty() {
 *         if (lastModified == null) lastModified = new SimpleLongProperty(this, &quot;lastModified&quot;);
 *         return lastModified;
 *     }
 * }}&lt;/pre&gt;
 *
 * &lt;p&gt;Firstly, a TreeTableView instance needs to be defined, as such:
 *
 * &lt;pre&gt;{@code
 * TreeTableView&lt;File&gt; treeTable = new TreeTableView&lt;&gt;();}&lt;/pre&gt;
 *
 * &lt;p&gt;With the basic TreeTableView instantiated, we next focus on the data model.
 * As mentioned, for this example, we'll be representing a file system using File
 * instances. To do this, we need to define the root node of the tree table, as such:
 *
 * &lt;pre&gt;{@code
 * TreeItem&lt;File&gt; root = new TreeItem&lt;&gt;(new File(&quot;/&quot;));
 * treeTable.setRoot(root);}&lt;/pre&gt;
 *
 * &lt;p&gt;With the root set as such, the TreeTableView will automatically update whenever
 * the {@link TreeItem#getChildren() children} of the root changes.
 *
 * &lt;p&gt;At this point we now have a TreeTableView hooked up to observe the root
 * TreeItem instance. The missing ingredient
 * now is the means of splitting out the data contained within the model and
 * representing it in one or more {@link TreeTableColumn} instances. To
 * create a two-column TreeTableView to show the file name and last modified
 * properties, we extend the code shown above as follows:
 *
 * &lt;pre&gt;{@code
 * TreeTableColumns&lt;File,String&gt; fileNameCol = new TreeTableColumn&lt;&gt;(&quot;Filename&quot;);
 * TreeTableColumns&lt;File,Long&gt; lastModifiedCol = new TreeTableColumn&lt;&gt;(&quot;Size&quot;);
 *
 * table.getColumns().setAll(fileNameCol, lastModifiedCol);}&lt;/pre&gt;
 *
 * &lt;p&gt;With the code shown above we have nearly fully defined the minimum properties
 * required to create a TreeTableView instance. The only thing missing is the
 * {@link javafx.scene.control.TreeTableColumn#cellValueFactoryProperty() cell value factories}
 * for the two columns - it is these that are responsible for determining the value
 * of a cell in a given row. Commonly these can be specified using the
 * {@link javafx.scene.control.cell.TreeItemPropertyValueFactory} class, but
 * failing that you can also create an anonymous inner class and do whatever is
 * necessary. For example, using {@link javafx.scene.control.cell.TreeItemPropertyValueFactory}
 * you would do the following:
 *
 * &lt;pre&gt;{@code
 * fileNameCol.setCellValueFactory(new TreeItemPropertyValueFactory(&quot;name&quot;));
 * lastModifiedCol.setCellValueFactory(new TreeItemPropertyValueFactory(&quot;lastModified&quot;));}&lt;/pre&gt;
 *
 * Running this code (assuming the file system structure is probably built up in
 * memory) will result in a TreeTableView being shown with two columns for name
 * and lastModified. Any other properties of the File class will not be shown, as
 * no TreeTableColumns are defined for them.
 *
 * &lt;h3&gt;TreeTableView support for classes that don't contain properties&lt;/h3&gt;
 *
 * &lt;p&gt;The code shown above is the shortest possible code for creating a TreeTableView
 * when the domain objects are designed with JavaFX properties in mind
 * (additionally, {@link javafx.scene.control.cell.TreeItemPropertyValueFactory} supports
 * normal JavaBean properties too, although there is a caveat to this, so refer
 * to the class documentation for more information). When this is not the case,
 * it is necessary to provide a custom cell value factory. More information
 * about cell value factories can be found in the {@link TreeTableColumn} API
 * documentation, but briefly, here is how a TreeTableColumns could be specified:
 *
 * &lt;pre&gt;{@code
 * firstNameCol.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;Person, String&gt;, ObservableValue&lt;String&gt;&gt;() {
 *     public ObservableValue&lt;String&gt; call(CellDataFeatures&lt;Person, String&gt; p) {
 *         // p.getValue() returns the TreeItem&lt;Person&gt; instance for a particular TreeTableView row,
 *         // p.getValue().getValue() returns the Person instance inside the TreeItem&lt;Person&gt;
 *         return p.getValue().getValue().firstNameProperty();
 *     }
 *  });
 * }}&lt;/pre&gt;
 *
 * &lt;h3&gt;TreeTableView Selection / Focus APIs&lt;/h3&gt;
 * &lt;p&gt;To track selection and focus, it is necessary to become familiar with the
 * {@link SelectionModel} and {@link FocusModel} classes. A TreeTableView has at most
 * one instance of each of these classes, available from
 * {@link #selectionModelProperty() selectionModel} and
 * {@link #focusModelProperty() focusModel} properties, respectively.
 * Whilst it is possible to use this API to set a new selection model, in
 * most circumstances this is not necessary - the default selection and focus
 * models should work in most circumstances.
 *
 * &lt;p&gt;The default {@link SelectionModel} used when instantiating a TreeTableView is
 * an implementation of the {@link MultipleSelectionModel} abstract class.
 * However, as noted in the API documentation for
 * the {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 * property, the default value is {@link SelectionMode#SINGLE}. To enable
 * multiple selection in a default TreeTableView instance, it is therefore necessary
 * to do the following:
 *
 * &lt;pre&gt;
 * {@code
 * treeTableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}&lt;/pre&gt;
 *
 * &lt;h3&gt;Customizing TreeTableView Visuals&lt;/h3&gt;
 * &lt;p&gt;The visuals of the TreeTableView can be entirely customized by replacing the
 * default {@link #rowFactoryProperty() row factory}. A row factory is used to
 * generate {@link TreeTableRow} instances, which are used to represent an entire
 * row in the TreeTableView.
 *
 * &lt;p&gt;In many cases, this is not what is desired however, as it is more commonly
 * the case that cells be customized on a per-column basis, not a per-row basis.
 * It is therefore important to note that a {@link TreeTableRow} is not a
 * {@link TreeTableCell}. A  {@link TreeTableRow} is simply a container for zero or more
 * {@link TreeTableCell}, and in most circumstances it is more likely that you'll
 * want to create custom TreeTableCells, rather than TreeTableRows. The primary use case
 * for creating custom TreeTableRow instances would most probably be to introduce
 * some form of column spanning support.
 *
 * &lt;p&gt;You can create custom {@link TreeTableCell} instances per column by assigning
 * the appropriate function to the TreeTableColumns
 * {@link TreeTableColumn#cellFactoryProperty() cell factory} property.
 *
 * &lt;p&gt;See the {@link Cell} class documentation for a more complete
 * description of how to write custom Cells.
 *
 * &lt;h3&gt;Editing&lt;/h3&gt;
 * &lt;p&gt;This control supports inline editing of values, and this section attempts to
 * give an overview of the available APIs and how you should use them.&lt;/p&gt;
 *
 * &lt;p&gt;Firstly, cell editing most commonly requires a different user interface
 * than when a cell is not being edited. This is the responsibility of the
 * {@link Cell} implementation being used. For TreeTableView, it is highly
 * recommended that editing be
 * {@link javafx.scene.control.TreeTableColumn#cellFactoryProperty() per-TreeTableColumn},
 * rather than {@link #rowFactoryProperty() per row}, as more often than not
 * you want users to edit each column value differently, and this approach allows
 * for editors specific to each column. It is your choice whether the cell is
 * permanently in an editing state (e.g. this is common for {@link CheckBox} cells),
 * or to switch to a different UI when editing begins (e.g. when a double-click
 * is received on a cell).&lt;/p&gt;
 *
 * &lt;p&gt;To know when editing has been requested on a cell,
 * simply override the {@link javafx.scene.control.Cell#startEdit()} method, and
 * update the cell {@link javafx.scene.control.Cell#textProperty() text} and
 * {@link javafx.scene.control.Cell#graphicProperty() graphic} properties as
 * appropriate (e.g. set the text to null and set the graphic to be a
 * {@link TextField}). Additionally, you should also override
 * {@link Cell#cancelEdit()} to reset the UI back to its original visual state
 * when the editing concludes. In both cases it is important that you also
 * ensure that you call the super method to have the cell perform all duties it
 * must do to enter or exit its editing mode.&lt;/p&gt;
 *
 * &lt;p&gt;Once your cell is in an editing state, the next thing you are most probably
 * interested in is how to commit or cancel the editing that is taking place. This is your
 * responsibility as the cell factory provider. Your cell implementation will know
 * when the editing is over, based on the user input (e.g. when the user presses
 * the Enter or ESC keys on their keyboard). When this happens, it is your
 * responsibility to call {@link Cell#commitEdit(Object)} or
 * {@link Cell#cancelEdit()}, as appropriate.&lt;/p&gt;
 *
 * &lt;p&gt;When you call {@link Cell#commitEdit(Object)} an event is fired to the
 * TreeTableView, which you can observe by adding an {@link EventHandler} via
 * {@link TreeTableColumn#setOnEditCommit(javafx.event.EventHandler)}. Similarly,
 * you can also observe edit events for
 * {@link TreeTableColumn#setOnEditStart(javafx.event.EventHandler) edit start}
 * and {@link TreeTableColumn#setOnEditCancel(javafx.event.EventHandler) edit cancel}.&lt;/p&gt;
 *
 * &lt;p&gt;By default the TreeTableColumn edit commit handler is non-null, with a default
 * handler that attempts to overwrite the property value for the
 * item in the currently-being-edited row. It is able to do this as the
 * {@link Cell#commitEdit(Object)} method is passed in the new value, and this
 * is passed along to the edit commit handler via the
 * {@link javafx.scene.control.TreeTableColumn.CellEditEvent CellEditEvent} that is
 * fired. It is simply a matter of calling
 * {@link javafx.scene.control.TreeTableColumn.CellEditEvent#getNewValue()} to
 * retrieve this value.
 *
 * &lt;p&gt;It is very important to note that if you call
 * {@link TreeTableColumn#setOnEditCommit(javafx.event.EventHandler)} with your own
 * {@link EventHandler}, then you will be removing the default handler. Unless
 * you then handle the writeback to the property (or the relevant data source),
 * nothing will happen. You can work around this by using the
 * {@link TreeTableColumn#addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}
 * method to add a {@link TreeTableColumn#EDIT_COMMIT_EVENT} {@link EventType} with
 * your desired {@link EventHandler} as the second argument. Using this method,
 * you will not replace the default implementation, but you will be notified when
 * an edit commit has occurred.&lt;/p&gt;
 *
 * &lt;p&gt;Hopefully this summary answers some of the commonly asked questions.
 * Fortunately, JavaFX ships with a number of pre-built cell factories that
 * handle all the editing requirements on your behalf. You can find these
 * pre-built cell factories in the javafx.scene.control.cell package.&lt;/p&gt;
 *
 * @see TreeTableColumn
 * @see TreeTablePosition
 * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView.
 * @since JavaFX 8.0
 */
@DefaultProperty(&quot;root&quot;)
public class TreeTableView&lt;S&gt; extends Control {

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates an empty TreeTableView.
     *
     * &lt;p&gt;Refer to the {@link TreeTableView} class documentation for details on the
     * default state of other properties.
     */
    public TreeTableView() {
        this(null);
    }

    /**
     * Creates a TreeTableView with the provided root node.
     *
     * &lt;p&gt;Refer to the {@link TreeTableView} class documentation for details on the
     * default state of other properties.
     *
     * @param root The node to be the root in this TreeTableView.
     */
    public TreeTableView(TreeItem&lt;S&gt; root) {
        getStyleClass().setAll(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.TREE_TABLE_VIEW);

        setRoot(root);
        updateExpandedItemCount(root);

        // install default selection and focus models - it's unlikely this will be changed
        // by many users.
        setSelectionModel(new TreeTableViewArrayListSelectionModel&lt;S&gt;(this));
        setFocusModel(new TreeTableViewFocusModel&lt;S&gt;(this));

        // we watch the columns list, such that when it changes we can update
        // the leaf columns and visible leaf columns lists (which are read-only).
        getColumns().addListener(weakColumnsObserver);

        // watch for changes to the sort order list - and when it changes run
        // the sort method.
        getSortOrder().addListener((ListChangeListener.Change&lt;? extends TreeTableColumn&lt;S, ?&gt;&gt; c) -&gt; {
            doSort(TableUtil.SortEventType.SORT_ORDER_CHANGE, c);
        });

        // We're watching for changes to the content width such
        // that the resize policy can be run if necessary. This comes from
        // TreeTableViewSkin.
        getProperties().addListener((MapChangeListener&lt;Object, Object&gt;) c -&gt; {
            if (c.wasAdded() &amp;&amp; TableView.SET_CONTENT_WIDTH.equals(c.getKey())) {
                if (c.getValueAdded() instanceof Number) {
                    setContentWidth((Double) c.getValueAdded());
                }
                getProperties().remove(TableView.SET_CONTENT_WIDTH);
            }
        });

        isInited = true;
    }



    /***************************************************************************
     *                                                                         *
     * Static properties and methods                                           *
     *                                                                         *
     **************************************************************************/

    /**
     * An EventType that indicates some edit event has occurred. It is the parent
     * type of all other edit events: {@link #editStartEvent},
     *  {@link #editCommitEvent} and {@link #editCancelEvent}.
     *
     * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
     * @return An EventType that indicates some edit event has occurred
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editAnyEvent() {
        return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_ANY_EVENT;
    }
    private static final EventType&lt;?&gt; EDIT_ANY_EVENT =
            new EventType&lt;&gt;(Event.ANY, &quot;TREE_TABLE_VIEW_EDIT&quot;);

    /**
     * An EventType used to indicate that an edit event has started within the
     * TreeTableView upon which the event was fired.
     *
     * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
     * @return An EventType used to indicate that an edit event has started
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editStartEvent() {
        return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_START_EVENT;
    }
    private static final EventType&lt;?&gt; EDIT_START_EVENT =
            new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_START&quot;);

    /**
     * An EventType used to indicate that an edit event has just been canceled
     * within the TreeTableView upon which the event was fired.
     *
     * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
     * @return An EventType used to indicate that an edit event has just been
     *      canceled
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editCancelEvent() {
        return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_CANCEL_EVENT;
    }
    private static final EventType&lt;?&gt; EDIT_CANCEL_EVENT =
            new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_CANCEL&quot;);

    /**
     * An EventType that is used to indicate that an edit in a TreeTableView has been
     * committed. This means that user has made changes to the data of a
     * TreeItem, and that the UI should be updated.
     *
     * @param &lt;S&gt; The type of the TreeItem instances used in this TreeTableView
     * @return An EventType that is used to indicate that an edit in a TreeTableView
     *      has been committed
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;S&gt; EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt; editCommitEvent() {
        return (EventType&lt;TreeTableView.EditEvent&lt;S&gt;&gt;) EDIT_COMMIT_EVENT;
    }
    private static final EventType&lt;?&gt; EDIT_COMMIT_EVENT =
            new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_COMMIT&quot;);

    /**
     * Returns the number of levels of 'indentation' of the given TreeItem,
     * based on how many times {@link javafx.scene.control.TreeItem#getParent()}
     * can be recursively called. If the TreeItem does not have any parent set,
     * the returned value will be zero. For each time getParent() is recursively
     * called, the returned value is incremented by one.
     *
     * &lt;p&gt;&lt;strong&gt;Important note: &lt;/strong&gt;This method is deprecated as it does
     * not consider the root node. This means that this method will iterate
     * past the root node of the TreeTableView control, if the root node has a parent.
     * If this is important, call {@link TreeTableView#getTreeItemLevel(TreeItem)}
     * instead.
     *
     * @param node The TreeItem for which the level is needed.
     * @return An integer representing the number of parents above the given node,
     *         or -1 if the given TreeItem is null.
     * @deprecated This method does not correctly calculate the distance from the
     *          given TreeItem to the root of the TreeTableView. As of JavaFX 8.0_20,
     *          the proper way to do this is via
     *          {@link TreeTableView#getTreeItemLevel(TreeItem)}
     */
    @Deprecated(since=&quot;8u20&quot;)
    public static int getNodeLevel(TreeItem&lt;?&gt; node) {
        return TreeView.getNodeLevel(node);
    }

    /**
     * &lt;p&gt;Very simple resize policy that just resizes the specified column by the
     * provided delta and shifts all other columns (to the right of the given column)
     * further to the right (when the delta is positive) or to the left (when the
     * delta is negative).
     *
     * &lt;p&gt;It also handles the case where we have nested columns by sharing the new space,
     * or subtracting the removed space, evenly between all immediate children columns.
     * Of course, the immediate children may themselves be nested, and they would
     * then use this policy on their children.
     */
    public static final Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; UNCONSTRAINED_RESIZE_POLICY =
            new Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;() {

        @Override public String toString() {
            return &quot;unconstrained-resize&quot;;
        }

        @Override public Boolean call(TreeTableView.ResizeFeatures prop) {
            double result = TableUtil.resize(prop.getColumn(), prop.getDelta());
            return Double.compare(result, 0.0) == 0;
        }
    };

    /**
     * &lt;p&gt;Simple policy that ensures the width of all visible leaf columns in
     * this table sum up to equal the width of the table itself.
     *
     * &lt;p&gt;When the user resizes a column width with this policy, the table automatically
     * adjusts the width of the right hand side columns. When the user increases a
     * column width, the table decreases the width of the rightmost column until it
     * reaches its minimum width. Then it decreases the width of the second
     * rightmost column until it reaches minimum width and so on. When all right
     * hand side columns reach minimum size, the user cannot increase the size of
     * resized column any more.
     */
    public static final Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; CONSTRAINED_RESIZE_POLICY =
            new Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;() {

        private boolean isFirstRun = true;

        @Override public String toString() {
            return &quot;constrained-resize&quot;;
        }

        @Override public Boolean call(TreeTableView.ResizeFeatures prop) {
            TreeTableView&lt;?&gt; table = prop.getTable();
            List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; visibleLeafColumns = table.getVisibleLeafColumns();
            Boolean result = TableUtil.constrainedResize(prop,
                                               isFirstRun,
                                               table.contentWidth,
                                               visibleLeafColumns);
            isFirstRun = ! isFirstRun ? false : ! result;
            return result;
        }
    };

    /**
     * The default {@link #sortPolicyProperty() sort policy} that this TreeTableView
     * will use if no other policy is specified. The sort policy is a simple
     * {@link Callback} that accepts a TreeTableView as the sole argument and expects
     * a Boolean response representing whether the sort succeeded or not. A Boolean
     * response of true represents success, and a response of false (or null) will
     * be considered to represent failure.
     */
    public static final Callback&lt;TreeTableView, Boolean&gt; DEFAULT_SORT_POLICY = new Callback&lt;TreeTableView, Boolean&gt;() {
        @Override public Boolean call(TreeTableView table) {
            try {
                TreeItem rootItem = table.getRoot();
                if (rootItem == null) return false;

                TreeSortMode sortMode = table.getSortMode();
                if (sortMode == null) return false;

                rootItem.lastSortMode = sortMode;
                rootItem.lastComparator = table.getComparator();
                rootItem.sort();
                return true;
            } catch (UnsupportedOperationException e) {
                // TODO might need to support other exception types including:
                // ClassCastException - if the class of the specified element prevents it from being added to this list
                // NullPointerException - if the specified element is null and this list does not permit null elements
                // IllegalArgumentException - if some property of this element prevents it from being added to this list

                // If we are here the list does not support sorting, so we gracefully
                // fail the sort request and ensure the UI is put back to its previous
                // state. This is handled in the code that calls the sort policy.

                return false;
            }
        }
    };



    /***************************************************************************
     *                                                                         *
     * Instance Variables                                                      *
     *                                                                         *
     **************************************************************************/

    // used in the tree item modification event listener. Used by the
    // layoutChildren method to determine whether the tree item count should
    // be recalculated.
    private boolean expandedItemCountDirty = true;

    // Used in the getTreeItem(int row) method to act as a cache.
    // See RT-26716 for the justification and performance gains.
    private Map&lt;Integer, SoftReference&lt;TreeItem&lt;S&gt;&gt;&gt; treeItemCacheMap = new HashMap&lt;&gt;();

    // this is the only publicly writable list for columns. This represents the
    // columns as they are given initially by the developer.
    private final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = FXCollections.observableArrayList();

    // Finally, as convenience, we also have an observable list that contains
    // only the leaf columns that are currently visible.
    private final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; visibleLeafColumns = FXCollections.observableArrayList();
    private final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; unmodifiableVisibleLeafColumns = FXCollections.unmodifiableObservableList(visibleLeafColumns);

    // Allows for multiple column sorting based on the order of the TreeTableColumns
    // in this observableArrayList. Each TreeTableColumn is responsible for whether it is
    // sorted using ascending or descending order.
    private ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = FXCollections.observableArrayList();

    // width of VirtualFlow minus the vbar width
    // package protected for testing only
    double contentWidth;

    // Used to minimise the amount of work performed prior to the table being
    // completely initialised. In particular it reduces the amount of column
    // resize operations that occur, which slightly improves startup time.
    private boolean isInited = false;



    /***************************************************************************
     *                                                                         *
     * Callbacks and Events                                                    *
     *                                                                         *
     **************************************************************************/

    // we use this to forward events that have bubbled up TreeItem instances
    // to the TreeTableViewSkin, to force it to recalculate teh item count and redraw
    // if necessary
    private final EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; rootEvent = e -&gt; {
        // this forces layoutChildren at the next pulse, and therefore
        // updates the item count if necessary
        EventType&lt;?&gt; eventType = e.getEventType();
        boolean match = false;
        while (eventType != null) {
            if (eventType.equals(TreeItem.&lt;S&gt;expandedItemCountChangeEvent())) {
                match = true;
                break;
            }
            eventType = eventType.getSuperType();
        }

        if (match) {
            expandedItemCountDirty = true;
            requestLayout();
        }
    };

    private final ListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt; columnsObserver = new ListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt;() {
        @Override public void onChanged(ListChangeListener.Change&lt;? extends TreeTableColumn&lt;S,?&gt;&gt; c) {
            final List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getColumns();

            // Fix for RT-39822 - don't allow the same column to be installed twice
            while (c.next()) {
                if (c.wasAdded()) {
                    List&lt;TreeTableColumn&lt;S,?&gt;&gt; duplicates = new ArrayList&lt;&gt;();
                    for (TreeTableColumn&lt;S,?&gt; addedColumn : c.getAddedSubList()) {
                        if (addedColumn == null) continue;

                        int count = 0;
                        for (TreeTableColumn&lt;S,?&gt; column : columns) {
                            if (addedColumn == column) {
                                count++;
                            }
                        }

                        if (count &gt; 1) {
                            duplicates.add(addedColumn);
                        }
                    }

                    if (!duplicates.isEmpty()) {
                        String titleList = &quot;&quot;;
                        for (TreeTableColumn&lt;S,?&gt; dupe : duplicates) {
                            titleList += &quot;'&quot; + dupe.getText() + &quot;', &quot;;
                        }
                        throw new IllegalStateException(&quot;Duplicate TreeTableColumns detected in TreeTableView columns list with titles &quot; + titleList);
                    }
                }
            }
            c.reset();

            // Fix for RT-15194: Need to remove removed columns from the
            // sortOrder list.
            List&lt;TreeTableColumn&lt;S,?&gt;&gt; toRemove = new ArrayList&lt;TreeTableColumn&lt;S,?&gt;&gt;();
            while (c.next()) {
                final List&lt;? extends TreeTableColumn&lt;S, ?&gt;&gt; removed = c.getRemoved();
                final List&lt;? extends TreeTableColumn&lt;S, ?&gt;&gt; added = c.getAddedSubList();

                if (c.wasRemoved()) {
                    toRemove.addAll(removed);
                    for (TreeTableColumn&lt;S,?&gt; tc : removed) {
                        tc.setTreeTableView(null);
                    }
                }

                if (c.wasAdded()) {
                    toRemove.removeAll(added);
                    for (TreeTableColumn&lt;S,?&gt; tc : added) {
                        tc.setTreeTableView(TreeTableView.this);
                    }
                }

                // set up listeners
                TableUtil.removeColumnsListener(removed, weakColumnsObserver);
                TableUtil.addColumnsListener(added, weakColumnsObserver);

                TableUtil.removeTableColumnListener(c.getRemoved(),
                        weakColumnVisibleObserver,
                        weakColumnSortableObserver,
                        weakColumnSortTypeObserver,
                        weakColumnComparatorObserver);
                TableUtil.addTableColumnListener(c.getAddedSubList(),
                        weakColumnVisibleObserver,
                        weakColumnSortableObserver,
                        weakColumnSortTypeObserver,
                        weakColumnComparatorObserver);
            }

            // We don't maintain a bind for leafColumns, we simply call this update
            // function behind the scenes in the appropriate places.
            updateVisibleLeafColumns();

            sortOrder.removeAll(toRemove);

            // Fix for RT-38892.
            final TreeTableViewFocusModel&lt;S&gt; fm = getFocusModel();
            final TreeTableViewSelectionModel&lt;S&gt; sm = getSelectionModel();
            c.reset();

            // we need to collect together all removed and all added columns, because
            // the code below works on the actually removed columns. If we perform
            // the code within this while loop, we'll be deselecting columns that
            // should be deselected (because they have just moved place, for example).
            List&lt;TreeTableColumn&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;();
            List&lt;TreeTableColumn&lt;S,?&gt;&gt; added = new ArrayList&lt;&gt;();
            while (c.next()) {
                if (c.wasRemoved()) {
                    removed.addAll(c.getRemoved());
                }
                if (c.wasAdded()) {
                    added.addAll(c.getAddedSubList());
                }
            }
            removed.removeAll(added);


            // Fix for focus - we simply move focus to a cell to the left
            // of the focused cell if the focused cell was located within
            // a column that has been removed.
            if (fm != null) {
                TreeTablePosition&lt;S, ?&gt; focusedCell = fm.getFocusedCell();
                boolean match = false;
                for (TreeTableColumn&lt;S, ?&gt; tc : removed) {
                    match = focusedCell != null &amp;&amp; focusedCell.getTableColumn() == tc;
                    if (match) {
                        break;
                    }
                }

                if (match) {
                    int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(focusedCell.getTableColumn(), 0);
                    int newFocusColumnIndex =
                            matchingColumnIndex == 0 ? 0 :
                                    Math.min(getVisibleLeafColumns().size() - 1, matchingColumnIndex - 1);
                    fm.focus(focusedCell.getRow(), getVisibleLeafColumn(newFocusColumnIndex));
                }
            }

            // Fix for selection - we remove selection from all cells that
            // were within the removed column.
            if (sm != null) {
                List&lt;TreeTablePosition&gt; selectedCells = new ArrayList&lt;&gt;(sm.getSelectedCells());
                for (TreeTablePosition selectedCell : selectedCells) {
                    boolean match = false;
                    for (TreeTableColumn&lt;S, ?&gt; tc : removed) {
                        match = selectedCell != null &amp;&amp; selectedCell.getTableColumn() == tc;
                        if (match) break;
                    }

                    if (match) {
                        // we can't just use the selectedCell.getTableColumn(), as that
                        // column no longer exists and therefore its index is not correct.
                        int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(selectedCell.getTableColumn(), -1);
                        if (matchingColumnIndex == -1) continue;

                        if (sm instanceof TreeTableViewArrayListSelectionModel) {
                            // Also, because the table column no longer exists in the columns
                            // list at this point, we can't just call:
                            // sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
                            // as the tableColumn would map to an index of -1, which means that
                            // selection will not be cleared. Instead, we have to create
                            // a new TablePosition with a fixed column index and use that.
                            TreeTablePosition&lt;S,?&gt; fixedTablePosition =
                                    new TreeTablePosition&lt;S,Object&gt;(TreeTableView.this,
                                            selectedCell.getRow(),
                                            selectedCell.getTableColumn());
                            fixedTablePosition.fixedColumnIndex = matchingColumnIndex;

                            ((TreeTableViewArrayListSelectionModel)sm).clearSelection(fixedTablePosition);
                        } else {
                            sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
                        }
                    }
                }
            }


            // update the lastKnownColumnIndex map
            lastKnownColumnIndex.clear();
            for (TreeTableColumn&lt;S,?&gt; tc : getColumns()) {
                int index = getVisibleLeafIndex(tc);
                if (index &gt; -1) {
                    lastKnownColumnIndex.put(tc, index);
                }
            }
        }
    };

    private final WeakHashMap&lt;TreeTableColumn&lt;S,?&gt;, Integer&gt; lastKnownColumnIndex = new WeakHashMap&lt;&gt;();

    private final InvalidationListener columnVisibleObserver = valueModel -&gt; {
        updateVisibleLeafColumns();
    };

    private final InvalidationListener columnSortableObserver = valueModel -&gt; {
        TreeTableColumn col = (TreeTableColumn) ((BooleanProperty)valueModel).getBean();
        if (! getSortOrder().contains(col)) return;
        doSort(TableUtil.SortEventType.COLUMN_SORTABLE_CHANGE, col);
    };

    private final InvalidationListener columnSortTypeObserver = valueModel -&gt; {
        TreeTableColumn col = (TreeTableColumn) ((ObjectProperty)valueModel).getBean();
        if (! getSortOrder().contains(col)) return;
        doSort(TableUtil.SortEventType.COLUMN_SORT_TYPE_CHANGE, col);
    };

    private final InvalidationListener columnComparatorObserver = valueModel -&gt; {
        TreeTableColumn col = (TreeTableColumn) ((SimpleObjectProperty)valueModel).getBean();
        if (! getSortOrder().contains(col)) return;
        doSort(TableUtil.SortEventType.COLUMN_COMPARATOR_CHANGE, col);
    };

    /* proxy pseudo-class state change from selectionModel's cellSelectionEnabledProperty */
    private final InvalidationListener cellSelectionModelInvalidationListener = o -&gt; {
        boolean isCellSelection = ((BooleanProperty)o).get();
        pseudoClassStateChanged(PSEUDO_CLASS_CELL_SELECTION,  isCellSelection);
        pseudoClassStateChanged(PSEUDO_CLASS_ROW_SELECTION,  !isCellSelection);
    };

    private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakRootEventListener;

    private final WeakInvalidationListener weakColumnVisibleObserver =
            new WeakInvalidationListener(columnVisibleObserver);

    private final WeakInvalidationListener weakColumnSortableObserver =
            new WeakInvalidationListener(columnSortableObserver);

    private final WeakInvalidationListener weakColumnSortTypeObserver =
            new WeakInvalidationListener(columnSortTypeObserver);

    private final WeakInvalidationListener weakColumnComparatorObserver =
            new WeakInvalidationListener(columnComparatorObserver);

    private final WeakListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt; weakColumnsObserver =
            new WeakListChangeListener&lt;TreeTableColumn&lt;S,?&gt;&gt;(columnsObserver);

    private final WeakInvalidationListener weakCellSelectionModelInvalidationListener =
            new WeakInvalidationListener(cellSelectionModelInvalidationListener);



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- Root
    private ObjectProperty&lt;TreeItem&lt;S&gt;&gt; root = new SimpleObjectProperty&lt;TreeItem&lt;S&gt;&gt;(this, &quot;root&quot;) {
        private WeakReference&lt;TreeItem&lt;S&gt;&gt; weakOldItem;

        @Override protected void invalidated() {
            TreeItem&lt;S&gt; oldTreeItem = weakOldItem == null ? null : weakOldItem.get();
            if (oldTreeItem != null &amp;&amp; weakRootEventListener != null) {
                oldTreeItem.removeEventHandler(TreeItem.&lt;S&gt;treeNotificationEvent(), weakRootEventListener);
            }

            TreeItem&lt;S&gt; root = getRoot();
            if (root != null) {
                weakRootEventListener = new WeakEventHandler&lt;&gt;(rootEvent);
                getRoot().addEventHandler(TreeItem.&lt;S&gt;treeNotificationEvent(), weakRootEventListener);
                weakOldItem = new WeakReference&lt;&gt;(root);
            }

            // Fix for RT-35763
            getSortOrder().clear();

            expandedItemCountDirty = true;
            updateRootExpanded();
        }
    };

    /**
     * Sets the root node in this TreeTableView. See the {@link TreeItem} class level
     * documentation for more details.
     *
     * @param value The {@link TreeItem} that will be placed at the root of the
     *      TreeTableView.
     */
    public final void setRoot(TreeItem&lt;S&gt; value) {
        rootProperty().set(value);
    }

    /**
     * Returns the current root node of this TreeTableView, or null if no root node
     * is specified.
     * @return The current root node, or null if no root node exists.
     */
    public final TreeItem&lt;S&gt; getRoot() {
        return root == null ? null : root.get();
    }

    /**
     * Property representing the root node of the TreeTableView.
     * @return the root property
     */
    public final ObjectProperty&lt;TreeItem&lt;S&gt;&gt; rootProperty() {
        return root;
    }



    // --- Show Root
    private BooleanProperty showRoot;

    /**
     * Specifies whether the root {@code TreeItem} should be shown within this
     * TreeTableView.
     *
     * @param value If true, the root TreeItem will be shown, and if false it
     *      will be hidden.
     */
    public final void setShowRoot(boolean value) {
        showRootProperty().set(value);
    }

    /**
     * Returns true if the root of the TreeTableView should be shown, and false if
     * it should not. By default, the root TreeItem is visible in the TreeTableView.
     * @return true if the root of the TreeTableView should be shown
     */
    public final boolean isShowRoot() {
        return showRoot == null ? true : showRoot.get();
    }

    /**
     * Property that represents whether or not the TreeTableView root node is visible.
     * @return the show root property
     */
    public final BooleanProperty showRootProperty() {
        if (showRoot == null) {
            showRoot = new SimpleBooleanProperty(this, &quot;showRoot&quot;, true) {
                @Override protected void invalidated() {
                    updateRootExpanded();
                    updateExpandedItemCount(getRoot());
                }
            };
        }
        return showRoot;
    }



    // --- Tree Column
    private ObjectProperty&lt;TreeTableColumn&lt;S,?&gt;&gt; treeColumn;
    /**
     * Property that represents which column should have the disclosure node
     * shown in it (that is, the column with the arrow). By default this will be
     * the left-most column if this property is null, otherwise it will be the
     * specified column assuming it is non-null and contained within the
     * {@link #getVisibleLeafColumns() visible leaf columns} list.
     * @return the tree column property
     */
    public final ObjectProperty&lt;TreeTableColumn&lt;S,?&gt;&gt; treeColumnProperty() {
        if (treeColumn == null) {
            treeColumn = new SimpleObjectProperty&lt;&gt;(this, &quot;treeColumn&quot;, null);
        }
        return treeColumn;
    }
    public final void setTreeColumn(TreeTableColumn&lt;S,?&gt; value) {
        treeColumnProperty().set(value);
    }
    public final TreeTableColumn&lt;S,?&gt; getTreeColumn() {
        return treeColumn == null ? null : treeColumn.get();
    }



    // --- Selection Model
    private ObjectProperty&lt;TreeTableViewSelectionModel&lt;S&gt;&gt; selectionModel;

    /**
     * Sets the {@link MultipleSelectionModel} to be used in the TreeTableView.
     * Despite a TreeTableView requiring a &lt;code&gt;&lt;b&gt;Multiple&lt;/b&gt;SelectionModel&lt;/code&gt;,
     * it is possible to configure it to only allow single selection (see
     * {@link MultipleSelectionModel#setSelectionMode(javafx.scene.control.SelectionMode)}
     * for more information).
     * @param value the {@link MultipleSelectionModel} to be used
     */
    public final void setSelectionModel(TreeTableViewSelectionModel&lt;S&gt; value) {
        selectionModelProperty().set(value);
    }

    /**
     * Returns the currently installed selection model.
     * @return the currently installed selection model
     */
    public final TreeTableViewSelectionModel&lt;S&gt; getSelectionModel() {
        return selectionModel == null ? null : selectionModel.get();
    }

    /**
     * The SelectionModel provides the API through which it is possible
     * to select single or multiple items within a TreeTableView, as  well as inspect
     * which rows have been selected by the user. Note that it has a generic
     * type that must match the type of the TreeTableView itself.
     * @return the selection model property
     */
    public final ObjectProperty&lt;TreeTableViewSelectionModel&lt;S&gt;&gt; selectionModelProperty() {
        if (selectionModel == null) {
            selectionModel = new SimpleObjectProperty&lt;TreeTableViewSelectionModel&lt;S&gt;&gt;(this, &quot;selectionModel&quot;) {

                TreeTableViewSelectionModel&lt;S&gt; oldValue = null;

                @Override protected void invalidated() {
                    // need to listen to the cellSelectionEnabledProperty
                    // in order to set pseudo-class state
                    if (oldValue != null) {
                        oldValue.cellSelectionEnabledProperty().removeListener(weakCellSelectionModelInvalidationListener);

                        if (oldValue instanceof TreeTableViewArrayListSelectionModel) {
                            ((TreeTableViewArrayListSelectionModel)oldValue).dispose();
                        }
                    }

                    oldValue = get();

                    if (oldValue != null) {
                        oldValue.cellSelectionEnabledProperty().addListener(weakCellSelectionModelInvalidationListener);
                        // fake invalidation to ensure updated pseudo-class states
                        weakCellSelectionModelInvalidationListener.invalidated(oldValue.cellSelectionEnabledProperty());
                    }
                }
            };
        }
        return selectionModel;
    }


    // --- Focus Model
    private ObjectProperty&lt;TreeTableViewFocusModel&lt;S&gt;&gt; focusModel;

    /**
     * Sets the {@link FocusModel} to be used in the TreeTableView.
     * @param value the {@link FocusModel} to be used
     */
    public final void setFocusModel(TreeTableViewFocusModel&lt;S&gt; value) {
        focusModelProperty().set(value);
    }

    /**
     * Returns the currently installed {@link FocusModel}.
     * @return the currently installed {@link FocusModel}
     */
    public final TreeTableViewFocusModel&lt;S&gt; getFocusModel() {
        return focusModel == null ? null : focusModel.get();
    }

    /**
     * The FocusModel provides the API through which it is possible
     * to control focus on zero or one rows of the TreeTableView. Generally the
     * default implementation should be more than sufficient.
     * @return the focus model property
     */
    public final ObjectProperty&lt;TreeTableViewFocusModel&lt;S&gt;&gt; focusModelProperty() {
        if (focusModel == null) {
            focusModel = new SimpleObjectProperty&lt;TreeTableViewFocusModel&lt;S&gt;&gt;(this, &quot;focusModel&quot;);
        }
        return focusModel;
    }


    // --- Tree node count
    /**
     * &lt;p&gt;Represents the number of tree nodes presently able to be visible in the
     * TreeTableView. This is essentially the count of all expanded tree items, and
     * their children.
     *
     * &lt;p&gt;For example, if just the root node is visible, the expandedItemCount will
     * be one. If the root had three children and the root was expanded, the value
     * will be four.
     */
    private ReadOnlyIntegerWrapper expandedItemCount = new ReadOnlyIntegerWrapper(this, &quot;expandedItemCount&quot;, 0);
    public final ReadOnlyIntegerProperty expandedItemCountProperty() {
        return expandedItemCount.getReadOnlyProperty();
    }
    private void setExpandedItemCount(int value) {
        expandedItemCount.set(value);
    }
    public final int getExpandedItemCount() {
        if (expandedItemCountDirty) {
            updateExpandedItemCount(getRoot());
        }
        return expandedItemCount.get();
    }


    // --- Editable
    private BooleanProperty editable;
    public final void setEditable(boolean value) {
        editableProperty().set(value);
    }
    public final boolean isEditable() {
        return editable == null ? false : editable.get();
    }
    /**
     * Specifies whether this TreeTableView is editable - only if the TreeTableView and
     * the TreeCells within it are both editable will a TreeCell be able to go
     * into their editing state.
     * @return the editable property
     */
    public final BooleanProperty editableProperty() {
        if (editable == null) {
            editable = new SimpleBooleanProperty(this, &quot;editable&quot;, false);
        }
        return editable;
    }


    // --- Editing Cell
    private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; editingCell;
    private void setEditingCell(TreeTablePosition&lt;S,?&gt; value) {
        editingCellPropertyImpl().set(value);
    }
    public final TreeTablePosition&lt;S,?&gt; getEditingCell() {
        return editingCell == null ? null : editingCell.get();
    }

    /**
     * Represents the current cell being edited, or null if
     * there is no cell being edited.
     * @return the editing cell property
     */
    public final ReadOnlyObjectProperty&lt;TreeTablePosition&lt;S,?&gt;&gt; editingCellProperty() {
        return editingCellPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; editingCellPropertyImpl() {
        if (editingCell == null) {
            editingCell = new ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt;(this, &quot;editingCell&quot;);
        }
        return editingCell;
    }


    // --- Table menu button visible
    private BooleanProperty tableMenuButtonVisible;
    /**
     * This controls whether a menu button is available when the user clicks
     * in a designated space within the TableView, within which is a radio menu
     * item for each TreeTableColumn in this table. This menu allows for the user to
     * show and hide all TreeTableColumns easily.
     * @return the table menu button visible property
     */
    public final BooleanProperty tableMenuButtonVisibleProperty() {
        if (tableMenuButtonVisible == null) {
            tableMenuButtonVisible = new SimpleBooleanProperty(this, &quot;tableMenuButtonVisible&quot;);
        }
        return tableMenuButtonVisible;
    }
    public final void setTableMenuButtonVisible (boolean value) {
        tableMenuButtonVisibleProperty().set(value);
    }
    public final boolean isTableMenuButtonVisible() {
        return tableMenuButtonVisible == null ? false : tableMenuButtonVisible.get();
    }


    // --- Column Resize Policy
    private ObjectProperty&lt;Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;&gt; columnResizePolicy;
    public final void setColumnResizePolicy(Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; callback) {
        columnResizePolicyProperty().set(callback);
    }
    public final Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; getColumnResizePolicy() {
        return columnResizePolicy == null ? UNCONSTRAINED_RESIZE_POLICY : columnResizePolicy.get();
    }

    /**
     * This is the function called when the user completes a column-resize
     * operation. The two most common policies are available as static functions
     * in the TableView class: {@link #UNCONSTRAINED_RESIZE_POLICY} and
     * {@link #CONSTRAINED_RESIZE_POLICY}.
     * @return the column resize policy property
     */
    public final ObjectProperty&lt;Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;&gt; columnResizePolicyProperty() {
        if (columnResizePolicy == null) {
            columnResizePolicy = new SimpleObjectProperty&lt;Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt;&gt;(this, &quot;columnResizePolicy&quot;, UNCONSTRAINED_RESIZE_POLICY) {
                private Callback&lt;TreeTableView.ResizeFeatures, Boolean&gt; oldPolicy;

                @Override protected void invalidated() {
                    if (isInited) {
                        get().call(new TreeTableView.ResizeFeatures(TreeTableView.this, null, 0.0));

                        if (oldPolicy != null) {
                            PseudoClass state = PseudoClass.getPseudoClass(oldPolicy.toString());
                            pseudoClassStateChanged(state, false);
                        }
                        if (get() != null) {
                            PseudoClass state = PseudoClass.getPseudoClass(get().toString());
                            pseudoClassStateChanged(state, true);
                        }
                        oldPolicy = get();
                    }
                }
            };
        }
        return columnResizePolicy;
    }


    // --- Row Factory
    private ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt;&gt; rowFactory;

    /**
     * A function which produces a TreeTableRow. The system is responsible for
     * reusing TreeTableRows. Return from this function a TreeTableRow which
     * might be usable for representing a single row in a TableView.
     * &lt;p&gt;
     * Note that a TreeTableRow is &lt;b&gt;not&lt;/b&gt; a TableCell. A TreeTableRow is
     * simply a container for a TableCell, and in most circumstances it is more
     * likely that you'll want to create custom TableCells, rather than
     * TreeTableRows. The primary use case for creating custom TreeTableRow
     * instances would most probably be to introduce some form of column
     * spanning support.
     * &lt;p&gt;
     * You can create custom TableCell instances per column by assigning the
     * appropriate function to the cellFactory property in the TreeTableColumn class.
     * @return the row factory property
     */
    public final ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt;&gt; rowFactoryProperty() {
        if (rowFactory == null) {
            rowFactory = new SimpleObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt;&gt;(this, &quot;rowFactory&quot;);
        }
        return rowFactory;
    }
    public final void setRowFactory(Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt; value) {
        rowFactoryProperty().set(value);
    }
    public final Callback&lt;TreeTableView&lt;S&gt;, TreeTableRow&lt;S&gt;&gt; getRowFactory() {
        return rowFactory == null ? null : rowFactory.get();
    }


    // --- Placeholder Node
    private ObjectProperty&lt;Node&gt; placeholder;
    /**
     * This Node is shown to the user when the table has no content to show.
     * This may be the case because the table model has no data in the first
     * place, that a filter has been applied to the table model, resulting
     * in there being nothing to show the user, or that there are no currently
     * visible columns.
     * @return the placeholder property
     */
    public final ObjectProperty&lt;Node&gt; placeholderProperty() {
        if (placeholder == null) {
            placeholder = new SimpleObjectProperty&lt;Node&gt;(this, &quot;placeholder&quot;);
        }
        return placeholder;
    }
    public final void setPlaceholder(Node value) {
        placeholderProperty().set(value);
    }
    public final Node getPlaceholder() {
        return placeholder == null ? null : placeholder.get();
    }


    // --- Fixed cell size
    private DoubleProperty fixedCellSize;

    /**
     * Sets the new fixed cell size for this control. Any value greater than
     * zero will enable fixed cell size mode, whereas a zero or negative value
     * (or Region.USE_COMPUTED_SIZE) will be used to disabled fixed cell size
     * mode.
     *
     * @param value The new fixed cell size value, or a value less than or equal
     *              to zero (or Region.USE_COMPUTED_SIZE) to disable.
     * @since JavaFX 8.0
     */
    public final void setFixedCellSize(double value) {
        fixedCellSizeProperty().set(value);
    }

    /**
     * Returns the fixed cell size value. A value less than or equal to zero is
     * used to represent that fixed cell size mode is disabled, and a value
     * greater than zero represents the size of all cells in this control.
     *
     * @return A double representing the fixed cell size of this control, or a
     *      value less than or equal to zero if fixed cell size mode is disabled.
     * @since JavaFX 8.0
     */
    public final double getFixedCellSize() {
        return fixedCellSize == null ? Region.USE_COMPUTED_SIZE : fixedCellSize.get();
    }
    /**
     * Specifies whether this control has cells that are a fixed height (of the
     * specified value). If this value is less than or equal to zero,
     * then all cells are individually sized and positioned. This is a slow
     * operation. Therefore, when performance matters and developers are not
     * dependent on variable cell sizes it is a good idea to set the fixed cell
     * size value. Generally cells are around 24px, so setting a fixed cell size
     * of 24 is likely to result in very little difference in visuals, but a
     * improvement to performance.
     *
     * &lt;p&gt;To set this property via CSS, use the -fx-fixed-cell-size property.
     * This should not be confused with the -fx-cell-size property. The difference
     * between these two CSS properties is that -fx-cell-size will size all
     * cells to the specified size, but it will not enforce that this is the
     * only size (thus allowing for variable cell sizes, and preventing the
     * performance gains from being possible). Therefore, when performance matters
     * use -fx-fixed-cell-size, instead of -fx-cell-size. If both properties are
     * specified in CSS, -fx-fixed-cell-size takes precedence.&lt;/p&gt;
     *
     * @return the fixed cell size property
     * @since JavaFX 8.0
     */
    public final DoubleProperty fixedCellSizeProperty() {
        if (fixedCellSize == null) {
            fixedCellSize = new StyleableDoubleProperty(Region.USE_COMPUTED_SIZE) {
                @Override public CssMetaData&lt;TreeTableView&lt;?&gt;,Number&gt; getCssMetaData() {
                    return StyleableProperties.FIXED_CELL_SIZE;
                }

                @Override public Object getBean() {
                    return TreeTableView.this;
                }

                @Override public String getName() {
                    return &quot;fixedCellSize&quot;;
                }
            };
        }
        return fixedCellSize;
    }


    // --- SortMode
    /**
     * Specifies the sort mode to use when sorting the contents of this TreeTableView,
     * should any columns be specified in the {@link #getSortOrder() sort order}
     * list.
     */
    private ObjectProperty&lt;TreeSortMode&gt; sortMode;
    public final ObjectProperty&lt;TreeSortMode&gt; sortModeProperty() {
        if (sortMode == null) {
            sortMode = new SimpleObjectProperty&lt;&gt;(this, &quot;sortMode&quot;, TreeSortMode.ALL_DESCENDANTS);
        }
        return sortMode;
    }
    public final void setSortMode(TreeSortMode value) {
        sortModeProperty().set(value);
    }
    public final TreeSortMode getSortMode() {
        return sortMode == null ? TreeSortMode.ALL_DESCENDANTS : sortMode.get();
    }


    // --- Comparator (built via sortOrder list, so read-only)
    /**
     * The comparator property is a read-only property that is representative of the
     * current state of the {@link #getSortOrder() sort order} list. The sort
     * order list contains the columns that have been added to it either programmatically
     * or via a user clicking on the headers themselves.
     */
    private ReadOnlyObjectWrapper&lt;Comparator&lt;TreeItem&lt;S&gt;&gt;&gt; comparator;
    private void setComparator(Comparator&lt;TreeItem&lt;S&gt;&gt; value) {
        comparatorPropertyImpl().set(value);
    }
    public final Comparator&lt;TreeItem&lt;S&gt;&gt; getComparator() {
        return comparator == null ? null : comparator.get();
    }
    public final ReadOnlyObjectProperty&lt;Comparator&lt;TreeItem&lt;S&gt;&gt;&gt; comparatorProperty() {
        return comparatorPropertyImpl().getReadOnlyProperty();
    }
    private ReadOnlyObjectWrapper&lt;Comparator&lt;TreeItem&lt;S&gt;&gt;&gt; comparatorPropertyImpl() {
        if (comparator == null) {
            comparator = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;comparator&quot;);
        }
        return comparator;
    }


    // --- sortPolicy
    /**
     * The sort policy specifies how sorting in this TreeTableView should be performed.
     * For example, a basic sort policy may just recursively sort the children of
     * the root tree item, whereas a more advanced sort policy may call to a
     * database to perform the necessary sorting on the server-side.
     *
     * &lt;p&gt;TreeTableView ships with a {@link TableView#DEFAULT_SORT_POLICY default
     * sort policy} that does precisely as mentioned above: it simply attempts
     * to sort the tree hierarchy in-place.
     *
     * &lt;p&gt;It is recommended that rather than override the {@link TreeTableView#sort() sort}
     * method that a different sort policy be provided instead.
     */
    private ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;&gt; sortPolicy;
    public final void setSortPolicy(Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; callback) {
        sortPolicyProperty().set(callback);
    }
    @SuppressWarnings(&quot;unchecked&quot;)
    public final Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; getSortPolicy() {
        return sortPolicy == null ?
                (Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY :
                sortPolicy.get();
    }
    @SuppressWarnings(&quot;unchecked&quot;)
    public final ObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;&gt; sortPolicyProperty() {
        if (sortPolicy == null) {
            sortPolicy = new SimpleObjectProperty&lt;Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;&gt;(
                    this, &quot;sortPolicy&quot;, (Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY) {
                @Override protected void invalidated() {
                    sort();
                }
            };
        }
        return sortPolicy;
    }


    // onSort
    /**
     * Called when there's a request to sort the control.
     */
    private ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt;&gt; onSort;

    public void setOnSort(EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; value) {
        onSortProperty().set(value);
    }

    public EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; getOnSort() {
        if( onSort != null ) {
            return onSort.get();
        }
        return null;
    }

    public ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt;&gt; onSortProperty() {
        if( onSort == null ) {
            onSort = new ObjectPropertyBase&lt;EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt;&gt;() {
                @Override protected void invalidated() {
                    EventType&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; eventType = SortEvent.sortEvent();
                    EventHandler&lt;SortEvent&lt;TreeTableView&lt;S&gt;&gt;&gt; eventHandler = get();
                    setEventHandler(eventType, eventHandler);
                }

                @Override public Object getBean() {
                    return TreeTableView.this;
                }

                @Override public String getName() {
                    return &quot;onSort&quot;;
                }
            };
        }
        return onSort;
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected void layoutChildren() {
        if (expandedItemCountDirty) {
            updateExpandedItemCount(getRoot());
        }

        super.layoutChildren();
    }

    /**
     * Scrolls the TreeTableView such that the item in the given index is visible to
     * the end user.
     *
     * @param index The index that should be made visible to the user, assuming
     *      of course that it is greater than, or equal to 0, and less than the
     *      number of the visible items in the TreeTableView.
     */
    public void scrollTo(int index) {
        ControlUtils.scrollToIndex(this, index);
    }

    /**
     * Called when there's a request to scroll an index into view using {@link #scrollTo(int)}
     */
    private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollTo;

    public void setOnScrollTo(EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; value) {
        onScrollToProperty().set(value);
    }

    public EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; getOnScrollTo() {
        if( onScrollTo != null ) {
            return onScrollTo.get();
        }
        return null;
    }

    public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollToProperty() {
        if( onScrollTo == null ) {
            onScrollTo = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt;() {
                @Override protected void invalidated() {
                    setEventHandler(ScrollToEvent.scrollToTopIndex(), get());
                }

                @Override public Object getBean() {
                    return TreeTableView.this;
                }

                @Override public String getName() {
                    return &quot;onScrollTo&quot;;
                }
            };
        }
        return onScrollTo;
    }

    /**
     * Scrolls the TreeTableView so that the given column is visible within the viewport.
     * @param column The column that should be visible to the user.
     */
    public void scrollToColumn(TreeTableColumn&lt;S, ?&gt; column) {
        ControlUtils.scrollToColumn(this, column);
    }

    /**
     * Scrolls the TreeTableView so that the given index is visible within the viewport.
     * @param columnIndex The index of a column that should be visible to the user.
     */
    public void scrollToColumnIndex(int columnIndex) {
        if( getColumns() != null ) {
            ControlUtils.scrollToColumn(this, getColumns().get(columnIndex));
        }
    }

    /**
     * Called when there's a request to scroll a column into view using {@link #scrollToColumn(TreeTableColumn)}
     * or {@link #scrollToColumnIndex(int)}
     */
    private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumn;

    public void setOnScrollToColumn(EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt; value) {
        onScrollToColumnProperty().set(value);
    }

    public EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt; getOnScrollToColumn() {
        if( onScrollToColumn != null ) {
            return onScrollToColumn.get();
        }
        return null;
    }

    public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumnProperty() {
        if( onScrollToColumn == null ) {
            onScrollToColumn = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt;&gt;() {
                @Override
                protected void invalidated() {
                    EventType&lt;ScrollToEvent&lt;TreeTableColumn&lt;S, ?&gt;&gt;&gt; type = ScrollToEvent.scrollToColumn();
                    setEventHandler(type, get());
                }
                @Override
                public Object getBean() {
                    return TreeTableView.this;
                }

                @Override
                public String getName() {
                    return &quot;onScrollToColumn&quot;;
                }
            };
        }
        return onScrollToColumn;
    }

    /**
     * Returns the index position of the given TreeItem, assuming that it is
     * currently accessible through the tree hierarchy (most notably, that all
     * parent tree items are expanded). If a parent tree item is collapsed,
     * the result is that this method will return -1 to indicate that the
     * given tree item is not accessible in the tree.
     *
     * @param item The TreeItem for which the index is sought.
     * @return An integer representing the location in the current TreeTableView of the
     *      first instance of the given TreeItem, or -1 if it is null or can not
     *      be found (for example, if a parent (all the way up to the root) is
     *      collapsed).
     */
    public int getRow(TreeItem&lt;S&gt; item) {
        return TreeUtil.getRow(item, getRoot(), expandedItemCountDirty, isShowRoot());
    }

    /**
     * Returns the TreeItem in the given index, or null if it is out of bounds.
     *
     * @param row The index of the TreeItem being sought.
     * @return The TreeItem in the given index, or null if it is out of bounds.
     */
    public TreeItem&lt;S&gt; getTreeItem(int row) {
        if (row &lt; 0) return null;

        // normalize the requested row based on whether showRoot is set
        final int _row = isShowRoot() ? row : (row + 1);

        if (expandedItemCountDirty) {
            updateExpandedItemCount(getRoot());
        } else {
            if (treeItemCacheMap.containsKey(_row)) {
                SoftReference&lt;TreeItem&lt;S&gt;&gt; treeItemRef = treeItemCacheMap.get(_row);
                TreeItem&lt;S&gt; treeItem = treeItemRef.get();
                if (treeItem != null) {
                    return treeItem;
                }
            }
        }

        TreeItem&lt;S&gt; treeItem = TreeUtil.getItem(getRoot(), _row, expandedItemCountDirty);
        treeItemCacheMap.put(_row, new SoftReference&lt;&gt;(treeItem));
        return treeItem;
    }

    /**
     * Returns the number of levels of 'indentation' of the given TreeItem,
     * based on how many times getParent() can be recursively called. If the
     * given TreeItem is the root node of this TreeTableView, or if the TreeItem
     * does not have any parent set, the returned value will be zero. For each
     * time getParent() is recursively called, the returned value is incremented
     * by one.
     *
     * @param node The TreeItem for which the level is needed.
     * @return An integer representing the number of parents above the given node,
     *         or -1 if the given TreeItem is null.
     */
    public int getTreeItemLevel(TreeItem&lt;?&gt; node) {
        final TreeItem&lt;?&gt; root = getRoot();

        if (node == null) return -1;
        if (node == root) return 0;

        int level = 0;
        TreeItem&lt;?&gt; parent = node.getParent();
        while (parent != null) {
            level++;

            if (parent == root) {
                break;
            }

            parent = parent.getParent();
        }

        return level;
    }

    /**
     * The TreeTableColumns that are part of this TableView. As the user reorders
     * the TableView columns, this list will be updated to reflect the current
     * visual ordering.
     *
     * &lt;p&gt;Note: to display any data in a TableView, there must be at least one
     * TreeTableColumn in this ObservableList.&lt;/p&gt;
     * @return the table table column
     */
    public final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; getColumns() {
        return columns;
    }

    /**
     * The sortOrder list defines the order in which {@link TreeTableColumn} instances
     * are sorted. An empty sortOrder list means that no sorting is being applied
     * on the TableView. If the sortOrder list has one TreeTableColumn within it,
     * the TableView will be sorted using the
     * {@link TreeTableColumn#sortTypeProperty() sortType} and
     * {@link TreeTableColumn#comparatorProperty() comparator} properties of this
     * TreeTableColumn (assuming
     * {@link TreeTableColumn#sortableProperty() TreeTableColumn.sortable} is true).
     * If the sortOrder list contains multiple TreeTableColumn instances, then
     * the TableView is firstly sorted based on the properties of the first
     * TreeTableColumn. If two elements are considered equal, then the second
     * TreeTableColumn in the list is used to determine ordering. This repeats until
     * the results from all TreeTableColumn comparators are considered, if necessary.
     *
     * @return An ObservableList containing zero or more TreeTableColumn instances.
     */
    public final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; getSortOrder() {
        return sortOrder;
    }

    /**
     * Applies the currently installed resize policy against the given column,
     * resizing it based on the delta value provided.
     * @param column the column
     * @param delta the delta
     * @return true if column resizing is applied
     */
    public boolean resizeColumn(TreeTableColumn&lt;S,?&gt; column, double delta) {
        if (column == null || Double.compare(delta, 0.0) == 0) return false;

        boolean allowed = getColumnResizePolicy().call(new TreeTableView.ResizeFeatures&lt;S&gt;(TreeTableView.this, column, delta));
        if (!allowed) return false;
        return true;
    }

    /**
     * Causes the cell at the given row/column view indexes to switch into
     * its editing state, if it is not already in it, and assuming that the
     * TableView and column are also editable.
     * @param row the row
     * @param column the column
     */
    public void edit(int row, TreeTableColumn&lt;S,?&gt; column) {
        if (!isEditable() || (column != null &amp;&amp; ! column.isEditable())) {
            return;
        }

        if (row &lt; 0 &amp;&amp; column == null) {
<A NAME="7"></A>            setEditingCell(null);
        } else {
            setEditingCell(new TreeTablePosition&lt;&gt;(this, row, column));
        <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#7',2,'match37-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
    }

    /**
     * Returns an unmodifiable list containing the currently visible leaf columns.
     * @return an unmodifiable list containing the currently visible leaf columns
     */
    public ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; getVisibleLeafColumns() {
        return unmodifiableVisibleLeafColumns;
    }

    /**
     * Returns the position of the given column, relative to all other
     * visible leaf columns.
     * @param column the column
     * @return the position of the given column, relative to all other
     * visible leaf columns
     */
    public int getVisibleLeafIndex(TreeTableColumn&lt;S,?&gt; column) {
        return getVisibleLeafColumns().indexOf(column);
    }

    /**
     * Returns the TreeTableColumn in the given column index, relative to all other
     * visible leaf columns.
     * @param column the column
     * @return the TreeTableColumn in the given column index, relative to all other
     * visible leaf columns
     */
    public TreeTableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {</B></FONT>
        if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
        return visibleLeafColumns.get(column);
    }

    /**
     * The sort method forces the TreeTableView to re-run its sorting algorithm. More
     * often than not it is not necessary to call this method directly, as it is
     * automatically called when the {@link #getSortOrder() sort order},
     * {@link #sortPolicyProperty() sort policy}, or the state of the
     * TreeTableColumn {@link TreeTableColumn#sortTypeProperty() sort type} properties
     * change. In other words, this method should only be called directly when
     * something external changes and a sort is required.
     */
    public void sort() {
        final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = getSortOrder();

        // update the Comparator property
        final Comparator&lt;TreeItem&lt;S&gt;&gt; oldComparator = getComparator();
        setComparator(sortOrder.isEmpty() ? null : new TableColumnComparatorBase.TreeTableColumnComparator(sortOrder));

        // fire the onSort event and check if it is consumed, if
        // so, don't run the sort
        SortEvent&lt;TreeTableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TreeTableView.this, TreeTableView.this);
        fireEvent(sortEvent);
        if (sortEvent.isConsumed()) {
            // if the sort is consumed we could back out the last action (the code
            // is commented out right below), but we don't as we take it as a
            // sign that the developer has decided to handle the event themselves.

            // sortLock = true;
            // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
            // sortLock = false;
            return;
        }

        final List&lt;TreeTablePosition&lt;S,?&gt;&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
        final int itemCount = prevState.size();

        // we set makeAtomic to true here, so that we don't fire intermediate
        // sort events - instead we send a single permutation event at the end
        // of this method.
        getSelectionModel().startAtomic();

        // get the sort policy and run it
        Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
        if (sortPolicy == null) return;
        Boolean success = sortPolicy.call(this);

        getSelectionModel().stopAtomic();

        if (success == null || ! success) {
            // the sort was a failure. Need to backout if possible
            sortLock = true;
            TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
            setComparator(oldComparator);
            sortLock = false;
        } else {
            // sorting was a success, now we possibly fire an event on the
            // selection model that the items list has 'permutated' to a new ordering

            // FIXME we should support alternative selection model implementations!
            if (getSelectionModel() instanceof TreeTableViewArrayListSelectionModel) {
                final TreeTableViewArrayListSelectionModel&lt;S&gt; sm = (TreeTableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
                final ObservableList&lt;TreeTablePosition&lt;S, ?&gt;&gt; newState = sm.getSelectedCells();

                List&lt;TreeTablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
                for (int i = 0; i &lt; itemCount; i++) {
                    TreeTablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
                    if (!newState.contains(prevItem)) {
                        removed.add(prevItem);
                    }
                }

                if (!removed.isEmpty()) {
                    // the sort operation effectively permutates the selectedCells list,
                    // but we cannot fire a permutation event as we are talking about
                    // TreeTablePosition's changing (which may reside in the same list
                    // position before and after the sort). Therefore, we need to fire
                    // a single add/remove event to cover the added and removed positions.
                    ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(0, itemCount, removed, newState);
                    sm.fireCustomSelectedCellsListChangeEvent(c);
                }
            }
        }
    }

    /**
     * Calling {@code refresh()} forces the TreeTableView control to recreate and
     * repopulate the cells necessary to populate the visual bounds of the control.
     * In other words, this forces the TreeTableView to update what it is showing to
     * the user. This is useful in cases where the underlying data source has
     * changed in a way that is not observed by the TreeTableView itself.
     *
     * @since JavaFX 8u60
     */
    public void refresh() {
        getProperties().put(Properties.RECREATE, Boolean.TRUE);
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private boolean sortLock = false;
    private TableUtil.SortEventType lastSortEventType = null;
    private Object[] lastSortEventSupportInfo = null;

    private void doSort(final TableUtil.SortEventType sortEventType, final Object... supportInfo) {
        if (sortLock) {
            return;
        }

        this.lastSortEventType = sortEventType;
        this.lastSortEventSupportInfo = supportInfo;
        sort();
        this.lastSortEventType = null;
        this.lastSortEventSupportInfo = null;
    }

    private void updateExpandedItemCount(TreeItem&lt;S&gt; treeItem) {
        setExpandedItemCount(TreeUtil.updateExpandedItemCount(treeItem, expandedItemCountDirty, isShowRoot()));

        if (expandedItemCountDirty) {
            // this is a very inefficient thing to do, but for now having a cache
            // is better than nothing at all...
            treeItemCacheMap.clear();
        }

        expandedItemCountDirty = false;
    }

    private void updateRootExpanded() {
        // if we aren't showing the root, and the root isn't expanded, we expand
        // it now so that something is shown.
        if (!isShowRoot() &amp;&amp; getRoot() != null &amp;&amp; ! getRoot().isExpanded()) {
            getRoot().setExpanded(true);
        }
    }


    // --- Content width
    private void setContentWidth(double contentWidth) {
        this.contentWidth = contentWidth;
        if (isInited) {
            // sometimes the current column resize policy will have to modify the
            // column width of all columns in the table if the table width changes,
            // so we short-circuit the resize function and just go straight there
            // with a null TreeTableColumn, which indicates to the resize policy function
            // that it shouldn't actually do anything specific to one column.
            getColumnResizePolicy().call(new TreeTableView.ResizeFeatures&lt;S&gt;(TreeTableView.this, null, 0.0));
        }
    }

    /**
     * Recomputes the currently visible leaf columns in this TableView.
     */
    private void updateVisibleLeafColumns() {
        // update visible leaf columns list
        List&lt;TreeTableColumn&lt;S,?&gt;&gt; cols = new ArrayList&lt;TreeTableColumn&lt;S,?&gt;&gt;();
        buildVisibleLeafColumns(getColumns(), cols);
        visibleLeafColumns.setAll(cols);

        // sometimes the current column resize policy will have to modify the
        // column width of all columns in the table if the table width changes,
        // so we short-circuit the resize function and just go straight there
        // with a null TreeTableColumn, which indicates to the resize policy function
        // that it shouldn't actually do anything specific to one column.
        getColumnResizePolicy().call(new TreeTableView.ResizeFeatures&lt;S&gt;(TreeTableView.this, null, 0.0));
    }

    private void buildVisibleLeafColumns(List&lt;TreeTableColumn&lt;S,?&gt;&gt; cols, List&lt;TreeTableColumn&lt;S,?&gt;&gt; vlc) {
        for (TreeTableColumn&lt;S,?&gt; c : cols) {
            if (c == null) continue;

            boolean hasChildren = ! c.getColumns().isEmpty();

            if (hasChildren) {
                buildVisibleLeafColumns(c.getColumns(), vlc);
            } else if (c.isVisible()) {
                vlc.add(c);
            }
        }
    }



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;tree-table-view&quot;;

    private static final PseudoClass PSEUDO_CLASS_CELL_SELECTION =
            PseudoClass.getPseudoClass(&quot;cell-selection&quot;);
    private static final PseudoClass PSEUDO_CLASS_ROW_SELECTION =
            PseudoClass.getPseudoClass(&quot;row-selection&quot;);

    private static class StyleableProperties {
        private static final CssMetaData&lt;TreeTableView&lt;?&gt;,Number&gt; FIXED_CELL_SIZE =
                new CssMetaData&lt;TreeTableView&lt;?&gt;,Number&gt;(&quot;-fx-fixed-cell-size&quot;,
                                                     SizeConverter.getInstance(),
                                                     Region.USE_COMPUTED_SIZE) {

                    @Override public Double getInitialValue(TreeTableView&lt;?&gt; node) {
                        return node.getFixedCellSize();
                    }

                    @Override public boolean isSettable(TreeTableView&lt;?&gt; n) {
                        return n.fixedCellSize == null || !n.fixedCellSize.isBound();
                    }

                    @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(TreeTableView&lt;?&gt; n) {
                        return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;) n.fixedCellSizeProperty();
                    }
                };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                    new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
            styleables.add(FIXED_CELL_SIZE);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
        return getClassCssMetaData();
    }

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new TreeTableViewSkin&lt;S&gt;(this);
    }



    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case ROW_COUNT: return getExpandedItemCount();
            case COLUMN_COUNT: return getVisibleLeafColumns().size();

            /*
             * TreeTableViewSkin returns TreeTableRows back to TreeTableView.
             * TreeTableRowSkin returns TreeTableCells back to TreeTableRow.
             */
            case SELECTED_ITEMS: {
                @SuppressWarnings(&quot;unchecked&quot;)
                ObservableList&lt;TreeTableRow&lt;S&gt;&gt; rows = (ObservableList&lt;TreeTableRow&lt;S&gt;&gt;)super.queryAccessibleAttribute(attribute, parameters);
                List&lt;Node&gt; selection = new ArrayList&lt;&gt;();
                for (TreeTableRow&lt;S&gt; row : rows) {
                    @SuppressWarnings(&quot;unchecked&quot;)
                    ObservableList&lt;Node&gt; cells = (ObservableList&lt;Node&gt;)row.queryAccessibleAttribute(attribute, parameters);
                    if (cells != null) selection.addAll(cells);
                }
                return FXCollections.observableArrayList(selection);
            }
            case FOCUS_ITEM: {
                Node row = (Node)super.queryAccessibleAttribute(attribute, parameters);
                if (row == null) return null;
                Node cell = (Node)row.queryAccessibleAttribute(attribute, parameters);
                /* cell equals to null means the row is a placeholder node */
                return cell != null ?  cell : row;
            }
            case CELL_AT_ROW_COLUMN: {
                @SuppressWarnings(&quot;unchecked&quot;)
                TreeTableRow&lt;S&gt; row = (TreeTableRow&lt;S&gt;)super.queryAccessibleAttribute(attribute, parameters);
                return row != null ? row.queryAccessibleAttribute(attribute, parameters) : null;
            }
            case MULTIPLE_SELECTION: {
                TreeTableViewSelectionModel&lt;S&gt; sm = getSelectionModel();
                return sm != null &amp;&amp; sm.getSelectionMode() == SelectionMode.MULTIPLE;
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /***************************************************************************
     *                                                                         *
     * Support Classes                                                         *
     *                                                                         *
     **************************************************************************/

     /**
      * An immutable wrapper class for use in the TableView
     * {@link TreeTableView#columnResizePolicyProperty() column resize} functionality.
      * @since JavaFX 8.0
      */
     public static class ResizeFeatures&lt;S&gt; extends ResizeFeaturesBase&lt;TreeItem&lt;S&gt;&gt; {
        private TreeTableView&lt;S&gt; treeTable;

        /**
         * Creates an instance of this class, with the provided TreeTableView,
         * TreeTableColumn and delta values being set and stored in this immutable
         * instance.
         *
         * @param treeTable The TreeTableView upon which the resize operation is occurring.
         * @param column The column upon which the resize is occurring, or null
         *      if this ResizeFeatures instance is being created as a result of a
         *      TreeTableView resize operation.
         * @param delta The amount of horizontal space added or removed in the
         *      resize operation.
         */
        public ResizeFeatures(TreeTableView&lt;S&gt; treeTable, TreeTableColumn&lt;S,?&gt; column, Double delta) {
            super(column, delta);
            this.treeTable = treeTable;
        }

        /**
         * Returns the column upon which the resize is occurring, or null
         * if this ResizeFeatures instance was created as a result of a
         * TreeTableView resize operation.
         */
        @Override public TreeTableColumn&lt;S,?&gt; getColumn() {
            return (TreeTableColumn&lt;S,?&gt;) super.getColumn();
        }

        /**
         * Returns the TreeTableView upon which the resize operation is occurring.
         * @return the TreeTableView upon which the resize operation is occurring
         */
        public TreeTableView&lt;S&gt; getTable() { return treeTable; }
    }



    /**
     * An {@link Event} subclass used specifically in TreeTableView for representing
     * edit-related events. It provides additional API to easily access the
     * TreeItem that the edit event took place on, as well as the input provided
     * by the end user.
     *
     * @param &lt;S&gt; The type of the input, which is the same type as the TreeTableView
     *      itself.
     * @since JavaFX 8.0
     */
    public static class EditEvent&lt;S&gt; extends Event {
        private static final long serialVersionUID = -4437033058917528976L;

        /**
         * Common supertype for all edit event types.
         */
        public static final EventType&lt;?&gt; ANY = EDIT_ANY_EVENT;

        private final TreeTableView&lt;S&gt; source;
        private final S oldValue;
        private final S newValue;
        private transient final TreeItem&lt;S&gt; treeItem;

        /**
         * Creates a new EditEvent instance to represent an edit event. This
         * event is used for {@link #editStartEvent()},
         * {@link #editCommitEvent()} and {@link #editCancelEvent()} types.
         * @param source the source
         * @param eventType the eventType
         * @param treeItem the treeItem
         * @param oldValue the oldValue
         * @param newValue the newValue
         */
        public EditEvent(TreeTableView&lt;S&gt; source,
                         EventType&lt;? extends TreeTableView.EditEvent&gt; eventType,
                         TreeItem&lt;S&gt; treeItem, S oldValue, S newValue) {
            super(source, Event.NULL_SOURCE_TARGET, eventType);
            this.source = source;
            this.oldValue = oldValue;
            this.newValue = newValue;
            this.treeItem = treeItem;
        }

        /**
         * Returns the TreeTableView upon which the edit took place.
         * @return the TreeTableView upon which the edit took place
         */
        @Override public TreeTableView&lt;S&gt; getSource() {
            return source;
        }

        /**
         * Returns the {@link TreeItem} upon which the edit took place.
         * @return the {@link TreeItem} upon which the edit took place
         */
        public TreeItem&lt;S&gt; getTreeItem() {
            return treeItem;
        }

        /**
         * Returns the new value input into the TreeItem by the end user.
         * @return the new value input into the TreeItem by the end user
         */
        public S getNewValue() {
            return newValue;
        }

        /**
         * Returns the old value that existed in the TreeItem prior to the current
         * edit event.
         * @return the old value that existed in the TreeItem prior to the current
         * edit event
         */
        public S getOldValue() {
            return oldValue;
        }
    }



     /**
     * A simple extension of the {@link SelectionModel} abstract class to
     * allow for special support for TreeTableView controls.
      *
     * @since JavaFX 8.0
     */
    public static abstract class TreeTableViewSelectionModel&lt;S&gt; extends
            TableSelectionModel&lt;TreeItem&lt;S&gt;&gt; {

        /***********************************************************************
         *                                                                     *
         * Private fields                                                      *
         *                                                                     *
         **********************************************************************/

        private final TreeTableView&lt;S&gt; treeTableView;


        /***********************************************************************
         *                                                                     *
         * Constructors                                                        *
         *                                                                     *
         **********************************************************************/

        /**
         * Builds a default TreeTableViewSelectionModel instance with the provided
         * TreeTableView.
         * @param treeTableView The TreeTableView upon which this selection model should
         *      operate.
         * @throws NullPointerException TreeTableView can not be null.
         */
        public TreeTableViewSelectionModel(final TreeTableView&lt;S&gt; treeTableView) {
            if (treeTableView == null) {
                throw new NullPointerException(&quot;TreeTableView can not be null&quot;);
            }

            this.treeTableView = treeTableView;
        }



        /***********************************************************************
         *                                                                     *
         * Abstract API                                                        *
         *                                                                     *
         **********************************************************************/

         /**
         * A read-only ObservableList representing the currently selected cells
         * in this TreeTableView. Rather than directly modify this list, please
         * use the other methods provided in the TreeTableViewSelectionModel.
         * @return a list of selected cells
         */
        public abstract ObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt; getSelectedCells();



        /***********************************************************************
         *                                                                     *
         * Public API                                                          *
         *                                                                     *
         **********************************************************************/

         /**
          * Returns the TreeTableView instance that this selection model is installed in.
         * @return the TreeTableView instance that this selection model is installed in
          */
         public TreeTableView&lt;S&gt; getTreeTableView() {
             return treeTableView;
         }

         /** {@inheritDoc} */
         @Override public TreeItem&lt;S&gt; getModelItem(int index) {
             return treeTableView.getTreeItem(index);
         }

         /** {@inheritDoc} */
         @Override protected int getItemCount() {
             return treeTableView.getExpandedItemCount();
         }

         /** {@inheritDoc} */
         @Override public void focus(int row) {
             focus(row, null);
         }

         /** {@inheritDoc} */
         @Override public int getFocusedIndex() {
             return getFocusedCell().getRow();
         }

         /** {@inheritDoc} */
         @Override public void selectRange(int minRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; minColumn,
                                           int maxRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; maxColumn) {
             final int minColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)minColumn);
             final int maxColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)maxColumn);
             for (int _row = minRow; _row &lt;= maxRow; _row++) {
                 for (int _col = minColumnIndex; _col &lt;= maxColumnIndex; _col++) {
                     select(_row, treeTableView.getVisibleLeafColumn(_col));
                 }
             }
         }



        /***********************************************************************
         *                                                                     *
         * Private implementation                                              *
         *                                                                     *
         **********************************************************************/

         private void focus(int row, TreeTableColumn&lt;S,?&gt; column) {
             focus(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, column));
         }

         private void focus(TreeTablePosition&lt;S,?&gt; pos) {
             if (getTreeTableView().getFocusModel() == null) return;

             getTreeTableView().getFocusModel().focus(pos.getRow(), pos.getTableColumn());
         }

         private TreeTablePosition&lt;S,?&gt; getFocusedCell() {
             if (treeTableView.getFocusModel() == null) {
                 return new TreeTablePosition&lt;&gt;(treeTableView, -1, null);
             }
             return treeTableView.getFocusModel().getFocusedCell();
         }
     }



    /**
     * A primitive selection model implementation, using a List&lt;Integer&gt; to store all
     * selected indices.
     */
    // package for testing
    static class TreeTableViewArrayListSelectionModel&lt;S&gt; extends TreeTableViewSelectionModel&lt;S&gt; {

        private final MappingChange.Map&lt;TreeTablePosition&lt;S,?&gt;,Integer&gt; cellToIndicesMap = f -&gt; f.getRow();

        private TreeTableView&lt;S&gt; treeTableView = null;

        /***********************************************************************
         *                                                                     *
         * Constructors                                                        *
         *                                                                     *
         **********************************************************************/

        public TreeTableViewArrayListSelectionModel(final TreeTableView&lt;S&gt; treeTableView) {
            super(treeTableView);
            this.treeTableView = treeTableView;

            this.treeTableView.rootProperty().addListener(weakRootPropertyListener);
            this.treeTableView.showRootProperty().addListener(showRootPropertyListener);
            updateTreeEventListener(null, treeTableView.getRoot());

            selectedCellsMap = new SelectedCellsMap&lt;TreeTablePosition&lt;S,?&gt;&gt;(this::fireCustomSelectedCellsListChangeEvent) {
                @Override public boolean isCellSelectionEnabled() {
                    return TreeTableViewArrayListSelectionModel.this.isCellSelectionEnabled();
                }
            };

            selectedCellsSeq = new ReadOnlyUnbackedObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt;() {
                @Override public TreeTablePosition&lt;S,?&gt; get(int i) {
                    return selectedCellsMap.get(i);
                }

                @Override public int size() {
                    return selectedCellsMap.size();
                }
            };
//            selectedCellsSeq.addListener((ListChangeListener&lt;? super TreeTablePosition&lt;S,?&gt;&gt;) c -&gt; {
//                ControlUtils.updateSelectedIndices(this, c);
//            });

            updateDefaultSelection();

            cellSelectionEnabledProperty().addListener(o -&gt; {
                updateDefaultSelection();
                TableCellBehaviorBase.setAnchor(treeTableView, getFocusedCell(), true);
            });
        }

        private void dispose() {
            this.treeTableView.rootProperty().removeListener(weakRootPropertyListener);
            this.treeTableView.showRootProperty().removeListener(showRootPropertyListener);

            TreeItem&lt;S&gt; root = this.treeTableView.getRoot();
            if (root != null) {
                root.removeEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
            }
        }

        private void updateTreeEventListener(TreeItem&lt;S&gt; oldRoot, TreeItem&lt;S&gt; newRoot) {
            if (oldRoot != null &amp;&amp; weakTreeItemListener != null) {
                oldRoot.removeEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
            }

            if (newRoot != null) {
                weakTreeItemListener = new WeakEventHandler&lt;&gt;(treeItemListener);
                newRoot.addEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
            }
        }

        private ChangeListener&lt;TreeItem&lt;S&gt;&gt; rootPropertyListener = (observable, oldValue, newValue) -&gt; {
            updateDefaultSelection();

            updateTreeEventListener(oldValue, newValue);
        };

        private InvalidationListener showRootPropertyListener = o -&gt; {
            shiftSelection(0, treeTableView.isShowRoot() ? 1 : -1, null);
        };

        private EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; treeItemListener = new EventHandler&lt;&gt;() {
            @Override public void handle(TreeItem.TreeModificationEvent&lt;S&gt; e) {

                if (getSelectedIndex() == -1 &amp;&amp; getSelectedItem() == null) return;

                final TreeItem&lt;S&gt; treeItem = e.getTreeItem();
                if (treeItem == null) return;

                final int oldSelectedIndex = getSelectedIndex();

                treeTableView.expandedItemCountDirty = true;

                // we only shift selection from this row - everything before it
                // is safe. We might change this below based on certain criteria
                int startRow = treeTableView.getRow(treeItem);

                int shift = 0;
                ListChangeListener.Change&lt;? extends TreeItem&lt;?&gt;&gt; change = e.getChange();
                if (change != null) {
                    change.next();
                }

                do {
                    final int addedSize = change == null ? 0 : change.getAddedSize();
                    final int removedSize = change == null ? 0 : change.getRemovedSize();

                    if (e.wasExpanded()) {
                        // need to shuffle selection by the number of visible children
                        shift += treeItem.getExpandedDescendentCount(false) - 1;
                        startRow++;
                    } else if (e.wasCollapsed()) {
                        // remove selection from any child treeItem, and also determine
                        // if any child item was selected (in which case the parent
                        // takes the selection on collapse)
                        treeItem.getExpandedDescendentCount(false);
                        final int count = treeItem.previousExpandedDescendentCount;

                        final int selectedIndex = getSelectedIndex();
                        final boolean wasPrimarySelectionInChild =
                                selectedIndex &gt;= (startRow + 1) &amp;&amp;
                                        selectedIndex &lt; (startRow + count);

                        boolean wasAnyChildSelected = false;
                        final boolean isCellSelectionMode = isCellSelectionEnabled();
                        ObservableList&lt;TreeTableColumn&lt;S, ?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();

                        selectedIndices._beginChange();
                        final int from = startRow + 1;
                        final int to = startRow + count;
                        final List&lt;Integer&gt; removed = new ArrayList&lt;&gt;();
                        TreeTableColumn&lt;S, ?&gt; selectedColumn = null;
                        for (int i = from; i &lt; to; i++) {
                            // we have to handle cell selection mode differently than
                            // row selection mode. Refer to RT-34103 for the bug report
                            // that drove this change, but in short the issue was that
                            // when collapsing a branch that had selection, we were
                            // always calling isSelected(row), but that always returns
                            // false in cell selection mode.
                            if (isCellSelectionMode) {
                                for (int column = 0; column &lt; columns.size(); column++) {
                                    final TreeTableColumn&lt;S, ?&gt; col = columns.get(column);
                                    if (isSelected(i, col)) {
                                        wasAnyChildSelected = true;
                                        clearSelection(i, col);
                                        selectedColumn = col;
                                    }
                                }
                            } else {
                                if (isSelected(i)) {
                                    wasAnyChildSelected = true;
                                    removed.add(i);
                                }
                            }
                        }

                        ControlUtils.reducingChange(selectedIndices, removed);

                        for (int index : removed) {
                            startAtomic();
                            // we pass in false here to prevent a lookup into the TreeItem, as it is unnecessary
                            // and results in JDK-8152396
                            clearSelection(new TreeTablePosition&lt;&gt;(treeTableView, index, null, false));
                            stopAtomic();
                        }
                        selectedIndices._endChange();

                        // put selection onto the newly-collapsed tree item
                        if (wasPrimarySelectionInChild &amp;&amp; wasAnyChildSelected) {
                            select(startRow, selectedColumn);
                        }

                        shift += -count + 1;
                        startRow++;
                    } else if (e.wasPermutated()) {
                        // General approach:
                        //   -- detected a sort has happened
                        //   -- Create a permutation lookup map (1)
                        //   -- dump all the selected indices into a list (2)
                        //   -- create a list containing the new indices (3)
                        //   -- for each previously-selected index (4)
                        //     -- if index is in the permutation lookup map
                        //       -- add the new index to the new indices list
                        //   -- Perform batch selection (5)

                        startAtomic();

                        final int offset = startRow + 1;

                        // (1)
                        int length = e.getTo() - e.getFrom();
                        HashMap&lt;Integer, Integer&gt; pMap = new HashMap&lt;&gt; (length);
                        for (int i = e.getFrom(); i &lt; e.getTo(); i++) {
                            pMap.put(i, e.getChange().getPermutation(i));
                        }

                        // (2)
                        List&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedIndices = new ArrayList&lt;&gt;(getSelectedCells());

                        // (3)
                        List&lt;TreeTablePosition&lt;S,?&gt;&gt; newIndices = new ArrayList&lt;&gt;(selectedIndices.size());

                        // (4)
                        boolean selectionIndicesChanged = false;
                        for (int i = 0; i &lt; selectedIndices.size(); i++) {
                            final TreeTablePosition&lt;S,?&gt; oldIndex = selectedIndices.get(i);
                            final int oldRow = oldIndex.getRow() - offset;

                            if (pMap.containsKey(oldRow)) {
                                int newIndex = pMap.get(oldRow) + offset;

                                selectionIndicesChanged = selectionIndicesChanged || newIndex != oldRow;

                                newIndices.add(new TreeTablePosition&lt;&gt;(oldIndex.getTreeTableView(), newIndex, oldIndex.getTableColumn()));
                            }

                            // check if the root element of this event was selected, so that we can retain it
                            if (oldIndex.getRow() == startRow) {
                                newIndices.add(new TreeTablePosition&lt;&gt;(oldIndex.getTreeTableView(), oldIndex.getRow(), oldIndex.getTableColumn()));
                            }
                        }

                        if (selectionIndicesChanged) {
                            // (5)
                            quietClearSelection();
                            stopAtomic();

                            selectedCellsMap.setAll(newIndices);

                            final int offsetOldIndex = oldSelectedIndex - offset;
                            if (offsetOldIndex &gt;= 0 &amp;&amp; offsetOldIndex &lt; getItemCount()) {
                                int newIndex = e.getChange().getPermutation(offsetOldIndex);
                                setSelectedIndex(newIndex + offset);
                                focus(newIndex + offset);
                            }
                        } else {
                            stopAtomic();
                        }
                    } else if (e.wasAdded()) {
                        // shuffle selection by the number of added items
                        shift += treeItem.isExpanded() ? addedSize : 0;

                        // RT-32963: We were taking the startRow from the TreeItem
                        // in which the children were added, rather than from the
                        // actual position of the new child. This led to selection
                        // being moved off the parent TreeItem by mistake.
                        // The 'if (e.getAddedSize() == 1)' condition here was
                        // subsequently commented out due to RT-33894.
                        startRow = treeTableView.getRow(e.getChange().getAddedSubList().get(0));

                        TreeTablePosition&lt;S, ?&gt; anchor = TreeTableCellBehavior.getAnchor(treeTableView, null);
                        if (anchor != null) {
                            boolean isAnchorSelected = isSelected(anchor.getRow(), anchor.getTableColumn());
                            if (isAnchorSelected) {
                                TreeTablePosition&lt;S, ?&gt; newAnchor = new TreeTablePosition&lt;&gt;(treeTableView, anchor.getRow() + shift, anchor.getTableColumn());
                                TreeTableCellBehavior.setAnchor(treeTableView, newAnchor, false);
                            }
                        }
                    } else if (e.wasRemoved()) {
                        // shuffle selection by the number of removed items
                        shift += treeItem.isExpanded() ? -removedSize : 0;

                        // the start row is incorrect - it is _not_ the index of the
                        // TreeItem in which the children were removed from (which is
                        // what it currently represents). We need to take the 'from'
                        // value out of the event and make use of that to understand
                        // what actually changed inside the children list.
                        startRow += e.getFrom() + 1;

                        // whilst we are here, we should check if the removed items
                        // are part of the selectedItems list - and remove them
                        // from selection if they are (as per RT-15446)
                        final List&lt;Integer&gt; selectedIndices = getSelectedIndices();
                        final List&lt;TreeItem&lt;S&gt;&gt; selectedItems = getSelectedItems();
                        final TreeItem&lt;S&gt; selectedItem = getSelectedItem();
                        final List&lt;? extends TreeItem&lt;S&gt;&gt; removedChildren = e.getChange().getRemoved();

                        for (int i = 0; i &lt; selectedIndices.size() &amp;&amp; !selectedItems.isEmpty(); i++) {
                            int index = selectedIndices.get(i);
                            if (index &gt; selectedItems.size()) break;

                            if (removedChildren.size() == 1 &amp;&amp;
                                    selectedItems.size() == 1 &amp;&amp;
                                    selectedItem != null &amp;&amp;
                                    selectedItem.equals(removedChildren.get(0))) {
                                // Bug fix for RT-28637
                                if (oldSelectedIndex &lt; getItemCount()) {
                                    final int previousRow = oldSelectedIndex == 0 ? 0 : oldSelectedIndex - 1;
                                    TreeItem&lt;S&gt; newSelectedItem = getModelItem(previousRow);
                                    if (!selectedItem.equals(newSelectedItem)) {
                                        clearAndSelect(previousRow);
                                    }
                                }
                            }
                        }
                    }
                } while (e.getChange() != null &amp;&amp; e.getChange().next());

                shiftSelection(startRow, shift, new Callback&lt;ShiftParams, Void&gt;() {
                    @Override public Void call(ShiftParams param) {

                        // we make the shifts atomic, as otherwise listeners to
                        // the items / indices lists get a lot of intermediate
                        // noise. They eventually get the summary event fired
                        // from within shiftSelection, so this is ok.
                        startAtomic();

                        final int clearIndex = param.getClearIndex();
                        final int setIndex = param.getSetIndex();
                        TreeTablePosition&lt;S,?&gt; oldTP = null;
                        if (clearIndex &gt; -1) {
                            for (int i = 0; i &lt; selectedCellsMap.size(); i++) {
                                TreeTablePosition&lt;S,?&gt; tp = selectedCellsMap.get(i);
                                if (tp.getRow() == clearIndex) {
                                    oldTP = tp;
                                    selectedCellsMap.remove(tp);
                                } else if (tp.getRow() == setIndex &amp;&amp; !param.isSelected()) {
                                    selectedCellsMap.remove(tp);
                                }
                            }
                        }

                        if (oldTP != null &amp;&amp; param.isSelected()) {
                            TreeTablePosition&lt;S,?&gt; newTP = new TreeTablePosition&lt;&gt;(
                                    treeTableView, param.getSetIndex(), oldTP.getTableColumn());

                            selectedCellsMap.add(newTP);
                        }

                        stopAtomic();

                        return null;
                    }
                });
            }
        };

        private WeakChangeListener&lt;TreeItem&lt;S&gt;&gt; weakRootPropertyListener =
                new WeakChangeListener&lt;&gt;(rootPropertyListener);

        private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakTreeItemListener;



        /***********************************************************************
         *                                                                     *
         * Observable properties (and getters/setters)                         *
         *                                                                     *
         **********************************************************************/

        // the only 'proper' internal data structure, selectedItems and selectedIndices
        // are both 'read-only and unbacked'.
        private final SelectedCellsMap&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedCellsMap;

        private final ReadOnlyUnbackedObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedCellsSeq;
        @Override public ObservableList&lt;TreeTablePosition&lt;S,?&gt;&gt; getSelectedCells() {
            return selectedCellsSeq;
        }


        /***********************************************************************
         *                                                                     *
         * Internal properties                                                 *
         *                                                                     *
         **********************************************************************/



        /***********************************************************************
         *                                                                     *
         * Public selection API                                                *
         *                                                                     *
         **********************************************************************/

        @Override public void clearAndSelect(int row) {
            clearAndSelect(row, null);
        }

        @Override public void clearAndSelect(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) return;

            final TreeTablePosition&lt;S,?&gt; newTablePosition = new TreeTablePosition&lt;&gt;(getTreeTableView(), row, (TreeTableColumn&lt;S,?&gt;)column);
            final boolean isCellSelectionEnabled = isCellSelectionEnabled();

            // replace the anchor
            TreeTableCellBehavior.setAnchor(treeTableView, newTablePosition, false);

            // firstly we make a copy of the selection, so that we can send out
            // the correct details in the selection change event.
            List&lt;TreeTablePosition&lt;S,?&gt;&gt; previousSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());

            // secondly we check if we can short-circuit out of here because the new selection
            // equals the current selection
            final boolean wasSelected = isSelected(row, column);
            if (wasSelected &amp;&amp; previousSelection.size() == 1) {
                // before we return, we double-check that the selected item
                // is equal to the item in the given index
                TreeTablePosition&lt;S,?&gt; selectedCell = getSelectedCells().get(0);
                if (getSelectedItem() == getModelItem(row)) {
                    if (selectedCell.getRow() == row &amp;&amp; selectedCell.getTableColumn() == column) {
                        return;
                    }
                }
            }

            // RT-32411: We used to call quietClearSelection() here, but this
            // resulted in the selectedItems and selectedIndices lists never
            // reporting that they were empty.
            // makeAtomic toggle added to resolve RT-32618
            startAtomic();

            // then clear the current selection
            clearSelection();

            // and select the new cell
            select(row, column);

            stopAtomic();

            // We remove the new selection from the list seeing as it is not removed.
            if (isCellSelectionEnabled) {
                previousSelection.remove(newTablePosition);
            } else {
                for (TreeTablePosition&lt;S,?&gt; tp : previousSelection) {
                    if (tp.getRow() == row) {
                        previousSelection.remove(tp);
                        break;
                    }
                }
            }

            // fire off a single add/remove/replace notification (rather than
            // individual remove and add notifications) - see RT-33324
            ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; change;

            /*
             * getFrom() documentation:
             *   If wasAdded is true, the interval contains all the values that were added.
             *   If wasPermutated is true, the interval marks the values that were permutated.
             *   If wasRemoved is true and wasAdded is false, getFrom() and getTo() should
             *   return the same number - the place where the removed elements were positioned in the list.
             */
            if (wasSelected) {
                change = ControlUtils.buildClearAndSelectChange(selectedCellsSeq, previousSelection, row);
            } else {
                final int changeIndex = isCellSelectionEnabled ? 0 : Math.max(0, selectedCellsSeq.indexOf(newTablePosition));
                final int changeSize = isCellSelectionEnabled ? getSelectedCells().size() : 1;
                change = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(
                        changeIndex, changeIndex + changeSize, previousSelection, selectedCellsSeq);
//                selectedCellsSeq._beginChange();
//                selectedCellsSeq._nextAdd(changeIndex, changeIndex + changeSize);
//                selectedCellsSeq._nextRemove(changeIndex, previousSelection);
//                selectedCellsSeq._endChange();
            }

            fireCustomSelectedCellsListChangeEvent(change);
        }

        @Override public void select(int row) {
            select(row, null);
        }

        @Override public void select(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
            // TODO we need to bring in the TreeView selection stuff here...
            if (row &lt; 0 || row &gt;= getRowCount()) return;

            // if I'm in cell selection mode but the column is null, select each
            // of the contained cells individually
            if (isCellSelectionEnabled() &amp;&amp; column == null) {
                List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
                for (int i = 0; i &lt; columns.size(); i++) {
                    select(row, columns.get(i));
                }
                return;
            }

            if (TableCellBehavior.hasDefaultAnchor(treeTableView)) {
                TableCellBehavior.removeAnchor(treeTableView);
            }

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
            }
            selectedCellsMap.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, (TreeTableColumn&lt;S,?&gt;)column));

            updateSelectedIndex(row);
            focus(row, (TreeTableColumn&lt;S, ?&gt;) column);
        }

        @Override public void select(TreeItem&lt;S&gt; obj) {
            if (obj == null &amp;&amp; getSelectionMode() == SelectionMode.SINGLE) {
                clearSelection();
                return;
            }

            int firstIndex = treeTableView.getRow(obj);
            if (firstIndex &gt; -1) {
                if (isSelected(firstIndex)) {
                    return;
                }

                if (getSelectionMode() == SelectionMode.SINGLE) {
                    quietClearSelection();
                }

                select(firstIndex);
            } else {
                // if we are here, we did not find the item in the entire data model.
                // Even still, we allow for this item to be set to the give object.
                // We expect that in concrete subclasses of this class we observe the
                // data model such that we check to see if the given item exists in it,
                // whilst SelectedIndex == -1 &amp;&amp; SelectedItem != null.
                setSelectedIndex(-1);
                setSelectedItem(obj);
            }
        }

        @Override public void selectIndices(int row, int... rows) {
            if (rows == null) {
                select(row);
                return;
            }

            /*
             * Performance optimisation - if multiple selection is disabled, only
             * process the end-most row index.
             */
            int rowCount = getRowCount();

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();

                for (int i = rows.length - 1; i &gt;= 0; i--) {
                    int index = rows[i];
                    if (index &gt;= 0 &amp;&amp; index &lt; rowCount) {
                        select(index);
                        break;
                    }
                }

                if (selectedCellsMap.isEmpty()) {
                    if (row &gt; 0 &amp;&amp; row &lt; rowCount) {
                        select(row);
                    }
                }
            } else {
                int lastIndex = -1;
                Set&lt;TreeTablePosition&lt;S,?&gt;&gt; positions = new LinkedHashSet&lt;&gt;();

                // --- firstly, we special-case the non-varargs 'row' argument
                if (row &gt;= 0 &amp;&amp; row &lt; rowCount) {
                    // if I'm in cell selection mode, we want to select each
                    // of the contained cells individually
                    if (isCellSelectionEnabled()) {
                        List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
                        for (int column = 0; column &lt; columns.size(); column++) {
                            if (! selectedCellsMap.isSelected(row, column)) {
                                positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, columns.get(column)));
                            }
                        }
                    } else {
                        boolean match = selectedCellsMap.isSelected(row, -1);
                        if (!match) {
                            positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, null));
                        }
                    }

                    lastIndex = row;
                }

                // --- now we iterate through all varargs values
                for (int i = 0; i &lt; rows.length; i++) {
                    int index = rows[i];
                    if (index &lt; 0 || index &gt;= rowCount) continue;
                    lastIndex = index;

                    if (isCellSelectionEnabled()) {
                        List&lt;TreeTableColumn&lt;S,?&gt;&gt; columns = getTreeTableView().getVisibleLeafColumns();
                        for (int column = 0; column &lt; columns.size(); column++) {
                            if (! selectedCellsMap.isSelected(index, column)) {
                                positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), index, columns.get(column)));
                                lastIndex = index;
                            }
                        }
                    } else {
                        if (! selectedCellsMap.isSelected(index, -1)) {
                            // if we are here then we have successfully gotten through the for-loop above
                            positions.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), index, null));
                        }
                    }
                }

                selectedCellsMap.addAll(positions);

                if (lastIndex != -1) {
                    select(lastIndex);
                }
            }
        }

        @Override public void selectAll() {
            if (getSelectionMode() == SelectionMode.SINGLE) return;

            if (isCellSelectionEnabled()) {
                List&lt;TreeTablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
                TreeTableColumn&lt;S,?&gt; column;
                TreeTablePosition&lt;S,?&gt; tp = null;
                for (int col = 0; col &lt; getTreeTableView().getVisibleLeafColumns().size(); col++) {
                    column = getTreeTableView().getVisibleLeafColumns().get(col);
                    for (int row = 0; row &lt; getRowCount(); row++) {
                        tp = new TreeTablePosition&lt;&gt;(getTreeTableView(), row, column);
                        indices.add(tp);
                    }
                }
                selectedCellsMap.setAll(indices);

                if (tp != null) {
                    select(tp.getRow(), tp.getTableColumn());
                    focus(tp.getRow(), tp.getTableColumn());
                }
            } else {
                List&lt;TreeTablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
                for (int i = 0; i &lt; getRowCount(); i++) {
                    indices.add(new TreeTablePosition&lt;&gt;(getTreeTableView(), i, null));
                }
                selectedCellsMap.setAll(indices);

                int focusedIndex = getFocusedIndex();
                if (focusedIndex == -1) {
                    final int itemCount = getItemCount();
                    if (itemCount &gt; 0) {
                        select(itemCount - 1);
                        focus(indices.get(indices.size() - 1));
                    }
                } else {
                    select(focusedIndex);
                    focus(focusedIndex);
                }
            }
        }

        @Override public void selectRange(int minRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; minColumn,
                                          int maxRow, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; maxColumn) {
            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
                select(maxRow, maxColumn);
                return;
            }

            startAtomic();

            final int itemCount = getItemCount();
            final boolean isCellSelectionEnabled = isCellSelectionEnabled();

            final int minColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)minColumn);
            final int maxColumnIndex = treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S,?&gt;)maxColumn);
            final int _minColumnIndex = Math.min(minColumnIndex, maxColumnIndex);
            final int _maxColumnIndex = Math.max(minColumnIndex, maxColumnIndex);

            final int _minRow = Math.min(minRow, maxRow);
            final int _maxRow = Math.max(minRow, maxRow);

            List&lt;TreeTablePosition&lt;S,?&gt;&gt; cellsToSelect = new ArrayList&lt;&gt;();

            for (int _row = _minRow; _row &lt;= _maxRow; _row++) {
                // begin copy/paste of select(int, column) method (with some
                // slight modifications)
                if (_row &lt; 0 || _row &gt;= itemCount) continue;

                if (! isCellSelectionEnabled) {
                    cellsToSelect.add(new TreeTablePosition&lt;&gt;(treeTableView, _row, (TreeTableColumn&lt;S,?&gt;)minColumn));
                } else {
                    for (int _col = _minColumnIndex; _col &lt;= _maxColumnIndex; _col++) {
                        final TreeTableColumn&lt;S, ?&gt; column = treeTableView.getVisibleLeafColumn(_col);

                        // if I'm in cell selection mode but the column is null, I don't want
                        // to select the whole row instead...
                        if (column == null &amp;&amp; isCellSelectionEnabled) continue;

                        cellsToSelect.add(new TreeTablePosition&lt;&gt;(treeTableView, _row, column));
                        // end copy/paste
                    }
                }
            }

            // to prevent duplication we remove all currently selected cells from
            // our list of cells to select.
            cellsToSelect.removeAll(getSelectedCells());

            selectedCellsMap.addAll(cellsToSelect);
            stopAtomic();

            // fire off events
            // Note that focus and selection always goes to maxRow, not _maxRow.
            updateSelectedIndex(maxRow);
            focus(maxRow, (TreeTableColumn&lt;S,?&gt;)maxColumn);

            final TreeTableColumn&lt;S,?&gt; startColumn = (TreeTableColumn&lt;S,?&gt;)minColumn;
            final TreeTableColumn&lt;S,?&gt; endColumn = isCellSelectionEnabled ? (TreeTableColumn&lt;S,?&gt;)maxColumn : startColumn;
            final int startChangeIndex = selectedCellsMap.indexOf(new TreeTablePosition&lt;&gt;(treeTableView, minRow, startColumn));
            final int endChangeIndex = selectedCellsMap.indexOf(new TreeTablePosition&lt;&gt;(treeTableView, maxRow, endColumn));

            if (startChangeIndex &gt; -1 &amp;&amp; endChangeIndex &gt; -1) {
                final int startIndex = Math.min(startChangeIndex, endChangeIndex);
                final int endIndex = Math.max(startChangeIndex, endChangeIndex);

                ListChangeListener.Change c = new NonIterableChange.SimpleAddChange&lt;&gt;(startIndex, endIndex + 1, selectedCellsSeq);
                fireCustomSelectedCellsListChangeEvent(c);
//                selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextAdd(startIndex, endIndex + 1));
            }
        }

        @Override public void clearSelection(int index) {
            clearSelection(index, null);
        }

        @Override
        public void clearSelection(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
            clearSelection(new TreeTablePosition&lt;S,Object&gt;(getTreeTableView(), row, (TreeTableColumn)column));
        }

        private void clearSelection(TreeTablePosition&lt;S,?&gt; tp) {
            final boolean csMode = isCellSelectionEnabled();
            final int row = tp.getRow();
            final boolean columnIsNull = tp.getTableColumn() == null;

            List&lt;TreeTablePosition&gt; toRemove = new ArrayList&lt;&gt;();
            for (TreeTablePosition pos : getSelectedCells()) {
                if (!csMode) {
                    if (pos.getRow() == row) {
                        toRemove.add(pos);
                        break;
                    }
                } else {
                    if (columnIsNull &amp;&amp; pos.getRow() == row) {
                        // if we are in cell selection mode and the column is null,
                        // we remove all items in the row
                        toRemove.add(pos);
                    } else if (pos.equals(tp)) {
                        toRemove.add(tp);
                        break;
                    }
                }
            }
            toRemove.stream().forEach(selectedCellsMap::remove);

            if (isEmpty() &amp;&amp; ! isAtomic()) {
                updateSelectedIndex(-1);
                selectedCellsMap.clear();
            }
        }

        @Override public void clearSelection() {
            final List&lt;TreeTablePosition&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;((Collection)getSelectedCells());

            quietClearSelection();

            if (! isAtomic()) {
                updateSelectedIndex(-1);
                focus(-1);

                if (!removed.isEmpty()) {
//                    selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextRemove(0, removed));
                    ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange&lt;TreeTablePosition&lt;S, ?&gt;&gt;(0, 0, selectedCellsSeq) {
                        @Override public List&lt;TreeTablePosition&lt;S, ?&gt;&gt; getRemoved() {
                            return removed;
                        }
                    };
                    fireCustomSelectedCellsListChangeEvent(c);
                }
            }
        }

        private void quietClearSelection() {
            startAtomic();
            selectedCellsMap.clear();
            stopAtomic();
        }

        @Override public boolean isSelected(int index) {
            return isSelected(index, null);
        }

        @Override public boolean isSelected(int row, TableColumnBase&lt;TreeItem&lt;S&gt;,?&gt; column) {
            // When in cell selection mode, if the column is null, then we interpret
            // the users query to be asking if _all_ of the cells in the row are selected,
            // rather than if _any_ of the cells in the row are selected.
            final boolean isCellSelectionEnabled = isCellSelectionEnabled();
            if (isCellSelectionEnabled &amp;&amp; column == null) {
                int columnCount = treeTableView.getVisibleLeafColumns().size();
                for (int col = 0; col &lt; columnCount; col++) {
                    if (!selectedCellsMap.isSelected(row, col)) {
                        return false;
                    }
                }
                return true;
            } else {
                int columnIndex = !isCellSelectionEnabled || column == null ? -1 : treeTableView.getVisibleLeafIndex((TreeTableColumn&lt;S, ?&gt;) column);
                return selectedCellsMap.isSelected(row, columnIndex);
            }
        }

        @Override public boolean isEmpty() {
            return selectedCellsMap.isEmpty();
        }

        @Override public void selectPrevious() {
            if (isCellSelectionEnabled()) {
                // in cell selection mode, we have to wrap around, going from
                // right-to-left, and then wrapping to the end of the previous line
                TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
                if (pos.getColumn() - 1 &gt;= 0) {
                    // go to previous row
                    select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
                } else if (pos.getRow() &lt; getRowCount() - 1) {
                    // wrap to end of previous row
                    select(pos.getRow() - 1, getTableColumn(getTreeTableView().getVisibleLeafColumns().size() - 1));
                }
            } else {
                int focusIndex = getFocusedIndex();
                if (focusIndex == -1) {
                    select(getRowCount() - 1);
                } else if (focusIndex &gt; 0) {
                    select(focusIndex - 1);
                }
            }
        }

        @Override public void selectNext() {
            if (isCellSelectionEnabled()) {
                // in cell selection mode, we have to wrap around, going from
                // left-to-right, and then wrapping to the start of the next line
                TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
                if (pos.getColumn() + 1 &lt; getTreeTableView().getVisibleLeafColumns().size()) {
                    // go to next column
                    select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
                } else if (pos.getRow() &lt; getRowCount() - 1) {
                    // wrap to start of next row
                    select(pos.getRow() + 1, getTableColumn(0));
                }
            } else {
                int focusIndex = getFocusedIndex();
                if (focusIndex == -1) {
                    select(0);
                } else if (focusIndex &lt; getRowCount() -1) {
                    select(focusIndex + 1);
                }
            }
        }

        @Override public void selectAboveCell() {
            TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
            if (pos.getRow() == -1) {
                select(getRowCount() - 1);
            } else if (pos.getRow() &gt; 0) {
                select(pos.getRow() - 1, pos.getTableColumn());
            }
        }

        @Override public void selectBelowCell() {
            TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();

            if (pos.getRow() == -1) {
                select(0);
            } else if (pos.getRow() &lt; getRowCount() -1) {
                select(pos.getRow() + 1, pos.getTableColumn());
            }
        }

        @Override public void selectFirst() {
            TreeTablePosition&lt;S,?&gt; focusedCell = getFocusedCell();

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
            }

            if (getRowCount() &gt; 0) {
                if (isCellSelectionEnabled()) {
                    select(0, focusedCell.getTableColumn());
                } else {
                    select(0);
                }
            }
        }

        @Override public void selectLast() {
            TreeTablePosition&lt;S,?&gt; focusedCell = getFocusedCell();

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
            }

            int numItems = getRowCount();
            if (numItems &gt; 0 &amp;&amp; getSelectedIndex() &lt; numItems - 1) {
                if (isCellSelectionEnabled()) {
                    select(numItems - 1, focusedCell.getTableColumn());
                } else {
                    select(numItems - 1);
                }
            }
        }

        @Override public void selectLeftCell() {
            if (! isCellSelectionEnabled()) return;

            TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
            if (pos.getColumn() - 1 &gt;= 0) {
                select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
            }
        }

        @Override public void selectRightCell() {
            if (! isCellSelectionEnabled()) return;

            TreeTablePosition&lt;S,?&gt; pos = getFocusedCell();
            if (pos.getColumn() + 1 &lt; getTreeTableView().getVisibleLeafColumns().size()) {
                select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
            }
        }



        /***********************************************************************
         *                                                                     *
         * Support code                                                        *
         *                                                                     *
         **********************************************************************/

        private void updateDefaultSelection() {
            // when the items list totally changes, we should clear out
            // the selection
            int newSelectionIndex = -1;
            TreeItem&lt;S&gt; selectedItem = getSelectedItem();
            if (selectedItem != null) {
                newSelectionIndex = treeTableView.getRow(selectedItem);
            }

            // we put focus onto the first item, if there is at least
            // one item in the list
            int newFocusIndex = newSelectionIndex != -1 ? newSelectionIndex : treeTableView.getExpandedItemCount() &gt; 0 ? 0 : -1;

            clearSelection();
            select(newSelectionIndex, isCellSelectionEnabled() ? getTableColumn(0) : null);
            focus(newFocusIndex, isCellSelectionEnabled() ? getTableColumn(0) : null);
        }

        private TreeTableColumn&lt;S,?&gt; getTableColumn(int pos) {
            return getTreeTableView().getVisibleLeafColumn(pos);
        }

        // Gets a table column to the left or right of the current one, given an offset
        private TreeTableColumn&lt;S,?&gt; getTableColumn(TreeTableColumn&lt;S,?&gt; column, int offset) {
            int columnIndex = getTreeTableView().getVisibleLeafIndex(column);
            int newColumnIndex = columnIndex + offset;
            return getTreeTableView().getVisibleLeafColumn(newColumnIndex);
        }

        private void updateSelectedIndex(int row) {
            setSelectedIndex(row);
            setSelectedItem(getModelItem(row));
        }

        @Override public void focus(int row) {
            focus(row, null);
        }

        private void focus(int row, TreeTableColumn&lt;S,?&gt; column) {
            focus(new TreeTablePosition&lt;&gt;(getTreeTableView(), row, column));
        }

        private void focus(TreeTablePosition&lt;S,?&gt; pos) {
            if (getTreeTableView().getFocusModel() == null) return;

            getTreeTableView().getFocusModel().focus(pos.getRow(), pos.getTableColumn());
            getTreeTableView().notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
        }

        @Override public int getFocusedIndex() {
            return getFocusedCell().getRow();
        }

        private TreeTablePosition&lt;S,?&gt; getFocusedCell() {
            if (treeTableView.getFocusModel() == null) {
                return new TreeTablePosition&lt;&gt;(treeTableView, -1, null);
            }
            return treeTableView.getFocusModel().getFocusedCell();
        }

        private int getRowCount() {
            return treeTableView.getExpandedItemCount();
        }

        private void fireCustomSelectedCellsListChangeEvent(ListChangeListener.Change&lt;? extends TreeTablePosition&lt;S,?&gt;&gt; c) {
            ControlUtils.updateSelectedIndices(this, c);

            if (isAtomic()) {
                return;
            }

            selectedCellsSeq.callObservers(new MappingChange&lt;&gt;(c, MappingChange.NOOP_MAP, selectedCellsSeq));
        }
    }




    /**
     * A {@link FocusModel} with additional functionality to support the requirements
     * of a TableView control.
     *
     * @see TableView
     * @since JavaFX 8.0
     */
    public static class TreeTableViewFocusModel&lt;S&gt; extends TableFocusModel&lt;TreeItem&lt;S&gt;, TreeTableColumn&lt;S,?&gt;&gt; {

        private final TreeTableView&lt;S&gt; treeTableView;

        private final TreeTablePosition EMPTY_CELL;

        /**
         * Creates a default TableViewFocusModel instance that will be used to
         * manage focus of the provided TableView control.
         *
         * @param treeTableView The tableView upon which this focus model operates.
         * @throws NullPointerException The TableView argument can not be null.
         */
        public TreeTableViewFocusModel(final TreeTableView&lt;S&gt; treeTableView) {
            if (treeTableView == null) {
                throw new NullPointerException(&quot;TableView can not be null&quot;);
            }

            this.treeTableView = treeTableView;
            this.EMPTY_CELL = new TreeTablePosition&lt;&gt;(treeTableView, -1, null);

            this.treeTableView.rootProperty().addListener(weakRootPropertyListener);
            updateTreeEventListener(null, treeTableView.getRoot());

            int focusRow = getItemCount() &gt; 0 ? 0 : -1;
            TreeTablePosition&lt;S,?&gt; pos = new TreeTablePosition&lt;&gt;(treeTableView, focusRow, null);
            setFocusedCell(pos);

            treeTableView.showRootProperty().addListener(o -&gt; {
                if (isFocused(0)) {
                    focus(-1);
                    focus(0);
                }
            });

            focusedCellProperty().addListener(o -&gt; {
                treeTableView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
            });
        }

        private final ChangeListener&lt;TreeItem&lt;S&gt;&gt; rootPropertyListener = (observable, oldValue, newValue) -&gt; {
            updateTreeEventListener(oldValue, newValue);
        };

        private final WeakChangeListener&lt;TreeItem&lt;S&gt;&gt; weakRootPropertyListener =
                new WeakChangeListener&lt;&gt;(rootPropertyListener);

        private void updateTreeEventListener(TreeItem&lt;S&gt; oldRoot, TreeItem&lt;S&gt; newRoot) {
            if (oldRoot != null &amp;&amp; weakTreeItemListener != null) {
                oldRoot.removeEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
            }

            if (newRoot != null) {
                weakTreeItemListener = new WeakEventHandler&lt;&gt;(treeItemListener);
                newRoot.addEventHandler(TreeItem.&lt;S&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
            }
        }

        private EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; treeItemListener = new EventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt;() {
            @Override public void handle(TreeItem.TreeModificationEvent&lt;S&gt; e) {
                // don't shift focus if the event occurred on a tree item after
                // the focused row, or if there is no focus index at present
                if (getFocusedIndex() == -1) return;

                int shift = 0;
                if (e.getChange() != null) {
                    e.getChange().next();
                }

                do {
                    int row = treeTableView.getRow(e.getTreeItem());

                    if (e.wasExpanded()) {
                        if (row &lt; getFocusedIndex()) {
                            // need to shuffle selection by the number of visible children
                            shift += e.getTreeItem().getExpandedDescendentCount(false) - 1;
                        }
                    } else if (e.wasCollapsed()) {
                        if (row &lt; getFocusedIndex()) {
                            // need to shuffle selection by the number of visible children
                            // that were just hidden
                            shift += -e.getTreeItem().previousExpandedDescendentCount + 1;
                        }
                    } else if (e.wasAdded()) {
                        // get the TreeItem the event occurred on - we only need to
                        // shift if the tree item is expanded
                        TreeItem&lt;S&gt; eventTreeItem = e.getTreeItem();
                        if (eventTreeItem.isExpanded()) {
                            for (int i = 0; i &lt; e.getAddedChildren().size(); i++) {
                                // get the added item and determine the row it is in
                                TreeItem&lt;S&gt; item = e.getAddedChildren().get(i);
                                row = treeTableView.getRow(item);

                                if (item != null &amp;&amp; row &lt;= (shift+getFocusedIndex())) {
                                    shift += item.getExpandedDescendentCount(false);
                                }
                            }
                        }
                    } else if (e.wasRemoved()) {
                        row += e.getFrom() + 1;

                        for (int i = 0; i &lt; e.getRemovedChildren().size(); i++) {
                            TreeItem&lt;S&gt; item = e.getRemovedChildren().get(i);
                            if (item != null &amp;&amp; item.equals(getFocusedItem())) {
                                focus(Math.max(0, getFocusedIndex() - 1));
                                return;
                            }
                        }

                        if (row &lt;= getFocusedIndex()) {
                            // shuffle selection by the number of removed items
                            shift += e.getTreeItem().isExpanded() ? -e.getRemovedSize() : 0;
                        }
                    }
                } while (e.getChange() != null &amp;&amp; e.getChange().next());

                if (shift != 0) {
                    TreeTablePosition&lt;S, ?&gt; focusedCell = getFocusedCell();
                    final int newFocus = focusedCell.getRow() + shift;
                    if (newFocus &gt;= 0) {
                        Platform.runLater(() -&gt; focus(newFocus, focusedCell.getTableColumn()));
                    }
                }
            }
        };

        private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakTreeItemListener;

        /** {@inheritDoc} */
        @Override protected int getItemCount() {
//            if (tableView.getItems() == null) return -1;
//            return tableView.getItems().size();
            return treeTableView.getExpandedItemCount();
        }

        /** {@inheritDoc} */
        @Override protected TreeItem&lt;S&gt; getModelItem(int index) {
            if (index &lt; 0 || index &gt;= getItemCount()) return null;
            return treeTableView.getTreeItem(index);
        }

        /**
         * The position of the current item in the TableView which has the focus.
         */
        private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; focusedCell;
        public final ReadOnlyObjectProperty&lt;TreeTablePosition&lt;S,?&gt;&gt; focusedCellProperty() {
            return focusedCellPropertyImpl().getReadOnlyProperty();
        }
        private void setFocusedCell(TreeTablePosition&lt;S,?&gt; value) { focusedCellPropertyImpl().set(value);  }
        public final TreeTablePosition&lt;S,?&gt; getFocusedCell() { return focusedCell == null ? EMPTY_CELL : focusedCell.get(); }

        private ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt; focusedCellPropertyImpl() {
            if (focusedCell == null) {
                focusedCell = new ReadOnlyObjectWrapper&lt;TreeTablePosition&lt;S,?&gt;&gt;(EMPTY_CELL) {
                    private TreeTablePosition&lt;S,?&gt; old;
                    @Override protected void invalidated() {
                        if (get() == null) return;

                        if (old == null || !old.equals(get())) {
                            setFocusedIndex(get().getRow());
                            setFocusedItem(getModelItem(getValue().getRow()));

                            old = get();
                        }
                    }

                    @Override
                    public Object getBean() {
                        return TreeTableView.TreeTableViewFocusModel.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;focusedCell&quot;;
                    }
                };
            }
            return focusedCell;
        }


        /**
         * Causes the item at the given index to receive the focus.
         *
         * @param row The row index of the item to give focus to.
         * @param column The column of the item to give focus to. Can be null.
         */
        @Override public void focus(int row, TreeTableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) {
                setFocusedCell(EMPTY_CELL);
            } else {
                TreeTablePosition&lt;S,?&gt; oldFocusCell = getFocusedCell();
                TreeTablePosition&lt;S,?&gt; newFocusCell = new TreeTablePosition&lt;&gt;(treeTableView, row, column);
                setFocusedCell(newFocusCell);

                if (newFocusCell.equals(oldFocusCell)) {
                    // manually update the focus properties to ensure consistency
                    setFocusedIndex(row);
                    setFocusedItem(getModelItem(row));
                }
            }
        }

        /**
         * Convenience method for setting focus on a particular row or cell
         * using a {@link TablePosition}.
         *
         * @param pos The table position where focus should be set.
         */
        public void focus(TreeTablePosition&lt;S,?&gt; pos) {
            if (pos == null) return;
            focus(pos.getRow(), pos.getTableColumn());
        }


        /***********************************************************************
         *                                                                     *
         * Public API                                                          *
         *                                                                     *
         **********************************************************************/

        /**
         * Tests whether the row / cell at the given location currently has the
         * focus within the TableView.
         */
        @Override public boolean isFocused(int row, TreeTableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) return false;

            TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
            boolean columnMatch = column == null || column.equals(cell.getTableColumn());

            return cell.getRow() == row &amp;&amp; columnMatch;
        }

        /**
         * Causes the item at the given index to receive the focus. This does not
         * cause the current selection to change. Updates the focusedItem and
         * focusedIndex properties such that &lt;code&gt;focusedIndex = -1&lt;/code&gt; unless
         * &lt;pre&gt;&lt;code&gt;0 &amp;lt;= index &amp;lt; model size&lt;/code&gt;&lt;/pre&gt;.
         *
         * @param index The index of the item to get focus.
         */
        @Override public void focus(int index) {
            if (treeTableView.expandedItemCountDirty) {
                treeTableView.updateExpandedItemCount(treeTableView.getRoot());
            }

            if (index &lt; 0 || index &gt;= getItemCount()) {
                setFocusedCell(EMPTY_CELL);
            } else {
                setFocusedCell(new TreeTablePosition&lt;&gt;(treeTableView, index, null));
            }
        }

        /**
         * Attempts to move focus to the cell above the currently focused cell.
         */
        @Override public void focusAboveCell() {
            TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();

            if (getFocusedIndex() == -1) {
                focus(getItemCount() - 1, cell.getTableColumn());
            } else if (getFocusedIndex() &gt; 0) {
                focus(getFocusedIndex() - 1, cell.getTableColumn());
            }
        }

        /**
         * Attempts to move focus to the cell below the currently focused cell.
         */
        @Override public void focusBelowCell() {
            TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
            if (getFocusedIndex() == -1) {
                focus(0, cell.getTableColumn());
            } else if (getFocusedIndex() != getItemCount() -1) {
                focus(getFocusedIndex() + 1, cell.getTableColumn());
            }
        }

        /**
         * Attempts to move focus to the cell to the left of the currently focused cell.
         */
        @Override public void focusLeftCell() {
            TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
            if (cell.getColumn() &lt;= 0) return;
            focus(cell.getRow(), getTableColumn(cell.getTableColumn(), -1));
        }

        /**
         * Attempts to move focus to the cell to the right of the the currently focused cell.
         */
        @Override public void focusRightCell() {
            TreeTablePosition&lt;S,?&gt; cell = getFocusedCell();
            if (cell.getColumn() == getColumnCount() - 1) return;
            focus(cell.getRow(), getTableColumn(cell.getTableColumn(), 1));
        }

        /** {@inheritDoc} */
        @Override public void focusPrevious() {
            if (getFocusedIndex() == -1) {
                focus(0);
            } else if (getFocusedIndex() &gt; 0) {
                focusAboveCell();
            }
        }

        /** {@inheritDoc} */
        @Override public void focusNext() {
            if (getFocusedIndex() == -1) {
                focus(0);
            } else if (getFocusedIndex() != getItemCount() -1) {
                focusBelowCell();
            }
        }



         /***********************************************************************
         *                                                                     *
         * Private Implementation                                              *
         *                                                                     *
         **********************************************************************/

        private int getColumnCount() {
            return treeTableView.getVisibleLeafColumns().size();
        }

        // Gets a table column to the left or right of the current one, given an offset
        private TreeTableColumn&lt;S,?&gt; getTableColumn(TreeTableColumn&lt;S,?&gt; column, int offset) {
            int columnIndex = treeTableView.getVisibleLeafIndex(column);
            int newColumnIndex = columnIndex + offset;
            return treeTableView.getVisibleLeafColumn(newColumnIndex);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/ColorPalette.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.ParentHelper;
import com.sun.javafx.scene.control.CustomColorDialog;
import com.sun.javafx.scene.control.skin.Utils;
import com.sun.javafx.scene.traversal.Algorithm;
import com.sun.javafx.scene.traversal.Direction;
import com.sun.javafx.scene.traversal.ParentTraversalEngine;
import com.sun.javafx.scene.traversal.TraversalContext;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.scene.Node;
import javafx.scene.control.ColorPicker;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Hyperlink;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.control.PopupControl;
import javafx.scene.control.Separator;
import javafx.scene.control.Tooltip;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.shape.StrokeType;

import java.util.List;

import static com.sun.javafx.scene.control.Properties.getColorPickerString;

// Not public API - this is (presently) an implementation detail only
class ColorPalette extends Region {

    private static final int SQUARE_SIZE = 15;

    // package protected for testing purposes
    ColorPickerGrid colorPickerGrid;
    final Hyperlink customColorLink = new Hyperlink(getColorPickerString(&quot;customColorLink&quot;));
    CustomColorDialog customColorDialog = null;

    private ColorPicker colorPicker;
    private final GridPane standardColorGrid = new GridPane();
    private final GridPane customColorGrid = new GridPane();
    private final Separator separator = new Separator();
    private final Label customColorLabel = new Label(getColorPickerString(&quot;customColorLabel&quot;));

    private PopupControl popupControl;
    private ColorSquare focusedSquare;
    private ContextMenu contextMenu = null;

    private Color mouseDragColor = null;
    private boolean dragDetected = false;

    // Metrics for custom colors
    private int customColorNumber = 0;
    private int customColorRows = 0;
    private int customColorLastRowLength = 0;

    private final ColorSquare hoverSquare = new ColorSquare();

    public ColorPalette(final ColorPicker colorPicker) {
        getStyleClass().add(&quot;color-palette-region&quot;);
        this.colorPicker = colorPicker;
        colorPickerGrid = new ColorPickerGrid();
        colorPickerGrid.getChildren().get(0).requestFocus();
        customColorLabel.setAlignment(Pos.CENTER_LEFT);
        customColorLink.setPrefWidth(colorPickerGrid.prefWidth(-1));
        customColorLink.setAlignment(Pos.CENTER);
        customColorLink.setFocusTraversable(true);
        customColorLink.setVisited(true); // so that it always appears blue
        customColorLink.setOnAction(new EventHandler&lt;ActionEvent&gt;() {
            @Override public void handle(ActionEvent t) {
                if (customColorDialog == null) {
                    customColorDialog = new CustomColorDialog(popupControl);
                    customColorDialog.customColorProperty().addListener((ov, t1, t2) -&gt; {
                        colorPicker.setValue(customColorDialog.customColorProperty().get());
                    });
                    customColorDialog.setOnSave(() -&gt; {
                        Color customColor = customColorDialog.customColorProperty().get();
                        buildCustomColors();
                        colorPicker.getCustomColors().add(customColor);
                        updateSelection(customColor);
                        Event.fireEvent(colorPicker, new ActionEvent());
                        colorPicker.hide();
                    });
                    customColorDialog.setOnUse(() -&gt; {
                        Event.fireEvent(colorPicker, new ActionEvent());
                        colorPicker.hide();
                    });
                }
                customColorDialog.setCurrentColor(colorPicker.valueProperty().get());
                if (popupControl != null) popupControl.setAutoHide(false);
                customColorDialog.show();
                 customColorDialog.setOnHidden(event -&gt; {
                    if (popupControl != null) popupControl.setAutoHide(true);
                 });
            }
        });

        initNavigation();

        buildStandardColors();
        standardColorGrid.getStyleClass().add(&quot;color-picker-grid&quot;);
        standardColorGrid.setVisible(true);
        customColorGrid.getStyleClass().add(&quot;color-picker-grid&quot;);
        customColorGrid.setVisible(false);
        buildCustomColors();
        colorPicker.getCustomColors().addListener(new ListChangeListener&lt;Color&gt;() {
            @Override public void onChanged(Change&lt;? extends Color&gt; change) {
                buildCustomColors();
            }
        });

        VBox paletteBox = new VBox();
        paletteBox.getStyleClass().add(&quot;color-palette&quot;);
        paletteBox.getChildren().addAll(standardColorGrid, colorPickerGrid, customColorLabel, customColorGrid, separator, customColorLink);

        hoverSquare.setMouseTransparent(true);
        hoverSquare.getStyleClass().addAll(&quot;hover-square&quot;);
        setFocusedSquare(null);

        getChildren().addAll(paletteBox, hoverSquare);
    }

    private void setFocusedSquare(ColorSquare square) {
        if (square == focusedSquare) {
            return;
        }
        focusedSquare = square;

        hoverSquare.setVisible(focusedSquare != null);
        if (focusedSquare == null) {
            return;
        }

        if (!focusedSquare.isFocused()) {
            focusedSquare.requestFocus();
        }

        hoverSquare.rectangle.setFill(focusedSquare.rectangle.getFill());

        Bounds b = square.localToScene(square.getLayoutBounds());

        double x = b.getMinX();
        double y = b.getMinY();

        double xAdjust;
        double scaleAdjust = hoverSquare.getScaleX() == 1.0 ? 0 : hoverSquare.getWidth() / 4.0;

        if (colorPicker.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
            x = focusedSquare.getLayoutX();
            xAdjust = -focusedSquare.getWidth() + scaleAdjust;
        } else {
            xAdjust = focusedSquare.getWidth() / 2.0 + scaleAdjust;
        }

        hoverSquare.setLayoutX(snapPositionX(x) - xAdjust);
        hoverSquare.setLayoutY(snapPositionY(y) - focusedSquare.getHeight() / 2.0 + (hoverSquare.getScaleY() == 1.0 ? 0 : focusedSquare.getHeight() / 4.0));
    }

    private void buildStandardColors() {
        // WARNING:
        // Make sure that the number of standard colors is equal to NUM_OF_COLUMNS
        // Currently, 12 standard colors are supported in a single row
        // Note : Creation &amp; access logic of standardColorGrid needs to be updated
        // in case more colors are added as separate row(s) in future.

        final Color[] STANDARD_COLORS = {
            Color.AQUA,
            Color.TEAL,
            Color.BLUE,
            Color.NAVY,
            Color.FUCHSIA,
            Color.PURPLE,
            Color.RED,
            Color.MAROON,
            Color.YELLOW,
            Color.OLIVE,
            Color.GREEN,
            Color.LIME
        };

        standardColorGrid.getChildren().clear();

        for (int i = 0; i &lt; NUM_OF_COLUMNS; i++) {
            standardColorGrid.add(new ColorSquare(STANDARD_COLORS[i], i, ColorType.STANDARD), i, 0);
        }
    }

    private void buildCustomColors() {
        final ObservableList&lt;Color&gt; customColors = colorPicker.getCustomColors();
        customColorNumber = customColors.size();

        customColorGrid.getChildren().clear();
        if (customColors.isEmpty()) {
            customColorLabel.setVisible(false);
            customColorLabel.setManaged(false);
            customColorGrid.setVisible(false);
            customColorGrid.setManaged(false);
            return;
        } else {
            customColorLabel.setVisible(true);
            customColorLabel.setManaged(true);
            customColorGrid.setVisible(true);
            customColorGrid.setManaged(true);
            if (contextMenu == null) {
                MenuItem item = new MenuItem(getColorPickerString(&quot;removeColor&quot;));
                item.setOnAction(e -&gt; {
                    ColorSquare square = (ColorSquare)contextMenu.getOwnerNode();
                    customColors.remove(square.rectangle.getFill());
                    buildCustomColors();
                });
                contextMenu = new ContextMenu(item);
            }
        }

        int customColumnIndex = 0;
        int customRowIndex = 0;
        int remainingSquares = customColors.size() % NUM_OF_COLUMNS;
        int numEmpty = (remainingSquares == 0) ? 0 : NUM_OF_COLUMNS - remainingSquares;
        customColorLastRowLength = remainingSquares == 0 ? 12 : remainingSquares;

        for (int i = 0; i &lt; customColors.size(); i++) {
            Color c = customColors.get(i);
            ColorSquare square = new ColorSquare(c, i, ColorType.CUSTOM);
            square.addEventHandler(KeyEvent.KEY_PRESSED, e -&gt; {
                if (e.getCode() == KeyCode.DELETE) {
                    customColors.remove(square.rectangle.getFill());
                    buildCustomColors();
                }
            });
            customColorGrid.add(square, customColumnIndex, customRowIndex);
            customColumnIndex++;
            if (customColumnIndex == NUM_OF_COLUMNS) {
                customColumnIndex = 0;
                customRowIndex++;
            }
        }
        for (int i = 0; i &lt; numEmpty; i++) {
            ColorSquare emptySquare = new ColorSquare();
            emptySquare.setDisable(true);
            customColorGrid.add(emptySquare, customColumnIndex, customRowIndex);
            customColumnIndex++;
        }
        customColorRows = customRowIndex + 1;
        requestLayout();

    }

    private void initNavigation() {
        setOnKeyPressed(ke -&gt; {
            switch (ke.getCode()) {
                case SPACE:
                case ENTER:
                    processSelectKey(ke);
                    ke.consume();
                    break;
                default: // no-op
            }
        });

        ParentHelper.setTraversalEngine(this, new ParentTraversalEngine(this, new Algorithm() {
            @Override
            public Node select(Node owner, Direction dir, TraversalContext context) {
                final Node subsequentNode = context.selectInSubtree(context.getRoot(), owner, dir);
                switch (dir) {
                    case NEXT:
                    case NEXT_IN_LINE:
                    case PREVIOUS:
                        return subsequentNode;
                    // Here, we need to intercept the standard algorithm in a few cases to get the desired traversal
                    // For right or left direction we want to continue on the next or previous row respectively
                    // For up and down, the custom color panel might be skipped by the standard algorithm (if not wide enough
                    // to be between the current color and custom color button), so we need to include it in the path explicitly.
                    case LEFT:
                    case RIGHT:
                    case UP:
                    case DOWN:
                        if (owner instanceof ColorSquare) {
                            Node result =  processArrow((ColorSquare)owner, dir);
                            return result != null ? result : subsequentNode;
                        } else {
                            return subsequentNode;
                        }
                }
                return null;
            }

            private Node processArrow(ColorSquare owner, Direction dir) {
                int row = 0;
                int column = 0;

                if (owner.colorType == ColorType.STANDARD) {
                    row = 0;
                    column = owner.index;
                } else {
                    row = owner.index / NUM_OF_COLUMNS;
                    column = owner.index % NUM_OF_COLUMNS;
                }

                // Adjust the direction according to color picker orientation
                dir = dir.getDirectionForNodeOrientation(colorPicker.getEffectiveNodeOrientation());
                // This returns true for all the cases which we need to override
                if (isAtBorder(dir, row, column, (owner.colorType == ColorType.CUSTOM))) {
                    // There's no other node in the direction from the square, so we need to continue on some other row
                    // or cycle
                    int subsequentRow = row;
                    int subsequentColumn = column;
                    boolean subSequentSquareCustom = (owner.colorType == ColorType.CUSTOM);
                    boolean subSequentSquareStandard = (owner.colorType == ColorType.STANDARD);
                    switch (dir) {
                        case LEFT:
                        case RIGHT:
                            // The next row is either the first or the last, except when cycling in custom colors, the last row
                            // might have different number of columns
                            if (owner.colorType == ColorType.STANDARD) {
                                subsequentRow = 0;
                                subsequentColumn = (dir == Direction.LEFT)? NUM_OF_COLUMNS - 1 : 0;
                            }
                            else if (owner.colorType == ColorType.CUSTOM) {
                                subsequentRow = Math.floorMod(dir == Direction.LEFT ? row - 1 : row + 1, customColorRows);
                                subsequentColumn = dir == Direction.LEFT ? subsequentRow == customColorRows - 1 ?
                                        customColorLastRowLength - 1 : NUM_OF_COLUMNS - 1 : 0;
                            } else {
                                subsequentRow = Math.floorMod(dir == Direction.LEFT ? row - 1 : row + 1, NUM_OF_ROWS);
                                subsequentColumn = dir == Direction.LEFT ? NUM_OF_COLUMNS - 1 : 0;
                            }
                            break;
                        case UP: // custom color are not handled here
                            if (owner.colorType == ColorType.NORMAL &amp;&amp; row == 0) {
                                subSequentSquareStandard = true;
                            }
                            break;
                        case DOWN: // custom color are not handled here
                            if (customColorNumber &gt; 0) {
                                subSequentSquareCustom = true;
                                subsequentRow = 0;
                                subsequentColumn = customColorRows &gt; 1 ? column : Math.min(customColorLastRowLength - 1, column);
                                break;
                            } else {
                                return null; // Let the default algorithm handle this
                            }

                    }
                    if (subSequentSquareCustom) {
                        return customColorGrid.getChildren().get(subsequentRow * NUM_OF_COLUMNS + subsequentColumn);
                    } else if (subSequentSquareStandard) {
                        return standardColorGrid.getChildren().get(subsequentColumn);
                    } else {
                        return colorPickerGrid.getChildren().get(subsequentRow * NUM_OF_COLUMNS + subsequentColumn);
                    }
                }
                return null;
            }

            private boolean isAtBorder(Direction dir, int row, int column, boolean custom) {
                switch (dir) {
                    case LEFT:
                        return column == 0;
                    case RIGHT:
                        return custom &amp;&amp; row == customColorRows - 1 ?
                                column == customColorLastRowLength - 1 : column == NUM_OF_COLUMNS - 1;
                    case UP:
                        return !custom &amp;&amp; row == 0;
                    case DOWN:
                        return !custom &amp;&amp; row == NUM_OF_ROWS - 1;
                }
                return false;
            }

            @Override
            public Node selectFirst(TraversalContext context) {
                return standardColorGrid.getChildren().get(0);
            }

            @Override
            public Node selectLast(TraversalContext context) {
                return customColorLink;
            }
        }));
    }

    private void processSelectKey(KeyEvent ke) {
        if (focusedSquare != null) focusedSquare.selectColor(ke);
    }

    public void setPopupControl(PopupControl pc) {
        this.popupControl = pc;
    }

    public ColorPickerGrid getColorGrid() {
        return colorPickerGrid;
    }

    public boolean isCustomColorDialogShowing() {
        if (customColorDialog != null) return customColorDialog.isVisible();
        return false;
    }


    enum ColorType {
        NORMAL,
        STANDARD,
        CUSTOM
    };

    class ColorSquare extends StackPane {
        Rectangle rectangle;
        int index;
        boolean isEmpty;
        ColorType colorType = ColorType.NORMAL;

        public ColorSquare() {
            this(null, -1, ColorType.NORMAL);
        }

        public ColorSquare(Color color, int index) {
            this(color, index, ColorType.NORMAL);
        }

        public ColorSquare(Color color, int index, ColorType type) {
            // Add style class to handle selected color square
            getStyleClass().add(&quot;color-square&quot;);
            if (color != null) {
                setFocusTraversable(true);

                focusedProperty().addListener((s, ov, nv) -&gt; {
                    setFocusedSquare(nv ? this : null);
                });

                addEventHandler(MouseEvent.MOUSE_ENTERED, event -&gt; {
                    setFocusedSquare(ColorSquare.this);
                });
                addEventHandler(MouseEvent.MOUSE_EXITED, event -&gt; {
                    setFocusedSquare(null);
                });

                addEventHandler(MouseEvent.MOUSE_RELEASED, event -&gt; {
                    if (!dragDetected &amp;&amp; event.getButton() == MouseButton.PRIMARY &amp;&amp; event.getClickCount() == 1) {
                        if (!isEmpty) {
                            Color fill = (Color) rectangle.getFill();
                            colorPicker.setValue(fill);
                            colorPicker.fireEvent(new ActionEvent());
                            updateSelection(fill);
                            event.consume();
                        }
<A NAME="41"></A>                        colorPicker.hide();
                    } else if (event.getButton() == MouseButton.SECONDARY ||
                            event.getButton() == MouseButton.MIDDLE) {
                        <FONT color="#f87a17"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#41',2,'match37-top.html#41',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if ((colorType == ColorType.CUSTOM) &amp;&amp; contextMenu != null) {
                            if (!contextMenu.isShowing()) {
                                contextMenu.show(ColorSquare.this, Side.RIGHT, 0, 0);
                                Utils.addMnemonics(contextMenu, ColorSquare.this.getScene(), NodeHelper.isShowMnemonics(colorPicker));
                            } else {
                                contextMenu.hide();
                                Utils.removeMnemonics(contextMenu, ColorSquare.this.getScene());
                            }
                        }</B></FONT>
                    }
                });
            }
            this.index = index;
            this.colorType = type;
            rectangle = new Rectangle(SQUARE_SIZE, SQUARE_SIZE);
            if (color == null) {
                rectangle.setFill(Color.WHITE);
                isEmpty = true;
            } else {
                rectangle.setFill(color);
            }

            rectangle.setStrokeType(StrokeType.INSIDE);

            String tooltipStr = ColorPickerSkin.tooltipString(color);
            Tooltip.install(this, new Tooltip((tooltipStr == null) ? &quot;&quot; : tooltipStr));

            rectangle.getStyleClass().add(&quot;color-rect&quot;);

            getChildren().add(rectangle);
        }

        public void selectColor(KeyEvent event) {
            if (rectangle.getFill() != null) {
                if (rectangle.getFill() instanceof Color) {
                    colorPicker.setValue((Color) rectangle.getFill());
                    colorPicker.fireEvent(new ActionEvent());
                }
                event.consume();
            }
            colorPicker.hide();
        }
    }

    // The skin can update selection if colorpicker value changes..
    public void updateSelection(Color color) {
        setFocusedSquare(null);

        // Check all color grids to find ColorSquare that matches color
        // if found, set focus to it

        List&lt;GridPane&gt; gridList = List.of(standardColorGrid, colorPickerGrid,
                                          customColorGrid);

        for (GridPane grid : gridList) {
            ColorSquare sq = findColorSquare(grid, color);
            if (sq != null) {
                setFocusedSquare(sq);
                return;
            }
        }
    }

    private ColorSquare findColorSquare(GridPane colorGrid, Color color) {
        for (Node n : colorGrid.getChildren()) {
            ColorSquare c = (ColorSquare) n;
            if (c.rectangle.getFill().equals(color)) {
                return c;
            }
        }
        return null;
    }

    class ColorPickerGrid extends GridPane {

        private final List&lt;ColorSquare&gt; squares;

        public ColorPickerGrid() {
            getStyleClass().add(&quot;color-picker-grid&quot;);
            setId(&quot;ColorCustomizerColorGrid&quot;);
            int columnIndex = 0, rowIndex = 0;
            squares = FXCollections.observableArrayList();
            final int numColors = RAW_VALUES.length / 3;
            Color[] colors = new Color[numColors];
            for (int i = 0; i &lt; numColors; i++) {
                colors[i] = new Color(RAW_VALUES[(i * 3)] / 255,
                        RAW_VALUES[(i * 3) + 1] / 255, RAW_VALUES[(i * 3) + 2] / 255,
                        1.0);
                ColorSquare cs = new ColorSquare(colors[i], i);
                squares.add(cs);
            }

            for (ColorSquare square : squares) {
                add(square, columnIndex, rowIndex);
                columnIndex++;
                if (columnIndex == NUM_OF_COLUMNS) {
                    columnIndex = 0;
                    rowIndex++;
                }
            }
            setOnMouseDragged(t -&gt; {
                if (!dragDetected) {
                    dragDetected = true;
                    mouseDragColor = colorPicker.getValue();
                }
                int xIndex = com.sun.javafx.util.Utils.clamp(0,
                        (int)t.getX()/(SQUARE_SIZE + 1), NUM_OF_COLUMNS - 1);
                int yIndex = com.sun.javafx.util.Utils.clamp(0,
                        (int)t.getY()/(SQUARE_SIZE + 1), NUM_OF_ROWS - 1);
                int index = xIndex + yIndex*NUM_OF_COLUMNS;
                colorPicker.setValue((Color) squares.get(index).rectangle.getFill());
                updateSelection(colorPicker.getValue());
            });
            addEventHandler(MouseEvent.MOUSE_RELEASED, t -&gt; {
                if(colorPickerGrid.getBoundsInLocal().contains(t.getX(), t.getY())) {
                    updateSelection(colorPicker.getValue());
                    colorPicker.fireEvent(new ActionEvent());
                    colorPicker.hide();
                } else {
                    // restore color as mouse release happened outside the grid.
                    if (mouseDragColor != null) {
                        colorPicker.setValue(mouseDragColor);
                        updateSelection(mouseDragColor);
                    }
                }
                dragDetected = false;
            });
        }

        public List&lt;ColorSquare&gt; getSquares() {
            return squares;
        }

        @Override protected double computePrefWidth(double height) {
            return (SQUARE_SIZE + 1)*NUM_OF_COLUMNS;
        }

        @Override protected double computePrefHeight(double width) {
            return (SQUARE_SIZE + 1)*NUM_OF_ROWS;
        }
    }

    private static final int NUM_OF_COLUMNS = 12;
    private static double[] RAW_VALUES = {
            // WARNING: always make sure the number of colors is a divisable by NUM_OF_COLUMNS
            255, 255, 255, // first row
            242, 242, 242,
            230, 230, 230,
            204, 204, 204,
            179, 179, 179,
            153, 153, 153,
            128, 128, 128,
            102, 102, 102,
            77, 77, 77,
            51, 51, 51,
            26, 26, 26,
            0, 0, 0,
            0, 51, 51, // second row
            0, 26, 128,
            26, 0, 104,
            51, 0, 51,
            77, 0, 26,
            153, 0, 0,
            153, 51, 0,
            153, 77, 0,
            153, 102, 0,
            153, 153, 0,
            102, 102, 0,
            0, 51, 0,
            26, 77, 77, // third row
            26, 51, 153,
            51, 26, 128,
            77, 26, 77,
            102, 26, 51,
            179, 26, 26,
            179, 77, 26,
            179, 102, 26,
            179, 128, 26,
            179, 179, 26,
            128, 128, 26,
            26, 77, 26,
            51, 102, 102, // fourth row
            51, 77, 179,
            77, 51, 153,
            102, 51, 102,
            128, 51, 77,
            204, 51, 51,
            204, 102, 51,
            204, 128, 51,
            204, 153, 51,
            204, 204, 51,
            153, 153, 51,
            51, 102, 51,
            77, 128, 128, // fifth row
            77, 102, 204,
            102, 77, 179,
            128, 77, 128,
            153, 77, 102,
            230, 77, 77,
            230, 128, 77,
            230, 153, 77,
            230, 179, 77,
            230, 230, 77,
            179, 179, 77,
            77, 128, 77,
            102, 153, 153, // sixth row
            102, 128, 230,
            128, 102, 204,
            153, 102, 153,
            179, 102, 128,
            255, 102, 102,
            255, 153, 102,
            255, 179, 102,
            255, 204, 102,
            255, 255, 77,
            204, 204, 102,
            102, 153, 102,
            128, 179, 179, // seventh row
            128, 153, 255,
            153, 128, 230,
            179, 128, 179,
            204, 128, 153,
            255, 128, 128,
            255, 153, 128,
            255, 204, 128,
            255, 230, 102,
            255, 255, 102,
            230, 230, 128,
            128, 179, 128,
            153, 204, 204, // eigth row
            153, 179, 255,
            179, 153, 255,
            204, 153, 204,
            230, 153, 179,
            255, 153, 153,
            255, 179, 128,
            255, 204, 153,
            255, 230, 128,
            255, 255, 128,
            230, 230, 153,
            153, 204, 153,
            179, 230, 230, // ninth row
            179, 204, 255,
            204, 179, 255,
            230, 179, 230,
            230, 179, 204,
            255, 179, 179,
            255, 179, 153,
            255, 230, 179,
            255, 230, 153,
            255, 255, 153,
            230, 230, 179,
            179, 230, 179,
            204, 255, 255, // tenth row
            204, 230, 255,
            230, 204, 255,
            255, 204, 255,
            255, 204, 230,
            255, 204, 204,
            255, 204, 179,
            255, 230, 204,
            255, 255, 179,
            255, 255, 204,
            230, 230, 204,
            204, 255, 204
    };

    private static final int NUM_OF_COLORS = RAW_VALUES.length / 3;
    private static final int NUM_OF_ROWS = NUM_OF_COLORS / NUM_OF_COLUMNS;
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/ProgressIndicatorSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.control.skin.Utils;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.NodeOrientation;
import javafx.geometry.VPos;
import javafx.scene.Node;
import javafx.scene.control.Control;
import javafx.scene.control.ProgressIndicator;
import javafx.scene.control.SkinBase;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.scene.shape.Arc;
import javafx.scene.shape.ArcType;
import javafx.scene.shape.Circle;
import javafx.scene.text.Text;
import javafx.scene.text.TextBoundsType;
import javafx.scene.transform.Scale;
import javafx.util.Duration;
import javafx.css.CssMetaData;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableIntegerProperty;
import javafx.css.converter.BooleanConverter;
import javafx.css.converter.PaintConverter;
import javafx.css.converter.SizeConverter;
import com.sun.javafx.scene.control.skin.resources.ControlResources;
import javafx.css.Styleable;

/**
 * Default skin implementation for the {@link ProgressIndicator} control.
 *
 * @see ProgressIndicator
 * @since 9
 */
public class ProgressIndicatorSkin extends SkinBase&lt;ProgressIndicator&gt; {

    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    // JDK-8149818: This constant should not be static, because the
    // Locale may change between instances.

    /** DONE string is just used to know the size of Done as that is the biggest text we need to allow for */
    private final String DONE = ControlResources.getString(&quot;ProgressIndicator.doneString&quot;);

    final Duration CLIPPED_DELAY = new Duration(300);
    final Duration UNCLIPPED_DELAY = new Duration(0);

    private IndeterminateSpinner spinner;
    private DeterminateIndicator determinateIndicator;
    private ProgressIndicator control;

    Animation indeterminateTransition;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new ProgressIndicatorSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list.
     *
     * @param control The control that this skin should be installed onto.
     */
    public ProgressIndicatorSkin(ProgressIndicator control) {
        super(control);

        this.control = control;

        // register listeners
        registerChangeListener(control.indeterminateProperty(), e -&gt; initialize());
        registerChangeListener(control.progressProperty(), e -&gt; updateProgress());
        registerChangeListener(NodeHelper.treeShowingProperty(control), e -&gt; updateAnimation());
        registerChangeListener(control.sceneProperty(), e-&gt;updateAnimation());

        initialize();
        updateAnimation();
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * The colour of the progress segment.
     */
    private ObjectProperty&lt;Paint&gt; progressColor = new StyleableObjectProperty&lt;Paint&gt;(null) {
        @Override protected void invalidated() {
            final Paint value = get();
            if (value != null &amp;&amp; !(value instanceof Color)) {
                if (isBound()) {
                    unbind();
                }
                set(null);
                throw new IllegalArgumentException(&quot;Only Color objects are supported&quot;);
            }
            if (spinner!=null) spinner.setFillOverride(value);
            if (determinateIndicator!=null) determinateIndicator.setFillOverride(value);
        }

        @Override public Object getBean() {
            return ProgressIndicatorSkin.this;
        }

        @Override public String getName() {
            return &quot;progressColorProperty&quot;;
        }

        @Override public CssMetaData&lt;ProgressIndicator,Paint&gt; getCssMetaData() {
            return PROGRESS_COLOR;
        }
    };

    Paint getProgressColor() {
        return progressColor.get();
    }

    /**
     * The number of segments in the spinner.
     */
    private IntegerProperty indeterminateSegmentCount = new StyleableIntegerProperty(8) {
        @Override protected void invalidated() {
            if (spinner!=null) spinner.rebuild();
        }

        @Override public Object getBean() {
            return ProgressIndicatorSkin.this;
        }

        @Override public String getName() {
            return &quot;indeterminateSegmentCount&quot;;
        }

        @Override public CssMetaData&lt;ProgressIndicator,Number&gt; getCssMetaData() {
            return INDETERMINATE_SEGMENT_COUNT;
        }
    };

    /**
     * True if the progress indicator should rotate as well as animate opacity.
     */
    private final BooleanProperty spinEnabled = new StyleableBooleanProperty(false) {
        @Override protected void invalidated() {
            if (spinner!=null) spinner.setSpinEnabled(get());
        }

        @Override public CssMetaData&lt;ProgressIndicator,Boolean&gt; getCssMetaData() {
            return SPIN_ENABLED;
        }

        @Override public Object getBean() {
            return ProgressIndicatorSkin.this;
        }

        @Override public String getName() {
            return &quot;spinEnabled&quot;;
        }
    };



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (indeterminateTransition != null) {
            indeterminateTransition.stop();
            indeterminateTransition = null;
        }

        if (spinner != null) {
            spinner = null;
        }

        control = null;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        if (spinner != null &amp;&amp; control.isIndeterminate()) {
            spinner.layoutChildren();
            spinner.resizeRelocate(0, 0, w, h);
        } else if (determinateIndicator != null) {
            determinateIndicator.layoutChildren();
            determinateIndicator.resizeRelocate(0, 0, w, h);
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        double minWidth = 0.0;

        if (spinner != null &amp;&amp; control.isIndeterminate()) {
            minWidth = spinner.minWidth(-1);
        } else if (determinateIndicator != null) {
            minWidth = determinateIndicator.minWidth(-1);
        }
        return minWidth;
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        double minHeight = 0.0;

        if (spinner != null &amp;&amp; control.isIndeterminate()) {
            minHeight = spinner.minHeight(-1);
        } else if (determinateIndicator != null) {
            minHeight = determinateIndicator.minHeight(-1);
        }
        return minHeight;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        double prefWidth = 0.0;

        if (spinner != null &amp;&amp; control.isIndeterminate()) {
            prefWidth = spinner.prefWidth(height);
        } else if (determinateIndicator != null) {
            prefWidth = determinateIndicator.prefWidth(height);
        }
        return prefWidth;
    }

   /** {@inheritDoc} */
   @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        double prefHeight = 0.0;

        if (spinner != null &amp;&amp; control.isIndeterminate()) {
            prefHeight = spinner.prefHeight(width);
        } else if (determinateIndicator != null) {
            prefHeight = determinateIndicator.prefHeight(width);
        }
        return prefHeight;
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return computePrefWidth(height, topInset, rightInset, bottomInset, leftInset);
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return computePrefHeight(width, topInset, rightInset, bottomInset, leftInset);
    }


    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    void initialize() {
        boolean isIndeterminate = control.isIndeterminate();
        if (isIndeterminate) {
            // clean up determinateIndicator
            determinateIndicator = null;

            // create spinner
            spinner = new IndeterminateSpinner(spinEnabled.get(), progressColor.get());
            getChildren().setAll(spinner);
            if (NodeHelper.isTreeShowing(control)) {
                if (indeterminateTransition != null) {
                    indeterminateTransition.play();
                }
            }
        } else {
            // clean up after spinner
            if (spinner != null) {
                if (indeterminateTransition != null) {
                    indeterminateTransition.stop();
                }
                spinner = null;
            }

            // create determinateIndicator
            determinateIndicator = new DeterminateIndicator(control, this, progressColor.get());
            getChildren().setAll(determinateIndicator);
        }
    }

    void updateProgress() {
        if (determinateIndicator != null) {
            determinateIndicator.updateProgress(control.getProgress());
        }
    }

    void createIndeterminateTimeline() {
        if (spinner != null) {
            spinner.rebuildTimeline();
        }
    }

    void pauseTimeline(boolean pause) {
        if (getSkinnable().isIndeterminate()) {
            if (indeterminateTransition == null) {
                createIndeterminateTimeline();
            }
            if (pause) {
                indeterminateTransition.pause();
            } else {
                indeterminateTransition.play();
            }
        }
    }

    void updateAnimation() {
        ProgressIndicator control = getSkinnable();
        final boolean isTreeShowing = NodeHelper.isTreeShowing(control) &amp;&amp;
                                      control.getScene() != null;
        if (indeterminateTransition != null) {
            pauseTimeline(!isTreeShowing);
        } else if (isTreeShowing) {
            createIndeterminateTimeline();
        }
    }



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final CssMetaData&lt;ProgressIndicator,Paint&gt; PROGRESS_COLOR =
            new CssMetaData&lt;ProgressIndicator,Paint&gt;(&quot;-fx-progress-color&quot;,
                    PaintConverter.getInstance(), null) {

                @Override
                public boolean isSettable(ProgressIndicator n) {
                    final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
                    return skin.progressColor == null ||
                            !skin.progressColor.isBound();
                }

                @Override
                public StyleableProperty&lt;Paint&gt; getStyleableProperty(ProgressIndicator n) {
                    final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
                    return (StyleableProperty&lt;Paint&gt;)(WritableValue&lt;Paint&gt;)skin.progressColor;
                }
            };
    private static final CssMetaData&lt;ProgressIndicator,Number&gt; INDETERMINATE_SEGMENT_COUNT =
            new CssMetaData&lt;ProgressIndicator,Number&gt;(&quot;-fx-indeterminate-segment-count&quot;,
                    SizeConverter.getInstance(), 8) {

                @Override public boolean isSettable(ProgressIndicator n) {
                    final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
                    return skin.indeterminateSegmentCount == null ||
                            !skin.indeterminateSegmentCount.isBound();
                }

                @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(ProgressIndicator n) {
                    final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
                    return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)skin.indeterminateSegmentCount;
                }
            };
    private static final CssMetaData&lt;ProgressIndicator,Boolean&gt; SPIN_ENABLED =
            new CssMetaData&lt;ProgressIndicator,Boolean&gt;(&quot;-fx-spin-enabled&quot;, BooleanConverter.getInstance(), Boolean.FALSE) {

                @Override public boolean isSettable(ProgressIndicator node) {
                    final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) node.getSkin();
                    return skin.spinEnabled == null || !skin.spinEnabled.isBound();
                }

                @Override public StyleableProperty&lt;Boolean&gt; getStyleableProperty(ProgressIndicator node) {
                    final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) node.getSkin();
                    return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)skin.spinEnabled;
                }
            };

    private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
    static {
        final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
        styleables.add(PROGRESS_COLOR);
        styleables.add(INDETERMINATE_SEGMENT_COUNT);
        styleables.add(SPIN_ENABLED);
        STYLEABLES = Collections.unmodifiableList(styleables);
    }

    /**
     * Returns the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    private final class DeterminateIndicator extends Region {
        private double textGap = 2.0F;

        // only update progress text on whole percentages
        private int intProgress;

        // only update pie arc to nearest degree
        private int degProgress;
        private Text text;
        private StackPane indicator;
        private StackPane progress;
        private StackPane tick;
        private Arc arcShape;
        private Circle indicatorCircle;
        private double doneTextWidth;
        private double doneTextHeight;

        public DeterminateIndicator(ProgressIndicator control, ProgressIndicatorSkin s, Paint fillOverride) {

            getStyleClass().add(&quot;determinate-indicator&quot;);

            intProgress = (int) Math.round(control.getProgress() * 100.0) ;
            degProgress = (int) (360 * control.getProgress());

            getChildren().clear();

            text = new Text((control.getProgress() &gt;= 1) ? (DONE) : (&quot;&quot; + intProgress + &quot;%&quot;));
            text.setTextOrigin(VPos.TOP);
            text.getStyleClass().setAll(&quot;text&quot;, &quot;percentage&quot;);

            registerChangeListener(text.fontProperty(), o -&gt; {
                doneTextWidth = Utils.computeTextWidth(text.getFont(), DONE, 0);
                doneTextHeight = Utils.computeTextHeight(text.getFont(), DONE, 0, TextBoundsType.LOGICAL_VERTICAL_CENTER);
            });

            // The circular background for the progress pie piece
            indicator = new StackPane();
            indicator.setScaleShape(false);
            indicator.setCenterShape(false);
            indicator.getStyleClass().setAll(&quot;indicator&quot;);
            indicatorCircle = new Circle();
            indicator.setShape(indicatorCircle);

            // The shape for our progress pie piece
            arcShape = new Arc();
            arcShape.setType(ArcType.ROUND);
            arcShape.setStartAngle(90.0F);

            // Our progress pie piece
            progress = new StackPane();
            progress.getStyleClass().setAll(&quot;progress&quot;);
            progress.setScaleShape(false);
            progress.setCenterShape(false);
            progress.setShape(arcShape);
            progress.getChildren().clear();
            setFillOverride(fillOverride);

            // The check mark that's drawn at 100%
            tick = new StackPane();
            tick.getStyleClass().setAll(&quot;tick&quot;);

            getChildren().setAll(indicator, progress, text, tick);
            updateProgress(control.getProgress());
        }

        private void setFillOverride(Paint fillOverride) {
            if (fillOverride instanceof Color) {
                Color c = (Color)fillOverride;
                progress.setStyle(&quot;-fx-background-color: rgba(&quot;+((int)(255*c.getRed()))+&quot;,&quot;+((int)(255*c.getGreen()))+&quot;,&quot;+((int)(255*c.getBlue()))+&quot;,&quot;+c.getOpacity()+&quot;);&quot;);
            } else {
                progress.setStyle(null);
            }
        }

        @Override public boolean usesMirroring() {
            // This is used instead of setting NodeOrientation,
            // allowing the Text node to inherit the current
            // orientation.
            return false;
        }

        private void updateProgress(double progress) {
            intProgress = (int) Math.round(progress * 100.0) ;
            text.setText((progress &gt;= 1) ? (DONE) : (&quot;&quot; + intProgress + &quot;%&quot;));

            degProgress = (int) (360 * progress);
            arcShape.setLength(-degProgress);
            requestLayout();
        }

        @Override protected void layoutChildren() {
            // Position and size the circular background
            final double left = control.snappedLeftInset();
            final double right = control.snappedRightInset();
            final double top = control.snappedTopInset();
            final double bottom = control.snappedBottomInset();

            /*
            ** use the min of width, or height, keep it a circle
            */
            final double areaW = control.getWidth() - left - right;
            final double areaH = control.getHeight() - top - bottom - textGap - doneTextHeight;
            final double radiusW = areaW / 2;
            final double radiusH = areaH / 2;
            final double radius = Math.floor(Math.min(radiusW, radiusH));
            final double centerX = snapPosition(left + radiusW);
            final double centerY = snapPosition(top + radius);

            // find radius that fits inside radius - insetsPadding
            final double iLeft = indicator.snappedLeftInset();
            final double iRight = indicator.snappedRightInset();
            final double iTop = indicator.snappedTopInset();
            final double iBottom = indicator.snappedBottomInset();
            final double progressRadius = snapSize(Math.min(
                    Math.min(radius - iLeft, radius - iRight),
                    Math.min(radius - iTop, radius - iBottom)));

            indicatorCircle.setRadius(radius);
            indicator.setLayoutX(centerX);
            indicator.setLayoutY(centerY);

            arcShape.setRadiusX(progressRadius);
            arcShape.setRadiusY(progressRadius);
            progress.setLayoutX(centerX);
            progress.setLayoutY(centerY);

            // find radius that fits inside progressRadius - progressInsets
            final double pLeft = progress.snappedLeftInset();
            final double pRight = progress.snappedRightInset();
            final double pTop = progress.snappedTopInset();
            final double pBottom = progress.snappedBottomInset();
            final double indicatorRadius = snapSize(Math.min(
                    Math.min(progressRadius - pLeft, progressRadius - pRight),
                    Math.min(progressRadius - pTop, progressRadius - pBottom)));

            // find size of spare box that fits inside indicator radius
            double squareBoxHalfWidth = Math.ceil(Math.sqrt((indicatorRadius * indicatorRadius) / 2));

            tick.setLayoutX(centerX - squareBoxHalfWidth);
            tick.setLayoutY(centerY - squareBoxHalfWidth);
            tick.resize(squareBoxHalfWidth + squareBoxHalfWidth, squareBoxHalfWidth + squareBoxHalfWidth);
            tick.setVisible(control.getProgress() &gt;= 1);

            // if the % text can't fit anywhere in the bounds then don't display it
            double textWidth = text.getLayoutBounds().getWidth();
            double textHeight = text.getLayoutBounds().getHeight();
            if (control.getWidth() &gt;= textWidth &amp;&amp; control.getHeight() &gt;= textHeight) {
                if (!text.isVisible()) text.setVisible(true);
                text.setLayoutY(snapPosition(centerY + radius + textGap));
                text.setLayoutX(snapPosition(centerX - (textWidth/2)));
            } else {
                if (text.isVisible()) text.setVisible(false);
            }
        }

        @Override protected double computePrefWidth(double height) {
            final double left = control.snappedLeftInset();
            final double right = control.snappedRightInset();
            final double iLeft = indicator.snappedLeftInset();
            final double iRight = indicator.snappedRightInset();
            final double iTop = indicator.snappedTopInset();
            final double iBottom = indicator.snappedBottomInset();
            final double indicatorMax = snapSize(Math.max(Math.max(iLeft, iRight), Math.max(iTop, iBottom)));
            final double pLeft = progress.snappedLeftInset();
            final double pRight = progress.snappedRightInset();
            final double pTop = progress.snappedTopInset();
            final double pBottom = progress.snappedBottomInset();
            final double progressMax = snapSize(Math.max(Math.max(pLeft, pRight), Math.max(pTop, pBottom)));
            final double tLeft = tick.snappedLeftInset();
            final double tRight = tick.snappedRightInset();
            final double indicatorWidth = indicatorMax + progressMax + tLeft + tRight + progressMax + indicatorMax;
            return left + Math.max(indicatorWidth, doneTextWidth) + right;
        }

        @Override protected double computePrefHeight(double width) {
            final double top = control.snappedTopInset();
            final double bottom = control.snappedBottomInset();
            final double iLeft = indicator.snappedLeftInset();
            final double iRight = indicator.snappedRightInset();
            final double iTop = indicator.snappedTopInset();
            final double iBottom = indicator.snappedBottomInset();
            final double indicatorMax = snapSize(Math.max(Math.max(iLeft, iRight), Math.max(iTop, iBottom)));
            final double pLeft = progress.snappedLeftInset();
            final double pRight = progress.snappedRightInset();
            final double pTop = progress.snappedTopInset();
            final double pBottom = progress.snappedBottomInset();
            final double progressMax = snapSize(Math.max(Math.max(pLeft, pRight), Math.max(pTop, pBottom)));
            final double tTop = tick.snappedTopInset();
            final double tBottom = tick.snappedBottomInset();
            final double indicatorHeight = indicatorMax + progressMax + tTop + tBottom + progressMax + indicatorMax;
            return top + indicatorHeight + textGap + doneTextHeight + bottom;
        }

        @Override protected double computeMaxWidth(double height) {
            return computePrefWidth(height);
        }

        @Override protected double computeMaxHeight(double width) {
            return computePrefHeight(width);
        }
    }


    private final class IndeterminateSpinner extends Region {
        private IndicatorPaths pathsG;
        private final List&lt;Double&gt; opacities = new ArrayList&lt;&gt;();
        private boolean spinEnabled = false;
        private Paint fillOverride = null;

        private IndeterminateSpinner(boolean spinEnabled, Paint fillOverride) {
            this.spinEnabled = spinEnabled;
            this.fillOverride = fillOverride;

            setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
<A NAME="37"></A>            getStyleClass().setAll(&quot;spinner&quot;);

            pathsG = new IndicatorPaths();
            <FONT color="#810541"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#37',2,'match37-top.html#37',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getChildren().add(pathsG);
            rebuild();

            rebuildTimeline();

        }

        public void setFillOverride(Paint fillOverride) {
            this.fillOverride = fillOverride;
            rebuild();
        }

        public void se</B></FONT>tSpinEnabled(boolean spinEnabled) {
            this.spinEnabled = spinEnabled;
            rebuildTimeline();
        }

        private void rebuildTimeline() {
            if (spinEnabled) {
                if (indeterminateTransition == null) {
                    indeterminateTransition = new Timeline();
                    indeterminateTransition.setCycleCount(Timeline.INDEFINITE);
                    indeterminateTransition.setDelay(UNCLIPPED_DELAY);
                } else {
                    indeterminateTransition.stop();
                    ((Timeline)indeterminateTransition).getKeyFrames().clear();
                }
                final ObservableList&lt;KeyFrame&gt; keyFrames = FXCollections.&lt;KeyFrame&gt;observableArrayList();

                keyFrames.add(new KeyFrame(Duration.millis(1), new KeyValue(pathsG.rotateProperty(), 360)));
                keyFrames.add(new KeyFrame(Duration.millis(3900), new KeyValue(pathsG.rotateProperty(), 0)));

                for (int i = 100; i &lt;= 3900; i += 100) {
                    keyFrames.add(new KeyFrame(Duration.millis(i), event -&gt; shiftColors()));
                }

                ((Timeline)indeterminateTransition).getKeyFrames().setAll(keyFrames);
                indeterminateTransition.playFromStart();
            } else {
                if (indeterminateTransition != null) {
                    indeterminateTransition.stop();
                    ((Timeline)indeterminateTransition).getKeyFrames().clear();
                    indeterminateTransition = null;
                }
            }
        }

        private class IndicatorPaths extends Pane {
            @Override protected double computePrefWidth(double height) {
                double w = 0;
                for(Node child: getChildren()) {
                    if (child instanceof Region) {
                        Region region = (Region)child;
                        if (region.getShape() != null) {
                            w = Math.max(w,region.getShape().getLayoutBounds().getMaxX());
                        } else {
                            w = Math.max(w,region.prefWidth(height));
                        }
                    }
                }
                return w;
            }

            @Override protected double computePrefHeight(double width) {
                double h = 0;
                for(Node child: getChildren()) {
                    if (child instanceof Region) {
                        Region region = (Region)child;
                        if (region.getShape() != null) {
                            h = Math.max(h,region.getShape().getLayoutBounds().getMaxY());
                        } else {
                            h = Math.max(h,region.prefHeight(width));
                        }
                    }
                }
                return h;
            }

            @Override protected void layoutChildren() {
                // calculate scale
                double scale = getWidth() / computePrefWidth(-1);
                for(Node child: getChildren()) {
                    if (child instanceof Region) {
                        Region region = (Region)child;
                        if (region.getShape() != null) {
                            region.resize(
                                    region.getShape().getLayoutBounds().getMaxX(),
                                    region.getShape().getLayoutBounds().getMaxY()
                            );
                            region.getTransforms().setAll(new Scale(scale,scale,0,0));
                        } else {
                            region.autosize();
                        }
                    }
                }
            }
        }

        @Override protected void layoutChildren() {
            final double w = control.getWidth() - control.snappedLeftInset() - control.snappedRightInset();
            final double h = control.getHeight() - control.snappedTopInset() - control.snappedBottomInset();
            final double prefW = pathsG.prefWidth(-1);
            final double prefH = pathsG.prefHeight(-1);
            double scaleX = w / prefW;
            double scale = scaleX;
            if ((scaleX * prefH) &gt; h) {
                scale = h / prefH;
            }
            double indicatorW = prefW * scale;
            double indicatorH = prefH * scale;
            pathsG.resizeRelocate((w - indicatorW) / 2, (h - indicatorH) / 2, indicatorW, indicatorH);
        }

        private void rebuild() {
            // update indeterminate indicator
            final int segments = indeterminateSegmentCount.get();
            opacities.clear();
            pathsG.getChildren().clear();
            final double step = 0.8/(segments-1);
            for (int i = 0; i &lt; segments; i++) {
                Region region = new Region();
                region.setScaleShape(false);
                region.setCenterShape(false);
                region.getStyleClass().addAll(&quot;segment&quot;, &quot;segment&quot; + i);
                if (fillOverride instanceof Color) {
                    Color c = (Color)fillOverride;
                    region.setStyle(&quot;-fx-background-color: rgba(&quot;+((int)(255*c.getRed()))+&quot;,&quot;+((int)(255*c.getGreen()))+&quot;,&quot;+((int)(255*c.getBlue()))+&quot;,&quot;+c.getOpacity()+&quot;);&quot;);
                } else {
                    region.setStyle(null);
                }
                pathsG.getChildren().add(region);
                opacities.add(Math.max(0.1, (1.0 - (step*i))));
            }
        }

        private void shiftColors() {
            if (opacities.size() &lt;= 0) return;
            final int segments = indeterminateSegmentCount.get();
            Collections.rotate(opacities, -1);
            for (int i = 0; i &lt; segments; i++) {
                pathsG.getChildren().get(i).setOpacity(opacities.get(i));
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TabPaneSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.TabObservableList;
import com.sun.javafx.util.Utils;
import javafx.animation.Animation;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.animation.Transition;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Point2D;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.geometry.VPos;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Control;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.control.RadioMenuItem;
import javafx.scene.control.SkinBase;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.control.TabPane.TabClosingPolicy;
import javafx.scene.control.TabPane.TabDragPolicy;
import javafx.scene.control.ToggleGroup;
import javafx.scene.control.Tooltip;
import javafx.scene.effect.DropShadow;
import javafx.scene.image.ImageView;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.input.SwipeEvent;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import javafx.css.converter.EnumConverter;
import com.sun.javafx.scene.control.behavior.TabPaneBehavior;

import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;

/**
 * Default skin implementation for the {@link TabPane} control.
 *
 * @see TabPane
 * @since 9
 */
public class TabPaneSkin extends SkinBase&lt;TabPane&gt; {

    /***************************************************************************
     *                                                                         *
     * Enums                                                                   *
     *                                                                         *
     **************************************************************************/

    private enum TabAnimation {
        NONE,
        GROW
        // In future we could add FADE, ...
    }

    private enum TabAnimationState {
        SHOWING, HIDING, NONE;
    }



    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    static int CLOSE_BTN_SIZE = 16;



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private static final double ANIMATION_SPEED = 150;
    private static final int SPACER = 10;

    private TabHeaderArea tabHeaderArea;
    private ObservableList&lt;TabContentRegion&gt; tabContentRegions;
    private Rectangle clipRect;
    private Rectangle tabHeaderAreaClipRect;
    private Tab selectedTab;
    private boolean isSelectingTab;

    private final TabPaneBehavior behavior;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TabPaneSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TabPaneSkin(TabPane control) {
        super(control);

        // install default input map for the TabPane control
        this.behavior = new TabPaneBehavior(control);
//        control.setInputMap(behavior.getInputMap());

        clipRect = new Rectangle(control.getWidth(), control.getHeight());
        getSkinnable().setClip(clipRect);

        tabContentRegions = FXCollections.&lt;TabContentRegion&gt;observableArrayList();

        for (Tab tab : getSkinnable().getTabs()) {
            addTabContent(tab);
        }

        tabHeaderAreaClipRect = new Rectangle();
        tabHeaderArea = new TabHeaderArea();
        tabHeaderArea.setClip(tabHeaderAreaClipRect);
        getChildren().add(tabHeaderArea);
        if (getSkinnable().getTabs().size() == 0) {
            tabHeaderArea.setVisible(false);
        }

        initializeTabListener();

        registerChangeListener(control.getSelectionModel().selectedItemProperty(), e -&gt; {
            isSelectingTab = true;
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.sideProperty(), e -&gt; updateTabPosition());
        registerChangeListener(control.widthProperty(), e -&gt; clipRect.setWidth(getSkinnable().getWidth()));
        registerChangeListener(control.heightProperty(), e -&gt; clipRect.setHeight(getSkinnable().getHeight()));

        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        // Could not find the selected tab try and get the selected tab using the selected index
        if (selectedTab == null &amp;&amp; getSkinnable().getSelectionModel().getSelectedIndex() != -1) {
            getSkinnable().getSelectionModel().select(getSkinnable().getSelectionModel().getSelectedIndex());
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        }
        if (selectedTab == null) {
            // getSelectedItem and getSelectedIndex failed select the first.
            getSkinnable().getSelectionModel().selectFirst();
        }
        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        isSelectingTab = false;

        initializeSwipeHandlers();
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    private ObjectProperty&lt;TabAnimation&gt; openTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.OPEN_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;openTabAnimation&quot;;
        }
    };

    private ObjectProperty&lt;TabAnimation&gt; closeTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.CLOSE_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;closeTabAnimation&quot;;
        }
    };



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as wide as it widest content width.
        double maxw = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxw = Math.max(maxw, snapSizeX(contentRegion.prefWidth(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeX(tabHeaderArea.prefWidth(-1))
                : snapSizeY(tabHeaderArea.prefHeight(-1));

        double prefWidth = isHorizontal ?
                Math.max(maxw, tabHeaderAreaSize) : maxw + tabHeaderAreaSize;
        return snapSizeX(prefWidth) + rightInset + leftInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as high as it highest content height.
        double maxh = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxh = Math.max(maxh, snapSizeY(contentRegion.prefHeight(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefWidth(-1));

        double prefHeight = isHorizontal ?
                maxh + snapSizeY(tabHeaderAreaSize) : Math.max(maxh, tabHeaderAreaSize);
        return snapSizeY(prefHeight) + topInset + bottomInset;
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        Side tabPosition = getSkinnable().getSide();
        if (tabPosition == Side.TOP) {
            return tabHeaderArea.getBaselineOffset() + topInset;
        }
        return 0;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        TabPane tabPane = getSkinnable();
        Side tabPosition = tabPane.getSide();

        double headerHeight = tabPosition.isHorizontal()
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefHeight(-1));
        double tabsStartX = tabPosition.equals(Side.RIGHT)? x + w - headerHeight : x;
        double tabsStartY = tabPosition.equals(Side.BOTTOM)? y + h - headerHeight : y;

        final double leftInset = snappedLeftInset();
        final double topInset = snappedTopInset();

        if (tabPosition == Side.TOP) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(tabsStartX, tabsStartY);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.TOP)));
        } else if (tabPosition == Side.BOTTOM) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(w + leftInset, tabsStartY - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.BOTTOM), 0, headerHeight));
        } else if (tabPosition == Side.LEFT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX + headerHeight, h - headerHeight + topInset);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.LEFT), 0, headerHeight));
        } else if (tabPosition == Side.RIGHT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX, y - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.RIGHT), 0, headerHeight));
        }

        tabHeaderAreaClipRect.setX(0);
        tabHeaderAreaClipRect.setY(0);
        if (isHorizontal()) {
            tabHeaderAreaClipRect.setWidth(w);
        } else {
            tabHeaderAreaClipRect.setWidth(h);
        }
        tabHeaderAreaClipRect.setHeight(headerHeight);

        // ==================================
        // position the tab content for the selected tab only
        // ==================================
        // if the tabs are on the left, the content needs to be indented
        double contentStartX = 0;
        double contentStartY = 0;

        if (tabPosition == Side.TOP) {
            contentStartX = x;
            contentStartY = y + headerHeight;
            if (isFloatingStyleClass()) {
                // This is to hide the top border content
                contentStartY -= 1;
            }
        } else if (tabPosition == Side.BOTTOM) {
            contentStartX = x;
            contentStartY = y + topInset;
            if (isFloatingStyleClass()) {
                // This is to hide the bottom border content
                contentStartY = 1 + topInset;
            }
        } else if (tabPosition == Side.LEFT) {
            contentStartX = x + headerHeight;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the left border content
                contentStartX -= 1;
            }
        } else if (tabPosition == Side.RIGHT) {
            contentStartX = x + leftInset;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the right border content
                contentStartX = 1 + leftInset;
            }
        }

        double contentWidth = w - (isHorizontal() ? 0 : headerHeight);
        double contentHeight = h - (isHorizontal() ? headerHeight: 0);

        for (int i = 0, max = tabContentRegions.size(); i &lt; max; i++) {
            TabContentRegion tabContent = tabContentRegions.get(i);

            tabContent.setAlignment(Pos.TOP_LEFT);
            if (tabContent.getClip() != null) {
                ((Rectangle)tabContent.getClip()).setWidth(contentWidth);
                ((Rectangle)tabContent.getClip()).setHeight(contentHeight);
            }

            // we need to size all tabs, even if they aren't visible. For example,
            // see RT-29167
            tabContent.resize(contentWidth, contentHeight);
            tabContent.relocate(contentStartX, contentStartY);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private static int getRotation(Side pos) {
        switch (pos) {
            case TOP:
                return 0;
            case BOTTOM:
                return 180;
            case LEFT:
                return -90;
            case RIGHT:
                return 90;
            default:
                return 0;
        }
    }

    /**
     * VERY HACKY - this lets us 'duplicate' Label and ImageView nodes to be used in a
     * Tab and the tabs menu at the same time.
     */
    private static Node clone(Node n) {
        if (n == null) {
            return null;
        }
        if (n instanceof ImageView) {
            ImageView iv = (ImageView) n;
            ImageView imageview = new ImageView();
            imageview.imageProperty().bind(iv.imageProperty());
            return imageview;
        }
        if (n instanceof Label) {
            Label l = (Label)n;
            Label label = new Label(l.getText(), clone(l.getGraphic()));
            label.textProperty().bind(l.textProperty());
            return label;
        }
        return null;
    }

    private void removeTabs(List&lt;? extends Tab&gt; removedList) {
        for (final Tab tab : removedList) {
            stopCurrentAnimation(tab);
            // Animate the tab removal
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                tabRegion.isClosing = true;

                tabRegion.removeListeners(tab);
                removeTabContent(tab);

                EventHandler&lt;ActionEvent&gt; cleanup = ae -&gt; {
                    tabRegion.animationState = TabAnimationState.NONE;

                    tabHeaderArea.removeTab(tab);
                    tabHeaderArea.requestLayout();
                    if (getSkinnable().getTabs().isEmpty()) {
                        tabHeaderArea.setVisible(false);
                    }
                };

                if (closeTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.HIDING;
                    Timeline closedTabTimeline = tabRegion.currentAnimation =
                            createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 0.0F, cleanup);
                    closedTabTimeline.play();
                } else {
                    cleanup.handle(null);
                }
            }
        }
    }

    private void stopCurrentAnimation(Tab tab) {
        final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
        if (tabRegion != null) {
            // Execute the code immediately, don't wait for the animation to finish.
            Timeline timeline = tabRegion.currentAnimation;
            if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING) {
                timeline.getOnFinished().handle(null);
                timeline.stop();
                tabRegion.currentAnimation = null;
            }
        }
    }

    private void addTabs(List&lt;? extends Tab&gt; addedList, int from) {
        int i = 0;

        // RT-39984: check if any other tabs are animating - they must be completed first.
        List&lt;Node&gt; headers = new ArrayList&lt;&gt;(tabHeaderArea.headersRegion.getChildren());
        for (Node n : headers) {
            TabHeaderSkin header = (TabHeaderSkin) n;
            if (header.animationState == TabAnimationState.HIDING) {
                stopCurrentAnimation(header.tab);
            }
        }
        // end of fix for RT-39984

        for (final Tab tab : addedList) {
            stopCurrentAnimation(tab); // Note that this must happen before addTab() call below
            // A new tab was added - animate it out
            if (!tabHeaderArea.isVisible()) {
                tabHeaderArea.setVisible(true);
            }
            int index = from + i++;
            tabHeaderArea.addTab(tab, index);
            addTabContent(tab);
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                if (openTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.SHOWING;
                    tabRegion.animationTransition.setValue(0.0);
                    tabRegion.setVisible(true);
                    tabRegion.currentAnimation = createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 1.0, event -&gt; {
                        tabRegion.animationState = TabAnimationState.NONE;
                        tabRegion.setVisible(true);
                        tabRegion.inner.requestLayout();
                    });
                    tabRegion.currentAnimation.play();
                } else {
                    tabRegion.setVisible(true);
                    tabRegion.inner.requestLayout();
                }
            }
        }
    }

    private void initializeTabListener() {
        getSkinnable().getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; {
            List&lt;Tab&gt; tabsToRemove = new ArrayList&lt;&gt;();
            List&lt;Tab&gt; tabsToAdd = new ArrayList&lt;&gt;();
            int insertPos = -1;

            while (c.next()) {
                if (c.wasPermutated()) {
                    if (dragState != DragState.REORDER) {
                        TabPane tabPane = getSkinnable();
                        List&lt;Tab&gt; tabs = tabPane.getTabs();

                        // tabs sorted : create list of permutated tabs.
                        // clear selection, set tab animation to NONE
                        // remove permutated tabs, add them back in correct order.
                        // restore old selection, and old tab animation states.
                        int size = c.getTo() - c.getFrom();
                        Tab selTab = tabPane.getSelectionModel().getSelectedItem();
                        List&lt;Tab&gt; permutatedTabs = new ArrayList&lt;Tab&gt;(size);
                        getSkinnable().getSelectionModel().clearSelection();

                        // save and set tab animation to none - as it is not a good idea
                        // to animate on the same data for open and close.
                        TabAnimation prevOpenAnimation = openTabAnimation.get();
                        TabAnimation prevCloseAnimation = closeTabAnimation.get();
                        openTabAnimation.set(TabAnimation.NONE);
                        closeTabAnimation.set(TabAnimation.NONE);
                        for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                            permutatedTabs.add(tabs.get(i));
                        }

                        removeTabs(permutatedTabs);
                        addTabs(permutatedTabs, c.getFrom());
                        openTabAnimation.set(prevOpenAnimation);
                        closeTabAnimation.set(prevCloseAnimation);
                        getSkinnable().getSelectionModel().select(selTab);
                    }
                }

                if (c.wasRemoved()) {
                    tabsToRemove.addAll(c.getRemoved());
                }
                if (c.wasAdded()) {
                    tabsToAdd.addAll(c.getAddedSubList());
                    insertPos = c.getFrom();
                }
            }

            // now only remove the tabs that are not in the tabsToAdd list
            tabsToRemove.removeAll(tabsToAdd);
            removeTabs(tabsToRemove);

            // and add in any new tabs (that we don't already have showing)
            if (!tabsToAdd.isEmpty()) {
                for (TabContentRegion tabContentRegion : tabContentRegions) {
                    Tab tab = tabContentRegion.getTab();
                    TabHeaderSkin tabHeader = tabHeaderArea.getTabHeaderSkin(tab);
                    if (!tabHeader.isClosing &amp;&amp; tabsToAdd.contains(tabContentRegion.getTab())) {
                        tabsToAdd.remove(tabContentRegion.getTab());
                    }
                }

                addTabs(tabsToAdd, insertPos == -1 ? tabContentRegions.size() : insertPos);
            }

            // Fix for RT-34692
            getSkinnable().requestLayout();
        });
    }

    private void addTabContent(Tab tab) {
        TabContentRegion tabContentRegion = new TabContentRegion(tab);
        tabContentRegion.setClip(new Rectangle());
        tabContentRegions.add(tabContentRegion);
        // We want the tab content to always sit below the tab headers
        getChildren().add(0, tabContentRegion);
    }

    private void removeTabContent(Tab tab) {
        for (TabContentRegion contentRegion : tabContentRegions) {
            if (contentRegion.getTab().equals(tab)) {
                contentRegion.removeListeners(tab);
                getChildren().remove(contentRegion);
                tabContentRegions.remove(contentRegion);
                break;
            }
        }
    }

    private void updateTabPosition() {
        tabHeaderArea.setScrollOffset(0.0F);
        getSkinnable().applyCss();
        getSkinnable().requestLayout();
    }

    private Timeline createTimeline(final TabHeaderSkin tabRegion, final Duration duration, final double endValue, final EventHandler&lt;ActionEvent&gt; func) {
        Timeline timeline = new Timeline();
        timeline.setCycleCount(1);

        KeyValue keyValue = new KeyValue(tabRegion.animationTransition, endValue, Interpolator.LINEAR);
        timeline.getKeyFrames().clear();
        timeline.getKeyFrames().add(new KeyFrame(duration, keyValue));

        timeline.setOnFinished(func);
        return timeline;
    }

    private boolean isHorizontal() {
        Side tabPosition = getSkinnable().getSide();
        return Side.TOP.equals(tabPosition) || Side.BOTTOM.equals(tabPosition);
    }

    private void initializeSwipeHandlers() {
        if (Properties.IS_TOUCH_SUPPORTED) {
            getSkinnable().addEventHandler(SwipeEvent.SWIPE_LEFT, t -&gt; {
                behavior.selectNextTab();
            });

            getSkinnable().addEventHandler(SwipeEvent.SWIPE_RIGHT, t -&gt; {
                behavior.selectPreviousTab();
            });
        }
    }

    //TODO need to cache this.
    private boolean isFloatingStyleClass() {
        return getSkinnable().getStyleClass().contains(TabPane.STYLE_CLASS_FLOATING);
    }



    /***************************************************************************
     *                                                                         *
     * CSS                                                                     *
     *                                                                         *
     **************************************************************************/

   /*
    * Super-lazy instantiation pattern from Bill Pugh.
    */
   private static class StyleableProperties {
        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; OPEN_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-open-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.openTabAnimation;
            }
        };

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; CLOSE_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-close-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.closeTabAnimation;
            }
        };

        static {

           final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
               new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
           styleables.add(OPEN_TAB_ANIMATION);
           styleables.add(CLOSE_TAB_ANIMATION);
           STYLEABLES = Collections.unmodifiableList(styleables);

        }
    }

    /**
     * Returns the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    /**************************************************************************
     *
     * TabHeaderArea: Area responsible for painting all tabs
     *
     **************************************************************************/
    class TabHeaderArea extends StackPane {
        private Rectangle headerClip;
        private StackPane headersRegion;
        private StackPane headerBackground;
        private TabControlButtons controlButtons;

        private boolean measureClosingTabs = false;

        private double scrollOffset;

        public TabHeaderArea() {
            getStyleClass().setAll(&quot;tab-header-area&quot;);
            setManaged(false);
            final TabPane tabPane = getSkinnable();

            headerClip = new Rectangle();

            headersRegion = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double width = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        if (tabHeaderSkin.isVisible() &amp;&amp; (measureClosingTabs || ! tabHeaderSkin.isClosing)) {
                            width += tabHeaderSkin.prefWidth(height);
                        }
                    }
                    return snapSize(width) + snappedLeftInset() + snappedRightInset();
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        height = Math.max(height, tabHeaderSkin.prefHeight(width));
                    }
                    return snapSize(height) + snappedTopInset() + snappedBottomInset();
                }

                @Override protected void layoutChildren() {
                    if (tabsFit()) {
                        setScrollOffset(0.0);
                    } else {
                        if (isSelectingTab) {
                            ensureSelectedTabIsVisible();
                        } else {
                            validateScrollOffset();
                        }
                    }
                    isSelectingTab = false;

                    Side tabPosition = getSkinnable().getSide();
                    double tabBackgroundHeight = snapSize(prefHeight(-1));
                    double tabX = (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) ?
                        snapSize(getWidth()) - getScrollOffset() : getScrollOffset();

                    updateHeaderClip();
                    for (Node node : getChildren()) {
                        TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                        // size and position the header relative to the other headers
                        double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1) * tabHeader.animationTransition.get());
                        double tabHeaderPrefHeight = snapSize(tabHeader.prefHeight(-1));
                        tabHeader.resize(tabHeaderPrefWidth, tabHeaderPrefHeight);

                        // This ensures that the tabs are located in the correct position
                        // when there are tabs of differing heights.
                        double startY = tabPosition.equals(Side.BOTTOM) ?
                            0 : tabBackgroundHeight - tabHeaderPrefHeight - snappedBottomInset();
                        if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                            // build from the right
                            tabX -= tabHeaderPrefWidth;
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                        } else {
                            // build from the left
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                            tabX += tabHeaderPrefWidth;
                        }
                    }
                }

            };
            headersRegion.getStyleClass().setAll(&quot;headers-region&quot;);
            headersRegion.setClip(headerClip);
            setupReordering(headersRegion);

            headerBackground = new StackPane();
            headerBackground.getStyleClass().setAll(&quot;tab-header-background&quot;);

            int i = 0;
            for (Tab tab: tabPane.getTabs()) {
                addTab(tab, i++);
            }

            controlButtons = new TabControlButtons();
            controlButtons.setVisible(false);
            if (controlButtons.isVisible()) {
                controlButtons.setVisible(true);
            }
            getChildren().addAll(headerBackground, headersRegion, controlButtons);

            // support for mouse scroll of header area (for when the tabs exceed
            // the available space).
            // Scrolling the mouse wheel downwards results in the tabs scrolling left (i.e. exposing the right-most tabs)
            // Scrolling the mouse wheel upwards results in the tabs scrolling right (i.e. exposing th left-most tabs)
            addEventHandler(ScrollEvent.SCROLL, (ScrollEvent e) -&gt; {
                Side side = getSkinnable().getSide();
                side = side == null ? Side.TOP : side;
                switch (side) {
                    default:
                    case TOP:
                    case BOTTOM:
                        setScrollOffset(scrollOffset + e.getDeltaY());
                        break;
                    case LEFT:
                    case RIGHT:
                        setScrollOffset(scrollOffset - e.getDeltaY());
                        break;
                }

            });
        }

        private void updateHeaderClip() {
            Side tabPosition = getSkinnable().getSide();

            double x = 0;
            double y = 0;
            double clipWidth = 0;
            double clipHeight = 0;
            double maxWidth = 0;
            double shadowRadius = 0;
            double clipOffset = firstTabIndent();
            double controlButtonPrefWidth = snapSize(controlButtons.prefWidth(-1));

            measureClosingTabs = true;
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            measureClosingTabs = false;

            double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));

            // Add the spacer if isShowTabsMenu is true.
            if (controlButtonPrefWidth &gt; 0) {
                controlButtonPrefWidth = controlButtonPrefWidth + SPACER;
            }

            if (headersRegion.getEffect() instanceof DropShadow) {
                DropShadow shadow = (DropShadow)headersRegion.getEffect();
                shadowRadius = shadow.getRadius();
            }

            maxWidth = snapSize(getWidth()) - controlButtonPrefWidth - clipOffset;
            if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                if (headersPrefWidth &lt; maxWidth) {
                    clipWidth = headersPrefWidth + shadowRadius;
                } else {
                    x = headersPrefWidth - maxWidth;
                    clipWidth = maxWidth + shadowRadius;
                }
                clipHeight = headersPrefHeight;
            } else {
                // If x = 0 the header region's drop shadow is clipped.
                x = -shadowRadius;
                clipWidth = (headersPrefWidth &lt; maxWidth ? headersPrefWidth : maxWidth) + shadowRadius;
                clipHeight = headersPrefHeight;
            }

            headerClip.setX(x);
            headerClip.setY(y);
            headerClip.setWidth(clipWidth);
            headerClip.setHeight(clipHeight);
        }

        private void addTab(Tab tab, int addToIndex) {
            TabHeaderSkin tabHeaderSkin = new TabHeaderSkin(tab);
            headersRegion.getChildren().add(addToIndex, tabHeaderSkin);
        }

        private void removeTab(Tab tab) {
            TabHeaderSkin tabHeaderSkin = getTabHeaderSkin(tab);
            if (tabHeaderSkin != null) {
                headersRegion.getChildren().remove(tabHeaderSkin);
            }
        }

        private TabHeaderSkin getTabHeaderSkin(Tab tab) {
            for (Node child: headersRegion.getChildren()) {
                TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                if (tabHeaderSkin.getTab().equals(tab)) {
                    return tabHeaderSkin;
                }
            }
            return null;
        }

        private boolean tabsFit() {
            double headerPrefWidth = snapSize(headersRegion.prefWidth(-1));
            double controlTabWidth = snapSize(controlButtons.prefWidth(-1));
            double visibleWidth = headerPrefWidth + controlTabWidth + firstTabIndent() + SPACER;
            return visibleWidth &lt; getWidth();
        }

        private void ensureSelectedTabIsVisible() {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // and get where the selected tab is in the header area
            double offset = 0.0;
            double selectedTabOffset = 0.0;
            double selectedTabWidth = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));

                if (selectedTab != null &amp;&amp; selectedTab.equals(tabHeader.getTab())) {
                    selectedTabOffset = offset;
                    selectedTabWidth = tabHeaderPrefWidth;
                }
                offset += tabHeaderPrefWidth;
            }

            final double scrollOffset = getScrollOffset();
            final double selectedTabStartX = selectedTabOffset;
            final double selectedTabEndX = selectedTabOffset + selectedTabWidth;
<A NAME="32"></A>
            final double visibleAreaEndX = visibleWidth;

            <FONT color="#82cafa"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#32',2,'match37-top.html#32',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (selectedTabStartX &lt; -scrollOffset) {
                setScrollOffset(-selectedTabStartX);
            } else if (selectedTabEndX &gt; (visibleAreaEndX - scrollOffset)) {
                setScrollOffset(visibleAreaEndX - selectedTabEndX);
            }
        }

        public double g</B></FONT>etScrollOffset() {
            return scrollOffset;
        }

        private void validateScrollOffset() {
            setScrollOffset(getScrollOffset());
        }

        private void setScrollOffset(double newScrollOffset) {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // measure the width of all tabs
            double offset = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;
                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));
                offset += tabHeaderPrefWidth;
            }

            double actualNewScrollOffset;

            if ((visibleWidth - newScrollOffset) &gt; offset &amp;&amp; newScrollOffset &lt; 0) {
                // need to make sure the right-most tab is attached to the
                // right-hand side of the tab header (e.g. if the tab header area width
                // is expanded), and if it isn't modify the scroll offset to bring
                // it into line. See RT-35194 for a test case.
                actualNewScrollOffset = visibleWidth - offset;
            } else if (newScrollOffset &gt; 0) {
                // need to prevent the left-most tab from becoming detached
                // from the left-hand side of the tab header.
                actualNewScrollOffset = 0;
            } else {
                actualNewScrollOffset = newScrollOffset;
            }

            if (Math.abs(actualNewScrollOffset - scrollOffset) &gt; 0.001) {
                scrollOffset = actualNewScrollOffset;
                headersRegion.requestLayout();
            }
        }

        private double firstTabIndent() {
            switch (getSkinnable().getSide()) {
                case TOP:
                case BOTTOM:
                    return snappedLeftInset();
                case RIGHT:
                case LEFT:
                    return snappedTopInset();
                default:
                    return 0;
            }
        }

        @Override protected double computePrefWidth(double height) {
            double padding = isHorizontal() ?
                snappedLeftInset() + snappedRightInset() :
                snappedTopInset() + snappedBottomInset();
            return snapSize(headersRegion.prefWidth(height)) + controlButtons.prefWidth(height) +
                    firstTabIndent() + SPACER + padding;
        }

        @Override protected double computePrefHeight(double width) {
            double padding = isHorizontal() ?
                snappedTopInset() + snappedBottomInset() :
                snappedLeftInset() + snappedRightInset();
            return snapSize(headersRegion.prefHeight(-1)) + padding;
        }

        @Override public double getBaselineOffset() {
            if (getSkinnable().getSide() == Side.TOP) {
                return headersRegion.getBaselineOffset() + snappedTopInset();
            }
            return 0;
        }

        @Override protected void layoutChildren() {
            final double leftInset = snappedLeftInset();
            final double rightInset = snappedRightInset();
            final double topInset = snappedTopInset();
            final double bottomInset = snappedBottomInset();
            double w = snapSize(getWidth()) - (isHorizontal() ?
                    leftInset + rightInset : topInset + bottomInset);
            double h = snapSize(getHeight()) - (isHorizontal() ?
                    topInset + bottomInset : leftInset + rightInset);
            double tabBackgroundHeight = snapSize(prefHeight(-1));
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));

            controlButtons.showTabsMenu(! tabsFit());

            updateHeaderClip();
            headersRegion.requestLayout();

            // RESIZE CONTROL BUTTONS
            double btnWidth = snapSize(controlButtons.prefWidth(-1));
            final double btnHeight = controlButtons.prefHeight(btnWidth);
            controlButtons.resize(btnWidth, btnHeight);

            // POSITION TABS
            headersRegion.resize(headersPrefWidth, headersPrefHeight);

            if (isFloatingStyleClass()) {
                headerBackground.setVisible(false);
            } else {
                headerBackground.resize(snapSize(getWidth()), snapSize(getHeight()));
                headerBackground.setVisible(true);
            }

            double startX = 0;
            double startY = 0;
            double controlStartX = 0;
            double controlStartY = 0;
            Side tabPosition = getSkinnable().getSide();

            if (tabPosition.equals(Side.TOP)) {
                startX = leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - bottomInset;
                controlStartX = w - btnWidth + leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - bottomInset;
            } else if (tabPosition.equals(Side.RIGHT)) {
                startX = topInset;
                startY = tabBackgroundHeight - headersPrefHeight - leftInset;
                controlStartX = w - btnWidth + topInset;
                controlStartY = snapSize(getHeight()) - btnHeight - leftInset;
            } else if (tabPosition.equals(Side.BOTTOM)) {
                startX = snapSize(getWidth()) - headersPrefWidth - leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - topInset;
                controlStartX = rightInset;
                controlStartY = snapSize(getHeight()) - btnHeight - topInset;
            } else if (tabPosition.equals(Side.LEFT)) {
                startX = snapSize(getWidth()) - headersPrefWidth - topInset;
                startY = tabBackgroundHeight - headersPrefHeight - rightInset;
                controlStartX = leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - rightInset;
            }
            if (headerBackground.isVisible()) {
                positionInArea(headerBackground, 0, 0,
                        snapSize(getWidth()), snapSize(getHeight()), /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
            }
            positionInArea(headersRegion, startX, startY, w, h, /*baseline ignored*/0, HPos.LEFT, VPos.CENTER);
            positionInArea(controlButtons, controlStartX, controlStartY, btnWidth, btnHeight,
                        /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
        }
    } /* End TabHeaderArea */




    /**************************************************************************
     *
     * TabHeaderSkin: skin for each tab
     *
     **************************************************************************/

    class TabHeaderSkin extends StackPane {
        private final Tab tab;
        public Tab getTab() {
            return tab;
        }
        private Label label;
        private StackPane closeBtn;
        private StackPane inner;
        private Tooltip oldTooltip;
        private Tooltip tooltip;
        private Rectangle clip;

        private boolean isClosing = false;

        private LambdaMultiplePropertyChangeListenerHandler listener = new LambdaMultiplePropertyChangeListenerHandler();

        private final ListChangeListener&lt;String&gt; styleClassListener = new ListChangeListener&lt;String&gt;() {
            @Override
            public void onChanged(Change&lt;? extends String&gt; c) {
                getStyleClass().setAll(tab.getStyleClass());
            }
        };

        private final WeakListChangeListener&lt;String&gt; weakStyleClassListener =
                new WeakListChangeListener&lt;&gt;(styleClassListener);

        public TabHeaderSkin(final Tab tab) {
            getStyleClass().setAll(tab.getStyleClass());
            setId(tab.getId());
            setStyle(tab.getStyle());
            setAccessibleRole(AccessibleRole.TAB_ITEM);
            setViewOrder(1);

            this.tab = tab;
            clip = new Rectangle();
            setClip(clip);

            label = new Label(tab.getText(), tab.getGraphic());
            label.getStyleClass().setAll(&quot;tab-label&quot;);

            closeBtn = new StackPane() {
                @Override protected double computePrefWidth(double h) {
                    return CLOSE_BTN_SIZE;
                }
                @Override protected double computePrefHeight(double w) {
                    return CLOSE_BTN_SIZE;
                }
                @Override
                public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
                    switch (action) {
                        case FIRE: {
                            Tab tab = getTab();
                            if (behavior.canCloseTab(tab)) {
                                behavior.closeTab(tab);
                                setOnMousePressed(null);
                            }
                            break;
                        }
                        default: super.executeAccessibleAction(action, parameters);
                    }
                }
            };
            closeBtn.setAccessibleRole(AccessibleRole.BUTTON);
            closeBtn.setAccessibleText(getString(&quot;Accessibility.title.TabPane.CloseButton&quot;));
            closeBtn.getStyleClass().setAll(&quot;tab-close-button&quot;);
            closeBtn.setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override
                public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (me.getButton().equals(MouseButton.PRIMARY) &amp;&amp; behavior.canCloseTab(tab)) {
                        behavior.closeTab(tab);
                        setOnMousePressed(null);
                        me.consume();
                    }
                }
            });

            updateGraphicRotation();

            final Region focusIndicator = new Region();
            focusIndicator.setMouseTransparent(true);
            focusIndicator.getStyleClass().add(&quot;focus-indicator&quot;);

            inner = new StackPane() {
                @Override protected void layoutChildren() {
                    final TabPane skinnable = getSkinnable();

                    final double paddingTop = snappedTopInset();
                    final double paddingRight = snappedRightInset();
                    final double paddingBottom = snappedBottomInset();
                    final double paddingLeft = snappedLeftInset();
                    final double w = getWidth() - (paddingLeft + paddingRight);
                    final double h = getHeight() - (paddingTop + paddingBottom);

                    final double prefLabelWidth = snapSize(label.prefWidth(-1));
                    final double prefLabelHeight = snapSize(label.prefHeight(-1));

                    final double closeBtnWidth = showCloseButton() ? snapSize(closeBtn.prefWidth(-1)) : 0;
                    final double closeBtnHeight = showCloseButton() ? snapSize(closeBtn.prefHeight(-1)) : 0;
                    final double minWidth = snapSize(skinnable.getTabMinWidth());
                    final double maxWidth = snapSize(skinnable.getTabMaxWidth());
                    final double maxHeight = snapSize(skinnable.getTabMaxHeight());

                    double labelAreaWidth = prefLabelWidth;
                    double labelWidth = prefLabelWidth;
                    double labelHeight = prefLabelHeight;

                    final double childrenWidth = labelAreaWidth + closeBtnWidth;
                    final double childrenHeight = Math.max(labelHeight, closeBtnHeight);

                    if (childrenWidth &gt; maxWidth &amp;&amp; maxWidth != Double.MAX_VALUE) {
                        labelAreaWidth = maxWidth - closeBtnWidth;
                        labelWidth = maxWidth - closeBtnWidth;
                    } else if (childrenWidth &lt; minWidth) {
                        labelAreaWidth = minWidth - closeBtnWidth;
                    }

                    if (childrenHeight &gt; maxHeight &amp;&amp; maxHeight != Double.MAX_VALUE) {
                        labelHeight = maxHeight;
                    }

                    if (animationState != TabAnimationState.NONE) {
//                        if (prefWidth.getValue() &lt; labelAreaWidth) {
//                            labelAreaWidth = prefWidth.getValue();
//                        }
                        labelAreaWidth *= animationTransition.get();
                        closeBtn.setVisible(false);
                    } else {
                        closeBtn.setVisible(showCloseButton());
                    }


                    label.resize(labelWidth, labelHeight);


                    double labelStartX = paddingLeft;

                    // If maxWidth is less than Double.MAX_VALUE, the user has
                    // clamped the max width, but we should
                    // position the close button at the end of the tab,
                    // which may not necessarily be the entire width of the
                    // provided max width.
                    double closeBtnStartX = (maxWidth &lt; Double.MAX_VALUE ? Math.min(w, maxWidth) : w) - paddingRight - closeBtnWidth;

                    positionInArea(label, labelStartX, paddingTop, labelAreaWidth, h,
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);

                    if (closeBtn.isVisible()) {
                        closeBtn.resize(closeBtnWidth, closeBtnHeight);
                        positionInArea(closeBtn, closeBtnStartX, paddingTop, closeBtnWidth, h,
                                /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                    }

                    // Magic numbers regretfully introduced for RT-28944 (so that
                    // the focus rect appears as expected on Windows and Mac).
                    // In short we use the vPadding to shift the focus rect down
                    // into the content area (whereas previously it was being clipped
                    // on Windows, whilst it still looked fine on Mac). In the
                    // future we may want to improve this code to remove the
                    // magic number. Similarly, the hPadding differs on Mac.
                    final int vPadding = Utils.isMac() ? 2 : 3;
                    final int hPadding = Utils.isMac() ? 2 : 1;
                    focusIndicator.resizeRelocate(
                            paddingLeft - hPadding,
                            paddingTop + vPadding,
                            w + 2 * hPadding,
                            h - 2 * vPadding);
                }
            };
            inner.getStyleClass().add(&quot;tab-container&quot;);
            inner.setRotate(getSkinnable().getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            inner.getChildren().addAll(label, closeBtn, focusIndicator);

            getChildren().addAll(inner);

            tooltip = tab.getTooltip();
            if (tooltip != null) {
                Tooltip.install(this, tooltip);
                oldTooltip = tooltip;
            }

            listener.registerChangeListener(tab.closableProperty(), e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.selectedProperty(), e -&gt; {
                pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
                // Need to request a layout pass for inner because if the width
                // and height didn't not change the label or close button may have
                // changed.
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.textProperty(),e -&gt; label.setText(getTab().getText()));
            listener.registerChangeListener(tab.graphicProperty(), e -&gt; label.setGraphic(getTab().getGraphic()));
            listener.registerChangeListener(tab.tooltipProperty(), e -&gt; {
                // uninstall the old tooltip
                if (oldTooltip != null) {
                    Tooltip.uninstall(this, oldTooltip);
                }
                tooltip = tab.getTooltip();
                if (tooltip != null) {
                    // install new tooltip and save as old tooltip.
                    Tooltip.install(this, tooltip);
                    oldTooltip = tooltip;
                }
            });
            listener.registerChangeListener(tab.disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.getTabPane().disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.styleProperty(), e -&gt; setStyle(tab.getStyle()));

            tab.getStyleClass().addListener(weakStyleClassListener);

            listener.registerChangeListener(getSkinnable().tabClosingPolicyProperty(),e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(getSkinnable().sideProperty(),e -&gt; {
                final Side side = getSkinnable().getSide();
                pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
                pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
                pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
                pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
                inner.setRotate(side == Side.BOTTOM ? 180.0F : 0.0F);
                if (getSkinnable().isRotateGraphic()) {
                    updateGraphicRotation();
                }
            });
            listener.registerChangeListener(getSkinnable().rotateGraphicProperty(), e -&gt; updateGraphicRotation());
            listener.registerChangeListener(getSkinnable().tabMinWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMaxWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMinHeightProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMaxHeightProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });

            getProperties().put(Tab.class, tab);
            getProperties().put(ContextMenu.class, tab.getContextMenu());

            setOnContextMenuRequested((ContextMenuEvent me) -&gt; {
               if (getTab().getContextMenu() != null) {
                    getTab().getContextMenu().show(inner, me.getScreenX(), me.getScreenY());
                    me.consume();
                }
            });
            setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (tab.isDisable()) {
                        return;
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)
                        || me.getButton().equals(MouseButton.PRIMARY)) {

                        if (tab.getContextMenu() != null
                            &amp;&amp; tab.getContextMenu().isShowing()) {
                            tab.getContextMenu().hide();
                        }
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)) {
                        if (showCloseButton()) {
                            if (behavior.canCloseTab(tab)) {
                                removeListeners(tab);
                                behavior.closeTab(tab);
                            }
                        }
                    } else if (me.getButton().equals(MouseButton.PRIMARY)) {
                        behavior.selectTab(tab);
                    }
                }
            });

            // initialize pseudo-class state
            pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            final Side side = getSkinnable().getSide();
            pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
            pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
            pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
            pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
        }

        private void updateTabDisabledState() {
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            inner.requestLayout();
            requestLayout();
        }

        private void updateGraphicRotation() {
            if (label.getGraphic() != null) {
                label.getGraphic().setRotate(getSkinnable().isRotateGraphic() ? 0.0F :
                    (getSkinnable().getSide().equals(Side.RIGHT) ? -90.0F :
                        (getSkinnable().getSide().equals(Side.LEFT) ? 90.0F : 0.0F)));
            }
        }

        private boolean showCloseButton() {
            return tab.isClosable() &amp;&amp;
                    (getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.ALL_TABS) ||
                    getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.SELECTED_TAB) &amp;&amp; tab.isSelected());
        }

        private final DoubleProperty animationTransition = new SimpleDoubleProperty(this, &quot;animationTransition&quot;, 1.0) {
            @Override protected void invalidated() {
                requestLayout();
            }
        };

        private void removeListeners(Tab tab) {
            listener.dispose();
            inner.getChildren().clear();
            getChildren().clear();
            setOnContextMenuRequested(null);
            setOnMousePressed(null);
        }

        private TabAnimationState animationState = TabAnimationState.NONE;
        private Timeline currentAnimation;

        @Override protected double computePrefWidth(double height) {
//            if (animating) {
//                return prefWidth.getValue();
//            }
            double minWidth = snapSize(getSkinnable().getTabMinWidth());
            double maxWidth = snapSize(getSkinnable().getTabMaxWidth());
            double paddingRight = snappedRightInset();
            double paddingLeft = snappedLeftInset();
            double tmpPrefWidth = snapSize(label.prefWidth(-1));

            // only include the close button width if it is relevant
            if (showCloseButton()) {
                tmpPrefWidth += snapSize(closeBtn.prefWidth(-1));
            }

            if (tmpPrefWidth &gt; maxWidth) {
                tmpPrefWidth = maxWidth;
            } else if (tmpPrefWidth &lt; minWidth) {
                tmpPrefWidth = minWidth;
            }
            tmpPrefWidth += paddingRight + paddingLeft;
//            prefWidth.setValue(tmpPrefWidth);
            return tmpPrefWidth;
        }

        @Override protected double computePrefHeight(double width) {
            double minHeight = snapSize(getSkinnable().getTabMinHeight());
            double maxHeight = snapSize(getSkinnable().getTabMaxHeight());
            double paddingTop = snappedTopInset();
            double paddingBottom = snappedBottomInset();
            double tmpPrefHeight = snapSize(label.prefHeight(width));

            if (tmpPrefHeight &gt; maxHeight) {
                tmpPrefHeight = maxHeight;
            } else if (tmpPrefHeight &lt; minHeight) {
                tmpPrefHeight = minHeight;
            }
            tmpPrefHeight += paddingTop + paddingBottom;
            return tmpPrefHeight;
        }

        @Override protected void layoutChildren() {
            double w = (snapSize(getWidth()) - snappedRightInset() - snappedLeftInset()) * animationTransition.getValue();
            inner.resize(w, snapSize(getHeight()) - snappedTopInset() - snappedBottomInset());
            inner.relocate(snappedLeftInset(), snappedTopInset());
        }

        @Override protected void setWidth(double value) {
            super.setWidth(value);
            clip.setWidth(value);
        }

        @Override protected void setHeight(double value) {
            super.setHeight(value);
            clip.setHeight(value);
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case TEXT: return getTab().getText();
                case SELECTED: return selectedTab == getTab();
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }

        /** {@inheritDoc} */
        @Override
        public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
            switch (action) {
                case REQUEST_FOCUS:
                    getSkinnable().getSelectionModel().select(getTab());
                    break;
                default: super.executeAccessibleAction(action, parameters);
            }
        }

    } /* End TabHeaderSkin */

    private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;selected&quot;);
    private static final PseudoClass TOP_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;top&quot;);
    private static final PseudoClass BOTTOM_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;bottom&quot;);
    private static final PseudoClass LEFT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;left&quot;);
    private static final PseudoClass RIGHT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;right&quot;);
    private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;disabled&quot;);


    /**************************************************************************
     *
     * TabContentRegion: each tab has one to contain the tab's content node
     *
     **************************************************************************/
    static class TabContentRegion extends StackPane {

        private Tab tab;

        private InvalidationListener tabContentListener = valueModel -&gt; {
            updateContent();
        };
        private InvalidationListener tabSelectedListener = new InvalidationListener() {
            @Override public void invalidated(Observable valueModel) {
                setVisible(tab.isSelected());
            }
        };

        private WeakInvalidationListener weakTabContentListener =
                new WeakInvalidationListener(tabContentListener);
        private WeakInvalidationListener weakTabSelectedListener =
                new WeakInvalidationListener(tabSelectedListener);

        public Tab getTab() {
            return tab;
        }

        public TabContentRegion(Tab tab) {
            getStyleClass().setAll(&quot;tab-content-area&quot;);
            setManaged(false);
            this.tab = tab;
            updateContent();
            setVisible(tab.isSelected());

            tab.selectedProperty().addListener(weakTabSelectedListener);
            tab.contentProperty().addListener(weakTabContentListener);
        }

        private void updateContent() {
            Node newContent = getTab().getContent();
            if (newContent == null) {
                getChildren().clear();
            } else {
                getChildren().setAll(newContent);
            }
        }

        private void removeListeners(Tab tab) {
            tab.selectedProperty().removeListener(weakTabSelectedListener);
            tab.contentProperty().removeListener(weakTabContentListener);
        }

    } /* End TabContentRegion */

    /**************************************************************************
     *
     * TabControlButtons: controls to manipulate tab interaction
     *
     **************************************************************************/
    class TabControlButtons extends StackPane {
        private StackPane inner;
        private StackPane downArrow;
        private Pane downArrowBtn;
        private boolean showControlButtons;
        private ContextMenu popup;

        public TabControlButtons() {
            getStyleClass().setAll(&quot;control-buttons-tab&quot;);

            TabPane tabPane = getSkinnable();

            downArrowBtn = new Pane();
            downArrowBtn.getStyleClass().setAll(&quot;tab-down-button&quot;);
            downArrowBtn.setVisible(isShowTabsMenu());
            downArrow = new StackPane();
            downArrow.setManaged(false);
            downArrow.getStyleClass().setAll(&quot;arrow&quot;);
            downArrow.setRotate(tabPane.getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            downArrowBtn.getChildren().add(downArrow);
            downArrowBtn.setOnMouseClicked(me -&gt; {
                showPopupMenu();
            });

            setupPopupMenu();

            inner = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double pw;
                    double maxArrowWidth = ! isShowTabsMenu() ? 0 : snapSize(downArrow.prefWidth(getHeight())) + snapSize(downArrowBtn.prefWidth(getHeight()));
                    pw = 0.0F;
                    if (isShowTabsMenu()) {
                        pw += maxArrowWidth;
                    }
                    if (pw &gt; 0) {
                        pw += snappedLeftInset() + snappedRightInset();
                    }
                    return pw;
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    if (isShowTabsMenu()) {
                        height = Math.max(height, snapSize(downArrowBtn.prefHeight(width)));
                    }
                    if (height &gt; 0) {
                        height += snappedTopInset() + snappedBottomInset();
                    }
                    return height;
                }

                @Override protected void layoutChildren() {
                    if (isShowTabsMenu()) {
                        double x = 0;
                        double y = snappedTopInset();
                        double w = snapSize(getWidth()) - x + snappedLeftInset();
                        double h = snapSize(getHeight()) - y + snappedBottomInset();
                        positionArrow(downArrowBtn, downArrow, x, y, w, h);
                    }
                }

                private void positionArrow(Pane btn, StackPane arrow, double x, double y, double width, double height) {
                    btn.resize(width, height);
                    positionInArea(btn, x, y, width, height, /*baseline ignored*/0,
                            HPos.CENTER, VPos.CENTER);
                    // center arrow region within arrow button
                    double arrowWidth = snapSize(arrow.prefWidth(-1));
                    double arrowHeight = snapSize(arrow.prefHeight(-1));
                    arrow.resize(arrowWidth, arrowHeight);
                    positionInArea(arrow, btn.snappedLeftInset(), btn.snappedTopInset(),
                            width - btn.snappedLeftInset() - btn.snappedRightInset(),
                            height - btn.snappedTopInset() - btn.snappedBottomInset(),
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                }
            };
            inner.getStyleClass().add(&quot;container&quot;);
            inner.getChildren().add(downArrowBtn);

            getChildren().add(inner);

            tabPane.sideProperty().addListener(valueModel -&gt; {
                Side tabPosition = getSkinnable().getSide();
                downArrow.setRotate(tabPosition.equals(Side.BOTTOM)? 180.0F : 0.0F);
            });
            tabPane.getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; setupPopupMenu());
            showControlButtons = false;
            if (isShowTabsMenu()) {
                showControlButtons = true;
                requestLayout();
            }
            getProperties().put(ContextMenu.class, popup);
        }

        private boolean showTabsMenu = false;

        private void showTabsMenu(boolean value) {
            final boolean wasTabsMenuShowing = isShowTabsMenu();
            this.showTabsMenu = value;

            if (showTabsMenu &amp;&amp; !wasTabsMenuShowing) {
                downArrowBtn.setVisible(true);
                showControlButtons = true;
                inner.requestLayout();
                tabHeaderArea.requestLayout();
            } else if (!showTabsMenu &amp;&amp; wasTabsMenuShowing) {
                hideControlButtons();
            }
        }

        private boolean isShowTabsMenu() {
            return showTabsMenu;
        }

        @Override protected double computePrefWidth(double height) {
            double pw = snapSize(inner.prefWidth(height));
            if (pw &gt; 0) {
                pw += snappedLeftInset() + snappedRightInset();
            }
            return pw;
        }

        @Override protected double computePrefHeight(double width) {
            return Math.max(getSkinnable().getTabMinHeight(), snapSize(inner.prefHeight(width))) +
                    snappedTopInset() + snappedBottomInset();
        }

        @Override protected void layoutChildren() {
            double x = snappedLeftInset();
            double y = snappedTopInset();
            double w = snapSize(getWidth()) - x + snappedRightInset();
            double h = snapSize(getHeight()) - y + snappedBottomInset();

            if (showControlButtons) {
                showControlButtons();
                showControlButtons = false;
            }

            inner.resize(w, h);
            positionInArea(inner, x, y, w, h, /*baseline ignored*/0, HPos.CENTER, VPos.BOTTOM);
        }

        private void showControlButtons() {
            setVisible(true);
            if (popup == null) {
                setupPopupMenu();
            }
        }

        private void hideControlButtons() {
            // If the scroll arrows or tab menu is still visible we don't want
            // to hide it animate it back it.
            if (isShowTabsMenu()) {
                showControlButtons = true;
            } else {
                setVisible(false);
                clearPopupMenu();
                popup = null;
            }

            // This needs to be called when we are in the left tabPosition
            // to allow for the clip offset to move properly (otherwise
            // it jumps too early - before the animation is done).
            requestLayout();
        }

        private void setupPopupMenu() {
            if (popup == null) {
                popup = new ContextMenu();
            }
            clearPopupMenu();
            ToggleGroup group = new ToggleGroup();
            ObservableList&lt;RadioMenuItem&gt; menuitems = FXCollections.&lt;RadioMenuItem&gt;observableArrayList();
            for (final Tab tab : getSkinnable().getTabs()) {
                TabMenuItem item = new TabMenuItem(tab);
                item.setToggleGroup(group);
                item.setOnAction(t -&gt; getSkinnable().getSelectionModel().select(tab));
                menuitems.add(item);
            }
            popup.getItems().addAll(menuitems);
        }

        private void clearPopupMenu() {
            for (MenuItem item : popup.getItems()) {
                ((TabMenuItem) item).dispose();
            }
            popup.getItems().clear();
        }

        private void showPopupMenu() {
            for (MenuItem mi: popup.getItems()) {
                TabMenuItem tmi = (TabMenuItem)mi;
                if (selectedTab.equals(tmi.getTab())) {
                    tmi.setSelected(true);
                    break;
                }
            }
            popup.show(downArrowBtn, Side.BOTTOM, 0, 0);
        }
    } /* End TabControlButtons*/

    static class TabMenuItem extends RadioMenuItem {
        Tab tab;

        private InvalidationListener disableListener = new InvalidationListener() {
            @Override public void invalidated(Observable o) {
                setDisable(tab.isDisable());
            }
        };

        private WeakInvalidationListener weakDisableListener =
                new WeakInvalidationListener(disableListener);

        public TabMenuItem(final Tab tab) {
            super(tab.getText(), TabPaneSkin.clone(tab.getGraphic()));
            this.tab = tab;
            setDisable(tab.isDisable());
            tab.disableProperty().addListener(weakDisableListener);
            textProperty().bind(tab.textProperty());
        }

        public Tab getTab() {
            return tab;
        }

        public void dispose() {
            textProperty().unbind();
            tab.disableProperty().removeListener(weakDisableListener);
            tab = null;
        }
    }

    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case FOCUS_ITEM: return tabHeaderArea.getTabHeaderSkin(selectedTab);
            case ITEM_COUNT: return tabHeaderArea.headersRegion.getChildren().size();
            case ITEM_AT_INDEX: {
                Integer index = (Integer)parameters[0];
                if (index == null) return null;
                return tabHeaderArea.headersRegion.getChildren().get(index);
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    // --------------------------
    // Tab Reordering
    // --------------------------
    private enum DragState {
        NONE,
        START,
        REORDER
    }
    private EventHandler&lt;MouseEvent&gt; headerDraggedHandler = this::handleHeaderDragged;
    private EventHandler&lt;MouseEvent&gt; headerMousePressedHandler = this::handleHeaderMousePressed;
    private EventHandler&lt;MouseEvent&gt; headerMouseReleasedHandler = this::handleHeaderMouseReleased;

    private int dragTabHeaderIndex;
    private TabHeaderSkin dragTabHeader;
    private TabHeaderSkin dropTabHeader;
    private StackPane headersRegion;
    private DragState dragState;
    private final int MIN_TO_MAX = 1;
    private final int MAX_TO_MIN = -1;
    private int xLayoutDirection;
    private double dragEventPrevLoc;
    private int prevDragDirection = MIN_TO_MAX;
    private final double DRAG_DIST_THRESHOLD = 0.75;

    // Reordering Animation
    private final double ANIM_DURATION = 120;
    private TabHeaderSkin dropAnimHeader;
    private Tab swapTab;
    private double dropHeaderSourceX;
    private double dropHeaderTransitionX;
    private final Animation dropHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_BOTH);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                completeHeaderReordering();
            });
        }
        protected void interpolate(double frac) {
            dropAnimHeader.setLayoutX(dropHeaderSourceX + dropHeaderTransitionX * frac);
        }
    };
    private double dragHeaderStartX;
    private double dragHeaderDestX;
    private double dragHeaderSourceX;
    private double dragHeaderTransitionX;
    private final Animation dragHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_OUT);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                resetDrag();
            });
        }
        protected void interpolate(double frac) {
            dragTabHeader.setLayoutX(dragHeaderSourceX + dragHeaderTransitionX * frac);
        }
    };

    // Helper methods for managing the listeners based on TabDragPolicy.
    private void addReorderListeners(Node n) {
        n.addEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.addEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.addEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private void removeReorderListeners(Node n) {
        n.removeEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private ListChangeListener childListener = new ListChangeListener&lt;Node&gt;() {
        public void onChanged(Change&lt;? extends Node&gt; change) {
            while (change.next()) {
                if (change.wasAdded()) {
                    for(Node n : change.getAddedSubList()) {
                        addReorderListeners(n);
                    }
                }
                if (change.wasRemoved()) {
                    for(Node n : change.getRemoved()) {
                        removeReorderListeners(n);
                    }
                }
            }
        }
    };

    private void updateListeners() {
        if (getSkinnable().getTabDragPolicy() == TabDragPolicy.FIXED ||
                getSkinnable().getTabDragPolicy() == null) {
            for (Node n : headersRegion.getChildren()) {
                removeReorderListeners(n);
            }
            headersRegion.getChildren().removeListener(childListener);
        } else if (getSkinnable().getTabDragPolicy() == TabDragPolicy.REORDER) {
            for (Node n : headersRegion.getChildren()) {
                addReorderListeners(n);
            }
            headersRegion.getChildren().addListener(childListener);
        }
    }

    private void setupReordering(StackPane headersRegion) {
        dragState = DragState.NONE;
        this.headersRegion = headersRegion;
        updateListeners();
        getSkinnable().tabDragPolicyProperty().addListener((observable, oldValue, newValue) -&gt; {
            if (oldValue != newValue) {
                updateListeners();
            }
        });
    }

    private void handleHeaderMousePressed(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(true);
            startDrag(event);
        }
    }

    private void handleHeaderMouseReleased(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(false);
            stopDrag();
            event.consume();
        }
    }

    private void handleHeaderDragged(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            perfromDrag(event);
        }
    }

    private double getDragDelta(double curr, double prev) {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            return curr - prev;
        } else {
            return prev - curr;
        }
    }

    private int deriveTabHeaderLayoutXDirection() {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            // TabHeaderSkin are laid out in left to right direction inside headersRegion
            return MIN_TO_MAX;
        }
        // TabHeaderSkin are laid out in right to left direction inside headersRegion
        return MAX_TO_MIN;
    }

    private void perfromDrag(MouseEvent event) {
        int dragDirection;
        double dragHeaderNewLayoutX;
        Bounds dragHeaderBounds;
        Bounds dropHeaderBounds;
        double draggedDist;
        double mouseCurrentLoc = getHeaderRegionLocalX(event);
        double dragDelta = getDragDelta(mouseCurrentLoc, dragEventPrevLoc);

        if (dragDelta &gt; 0) {
            // Dragging the tab header towards higher indexed tab headers inside headersRegion.
            dragDirection = MIN_TO_MAX;
        } else {
            // Dragging the tab header towards lower indexed tab headers inside headersRegion.
            dragDirection = MAX_TO_MIN;
        }
        // Stop dropHeaderAnim if direction of drag is changed
        if (prevDragDirection != dragDirection) {
            stopAnim(dropHeaderAnim);
            prevDragDirection = dragDirection;
        }

        dragHeaderNewLayoutX = dragTabHeader.getLayoutX() + xLayoutDirection * dragDelta;

        if (dragHeaderNewLayoutX &gt;= 0 &amp;&amp;
                dragHeaderNewLayoutX + dragTabHeader.getWidth() &lt;= headersRegion.getWidth()) {

            dragState = DragState.REORDER;
            dragTabHeader.setLayoutX(dragHeaderNewLayoutX);
            dragHeaderBounds = dragTabHeader.getBoundsInParent();

            if (dragDirection == MIN_TO_MAX) {
                // Dragging the tab header towards higher indexed tab headers
                // Last tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // headers to be reordered.
                for (int i = dragTabHeaderIndex + 1; i &lt; headersRegion.getChildren().size(); i++) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        } else {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab header crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * -dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            } else {
                // dragDirection is MAX_TO_MIN
                // Dragging the tab header towards lower indexed tab headers.
                // First tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // tab headers to be reordered.
                for (int i = dragTabHeaderIndex - 1; i &gt;= 0; i--) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        } else {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            }
        }
        dragEventPrevLoc = mouseCurrentLoc;
        event.consume();
    }

    private void startDrag(MouseEvent event) {
        // Stop the animations if any are running from previous reorder.
        stopAnim(dropHeaderAnim);
        stopAnim(dragHeaderAnim);

        dragTabHeader = (TabHeaderSkin) event.getSource();
        if (dragTabHeader != null) {
            dragState = DragState.START;
            swapTab = null;
            xLayoutDirection = deriveTabHeaderLayoutXDirection();
            dragEventPrevLoc = getHeaderRegionLocalX(event);
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
            dragTabHeader.setViewOrder(0);
            dragHeaderStartX = dragHeaderDestX = dragTabHeader.getLayoutX();
        }
    }

    private double getHeaderRegionLocalX(MouseEvent ev) {
        // The event is converted to tab header's parent i.e. headersRegion's local space.
        // This will provide a value of X co-ordinate with all transformations of TabPane
        // and transformations of all nodes in the TabPane's parent hierarchy.
        Point2D sceneToLocalHR = headersRegion.sceneToLocal(ev.getSceneX(), ev.getSceneY());
        return sceneToLocalHR.getX();
    }

    private void stopDrag() {
        if (dragState == DragState.START) {
            // No drag action was performed.
            resetDrag();
            return;
        }
        // Animate tab header being dragged to its final position.
        dragHeaderSourceX = dragTabHeader.getLayoutX();
        dragHeaderTransitionX = dragHeaderDestX - dragHeaderSourceX;
        dragHeaderAnim.playFromStart();

        // Reorder the tab list.
        if (dragHeaderStartX != dragHeaderDestX) {
            ((TabObservableList&lt;Tab&gt;) getSkinnable().getTabs()).reorder(dragTabHeader.tab, swapTab);
            swapTab = null;
        }
    }

    private void resetDrag() {
        dragState = DragState.NONE;
        dragTabHeader.setViewOrder(1);
        dragTabHeader = null;
        dropTabHeader = null;
        headersRegion.requestLayout();
    }

    // Animate tab header being dropped-on to its new position.
    private void startHeaderReorderingAnim() {
        dropAnimHeader = dropTabHeader;
        swapTab = dropAnimHeader.tab;
        dropHeaderSourceX = dropAnimHeader.getLayoutX();
        dropHeaderAnim.playFromStart();
    }

    // Remove dropAnimHeader and add at the index position of dragTabHeader.
    private void completeHeaderReordering() {
        if (dropAnimHeader != null) {
            headersRegion.getChildren().remove(dropAnimHeader);
            headersRegion.getChildren().add(dragTabHeaderIndex, dropAnimHeader);
            dropAnimHeader = null;
            headersRegion.requestLayout();
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
        }
    }

    // Helper method to stop an animation.
    private void stopAnim(Animation anim) {
        if (anim.getStatus() == Animation.Status.RUNNING) {
            anim.getOnFinished().handle(null);
            anim.stop();
        }
    }

    // For testing purpose.
    ContextMenu test_getTabsMenu() {
        return tabHeaderArea.controlButtons.popup;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TextFieldSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.behavior.BehaviorBase;
import com.sun.javafx.scene.control.behavior.TextAreaBehavior;
import com.sun.javafx.scene.control.behavior.TextInputControlBehavior;
import javafx.beans.binding.BooleanBinding;
import javafx.beans.binding.DoubleBinding;
import javafx.beans.binding.ObjectBinding;
import javafx.beans.binding.StringBinding;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.ObservableBooleanValue;
import javafx.beans.value.ObservableDoubleValue;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.control.Accordion;
import javafx.scene.control.Button;
import javafx.scene.control.Control;
import javafx.scene.control.IndexRange;
import javafx.scene.control.PasswordField;
import javafx.scene.control.TextField;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.scene.shape.Path;
import javafx.scene.shape.PathElement;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Text;
import javafx.scene.text.HitInfo;
import java.util.List;
import com.sun.javafx.scene.control.behavior.TextFieldBehavior;
import com.sun.javafx.scene.control.behavior.PasswordFieldBehavior;

/**
 * Default skin implementation for the {@link TextField} control.
 *
 * @see TextField
 * @since 9
 */
public class TextFieldSkin extends TextInputControlSkin&lt;TextField&gt; {

    /**************************************************************************
     *
     * Private fields
     *
     **************************************************************************/

    private final TextFieldBehavior behavior;

    /**
     * This group contains the text, caret, and selection rectangle.
     * It is clipped. The textNode, selectionHighlightPath, and
     * caret are each translated individually when horizontal
     * translation is needed to keep the caretPosition visible.
     */
    private Pane textGroup = new Pane();
    private Group handleGroup;

    /**
     * The clip, applied to the textGroup. This makes sure that any
     * text / selection wandering off the text box is clipped
     */
    private Rectangle clip = new Rectangle();
    /**
     * The node actually displaying the text. Note that it has the
     * ability to render both the normal fill as well as the highlight
     * fill, to perform hit testing, fetching of the selection
     * highlight, and other such duties.
     */
    private Text textNode = new Text();
    /**
     *
     * The node used for showing the prompt text.
     */
    private Text promptNode;
    /**
     * A path, provided by the textNode, which represents the area
     * which is selected. The path elements which make up the
     * selection must be updated whenever the selection changes. We
     * don't need to keep track of text changes because those will
     * force the selection to be updated.
     */
    private Path selectionHighlightPath = new Path();

    private Path characterBoundingPath = new Path();
    private ObservableBooleanValue usePromptText;
    private DoubleProperty textTranslateX = new SimpleDoubleProperty(this, &quot;textTranslateX&quot;);
    private double caretWidth;

    /**
     * Right edge of the text region sans padding
     */
    private ObservableDoubleValue textRight;

    private double pressX, pressY; // For dragging handles on embedded

    // For use with PasswordField
    static final char BULLET = '\u25cf';



    /**************************************************************************
     *
     * Constructors
     *
     **************************************************************************/

    /**
     * Creates a new TextFieldSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TextFieldSkin(final TextField control) {
        super(control);

        // install default input map for the text field control
        this.behavior = (control instanceof PasswordField)
                ? new PasswordFieldBehavior((PasswordField)control)
                : new TextFieldBehavior(control);
        this.behavior.setTextFieldSkin(this);
//        control.setInputMap(behavior.getInputMap());

        control.caretPositionProperty().addListener((observable, oldValue, newValue) -&gt; {
            if (control.getWidth() &gt; 0) {
                updateTextNodeCaretPos(control.getCaretPosition());
                if (!isForwardBias()) {
                    setForwardBias(true);
                }
                updateCaretOff();
            }
        });

        forwardBiasProperty().addListener(observable -&gt; {
            if (control.getWidth() &gt; 0) {
                updateTextNodeCaretPos(control.getCaretPosition());
                updateCaretOff();
            }
        });

        textRight = new DoubleBinding() {
            { bind(textGroup.widthProperty()); }
            @Override protected double computeValue() {
                return textGroup.getWidth();
            }
        };

        // Once this was crucial for performance, not sure now.
        clip.setSmooth(false);
        clip.setX(0);
        clip.widthProperty().bind(textGroup.widthProperty());
        clip.heightProperty().bind(textGroup.heightProperty());

        // Add content
        textGroup.setClip(clip);
        // Hack to defeat the fact that otherwise when the caret blinks the parent group
        // bounds are completely invalidated and therefore the dirty region is much
        // larger than necessary.
        textGroup.getChildren().addAll(selectionHighlightPath, textNode, new Group(caretPath));
        getChildren().add(textGroup);
        if (SHOW_HANDLES) {
            handleGroup = new Group();
            handleGroup.setManaged(false);
            handleGroup.getChildren().addAll(caretHandle, selectionHandle1, selectionHandle2);
            getChildren().add(handleGroup);
        }

        // Add text
        textNode.setManaged(false);
        textNode.getStyleClass().add(&quot;text&quot;);
        textNode.fontProperty().bind(control.fontProperty());

        textNode.layoutXProperty().bind(textTranslateX);
        textNode.textProperty().bind(new StringBinding() {
            { bind(control.textProperty()); }
            @Override protected String computeValue() {
                return maskText(control.textProperty().getValueSafe());
            }
        });
        textNode.fillProperty().bind(textFillProperty());
        textNode.selectionFillProperty().bind(new ObjectBinding&lt;Paint&gt;() {
            { bind(highlightTextFillProperty(), textFillProperty(), control.focusedProperty()); }
            @Override protected Paint computeValue() {
                return control.isFocused() ? highlightTextFillProperty().get() : textFillProperty().get();
            }
        });
        // updated by listener on caretPosition to ensure order
        updateTextNodeCaretPos(control.getCaretPosition());
        control.selectionProperty().addListener(observable -&gt; {
            updateSelection();
        });

        // Add selection
        selectionHighlightPath.setManaged(false);
        selectionHighlightPath.setStroke(null);
        selectionHighlightPath.layoutXProperty().bind(textTranslateX);
        selectionHighlightPath.visibleProperty().bind(control.anchorProperty().isNotEqualTo(control.caretPositionProperty()).and(control.focusedProperty()));
        selectionHighlightPath.fillProperty().bind(highlightFillProperty());
        textNode.selectionShapeProperty().addListener(observable -&gt; {
            updateSelection();
        });

        // Add caret
        caretPath.setManaged(false);
        caretPath.setStrokeWidth(1);
        caretPath.fillProperty().bind(textFillProperty());
        caretPath.strokeProperty().bind(textFillProperty());

        // modifying visibility of the caret forces a layout-pass (RT-32373), so
        // instead we modify the opacity.
        caretPath.opacityProperty().bind(new DoubleBinding() {
            { bind(caretVisibleProperty()); }
            @Override protected double computeValue() {
                return caretVisibleProperty().get() ? 1.0 : 0.0;
            }
        });
        caretPath.layoutXProperty().bind(textTranslateX);
        textNode.caretShapeProperty().addListener(observable -&gt; {
            caretPath.getElements().setAll(textNode.caretShapeProperty().get());
            if (caretPath.getElements().size() == 0) {
                // The caret pos is invalid.
                updateTextNodeCaretPos(control.getCaretPosition());
            } else if (caretPath.getElements().size() == 4) {
                // The caret is split. Ignore and keep the previous width value.
            } else {
                caretWidth = Math.round(caretPath.getLayoutBounds().getWidth());
            }
        });

        // Be sure to get the control to request layout when the font changes,
        // since this will affect the pref height and pref width.
        control.fontProperty().addListener(observable -&gt; {
            // I do both so that any cached values for prefWidth/height are cleared.
            // The problem is that the skin is unmanaged and so calling request layout
            // doesn't walk up the tree all the way. I think....
            control.requestLayout();
            getSkinnable().requestLayout();
        });

        registerChangeListener(control.prefColumnCountProperty(), e -&gt; getSkinnable().requestLayout());
        if (control.isFocused()) setCaretAnimating(true);

        control.alignmentProperty().addListener(observable -&gt; {
            if (control.getWidth() &gt; 0) {
                updateTextPos();
                updateCaretOff();
                control.requestLayout();
            }
        });

        usePromptText = new BooleanBinding() {
            { bind(control.textProperty(),
                   control.promptTextProperty(),
                   promptTextFillProperty()); }
            @Override protected boolean computeValue() {
                String txt = control.getText();
                String promptTxt = control.getPromptText();
                return ((txt == null || txt.isEmpty()) &amp;&amp;
                        promptTxt != null &amp;&amp; !promptTxt.isEmpty() &amp;&amp;
                        !getPromptTextFill().equals(Color.TRANSPARENT));
            }
        };

        promptTextFillProperty().addListener(observable -&gt; {
            updateTextPos();
        });

        control.textProperty().addListener(observable -&gt; {
            if (!behavior.isEditing()) {
                // Text changed, but not by user action
                updateTextPos();
            }
        });

        if (usePromptText.get()) {
            createPromptNode();
        }

        usePromptText.addListener(observable -&gt; {
            createPromptNode();
            control.requestLayout();
        });

        if (SHOW_HANDLES) {
            selectionHandle1.setRotate(180);

            EventHandler&lt;MouseEvent&gt; handlePressHandler = e -&gt; {
                pressX = e.getX();
                pressY = e.getY();
                e.consume();
            };

            caretHandle.setOnMousePressed(handlePressHandler);
            selectionHandle1.setOnMousePressed(handlePressHandler);
            selectionHandle2.setOnMousePressed(handlePressHandler);

            caretHandle.setOnMouseDragged(e -&gt; {
                Point2D p = new Point2D(caretHandle.getLayoutX() + e.getX() + pressX - textNode.getLayoutX(),
                                        caretHandle.getLayoutY() + e.getY() - pressY - 6);
                HitInfo hit = textNode.hitTest(p);
                positionCaret(hit, false);
                e.consume();
            });

            selectionHandle1.setOnMouseDragged(new EventHandler&lt;MouseEvent&gt;() {
                @Override public void handle(MouseEvent e) {
                    TextField control = getSkinnable();
                    Point2D tp = textNode.localToScene(0, 0);
                    Point2D p = new Point2D(e.getSceneX() - tp.getX() + 10/*??*/ - pressX + selectionHandle1.getWidth() / 2,
                                            e.getSceneY() - tp.getY() - pressY - 6);
                    HitInfo hit = textNode.hitTest(p);
                    if (control.getAnchor() &lt; control.getCaretPosition()) {
                        // Swap caret and anchor
                        control.selectRange(control.getCaretPosition(), control.getAnchor());
                    }
                    int pos = hit.getInsertionIndex();
                    if (pos &gt;= 0) {
                        if (pos &gt;= control.getAnchor() - 1) {
                            pos = Math.max(0, control.getAnchor() - 1);
                        }
                        positionCaret(pos, hit.isLeading(), true);
                    }
                    e.consume();
                }
            });

            selectionHandle2.setOnMouseDragged(new EventHandler&lt;MouseEvent&gt;() {
                @Override public void handle(MouseEvent e) {
                    TextField control = getSkinnable();
                    Point2D tp = textNode.localToScene(0, 0);
                    Point2D p = new Point2D(e.getSceneX() - tp.getX() + 10/*??*/ - pressX + selectionHandle2.getWidth() / 2,
                                            e.getSceneY() - tp.getY() - pressY - 6);
                    HitInfo hit = textNode.hitTest(p);
                    if (control.getAnchor() &gt; control.getCaretPosition()) {
                        // Swap caret and anchor
                        control.selectRange(control.getCaretPosition(), control.getAnchor());
                    }
                    int pos = hit.getInsertionIndex();
                    if (pos &gt; 0) {
                        if (pos &lt;= control.getAnchor()) {
                            pos = Math.min(control.getAnchor() + 1, control.getLength());
                        }
                        positionCaret(pos, hit.isLeading(), true);
                    }
                    e.consume();
                }
            });
        }
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        TextField textField = getSkinnable();

        double characterWidth = fontMetrics.get().getCharWidth('W');

        int columnCount = textField.getPrefColumnCount();

        return columnCount * characterWidth + leftInset + rightInset;
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return computePrefHeight(width, topInset, rightInset, bottomInset, leftInset);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return topInset + textNode.getLayoutBounds().getHeight() + bottomInset;
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return getSkinnable().prefHeight(width);
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        return topInset + textNode.getBaselineOffset();
    }

    // Public for behavior
    /**
     * Replaces a range of characters with the given text.
     *
     * Call this implementation from behavior classes instead of the
     * one provided on TextInputControl to ensure that the text
     * scrolls as needed.
     *
     * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
     * @param end The ending index in the range, exclusive. This is one-past the last character to
     *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
     *            and &amp;lt;= the length of the text.
     * @param txt The text that is to replace the range. This must not be null.
     * @see TextField#replaceText(int, int, String)
     */
    public void replaceText(int start, int end, String txt) {
        final double textMaxXOld = textNode.getBoundsInParent().getMaxX();
        final double caretMaxXOld = caretPath.getLayoutBounds().getMaxX() + textTranslateX.get();
        getSkinnable().replaceText(start, end, txt);
        scrollAfterDelete(textMaxXOld, caretMaxXOld);
    }

    // Public for behavior
    /**
     * Deletes the character that follows or precedes the current
     * caret position from the text if there is no selection, or
     * deletes the selection if there is one.
     *
     * Call this implementation from behavior classes instead of the
     * one provided on TextInputControl to ensure that the text
     * scrolls as needed.
     *
     * @param previous whether to delete the preceding character.
     */
    public void deleteChar(boolean previous) {
        final double textMaxXOld = textNode.getBoundsInParent().getMaxX();
        final double caretMaxXOld = caretPath.getLayoutBounds().getMaxX() + textTranslateX.get();
        if (previous ? getSkinnable().deletePreviousChar() : getSkinnable().deleteNextChar()) {
            scrollAfterDelete(textMaxXOld, caretMaxXOld);
        }
    }

    // Public for behavior
    /**
     * Performs a hit test, mapping point to index in the content.
     *
     * @param x the x coordinate of the point.
     * @param y the y coordinate of the point.
     * @return a {@code HitInfo} object describing the index and forward bias.
     */
    public HitInfo getIndex(double x, double y) {
        // adjust the event to be in the same coordinate space as the
        // text content of the textInputControl
        Point2D p = new Point2D(x - textTranslateX.get() - snappedLeftInset(),
                                y - snappedTopInset());
        return textNode.hitTest(p);
    }

    // Public for behavior
    /**
     * Moves the caret to the specified position.
     *
     * @param hit the new position and forward bias of the caret.
     * @param select whether to extend selection to the new position.
     */
    public void positionCaret(HitInfo hit, boolean select) {
        positionCaret(hit.getInsertionIndex(), hit.isLeading(), select);
    }

    private void positionCaret(int pos, boolean leading, boolean select) {
        TextField textField = getSkinnable();
        if (select) {
            textField.selectPositionCaret(pos);
        } else {
            textField.positionCaret(pos);
        }
        setForwardBias(leading);
    }

    /** {@inheritDoc} */
    @Override public Rectangle2D getCharacterBounds(int index) {
        double x, y;
        double width, height;
        if (index == textNode.getText().length()) {
            Bounds textNodeBounds = textNode.getBoundsInLocal();
            x = textNodeBounds.getMaxX();
            y = 0;
            width = 0;
            height = textNodeBounds.getMaxY();
        } else {
            characterBoundingPath.getElements().clear();
            characterBoundingPath.getElements().addAll(textNode.rangeShape(index, index + 1));
            characterBoundingPath.setLayoutX(textNode.getLayoutX());
            characterBoundingPath.setLayoutY(textNode.getLayoutY());

            Bounds bounds = characterBoundingPath.getBoundsInLocal();

            x = bounds.getMinX();
            y = bounds.getMinY();
            // Sometimes the bounds is empty, in which case we must ignore the width/height
            width  = bounds.isEmpty() ? 0 : bounds.getWidth();
            height = bounds.isEmpty() ? 0 : bounds.getHeight();
        }

        Bounds textBounds = textGroup.getBoundsInParent();

        return new Rectangle2D(x + textBounds.getMinX() + textTranslateX.get(),
                y + textBounds.getMinY(), width, height);
    }

    /** {@inheritDoc} */
    @Override protected PathElement[] getUnderlineShape(int start, int end) {
        return textNode.underlineShape(start, end);
    }

    /** {@inheritDoc} */
    @Override protected PathElement[] getRangeShape(int start, int end) {
        return textNode.rangeShape(start, end);
    }

    /** {@inheritDoc} */
    @Override protected void addHighlight(List&lt;? extends Node&gt; nodes, int start) {
        textGroup.getChildren().addAll(nodes);
    }

    /** {@inheritDoc} */
    @Override protected void removeHighlight(List&lt;? extends Node&gt; nodes) {
        textGroup.getChildren().removeAll(nodes);
    }

    /** {@inheritDoc} */
    @Override public void moveCaret(TextUnit unit, Direction dir, boolean select) {
        switch (unit) {
            case CHARACTER:
                switch (dir) {
                    case LEFT:
                    case RIGHT:
                        nextCharacterVisually(dir == Direction.RIGHT);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;
            default:
                throw new IllegalArgumentException(&quot;&quot;+unit);
        }
    }

    private void nextCharacterVisually(boolean moveRight) {
        if (isRTL()) {
            // Text node is mirrored.
            moveRight = !moveRight;
        }

        Bounds caretBounds = caretPath.getLayoutBounds();
        if (caretPath.getElements().size() == 4) {
            // The caret is split
            // TODO: Find a better way to get the primary caret position
            // instead of depending on the internal implementation.
            // See RT-25465.
            caretBounds = new Path(caretPath.getElements().get(0), caretPath.getElements().get(1)).getLayoutBounds();
        }
        double hitX = moveRight ? caretBounds.getMaxX() : caretBounds.getMinX();
        double hitY = (caretBounds.getMinY() + caretBounds.getMaxY()) / 2;
        HitInfo hit = textNode.hitTest(new Point2D(hitX, hitY));
        boolean leading = hit.isLeading();
        Path charShape = new Path(textNode.rangeShape(hit.getCharIndex(), hit.getCharIndex() + 1));
        if ((moveRight &amp;&amp; charShape.getLayoutBounds().getMaxX() &gt; caretBounds.getMaxX()) ||
                (!moveRight &amp;&amp; charShape.getLayoutBounds().getMinX() &lt; caretBounds.getMinX())) {
            leading = !leading;
        }
        positionCaret(hit.getInsertionIndex(), leading, false);
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        super.layoutChildren(x, y, w, h);

        if (textNode != null) {
            double textY;
            final Bounds textNodeBounds = textNode.getLayoutBounds();
            final double ascent = textNode.getBaselineOffset();
            final double descent = textNodeBounds.getHeight() - ascent;

            switch (getSkinnable().getAlignment().getVpos()) {
                case TOP:
                    textY = ascent;
                    break;

                case CENTER:
                    textY = (ascent + textGroup.getHeight() - descent) / 2;
                    break;

                case BOTTOM:
                default:
                    textY = textGroup.getHeight() - descent;
            }
            textNode.setY(textY);
            if (promptNode != null) {
                promptNode.setY(textY);
            }

            if (getSkinnable().getWidth() &gt; 0) {
                updateTextPos();
                updateCaretOff();
            }
        }

        if (SHOW_HANDLES) {
            handleGroup.setLayoutX(x + caretWidth / 2);
            handleGroup.setLayoutY(y);

            // Resize handles for caret and anchor.
//            IndexRange selection = textField.getSelection();
            selectionHandle1.resize(selectionHandle1.prefWidth(-1),
                    selectionHandle1.prefHeight(-1));
            selectionHandle2.resize(selectionHandle2.prefWidth(-1),
                    selectionHandle2.prefHeight(-1));
            caretHandle.resize(caretHandle.prefWidth(-1),
                    caretHandle.prefHeight(-1));

            Bounds b = caretPath.getBoundsInParent();
            caretHandle.setLayoutY(b.getMaxY() - 1);
            //selectionHandle1.setLayoutY(b.getMaxY() - 1);
            selectionHandle1.setLayoutY(b.getMinY() - selectionHandle1.getHeight() + 1);
            selectionHandle2.setLayoutY(b.getMaxY() - 1);
        }
    }

    private HPos getHAlignment() {
        HPos hPos = getSkinnable().getAlignment().getHpos();
        return hPos;
    }

    /** {@inheritDoc} */
    @Override public Point2D getMenuPosition() {
        Point2D p = super.getMenuPosition();
        if (p != null) {
            p = new Point2D(Math.max(0, p.getX() - textNode.getLayoutX() - snappedLeftInset() + textTranslateX.get()),
                    Math.max(0, p.getY() - textNode.getLayoutY() - snappedTopInset()));
        }
        return p;
    }

    /** {@inheritDoc} */
    @Override protected String maskText(String txt) {
        if (getSkinnable() instanceof PasswordField) {
            int n = txt.length();
            StringBuilder passwordBuilder = new StringBuilder(n);
            for (int i = 0; i &lt; n; i++) {
                passwordBuilder.append(BULLET);
            }

            return passwordBuilder.toString();
        } else {
            return txt;
        }
    }

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case BOUNDS_FOR_RANGE:
            case OFFSET_AT_POINT:
                return textNode.queryAccessibleAttribute(attribute, parameters);
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }



    /**************************************************************************
     *
     * Private implementation
     *
     **************************************************************************/

    TextInputControlBehavior getBehavior() {
        return behavior;
    }

    private void updateTextNodeCaretPos(int pos) {
        if (pos == 0 || isForwardBias()) {
            textNode.setCaretPosition(pos);
<A NAME="20"></A>        } else {
            textNode.setCaretPosition(pos - 1);
        }
        <FONT color="#d4a017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#20',2,'match37-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>textNode.caretBiasProperty().set(isForwardBias());
    }

    private void createPromptNode() {
        if (promptNode != null || !usePromptText.get()) return;

        promptNode = new Text();
        textGroup.getChildren().add</B></FONT>(0, promptNode);
        promptNode.setManaged(false);
        promptNode.getStyleClass().add(&quot;text&quot;);
        promptNode.visibleProperty().bind(usePromptText);
        promptNode.fontProperty().bind(getSkinnable().fontProperty());

        promptNode.textProperty().bind(getSkinnable().promptTextProperty());
        promptNode.fillProperty().bind(promptTextFillProperty());
        updateSelection();
    }

    private void updateSelection() {
        TextField textField = getSkinnable();
        IndexRange newValue = textField.getSelection();

        if (newValue == null || newValue.getLength() == 0) {
            textNode.selectionStartProperty().set(-1);
            textNode.selectionEndProperty().set(-1);
        } else {
            textNode.selectionStartProperty().set(newValue.getStart());
            // This intermediate value is needed to force selection shape layout.
            textNode.selectionEndProperty().set(newValue.getStart());
            textNode.selectionEndProperty().set(newValue.getEnd());
        }

        PathElement[] elements = textNode.selectionShapeProperty().get();
        if (elements == null) {
            selectionHighlightPath.getElements().clear();
        } else {
            selectionHighlightPath.getElements().setAll(elements);
        }

        if (SHOW_HANDLES &amp;&amp; newValue != null &amp;&amp; newValue.getLength() &gt; 0) {
            int caretPos = textField.getCaretPosition();
            int anchorPos = textField.getAnchor();

            {
                // Position the handle for the anchor. This could be handle1 or handle2.
                // Do this before positioning the handle for the caret.
                updateTextNodeCaretPos(anchorPos);
                Bounds b = caretPath.getBoundsInParent();
                if (caretPos &lt; anchorPos) {
                    selectionHandle2.setLayoutX(b.getMinX() - selectionHandle2.getWidth() / 2);
                } else {
                    selectionHandle1.setLayoutX(b.getMinX() - selectionHandle1.getWidth() / 2);
                }
            }

            {
                // Position handle for the caret. This could be handle1 or handle2.
                updateTextNodeCaretPos(caretPos);
                Bounds b = caretPath.getBoundsInParent();
                if (caretPos &lt; anchorPos) {
                    selectionHandle1.setLayoutX(b.getMinX() - selectionHandle1.getWidth() / 2);
                } else {
                    selectionHandle2.setLayoutX(b.getMinX() - selectionHandle2.getWidth() / 2);
                }
            }
        }
    }

    /**
     * Updates the textTranslateX value for the Text node position. This is
     * done for general layout, but care is taken to avoid resetting the
     * position when there's a need to scroll the text due to caret movement,
     * or when editing text that overflows on either side.
     */
    private void updateTextPos() {
        double oldX = textTranslateX.get();
        double newX;
        double textNodeWidth = textNode.getLayoutBounds().getWidth();

        switch (getHAlignment()) {
          case CENTER:
            double midPoint = textRight.get() / 2;
            if (usePromptText.get()) {
                // If a prompt is shown (which implies that the text is
                // empty), then we align the Text node so that the caret will
                // appear at the left of the centered prompt.
                newX = midPoint - promptNode.getLayoutBounds().getWidth() / 2;
                promptNode.setLayoutX(newX);
            } else {
                newX = midPoint - textNodeWidth / 2;
            }
            // Update if there is space on the right
            if (newX + textNodeWidth &lt;= textRight.get()) {
                textTranslateX.set(newX);
            }
            break;

          case RIGHT:
            newX = textRight.get() - textNodeWidth - caretWidth / 2;
            // Update if there is space on the right
            if (newX &gt; oldX || newX &gt; 0) {
                textTranslateX.set(newX);
            }
            if (usePromptText.get()) {
                promptNode.setLayoutX(textRight.get() - promptNode.getLayoutBounds().getWidth() -
                                      caretWidth / 2);
            }
            break;

          case LEFT:
          default:
            newX = caretWidth / 2;
            // Update if there is space on either side.
            if (newX &lt; oldX || newX + textNodeWidth &lt;= textRight.get()) {
                textTranslateX.set(newX);
            }
            if (usePromptText.get()) {
                promptNode.layoutXProperty().set(newX);
            }
        }
    }

    // should be called when the padding changes, or the text box width, or
    // the dot moves
    private void updateCaretOff() {
        double delta = 0.0;
        double caretX = caretPath.getLayoutBounds().getMinX() + textTranslateX.get();
        // If the caret position is less than or equal to the left edge of the
        // clip then the caret will be clipped. We want the caret to end up
        // being positioned one pixel right of the clip's left edge. The same
        // applies on the right edge (but going the other direction of course).
        if (caretX &lt; 0) {
            // I'll end up with a negative number
            delta = caretX;
        } else if (caretX &gt; (textRight.get() - caretWidth)) {
            // I'll end up with a positive number
            delta = caretX - (textRight.get() - caretWidth);
        }

        // If delta is negative, then translate in the negative direction
        // to cause the text to scroll to the right. Vice-versa for positive.
        switch (getHAlignment()) {
          case CENTER:
            textTranslateX.set(textTranslateX.get() - delta);
            break;

          case RIGHT:
            textTranslateX.set(Math.max(textTranslateX.get() - delta,
                                        textRight.get() - textNode.getLayoutBounds().getWidth() -
                                        caretWidth / 2));
            break;

          case LEFT:
          default:
            textTranslateX.set(Math.min(textTranslateX.get() - delta,
                                        caretWidth / 2));
        }
        if (SHOW_HANDLES) {
            caretHandle.setLayoutX(caretX - caretHandle.getWidth() / 2);
        }
    }

    private void scrollAfterDelete(double textMaxXOld, double caretMaxXOld) {
        final Bounds textLayoutBounds = textNode.getLayoutBounds();
        final Bounds textBounds = textNode.localToParent(textLayoutBounds);
        final Bounds clipBounds = clip.getBoundsInParent();
        final Bounds caretBounds = caretPath.getLayoutBounds();

        switch (getHAlignment()) {
          case RIGHT:
            if (textBounds.getMaxX() &gt; clipBounds.getMaxX()) {
                double delta = caretMaxXOld - caretBounds.getMaxX() - textTranslateX.get();
                if (textBounds.getMaxX() + delta &lt; clipBounds.getMaxX()) {
                    if (textMaxXOld &lt;= clipBounds.getMaxX()) {
                        delta = textMaxXOld - textBounds.getMaxX();
                    } else {
                        delta = clipBounds.getMaxX() - textBounds.getMaxX();
                    }
                }
                textTranslateX.set(textTranslateX.get() + delta);
            } else {
                updateTextPos();
            }
            break;

          case LEFT:
          case CENTER:
          default:
            if (textBounds.getMinX() &lt; clipBounds.getMinX() + caretWidth / 2 &amp;&amp;
                textBounds.getMaxX() &lt;= clipBounds.getMaxX()) {
                double delta = caretMaxXOld - caretBounds.getMaxX() - textTranslateX.get();
                if (textBounds.getMaxX() + delta &lt; clipBounds.getMaxX()) {
                    if (textMaxXOld &lt;= clipBounds.getMaxX()) {
                        delta = textMaxXOld - textBounds.getMaxX();
                    } else {
                        delta = clipBounds.getMaxX() - textBounds.getMaxX();
                    }
                }
                textTranslateX.set(textTranslateX.get() + delta);
            }
        }

        updateCaretOff();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.fxml/com/sun/javafx/fxml/BeanAdapter.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.fxml;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;

import java.lang.reflect.*;
import java.security.AccessController;
import java.security.PrivilegedAction;

import javafx.beans.value.ObservableValue;
import com.sun.javafx.reflect.FieldUtil;
import com.sun.javafx.reflect.MethodUtil;
import com.sun.javafx.reflect.ReflectUtil;

/**
 * Exposes Java Bean properties of an object via the {@link Map} interface.
 * A call to {@link Map#get(Object)} invokes the getter for the corresponding
 * property, and a call to {@link Map#put(Object, Object)} invokes the
 * property's setter. Appending a &quot;Property&quot; suffix to the key returns the
 * corresponding property model.
 */
public class BeanAdapter extends AbstractMap&lt;String, Object&gt; {
    private final Object bean;

    private static class MethodCache {
        private final Map&lt;String, List&lt;Method&gt;&gt; methods;
        private final MethodCache nextClassCache;

        private MethodCache(Map&lt;String, List&lt;Method&gt;&gt; methods, MethodCache nextClassCache) {
            this.methods = methods;
            this.nextClassCache = nextClassCache;
        }

        private Method getMethod(String name, Class&lt;?&gt;... parameterTypes) {
            List&lt;Method&gt; namedMethods = methods.get(name);
            if (namedMethods != null) {
                for (int i = 0; i &lt; namedMethods.size(); i++) {
                    Method namedMethod = namedMethods.get(i);
                    if (namedMethod.getName().equals(name)
                            &amp;&amp; Arrays.equals(namedMethod.getParameterTypes(), parameterTypes)) {
                        return namedMethod;
                    }
                }
            }

            return nextClassCache != null ? nextClassCache.getMethod(name, parameterTypes) : null;
        }

    }

<A NAME="1"></A>    private static final HashMap&lt;Class&lt;?&gt;, MethodCache&gt; globalMethodCache =
        new HashMap&lt;&gt;();

    <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#1',2,'match37-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private final MethodCache localCache;

    public static final String GET_PREFIX = &quot;get&quot;;
    public static final String IS_PREFIX = &quot;is&quot;;
    public static final String SET_PREFIX = &quot;set&quot;;
    public static final String PROPERTY_SUFFIX = &quot;Property&quot;;

    public static final String VALUE_OF_METHOD_NAME = &quot;valueOf&quot;;

    /**
     * Creates a new Bean adapter.
     *
     * @param bean
     * The Bean object to wrap.
     */
    public BeanAdapter(Object bean) {
        this.bean = bean;

        localCache = getClassMethodCache(bean.getClass());
    }

    private static MethodCache getClassMethodCache(final Class&lt;?&gt; type</B></FONT>) {
        if (type == Object.class) {
            return null;
        }
        MethodCache classMethodCache;
        synchronized (globalMethodCache) {
            if ((classMethodCache = globalMethodCache.get(type)) != null) {
                return classMethodCache;
            }
            Map&lt;String, List&lt;Method&gt;&gt; classMethods = new HashMap&lt;&gt;();

            ReflectUtil.checkPackageAccess(type);
            if (Modifier.isPublic(type.getModifiers())) {
                // only interested in public methods in public classes in
                // non-restricted packages
                final Method[] declaredMethods =
                        AccessController.doPrivileged(
                                new PrivilegedAction&lt;Method[]&gt;() {
                                    @Override
                                    public Method[] run() {
                                        return type.getDeclaredMethods();
                                    }
                                });
                for (int i = 0; i &lt; declaredMethods.length; i++) {
                    Method method = declaredMethods[i];
                    int modifiers = method.getModifiers();

                    if (Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isStatic(modifiers)) {
                        String name = method.getName();
                        List&lt;Method&gt; namedMethods = classMethods.get(name);

                        if (namedMethods == null) {
                            namedMethods = new ArrayList&lt;&gt;();
                            classMethods.put(name, namedMethods);
                        }

                        namedMethods.add(method);
                    }
                }
            }
            MethodCache cache = new MethodCache(classMethods, getClassMethodCache(type.getSuperclass()));
            globalMethodCache.put(type, cache);
            return cache;
        }
    }

    /**
     * Returns the Bean object this adapter wraps.
     *
     * @return
     * The Bean object, or &lt;tt&gt;null&lt;/tt&gt; if no Bean has been set.
     */
    public Object getBean() {
        return bean;
    }

    private Method getGetterMethod(String key) {
        Method getterMethod = localCache.getMethod(getMethodName(GET_PREFIX, key));

        if (getterMethod == null) {
            getterMethod = localCache.getMethod(getMethodName(IS_PREFIX, key));
        }

        return getterMethod;
    }

    private Method getSetterMethod(String key) {
        Class&lt;?&gt; type = getType(key);

        if (type == null) {
            throw new UnsupportedOperationException(&quot;Cannot determine type for property.&quot;);
        }

        return localCache.getMethod(getMethodName(SET_PREFIX, key), type);
    }

    private static String getMethodName(String prefix, String key) {
        return prefix + Character.toUpperCase(key.charAt(0)) + key.substring(1);
    }

    /**
     * Invokes the getter method for the given property.
     *
     * @param key
     * The property name.
     *
     * @return
     * The value returned by the method, or &lt;tt&gt;null&lt;/tt&gt; if no such method
     * exists.
     */
    @Override
    public Object get(Object key) {
        if (key == null) {
            throw new NullPointerException();
        }

        return get(key.toString());
    }

    private Object get(String key) {
        Method getterMethod = key.endsWith(PROPERTY_SUFFIX) ? localCache.getMethod(key) : getGetterMethod(key);

        Object value;
        if (getterMethod != null) {
            try {
                value = ModuleHelper.invoke(getterMethod, bean, (Object[]) null);
            } catch (IllegalAccessException exception) {
                throw new RuntimeException(exception);
            } catch (InvocationTargetException exception) {
                throw new RuntimeException(exception);
            }
        } else {
            value = null;
        }

        return value;
    }

    /**
     * Invokes a setter method for the given property. The
     * {@link #coerce(Object, Class)} method is used as needed to attempt to
     * convert a given value to the property type, as defined by the return
     * value of the getter method.
     *
     * @param key
     * The property name.
     *
     * @param value
     * The new property value.
     *
     * @return
     * Returns &lt;tt&gt;null&lt;/tt&gt;, since returning the previous value would require
     * an unnecessary call to the getter method.
     *
     * @throws PropertyNotFoundException
     * If the given property does not exist or is read-only.
     */
    @Override
    public Object put(String key, Object value) {
        if (key == null) {
            throw new NullPointerException();
        }

        Method setterMethod = getSetterMethod(key);

        if (setterMethod == null) {
            throw new PropertyNotFoundException(&quot;Property \&quot;&quot; + key + &quot;\&quot; does not exist&quot;
                + &quot; or is read-only.&quot;);
        }

        try {
            ModuleHelper.invoke(setterMethod, bean, new Object[] { coerce(value, getType(key)) });
        } catch (IllegalAccessException exception) {
            throw new RuntimeException(exception);
        } catch (InvocationTargetException exception) {
            throw new RuntimeException(exception);
        }

        return null;
    }

    /**
     * Verifies the existence of a property.
     *
     * @param key
     * The property name.
     *
     * @return
     * &lt;tt&gt;true&lt;/tt&gt; if the property exists; &lt;tt&gt;false&lt;/tt&gt;, otherwise.
     */
    @Override
    public boolean containsKey(Object key) {
        if (key == null) {
            throw new NullPointerException();
        }

        return getType(key.toString()) != null;
    }

    @Override
    public Set&lt;Entry&lt;String, Object&gt;&gt; entrySet() {
        throw new UnsupportedOperationException();
    }

    /**
     * Tests the mutability of a property.
     *
     * @param key
     * The property name.
     *
     * @return
     * &lt;tt&gt;true&lt;/tt&gt; if the property is read-only; &lt;tt&gt;false&lt;/tt&gt;, otherwise.
     */
    public boolean isReadOnly(String key) {
        if (key == null) {
            throw new NullPointerException();
        }

        return getSetterMethod(key) == null;
    }

    /**
     * Returns the property model for the given property.
     *
     * @param key
     * The property name.
     *
     * @return
     * The named property model, or &lt;tt&gt;null&lt;/tt&gt; if no such property exists.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; ObservableValue&lt;T&gt; getPropertyModel(String key) {
        if (key == null) {
            throw new NullPointerException();
        }

        return (ObservableValue&lt;T&gt;)get(key + BeanAdapter.PROPERTY_SUFFIX);
    }

    /**
     * Returns the type of a property.
     *
     * @param key
     * The property name.
     */
    public Class&lt;?&gt; getType(String key) {
        if (key == null) {
            throw new NullPointerException();
        }

        Method getterMethod = getGetterMethod(key);

        return (getterMethod == null) ? null : getterMethod.getReturnType();
    }

    /**
     * Returns the generic type of a property.
     *
     * @param key
     * The property name.
     */
    public Type getGenericType(String key) {
        if (key == null) {
            throw new NullPointerException();
        }

        Method getterMethod = getGetterMethod(key);

        return (getterMethod == null) ? null : getterMethod.getGenericReturnType();
    }

    @Override
    public boolean equals(Object object) {
        boolean equals = false;

        if (object instanceof BeanAdapter) {
            BeanAdapter beanAdapter = (BeanAdapter)object;
            equals = (bean == beanAdapter.bean);
        }

        return equals;
    }

    @Override
    public int hashCode() {
        return (bean == null) ? -1 : bean.hashCode();
    }

    /**
     * Coerces a value to a given type.
     *
     * @param value
     * @param type
     *
     * @return
     * The coerced value.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T coerce(Object value, Class&lt;? extends T&gt; type) {
        if (type == null) {
            throw new NullPointerException();
        }

        Object coercedValue = null;

        if (value == null) {
            // Null values can only be coerced to null
            coercedValue = null;
        } else if (type.isAssignableFrom(value.getClass())) {
            // Value doesn't require coercion
            coercedValue = value;
        } else if (type == Boolean.class
            || type == Boolean.TYPE) {
            coercedValue = Boolean.valueOf(value.toString());
        } else if (type == Character.class
            || type == Character.TYPE) {
            coercedValue = value.toString().charAt(0);
        } else if (type == Byte.class
            || type == Byte.TYPE) {
            if (value instanceof Number) {
                coercedValue = ((Number)value).byteValue();
            } else {
                coercedValue = Byte.valueOf(value.toString());
            }
        } else if (type == Short.class
            || type == Short.TYPE) {
            if (value instanceof Number) {
                coercedValue = ((Number)value).shortValue();
            } else {
                coercedValue = Short.valueOf(value.toString());
            }
        } else if (type == Integer.class
            || type == Integer.TYPE) {
            if (value instanceof Number) {
                coercedValue = ((Number)value).intValue();
            } else {
                coercedValue = Integer.valueOf(value.toString());
            }
        } else if (type == Long.class
            || type == Long.TYPE) {
            if (value instanceof Number) {
                coercedValue = ((Number)value).longValue();
            } else {
                coercedValue = Long.valueOf(value.toString());
            }
        } else if (type == BigInteger.class) {
            if (value instanceof Number) {
                coercedValue = BigInteger.valueOf(((Number)value).longValue());
            } else {
                coercedValue = new BigInteger(value.toString());
            }
        } else if (type == Float.class
            || type == Float.TYPE) {
            if (value instanceof Number) {
                coercedValue = ((Number)value).floatValue();
            } else {
                coercedValue = Float.valueOf(value.toString());
            }
        } else if (type == Double.class
            || type == Double.TYPE) {
            if (value instanceof Number) {
                coercedValue = ((Number)value).doubleValue();
            } else {
                coercedValue = Double.valueOf(value.toString());
            }
        } else if (type == Number.class) {
            String number = value.toString();
            if (number.contains(&quot;.&quot;)) {
                coercedValue = Double.valueOf(number);
            } else {
                coercedValue = Long.valueOf(number);
            }
        } else if (type == BigDecimal.class) {
            if (value instanceof Number) {
                coercedValue = BigDecimal.valueOf(((Number)value).doubleValue());
            } else {
                coercedValue = new BigDecimal(value.toString());
            }
        } else if (type == Class.class) {
            try {
                final String className = value.toString();
                ReflectUtil.checkPackageAccess(className);
                final ClassLoader cl = Thread.currentThread().getContextClassLoader();
                coercedValue = Class.forName(
                        className,
                        false,
                        cl);
            } catch (ClassNotFoundException exception) {
                throw new IllegalArgumentException(exception);
            }
        } else {
            Class&lt;?&gt; valueType = value.getClass();
            Method valueOfMethod = null;

            while (valueOfMethod == null
                &amp;&amp; valueType != null) {
                try {
                    ReflectUtil.checkPackageAccess(type);
                    valueOfMethod = type.getDeclaredMethod(VALUE_OF_METHOD_NAME, valueType);
                } catch (NoSuchMethodException exception) {
                    // No-op
                }

                if (valueOfMethod == null) {
                    valueType = valueType.getSuperclass();
                }
            }

            if (valueOfMethod == null) {
                throw new IllegalArgumentException(&quot;Unable to coerce &quot; + value + &quot; to &quot; + type + &quot;.&quot;);
            }

            if (type.isEnum()
                &amp;&amp; value instanceof String
                &amp;&amp; Character.isLowerCase(((String)value).charAt(0))) {
                value = toAllCaps((String)value);
            }

            try {
                coercedValue = ModuleHelper.invoke(valueOfMethod, null, new Object[] { value });
            } catch (IllegalAccessException exception) {
                throw new RuntimeException(exception);
            } catch (InvocationTargetException exception) {
                throw new RuntimeException(exception);
            } catch (SecurityException exception) {
                throw new RuntimeException(exception);
            }
        }

        return (T)coercedValue;
    }

    /**
     * Invokes the static getter method for the given property.
     *
     * @param target
     * The object to which the property is attached.
     *
     * @param sourceType
     * The class that defines the property.
     *
     * @param key
     * The property name.
     *
     * @return
     * The value returned by the method, or &lt;tt&gt;null&lt;/tt&gt; if no such method
     * exists.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T get(Object target, Class&lt;?&gt; sourceType, String key) {
        T value = null;

        Class&lt;?&gt; targetType = target.getClass();
        Method getterMethod = getStaticGetterMethod(sourceType, key, targetType);

        if (getterMethod != null) {
            try {
                value = (T) ModuleHelper.invoke(getterMethod, null, new Object[] { target } );
            } catch (InvocationTargetException exception) {
                throw new RuntimeException(exception);
            } catch (IllegalAccessException exception) {
                throw new RuntimeException(exception);
            }
        }

        return value;
    }

    /**
     * Invokes a static setter method for the given property. If the value is
     * &lt;tt&gt;null&lt;/tt&gt; or there is no explicit setter for a given type, the
     * {@link #coerce(Object, Class)} method is used to attempt to convert the
     * value to the actual property type (defined by the return value of the
     * getter method).
     *
     * @param target
     * The object to which the property is or will be attached.
     *
     * @param sourceType
     * The class that defines the property.
     *
     * @param key
     * The property name.
     *
     * @param value
     * The new property value.
     *
     * @throws PropertyNotFoundException
     * If the given static property does not exist or is read-only.
     */
    public static void put(Object target, Class&lt;?&gt; sourceType, String key, Object value) {
        Class&lt;?&gt; targetType = target.getClass();

        Method setterMethod = null;
        if (value != null) {
            setterMethod = getStaticSetterMethod(sourceType, key, value.getClass(), targetType);
        }

        if (setterMethod == null) {
            // Get the property type and attempt to coerce the value to it
            Class&lt;?&gt; propertyType = getType(sourceType, key, targetType);

            if (propertyType != null) {
                setterMethod = getStaticSetterMethod(sourceType, key, propertyType, targetType);
                value = coerce(value, propertyType);
            }
        }

        if (setterMethod == null) {
            throw new PropertyNotFoundException(&quot;Static property \&quot;&quot; + key + &quot;\&quot; does not exist&quot;
                + &quot; or is read-only.&quot;);
        }

        // Invoke the setter
        try {
            ModuleHelper.invoke(setterMethod, null, new Object[] { target, value });
        } catch (InvocationTargetException exception) {
            throw new RuntimeException(exception);
        } catch (IllegalAccessException exception) {
            throw new RuntimeException(exception);
        }
    }

    /**
     * Tests the existence of a static property.
     *
     * @param sourceType
     * The class that defines the property.
     *
     * @param key
     * The property name.
     *
     * @param targetType
     * The type of the object to which the property applies.
     *
     * @return
     * &lt;tt&gt;true&lt;/tt&gt; if the property exists; &lt;tt&gt;false&lt;/tt&gt;, otherwise.
     */
    public static boolean isDefined(Class&lt;?&gt; sourceType, String key, Class&lt;?&gt; targetType) {
        return (getStaticGetterMethod(sourceType, key, targetType) != null);
    }

    /**
     * Returns the type of a static property.
     *
     * @param sourceType
     * The class that defines the property.
     *
     * @param key
     * The property name.
     *
     * @param targetType
     * The type of the object to which the property applies.
     */
    public static Class&lt;?&gt; getType(Class&lt;?&gt; sourceType, String key, Class&lt;?&gt; targetType) {
        Method getterMethod = getStaticGetterMethod(sourceType, key, targetType);
        return (getterMethod == null) ? null : getterMethod.getReturnType();
    }

    /**
     * Returns the generic type of a static property.
     *
     * @param sourceType
     * The class that defines the property.
     *
     * @param key
     * The property name.
     *
     * @param targetType
     * The type of the object to which the property applies.
     */
    public static Type getGenericType(Class&lt;?&gt; sourceType, String key, Class&lt;?&gt; targetType) {
        Method getterMethod = getStaticGetterMethod(sourceType, key, targetType);
        return (getterMethod == null) ? null : getterMethod.getGenericReturnType();
    }

    /**
     * Determines the type of a list item.
     *
     * @param listType
     */
    public static Class&lt;?&gt; getListItemType(Type listType) {
        Type itemType = getGenericListItemType(listType);

        if (itemType instanceof ParameterizedType) {
            itemType = ((ParameterizedType)itemType).getRawType();
        }

        return (Class&lt;?&gt;)itemType;
    }

    /**
     * Determines the type of a map value.
     *
     * @param mapType
     */
    public static Class&lt;?&gt; getMapValueType(Type mapType) {
        Type valueType = getGenericMapValueType(mapType);

        if (valueType instanceof ParameterizedType) {
            valueType = ((ParameterizedType)valueType).getRawType();
        }

        return (Class&lt;?&gt;)valueType;
    }

    /**
     * Determines the type of a list item.
     *
     * @param listType
     */
    public static Type getGenericListItemType(Type listType) {
        Type itemType = null;

        Type parentType = listType;
        while (parentType != null) {
            if (parentType instanceof ParameterizedType) {
                ParameterizedType parameterizedType = (ParameterizedType)parentType;
                Class&lt;?&gt; rawType = (Class&lt;?&gt;)parameterizedType.getRawType();

                if (List.class.isAssignableFrom(rawType)) {
                    itemType = parameterizedType.getActualTypeArguments()[0];
                }

                break;
            }

            Class&lt;?&gt; classType = (Class&lt;?&gt;)parentType;
            Type[] genericInterfaces = classType.getGenericInterfaces();

            for (int i = 0; i &lt; genericInterfaces.length; i++) {
                Type genericInterface = genericInterfaces[i];

                if (genericInterface instanceof ParameterizedType) {
                    ParameterizedType parameterizedType = (ParameterizedType)genericInterface;
                    Class&lt;?&gt; interfaceType = (Class&lt;?&gt;)parameterizedType.getRawType();

                    if (List.class.isAssignableFrom(interfaceType)) {
                        itemType = parameterizedType.getActualTypeArguments()[0];
                        break;
                    }
                }
            }

            if (itemType != null) {
                break;
            }

            parentType = classType.getGenericSuperclass();
        }

        if (itemType != null &amp;&amp; itemType instanceof TypeVariable&lt;?&gt;) {
            itemType = Object.class;
        }

        return itemType;
    }

    /**
     * Determines the type of a map value.
     *
     * @param mapType
     */
    public static Type getGenericMapValueType(Type mapType) {
        Type valueType = null;

        Type parentType = mapType;
        while (parentType != null) {
            if (parentType instanceof ParameterizedType) {
                ParameterizedType parameterizedType = (ParameterizedType)parentType;
                Class&lt;?&gt; rawType = (Class&lt;?&gt;)parameterizedType.getRawType();

                if (Map.class.isAssignableFrom(rawType)) {
                    valueType = parameterizedType.getActualTypeArguments()[1];
                }

                break;
            }

            Class&lt;?&gt; classType = (Class&lt;?&gt;)parentType;
            Type[] genericInterfaces = classType.getGenericInterfaces();

            for (int i = 0; i &lt; genericInterfaces.length; i++) {
                Type genericInterface = genericInterfaces[i];

                if (genericInterface instanceof ParameterizedType) {
                    ParameterizedType parameterizedType = (ParameterizedType)genericInterface;
                    Class&lt;?&gt; interfaceType = (Class&lt;?&gt;)parameterizedType.getRawType();

                    if (Map.class.isAssignableFrom(interfaceType)) {
                        valueType = parameterizedType.getActualTypeArguments()[1];
                        break;
                    }
                }
            }

            if (valueType != null) {
                break;
            }

            parentType = classType.getGenericSuperclass();
        }

        if (valueType != null &amp;&amp; valueType instanceof TypeVariable&lt;?&gt;) {
            valueType = Object.class;
        }

        return valueType;
    }

    /**
     * Returns the value of a named constant.
     *
     * @param type
     * The type that defines the constant.
     *
     * @param name
     * The name of the constant.
     */
    public static Object getConstantValue(Class&lt;?&gt; type, String name) {
        if (type == null) {
            throw new IllegalArgumentException();
        }

        if (name == null) {
            throw new IllegalArgumentException();
        }

        Field field;
        try {
            field = FieldUtil.getField(type, name);
        } catch (NoSuchFieldException exception) {
            throw new IllegalArgumentException(exception);
        }

        int fieldModifiers = field.getModifiers();
        if ((fieldModifiers &amp; Modifier.STATIC) == 0
            || (fieldModifiers &amp; Modifier.FINAL) == 0) {
            throw new IllegalArgumentException(&quot;Field is not a constant.&quot;);
        }

        Object value;
        try {
            value = field.get(null);
        } catch (IllegalAccessException exception) {
            throw new IllegalArgumentException(exception);
        }

        return value;
    }

    private static Method getStaticGetterMethod(Class&lt;?&gt; sourceType, String key,
        Class&lt;?&gt; targetType) {
        if (sourceType == null) {
            throw new NullPointerException();
        }

        if (key == null) {
            throw new NullPointerException();
        }

        Method method = null;

        if (targetType != null) {
            key = Character.toUpperCase(key.charAt(0)) + key.substring(1);

            String getMethodName = GET_PREFIX + key;
            String isMethodName = IS_PREFIX + key;

            try {
                method = MethodUtil.getMethod(sourceType, getMethodName, new Class[] { targetType });
            } catch (NoSuchMethodException exception) {
                // No-op
            }

            if (method == null) {
                try {
                    method = MethodUtil.getMethod(sourceType, isMethodName, new Class[] { targetType });
                } catch (NoSuchMethodException exception) {
                    // No-op
                }
            }

            // Check for interfaces
            if (method == null) {
                Class&lt;?&gt;[] interfaces = targetType.getInterfaces();
                for (int i = 0; i &lt; interfaces.length; i++) {
                    try {
                        method = MethodUtil.getMethod(sourceType, getMethodName, new Class[] { interfaces[i] });
                    } catch (NoSuchMethodException exception) {
                        // No-op
                    }

                    if (method == null) {
                        try {
                            method = MethodUtil.getMethod(sourceType, isMethodName, new Class[] { interfaces[i] });
                        } catch (NoSuchMethodException exception) {
                            // No-op
                        }
                    }

                    if (method != null) {
                        break;
                    }
                }
            }

            if (method == null) {
                method = getStaticGetterMethod(sourceType, key, targetType.getSuperclass());
            }
        }

        return method;
    }

    private static Method getStaticSetterMethod(Class&lt;?&gt; sourceType, String key,
        Class&lt;?&gt; valueType, Class&lt;?&gt; targetType) {
        if (sourceType == null) {
            throw new NullPointerException();
        }

        if (key == null) {
            throw new NullPointerException();
        }

        if (valueType == null) {
            throw new NullPointerException();
        }

        Method method = null;

        if (targetType != null) {
            key = Character.toUpperCase(key.charAt(0)) + key.substring(1);

            String setMethodName = SET_PREFIX + key;
            try {
                method = MethodUtil.getMethod(sourceType, setMethodName, new Class[] { targetType, valueType });
            } catch (NoSuchMethodException exception) {
                // No-op
            }

            // Check for interfaces
            if (method == null) {
                Class&lt;?&gt;[] interfaces = targetType.getInterfaces();
                for (int i = 0; i &lt; interfaces.length; i++) {
                    try {
                        method = MethodUtil.getMethod(sourceType, setMethodName, new Class[] { interfaces[i], valueType });
                    } catch (NoSuchMethodException exception) {
                        // No-op
                    }

                    if (method != null) {
                        break;
                    }
                }
            }

            if (method == null) {
                method = getStaticSetterMethod(sourceType, key, valueType, targetType.getSuperclass());
            }
        }

        return method;
    }

    private static String toAllCaps(String value) {
        if (value == null) {
            throw new NullPointerException();
        }

        StringBuilder allCapsBuilder = new StringBuilder();

        for (int i = 0, n = value.length(); i &lt; n; i++) {
            char c = value.charAt(i);

            if (Character.isUpperCase(c)) {
                allCapsBuilder.append('_');
            }

            allCapsBuilder.append(Character.toUpperCase(c));
        }

        return allCapsBuilder.toString();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.fxml/com/sun/javafx/fxml/builder/JavaFXFontBuilder.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="47"></A> * questions.
 */

<FONT color="#d16587"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#47',2,'match37-top.html#47',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.javafx.fxml.builder;

import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.AbstractMap;
import java.util.Set;
import java.util.StringTokenizer;
import javafx.scene.text.Font;
import javafx.scene.text.FontPosture;
import javafx.scene.text.FontWeight;
import javafx.util.Builder;

/**
 * JavaFX font builder.
 */
public final class JavaFXFontBuilder extends AbstractMap&lt;String, Object&gt; implements Builder&lt;Font&gt; {
    private String      name = null;
    private double      size = 12D;
    private FontWeight  weight = nul</B></FONT>l;
    private FontPosture posture = null;
    private URL         url     = null;

    @Override
    public Font build() {
        Font f;
        if ( url != null) {
            //TODO Implement some font name caching so that the font
            // is not constructed from the stream every time
            InputStream in = null;
            try {
                in = url.openStream();
                f = Font.loadFont(in, size);
            } catch( Exception e) {
                //TODO
                throw new RuntimeException( &quot;Load of font file failed from &quot; + url, e);
            } finally {
                try {
                    if ( in != null) {
                        in.close();
                    }
                } catch( Exception e) {
                    //TODO
                    e.printStackTrace();
                }
            }
        } else {
            if (weight == null &amp;&amp; posture == null) {
                f = new Font(name, size);
            } else {
                if (weight == null) weight = FontWeight.NORMAL;
                if (posture == null) posture = FontPosture.REGULAR;
                f = Font.font(name, weight, posture, size);
            }
        }
        return f;
    }

    @Override
    public Object put(String key, Object value) {
        if ( &quot;name&quot;.equals( key)) {
            if ( value instanceof URL) {
                url = (URL) value;
            } else {
                name = (String) value;
            }
        } else if ( &quot;size&quot;.equals(key)) {
            size =  Double.parseDouble((String) value);
        } else if ( &quot;style&quot;.equals(key)) {
            String style = (String) value;
            if ( style != null &amp;&amp; style.length() &gt; 0) {
                boolean isWeightSet = false;
                for( StringTokenizer st = new StringTokenizer( style, &quot; &quot;); st.hasMoreTokens(); ) {
                    String stylePart = st.nextToken();
                    FontWeight fw;
                    if ( !isWeightSet &amp;&amp; (fw=FontWeight.findByName(stylePart)) != null) {
                        weight = fw;
                        isWeightSet = true;
                        continue;
                    }
                    FontPosture fp;
                    if ( (fp=FontPosture.findByName(stylePart)) != null) {
                        posture = fp;
                        continue;
                    }
                }
            }
        } else if ( &quot;url&quot;.equals(key)) {
            if ( value instanceof URL) {
                url = (URL) value;
            } else {
                try {
                    url = new URL( value.toString());
                } catch( MalformedURLException e) {
                    //TODO Better exception
                    throw new IllegalArgumentException(&quot;Invalid url &quot; + value.toString(), e);
                }
            }
        } else {
            throw new IllegalArgumentException(&quot;Unknown Font property: &quot; + key);
        }
        return null;
    }

    @Override
    public boolean containsKey(Object key) {
        return false; // False in this context means that the property is NOT read only
    }

    @Override
    public Object get(Object key) {
        return null; // In certain cases, get is also required to return null for read-write &quot;properties&quot;
    }

    @Override
    public Set&lt;Entry&lt;String, Object&gt;&gt; entrySet() {
        throw new UnsupportedOperationException();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.fxml/com/sun/javafx/fxml/expression/Expression.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.fxml.expression;

import java.io.IOException;
import java.io.PushbackReader;
import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.sun.javafx.fxml.BeanAdapter;
import static com.sun.javafx.fxml.expression.Operator.*;

/**
 * Abstract base class for expressions. Also provides static methods for
 * creating arithmetic and logical expressions as well as accessing namespace
 * values by key path.
 */
public abstract class Expression&lt;T&gt; {
    // Expression parser class
    private static class Parser {
        public static class Token {
            public Token(TokenType type, Object value) {
                this.type = type;
                this.value = value;
            }

            public final TokenType type;
            public final Object value;

            @Override
            public String toString() {
                return value.toString();
            }
        }

        public enum TokenType {
            LITERAL,
            VARIABLE,
            FUNCTION,
            UNARY_OPERATOR,
            BINARY_OPERATOR,
            BEGIN_GROUP,
            END_GROUP
        }

        private int c = -1;
        private char[] pushbackBuffer = new char[PUSHBACK_BUFFER_SIZE];

        private static final int PUSHBACK_BUFFER_SIZE = 6;

        public Expression parse(Reader reader) throws IOException {
            LinkedList&lt;Token&gt; tokens = tokenize(new PushbackReader(reader, PUSHBACK_BUFFER_SIZE));

            LinkedList&lt;Expression&gt; stack = new LinkedList&lt;Expression&gt;();

            for (Token token : tokens) {
                Expression&lt;?&gt; expression;
                switch (token.type) {
                    case LITERAL: {
                        expression = new LiteralExpression(token.value);
                        break;
                    }
<A NAME="4"></A>
                    case VARIABLE: {
                        expression = new VariableExpression((KeyPath)token.value);
                        <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#4',2,'match37-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>break;
                    }

                    case FUNCTION: {
                        // TODO Create a new FunctionExpression type; this
                        // class will have a property of type Method that
                        // refers to a method defined by the &quot;scope context&quot;
                        // (e.g. an FXML document controller), which must be
                        // set prior to evaluating the expression; it will
                        // also have a list of argument Expressions
                        expression = null;
                        break;
                    }

                    case UNARY_OPERATOR: {</B></FONT>
                        Operator operator = (Operator)token.value;
                        Expression operand = stack.pop();

                        switch(operator) {
                            case NEGATE:
                                expression = negate(operand);
                                break;
                            case NOT:
                                expression = not(operand);
                                break;
                            default:
                                throw new UnsupportedOperationException();

                        }

                        break;
                    }

                    case BINARY_OPERATOR: {
                        Operator operator = (Operator)token.value;
                        Expression right = stack.pop();
                        Expression left = stack.pop();

                        switch(operator) {
                            case ADD:
                                expression = add(left, right);
                                break;
                            case SUBTRACT:
                                expression = subtract(left, right);
                                break;
                            case MULTIPLY:
                                expression = multiply(left, right);
                                break;
                            case DIVIDE:
                                expression = divide(left, right);
                                break;
                            case MODULO:
                                expression = modulo(left, right);
                                break;
                            case GREATER_THAN:
                                expression = greaterThan(left, right);
                                break;
                            case GREATER_THAN_OR_EQUAL_TO:
                                expression = greaterThanOrEqualTo(left, right);
                                break;
                            case LESS_THAN:
                                expression = lessThan(left, right);
                                break;
                            case LESS_THAN_OR_EQUAL_TO:
                                expression = lessThanOrEqualTo(left, right);
                                break;
                            case EQUAL_TO:
                                expression = equalTo(left, right);
                                break;
                            case NOT_EQUAL_TO:
                                expression = notEqualTo(left, right);
                                break;
                            case AND:
                                expression = and(left, right);
                                break;
                            case OR:
                                expression = or(left, right);
                                break;
                            default:
                                throw new UnsupportedOperationException();
                        }

                        break;
                    }

                    default: {
                        throw new UnsupportedOperationException();
                    }
                }

                stack.push(expression);
            }

            if (stack.size() != 1) {
                throw new IllegalArgumentException(&quot;Invalid expression.&quot;);
            }

            return stack.peek();
        }

        private LinkedList&lt;Token&gt; tokenize(PushbackReader reader) throws IOException {
            // Read the string into a postfix list of tokens
            LinkedList&lt;Token&gt; tokens = new LinkedList&lt;Token&gt;();
            LinkedList&lt;Token&gt; stack = new LinkedList&lt;Token&gt;();

            c = reader.read();
            boolean unary = true;

            while (c != -1) {
                // Skip whitespace
                while (c != -1 &amp;&amp; Character.isWhitespace(c)) {
                    c = reader.read();
                }

                if (c != -1) {
                    Token token;

                    if (c == 'n') {
                        if (readKeyword(reader, NULL_KEYWORD)) {
                            token = new Token(TokenType.LITERAL, null);
                        } else {
                            token = new Token(TokenType.VARIABLE, KeyPath.parse(reader));
                            c = reader.read();
                        }
                    } else if (c == '&quot;' || c == '\'') {
                        StringBuilder stringBuilder = new StringBuilder();

                        // Use the same delimiter to close the string
                        int t = c;

                        // Move to the next character after the delimiter
                        c = reader.read();

                        while (c != -1 &amp;&amp; c != t) {
                            if (!Character.isISOControl(c)) {
                                if (c == '\\') {
                                    c = reader.read();

                                    if (c == 'b') {
                                        c = '\b';
                                    } else if (c == 'f') {
                                        c = '\f';
                                    } else if (c == 'n') {
                                        c = '\n';
                                    } else if (c == 'r') {
                                        c = '\r';
                                    } else if (c == 't') {
                                        c = '\t';
                                    } else if (c == 'u') {
                                        StringBuilder unicodeValueBuilder = new StringBuilder();
                                        while (unicodeValueBuilder.length() &lt; 4) {
                                            c = reader.read();
                                            unicodeValueBuilder.append((char)c);
                                        }

                                        String unicodeValue = unicodeValueBuilder.toString();
                                        c = (char)Integer.parseInt(unicodeValue, 16);
                                    } else {
                                        if (!(c == '\\'
                                            || c == '/'
                                            || c == '\&quot;'
                                            || c == '\''
                                            || c == t)) {
                                            throw new IllegalArgumentException(&quot;Unsupported escape sequence.&quot;);
                                        }
                                    }
                                }

                                stringBuilder.append((char)c);
                            }

                            c = reader.read();
                        }

                        if (c != t) {
                            throw new IllegalArgumentException(&quot;Unterminated string.&quot;);
                        }

                        // Move to the next character after the delimiter
                        c = reader.read();

                        token = new Token(TokenType.LITERAL, stringBuilder.toString());
                    } else if (Character.isDigit(c)) {
                        StringBuilder numberBuilder = new StringBuilder();
                        boolean integer = true;

                        while (c != -1 &amp;&amp; (Character.isDigit(c) || c == '.'
                            || c == 'e' || c == 'E')) {
                            numberBuilder.append((char)c);
                            integer &amp;= !(c == '.');
                            c = reader.read();
                        }

                        Number value;
                        if (integer) {
                            value = Long.parseLong(numberBuilder.toString());
                        } else {
                            value = Double.parseDouble(numberBuilder.toString());
                        }

                        token = new Token(TokenType.LITERAL, value);
                    } else if (c == 't') {
                        if (readKeyword(reader, TRUE_KEYWORD)) {
                            token = new Token(TokenType.LITERAL, true);
                        } else {
                            token = new Token(TokenType.VARIABLE, KeyPath.parse(reader));
                            c = reader.read();
                        }
                    } else if (c == 'f') {
                        if (readKeyword(reader, FALSE_KEYWORD)) {
                            token = new Token(TokenType.LITERAL, false);
                        } else {
                            token = new Token(TokenType.VARIABLE, KeyPath.parse(reader));
                            c = reader.read();
                        }
                    } else if (Character.isJavaIdentifierStart(c)) {
                        reader.unread(c);

                        // TODO Here (and everywhere else where we call KeyPath.parse()),
                        // read the path value. If c == '(' when this method returns, the
                        // path refers to a function; read the arguments and create a
                        // FUNCTION token
                        token = new Token(TokenType.VARIABLE, KeyPath.parse(reader));
                        c = reader.read();
                    } else {
                        boolean readNext = true;
                        if (unary) {
                            switch(c) {
                                case '-':
                                    token = new Token(TokenType.UNARY_OPERATOR, NEGATE);
                                    break;
                                case '!':
                                    token = new Token(TokenType.UNARY_OPERATOR, NOT);
                                    break;
                                case '(':
                                    token = new Token(TokenType.BEGIN_GROUP, null);
                                    break;
                                default:
                                    throw new IllegalArgumentException(&quot;Unexpected character in expression.&quot;);
                            }
                        } else {
                            switch(c) {
                                case '+':
                                    token = new Token(TokenType.BINARY_OPERATOR, ADD);
                                    break;
                                case '-':
                                    token = new Token(TokenType.BINARY_OPERATOR, SUBTRACT);
                                    break;
                                case '*':
                                    token = new Token(TokenType.BINARY_OPERATOR, MULTIPLY);
                                    break;
                                case '/':
                                    token = new Token(TokenType.BINARY_OPERATOR, DIVIDE);
                                    break;
                                case '%':
                                    token = new Token(TokenType.BINARY_OPERATOR, MODULO);
                                    break;
                                case '=':
                                    c = reader.read();
                                    if (c == '=') {
                                        token = new Token(TokenType.BINARY_OPERATOR, EQUAL_TO);
                                    } else {
                                        throw new IllegalArgumentException(&quot;Unexpected character in expression.&quot;);
                                    }
                                    break;
                                case '!':
                                    c = reader.read();

                                    if (c == '=') {
                                        token = new Token(TokenType.BINARY_OPERATOR, NOT_EQUAL_TO);
                                    } else {
                                        throw new IllegalArgumentException(&quot;Unexpected character in expression.&quot;);
                                    }
                                    break;
                                case '&gt;':
                                    c = reader.read();

                                    if (c == '=') {
                                        token = new Token(TokenType.BINARY_OPERATOR, GREATER_THAN_OR_EQUAL_TO);
                                    } else {
                                        readNext = false;
                                        token = new Token(TokenType.BINARY_OPERATOR, GREATER_THAN);
                                    }
                                    break;
                                case '&lt;':
                                    c = reader.read();

                                    if (c == '=') {
                                        token = new Token(TokenType.BINARY_OPERATOR, LESS_THAN_OR_EQUAL_TO);
                                    } else {
                                        readNext = false;
                                        token = new Token(TokenType.BINARY_OPERATOR, LESS_THAN);
                                    }
                                    break;
                                case '&amp;':
                                    c = reader.read();

                                    if (c == '&amp;') {
                                        token = new Token(TokenType.BINARY_OPERATOR, AND);
                                    } else {
                                        throw new IllegalArgumentException(&quot;Unexpected character in expression.&quot;);
                                    }
                                    break;
                                case '|':
                                    c = reader.read();

                                    if (c == '|') {
                                        token = new Token(TokenType.BINARY_OPERATOR, OR);
                                    } else {
                                        throw new IllegalArgumentException(&quot;Unexpected character in expression.&quot;);
                                    }
                                    break;

                                case ')':
                                    token = new Token(TokenType.END_GROUP, null);
                                    break;
                                default:
                                    throw new IllegalArgumentException(&quot;Unexpected character in expression.&quot;);
                            }

                        }
                        if (readNext) {
                            c = reader.read();
                        }
                    }

                    // Process the token
                    switch (token.type) {
                        case LITERAL:
                        case VARIABLE: {
                            tokens.add(token);
                            break;
                        }

                        case UNARY_OPERATOR:
                        case BINARY_OPERATOR: {
                            int priority = ((Operator)token.value).getPriority();

                            while (!stack.isEmpty()
                                &amp;&amp; stack.peek().type != TokenType.BEGIN_GROUP
                                &amp;&amp; ((Operator)stack.peek().value).getPriority() &gt;= priority
                                &amp;&amp; ((Operator)stack.peek().value).getPriority() != Operator.MAX_PRIORITY) {
                                tokens.add(stack.pop());
                            }

                            stack.push(token);
                            break;
                        }

                        case BEGIN_GROUP: {
                            stack.push(token);
                            break;
                        }

                        case END_GROUP: {
                            for (Token t = stack.pop(); t.type != TokenType.BEGIN_GROUP; t = stack.pop()) {
                                tokens.add(t);
                            }

                            break;
                        }

                        default: {
                            throw new UnsupportedOperationException();
                        }
                    }

                    unary = !(token.type == TokenType.LITERAL || token.type == TokenType.VARIABLE || token.type == TokenType.END_GROUP);
                }
            }

            while (!stack.isEmpty()) {
                tokens.add(stack.pop());
            }

            return tokens;
        }

        private boolean readKeyword(PushbackReader reader, String keyword) throws IOException {
            int n = keyword.length();
            int i = 0;

            while (c != -1 &amp;&amp; i &lt; n) {
                pushbackBuffer[i] = (char)c;
                if (keyword.charAt(i) != c) {
                    break;
                }

                c = reader.read();
                i++;
            }

            boolean result;
            if (i &lt; n) {
                reader.unread(pushbackBuffer, 0, i + 1);
                result = false;
            } else {
                result = true;
            }

            return result;
        }

    }

    private static final String NULL_KEYWORD = &quot;null&quot;;
    private static final String TRUE_KEYWORD = &quot;true&quot;;
    private static final String FALSE_KEYWORD = &quot;false&quot;;

    /**
     * Evaluates the expression.
     *
     * @param namespace
     * The namespace against which the expression will be evaluated.
     *
     * @return
     * The result of evaluating the expression.
     */
    public abstract T evaluate(Object namespace);

    /**
     * Updates the expression value.
     *
     * @param namespace
     * The namespace against which the expression will be evaluated.
     *
     * @param value
     * The value to assign to the expression.
     */
    public abstract void update(Object namespace, T value);

    /**
     * Tests whether the expression is defined.
     *
     * @param namespace
     * The namespace against which the expression will be evaluated.
     *
     * @return
     * &lt;tt&gt;true&lt;/tt&gt; if the expression is defined; &lt;tt&gt;false&lt;/tt&gt;, otherwise.
     */
    public abstract boolean isDefined(Object namespace);

    /**
     * Tests whether the expression represents an l-value (i.e. can be
     * assigned to).
     *
     * @return
     * &lt;tt&gt;true&lt;/tt&gt; if the expression is an l-value; &lt;tt&gt;false&lt;/tt&gt;,
     * otherwise.
     */
    public abstract boolean isLValue();

    /**
     * Returns a list of arguments to this expression.
     */
    public List&lt;KeyPath&gt; getArguments() {
        ArrayList&lt;KeyPath&gt; arguments = new ArrayList&lt;KeyPath&gt;();
        getArguments(arguments);

        return arguments;
    }

    /**
     * Populates a list of arguments to this expression.
     */
    protected abstract void getArguments(List&lt;KeyPath&gt; arguments);

    /**
     * Returns the value at a given path within a namespace.
     *
     * @param namespace
     * @param keyPath
     *
     * @return
     * The value at the given path, or &lt;tt&gt;null&lt;/tt&gt; if no such value exists.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T get(Object namespace, KeyPath keyPath) {
        if (keyPath == null) {
            throw new NullPointerException();
        }

        return (T)get(namespace, keyPath.iterator());
    }

    /**
     * Returns the value at a given path within a namespace.
     *
     * @param namespace
     * @param keyPathIterator
     *
     * @return
     * The value at the given path, or &lt;tt&gt;null&lt;/tt&gt; if no such value exists.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private static &lt;T&gt; T get(Object namespace, Iterator&lt;String&gt; keyPathIterator) {
        if (keyPathIterator == null) {
            throw new NullPointerException();
        }

        T value;
        if (keyPathIterator.hasNext()) {
            // TODO Remove cast to T when build is updated to Java 7
            value = (T)get(get(namespace, keyPathIterator.next()), keyPathIterator);
        } else {
            value = (T)namespace;
        }

        return value;
    }

    /**
     * Returns the value at a given key within a namespace.
     *
     * @param namespace
     * @param key
     *
     * @return
     * The value at the given key, or &lt;tt&gt;null&lt;/tt&gt; if no such value exists.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T get(Object namespace, String key) {
        if (key == null) {
            throw new NullPointerException();
        }

        Object value;
        if (namespace instanceof List&lt;?&gt;) {
            List&lt;Object&gt; list = (List&lt;Object&gt;)namespace;
            value = list.get(Integer.parseInt(key));
        } else if (namespace != null) {
            Map&lt;String, Object&gt; map;
            if (namespace instanceof Map&lt;?, ?&gt;) {
                map = (Map&lt;String, Object&gt;)namespace;
            } else {
                map = new BeanAdapter(namespace);
            }

            value = map.get(key);
        } else {
            value = null;
        }

        return (T)value;
    }

    /**
     * Sets the value at a given path within a namespace.
     *
     * @param namespace
     * @param keyPath
     * @param value
     */
    public static void set(Object namespace, KeyPath keyPath, Object value) {
        if (keyPath == null) {
            throw new NullPointerException();
        }

        set(namespace, keyPath.iterator(), value);
    }

    /**
     * Sets the value at a given path within a namespace.
     *
     * @param namespace
     * @param keyPathIterator
     * @param value
     */
    private static void set(Object namespace, Iterator&lt;String&gt; keyPathIterator, Object value) {
        if (keyPathIterator == null) {
            throw new NullPointerException();
        }

        if (!keyPathIterator.hasNext()) {
            throw new IllegalArgumentException();
        }

        String key = keyPathIterator.next();

        if (keyPathIterator.hasNext()) {
            set(get(namespace, key), keyPathIterator, value);
        } else {
            set(namespace, key, value);
        }
    }

    /**
     * Sets the value at a given path within a namespace.
     *
     * @param namespace
     * @param key
     * @param value
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static void set(Object namespace, String key, Object value) {
        if (key == null) {
            throw new NullPointerException();
        }

        if (namespace instanceof List&lt;?&gt;) {
            List&lt;Object&gt; list = (List&lt;Object&gt;)namespace;
            list.set(Integer.parseInt(key), value);
        } else if (namespace != null) {
            Map&lt;String, Object&gt; map;
            if (namespace instanceof Map&lt;?, ?&gt;) {
                map = (Map&lt;String, Object&gt;)namespace;
            } else {
                map = new BeanAdapter(namespace);
            }

            map.put(key, value);
        } else {
            throw new IllegalArgumentException();
        }
    }

    /**
     * Tests the existence of a path within a namespace.
     *
     * @param namespace
     * @param keyPath
     *
     * @return
     * &lt;tt&gt;true&lt;/tt&gt; if the path exists; &lt;tt&gt;false&lt;/tt&gt;, otherwise.
     */
    public static boolean isDefined(Object namespace, KeyPath keyPath) {
        if (keyPath == null) {
            throw new NullPointerException();
        }

        return isDefined(namespace, keyPath.iterator());
    }

    /**
     * Tests the existence of a path within a namespace.
     *
     * @param namespace
     * @param keyPathIterator
     *
     * @return
     * &lt;tt&gt;true&lt;/tt&gt; if the path exists; &lt;tt&gt;false&lt;/tt&gt;, otherwise.
     */
    private static boolean isDefined(Object namespace, Iterator&lt;String&gt; keyPathIterator) {
        if (keyPathIterator == null) {
            throw new NullPointerException();
        }

        if (!keyPathIterator.hasNext()) {
            throw new IllegalArgumentException();
        }

        String key = keyPathIterator.next();

        boolean defined;
        if (keyPathIterator.hasNext()) {
            defined = isDefined(get(namespace, key), keyPathIterator);
        } else {
            defined = isDefined(namespace, key);
        }

        return defined;
    }

    /**
     * Tests the existence of a key within a namespace.
     *
     * @param namespace
     * @param key
     *
     * @return
     * &lt;tt&gt;true&lt;/tt&gt; if the key exists; &lt;tt&gt;false&lt;/tt&gt;, otherwise.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static boolean isDefined(Object namespace, String key) {
        if (key == null) {
            throw new NullPointerException();
        }

        boolean defined;
        if (namespace instanceof List&lt;?&gt;) {
            List&lt;Object&gt; list = (List&lt;Object&gt;)namespace;
            defined = Integer.parseInt(key) &lt; list.size();
        } else if (namespace != null) {
            Map&lt;String, Object&gt; map;
            if (namespace instanceof Map&lt;?, ?&gt;) {
                map = (Map&lt;String, Object&gt;)namespace;
            } else {
                map = new BeanAdapter(namespace);
            }

            defined = map.containsKey(key);
        } else {
            defined = false;
        }

        return defined;
    }

    /**
     * Creates an addition or concatenation expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression add(Expression left, Expression right) {
        return new BinaryExpression(left, right, (leftValue, rightValue) -&gt; {
            Object value;
            if (leftValue instanceof String || rightValue instanceof String) {
                value = leftValue.toString().concat(rightValue.toString());
            } else {
                Number leftNumber = (Number)leftValue;
                Number rightNumber = (Number)rightValue;

                if (leftNumber instanceof Double || rightNumber instanceof Double) {
                    value = leftNumber.doubleValue() + rightNumber.doubleValue();
                } else if (leftNumber instanceof Float || rightNumber instanceof Float) {
                    value = leftNumber.floatValue() + rightNumber.floatValue();
                } else if (leftNumber instanceof Long || rightNumber instanceof Long) {
                    value = leftNumber.longValue() + rightNumber.longValue();
                } else if (leftNumber instanceof Integer || rightNumber instanceof Integer) {
                    value = leftNumber.intValue() + rightNumber.intValue();
                } else if (leftNumber instanceof Short || rightNumber instanceof Short) {
                    value = leftNumber.shortValue() + rightNumber.shortValue();
                } else if (leftNumber instanceof Byte || rightNumber instanceof Byte) {
                    value = leftNumber.byteValue() + rightNumber.byteValue();
                } else {
                    throw new UnsupportedOperationException();
                }
            }

            return value;
        });
    }

    /**
     * Creates an addition or concatenation expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression add(Expression left, Object right) {
        return add(left, new LiteralExpression(right));
    }

    /**
     * Creates an addition or concatenation expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression add(Object left, Expression right) {
        return add(new LiteralExpression(left), right);
    }

    /**
     * Creates an addition or concatenation expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression add(Object left, Object right) {
        return add(new LiteralExpression(left), new LiteralExpression(right));
    }

    /**
     * Creates a subtraction expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression subtract(Expression left, Expression right) {
        return new BinaryExpression&lt;Number, Number&gt;(left, right, (Number leftValue, Number rightValue) -&gt; {
            Number value;
            if (leftValue instanceof Double || rightValue instanceof Double) {
                value = leftValue.doubleValue() - rightValue.doubleValue();
            } else if (leftValue instanceof Float || rightValue instanceof Float) {
                value = leftValue.floatValue() - rightValue.floatValue();
            } else if (leftValue instanceof Long || rightValue instanceof Long) {
                value = leftValue.longValue() - rightValue.longValue();
            } else if (leftValue instanceof Integer || rightValue instanceof Integer) {
                value = leftValue.intValue() - rightValue.intValue();
            } else if (leftValue instanceof Short || rightValue instanceof Short) {
                value = leftValue.shortValue() - rightValue.shortValue();
            } else if (leftValue instanceof Byte || rightValue instanceof Byte) {
                value = leftValue.byteValue() - rightValue.byteValue();
            } else {
                throw new UnsupportedOperationException();
            }

            return value;
        });
    }

    /**
     * Creates a subtraction expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression subtract(Expression left, Number right) {
        return subtract(left, new LiteralExpression(right));
    }

    /**
     * Creates a subtraction expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression subtract(Number left, Expression right) {
        return subtract(new LiteralExpression(left), right);
    }

    /**
     * Creates a subtraction expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression subtract(Number left, Number right) {
        return subtract(new LiteralExpression(left), new LiteralExpression(right));
    }

    /**
     * Creates a multiplication expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression multiply(Expression left, Expression right) {
        return new BinaryExpression&lt;Number, Number&gt;(left, right, (Number leftValue, Number rightValue) -&gt; {

            Number value;
            if (leftValue instanceof Double || rightValue instanceof Double) {
                value = leftValue.doubleValue() * rightValue.doubleValue();
            } else if (leftValue instanceof Float || rightValue instanceof Float) {
                value = leftValue.floatValue() * rightValue.floatValue();
            } else if (leftValue instanceof Long || rightValue instanceof Long) {
                value = leftValue.longValue() * rightValue.longValue();
            } else if (leftValue instanceof Integer || rightValue instanceof Integer) {
                value = leftValue.intValue() * rightValue.intValue();
            } else if (leftValue instanceof Short || rightValue instanceof Short) {
                value = leftValue.shortValue() * rightValue.shortValue();
            } else if (leftValue instanceof Byte || rightValue instanceof Byte) {
                value = leftValue.byteValue() * rightValue.byteValue();
            } else {
                throw new UnsupportedOperationException();
            }

            return value;
        });
    }

    /**
     * Creates a multiplication expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression multiply(Expression left, Number right) {
        return multiply(left, new LiteralExpression(right));
    }

    /**
     * Creates a multiplication expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression multiply(Number left, Expression right) {
        return multiply(new LiteralExpression(left), right);
    }

    /**
     * Creates a multiplication expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression multiply(Number left, Number right) {
        return multiply(new LiteralExpression(left), new LiteralExpression(right));
    }

    /**
     * Creates a division expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression divide(Expression left, Expression right) {
        return new BinaryExpression&lt;Number, Number&gt;(left, right, (Number leftValue, Number rightValue) -&gt; {

            Number value;
            if (leftValue instanceof Double || rightValue instanceof Double) {
                value = leftValue.doubleValue() / rightValue.doubleValue();
            } else if (leftValue instanceof Float || rightValue instanceof Float) {
                value = leftValue.floatValue() / rightValue.floatValue();
            } else if (leftValue instanceof Long || rightValue instanceof Long) {
                value = leftValue.longValue() / rightValue.longValue();
            } else if (leftValue instanceof Integer || rightValue instanceof Integer) {
                value = leftValue.intValue() / rightValue.intValue();
            } else if (leftValue instanceof Short || rightValue instanceof Short) {
                value = leftValue.shortValue() / rightValue.shortValue();
            } else if (leftValue instanceof Byte || rightValue instanceof Byte) {
                value = leftValue.byteValue() / rightValue.byteValue();
            } else {
                throw new UnsupportedOperationException();
            }

            return value;
        });
    }

    /**
     * Creates a division expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression divide(Expression left, Number right) {
        return divide(left, new LiteralExpression(right));
    }

    /**
     * Creates a division expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression divide(Number left, Expression&lt;Number&gt; right) {
        return divide(new LiteralExpression(left), right);
    }

    /**
     * Creates a division expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression divide(Number left, Number right) {
        return divide(new LiteralExpression(left), new LiteralExpression(right));
    }

    /**
     * Creates a modulus expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression modulo(Expression left, Expression right) {
        return new BinaryExpression&lt;Number, Number&gt;(left, right, (Number leftValue, Number rightValue) -&gt; {

                Number value;
                if (leftValue instanceof Double || rightValue instanceof Double) {
                    value = leftValue.doubleValue() % rightValue.doubleValue();
                } else if (leftValue instanceof Float || rightValue instanceof Float) {
                    value = leftValue.floatValue() % rightValue.floatValue();
                } else if (leftValue instanceof Long || rightValue instanceof Long) {
                    value = leftValue.longValue() % rightValue.longValue();
                } else if (leftValue instanceof Integer || rightValue instanceof Integer) {
                    value = leftValue.intValue() % rightValue.intValue();
                } else if (leftValue instanceof Short || rightValue instanceof Short) {
                    value = leftValue.shortValue() % rightValue.shortValue();
                } else if (leftValue instanceof Byte || rightValue instanceof Byte) {
                    value = leftValue.byteValue() % rightValue.byteValue();
                } else {
                    throw new UnsupportedOperationException();
                }

                return value;
            });
    }

    /**
     * Creates a modulus expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression modulo(Expression&lt;Number&gt; left, Number right) {
        return modulo(left, new LiteralExpression(right));
    }

    /**
     * Creates a modulus expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression modulo(Number left, Expression&lt;Number&gt; right) {
        return modulo(new LiteralExpression(left), right);
    }

    /**
     * Creates a modulus expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression modulo(Number left, Number right) {
        return modulo(new LiteralExpression(left), new LiteralExpression(right));
    }

    /**
     * Creates an equality expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression equalTo(Expression left, Expression right) {
        return new BinaryExpression&lt;Comparable, Boolean&gt;(left, right, (Comparable leftValue, Comparable rightValue) -&gt;
                leftValue.compareTo(rightValue) == 0
            );
    }

    /**
     * Creates an equality expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression equalTo(Expression left, Object right) {
        return equalTo(left, new LiteralExpression(right));
    }

    /**
     * Creates an equality expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression equalTo(Object left, Expression right) {
        return equalTo(new LiteralExpression(left), right);
    }

    /**
     * Creates an equality expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression equalTo(Object left, Object right) {
        return equalTo(new LiteralExpression(left), new LiteralExpression(right));
    }

    /**
     * Creates an inverse equality expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression notEqualTo(Expression left, Expression right) {
        return new BinaryExpression&lt;Comparable, Boolean&gt;(left, right, (leftValue, rightValue) -&gt;
                 leftValue.compareTo(rightValue) != 0
        );
    }

    /**
     * Creates an inverse equality expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression notEqualTo(Expression left, Object right) {
        return notEqualTo(left, new LiteralExpression(right));
    }

    /**
     * Creates an inverse equality expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression notEqualTo(Object left, Expression right) {
        return notEqualTo(new LiteralExpression(left), right);
    }

    /**
     * Creates an inverse equality expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression notEqualTo(Object left, Object right) {
        return notEqualTo(new LiteralExpression(left), new LiteralExpression(right));
    }

    /**
     * Creates a &quot;greater-than&quot; comparison expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression greaterThan(Expression left, Expression right) {
        return new BinaryExpression&lt;Comparable, Boolean&gt;(left, right, (leftValue, rightValue) -&gt;
                leftValue.compareTo(rightValue) &gt; 0
        );
    }

    /**
     * Creates a &quot;greater-than&quot; comparison expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression greaterThan(Expression left, Object right) {
        return greaterThan(left, new LiteralExpression(right));
    }

    /**
     * Creates a &quot;greater-than&quot; comparison expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression greaterThan(Object left, Expression right) {
        return greaterThan(new LiteralExpression(left), right);
    }

    /**
     * Creates a &quot;greater-than&quot; comparison expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression greaterThan(Object left, Object right) {
        return greaterThan(new LiteralExpression(left), new LiteralExpression(right));
    }

    /**
     * Creates a &quot;greater-than-or-equal-to&quot; comparison expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression greaterThanOrEqualTo(Expression left, Expression right) {
        return new BinaryExpression&lt;Comparable, Boolean&gt;(left, right, (leftValue, rightValue) -&gt;
                leftValue.compareTo(rightValue) &gt;= 0
        );
    }

    /**
     * Creates a &quot;greater-than-or-equal-to&quot; comparison expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression greaterThanOrEqualTo(Expression left, Object right) {
        return greaterThanOrEqualTo(left, new LiteralExpression(right));
    }

    /**
     * Creates a &quot;greater-than-or-equal-to&quot; comparison expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression greaterThanOrEqualTo(Object left, Expression right) {
        return greaterThanOrEqualTo(new LiteralExpression(left), right);
    }

    /**
     * Creates a &quot;greater-than-or-equal-to&quot; comparison expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression greaterThanOrEqualTo(Object left, Object right) {
        return greaterThanOrEqualTo(new LiteralExpression(left), new LiteralExpression(right));
    }

    /**
     * Creates a &quot;less-than&quot; comparison expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression lessThan(Expression left, Expression right) {
        return new BinaryExpression&lt;Comparable, Boolean&gt;(left, right, (leftValue, rightValue) -&gt;
                leftValue.compareTo(rightValue) &lt; 0
        );
    }

    /**
     * Creates a &quot;less-than&quot; comparison expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression lessThan(Expression left, Object right) {
        return lessThan(left, new LiteralExpression(right));
    }

    /**
     * Creates a &quot;less-than&quot; comparison expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression lessThan(Object left, Expression right) {
        return lessThan(new LiteralExpression(left), right);
    }

    /**
     * Creates a &quot;less-than&quot; comparison expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression lessThan(Object left, Object right) {
        return lessThan(new LiteralExpression(left), new LiteralExpression(right));
    }

    /**
     * Creates a &quot;less-than-or-equal-to&quot; comparison expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression lessThanOrEqualTo(Expression left, Expression right) {
        return new BinaryExpression&lt;Comparable, Boolean&gt;(left, right, (leftValue, rightValue) -&gt;
                leftValue.compareTo(rightValue) &lt;= 0
        );
    }

    /**
     * Creates a &quot;less-than-or-equal-to&quot; comparison expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression lessThanOrEqualTo(Expression left, Object right) {
        return lessThanOrEqualTo(left, new LiteralExpression(right));
    }

    /**
     * Creates a &quot;less-than-or-equal-to&quot; comparison expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression lessThanOrEqualTo(Object left, Expression right) {
        return lessThanOrEqualTo(new LiteralExpression(left), right);
    }

    /**
     * Creates a &quot;less-than-or-equal-to&quot; comparison expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression lessThanOrEqualTo(Object left, Object right) {
        return lessThanOrEqualTo(new LiteralExpression(left), new LiteralExpression(right));
    }

    /**
     * Creates a boolean &quot;and&quot; expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression and(Expression left, Expression right) {
        return new BinaryExpression&lt;Boolean, Boolean&gt;(left, right, (leftValue, rightValue) -&gt;
                leftValue &amp;&amp; rightValue
        );
    }

    /**
     * Creates a boolean &quot;and&quot; expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression and(Expression left, Boolean right) {
        return and(left, new LiteralExpression(right));
    }

    /**
     * Creates a boolean &quot;and&quot; expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression and(Boolean left, Expression right) {
        return and(new LiteralExpression(left), right);
    }

    /**
     * Creates a boolean &quot;and&quot; expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression and(Boolean left, Boolean right) {
        return and(new LiteralExpression(left), new LiteralExpression(right));
    }

    /**
     * Creates a boolean &quot;or&quot; expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression or(Expression left, Expression right) {
        return new BinaryExpression&lt;Boolean, Boolean&gt;(left, right, (leftValue, rightValue) -&gt;
                leftValue || rightValue
        );
    }

    /**
     * Creates a boolean &quot;or&quot; expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression or(Expression left, Boolean right) {
        return or(left, new LiteralExpression(right));
    }

    /**
     * Creates a boolean &quot;or&quot; expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression or(Boolean left, Expression right) {
        return or(new LiteralExpression(left), right);
    }

    /**
     * Creates a boolean &quot;or&quot; expression.
     *
     * @param left
     * @param right
     */
    public static BinaryExpression or(Boolean left, Boolean right) {
        return or(new LiteralExpression(left), new LiteralExpression(right));
    }

    /**
     * Creates a numeric negation expression.
     *
     * @param operand
     */
    public static UnaryExpression negate(Expression operand) {
        return new UnaryExpression&lt;Number, Number&gt;(operand, (value) -&gt; {
                Class&lt;? extends Number&gt; type = value.getClass();

                if (type == Byte.class) {
                    return -value.byteValue();
                } else if (type == Short.class) {
                    return -value.shortValue();
                } else if (type == Integer.class) {
                    return -value.intValue();
                } else if (type == Long.class) {
                    return -value.longValue();
                } else if (type == Float.class) {
                    return -value.floatValue();
                } else if (type == Double.class) {
                    return -value.doubleValue();
                } else {
                    throw new UnsupportedOperationException();
                }

            });
    }

    /**
     * Creates a numeric negation expression.
     *
     * @param operand
     */
    public static UnaryExpression negate(Number operand) {
        return negate(new LiteralExpression(operand));
    }

    /**
     * Creates a boolean &quot;not&quot; expression.
     *
     * @param operand
     */
    public static UnaryExpression not(Expression operand) {
        return new UnaryExpression&lt;Boolean, Boolean&gt;(operand, (value) -&gt; !value);
    }

    /**
     * Creates a boolean &quot;not&quot; expression.
     *
     * @param operand
     */
    public static UnaryExpression not(Boolean operand) {
        return not(new LiteralExpression(operand));
    }

    /**
     * Parses a string representation of an expression into an expression
     * tree.
     *
     * @param value
     * The string representation of the expression.
     */
    public static Expression valueOf(String value) {
        if (value == null) {
            throw new NullPointerException();
        }

        Parser parser = new Parser();
        Expression expression;
        try {
            expression = parser.parse(new StringReader(value));
        } catch (IOException exception) {
            throw new RuntimeException(exception);
        }

        return expression;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.fxml/javafx/fxml/FXMLLoader.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.fxml;

import com.sun.javafx.util.Logging;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.regex.Pattern;

import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.property.Property;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.*;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.util.Builder;
import javafx.util.BuilderFactory;
import javafx.util.Callback;

import javax.script.Bindings;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import javax.script.SimpleBindings;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.util.StreamReaderDelegate;

import com.sun.javafx.beans.IDProperty;
import com.sun.javafx.fxml.BeanAdapter;
import com.sun.javafx.fxml.ParseTraceElement;
import com.sun.javafx.fxml.PropertyNotFoundException;
import com.sun.javafx.fxml.expression.Expression;
import com.sun.javafx.fxml.expression.ExpressionValue;
import com.sun.javafx.fxml.expression.KeyPath;
import static com.sun.javafx.FXPermissions.MODIFY_FXML_CLASS_LOADER_PERMISSION;
import com.sun.javafx.fxml.FXMLLoaderHelper;
import com.sun.javafx.fxml.MethodHelper;
import java.net.MalformedURLException;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.EnumMap;
import java.util.Locale;
import java.util.StringTokenizer;
import com.sun.javafx.reflect.ConstructorUtil;
import com.sun.javafx.reflect.MethodUtil;
import com.sun.javafx.reflect.ReflectUtil;

/**
 * Loads an object hierarchy from an XML document.
 * For more information, see the
 * &lt;a href=&quot;doc-files/introduction_to_fxml.html&quot;&gt;Introduction to FXML&lt;/a&gt;
 * document.
 *
 * @since JavaFX 2.0
 */
public class FXMLLoader {

    // Indicates permission to get the ClassLoader
    private static final RuntimePermission GET_CLASSLOADER_PERMISSION =
        new RuntimePermission(&quot;getClassLoader&quot;);

    // Instance of StackWalker used to get caller class (must be private)
    private static final StackWalker walker =
        AccessController.doPrivileged((PrivilegedAction&lt;StackWalker&gt;) () -&gt;
            StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE));

    // Abstract base class for elements
    private abstract class Element {
        public final Element parent;

        public Object value = null;
        private BeanAdapter valueAdapter = null;

        public final LinkedList&lt;Attribute&gt; eventHandlerAttributes = new LinkedList&lt;Attribute&gt;();
        public final LinkedList&lt;Attribute&gt; instancePropertyAttributes = new LinkedList&lt;Attribute&gt;();
        public final LinkedList&lt;Attribute&gt; staticPropertyAttributes = new LinkedList&lt;Attribute&gt;();
        public final LinkedList&lt;PropertyElement&gt; staticPropertyElements = new LinkedList&lt;PropertyElement&gt;();

        public Element() {
            parent = current;
        }

        public boolean isCollection() {
            // Return true if value is a list, or if the value's type defines
            // a default property that is a list
            boolean collection;
            if (value instanceof List&lt;?&gt;) {
                collection = true;
            } else {
                Class&lt;?&gt; type = value.getClass();
                DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);

                if (defaultProperty != null) {
                    collection = getProperties().get(defaultProperty.value()) instanceof List&lt;?&gt;;
                } else {
                    collection = false;
                }
            }

            return collection;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public void add(Object element) throws LoadException {
            // If value is a list, add element to it; otherwise, get the value
            // of the default property, which is assumed to be a list and add
            // to that (coerce to the appropriate type)
            List&lt;Object&gt; list;
            if (value instanceof List&lt;?&gt;) {
                list = (List&lt;Object&gt;)value;
            } else {
                Class&lt;?&gt; type = value.getClass();
                DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
                String defaultPropertyName = defaultProperty.value();

                // Get the list value
                list = (List&lt;Object&gt;)getProperties().get(defaultPropertyName);

                // Coerce the element to the list item type
                if (!Map.class.isAssignableFrom(type)) {
                    Type listType = getValueAdapter().getGenericType(defaultPropertyName);
                    element = BeanAdapter.coerce(element, BeanAdapter.getListItemType(listType));
                }
            }

            list.add(element);
        }

        public void set(Object value) throws LoadException {
            if (this.value == null) {
                throw constructLoadException(&quot;Cannot set value on this element.&quot;);
            }

            // Apply value to this element's properties
            Class&lt;?&gt; type = this.value.getClass();
            DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
            if (defaultProperty == null) {
                throw constructLoadException(&quot;Element does not define a default property.&quot;);
            }

            getProperties().put(defaultProperty.value(), value);
        }

        public void updateValue(Object value) {
            this.value = value;
            valueAdapter = null;
        }

        public boolean isTyped() {
            return !(value instanceof Map&lt;?, ?&gt;);
        }

        public BeanAdapter getValueAdapter() {
            if (valueAdapter == null) {
                valueAdapter = new BeanAdapter(value);
            }

            return valueAdapter;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public Map&lt;String, Object&gt; getProperties() {
            return (isTyped()) ? getValueAdapter() : (Map&lt;String, Object&gt;)value;
        }

        public void processStartElement() throws IOException {
            for (int i = 0, n = xmlStreamReader.getAttributeCount(); i &lt; n; i++) {
                String prefix = xmlStreamReader.getAttributePrefix(i);
                String localName = xmlStreamReader.getAttributeLocalName(i);
                String value = xmlStreamReader.getAttributeValue(i);

                if (loadListener != null
                    &amp;&amp; prefix != null
                    &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
                    loadListener.readInternalAttribute(prefix + &quot;:&quot; + localName, value);
                }

                processAttribute(prefix, localName, value);
            }
        }

        public void processEndElement() throws IOException {
            // No-op
        }

        public void processCharacters() throws IOException {
            throw constructLoadException(&quot;Unexpected characters in input stream.&quot;);
        }

        public void processInstancePropertyAttributes() throws IOException {
            if (instancePropertyAttributes.size() &gt; 0) {
                for (Attribute attribute : instancePropertyAttributes) {
                    processPropertyAttribute(attribute);
                }
            }
        }

        public void processAttribute(String prefix, String localName, String value)
            throws IOException{
            if (prefix == null) {
                // Add the attribute to the appropriate list
                if (localName.startsWith(EVENT_HANDLER_PREFIX)) {
                    if (loadListener != null) {
                        loadListener.readEventHandlerAttribute(localName, value);
                    }

                    eventHandlerAttributes.add(new Attribute(localName, null, value));
                } else {
                    int i = localName.lastIndexOf('.');

                    if (i == -1) {
                        // The attribute represents an instance property
                        if (loadListener != null) {
                            loadListener.readPropertyAttribute(localName, null, value);
                        }

                        instancePropertyAttributes.add(new Attribute(localName, null, value));
                    } else {
                        // The attribute represents a static property
                        String name = localName.substring(i + 1);
                        Class&lt;?&gt; sourceType = getType(localName.substring(0, i));

                        if (sourceType != null) {
                            if (loadListener != null) {
                                loadListener.readPropertyAttribute(name, sourceType, value);
                            }

                            staticPropertyAttributes.add(new Attribute(name, sourceType, value));
                        } else if (staticLoad) {
                            if (loadListener != null) {
                                loadListener.readUnknownStaticPropertyAttribute(localName, value);
                            }
                        } else {
                            throw constructLoadException(localName + &quot; is not a valid attribute.&quot;);
                        }
                    }

                }
            } else {
                throw constructLoadException(prefix + &quot;:&quot; + localName
                    + &quot; is not a valid attribute.&quot;);
            }
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public void processPropertyAttribute(Attribute attribute) throws IOException {
            String value = attribute.value;
            if (isBindingExpression(value)) {
                // Resolve the expression
                Expression expression;

                if (attribute.sourceType != null) {
                    throw constructLoadException(&quot;Cannot bind to static property.&quot;);
                }

                if (!isTyped()) {
                    throw constructLoadException(&quot;Cannot bind to untyped object.&quot;);
                }

                // TODO We may want to identify binding properties in processAttribute()
                // and apply them after build() has been called
                if (this.value instanceof Builder) {
                    throw constructLoadException(&quot;Cannot bind to builder property.&quot;);
                }

                if (!isStaticLoad()) {
                    value = value.substring(BINDING_EXPRESSION_PREFIX.length(),
                            value.length() - 1);
                    expression = Expression.valueOf(value);

                    // Create the binding
                    BeanAdapter targetAdapter = new BeanAdapter(this.value);
                    ObservableValue&lt;Object&gt; propertyModel = targetAdapter.getPropertyModel(attribute.name);
                    Class&lt;?&gt; type = targetAdapter.getType(attribute.name);

                    if (propertyModel instanceof Property&lt;?&gt;) {
                        ((Property&lt;Object&gt;) propertyModel).bind(new ExpressionValue(namespace, expression, type));
                    }
                }
            } else if (isBidirectionalBindingExpression(value)) {
                throw constructLoadException(new UnsupportedOperationException(&quot;This feature is not currently enabled.&quot;));
            } else {
                processValue(attribute.sourceType, attribute.name, value);
            }
        }

        private boolean isBindingExpression(String aValue) {
            return aValue.startsWith(BINDING_EXPRESSION_PREFIX)
                   &amp;&amp; aValue.endsWith(BINDING_EXPRESSION_SUFFIX);
        }

        private boolean isBidirectionalBindingExpression(String aValue) {
            return aValue.startsWith(BI_DIRECTIONAL_BINDING_PREFIX);
        }

        private boolean processValue(Class sourceType, String propertyName, String aValue)
            throws LoadException {

            boolean processed = false;
                //process list or array first
                if (sourceType == null &amp;&amp; isTyped()) {
                    BeanAdapter valueAdapter = getValueAdapter();
                    Class&lt;?&gt; type = valueAdapter.getType(propertyName);

                    if (type == null) {
                        throw new PropertyNotFoundException(&quot;Property \&quot;&quot; + propertyName
                            + &quot;\&quot; does not exist&quot; + &quot; or is read-only.&quot;);
                    }

                    if (List.class.isAssignableFrom(type)
                        &amp;&amp; valueAdapter.isReadOnly(propertyName)) {
                        populateListFromString(valueAdapter, propertyName, aValue);
                        processed = true;
                    } else if (type.isArray()) {
                        applyProperty(propertyName, sourceType,
                                populateArrayFromString(type, aValue));
                        processed = true;
                    }
                }
                if (!processed) {
                    applyProperty(propertyName, sourceType, resolvePrefixedValue(aValue));
                    processed = true;
                }
                return processed;
        }

        /**
         * Resolves value prefixed with RELATIVE_PATH_PREFIX and RESOURCE_KEY_PREFIX.
         */
        private Object resolvePrefixedValue(String aValue) throws LoadException {
            if (aValue.startsWith(ESCAPE_PREFIX)) {
                aValue = aValue.substring(ESCAPE_PREFIX.length());

                if (aValue.length() == 0
                    || !(aValue.startsWith(ESCAPE_PREFIX)
                        || aValue.startsWith(RELATIVE_PATH_PREFIX)
                        || aValue.startsWith(RESOURCE_KEY_PREFIX)
                        || aValue.startsWith(EXPRESSION_PREFIX)
                        || aValue.startsWith(BI_DIRECTIONAL_BINDING_PREFIX))) {
                    throw constructLoadException(&quot;Invalid escape sequence.&quot;);
                }
                return aValue;
            } else if (aValue.startsWith(RELATIVE_PATH_PREFIX)) {
                aValue = aValue.substring(RELATIVE_PATH_PREFIX.length());
                if (aValue.length() == 0) {
                    throw constructLoadException(&quot;Missing relative path.&quot;);
                }
                if (aValue.startsWith(RELATIVE_PATH_PREFIX)) {
                    // The prefix was escaped
                    warnDeprecatedEscapeSequence(RELATIVE_PATH_PREFIX);
                    return aValue;
                } else {
                        if (aValue.charAt(0) == '/') {
                            // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
                            final URL res = getClassLoader().getResource(aValue.substring(1));
                            if (res == null) {
                                throw constructLoadException(&quot;Invalid resource: &quot; + aValue + &quot; not found on the classpath&quot;);
                            }
                            return res.toString();
                        } else {
                            try {
                                return new URL(FXMLLoader.this.location, aValue).toString();
                            } catch (MalformedURLException e) {
                                System.err.println(FXMLLoader.this.location + &quot;/&quot; + aValue);
                            }
                        }
                }
            } else if (aValue.startsWith(RESOURCE_KEY_PREFIX)) {
                aValue = aValue.substring(RESOURCE_KEY_PREFIX.length());
                if (aValue.length() == 0) {
                    throw constructLoadException(&quot;Missing resource key.&quot;);
                }
                if (aValue.startsWith(RESOURCE_KEY_PREFIX)) {
                    // The prefix was escaped
                    warnDeprecatedEscapeSequence(RESOURCE_KEY_PREFIX);
                    return aValue;
                } else {
                    // Resolve the resource value
                    if (resources == null) {
                        throw constructLoadException(&quot;No resources specified.&quot;);
                    }
                    if (!resources.containsKey(aValue)) {
                        throw constructLoadException(&quot;Resource \&quot;&quot; + aValue + &quot;\&quot; not found.&quot;);
                    }

                    return resources.getString(aValue);
                }
            } else if (aValue.startsWith(EXPRESSION_PREFIX)) {
                aValue = aValue.substring(EXPRESSION_PREFIX.length());
                if (aValue.length() == 0) {
                    throw constructLoadException(&quot;Missing expression.&quot;);
                }
                if (aValue.startsWith(EXPRESSION_PREFIX)) {
                    // The prefix was escaped
                    warnDeprecatedEscapeSequence(EXPRESSION_PREFIX);
                    return aValue;
                } else if (aValue.equals(NULL_KEYWORD)) {
                    // The attribute value is null
                    return null;
                }
                return Expression.get(namespace, KeyPath.parse(aValue));
            }
            return aValue;
        }

        /**
         * Creates an array of given type and populates it with values from
         * a string where tokens are separated by ARRAY_COMPONENT_DELIMITER.
         * If token is prefixed with RELATIVE_PATH_PREFIX a value added to
         * the array becomes relative to document location.
         */
        private Object populateArrayFromString(
                Class&lt;?&gt;type,
                String stringValue) throws LoadException {

            Object propertyValue = null;
            // Split the string and set the values as an array
            Class&lt;?&gt; componentType = type.getComponentType();

            if (stringValue.length() &gt; 0) {
                String[] values = stringValue.split(ARRAY_COMPONENT_DELIMITER);
                propertyValue = Array.newInstance(componentType, values.length);
                for (int i = 0; i &lt; values.length; i++) {
                    Array.set(propertyValue, i,
                            BeanAdapter.coerce(resolvePrefixedValue(values[i].trim()),
                            type.getComponentType()));
                }
            } else {
                propertyValue = Array.newInstance(componentType, 0);
            }
            return propertyValue;
        }

        /**
         * Populates list with values from a string where tokens are separated
         * by ARRAY_COMPONENT_DELIMITER. If token is prefixed with RELATIVE_PATH_PREFIX
         * a value added to the list becomes relative to document location.
         */
        private void populateListFromString(
                BeanAdapter valueAdapter,
                String listPropertyName,
                String stringValue) throws LoadException {
            // Split the string and add the values to the list
            List&lt;Object&gt; list = (List&lt;Object&gt;)valueAdapter.get(listPropertyName);
            Type listType = valueAdapter.getGenericType(listPropertyName);
            Type itemType = (Class&lt;?&gt;)BeanAdapter.getGenericListItemType(listType);

            if (itemType instanceof ParameterizedType) {
                itemType = ((ParameterizedType)itemType).getRawType();
            }

            if (stringValue.length() &gt; 0) {
                String[] values = stringValue.split(ARRAY_COMPONENT_DELIMITER);

                for (String aValue: values) {
                    aValue = aValue.trim();
                    list.add(
                            BeanAdapter.coerce(resolvePrefixedValue(aValue),
                                               (Class&lt;?&gt;)itemType));
                }
            }
        }

        public void warnDeprecatedEscapeSequence(String prefix) {
            System.err.println(prefix + prefix + &quot; is a deprecated escape sequence. &quot;
                + &quot;Please use \\&quot; + prefix + &quot; instead.&quot;);
        }

        public void applyProperty(String name, Class&lt;?&gt; sourceType, Object value) {
            if (sourceType == null) {
                getProperties().put(name, value);
            } else {
                BeanAdapter.put(this.value, sourceType, name, value);
            }
        }

        private Object getExpressionObject(String handlerValue) throws LoadException{
            if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                handlerValue = handlerValue.substring(EXPRESSION_PREFIX.length());

                if (handlerValue.length() == 0) {
                    throw constructLoadException(&quot;Missing expression reference.&quot;);
                }

                Object expression = Expression.get(namespace, KeyPath.parse(handlerValue));
                if (expression == null) {
                    throw constructLoadException(&quot;Unable to resolve expression : $&quot; + handlerValue);
                }
                return expression;
            }
            return null;
        }

        private &lt;T&gt; T getExpressionObjectOfType(String handlerValue, Class&lt;T&gt; type) throws LoadException{
            Object expression = getExpressionObject(handlerValue);
            if (expression != null) {
                if (type.isInstance(expression)) {
                    return (T) expression;
                }
                throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue +&quot;\&quot; expression.&quot;
                        + &quot;Does not point to a &quot; + type.getName());
            }
            return null;
        }

        private MethodHandler getControllerMethodHandle(String handlerName, SupportedType... types) throws LoadException {
            if (handlerName.startsWith(CONTROLLER_METHOD_PREFIX)) {
                handlerName = handlerName.substring(CONTROLLER_METHOD_PREFIX.length());

                if (!handlerName.startsWith(CONTROLLER_METHOD_PREFIX)) {
                    if (handlerName.length() == 0) {
                        throw constructLoadException(&quot;Missing controller method.&quot;);
                    }

                    if (controller == null) {
                        throw constructLoadException(&quot;No controller specified.&quot;);
                    }

                    for (SupportedType t : types) {
                        Method method = controllerAccessor
                                            .getControllerMethods()
                                            .get(t)
                                            .get(handlerName);
                        if (method != null) {
                            return new MethodHandler(controller, method, t);
                        }
                    }
                    Method method = controllerAccessor
                                        .getControllerMethods()
                                        .get(SupportedType.PARAMETERLESS)
                                        .get(handlerName);
                    if (method != null) {
                        return new MethodHandler(controller, method, SupportedType.PARAMETERLESS);
                    }

                    return null;

                }

            }
            return null;
        }

        public void processEventHandlerAttributes() throws LoadException {
            if (eventHandlerAttributes.size() &gt; 0 &amp;&amp; !staticLoad) {
                for (Attribute attribute : eventHandlerAttributes) {
                    String handlerName = attribute.value;
                    if (value instanceof ObservableList &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
                        processObservableListHandler(handlerName);
                    } else if (value instanceof ObservableMap &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
                        processObservableMapHandler(handlerName);
                    } else if (value instanceof ObservableSet &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
                        processObservableSetHandler(handlerName);
                    } else if (attribute.name.endsWith(CHANGE_EVENT_HANDLER_SUFFIX)) {
                        processPropertyHandler(attribute.name, handlerName);
                    } else {
                        EventHandler&lt;? extends Event&gt; eventHandler = null;
                        MethodHandler handler = getControllerMethodHandle(handlerName, SupportedType.EVENT);
                        if (handler != null) {
                            eventHandler = new ControllerMethodEventHandler&lt;&gt;(handler);
                        }

                        if (eventHandler == null) {
                            eventHandler = getExpressionObjectOfType(handlerName, EventHandler.class);
                        }

                        if (eventHandler == null) {
                            if (handlerName.length() == 0 || scriptEngine == null) {
                                throw constructLoadException(&quot;Error resolving &quot; + attribute.name + &quot;='&quot; + attribute.value
                                        + &quot;', either the event handler is not in the Namespace or there is an error in the script.&quot;);
                            }

                            eventHandler = new ScriptEventHandler(handlerName, scriptEngine);
                        }

                        // Add the handler
                        getValueAdapter().put(attribute.name, eventHandler);
                    }
                }
            }
        }

        private void processObservableListHandler(String handlerValue) throws LoadException {
            ObservableList list = (ObservableList)value;
            if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.LIST_CHANGE_LISTENER);
                if (handler != null) {
                    list.addListener(new ObservableListChangeAdapter(handler));
                } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                }
            } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                Object listener = getExpressionObject(handlerValue);
                   if (listener instanceof ListChangeListener) {
                    list.addListener((ListChangeListener) listener);
                } else if (listener instanceof InvalidationListener) {
                    list.addListener((InvalidationListener) listener);
                } else {
                    throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                            + &quot;Must be either ListChangeListener or InvalidationListener&quot;);
                }
            }
        }

        private void processObservableMapHandler(String handlerValue) throws LoadException {
            ObservableMap map = (ObservableMap)value;
            if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.MAP_CHANGE_LISTENER);
                if (handler != null) {
                    map.addListener(new ObservableMapChangeAdapter(handler));
                } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                }
            } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                Object listener = getExpressionObject(handlerValue);
                if (listener instanceof MapChangeListener) {
                    map.addListener((MapChangeListener) listener);
                } else if (listener instanceof InvalidationListener) {
                    map.addListener((InvalidationListener) listener);
                } else {
                    throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                            + &quot;Must be either MapChangeListener or InvalidationListener&quot;);
                }
            }
        }

        private void processObservableSetHandler(String handlerValue) throws LoadException {
            ObservableSet set = (ObservableSet)value;
            if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.SET_CHANGE_LISTENER);
                if (handler != null) {
                    set.addListener(new ObservableSetChangeAdapter(handler));
                } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                }
            } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                Object listener = getExpressionObject(handlerValue);
                if (listener instanceof SetChangeListener) {
                    set.addListener((SetChangeListener) listener);
                } else if (listener instanceof InvalidationListener) {
                    set.addListener((InvalidationListener) listener);
                } else {
                    throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                            + &quot;Must be either SetChangeListener or InvalidationListener&quot;);
                }
            }
        }

        private void processPropertyHandler(String attributeName, String handlerValue) throws LoadException {
            int i = EVENT_HANDLER_PREFIX.length();
            int j = attributeName.length() - CHANGE_EVENT_HANDLER_SUFFIX.length();

            if (i != j) {
                String key = Character.toLowerCase(attributeName.charAt(i))
                        + attributeName.substring(i + 1, j);

                ObservableValue&lt;Object&gt; propertyModel = getValueAdapter().getPropertyModel(key);
                if (propertyModel == null) {
                    throw constructLoadException(value.getClass().getName() + &quot; does not define&quot;
                            + &quot; a property model for \&quot;&quot; + key + &quot;\&quot;.&quot;);
                }

                if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                    final MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.PROPERTY_CHANGE_LISTENER, SupportedType.EVENT);
                    if (handler != null) {
                        if (handler.type == SupportedType.EVENT) {
                            // Note: this part is solely for purpose of 2.2 backward compatibility where an Event object
                            // has been used instead of usual property change parameters
                            propertyModel.addListener(new ChangeListener&lt;Object&gt;() {
                                @Override
                                public void changed(ObservableValue&lt;?&gt; observable, Object oldValue, Object newValue) {
                                    handler.invoke(new Event(value, null, Event.ANY));
                                }
                            });
                        } else {
                            propertyModel.addListener(new PropertyChangeAdapter(handler));
                        }
                    } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                    }
                } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                    Object listener = getExpressionObject(handlerValue);
                    if (listener instanceof ChangeListener) {
                        propertyModel.addListener((ChangeListener) listener);
                    } else if (listener instanceof InvalidationListener) {
                        propertyModel.addListener((InvalidationListener) listener);
                    } else {
                        throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                                + &quot;Must be either ChangeListener or InvalidationListener&quot;);
                    }
                }

            }
        }
    }

    // Element representing a value
    private abstract class ValueElement extends Element {
        public String fx_id = null;

        @Override
        public void processStartElement() throws IOException {
            super.processStartElement();

            updateValue(constructValue());

            if (value instanceof Builder&lt;?&gt;) {
                processInstancePropertyAttributes();
            } else {
                processValue();
            }
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void processEndElement() throws IOException {
            super.processEndElement();

            // Build the value, if necessary
            if (value instanceof Builder&lt;?&gt;) {
                Builder&lt;Object&gt; builder = (Builder&lt;Object&gt;)value;
                updateValue(builder.build());

                processValue();
            } else {
                processInstancePropertyAttributes();
            }

            processEventHandlerAttributes();

            // Process static property attributes
            if (staticPropertyAttributes.size() &gt; 0) {
                for (Attribute attribute : staticPropertyAttributes) {
                    processPropertyAttribute(attribute);
                }
            }

            // Process static property elements
            if (staticPropertyElements.size() &gt; 0) {
                for (PropertyElement element : staticPropertyElements) {
                    BeanAdapter.put(value, element.sourceType, element.name, element.value);
                }
            }

            if (parent != null) {
                if (parent.isCollection()) {
                    parent.add(value);
                } else {
                    parent.set(value);
                }
            }
        }

        private Object getListValue(Element parent, String listPropertyName, Object value) {
            // If possible, coerce the value to the list item type
            if (parent.isTyped()) {
                Type listType = parent.getValueAdapter().getGenericType(listPropertyName);

                if (listType != null) {
                    Type itemType = BeanAdapter.getGenericListItemType(listType);

                    if (itemType instanceof ParameterizedType) {
                        itemType = ((ParameterizedType)itemType).getRawType();
                    }

                    value = BeanAdapter.coerce(value, (Class&lt;?&gt;)itemType);
                }
            }

            return value;
        }

        private void processValue() throws LoadException {
            // If this is the root element, update the value
            if (parent == null) {
                root = value;

                // checking version of fx namespace - throw exception if not supported
                String fxNSURI = xmlStreamReader.getNamespaceContext().getNamespaceURI(&quot;fx&quot;);
                if (fxNSURI != null) {
                    String fxVersion = fxNSURI.substring(fxNSURI.lastIndexOf(&quot;/&quot;) + 1);
                    if (compareJFXVersions(FX_NAMESPACE_VERSION, fxVersion) &lt; 0) {
                        throw constructLoadException(&quot;Loading FXML document of version &quot; +
                                fxVersion + &quot; by JavaFX runtime supporting version &quot; + FX_NAMESPACE_VERSION);
                    }
                }

                // checking the version JavaFX API - print warning if not supported
                String defaultNSURI = xmlStreamReader.getNamespaceContext().getNamespaceURI(&quot;&quot;);
                if (defaultNSURI != null) {
                    String nsVersion = defaultNSURI.substring(defaultNSURI.lastIndexOf(&quot;/&quot;) + 1);
                    if (compareJFXVersions(JAVAFX_VERSION, nsVersion) &lt; 0) {
                        Logging.getJavaFXLogger().warning(&quot;Loading FXML document with JavaFX API of version &quot; +
                                nsVersion + &quot; by JavaFX runtime of version &quot; + JAVAFX_VERSION);
                    }
                }
            }

            // Add the value to the namespace
            if (fx_id != null) {
                namespace.put(fx_id, value);

                // If the value defines an ID property, set it
                IDProperty idProperty = value.getClass().getAnnotation(IDProperty.class);

                if (idProperty != null) {
                    Map&lt;String, Object&gt; properties = getProperties();
                    // set fx:id property value to Node.id only if Node.id was not
                    // already set when processing start element attributes
                    if (properties.get(idProperty.value()) == null) {
                        properties.put(idProperty.value(), fx_id);
                    }
                }

                // Set the controller field value
                injectFields(fx_id, value);
            }
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void processCharacters() throws LoadException {
            Class&lt;?&gt; type = value.getClass();
            DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);

            // If the default property is a read-only list, add the value to it;
            // otherwise, set the value as the default property
            if (defaultProperty != null) {
                String text = xmlStreamReader.getText();
                text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;);

                String defaultPropertyName = defaultProperty.value();
                BeanAdapter valueAdapter = getValueAdapter();

                if (valueAdapter.isReadOnly(defaultPropertyName)
                    &amp;&amp; List.class.isAssignableFrom(valueAdapter.getType(defaultPropertyName))) {
                    List&lt;Object&gt; list = (List&lt;Object&gt;)valueAdapter.get(defaultPropertyName);
                    list.add(getListValue(this, defaultPropertyName, text));
                } else {
                    valueAdapter.put(defaultPropertyName, text.trim());
                }
            } else {
                throw constructLoadException(type.getName() + &quot; does not have a default property.&quot;);
            }
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException{
            if (prefix != null
                &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
                if (localName.equals(FX_ID_ATTRIBUTE)) {
                    // Verify that ID is a valid identifier
                    if (value.equals(NULL_KEYWORD)) {
                        throw constructLoadException(&quot;Invalid identifier.&quot;);
                    }

                    for (int i = 0, n = value.length(); i &lt; n; i++) {
                        if (!Character.isJavaIdentifierPart(value.charAt(i))) {
                            throw constructLoadException(&quot;Invalid identifier.&quot;);
                        }
                    }

                    fx_id = value;

                } else if (localName.equals(FX_CONTROLLER_ATTRIBUTE)) {
                    if (current.parent != null) {
                        throw constructLoadException(FX_NAMESPACE_PREFIX + &quot;:&quot; + FX_CONTROLLER_ATTRIBUTE
                            + &quot; can only be applied to root element.&quot;);
                    }

                    if (controller != null) {
                        throw constructLoadException(&quot;Controller value already specified.&quot;);
                    }

                    if (!staticLoad) {
                        Class&lt;?&gt; type;
                        try {
                            type = getClassLoader().loadClass(value);
                        } catch (ClassNotFoundException exception) {
                            throw constructLoadException(exception);
                        }

                        try {
                            if (controllerFactory == null) {
                                ReflectUtil.checkPackageAccess(type);
                                setController(type.newInstance());
                            } else {
                                setController(controllerFactory.call(type));
                            }
                        } catch (InstantiationException exception) {
                            throw constructLoadException(exception);
                        } catch (IllegalAccessException exception) {
                            throw constructLoadException(exception);
                        }
                    }
                } else {
                    throw constructLoadException(&quot;Invalid attribute.&quot;);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        public abstract Object constructValue() throws IOException;
    }

    // Element representing a class instance
    private class InstanceDeclarationElement extends ValueElement {
        public Class&lt;?&gt; type;

        public String constant = null;
        public String factory = null;

        public InstanceDeclarationElement(Class&lt;?&gt; type) throws LoadException {
            this.type = type;
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix != null
                &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
                if (localName.equals(FX_VALUE_ATTRIBUTE)) {
                    this.value = value;
                } else if (localName.equals(FX_CONSTANT_ATTRIBUTE)) {
                    constant = value;
                } else if (localName.equals(FX_FACTORY_ATTRIBUTE)) {
                    factory = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws IOException {
            Object value;
            if (this.value != null) {
                value = BeanAdapter.coerce(this.value, type);
            } else if (constant != null) {
                value = BeanAdapter.getConstantValue(type, constant);
            } else if (factory != null) {
                Method factoryMethod;
                try {
                    factoryMethod = MethodUtil.getMethod(type, factory, new Class[] {});
                } catch (NoSuchMethodException exception) {
                    throw constructLoadException(exception);
                }

                try {
                    value = MethodHelper.invoke(factoryMethod, null, new Object [] {});
                } catch (IllegalAccessException exception) {
                    throw constructLoadException(exception);
                } catch (InvocationTargetException exception) {
                    throw constructLoadException(exception);
                }
            } else {
                value = (builderFactory == null) ? null : builderFactory.getBuilder(type);

                if (value == null) {
                    value = DEFAULT_BUILDER_FACTORY.getBuilder(type);
                }

                if (value == null) {
                    try {
                        ReflectUtil.checkPackageAccess(type);
                        value = type.newInstance();
                    } catch (InstantiationException exception) {
                        throw constructLoadException(exception);
                    } catch (IllegalAccessException exception) {
                        throw constructLoadException(exception);
                    }
                }
            }

            return value;
        }
    }

    // Element representing an unknown type
    private class UnknownTypeElement extends ValueElement {
        // Map type representing an unknown value
        @DefaultProperty(&quot;items&quot;)
        public class UnknownValueMap extends AbstractMap&lt;String, Object&gt; {
            private ArrayList&lt;?&gt; items = new ArrayList&lt;Object&gt;();
            private HashMap&lt;String, Object&gt; values = new HashMap&lt;String, Object&gt;();

            @Override
            public Object get(Object key) {
                if (key == null) {
                    throw new NullPointerException();
                }

                return (key.equals(getClass().getAnnotation(DefaultProperty.class).value())) ?
                    items : values.get(key);
            }

            @Override
            public Object put(String key, Object value) {
                if (key == null) {
                    throw new NullPointerException();
                }

                if (key.equals(getClass().getAnnotation(DefaultProperty.class).value())) {
                    throw new IllegalArgumentException();
                }

                return values.put(key, value);
            }

            @Override
            public Set&lt;Entry&lt;String, Object&gt;&gt; entrySet() {
                return Collections.emptySet();
            }
        }

        @Override
        public void processEndElement() throws IOException {
            // No-op
        }

        @Override
        public Object constructValue() throws LoadException {
            return new UnknownValueMap();
        }
    }

    // Element representing an include
    private class IncludeElement extends ValueElement {
        public String source = null;
        public ResourceBundle resources = FXMLLoader.this.resources;
        public Charset charset = FXMLLoader.this.charset;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(INCLUDE_SOURCE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    source = value;
                } else if (localName.equals(INCLUDE_RESOURCES_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    resources = ResourceBundle.getBundle(value, Locale.getDefault(),
                            FXMLLoader.this.resources.getClass().getClassLoader());
                } else if (localName.equals(INCLUDE_CHARSET_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    charset = Charset.forName(value);
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws IOException {
            if (source == null) {
                throw constructLoadException(INCLUDE_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
            }

            URL location;
            final ClassLoader cl = getClassLoader();
            if (source.charAt(0) == '/') {
            // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
                location = cl.getResource(source.substring(1));
                if (location == null) {
                    throw constructLoadException(&quot;Cannot resolve path: &quot; + source);
                }
            } else {
                if (FXMLLoader.this.location == null) {
                    throw constructLoadException(&quot;Base location is undefined.&quot;);
                }

                location = new URL(FXMLLoader.this.location, source);
            }

            FXMLLoader fxmlLoader = new FXMLLoader(location, resources,
                builderFactory, controllerFactory, charset,
                loaders);
            fxmlLoader.parentLoader = FXMLLoader.this;

            if (isCyclic(FXMLLoader.this, fxmlLoader)) {
                throw new IOException(
                        String.format(
                        &quot;Including \&quot;%s\&quot; in \&quot;%s\&quot; created cyclic reference.&quot;,
                        fxmlLoader.location.toExternalForm(),
                        FXMLLoader.this.location.toExternalForm()));
            }
            fxmlLoader.setClassLoader(cl);
            fxmlLoader.setStaticLoad(staticLoad);

            Object value = fxmlLoader.loadImpl(callerClass);

            if (fx_id != null) {
                String id = this.fx_id + CONTROLLER_SUFFIX;
                Object controller = fxmlLoader.getController();

                namespace.put(id, controller);
                injectFields(id, controller);
            }

            return value;
        }
    }

    private void injectFields(String fieldName, Object value) throws LoadException {
        if (controller != null &amp;&amp; fieldName != null) {
            List&lt;Field&gt; fields = controllerAccessor.getControllerFields().get(fieldName);
            if (fields != null) {
                try {
                    for (Field f : fields) {
                        f.set(controller, value);
                    }
                } catch (IllegalAccessException exception) {
                    throw constructLoadException(exception);
                }
            }
        }
    }

    // Element representing a reference
    private class ReferenceElement extends ValueElement {
        public String source = null;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(REFERENCE_SOURCE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    source = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws LoadException {
            if (source == null) {
                throw constructLoadException(REFERENCE_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
            }

            KeyPath path = KeyPath.parse(source);
            if (!Expression.isDefined(namespace, path)) {
                throw constructLoadException(&quot;Value \&quot;&quot; + source + &quot;\&quot; does not exist.&quot;);
            }

            return Expression.get(namespace, path);
        }
    }

    // Element representing a copy
    private class CopyElement extends ValueElement {
        public String source = null;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(COPY_SOURCE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    source = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws LoadException {
            if (source == null) {
                throw constructLoadException(COPY_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
            }

            KeyPath path = KeyPath.parse(source);
            if (!Expression.isDefined(namespace, path)) {
                throw constructLoadException(&quot;Value \&quot;&quot; + source + &quot;\&quot; does not exist.&quot;);
            }

            Object sourceValue = Expression.get(namespace, path);
            Class&lt;?&gt; sourceValueType = sourceValue.getClass();

            Constructor&lt;?&gt; constructor = null;
            try {
                constructor = ConstructorUtil.getConstructor(sourceValueType, new Class[] { sourceValueType });
            } catch (NoSuchMethodException exception) {
                // No-op
            }

            Object value;
            if (constructor != null) {
                try {
                    ReflectUtil.checkPackageAccess(sourceValueType);
                    value = constructor.newInstance(sourceValue);
                } catch (InstantiationException exception) {
                    throw constructLoadException(exception);
                } catch (IllegalAccessException exception) {
                    throw constructLoadException(exception);
                } catch (InvocationTargetException exception) {
                    throw constructLoadException(exception);
                }
            } else {
                throw constructLoadException(&quot;Can't copy value &quot; + sourceValue + &quot;.&quot;);
            }

            return value;
        }
    }

    // Element representing a predefined root value
    private class RootElement extends ValueElement {
        public String type = null;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(ROOT_TYPE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    type = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws LoadException {
            if (type == null) {
                throw constructLoadException(ROOT_TYPE_ATTRIBUTE + &quot; is required.&quot;);
            }

            Class&lt;?&gt; type = getType(this.type);

            if (type == null) {
                throw constructLoadException(this.type + &quot; is not a valid type.&quot;);
            }

            Object value;
            if (root == null) {
                if (staticLoad) {
                    value = (builderFactory == null) ? null : builderFactory.getBuilder(type);

                    if (value == null) {
                        value = DEFAULT_BUILDER_FACTORY.getBuilder(type);
                    }

                    if (value == null) {
                        try {
                            ReflectUtil.checkPackageAccess(type);
                            value = type.newInstance();
                        } catch (InstantiationException exception) {
                            throw constructLoadException(exception);
                        } catch (IllegalAccessException exception) {
                            throw constructLoadException(exception);
                        }
                    }
                    root = value;
                } else {
                    throw constructLoadException(&quot;Root hasn't been set. Use method setRoot() before load.&quot;);
                }
            } else {
                if (!type.isAssignableFrom(root.getClass())) {
                    throw constructLoadException(&quot;Root is not an instance of &quot;
                        + type.getName() + &quot;.&quot;);
                }

                value = root;
            }

            return value;
        }
    }

    // Element representing a property
    private class PropertyElement extends Element {
        public final String name;
        public final Class&lt;?&gt; sourceType;
        public final boolean readOnly;

        public PropertyElement(String name, Class&lt;?&gt; sourceType) throws LoadException {
            if (parent == null) {
                throw constructLoadException(&quot;Invalid root element.&quot;);
            }

            if (parent.value == null) {
                throw constructLoadException(&quot;Parent element does not support property elements.&quot;);
            }

            this.name = name;
            this.sourceType = sourceType;

            if (sourceType == null) {
                // The element represents an instance property
                if (name.startsWith(EVENT_HANDLER_PREFIX)) {
                    throw constructLoadException(&quot;\&quot;&quot; + name + &quot;\&quot; is not a valid element name.&quot;);
                }

                Map&lt;String, Object&gt; parentProperties = parent.getProperties();

                if (parent.isTyped()) {
                    readOnly = parent.getValueAdapter().isReadOnly(name);
                } else {
                // If the map already defines a value for the property, assume
                    // that it is read-only
                    readOnly = parentProperties.containsKey(name);
                }

                if (readOnly) {
                    Object value = parentProperties.get(name);
                    if (value == null) {
                        throw constructLoadException(&quot;Invalid property.&quot;);
                    }

                    updateValue(value);
                }
            } else {
                // The element represents a static property
                readOnly = false;
            }
        }

        @Override
        public boolean isCollection() {
            return (readOnly) ? super.isCollection() : false;
        }

        @Override
        public void add(Object element) throws LoadException {
            // Coerce the element to the list item type
            if (parent.isTyped()) {
                Type listType = parent.getValueAdapter().getGenericType(name);
                element = BeanAdapter.coerce(element, BeanAdapter.getListItemType(listType));
            }

            // Add the item to the list
            super.add(element);
        }

        @Override
        public void set(Object value) throws LoadException {
            // Update the value
            updateValue(value);

            if (sourceType == null) {
                // Apply value to parent element's properties
                parent.getProperties().put(name, value);
            } else {
                if (parent.value instanceof Builder) {
                    // Defer evaluation of the property
                    parent.staticPropertyElements.add(this);
                } else {
                    // Apply the static property value
                    BeanAdapter.put(parent.value, sourceType, name, value);
                }
            }
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (!readOnly) {
                throw constructLoadException(&quot;Attributes are not supported for writable property elements.&quot;);
            }

            super.processAttribute(prefix, localName, value);
        }

        @Override
        public void processEndElement() throws IOException {
            super.processEndElement();

            if (readOnly) {
                processInstancePropertyAttributes();
                processEventHandlerAttributes();
            }
        }

        @Override
        public void processCharacters() throws IOException {
            String text = xmlStreamReader.getText();
            text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;).trim();

            if (readOnly) {
                if (isCollection()) {
                    add(text);
                } else {
                    super.processCharacters();
                }
            } else {
                set(text);
            }
        }
    }

    // Element representing an unknown static property
    private class UnknownStaticPropertyElement extends Element {
        public UnknownStaticPropertyElement() throws LoadException {
            if (parent == null) {
                throw constructLoadException(&quot;Invalid root element.&quot;);
            }

            if (parent.value == null) {
                throw constructLoadException(&quot;Parent element does not support property elements.&quot;);
            }
        }

        @Override
        public boolean isCollection() {
            return false;
        }

        @Override
        public void set(Object value) {
            updateValue(value);
        }

        @Override
        public void processCharacters() throws IOException {
            String text = xmlStreamReader.getText();
            text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;);

            updateValue(text.trim());
        }
    }

    // Element representing a script block
    private class ScriptElement extends Element {
        public String source = null;
        public Charset charset = FXMLLoader.this.charset;

        @Override
        public boolean isCollection() {
            return false;
        }

        @Override
        public void processStartElement() throws IOException {
            super.processStartElement();

            if (source != null &amp;&amp; !staticLoad) {
                int i = source.lastIndexOf(&quot;.&quot;);
                if (i == -1) {
                    throw constructLoadException(&quot;Cannot determine type of script \&quot;&quot;
                        + source + &quot;\&quot;.&quot;);
                }

                String extension = source.substring(i + 1);
                ScriptEngine engine;
                final ClassLoader cl = getClassLoader();
                if (scriptEngine != null &amp;&amp; scriptEngine.getFactory().getExtensions().contains(extension)) {
                    // If we have a page language and it's engine supports the extension, use the same engine
                    engine = scriptEngine;
                } else {
                    ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();
                    try {
                        Thread.currentThread().setContextClassLoader(cl);
                        ScriptEngineManager scriptEngineManager = getScriptEngineManager();
                        engine = scriptEngineManager.getEngineByExtension(extension);
                    } finally {
                        Thread.currentThread().setContextClassLoader(oldLoader);
                    }
                }

                if (engine == null) {
                    throw constructLoadException(&quot;Unable to locate scripting engine for&quot;
                        + &quot; extension &quot; + extension + &quot;.&quot;);
                }

                try {
                    URL location;
                    if (source.charAt(0) == '/') {
                        // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
                        location = cl.getResource(source.substring(1));
                    } else {
                        if (FXMLLoader.this.location == null) {
                            throw constructLoadException(&quot;Base location is undefined.&quot;);
                        }

                        location = new URL(FXMLLoader.this.location, source);
                    }

                    InputStreamReader scriptReader = null;
                    try {
                        scriptReader = new InputStreamReader(location.openStream(), charset);
                        engine.eval(scriptReader);
                    } catch(ScriptException exception) {
                        exception.printStackTrace();
                    } finally {
                        if (scriptReader != null) {
                            scriptReader.close();
                        }
                    }
                } catch (IOException exception) {
                    throw constructLoadException(exception);
                }
            }
        }

        @Override
        public void processEndElement() throws IOException {
            super.processEndElement();

            if (value != null &amp;&amp; !staticLoad) {
                // Evaluate the script
                try {
                    scriptEngine.eval((String)value);
                } catch (ScriptException exception) {
                    System.err.println(exception.getMessage());
                }
            }
        }

        @Override
        public void processCharacters() throws LoadException {
            if (source != null) {
                throw constructLoadException(&quot;Script source already specified.&quot;);
            }

            if (scriptEngine == null &amp;&amp; !staticLoad) {
                throw constructLoadException(&quot;Page language not specified.&quot;);
            }

            updateValue(xmlStreamReader.getText());
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null
                &amp;&amp; localName.equals(SCRIPT_SOURCE_ATTRIBUTE)) {
                if (loadListener != null) {
                    loadListener.readInternalAttribute(localName, value);
                }

                source = value;
            } else if (localName.equals(SCRIPT_CHARSET_ATTRIBUTE)) {
                if (loadListener != null) {
                    loadListener.readInternalAttribute(localName, value);
                }

                charset = Charset.forName(value);
            } else {
                throw constructLoadException(prefix == null ? localName : prefix + &quot;:&quot; + localName
                    + &quot; is not a valid attribute.&quot;);
            }
        }
    }

    // Element representing a define block
    private class DefineElement extends Element {
        @Override
        public boolean isCollection() {
            return true;
        }

        @Override
        public void add(Object element) {
            // No-op
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws LoadException{
            throw constructLoadException(&quot;Element does not support attributes.&quot;);
        }
    }

    // Class representing an attribute of an element
    private static class Attribute {
        public final String name;
        public final Class&lt;?&gt; sourceType;
        public final String value;

        public Attribute(String name, Class&lt;?&gt; sourceType, String value) {
            this.name = name;
            this.sourceType = sourceType;
            this.value = value;
        }
    }

    // Event handler that delegates to a method defined by the controller object
    private static class ControllerMethodEventHandler&lt;T extends Event&gt; implements EventHandler&lt;T&gt; {
        private final MethodHandler handler;

        public ControllerMethodEventHandler(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void handle(T event) {
            handler.invoke(event);
        }
    }

    // Event handler implemented in script code
    private static class ScriptEventHandler implements EventHandler&lt;Event&gt; {
        public final String script;
        public final ScriptEngine scriptEngine;

        public ScriptEventHandler(String script, ScriptEngine scriptEngine) {
            this.script = script;
            this.scriptEngine = scriptEngine;
        }

        @Override
        public void handle(Event event) {
            // Don't pollute the page namespace with values defined in the script
            Bindings engineBindings = scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);
            Bindings localBindings = scriptEngine.createBindings();
            localBindings.put(EVENT_KEY, event);
            localBindings.putAll(engineBindings);
            scriptEngine.setBindings(localBindings, ScriptContext.ENGINE_SCOPE);

            // Execute the script
            try {
                scriptEngine.eval(script);
            } catch (ScriptException exception){
                throw new RuntimeException(exception);
            }

            // Restore the original bindings
            scriptEngine.setBindings(engineBindings, ScriptContext.ENGINE_SCOPE);
        }
    }

    // Observable list change listener
    private static class ObservableListChangeAdapter implements ListChangeListener {
        private final MethodHandler handler;

        public ObservableListChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void onChanged(Change change) {
            if (handler != null) {
                handler.invoke(change);
            }
        }
    }

    // Observable map change listener
    private static class ObservableMapChangeAdapter implements MapChangeListener {
        public final MethodHandler handler;

        public ObservableMapChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void onChanged(Change change) {
            if (handler != null) {
                handler.invoke(change);
            }
        }
    }

    // Observable set change listener
    private static class ObservableSetChangeAdapter implements SetChangeListener {
        public final MethodHandler handler;

        public ObservableSetChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void onChanged(Change change) {
            if (handler != null) {
                handler.invoke(change);
            }
        }
    }

    // Property model change listener
    private static class PropertyChangeAdapter implements ChangeListener&lt;Object&gt; {
        public final MethodHandler handler;

        public PropertyChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void changed(ObservableValue&lt;? extends Object&gt; observable, Object oldValue, Object newValue) {
            handler.invoke(observable, oldValue, newValue);
        }
    }

    private static class MethodHandler {
        private final Object controller;
        private final Method method;
        private final SupportedType type;

        private MethodHandler(Object controller, Method method, SupportedType type) {
            this.method = method;
            this.controller = controller;
            this.type = type;
        }

        public void invoke(Object... params) {
            try {
                if (type != SupportedType.PARAMETERLESS) {
                    MethodHelper.invoke(method, controller, params);
                } else {
                    MethodHelper.invoke(method, controller, new Object[] {});
                }
            } catch (InvocationTargetException exception) {
                throw new RuntimeException(exception);
            } catch (IllegalAccessException exception) {
                throw new RuntimeException(exception);
            }
        }
    }

    private URL location;
    private ResourceBundle resources;

    private ObservableMap&lt;String, Object&gt; namespace = FXCollections.observableHashMap();

    private Object root = null;
    private Object controller = null;

    private BuilderFactory builderFactory;
    private Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory;
    private Charset charset;

    private final LinkedList&lt;FXMLLoader&gt; loaders;

    private ClassLoader classLoader = null;
    private boolean staticLoad = false;
    private LoadListener loadListener = null;

    private FXMLLoader parentLoader;

    private XMLStreamReader xmlStreamReader = null;
    private Element current = null;

    private ScriptEngine scriptEngine = null;

    private List&lt;String&gt; packages = new LinkedList&lt;String&gt;();
    private Map&lt;String, Class&lt;?&gt;&gt; classes = new HashMap&lt;String, Class&lt;?&gt;&gt;();

    private ScriptEngineManager scriptEngineManager = null;

    private static ClassLoader defaultClassLoader = null;

    private static final Pattern extraneousWhitespacePattern = Pattern.compile(&quot;\\s+&quot;);

    private static BuilderFactory DEFAULT_BUILDER_FACTORY = new JavaFXBuilderFactory();

    /**
     * The character set used when character set is not explicitly specified.
     */
    public static final String DEFAULT_CHARSET_NAME = &quot;UTF-8&quot;;

    /**
     * The tag name of language processing instruction.
     */
    public static final String LANGUAGE_PROCESSING_INSTRUCTION = &quot;language&quot;;
    /**
     * The tag name of import processing instruction.
     */
    public static final String IMPORT_PROCESSING_INSTRUCTION = &quot;import&quot;;

    /**
     * Prefix of 'fx' namespace.
     */
    public static final String FX_NAMESPACE_PREFIX = &quot;fx&quot;;
    /**
     * The name of fx:controller attribute of a root.
     */
    public static final String FX_CONTROLLER_ATTRIBUTE = &quot;controller&quot;;
    /**
     * The name of fx:id attribute.
     */
    public static final String FX_ID_ATTRIBUTE = &quot;id&quot;;
    /**
     * The name of fx:value attribute.
     */
    public static final String FX_VALUE_ATTRIBUTE = &quot;value&quot;;
    /**
     * The tag name of 'fx:constant'.
     * @since JavaFX 2.2
     */
    public static final String FX_CONSTANT_ATTRIBUTE = &quot;constant&quot;;
    /**
     * The name of 'fx:factory' attribute.
     */
    public static final String FX_FACTORY_ATTRIBUTE = &quot;factory&quot;;

    /**
     * The tag name of {@literal &lt;fx:include&gt;}.
     */
    public static final String INCLUDE_TAG = &quot;include&quot;;
    /**
     * The {@literal &lt;fx:include&gt;} 'source' attribute.
     */
    public static final String INCLUDE_SOURCE_ATTRIBUTE = &quot;source&quot;;
    /**
     * The {@literal &lt;fx:include&gt;} 'resources' attribute.
     */
    public static final String INCLUDE_RESOURCES_ATTRIBUTE = &quot;resources&quot;;
    /**
     * The {@literal &lt;fx:include&gt;} 'charset' attribute.
     */
    public static final String INCLUDE_CHARSET_ATTRIBUTE = &quot;charset&quot;;

    /**
     * The tag name of {@literal &lt;fx:script&gt;}.
     */
    public static final String SCRIPT_TAG = &quot;script&quot;;
    /**
     * The {@literal &lt;fx:script&gt;} 'source' attribute.
     */
    public static final String SCRIPT_SOURCE_ATTRIBUTE = &quot;source&quot;;
    /**
     * The {@literal &lt;fx:script&gt;} 'charset' attribute.
     */
    public static final String SCRIPT_CHARSET_ATTRIBUTE = &quot;charset&quot;;

    /**
     * The tag name of {@literal &lt;fx:define&gt;}.
     */
    public static final String DEFINE_TAG = &quot;define&quot;;

    /**
     * The tag name of {@literal &lt;fx:reference&gt;}.
     */
    public static final String REFERENCE_TAG = &quot;reference&quot;;
    /**
     * The {@literal &lt;fx:reference&gt;} 'source' attribute.
     */
    public static final String REFERENCE_SOURCE_ATTRIBUTE = &quot;source&quot;;

    /**
     * The tag name of {@literal &lt;fx:root&gt;}.
     * @since JavaFX 2.2
     */
    public static final String ROOT_TAG = &quot;root&quot;;
    /**
     * The {@literal &lt;fx:root&gt;} 'type' attribute.
     * @since JavaFX 2.2
     */
    public static final String ROOT_TYPE_ATTRIBUTE = &quot;type&quot;;

    /**
     * The tag name of {@literal &lt;fx:copy&gt;}.
     */
    public static final String COPY_TAG = &quot;copy&quot;;
    /**
     * The {@literal &lt;fx:copy&gt;} 'source' attribute.
     */
    public static final String COPY_SOURCE_ATTRIBUTE = &quot;source&quot;;

    /**
     * The prefix of event handler attributes.
     */
    public static final String EVENT_HANDLER_PREFIX = &quot;on&quot;;
    /**
     * The name of the Event object in event handler scripts.
     */
    public static final String EVENT_KEY = &quot;event&quot;;
    /**
     * Suffix for property change/invalidation handlers.
     */
    public static final String CHANGE_EVENT_HANDLER_SUFFIX = &quot;Change&quot;;
    private static final String COLLECTION_HANDLER_NAME = EVENT_HANDLER_PREFIX + CHANGE_EVENT_HANDLER_SUFFIX;

    /**
     * Value that represents 'null'.
     */
    public static final String NULL_KEYWORD = &quot;null&quot;;

    /**
     * Escape prefix for escaping special characters inside attribute values.
     * Serves as an escape for {@link #ESCAPE_PREFIX}, {@link #RELATIVE_PATH_PREFIX},
     * {@link #RESOURCE_KEY_PREFIX}, {@link #EXPRESSION_PREFIX},
     * {@link #BI_DIRECTIONAL_BINDING_PREFIX}
     * @since JavaFX 2.1
     */
    public static final String ESCAPE_PREFIX = &quot;\\&quot;;
    /**
     * Prefix for relative location resolution.
     */
    public static final String RELATIVE_PATH_PREFIX = &quot;@&quot;;
    /**
     * Prefix for resource resolution.
     */
    public static final String RESOURCE_KEY_PREFIX = &quot;%&quot;;
    /**
     * Prefix for (variable) expression resolution.
     */
    public static final String EXPRESSION_PREFIX = &quot;$&quot;;
    /**
     * Prefix for binding expression resolution.
     */
    public static final String BINDING_EXPRESSION_PREFIX = &quot;${&quot;;
    /**
     * Suffix for binding expression resolution.
     */
    public static final String BINDING_EXPRESSION_SUFFIX = &quot;}&quot;;

    /**
     * Prefix for bidirectional-binding expression resolution.
     * @since JavaFX 2.1
     */
    public static final String BI_DIRECTIONAL_BINDING_PREFIX = &quot;#{&quot;;
    /**
     * Suffix for bidirectional-binding expression resolution.
     * @since JavaFX 2.1
     */
    public static final String BI_DIRECTIONAL_BINDING_SUFFIX = &quot;}&quot;;

    /**
     * Delimiter for arrays as values.
     * @since JavaFX 2.1
     */
    public static final String ARRAY_COMPONENT_DELIMITER = &quot;,&quot;;

    /**
     * A key for location URL in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.2
     */
    public static final String LOCATION_KEY = &quot;location&quot;;
    /**
     * A key for ResourceBundle in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.2
     */
    public static final String RESOURCES_KEY = &quot;resources&quot;;

    /**
     * Prefix for controller method resolution.
     */
    public static final String CONTROLLER_METHOD_PREFIX = &quot;#&quot;;
    /**
     * A key for controller in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.1
     */
    public static final String CONTROLLER_KEYWORD = &quot;controller&quot;;
    /**
     * A suffix for controllers of included fxml files.
     * The full key is stored in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.2
     */
    public static final String CONTROLLER_SUFFIX = &quot;Controller&quot;;

    /**
     * The name of initialize method.
     * @since JavaFX 2.2
     */
    public static final String INITIALIZE_METHOD_NAME = &quot;initialize&quot;;

    /**
     * Contains the current javafx version.
     * @since JavaFX 8.0
     */
    public static final String JAVAFX_VERSION;

    /**
     * Contains the current fx namepsace version.
     * @since JavaFX 8.0
     */
    public static final String FX_NAMESPACE_VERSION = &quot;1&quot;;

    static {
        JAVAFX_VERSION = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
            @Override
            public String run() {
                return System.getProperty(&quot;javafx.version&quot;);
            }
        });

        FXMLLoaderHelper.setFXMLLoaderAccessor(new FXMLLoaderHelper.FXMLLoaderAccessor() {
            @Override
            public void setStaticLoad(FXMLLoader fxmlLoader, boolean staticLoad) {
                fxmlLoader.setStaticLoad(staticLoad);
            }
        });
    }

    /**
     * Creates a new FXMLLoader instance.
     */
    public FXMLLoader() {
        this((URL)null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location) {
        this(location, null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources) {
        this(location, resources, null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory) {
        this(location, resources, builderFactory, null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @param controllerFactory the controller factory used by this loader
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory) {
        this(location, resources, builderFactory, controllerFactory, Charset.forName(DEFAULT_CHARSET_NAME));
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param charset the character set used by this loader
     */
    public FXMLLoader(Charset charset) {
        this(null, null, null, null, charset);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @param controllerFactory the controller factory used by this loader
     * @param charset the character set used by this loader
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory, Charset charset) {
        this(location, resources, builderFactory, controllerFactory, charset,
            new LinkedList&lt;FXMLLoader&gt;());
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @param controllerFactory the controller factory used by this loader
     * @param charset the character set used by this loader
     * @param loaders list of loaders
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory, Charset charset,
        LinkedList&lt;FXMLLoader&gt; loaders) {
        setLocation(location);
        setResources(resources);
        setBuilderFactory(builderFactory);
        setControllerFactory(controllerFactory);
        setCharset(charset);

        this.loaders = new LinkedList(loaders);
    }

    /**
     * Returns the location used to resolve relative path attribute values.
     * @return the location used to resolve relative path attribute values
     */
    public URL getLocation() {
        return location;
    }

    /**
     * Sets the location used to resolve relative path attribute values.
     *
     * @param location the location
     */
    public void setLocation(URL location) {
        this.location = location;
    }

    /**
     * Returns the resources used to resolve resource key attribute values.
     * @return the resources used to resolve resource key attribute values
     */
    public ResourceBundle getResources() {
        return resources;
    }

    /**
     * Sets the resources used to resolve resource key attribute values.
     *
     * @param resources the resources
     */
    public void setResources(ResourceBundle resources) {
        this.resources = resources;
    }

    /**
     * Returns the namespace used by this loader.
     * @return the namespace
     */
    public ObservableMap&lt;String, Object&gt; getNamespace() {
        return namespace;
    }

    /**
     * Returns the root of the object hierarchy.
     * @param &lt;T&gt; the type of the root object
     * @return the root of the object hierarchy
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T getRoot() {
        return (T)root;
    }

    /**
     * Sets the root of the object hierarchy. The value passed to this method
     * is used as the value of the {@code &lt;fx:root&gt;} tag. This method
     * must be called prior to loading the document when using
     * {@code &lt;fx:root&gt;}.
     *
     * @param root the root of the object hierarchy
     *
     * @since JavaFX 2.2
     */
    public void setRoot(Object root) {
        this.root = root;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof FXMLLoader) {
            FXMLLoader loader = (FXMLLoader)obj;
            if (location == null || loader.location == null) {
                return loader.location == location;
            }
            return location.toExternalForm().equals(
                    loader.location.toExternalForm());
        }
        return false;
    }

    private boolean isCyclic(
                            FXMLLoader currentLoader,
                            FXMLLoader node) {
        if (currentLoader == null) {
            return false;
        }
        if (currentLoader.equals(node)) {
            return true;
        }
        return isCyclic(currentLoader.parentLoader, node);
    }

    /**
     * Returns the controller associated with the root object.
     * @param &lt;T&gt; the type of the controller
     * @return the controller associated with the root object
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T getController() {
        return (T)controller;
    }

    /**
     * Sets the controller associated with the root object. The value passed to
     * this method is used as the value of the {@code fx:controller} attribute.
     * This method must be called prior to loading the document when using
     * controller event handlers when an {@code fx:controller} attribute is not
     * specified in the document.
     *
     * @param controller the controller to associate with the root object
     *
     * @since JavaFX 2.2
     */
    public void setController(Object controller) {
        this.controller = controller;

        if (controller == null) {
            namespace.remove(CONTROLLER_KEYWORD);
        } else {
            namespace.put(CONTROLLER_KEYWORD, controller);
        }

        controllerAccessor.setController(controller);
    }

    /**
     * Returns the builder factory used by this loader.
     * @return the builder factory
     */
    public BuilderFactory getBuilderFactory() {
        return builderFactory;
    }

    /**
     * Sets the builder factory used by this loader.
     *
     * @param builderFactory the builder factory
     */
    public void setBuilderFactory(BuilderFactory builderFactory) {
        this.builderFactory = builderFactory;
    }

    /**
     * Returns the controller factory used by this loader.
     * @return the controller factory
     * @since JavaFX 2.1
     */
    public Callback&lt;Class&lt;?&gt;, Object&gt; getControllerFactory() {
        return controllerFactory;
    }

    /**
     * Sets the controller factory used by this loader.
     *
     * @param controllerFactory the controller factory
     * @since JavaFX 2.1
     */
    public void setControllerFactory(Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory) {
        this.controllerFactory = controllerFactory;
    }

    /**
     * Returns the character set used by this loader.
     * @return the character set
     */
    public Charset getCharset() {
        return charset;
    }

    /**
     * Sets the character set used by this loader.
     *
     * @param charset the character set
     * @since JavaFX 2.1
     */
    public void setCharset(Charset charset) {
        if (charset == null) {
            throw new NullPointerException(&quot;charset is null.&quot;);
        }

        this.charset = charset;
    }

    /**
     * Returns the classloader used by this loader.
     * @return the classloader
     * @since JavaFX 2.1
     */
    public ClassLoader getClassLoader() {
        if (classLoader == null) {
            final SecurityManager sm = System.getSecurityManager();
            final Class caller = (sm != null) ?
                    walker.getCallerClass() :
                    null;
            return getDefaultClassLoader(caller);
        }
        return classLoader;
    }

    /**
     * Sets the classloader used by this loader and clears any existing
     * imports.
     *
     * @param classLoader the classloader
     * @since JavaFX 2.1
     */
    public void setClassLoader(ClassLoader classLoader) {
        if (classLoader == null) {
            throw new IllegalArgumentException();
        }

        this.classLoader = classLoader;

        clearImports();
    }

    /*
     * Returns the static load flag.
     */
    boolean isStaticLoad() {
        // SB-dependency: RT-21226 has been filed to track this
        return staticLoad;
    }

    /*
     * Sets the static load flag.
     *
     * @param staticLoad
     */
    void setStaticLoad(boolean staticLoad) {
        // SB-dependency: RT-21226 has been filed to track this
        this.staticLoad = staticLoad;
    }

    /**
     * Returns this loader's load listener.
     *
     * @return the load listener
     *
     * @since 9
     */
    public LoadListener getLoadListener() {
        // SB-dependency: RT-21228 has been filed to track this
        return loadListener;
    }

    /**
     * Sets this loader's load listener.
     *
     * @param loadListener the load listener
     *
     * @since 9
     */
    public final void setLoadListener(LoadListener loadListener) {
        // SB-dependency: RT-21228 has been filed to track this
        this.loadListener = loadListener;
    }

    /**
     * Loads an object hierarchy from a FXML document. The location from which
     * the document will be loaded must have been set by a prior call to
     * {@link #setLocation(URL)}.
     *
     * @param &lt;T&gt; the type of the root object
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     *
     * @since JavaFX 2.1
     */
    public &lt;T&gt; T load() throws IOException {
        return loadImpl((System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param inputStream an input stream containing the FXML data to load
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public &lt;T&gt; T load(InputStream inputStream) throws IOException {
        return loadImpl(inputStream, (System.getSecurityManager() != null)
                                         ? walker.getCallerClass()
                                         : null);
    }

    private Class&lt;?&gt; callerClass;

    private &lt;T&gt; T loadImpl(final Class&lt;?&gt; callerClass) throws IOException {
        if (location == null) {
            throw new IllegalStateException(&quot;Location is not set.&quot;);
        }

        InputStream inputStream = null;
        T value;
        try {
            inputStream = location.openStream();
            value = loadImpl(inputStream, callerClass);
        } finally {
            if (inputStream != null) {
                inputStream.close();
            }
        }

        return value;
    }

    @SuppressWarnings({ &quot;dep-ann&quot;, &quot;unchecked&quot; })
    private &lt;T&gt; T loadImpl(InputStream inputStream,
                           Class&lt;?&gt; callerClass) throws IOException {
        if (inputStream == null) {
            throw new NullPointerException(&quot;inputStream is null.&quot;);
        }

        this.callerClass = callerClass;
        controllerAccessor.setCallerClass(callerClass);
        try {
            clearImports();

            // Initialize the namespace
            namespace.put(LOCATION_KEY, location);
            namespace.put(RESOURCES_KEY, resources);

            // Clear the script engine
            scriptEngine = null;

            // Create the parser
            try {
                XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
                xmlInputFactory.setProperty(&quot;javax.xml.stream.isCoalescing&quot;, true);

                // Some stream readers incorrectly report an empty string as the prefix
                // for the default namespace; correct this as needed
                InputStreamReader inputStreamReader = new InputStreamReader(inputStream, charset);
                xmlStreamReader = new StreamReaderDelegate(xmlInputFactory.createXMLStreamReader(inputStreamReader)) {
                    @Override
                    public String getPrefix() {
                        String prefix = super.getPrefix();

                        if (prefix != null
                            &amp;&amp; prefix.length() == 0) {
                            prefix = null;
                        }

                        return prefix;
                    }

                    @Override
                    public String getAttributePrefix(int index) {
                        String attributePrefix = super.getAttributePrefix(index);

                        if (attributePrefix != null
                            &amp;&amp; attributePrefix.length() == 0) {
                            attributePrefix = null;
                        }

                        return attributePrefix;
                    }
                };
            } catch (XMLStreamException exception) {
                throw constructLoadException(exception);
            }

            // Push this loader onto the stack
            loaders.push(this);

            // Parse the XML stream
            try {
<A NAME="38"></A>                while (xmlStreamReader.hasNext()) {
                    int event = xmlStreamReader.next();

                    <FONT color="#348781"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#38',2,'match37-top.html#38',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>switch (event) {
                        case XMLStreamConstants.PROCESSING_INSTRUCTION: {
                            processProcessingInstruction();
                            break;
                        }

                        case XMLStreamConstants.COMMENT: {
                            processComment();
                            break;
                        }

                        case XMLStreamConstants.START_ELEMENT: {
                            processStartElement();
                            break;
                        }

                        case XMLStreamConstants.END_ELEMENT: {
                            processEndElement();
                            break;
                        }

                        case</B></FONT> XMLStreamConstants.CHARACTERS: {
                            processCharacters();
                            break;
                        }
                    }
                }
            } catch (XMLStreamException exception) {
                throw constructLoadException(exception);
            }

            if (controller != null) {
                if (controller instanceof Initializable) {
                    ((Initializable)controller).initialize(location, resources);
                } else {
                    // Inject controller fields
                    Map&lt;String, List&lt;Field&gt;&gt; controllerFields =
                            controllerAccessor.getControllerFields();

                    injectFields(LOCATION_KEY, location);

                    injectFields(RESOURCES_KEY, resources);

                    // Initialize the controller
                    Method initializeMethod = controllerAccessor
                                                  .getControllerMethods()
                                                  .get(SupportedType.PARAMETERLESS)
                                                  .get(INITIALIZE_METHOD_NAME);

                    if (initializeMethod != null) {
                        try {
                            MethodHelper.invoke(initializeMethod, controller, new Object [] {});
                        } catch (IllegalAccessException exception) {
                            throw constructLoadException(exception);
                        } catch (InvocationTargetException exception) {
                            throw constructLoadException(exception);
                        }
                    }
                }
            }
        } catch (final LoadException exception) {
            throw exception;
        } catch (final Exception exception) {
            throw constructLoadException(exception);
        } finally {
            controllerAccessor.setCallerClass(null);
            // Clear controller accessor caches
            controllerAccessor.reset();
            // Clear the parser
            xmlStreamReader = null;
        }

        return (T)root;
    }

    private void clearImports() {
        packages.clear();
        classes.clear();
    }

    private LoadException constructLoadException(String message){
        return new LoadException(message + constructFXMLTrace());
    }

    private LoadException constructLoadException(Throwable cause) {
        return new LoadException(constructFXMLTrace(), cause);
    }

    private LoadException constructLoadException(String message, Throwable cause){
        return new LoadException(message + constructFXMLTrace(), cause);
    }

    private String constructFXMLTrace() {
        StringBuilder messageBuilder = new StringBuilder(&quot;\n&quot;);

        for (FXMLLoader loader : loaders) {
            messageBuilder.append(loader.location != null ? loader.location.getPath() : &quot;unknown path&quot;);

            if (loader.current != null) {
                messageBuilder.append(&quot;:&quot;);
                messageBuilder.append(loader.getLineNumber());
            }

            messageBuilder.append(&quot;\n&quot;);
        }
        return messageBuilder.toString();
    }

    /**
     * Returns the current line number.
     */
    int getLineNumber() {
        return xmlStreamReader.getLocation().getLineNumber();
    }

    /**
     * Returns the current parse trace.
     */
    ParseTraceElement[] getParseTrace() {
        ParseTraceElement[] parseTrace = new ParseTraceElement[loaders.size()];

        int i = 0;
        for (FXMLLoader loader : loaders) {
            parseTrace[i++] = new ParseTraceElement(loader.location, (loader.current != null) ?
                loader.getLineNumber() : -1);
        }

        return parseTrace;
    }

    private void processProcessingInstruction() throws LoadException {
        String piTarget = xmlStreamReader.getPITarget().trim();

        if (piTarget.equals(LANGUAGE_PROCESSING_INSTRUCTION)) {
            processLanguage();
        } else if (piTarget.equals(IMPORT_PROCESSING_INSTRUCTION)) {
            processImport();
        }
    }

    private void processLanguage() throws LoadException {
        if (scriptEngine != null) {
            throw constructLoadException(&quot;Page language already set.&quot;);
        }

        String language = xmlStreamReader.getPIData();

        if (loadListener != null) {
            loadListener.readLanguageProcessingInstruction(language);
        }

        if (!staticLoad) {
            ScriptEngineManager scriptEngineManager = getScriptEngineManager();
            scriptEngine = scriptEngineManager.getEngineByName(language);
        }
    }

    private void processImport() throws LoadException {
        String target = xmlStreamReader.getPIData().trim();

        if (loadListener != null) {
            loadListener.readImportProcessingInstruction(target);
        }

        if (target.endsWith(&quot;.*&quot;)) {
            importPackage(target.substring(0, target.length() - 2));
        } else {
            importClass(target);
        }
    }

    private void processComment() throws LoadException {
        if (loadListener != null) {
            loadListener.readComment(xmlStreamReader.getText());
        }
    }

    private void processStartElement() throws IOException {
        // Create the element
        createElement();

        // Process the start tag
        current.processStartElement();

        // Set the root value
        if (root == null) {
            root = current.value;
        }
    }

    private void createElement() throws IOException {
        String prefix = xmlStreamReader.getPrefix();
        String localName = xmlStreamReader.getLocalName();

        if (prefix == null) {
            int i = localName.lastIndexOf('.');

            if (Character.isLowerCase(localName.charAt(i + 1))) {
                String name = localName.substring(i + 1);

                if (i == -1) {
                    // This is an instance property
                    if (loadListener != null) {
                        loadListener.beginPropertyElement(name, null);
                    }

                    current = new PropertyElement(name, null);
                } else {
                    // This is a static property
                    Class&lt;?&gt; sourceType = getType(localName.substring(0, i));

                    if (sourceType != null) {
                        if (loadListener != null) {
                            loadListener.beginPropertyElement(name, sourceType);
                        }

                        current = new PropertyElement(name, sourceType);
                    } else if (staticLoad) {
                        // The source type was not recognized
                        if (loadListener != null) {
                            loadListener.beginUnknownStaticPropertyElement(localName);
                        }

                        current = new UnknownStaticPropertyElement();
                    } else {
                        throw constructLoadException(localName + &quot; is not a valid property.&quot;);
                    }
                }
            } else {
                if (current == null &amp;&amp; root != null) {
                    throw constructLoadException(&quot;Root value already specified.&quot;);
                }

                Class&lt;?&gt; type = getType(localName);

                if (type != null) {
                    if (loadListener != null) {
                        loadListener.beginInstanceDeclarationElement(type);
                    }

                    current = new InstanceDeclarationElement(type);
                } else if (staticLoad) {
                    // The type was not recognized
                    if (loadListener != null) {
                        loadListener.beginUnknownTypeElement(localName);
                    }

                    current = new UnknownTypeElement();
                } else {
                    throw constructLoadException(localName + &quot; is not a valid type.&quot;);
                }
            }
        } else if (prefix.equals(FX_NAMESPACE_PREFIX)) {
            if (localName.equals(INCLUDE_TAG)) {
                if (loadListener != null) {
                    loadListener.beginIncludeElement();
                }

                current = new IncludeElement();
            } else if (localName.equals(REFERENCE_TAG)) {
                if (loadListener != null) {
                    loadListener.beginReferenceElement();
                }

                current = new ReferenceElement();
            } else if (localName.equals(COPY_TAG)) {
                if (loadListener != null) {
                    loadListener.beginCopyElement();
                }

                current = new CopyElement();
            } else if (localName.equals(ROOT_TAG)) {
                if (loadListener != null) {
                    loadListener.beginRootElement();
                }

                current = new RootElement();
            } else if (localName.equals(SCRIPT_TAG)) {
                if (loadListener != null) {
                    loadListener.beginScriptElement();
                }

                current = new ScriptElement();
            } else if (localName.equals(DEFINE_TAG)) {
                if (loadListener != null) {
                    loadListener.beginDefineElement();
                }

                current = new DefineElement();
            } else {
                throw constructLoadException(prefix + &quot;:&quot; + localName + &quot; is not a valid element.&quot;);
            }
        } else {
            throw constructLoadException(&quot;Unexpected namespace prefix: &quot; + prefix + &quot;.&quot;);
        }
    }

    private void processEndElement() throws IOException {
        current.processEndElement();

        if (loadListener != null) {
            loadListener.endElement(current.value);
        }

        // Move up the stack
        current = current.parent;
    }

    private void processCharacters() throws IOException {
        // Process the characters
        if (!xmlStreamReader.isWhiteSpace()) {
            current.processCharacters();
        }
    }

    private void importPackage(String name) throws LoadException {
        packages.add(name);
    }

    private void importClass(String name) throws LoadException {
        try {
            loadType(name, true);
        } catch (ClassNotFoundException exception) {
            throw constructLoadException(exception);
        }
    }

    private Class&lt;?&gt; getType(String name) throws LoadException {
        Class&lt;?&gt; type = null;

        if (Character.isLowerCase(name.charAt(0))) {
            // This is a fully-qualified class name
            try {
                type = loadType(name, false);
            } catch (ClassNotFoundException exception) {
                // No-op
            }
        } else {
            // This is an unqualified class name
            type = classes.get(name);

            if (type == null) {
                // The class has not been loaded yet; look it up
                for (String packageName : packages) {
                    try {
                        type = loadTypeForPackage(packageName, name);
                    } catch (ClassNotFoundException exception) {
                        // No-op
                    }

                    if (type != null) {
                        break;
                    }
                }

                if (type != null) {
                    classes.put(name, type);
                }
            }
        }

        return type;
    }

    private Class&lt;?&gt; loadType(String name, boolean cache) throws ClassNotFoundException {
        int i = name.indexOf('.');
        int n = name.length();
        while (i != -1
            &amp;&amp; i &lt; n
            &amp;&amp; Character.isLowerCase(name.charAt(i + 1))) {
            i = name.indexOf('.', i + 1);
        }

        if (i == -1 || i == n) {
            throw new ClassNotFoundException();
        }

        String packageName = name.substring(0, i);
        String className = name.substring(i + 1);

        Class&lt;?&gt; type = loadTypeForPackage(packageName, className);

        if (cache) {
            classes.put(className, type);
        }

        return type;
    }

    // TODO Rename to loadType() when deprecated static version is removed
    private Class&lt;?&gt; loadTypeForPackage(String packageName, String className) throws ClassNotFoundException {
        return getClassLoader().loadClass(packageName + &quot;.&quot; + className.replace('.', '$'));
    }

    private static enum SupportedType {
        PARAMETERLESS {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 0;
            }

        },
        EVENT {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        Event.class.isAssignableFrom(m.getParameterTypes()[0]);
            }

        },
        LIST_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        m.getParameterTypes()[0].equals(ListChangeListener.Change.class);
            }

        },
        MAP_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        m.getParameterTypes()[0].equals(MapChangeListener.Change.class);
            }

        },
        SET_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        m.getParameterTypes()[0].equals(SetChangeListener.Change.class);
            }

        },
        PROPERTY_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 3 &amp;&amp;
                        ObservableValue.class.isAssignableFrom(m.getParameterTypes()[0])
                        &amp;&amp; m.getParameterTypes()[1].equals(m.getParameterTypes()[2]);
            }

        };

        protected abstract boolean methodIsOfType(Method m);
    }

    private static SupportedType toSupportedType(Method m) {
        for (SupportedType t : SupportedType.values()) {
            if (t.methodIsOfType(m)) {
                return t;
            }
        }
        return null;
    }

    private ScriptEngineManager getScriptEngineManager() {
        if (scriptEngineManager == null) {
            scriptEngineManager = new javax.script.ScriptEngineManager();
            scriptEngineManager.setBindings(new SimpleBindings(namespace));
        }

        return scriptEngineManager;
    }

    /**
     * Loads a type using the default class loader.
     *
     * @param packageName the package name of the class to load
     * @param className the name of the class to load
     *
     * @throws ClassNotFoundException if the specified class cannot be found
     * @return the class
     *
     * @deprecated
     * This method now delegates to {@link #getDefaultClassLoader()}.
     */
    @Deprecated
    public static Class&lt;?&gt; loadType(String packageName, String className) throws ClassNotFoundException {
        return loadType(packageName + &quot;.&quot; + className.replace('.', '$'));
    }

    /**
     * Loads a type using the default class loader.
     *
     * @param className the name of the class to load
     * @throws ClassNotFoundException if the specified class cannot be found
     * @return the class
     *
     * @deprecated
     * This method now delegates to {@link #getDefaultClassLoader()}.
     */
    @Deprecated
    public static Class&lt;?&gt; loadType(String className) throws ClassNotFoundException {
        ReflectUtil.checkPackageAccess(className);
        return Class.forName(className, true, getDefaultClassLoader());
    }

    private static boolean needsClassLoaderPermissionCheck(Class caller) {
        if (caller == null) {
            return false;
        }
        return !FXMLLoader.class.getModule().equals(caller.getModule());
    }

    private static ClassLoader getDefaultClassLoader(Class caller) {
        if (defaultClassLoader == null) {
            final SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                if (needsClassLoaderPermissionCheck(caller)) {
                    sm.checkPermission(GET_CLASSLOADER_PERMISSION);
                }
            }
            return Thread.currentThread().getContextClassLoader();
        }
        return defaultClassLoader;
    }

    /**
     * Returns the default class loader.
     * @return the default class loader
     * @since JavaFX 2.1
     */
    public static ClassLoader getDefaultClassLoader() {
        final SecurityManager sm = System.getSecurityManager();
        final Class caller = (sm != null) ?
                walker.getCallerClass() :
                null;
        return getDefaultClassLoader(caller);
    }

    /**
     * Sets the default class loader.
     *
     * @param defaultClassLoader
     * The default class loader to use when loading classes.
     * @since JavaFX 2.1
     */
    public static void setDefaultClassLoader(ClassLoader defaultClassLoader) {
        if (defaultClassLoader == null) {
            throw new NullPointerException();
        }
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            sm.checkPermission(MODIFY_FXML_CLASS_LOADER_PERMISSION);
        }

        FXMLLoader.defaultClassLoader = defaultClassLoader;
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public static &lt;T&gt; T load(URL location) throws IOException {
        return loadImpl(location, (System.getSecurityManager() != null)
                                      ? walker.getCallerClass()
                                      : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, Class&lt;?&gt; callerClass)
            throws IOException {
        return loadImpl(location, null, callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources)
                                     throws IOException {
        return loadImpl(location, resources,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  Class&lt;?&gt; callerClass) throws IOException {
        return loadImpl(location, resources,  null,
                        callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used to load the document
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources,
                             BuilderFactory builderFactory)
                                     throws IOException {
        return loadImpl(location, resources, builderFactory,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  BuilderFactory builderFactory,
                                  Class&lt;?&gt; callerClass) throws IOException {
        return loadImpl(location, resources, builderFactory, null, callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used when loading the document
     * @param controllerFactory the controller factory used when loading the document
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     *
     * @since JavaFX 2.1
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources,
                             BuilderFactory builderFactory,
                             Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory)
                                     throws IOException {
        return loadImpl(location, resources, builderFactory, controllerFactory,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  BuilderFactory builderFactory,
                                  Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
                                  Class&lt;?&gt; callerClass) throws IOException {
        return loadImpl(location, resources, builderFactory, controllerFactory,
                        Charset.forName(DEFAULT_CHARSET_NAME), callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used when loading the document
     * @param controllerFactory the controller factory used when loading the document
     * @param charset the character set used when loading the document
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     *
     * @since JavaFX 2.1
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources,
                             BuilderFactory builderFactory,
                             Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
                             Charset charset) throws IOException {
        return loadImpl(location, resources, builderFactory, controllerFactory,
                        charset,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  BuilderFactory builderFactory,
                                  Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
                                  Charset charset, Class&lt;?&gt; callerClass)
                                          throws IOException {
        if (location == null) {
            throw new NullPointerException(&quot;Location is required.&quot;);
        }

        FXMLLoader fxmlLoader =
                new FXMLLoader(location, resources, builderFactory,
                               controllerFactory, charset);

        return fxmlLoader.&lt;T&gt;loadImpl(callerClass);
    }

    /**
     * Utility method for comparing two JavaFX version strings (such as 2.2.5, 8.0.0-ea)
     * @param rtVer String representation of JavaFX runtime version, including - or _ appendix
     * @param nsVer String representation of JavaFX version to compare against runtime version
     * @return number &amp;lt; 0 if runtime version is lower, 0 when both versions are the same,
     *          number &amp;gt; 0 if runtime is higher version
     */
    static int compareJFXVersions(String rtVer, String nsVer) {

        int retVal = 0;

        if (rtVer == null || &quot;&quot;.equals(rtVer) ||
            nsVer == null || &quot;&quot;.equals(nsVer)) {
            return retVal;
        }

        if (rtVer.equals(nsVer)) {
            return retVal;
        }

        // version string can contain '-'
        int dashIndex = rtVer.indexOf(&quot;-&quot;);
        if (dashIndex &gt; 0) {
            rtVer = rtVer.substring(0, dashIndex);
        }

        // or &quot;_&quot;
        int underIndex = rtVer.indexOf(&quot;_&quot;);
        if (underIndex &gt; 0) {
            rtVer = rtVer.substring(0, underIndex);
        }

        // do not try to compare if the string is not valid version format
        if (!Pattern.matches(&quot;^(\\d+)(\\.\\d+)*$&quot;, rtVer) ||
            !Pattern.matches(&quot;^(\\d+)(\\.\\d+)*$&quot;, nsVer)) {
            return retVal;
        }

        StringTokenizer nsVerTokenizer = new StringTokenizer(nsVer, &quot;.&quot;);
        StringTokenizer rtVerTokenizer = new StringTokenizer(rtVer, &quot;.&quot;);
        int nsDigit = 0, rtDigit = 0;
        boolean rtVerEnd = false;

        while (nsVerTokenizer.hasMoreTokens() &amp;&amp; retVal == 0) {
            nsDigit = Integer.parseInt(nsVerTokenizer.nextToken());
            if (rtVerTokenizer.hasMoreTokens()) {
                rtDigit = Integer.parseInt(rtVerTokenizer.nextToken());
                retVal = rtDigit - nsDigit;
            } else {
                rtVerEnd = true;
                break;
            }
        }

        if (rtVerTokenizer.hasMoreTokens() &amp;&amp; retVal == 0) {
            rtDigit = Integer.parseInt(rtVerTokenizer.nextToken());
            if (rtDigit &gt; 0) {
                retVal = 1;
            }
        }

        if (rtVerEnd) {
            if (nsDigit &gt; 0) {
                retVal = -1;
            } else {
                while (nsVerTokenizer.hasMoreTokens()) {
                    nsDigit = Integer.parseInt(nsVerTokenizer.nextToken());
                    if (nsDigit &gt; 0) {
                        retVal = -1;
                        break;
                    }
                }
            }
        }

        return retVal;
    }

    private static void checkClassLoaderPermission() {
        final SecurityManager securityManager = System.getSecurityManager();
        if (securityManager != null) {
            securityManager.checkPermission(MODIFY_FXML_CLASS_LOADER_PERMISSION);
        }
    }

    private final ControllerAccessor controllerAccessor =
            new ControllerAccessor();

    private static final class ControllerAccessor {
        private static final int PUBLIC = 1;
        private static final int PROTECTED = 2;
        private static final int PACKAGE = 4;
        private static final int PRIVATE = 8;
        private static final int INITIAL_CLASS_ACCESS =
                PUBLIC | PROTECTED | PACKAGE | PRIVATE;
        private static final int INITIAL_MEMBER_ACCESS =
                PUBLIC | PROTECTED | PACKAGE | PRIVATE;

        private static final int METHODS = 0;
        private static final int FIELDS = 1;

        private Object controller;
        private ClassLoader callerClassLoader;

        private Map&lt;String, List&lt;Field&gt;&gt; controllerFields;
        private Map&lt;SupportedType, Map&lt;String, Method&gt;&gt; controllerMethods;

        void setController(final Object controller) {
            if (this.controller != controller) {
                this.controller = controller;
                reset();
            }
        }

        void setCallerClass(final Class&lt;?&gt; callerClass) {
            final ClassLoader newCallerClassLoader =
                    (callerClass != null) ? callerClass.getClassLoader()
                                          : null;
            if (callerClassLoader != newCallerClassLoader) {
                callerClassLoader = newCallerClassLoader;
                reset();
            }
        }

        void reset() {
            controllerFields = null;
            controllerMethods = null;
        }

        Map&lt;String, List&lt;Field&gt;&gt; getControllerFields() {
            if (controllerFields == null) {
                controllerFields = new HashMap&lt;&gt;();

                if (callerClassLoader == null) {
                    // allow null class loader only with permission check
                    checkClassLoaderPermission();
                }

                addAccessibleMembers(controller.getClass(),
                                     INITIAL_CLASS_ACCESS,
                                     INITIAL_MEMBER_ACCESS,
                                     FIELDS);
            }

            return controllerFields;
        }

        Map&lt;SupportedType, Map&lt;String, Method&gt;&gt; getControllerMethods() {
            if (controllerMethods == null) {
                controllerMethods = new EnumMap&lt;&gt;(SupportedType.class);
                for (SupportedType t: SupportedType.values()) {
                    controllerMethods.put(t, new HashMap&lt;String, Method&gt;());
                }

                if (callerClassLoader == null) {
                    // allow null class loader only with permission check
                    checkClassLoaderPermission();
                }

                addAccessibleMembers(controller.getClass(),
                                     INITIAL_CLASS_ACCESS,
                                     INITIAL_MEMBER_ACCESS,
                                     METHODS);
            }

            return controllerMethods;
        }

        private void addAccessibleMembers(final Class&lt;?&gt; type,
                                          final int prevAllowedClassAccess,
                                          final int prevAllowedMemberAccess,
                                          final int membersType) {
            if (type == Object.class) {
                return;
            }

            int allowedClassAccess = prevAllowedClassAccess;
            int allowedMemberAccess = prevAllowedMemberAccess;
            if ((callerClassLoader != null)
                    &amp;&amp; (type.getClassLoader() != callerClassLoader)) {
                // restrict further access
                allowedClassAccess &amp;= PUBLIC;
                allowedMemberAccess &amp;= PUBLIC;
            }

            final int classAccess = getAccess(type.getModifiers());
            if ((classAccess &amp; allowedClassAccess) == 0) {
                // we are done
                return;
            }

            ReflectUtil.checkPackageAccess(type);

            addAccessibleMembers(type.getSuperclass(),
                                 allowedClassAccess,
                                 allowedMemberAccess,
                                 membersType);

            final int finalAllowedMemberAccess = allowedMemberAccess;
            AccessController.doPrivileged(
                    new PrivilegedAction&lt;Void&gt;() {
                        @Override
                        public Void run() {
                            if (membersType == FIELDS) {
                                addAccessibleFields(type,
                                                    finalAllowedMemberAccess);
                            } else {
                                addAccessibleMethods(type,
                                                     finalAllowedMemberAccess);
                            }

                            return null;
                        }
                    });
        }

        private void addAccessibleFields(final Class&lt;?&gt; type,
                                         final int allowedMemberAccess) {
            final boolean isPublicType = Modifier.isPublic(type.getModifiers());

            final Field[] fields = type.getDeclaredFields();
            for (int i = 0; i &lt; fields.length; ++i) {
                final Field field = fields[i];
                final int memberModifiers = field.getModifiers();

                if (((memberModifiers &amp; (Modifier.STATIC
                                             | Modifier.FINAL)) != 0)
                        || ((getAccess(memberModifiers) &amp; allowedMemberAccess)
                                == 0)) {
                    continue;
                }

                if (!isPublicType || !Modifier.isPublic(memberModifiers)) {
                    if (field.getAnnotation(FXML.class) == null) {
                        // no fxml annotation on a non-public field
                        continue;
                    }

                    // Ensure that the field is accessible
                    field.setAccessible(true);
                }

                List&lt;Field&gt; list = controllerFields.get(field.getName());
                if (list == null) {
                    list = new ArrayList&lt;&gt;(1);
                    controllerFields.put(field.getName(), list);
                }
                list.add(field);

            }
        }

        private void addAccessibleMethods(final Class&lt;?&gt; type,
                                          final int allowedMemberAccess) {
            final boolean isPublicType = Modifier.isPublic(type.getModifiers());

            final Method[] methods = type.getDeclaredMethods();
            for (int i = 0; i &lt; methods.length; ++i) {
                final Method method = methods[i];
                final int memberModifiers = method.getModifiers();

                if (((memberModifiers &amp; (Modifier.STATIC
                                             | Modifier.NATIVE)) != 0)
                        || ((getAccess(memberModifiers) &amp; allowedMemberAccess)
                                == 0)) {
                    continue;
                }

                if (!isPublicType || !Modifier.isPublic(memberModifiers)) {
                    if (method.getAnnotation(FXML.class) == null) {
                        // no fxml annotation on a non-public method
                        continue;
                    }

                    // Ensure that the method is accessible
                    method.setAccessible(true);
                }

                // Add this method to the map if:
                // a) it is the initialize() method, or
                // b) it takes a single event argument, or
                // c) it takes no arguments and a handler with this
                //    name has not already been defined
                final String methodName = method.getName();
                final SupportedType convertedType;

                if ((convertedType = toSupportedType(method)) != null) {
                    controllerMethods.get(convertedType)
                                     .put(methodName, method);
                }
            }
        }

        private static int getAccess(final int fullModifiers) {
            final int untransformedAccess =
                    fullModifiers &amp; (Modifier.PRIVATE | Modifier.PROTECTED
                                                      | Modifier.PUBLIC);

            switch (untransformedAccess) {
                case Modifier.PUBLIC:
                    return PUBLIC;

                case Modifier.PROTECTED:
                    return PROTECTED;

                case Modifier.PRIVATE:
                    return PRIVATE;

                default:
                    return PACKAGE;
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/events/WindowEvent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.events;

import java.lang.annotation.Native;

public class WindowEvent {
    @Native final static public int RESIZE                = 511;
    @Native final static public int MOVE                  = 512;
    @Native final static public int RESCALE               = 513;

    @Native final static public int CLOSE                 = 521;
<A NAME="29"></A>    @Native final static public int DESTROY               = 522;

    @Native final static public int MINIMIZE              = 531;
    <FONT color="#faafba"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#29',2,'match37-top.html#29',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Native final static public int MAXIMIZE              = 532;
    @Native final static public int RESTORE               = 533;

    @Native final static public int _FOCUS_MIN            = 541;
    @Native final static public int FOCUS_LOST            = 541;
    @Native final static public int FOCUS_GAINED          = 542;
    @Native final static public int FOCUS_GAINED_FORWARD  = 543;
    @Native final static public int FOCUS_GAINED_BACKWARD = 544;
    @Native final static public int _FOCUS_MAX            = 544;

    @Native final static public int FOCUS_DISABLED        = 545;
    @Native final static public int FOCUS_UNGRAB          = 546;

    public stati</B></FONT>c String getEventName(final int eventType) {
        switch(eventType) {
            case WindowEvent.RESIZE:
                return &quot;RESIZE&quot;;
            case WindowEvent.MOVE:
                return &quot;MOVE&quot;;
            case WindowEvent.RESCALE:
                return &quot;RESCALE&quot;;
            case WindowEvent.CLOSE:
                return &quot;CLOSE&quot;;
            case WindowEvent.DESTROY:
                return &quot;DESTROY&quot;;
            case WindowEvent.MINIMIZE:
                return &quot;MINIMIZE&quot;;
            case WindowEvent.MAXIMIZE:
                return &quot;MAXIMIZE&quot;;
            case WindowEvent.RESTORE:
                return &quot;RESTORE&quot;;
            case WindowEvent.FOCUS_LOST:
                return &quot;FOCUS_LOST&quot;;
            case WindowEvent.FOCUS_GAINED:
                return &quot;FOCUS_GAINED&quot;;
            case WindowEvent.FOCUS_GAINED_FORWARD:
                return &quot;FOCUS_GAINED_FORWARD&quot;;
            case WindowEvent.FOCUS_GAINED_BACKWARD:
                return &quot;FOCUS_GAINED_BACKWARD&quot;;
            case WindowEvent.FOCUS_DISABLED:
                return &quot;FOCUS_DISABLED&quot;;
            case WindowEvent.FOCUS_UNGRAB:
                return &quot;FOCUS_UNGRAB&quot;;
            default:
                return &quot;UNKNOWN&quot;;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/CommonDialogs.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui;

import java.lang.annotation.Native;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
import java.io.File;

public class CommonDialogs {

    /**
     * Available file chooser types.
     *
     * @see #showFileChooser
     */
    public static final class Type {
        @Native public static final int OPEN = 0;
        @Native public static final int SAVE = 1;
    }

    /**
     * Provides a mechanism to filter different kinds of file name extensions.
     *
     * The following example creates an {@code ExtensionFilter} that will show
     * {@code txt} files:
     * &lt;pre&gt;
     *     List&lt;String&gt; extensions = new ArrayList&lt;String&gt;();
     *     extensions.add(&quot;*.txt&quot;);
     *     ExtensionFilter filter = new ExtensionFilter(&quot;Text files&quot;, extensions);
     *     List&lt;ExtensionFilter&gt; filters = new ArrayList&lt;ExtensionFilter&gt;();
     *     filters.add(filters);
     *     FileChooser.show(..., filters);
     * &lt;/pre&gt;
     *
     * @see #showFileChooser
     */
    public final static class ExtensionFilter {
        private final String description;
        private final List&lt;String&gt; extensions;

        /**
         * Creates an {@code ExtensionFilter} with the specified description
         * and the file name extensions.
         *
         * @param description    the textual description for the filter
         * @param extensions     the accepted file name extensions
         * @throws   IllegalArgumentException
         *           if the description of the filter is {@code null} or empty;
         *           if the extensions is {@code null}, empty or contains an empty string
         */
        public ExtensionFilter(String description, List&lt;String&gt; extensions) {
            Application.checkEventThread();
            if (description == null || description.trim().isEmpty()) {
                throw new IllegalArgumentException(&quot;Description parameter must be non-null and not empty&quot;);
            }

            if (extensions == null || extensions.isEmpty()) {
                throw new IllegalArgumentException(&quot;Extensions parameter must be non-null and not empty&quot;);
            }

            for (String extension : extensions) {
                if (extension == null || extension.length() == 0) {
                    throw new IllegalArgumentException(&quot;Each extension must be non-null and not empty&quot;);
                }
            }

            this.description = description;
            this.extensions = extensions;
        }

        public String getDescription() {
            Application.checkEventThread();
            return description;
        }

        public List&lt;String&gt; getExtensions() {
            Application.checkEventThread();
            return extensions;
        }

        // Called from native
        private String[] extensionsToArray() {
            Application.checkEventThread();
            return extensions.toArray(new String[extensions.size()]);
        }
    }

    /**
     * An object representing the result of showing a file chooser dialog.
     */
    public final static class FileChooserResult {
        private final List&lt;File&gt; files;
        private final ExtensionFilter filter;

        /**
         * Creates a new result object.
         * @param files should not be null, may be an empty list
         */
        public FileChooserResult(List&lt;File&gt; files, ExtensionFilter filter) {
            if (files == null) {
                throw new NullPointerException(&quot;files should not be null&quot;);
<A NAME="54"></A>            }
            this.files = files;
            this.filter = filter;
        <FONT color="#4e8975"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#54',2,'match37-top.html#54',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

        /**
         * Creates an empty results object.
         * Used when a user cancels a file chooser dialog.
         */
        public FileChooserResult() {
            this(new ArrayList&lt;File&gt;(), null);
        }

        /**
         * Returns a list of selected files.
         *
         * If a user cancels the dialog then this list is empty.
         *
         * Note that in case of a SAVE dialog the file name extension
         * corresponding to the selected ExtensionFilter may not be appended
         * automatically. Client code is responsible for checking the file
         * name and appending the extension if needed. Use {@link
         * #getExtensionFilter} to obtain the selected File Type filter.
         */
        public List&lt;File&gt; getFiles() {</B></FONT>
            return files;
        }

        /**
         * Returns the ExtensionFilter selected by a user when a
         * file chooser dialog is closed.
         *
         * A reference to one of the extension filter objects passed to the
         * showFileChooser() method.  May be null.
         */
        public ExtensionFilter getExtensionFilter() {
            return filter;
        }
    }

    private CommonDialogs() {
    }

    /**
     * Creates a native file chooser that lets the user select files.
     *
     * @param owner             the owner window for this file chooser (may be null)
     * @param folder            the initial folder, may be {@code null}
     * @param filename          the initial file name for a SAVE dialog (may be null)
     * @param title             the title of the file chooser
     * @param type              the type of the file chooser, one of the constants from {@link Type}
     * @param multipleMode      enables or disable multiple file selections
     * @param extensionFilters  the filters of the file chooser
     * @param defaultFilterIndex the zero-based index of the filter selected by default
     * @throws IllegalArgumentException
     *         if the initial folder is an invalid folder;
     *         if the type doesn't equal one of the constants from {@link Type}
     * @return the files that the user selects and the selected extension
     *         filter. If the user cancels the file chooser, the method returns empty
     *         results object.
     */
    public static FileChooserResult showFileChooser(Window owner, File folder, String filename, String title, int type,
                                        boolean multipleMode, List&lt;ExtensionFilter&gt; extensionFilters, int defaultFilterIndex)
    {
        Application.checkEventThread();
        String _folder = convertFolder(folder);
        if (filename == null) {
            filename = &quot;&quot;;
        }

        if (type != Type.OPEN &amp;&amp; type != Type.SAVE) {
            throw new IllegalArgumentException(&quot;Type parameter must be equal to one of the constants from Type&quot;);
        }

        ExtensionFilter[] _extensionFilters = null;
        if (extensionFilters != null) {
            _extensionFilters = extensionFilters.toArray(new ExtensionFilter[extensionFilters.size()]);
        }

        if (extensionFilters == null
                || extensionFilters.isEmpty()
                || defaultFilterIndex &lt; 0
                || defaultFilterIndex &gt;= extensionFilters.size()) {
            defaultFilterIndex = 0;
        }

        return Application.GetApplication().
            staticCommonDialogs_showFileChooser(owner, _folder, filename, convertTitle(title), type, multipleMode, _extensionFilters, defaultFilterIndex);
    }

    /**
     * Creates a native folder chooser that lets the user selects folder.
     *
     * @param owner  the owner window for this folder chooser (may be null)
     * @param folder the initial folder, may be {@code null}
     * @param title  the title of the folder chooser
     * @return the folder that the user selects. If the user cancels the folder chooser,
     *         the method returns null.
     */
    public static File showFolderChooser(Window owner, File folder, String title) {
        Application.checkEventThread();
        return Application.GetApplication().staticCommonDialogs_showFolderChooser(owner, convertFolder(folder), convertTitle(title));
    }

    private static String convertFolder(File folder) {
        if (folder != null) {
            if (folder.isDirectory()) {
                try {
                    return folder.getCanonicalPath();
                } catch (IOException e) {
                    throw new IllegalArgumentException(&quot;Unable to get a canonical path for folder&quot;, e);
                }
            } else {
                throw new IllegalArgumentException(&quot;Folder parameter must be a valid folder&quot;);
            }
        }

        return &quot;&quot;;
    }

    private static String convertTitle(String title) {
        return (title != null) ? title : &quot;&quot;;
    }

    /* a helper method for some platform implementations */
    protected static FileChooserResult createFileChooserResult(String[] files,
            ExtensionFilter[] extensionFilters, int index)
    {
        List&lt;File&gt; list = new ArrayList&lt;File&gt;();
        for (String s : files) {
            if (s != null) {
                list.add(new File(s));
            }
        }
        return new FileChooserResult(list,
                extensionFilters == null || index &lt; 0 || index &gt;= extensionFilters.length ?
                null : extensionFilters[index]);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/Screen.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui;

import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public final class Screen {

    // the list of attached screens provided by native.
    // screens[0] is the default/main Screen
    private static volatile List&lt;Screen&gt; screens = null ;

    // If dpiOverride is non-zero, use its value as screen DPI
    private static final int dpiOverride;

    static {
        dpiOverride = AccessController.doPrivileged((PrivilegedAction&lt;Integer&gt;) () -&gt; Integer.getInteger(&quot;com.sun.javafx.screenDPI&quot;, 0)).intValue();
    }

    public static class EventHandler {
        public void handleSettingsChanged() {
        }
    }

    public static double getVideoRefreshPeriod() {
        Application.checkEventThread();
        return Application.GetApplication().staticScreen_getVideoRefreshPeriod();
    }

    /**
     * Could be called from any thread
     * @return the main screen
     */
    public static Screen getMainScreen() {
        return getScreens().get(0);
    }

    /**
     * Could be called from any thread
     * @return list of all available screens
     */
    public static List&lt;Screen&gt; getScreens() {
        if (screens == null) {
            throw new RuntimeException(&quot;Internal graphics not initialized yet&quot;);
        }

        return screens;
    }

    private static EventHandler eventHandler;

    private volatile long ptr;
    private volatile int adapter;

    private final int depth;

    private final int x;
    private final int y;
    private final int width;
    private final int height;

    private final int platformX;
    private final int platformY;
    private final int platformWidth;
    private final int platformHeight;

    private final int visibleX;
    private final int visibleY;
    private final int visibleWidth;
    private final int visibleHeight;

    private final int resolutionX;
    private final int resolutionY;

    private final float platformScaleX;
    private final float platformScaleY;
    private final float outputScaleX;
    private final float outputScaleY;

    public Screen(
            long nativePtr,

            int depth,
            int x,
            int y,
            int width,
            int height,

            int platformX,
            int platformY,
            int platformWidth,
            int platformHeight,

            int visibleX,
            int visibleY,
            int visibleWidth,
            int visibleHeight,

            int resolutionX,
            int resolutionY,

            float platformScaleX,
            float platformScaleY,
            float outputScaleX,
            float outputScaleY
            ) {
        this.ptr = nativePtr;

        this.depth = depth;

        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;

        this.platformX = platformX;
        this.platformY = platformY;
        this.platformWidth = platformWidth;
        this.platformHeight = platformHeight;

        this.visibleX = visibleX;
        this.visibleY = visibleY;
        this.visibleWidth = visibleWidth;
        this.visibleHeight = visibleHeight;

        if (dpiOverride &gt; 0) {
            this.resolutionX = this.resolutionY = dpiOverride;
        } else {
            this.resolutionX = resolutionX;
            this.resolutionY = resolutionY;
        }

        this.platformScaleX = platformScaleX;
        this.platformScaleY = platformScaleY;
        this.outputScaleX = outputScaleX;
        this.outputScaleY = outputScaleY;
    }

    /**
     * Could be called from any thread
     */
    public int getDepth() {
        return this.depth;
    }

    /**
     * Could be called from any thread
     */
    public int getX() {
        return this.x;
    }

    /**
     * Could be called from any thread
     */
    public int getY() {
        return this.y;
    }

    /**
     * Could be called from any thread
     */
    public int getWidth() {
        return this.width;
    }

    /**
     * Could be called from any thread
     */
    public int getHeight() {
        return this.height;
    }

    /**
     * Could be called from any thread
     */
    public int getPlatformX() {
        return this.platformX;
    }

    /**
     * Could be called from any thread
     */
    public int getPlatformY() {
        return this.platformY;
    }

    /**
     * Could be called from any thread
     */
    public int getPlatformWidth() {
        return this.platformWidth;
    }

    /**
     * Could be called from any thread
     */
    public int getPlatformHeight() {
        return this.platformHeight;
    }

    public float fromPlatformX(int px) {
        return this.x + (px - platformX) / platformScaleX;
    }

    public float fromPlatformY(int py) {
        return this.y + (py - platformY) / platformScaleY;
    }

    public int toPlatformX(float ux) {
        return platformX + Math.round((ux - this.x) * platformScaleX);
    }

    public int toPlatformY(float uy) {
        return platformY + Math.round((uy - this.y) * platformScaleY);
    }

    public float portionIntersectsPlatformRect(int x, int y, int w, int h) {
        int x0 = Math.max(x, platformX);
        int y0 = Math.max(y, platformY);
        int x1 = Math.min(x + w, platformX + platformWidth);
        int y1 = Math.min(y + h, platformY + platformHeight);
        if ((x1 -= x0) &lt;= 0) return 0.0f;
        if ((y1 -= y0) &lt;= 0) return 0.0f;
        float ret = x1 * y1;
        return (ret / w) / h;
    }

    public boolean containsPlatformRect(int x, int y, int w, int h) {
        if (!containsPlatformCoords(x, y)) return false;
        if (w &lt;= 0 || h &lt;= 0) return true;
        return (x + w &lt;= platformX + platformWidth &amp;&amp;
                y + h &lt;= platformY + platformHeight);
    }

    public boolean containsPlatformCoords(int x, int y) {
        x -= platformX;
        y -= platformY;
        return (x &gt;= 0 &amp;&amp; x &lt; platformWidth &amp;&amp;
                y &gt;= 0 &amp;&amp; y &lt; platformHeight);
    }

    /**
     * Returns the horizontal scaling of the UI (window sizes and event
     * coordinates) from FX logical units to the platform units.
     * Could be called from any thread
     * @return platform X scaling
     */
    public float getPlatformScaleX() {
        return this.platformScaleX;
    }

    /**
     * Returns the vertical scaling of the UI (window sizes and event
     * coordinates) from FX logical units to the platform units.
     * Could be called from any thread
     * @return platform Y scaling
     */
    public float getPlatformScaleY() {
        return this.platformScaleY;
    }

    /**
     * Returns the recommended horizontal scaling for the rendered frames.
     * Could be called from any thread
     * @return recommended render X scaling
     */
    public float getRecommendedOutputScaleX() {
        return this.outputScaleX;
    }

    /**
     * Returns the recommended vertical scaling for the rendered frames.
     * Could be called from any thread
     * @return recommended render Y scaling
     */
    public float getRecommendedOutputScaleY() {
        return this.outputScaleY;
    }

    /**
     * Could be called from any thread
     */
    public int getVisibleX() {
        return this.visibleX;
    }

    /**
     * Could be called from any thread
     */
    public int getVisibleY() {
        return this.visibleY;
    }

    /**
     * Could be called from any thread
     */
    public int getVisibleWidth() {
        return this.visibleWidth;
    }

    /**
     * Could be called from any thread
     */
    public int getVisibleHeight() {
        return this.visibleHeight;
    }

    /**
     * Could be called from any thread
     */
    public int getResolutionX() {
        return this.resolutionX;
    }

    /**
     * Could be called from any thread
<A NAME="11"></A>     */
    public int getResolutionY() {
        return this.resolutionY;
    <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#11',2,'match37-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    /**
     * Could be called from any thread
     */
    public long getNativeScreen() {
        return this.ptr;
    }

    private void dispose() {
        this.ptr = 0L;
    }

    public int getAdapterOrdinal() {</B></FONT>
        return this.adapter;
    }

    public void setAdapterOrdinal(int adapter) {
        this.adapter = adapter;
    }

    public static void setEventHandler(EventHandler eh) {
        Application.checkEventThread();
        eventHandler = eh;
    }

    /**
     * Called from native when the Screen definitions change.
     */
    public static void notifySettingsChanged() {
        // Save the old screens in order to dispose them later
        List&lt;Screen&gt; oldScreens = screens;

        // Get the new screens
        initScreens();

        if (eventHandler != null) {
            eventHandler.handleSettingsChanged();
        }

        // Update the screen for each window to match the new instance.
        // Note that if a window has moved to another screen, the window
        // will be notified separately of that from native code and the
        // new screen will be updated there
        List&lt;Window&gt; windows = Window.getWindows();
        for (Window w : windows) {
            Screen oldScreen = w.getScreen();
            for (Screen newScreen : screens) {
                if (oldScreen.getNativeScreen() == newScreen.getNativeScreen()) {
                    w.setScreen(newScreen);
                    break;
                }
            }
        }

        // Dispose the old screens
        if (oldScreens != null) {
            for (Screen screen : oldScreens) {
                screen.dispose();
            }
        }
    }

    static void initScreens() {
        Application.checkEventThread();
        Screen[] newScreens = Application.GetApplication().staticScreen_getScreens();
        if (newScreens == null) {
            throw new RuntimeException(&quot;Internal graphics failed to initialize&quot;);
        }
        screens = Collections.unmodifiableList(Arrays.asList(newScreens));
    }

    @Override public String toString() {
        return  &quot;Screen:&quot;+&quot;\n&quot;+
                &quot;    ptr:&quot;+getNativeScreen()+&quot;\n&quot;+
                &quot;    adapter:&quot;+getAdapterOrdinal()+&quot;\n&quot;+
                &quot;    depth:&quot;+getDepth()+&quot;\n&quot;+
                &quot;    x:&quot;+getX()+&quot;\n&quot;+
                &quot;    y:&quot;+getY()+&quot;\n&quot;+
                &quot;    width:&quot;+getWidth()+&quot;\n&quot;+
                &quot;    height:&quot;+getHeight()+&quot;\n&quot;+
                &quot;    platformX:&quot;+getPlatformX()+&quot;\n&quot;+
                &quot;    platformY:&quot;+getPlatformY()+&quot;\n&quot;+
                &quot;    platformWidth:&quot;+getPlatformWidth()+&quot;\n&quot;+
                &quot;    platformHeight:&quot;+getPlatformHeight()+&quot;\n&quot;+
                &quot;    visibleX:&quot;+getVisibleX()+&quot;\n&quot;+
                &quot;    visibleY:&quot;+getVisibleY()+&quot;\n&quot;+
                &quot;    visibleWidth:&quot;+getVisibleWidth()+&quot;\n&quot;+
                &quot;    visibleHeight:&quot;+getVisibleHeight()+&quot;\n&quot;+
                &quot;    platformScaleX:&quot;+getPlatformScaleX()+&quot;\n&quot;+
                &quot;    platformScaleY:&quot;+getPlatformScaleY()+&quot;\n&quot;+
                &quot;    outputScaleX:&quot;+getRecommendedOutputScaleX()+&quot;\n&quot;+
                &quot;    outputScaleY:&quot;+getRecommendedOutputScaleY()+&quot;\n&quot;+
                &quot;    resolutionX:&quot;+getResolutionX()+&quot;\n&quot;+
                &quot;    resolutionY:&quot;+getResolutionY()+&quot;\n&quot;;
    }

    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Screen screen = (Screen) o;
        return ptr == screen.ptr
                &amp;&amp; adapter == screen.adapter
                &amp;&amp; depth == screen.depth
                &amp;&amp; x == screen.x
                &amp;&amp; y == screen.y
                &amp;&amp; width == screen.width
                &amp;&amp; height == screen.height
                &amp;&amp; visibleX == screen.visibleX
                &amp;&amp; visibleY == screen.visibleY
                &amp;&amp; visibleWidth == screen.visibleWidth
                &amp;&amp; visibleHeight == screen.visibleHeight
                &amp;&amp; resolutionX == screen.resolutionX
                &amp;&amp; resolutionY == screen.resolutionY
                &amp;&amp; Float.compare(screen.platformScaleX, platformScaleX) == 0
                &amp;&amp; Float.compare(screen.platformScaleY, platformScaleY) == 0
                &amp;&amp; Float.compare(screen.outputScaleX, outputScaleX) == 0
                &amp;&amp; Float.compare(screen.outputScaleY, outputScaleY) == 0;
    }

    @Override public int hashCode() {
        int result = 17;
        result = 31 * result + (int) (ptr ^ (ptr &gt;&gt;&gt; 32));
        result = 31 * result + adapter;
        result = 31 * result + depth;
        result = 31 * result + x;
        result = 31 * result + y;
        result = 31 * result + width;
        result = 31 * result + height;
        result = 31 * result + visibleX;
        result = 31 * result + visibleY;
        result = 31 * result + visibleWidth;
        result = 31 * result + visibleHeight;
        result = 31 * result + resolutionX;
        result = 31 * result + resolutionY;
        result = 31 * result + (platformScaleX != +0.0f ? Float.floatToIntBits(platformScaleX) : 0);
        result = 31 * result + (platformScaleY != +0.0f ? Float.floatToIntBits(platformScaleY) : 0);
        result = 31 * result + (outputScaleX != +0.0f ? Float.floatToIntBits(outputScaleX) : 0);
        result = 31 * result + (outputScaleY != +0.0f ? Float.floatToIntBits(outputScaleY) : 0);
        return result;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/gtk/GtkView.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui.gtk;

<A NAME="17"></A>import com.sun.glass.ui.Pixels;
import com.sun.glass.ui.View;
import java.nio.Buffer;
<FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#17',2,'match37-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.util.ArrayList;
import java.util.Map;

final class GtkView extends View {

    private boolean imEnabled = false;
    private boolean isInPreeditMode = false;
    private final StringBuilder preedit = new StringBuilder();
    private ByteBuffer attributes;
    private int lastCaret;

    private native void enableI</B></FONT>nputMethodEventsImpl(long ptr, boolean enable);

    @Override
    protected void _enableInputMethodEvents(long ptr, boolean enable) {
        enableInputMethodEventsImpl(ptr, enable);
        if (imEnabled) {
            preedit.setLength(0);
        }
        imEnabled = enable;
    }

    @Override
    protected int _getNativeFrameBuffer(long ptr) {
        return 0;
    }

    @Override
    protected native long _create(Map caps);

    @Override
    protected native long _getNativeView(long ptr);

    @Override
    protected native int _getX(long ptr);

    @Override
    protected native int _getY(long ptr);

    @Override
    protected native void _setParent(long ptr, long parentPtr);

    @Override
    protected native boolean _close(long ptr);

    @Override
    protected native void _scheduleRepaint(long ptr);

    @Override
    protected void _begin(long ptr) {}

    @Override
    protected void _end(long ptr) {}

    @Override
    protected void _uploadPixels(long ptr, Pixels pixels) {
        Buffer data = pixels.getPixels();
        if (data.isDirect() == true) {
            _uploadPixelsDirect(ptr, data, pixels.getWidth(), pixels.getHeight());
        } else if (data.hasArray() == true) {
            if (pixels.getBytesPerComponent() == 1) {
                ByteBuffer bytes = (ByteBuffer)data;
                _uploadPixelsByteArray(ptr, bytes.array(), bytes.arrayOffset(), pixels.getWidth(), pixels.getHeight());
            } else {
                IntBuffer ints = (IntBuffer)data;
                _uploadPixelsIntArray(ptr, ints.array(), ints.arrayOffset(), pixels.getWidth(), pixels.getHeight());
            }
        } else {
            // gznote: what are the circumstances under which this can happen?
            _uploadPixelsDirect(ptr, pixels.asByteBuffer(), pixels.getWidth(), pixels.getHeight());
        }
    }
    private native void _uploadPixelsDirect(long viewPtr, Buffer pixels, int width, int height);
    private native void _uploadPixelsByteArray(long viewPtr, byte[] pixels, int offset, int width, int height);
    private native void _uploadPixelsIntArray(long viewPtr, int[] pixels, int offset, int width, int height);

    @Override
    protected native boolean _enterFullscreen(long ptr, boolean animate, boolean keepRatio, boolean hideCursor);

    @Override
    protected native void _exitFullscreen(long ptr, boolean animate);

    @Override
    protected void _finishInputMethodComposition(long ptr) {
        if (imEnabled &amp;&amp; isInPreeditMode) {
            // Discard any pre-edited text
            preedit.setLength(0);
            notifyInputMethod(preedit.toString(), null, null, null, 0, 0, 0);
        }
    }

    private void notifyPreeditMode(boolean enabled){
        isInPreeditMode = enabled;
    }


    protected void notifyInputMethodDraw(String text, int first, int length, int caret, byte[] attr) {
        int[] boundary = null;
        byte[] values = null;

        if (attributes == null ) {
            attributes = ByteBuffer.allocate(32);
        }

        if (length &gt; 0) {
            preedit.replace(first, first + length, &quot;&quot;);
        }

        if (text != null) {
            preedit.insert(first, text);
        } else {
            if (attr == null) {
                preedit.setLength(0);
            }
        }

        if (attributes.capacity() &lt; preedit.length()) {
            ByteBuffer tmp  = ByteBuffer.allocate((int) (preedit.length() * 1.5));
            tmp.put(attributes);
            attributes = tmp;
        }

        attributes.limit(preedit.length());

        if (attr != null &amp;&amp; attributes.limit() &gt;= (first + attr.length)) {
            attributes.position(first);
            attributes.put(attr);
        }

        if (attributes.limit() &gt; 0) {
            ArrayList&lt;Integer&gt; boundaryList = new ArrayList&lt;&gt;();
            ArrayList&lt;Byte&gt; valuesList = new ArrayList&lt;&gt;();
            attributes.rewind();
            byte lastAttribute = attributes.get();

            boundaryList.add(0);
            valuesList.add(lastAttribute);

            int i = 1;
            while (attributes.hasRemaining()) {
                byte a = attributes.get();
                if (lastAttribute != a) {
                    boundaryList.add(i);
                    valuesList.add(a);
                }
                lastAttribute = a;
                i++;
            }

            boundaryList.add(attributes.limit());

            boundary = new int[boundaryList.size()];
            i = 0;
            for (Integer e : boundaryList) {
                boundary[i++] = e;
            }

            values = new byte[valuesList.size()];
            i = 0;
            for (Byte e: valuesList) {
                values[i++] = e;
            }
        }

        notifyInputMethod(preedit.toString(), boundary, boundary, values, 0, caret, 0);
        lastCaret = caret;
    }

    protected void notifyInputMethodCaret(int pos, int direction, int style) {
        switch (direction) {
            case 0: //XIMForwardChar
                lastCaret += pos;
                break;
            case 1: //XIMBackwardChar
                lastCaret -= pos;
                break;
            case 10: //XIMAbsolute
                lastCaret = pos;
                break;
            default:
                //TODO: as we don't know the text structure, we cannot compute the position
                // for other directions (like forward words, lines, etc...).
                // Luckily, vast majority of IM uses XIMAbsolute (10)
        }
        notifyInputMethod(preedit.toString(), null, null, null, 0, lastCaret, 0);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/geom/Edge.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.geom;

public final class Edge {
    static final int INIT_PARTS = 4;
    static final int GROW_PARTS = 10;

    Curve curve;
    int ctag;
    int etag;
    double activey;
    int equivalence;

    public Edge(Curve c, int ctag) {
        this(c, ctag, AreaOp.ETAG_IGNORE);
    }
<A NAME="25"></A>
    public Edge(Curve c, int ctag, int etag) {
        this.curve = c;
        <FONT color="#87f717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#25',2,'match37-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>this.ctag = ctag;
        this.etag = etag;
    }

    public Curve getCurve() {
        return curve;
    }

    public int getCurveTag() {
        return ctag;
    }

    public int getEdgeTag() {
        return etag;
    }

    public void setEdgeTag(int etag) {
        this.etag = etag;
    }

    public int get</B></FONT>Equivalence() {
        return equivalence;
    }

    public void setEquivalence(int eq) {
        equivalence = eq;
    }

    private Edge lastEdge;
    private int lastResult;
    private double lastLimit;

    public int compareTo(Edge other, double yrange[]) {
        if (other == lastEdge &amp;&amp; yrange[0] &lt; lastLimit) {
            if (yrange[1] &gt; lastLimit) {
                yrange[1] = lastLimit;
            }
            return lastResult;
        }
        if (this == other.lastEdge &amp;&amp; yrange[0] &lt; other.lastLimit) {
            if (yrange[1] &gt; other.lastLimit) {
                yrange[1] = other.lastLimit;
            }
            return 0-other.lastResult;
        }
        //long start = System.currentTimeMillis();
        int ret = curve.compareTo(other.curve, yrange);
        //long end = System.currentTimeMillis();
        /*
        System.out.println(&quot;compare: &quot;+
                           ((System.identityHashCode(this) &lt;
                             System.identityHashCode(other))
                            ? this+&quot; to &quot;+other
                            : other+&quot; to &quot;+this)+
                           &quot; == &quot;+ret+&quot; at &quot;+yrange[1]+
                           &quot; in &quot;+(end-start)+&quot;ms&quot;);
         */
        lastEdge = other;
        lastLimit = yrange[1];
        lastResult = ret;
        return ret;
    }

    public void record(double yend, int etag) {
        this.activey = yend;
        this.etag = etag;
    }

    public boolean isActiveFor(double y, int etag) {
        return (this.etag == etag &amp;&amp; this.activey &gt;= y);
    }

    @Override
    public String toString() {
        return (&quot;Edge[&quot;+curve+
                &quot;, &quot;+
                (ctag == AreaOp.CTAG_LEFT ? &quot;L&quot; : &quot;R&quot;)+
                &quot;, &quot;+
                (etag == AreaOp.ETAG_ENTER ? &quot;I&quot; :
                 (etag == AreaOp.ETAG_EXIT ? &quot;O&quot; : &quot;N&quot;))+
                &quot;]&quot;);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/runtime/async/BackgroundExecutor.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.runtime.async;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * ExecutorSingleton
 *
 */
public class BackgroundExecutor {
    private static ExecutorService instance;
    private static ScheduledExecutorService timerInstance;

    private BackgroundExecutor() {
        // not instantiable
    }

    public static synchronized ExecutorService getExecutor() {
        if (instance == null) {
            instance = Executors.newCachedThreadPool(r -&gt; {
                Thread t = new Thread(r);
                t.setPriority(Thread.MIN_PRIORITY);
                return t;
            });
            ((ThreadPoolExecutor) instance).setKeepAliveTime(1, TimeUnit.SECONDS);
        }

        return instance;
    }

    public static synchronized ScheduledExecutorService getTimer() {
        if (timerInstance == null) {
            // @@@ Here's where we load the configuration and such
            timerInstance = new ScheduledThreadPoolExecutor(1,
                    r -&gt; {
                        Thread t = new Thread(r);
                        t.setDaemon(true);
<A NAME="9"></A>                        return t;
                    }
            );
        <FONT color="#f88017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#9',2,'match37-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

        return timerInstance;
    }

    private static synchronized void shutdown() {
        if (instance != null) {
            instance.shutdown();
            instance = null;
        }
        if (timerInstance != null) {
            timerInstance.shutdown();
            timerInstance= null;
        }
    }</B></FONT>
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/scene/SceneEventDispatcher.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene;

import com.sun.javafx.event.BasicEventDispatcher;
import com.sun.javafx.event.CompositeEventDispatcher;
import com.sun.javafx.event.EventHandlerManager;

/**
 * An {@code EventDispatcher} for {@code Scene}. It is formed by a chain
 * of {@code KeyboardShortcutsHandler} followed by {@code EventHandlerManager}.
 */
public class SceneEventDispatcher extends CompositeEventDispatcher {
    private final KeyboardShortcutsHandler keyboardShortcutsHandler;

    private final EnteredExitedHandler enteredExitedHandler;

    private final EventHandlerManager eventHandlerManager;

    public SceneEventDispatcher(final Object eventSource) {
        this(new KeyboardShortcutsHandler(),
             new EnteredExitedHandler(eventSource),
             new EventHandlerManager(eventSource));

    }

<A NAME="2"></A>    public SceneEventDispatcher(
            final KeyboardShortcutsHandler keyboardShortcutsHandler,
            final EnteredExitedHandler enteredExitedHandler,
            <FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#2',2,'match37-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>final EventHandlerManager eventHandlerManager) {
        this.keyboardShortcutsHandler = keyboardShortcutsHandler;
        this.enteredExitedHandler = enteredExitedHandler;
        this.eventHandlerManager = eventHandlerManager;

        keyboardShortcutsHandler.insertNextDispatcher(enteredExitedHandler);
        enteredExitedHandler.insertNextDispatcher(eventHandlerManager);

    }

    public final KeyboardShortcutsHandler getKeyboardShortcutsHandler() {</B></FONT>
        return keyboardShortcutsHandler;
    }

    public final EnteredExitedHandler getEnteredExitedHandler() {
        return enteredExitedHandler;
    }

    public final EventHandlerManager getEventHandlerManager() {
        return eventHandlerManager;
    }

    @Override
    public BasicEventDispatcher getFirstDispatcher() {
        return keyboardShortcutsHandler;
    }

    @Override
    public BasicEventDispatcher getLastDispatcher() {
        return eventHandlerManager;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/sg/prism/CacheFilter.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.sg.prism;

import com.sun.javafx.logging.PulseLogger;
import javafx.scene.CacheHint;
import java.util.List;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.DirtyRegionContainer;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.prism.Graphics;
import com.sun.prism.RTTexture;
import com.sun.prism.Texture;
import com.sun.scenario.effect.Effect;
import com.sun.scenario.effect.FilterContext;
import com.sun.scenario.effect.Filterable;
import com.sun.scenario.effect.ImageData;
import com.sun.scenario.effect.impl.prism.PrDrawable;
import com.sun.scenario.effect.impl.prism.PrFilterContext;
import javafx.geometry.Insets;
import javafx.scene.layout.Background;
import javafx.scene.layout.BackgroundFill;
import javafx.scene.paint.Color;

/**
 * Base implementation of the Node.cache and cacheHint APIs.
 *
 * When all or a portion of the cacheHint becomes enabled, we should try *not*
 * to re-render the cache.  This avoids a big hiccup at the beginning of the
 * &quot;use SPEED only while animating&quot; use case:
 *   0) Under DEFAULT, we should already have a cached image
 *   1) scale/rotate caching is enabled (no expensive re-render required)
 *   2) animation happens, using the cached image
 *   3) animation completes, caching is disable and the node is re-rendered (at
 *      full-fidelity) with the final transform.
 *
 * Certain transform combinations are not supported, notably scaling by unequal
 * amounts in the x and y directions while also rotating.  Other than simple
 * translation, animations in this case will require re-rendering every frame.
 *
 * Ideally, a simple change to a Node's translation should never regenerate the
 * cached image.
 *
 * The CacheFilter is also capable of optimizing the scrolling of the cached contents.
 * For example, the ScrollView UI Control can define its content area as being cached,
 * such that when the user scrolls, we can shift the old content area and adjust the
 * dirty region so that it only includes the &quot;newly exposed&quot; area.
 */
public class CacheFilter {
<A NAME="0"></A>    /**
     * Defines the state when we're in the midst of scrolling a cached image
     */
    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#0',2,'match37-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private static enum ScrollCacheState {
        CHECKING_PRECONDITIONS,
        ENABLED,
        DISABLED
    }

    // Garbage-reduction variables:
    private static final Rectangle TEMP_RECT = new Rectangle();
    private static final DirtyRegionContainer TEMP_CONTAINER = new DirtyRegionContainer(1)</B></FONT>;
    private static final Affine3D TEMP_CACHEFILTER_TRANSFORM = new Affine3D();
    private static final RectBounds TEMP_BOUNDS = new RectBounds();
    // Fun with floating point
    private static final double EPSILON = 0.0000001;

    private RTTexture tempTexture;
    private double lastXDelta;
    private double lastYDelta;
    private ScrollCacheState scrollCacheState = ScrollCacheState.CHECKING_PRECONDITIONS;
    // Note: this ImageData is always created and assumed to be untransformed.
    private ImageData cachedImageData;
    private Rectangle cacheBounds = new Rectangle();
    // Used to draw into the cache
    private final Affine2D cachedXform = new Affine2D();

    // The scale and rotate used to draw into the cache
    private double cachedScaleX;
    private double cachedScaleY;
    private double cachedRotate;

    private double cachedX;
    private double cachedY;
    private NGNode node;

    // Used to draw the cached image to the screen
    private final Affine2D screenXform = new Affine2D();

    // Cache hint settings
    private boolean scaleHint;
    private boolean rotateHint;
    // We keep this around for the sake of matchesHint
    private CacheHint cacheHint;

    // Was the last paint unsupported by the cache?  If so, will need to
    // regenerate the cache next time.
    private boolean wasUnsupported = false;

    /**
     * Compute the dirty region that must be re-rendered after scrolling
     */
    private Rectangle computeDirtyRegionForTranslate() {
        if (lastXDelta != 0) {
            if (lastXDelta &gt; 0) {
                TEMP_RECT.setBounds(0, 0, (int)lastXDelta, cacheBounds.height);
            } else {
                TEMP_RECT.setBounds(cacheBounds.width + (int)lastXDelta, 0, -(int)lastXDelta, cacheBounds.height);
            }
        } else {
            if (lastYDelta &gt; 0) {
                TEMP_RECT.setBounds(0, 0, cacheBounds.width, (int)lastYDelta);
            } else {
                TEMP_RECT.setBounds(0, cacheBounds.height + (int)lastYDelta, cacheBounds.width, -(int)lastYDelta);
            }
        }
        return TEMP_RECT;
    }

    protected CacheFilter(NGNode node, CacheHint cacheHint) {
        this.node = node;
        this.scrollCacheState = ScrollCacheState.CHECKING_PRECONDITIONS;
        setHint(cacheHint);
    }

    public void setHint(CacheHint cacheHint) {
        this.cacheHint = cacheHint;
        this.scaleHint = (cacheHint == CacheHint.SPEED ||
                          cacheHint == CacheHint.SCALE ||
                          cacheHint == CacheHint.SCALE_AND_ROTATE);
        this.rotateHint = (cacheHint == CacheHint.SPEED ||
                           cacheHint == CacheHint.ROTATE ||
                           cacheHint == CacheHint.SCALE_AND_ROTATE);
    }

    // These two methods exist only for the sake of testing.
    final boolean isScaleHint() { return scaleHint; }
    final boolean isRotateHint() { return rotateHint; }

    /**
     * Indicates whether this CacheFilter's hint matches the CacheHint
     * passed in.
     */
    boolean matchesHint(CacheHint cacheHint) {
        return this.cacheHint == cacheHint;
    }

    /**
     * Are we attempting to use cache for an unsupported transform mode?  Mostly
     * this is for trying to rotate while scaling the object by different
     * amounts in the x and y directions (this also includes shearing).
     */
    boolean unsupported(double[] xformInfo) {
        double scaleX = xformInfo[0];
        double scaleY = xformInfo[1];
        double rotate = xformInfo[2];

        // If we're trying to rotate...
        if (rotate &gt; EPSILON || rotate &lt; -EPSILON) {
            // ...and if scaleX != scaleY.  This can be in the render xform, or
            // may have made it into the cached image.
            if (scaleX &gt; scaleY + EPSILON || scaleY &gt; scaleX + EPSILON ||
                scaleX &lt; scaleY - EPSILON || scaleY &lt; scaleX - EPSILON ||
                cachedScaleX &gt; cachedScaleY + EPSILON ||
                cachedScaleY &gt; cachedScaleX + EPSILON ||
                cachedScaleX &lt; cachedScaleY - EPSILON ||
                cachedScaleY &lt; cachedScaleX - EPSILON ) {
                    return true;
            }
        }
        return false;
    }

    private boolean isXformScrollCacheCapable(double[] xformInfo) {
        if (unsupported(xformInfo)) {
            return false;
        }
        double rotate = xformInfo[2];
        return rotateHint || rotate == 0;
    }

    /*
     * Do we need to regenerate the cached image?
     * Assumes that caller locked and validated the cachedImageData.untximage
     * if not null...
     */
    private boolean needToRenderCache(BaseTransform renderXform, double[] xformInfo,
                                      float pixelScaleX, float pixelScaleY)
    {
        if (cachedImageData == null) {
            return true;
        }

        if (lastXDelta != 0 || lastYDelta != 0) {
            if (Math.abs(lastXDelta) &gt;= cacheBounds.width || Math.abs(lastYDelta) &gt;= cacheBounds.height ||
                    Math.rint(lastXDelta) != lastXDelta || Math.rint(lastYDelta) != lastYDelta) {
                node.clearDirtyTree(); // Need to clear dirty (by translation) flags in the children
                lastXDelta = lastYDelta = 0;
                return true;
            }
            if (scrollCacheState == ScrollCacheState.CHECKING_PRECONDITIONS) {
                if (scrollCacheCapable() &amp;&amp; isXformScrollCacheCapable(xformInfo)) {
                    scrollCacheState = ScrollCacheState.ENABLED;
                } else {
                    scrollCacheState = ScrollCacheState.DISABLED;
                    return true;
                }
            }
        }

        // TODO: is == sufficient for floating point comparison here? (RT-23963)
        if (cachedXform.getMxx() == renderXform.getMxx() &amp;&amp;
            cachedXform.getMyy() == renderXform.getMyy() &amp;&amp;
            cachedXform.getMxy() == renderXform.getMxy() &amp;&amp;
            cachedXform.getMyx() == renderXform.getMyx()) {
            // It's just a translation - use cached Image
            return false;
        }
        // Not just a translation - if was or is unsupported, then must rerender
        if (wasUnsupported || unsupported(xformInfo)) {
            return true;
        }

        double scaleX = xformInfo[0];
        double scaleY = xformInfo[1];
        double rotate = xformInfo[2];
        if (scaleHint) {
            if (cachedScaleX &lt; pixelScaleX || cachedScaleY &lt; pixelScaleY) {
                // We have moved onto a screen with a higher pixelScale and
                // our cache was less than that pixel scale.  Even though
                // we have the scaleHint, we always cache at a minimum of
                // the pixel scale of the screen so we need to re-cache.
                return true;
            }
            if (rotateHint) {
                return false;
            } else {
                // Not caching for rotate: regenerate cache if rotate changed
                if (cachedRotate - EPSILON &lt; rotate &amp;&amp; rotate &lt; cachedRotate + EPSILON) {
                    return false;
                } else {
                    return true;
                }
            }
        } else {
            if (rotateHint) {
                // Not caching for scale: regenerate cache if scale changed
                if (cachedScaleX - EPSILON &lt; scaleX &amp;&amp; scaleX &lt; cachedScaleX + EPSILON &amp;&amp;
                    cachedScaleY - EPSILON &lt; scaleY &amp;&amp; scaleY &lt; cachedScaleY + EPSILON) {
                    return false;
                } else {// Scale is not &quot;equal enough&quot; - regenerate
                    return true;
                }
            }
            else { // Not caching for anything; always regenerate
                return true;
            }
        }
    }

    /*
     * Given the new xform info, update the screenXform as needed to correctly
     * paint the cache to the screen.
     */
    void updateScreenXform(double[] xformInfo) {
        // screenXform will be the difference between the cachedXform and the
        // render xform.

        if (scaleHint) {
            if (rotateHint) {
                double screenScaleX = xformInfo[0] / cachedScaleX;
                double screenScaleY = xformInfo[1] / cachedScaleY;
                double screenRotate = xformInfo[2] - cachedRotate;

                screenXform.setToScale(screenScaleX, screenScaleY);
                screenXform.rotate(screenRotate);
            } else {
                double screenScaleX = xformInfo[0] / cachedScaleX;
                double screenScaleY = xformInfo[1] / cachedScaleY;
                screenXform.setToScale(screenScaleX, screenScaleY);
            }
        } else {
            if (rotateHint) {
                double screenRotate = xformInfo[2] - cachedRotate;
                screenXform.setToRotation(screenRotate, 0.0, 0.0);
            } else {
                // No caching, cache already rendered with xform; just paint it
                screenXform.setTransform(BaseTransform.IDENTITY_TRANSFORM);
            }
        }
    }

    public void invalidate() {
        if (scrollCacheState == ScrollCacheState.ENABLED) {
            scrollCacheState = ScrollCacheState.CHECKING_PRECONDITIONS;
        }
        imageDataUnref();
        lastXDelta = lastYDelta = 0;
    }

    void imageDataUnref() {
        if (tempTexture != null) {
            tempTexture.dispose();
            tempTexture = null;
        }
        if (cachedImageData != null) {
            // While we hold on to this ImageData we leave the texture
            // unlocked so it can be reclaimed, but the default unref()
            // method assumes it was locked.
            Filterable implImage = cachedImageData.getUntransformedImage();
            if (implImage != null) {
                implImage.lock();
            }
            cachedImageData.unref();
            cachedImageData = null;
        }
    }

    void invalidateByTranslation(double translateXDelta, double translateYDelta) {
        if (cachedImageData == null) {
            return;
        }

        if (scrollCacheState == ScrollCacheState.DISABLED) {
            imageDataUnref();
        } else {
             // When both mxt and myt change, we don't currently use scroll optimization
            if (translateXDelta != 0 &amp;&amp; translateYDelta != 0) {
                imageDataUnref();
            } else {
                lastYDelta = translateYDelta;
                lastXDelta = translateXDelta;
            }
        }
    }

    public void dispose() {
        invalidate();
        node = null;
    }

    /*
     * unmatrix() and the supporting functions are based on the code from
     * &quot;Decomposing A Matrix Into Simple Transformations&quot; by Spencer W. Thomas
     * from Graphics Gems II, as found at
     * http://tog.acm.org/resources/GraphicsGems/
     * which states, &quot;All code here can be used without restrictions.&quot;
     *
     * The code was reduced from handling a 4x4 matrix (3D w/ perspective)
     * to handle just a 2x2 (2D scale/rotate, w/o translate, as that is handled
     * separately).
     */

    /**
     * Given a BaseTransform, decompose it into values for scaleX, scaleY and
     * rotate.
     *
     * The return value is a double[3], the values being:
     *   [0]: scaleX
     *   [1]: scaleY
     *   [2]: rotation angle, in radians, between *** and ***
     *
     * From unmatrix() in unmatrix.c
     */
    double[] unmatrix(BaseTransform xform) {
        double[] retVal = new double[3];

        double[][] row = {{xform.getMxx(), xform.getMxy()},
            {xform.getMyx(), xform.getMyy()}};
        final double xSignum = unitDir(row[0][0]);
        final double ySignum = unitDir(row[1][1]);

        // Compute X scale factor and normalize first row.
        // tran[U_SCALEX] = V3Length(&amp;row[0]);
        // row[0] = *V3Scale(&amp;row[0], 1.0);

        double scaleX = xSignum * v2length(row[0]);
        v2scale(row[0], xSignum);

        // Compute XY shear factor and make 2nd row orthogonal to 1st.
        // tran[U_SHEARXY] = V3Dot(&amp;row[0], &amp;row[1]);
        // (void)V3Combine(&amp;row[1], &amp;row[0], &amp;row[1], 1.0, -tran[U_SHEARXY]);
        //
        // &quot;this is too large by the y scaling factor&quot;
        double shearXY = v2dot(row[0], row[1]);

        // Combine into row[1]
        v2combine(row[1], row[0], row[1], 1.0, -shearXY);

        // Now, compute Y scale and normalize 2nd row
        // tran[U_SCALEY] = V3Length(&amp;row[1]);
        // V3Scale(&amp;row[1], 1.0);
        // tran[U_SHEARXY] /= tran[U_SCALEY];

        double scaleY = ySignum * v2length(row[1]);
        v2scale(row[1], ySignum);

        // Now extract the rotation. (This is new code, not from the Gem.)
        //
        // In our matrix, we now have
        // [   cos(theta)    -sin(theta)    ]
        // [   sin(theta)     cos(theta)    ]
        //
        // TODO: assert: all 4 values are sane (RT-23962)
        //
        double sin = row[1][0];
        double cos = row[0][0];
        double angleRad = 0.0;

        // Recall:
        // arcsin works for theta: -90 -&gt; 90
        // arccos works for theta:   0 -&gt; 180
        if (sin &gt;= 0) {
            // theta is 0 -&gt; 180, use acos()
            angleRad = Math.acos(cos);
        } else {
            if (cos &gt; 0) {
                // sin &lt; 0, cos &gt; 0, so theta is 270 -&gt; 360, aka -90 -&gt; 0
                // use asin(), add 360
                angleRad = 2.0 * Math.PI + Math.asin(sin);
            } else {
                // sin &lt; 0, cos &lt; 0, so theta 180 -&gt; 270
                // cos from 180 -&gt; 270 is inverse of cos from 0-&gt;90,
                // so take acos(-cos) and add 180
                angleRad = Math.PI + Math.acos(-cos);
            }
        }

        retVal[0] = scaleX;
        retVal[1] = scaleY;
        retVal[2] = angleRad;

        return retVal;
    }

    /**
     * Return the unit distance in a direction compatible with the matrix element.
     * @param v the matrix element representing a scale factor
     * @return -1.0 if the matrix element is negative, otherwise 1.0
     */
    double unitDir(double v) {
        return v &lt; 0.0 ? -1.0 : 1.0;
    }

    /**
     * make a linear combination of two vectors and return the result
     * result = (v0 * scalarA) + (v1 * scalarB)
     *
     * From V3Combine() in GGVecLib.c
     */
    void v2combine(double v0[], double v1[], double result[], double scalarA, double scalarB) {
        // make a linear combination of two vectors and return the result.
        // result = (a * ascl) + (b * bscl)
        /*
        Vector3 *V3Combine (a, b, result, ascl, bscl)
        Vector3 *a, *b, *result;
        double ascl, bscl;
        {
                result-&gt;x = (ascl * a-&gt;x) + (bscl * b-&gt;x);
                result-&gt;y = (ascl * a-&gt;y) + (bscl * b-&gt;y);
                result-&gt;z = (ascl * a-&gt;z) + (bscl * b-&gt;z);
                return(result);
        */

        result[0] = scalarA*v0[0] + scalarB*v1[0];
        result[1] = scalarA*v0[1] + scalarB*v1[1];
    }

    /**
     * dot product of 2 vectors of length 2
     */
    double v2dot(double v0[], double v1[]) {
        return v0[0]*v1[0] + v0[1]*v1[1];
    }

    /**
     * scale v[] to be relative to newLen
     *
     * From V3Scale() in GGVecLib.c
     */
    void v2scale(double v[], double newLen) {
        double len = v2length(v);
        if (len != 0) {
            v[0] *= newLen / len;
            v[1] *= newLen / len;
        }
    }

    /**
     * returns length of input vector
     *
     * Based on V3Length() in GGVecLib.c
     */
    double v2length(double v[]) {
        return Math.sqrt(v[0]*v[0] + v[1]*v[1]);
    }

    void render(Graphics g) {
        // The following is safe; xform will not be mutated below
        BaseTransform xform = g.getTransformNoClone();
        FilterContext fctx = PrFilterContext.getInstance(g.getAssociatedScreen()); // getFilterContext

        double[] xformInfo = unmatrix(xform);
        boolean isUnsupported = unsupported(xformInfo);

        lastXDelta = lastXDelta * xformInfo[0];
        lastYDelta = lastYDelta * xformInfo[1];

        if (cachedImageData != null) {
            Filterable implImage = cachedImageData.getUntransformedImage();
            if (implImage != null) {
                implImage.lock();
                if (!cachedImageData.validate(fctx)) {
                    implImage.unlock();
                    invalidate();
                }
            }
        }
        float pixelScaleX = g.getPixelScaleFactorX();
        float pixelScaleY = g.getPixelScaleFactorY();
        if (needToRenderCache(xform, xformInfo, pixelScaleX, pixelScaleY)) {
            if (PulseLogger.PULSE_LOGGING_ENABLED) {
                PulseLogger.incrementCounter(&quot;CacheFilter rebuilding&quot;);
            }
            if (cachedImageData != null) {
                Filterable implImage = cachedImageData.getUntransformedImage();
                if (implImage != null) {
                    implImage.unlock();
                }
                invalidate();
            }
            if (scaleHint) {
                // do not cache the image at a small scale factor when
                // scaleHint is set as it leads to poor rendering results
                // when image is scaled up.
                cachedScaleX = Math.max(pixelScaleX, xformInfo[0]);
                cachedScaleY = Math.max(pixelScaleY, xformInfo[1]);
                cachedRotate = 0;
                cachedXform.setTransform(cachedScaleX, 0.0,
                                         0.0, cachedScaleX,
                                         0.0, 0.0);
                updateScreenXform(xformInfo);
            } else {
                cachedScaleX = xformInfo[0];
                cachedScaleY = xformInfo[1];
                cachedRotate = xformInfo[2];

                // Update the cachedXform to the current xform (ignoring translate).
                cachedXform.setTransform(xform.getMxx(), xform.getMyx(),
                                         xform.getMxy(), xform.getMyy(),
                                         0.0, 0.0);

                // screenXform is always identity in this case, as we've just
                // rendered into the cache using the render xform.
                screenXform.setTransform(BaseTransform.IDENTITY_TRANSFORM);
            }

            cacheBounds = getCacheBounds(cacheBounds, cachedXform);
            cachedImageData = createImageData(fctx, cacheBounds);
            renderNodeToCache(cachedImageData, cacheBounds, cachedXform, null);

            // cachedBounds includes effects, and is in *scene* coords
            Rectangle cachedBounds = cachedImageData.getUntransformedBounds();

            // Save out the (un-transformed) x &amp; y coordinates.  This accounts
            // for effects and other reasons the untranslated location may not
            // be 0,0.
            cachedX = cachedBounds.x;
            cachedY = cachedBounds.y;

        } else {
            if (scrollCacheState == ScrollCacheState.ENABLED &amp;&amp;
                    (lastXDelta != 0 || lastYDelta != 0) ) {
                moveCacheBy(cachedImageData, lastXDelta, lastYDelta);
                renderNodeToCache(cachedImageData, cacheBounds, cachedXform, computeDirtyRegionForTranslate());
                lastXDelta = lastYDelta = 0;
            }
            // Using the cached image; calculate screenXform to paint to screen.
            if (isUnsupported) {
                // Only way we should be using the cached image in the
                // unsupported case is for a change in translate only.  No other
                // xform should be needed, so use identity.

                // TODO: assert cachedXform == render xform (ignoring translate)
                //   or  assert xforminfo == cachedXform info (RT-23962)
                screenXform.setTransform(BaseTransform.IDENTITY_TRANSFORM);
            } else {
                updateScreenXform(xformInfo);
            }
        }
        // If this render is unsupported, remember for next time.  We'll need
        // to regenerate the cache once we're in a supported scenario again.
        wasUnsupported = isUnsupported;

        Filterable implImage = cachedImageData.getUntransformedImage();
        if (implImage == null) {
            if (PulseLogger.PULSE_LOGGING_ENABLED) {
                PulseLogger.incrementCounter(&quot;CacheFilter not used&quot;);
            }
            renderNodeToScreen(g);
        } else {
            double mxt = xform.getMxt();
            double myt = xform.getMyt();
            renderCacheToScreen(g, implImage, mxt, myt);
            implImage.unlock();
        }
    }

    /**
     * Create the ImageData for the cached bitmap, with the specified bounds.
     */
    ImageData createImageData(FilterContext fctx, Rectangle bounds) {
        Filterable ret;
        try {
            ret = Effect.getCompatibleImage(fctx,
                    bounds.width, bounds.height);
            Texture cachedTex = ((PrDrawable) ret).getTextureObject();
            cachedTex.contentsUseful();
        } catch (Throwable e) {
            ret = null;
        }

        return new ImageData(fctx, ret, bounds);
    }

    /**
     * Render node to cache.
     * @param cacheData the cache
     * @param cacheBounds cache bounds
     * @param xform transformation
     * @param dirtyBounds null or dirty rectangle to be rendered
     */
    void renderNodeToCache(ImageData cacheData,
                                Rectangle cacheBounds,
                                BaseTransform xform,
                                Rectangle dirtyBounds) {
        final PrDrawable image = (PrDrawable) cacheData.getUntransformedImage();

        if (image != null) {
            Graphics g = image.createGraphics();
            TEMP_CACHEFILTER_TRANSFORM.setToIdentity();
            TEMP_CACHEFILTER_TRANSFORM.translate(-cacheBounds.x, -cacheBounds.y);
            if (xform != null) {
                TEMP_CACHEFILTER_TRANSFORM.concatenate(xform);
            }
            if (dirtyBounds != null) {
                TEMP_CONTAINER.deriveWithNewRegion((RectBounds)TEMP_BOUNDS.deriveWithNewBounds(dirtyBounds));
                // Culling might save us a lot when there's a dirty region
                node.doPreCulling(TEMP_CONTAINER, TEMP_CACHEFILTER_TRANSFORM, new GeneralTransform3D());
                g.setHasPreCullingBits(true);
                g.setClipRectIndex(0);
                g.setClipRect(dirtyBounds);
            }
            g.transform(TEMP_CACHEFILTER_TRANSFORM);
            if (node.getClipNode() != null) {
                node.renderClip(g);
            } else if (node.getEffectFilter() != null) {
                node.renderEffect(g);
            } else {
                node.renderContent(g);
            }
        }
    }

    /**
     * Render the node directly to the screen, in the case that the cached
     * image is unexpectedly null.  See RT-6428.
     */
    void renderNodeToScreen(Object implGraphics) {
        Graphics g = (Graphics)implGraphics;
        if (node.getEffectFilter() != null) {
            node.renderEffect(g);
        } else {
            node.renderContent(g);
        }
    }

    /**
     * Render the cached image to the screen, translated by mxt, myt.
     */
    void renderCacheToScreen(Object implGraphics, Filterable implImage,
                                  double mxt, double myt)
    {
        Graphics g = (Graphics)implGraphics;

        g.setTransform(screenXform.getMxx(),
                       screenXform.getMyx(),
                       screenXform.getMxy(),
                       screenXform.getMyy(),
                       mxt, myt);
        g.translate((float)cachedX, (float)cachedY);
        Texture cachedTex = ((PrDrawable)implImage).getTextureObject();
        Rectangle cachedBounds = cachedImageData.getUntransformedBounds();
        g.drawTexture(cachedTex, 0, 0,
                      cachedBounds.width, cachedBounds.height);
        // FYI: transform state is restored by the NGNode.render() method
    }

    /**
     * True if we can use scrolling optimization on this node.
     */
    boolean scrollCacheCapable() {
        if (!(node instanceof NGGroup)) {
            return false;
        }
        List&lt;NGNode&gt; children = ((NGGroup)node).getChildren();
        if (children.size() != 1) {
            return false;
        }
        NGNode child = children.get(0);
        if (!child.getTransform().is2D()) {
            return false;
        }

        NGNode clip = node.getClipNode();
        if (clip == null || !clip.isRectClip(BaseTransform.IDENTITY_TRANSFORM, false)) {
            return false;
        }

        if (node instanceof NGRegion) {
            NGRegion region = (NGRegion) node;
            if (!region.getBorder().isEmpty()) {
                return false;
            }
            final Background background = region.getBackground();

            if (!background.isEmpty()) {
                if (!background.getImages().isEmpty()
                        || background.getFills().size() != 1) {
                    return false;
                }
                BackgroundFill fill = background.getFills().get(0);
                javafx.scene.paint.Paint fillPaint = fill.getFill();
                BaseBounds clipBounds = clip.getCompleteBounds(TEMP_BOUNDS, BaseTransform.IDENTITY_TRANSFORM);

                return fillPaint.isOpaque() &amp;&amp; fillPaint instanceof Color &amp;&amp; fill.getInsets().equals(Insets.EMPTY)
                        &amp;&amp; clipBounds.getMinX() == 0 &amp;&amp; clipBounds.getMinY() == 0
                        &amp;&amp; clipBounds.getMaxX() == region.getWidth() &amp;&amp; clipBounds.getMaxY() == region.getHeight();
            }
        }

        return true;
    }

    /**
     * Moves a subregion of the cache, &quot;scrolling&quot; the cache by x/y Delta.
     * On of xDelta/yDelta must be zero. The rest of the pixels will be cleared.
     * @param cachedImageData cache
     * @param xDelta x-axis delta
     * @param yDelta y-axis delta
     */
    void moveCacheBy(ImageData cachedImageData, double xDelta, double yDelta) {
        PrDrawable drawable = (PrDrawable) cachedImageData.getUntransformedImage();
        final Rectangle r = cachedImageData.getUntransformedBounds();
        int x = (int)Math.max(0, (-xDelta));
        int y = (int)Math.max(0, (-yDelta));
        int destX = (int)Math.max(0, (xDelta));
        int destY = (int) Math.max(0, yDelta);
        int w = r.width - (int) Math.abs(xDelta);
        int h = r.height - (int) Math.abs(yDelta);

        final Graphics g = drawable.createGraphics();
        if (tempTexture != null) {
            tempTexture.lock();
            if (tempTexture.isSurfaceLost()) {
                tempTexture = null;
            }
        }
        if (tempTexture == null) {
            tempTexture = g.getResourceFactory().
                createRTTexture(drawable.getPhysicalWidth(), drawable.getPhysicalHeight(),
                                Texture.WrapMode.CLAMP_NOT_NEEDED);
        }
        final Graphics tempG = tempTexture.createGraphics();
        tempG.clear();
        tempG.drawTexture(drawable.getTextureObject(), 0, 0, w, h, x, y, x + w, y + h);
        tempG.sync();

        g.clear();
        g.drawTexture(tempTexture, destX, destY, destX + w, destY + h, 0, 0, w, h);
        tempTexture.unlock();
    }

    /**
     * Get the cache bounds.
     * @param bounds rectangle to store bounds to
     * @param xform transformation
     */
    Rectangle getCacheBounds(Rectangle bounds, BaseTransform xform) {
        final BaseBounds b = node.getClippedBounds(TEMP_BOUNDS, xform);
        bounds.setBounds(b);
        return bounds;
    }

    BaseBounds computeDirtyBounds(BaseBounds region, BaseTransform tx, GeneralTransform3D pvTx) {
        // For now, we just use the computed dirty bounds of the Node and
        // round them out before the transforms.
        // Later, we could use the bounds of the cache
        // to compute the dirty region directly (and more accurately).
        // See RT-34928 for more details.
        if (!node.dirtyBounds.isEmpty()) {
            region = region.deriveWithNewBounds(node.dirtyBounds);
        } else {
            region = region.deriveWithNewBounds(node.transformedBounds);
        }

        if (!region.isEmpty()) {
            region.roundOut();
            region = node.computePadding(region);
            region = tx.transform(region, region);
            region = pvTx.transform(region, region);
        }
        return region;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/sg/prism/NGCanvas.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.sg.prism;

import javafx.geometry.VPos;
import javafx.scene.text.Font;
import java.nio.IntBuffer;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;
import java.util.LinkedList;
import com.sun.javafx.font.PGFont;
import com.sun.javafx.geom.Arc2D;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.DirtyRegionContainer;
import com.sun.javafx.geom.DirtyRegionPool;
import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.PathIterator;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.RoundRectangle2D;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.javafx.scene.text.FontHelper;
import com.sun.javafx.text.PrismTextLayout;
import com.sun.javafx.tk.RenderJob;
import com.sun.javafx.tk.ScreenConfigurationAccessor;
import com.sun.javafx.tk.Toolkit;
import com.sun.prism.BasicStroke;
import com.sun.prism.CompositeMode;
import com.sun.prism.Graphics;
import com.sun.prism.GraphicsPipeline;
import com.sun.prism.Image;
import com.sun.prism.MaskTextureGraphics;
import com.sun.prism.PrinterGraphics;
import com.sun.prism.RTTexture;
import com.sun.prism.ResourceFactory;
import com.sun.prism.Texture;
import com.sun.prism.Texture.WrapMode;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.Paint;
import com.sun.scenario.effect.Blend;
import com.sun.scenario.effect.Blend.Mode;
import com.sun.scenario.effect.Effect;
import com.sun.scenario.effect.FilterContext;
import com.sun.scenario.effect.Filterable;
import com.sun.scenario.effect.ImageData;
import com.sun.scenario.effect.impl.prism.PrDrawable;
import com.sun.scenario.effect.impl.prism.PrFilterContext;
import com.sun.scenario.effect.impl.prism.PrTexture;
import javafx.scene.text.FontSmoothingType;

/**
 */
public class NGCanvas extends NGNode {
    public static final byte                 ATTR_BASE = 0;
    public static final byte GLOBAL_ALPHA  = ATTR_BASE + 0;
    public static final byte COMP_MODE     = ATTR_BASE + 1;
    public static final byte FILL_PAINT    = ATTR_BASE + 2;
    public static final byte STROKE_PAINT  = ATTR_BASE + 3;
    public static final byte LINE_WIDTH    = ATTR_BASE + 4;
    public static final byte LINE_CAP      = ATTR_BASE + 5;
    public static final byte LINE_JOIN     = ATTR_BASE + 6;
    public static final byte MITER_LIMIT   = ATTR_BASE + 7;
    public static final byte FONT          = ATTR_BASE + 8;
    public static final byte TEXT_ALIGN    = ATTR_BASE + 9;
    public static final byte TEXT_BASELINE = ATTR_BASE + 10;
    public static final byte TRANSFORM     = ATTR_BASE + 11;
    public static final byte EFFECT        = ATTR_BASE + 12;
    public static final byte PUSH_CLIP     = ATTR_BASE + 13;
    public static final byte POP_CLIP      = ATTR_BASE + 14;
    public static final byte ARC_TYPE      = ATTR_BASE + 15;
    public static final byte FILL_RULE     = ATTR_BASE + 16;
    public static final byte DASH_ARRAY    = ATTR_BASE + 17;
    public static final byte DASH_OFFSET   = ATTR_BASE + 18;
    public static final byte FONT_SMOOTH   = ATTR_BASE + 19;

    public static final byte                     OP_BASE = 20;
    public static final byte FILL_RECT         = OP_BASE + 0;
    public static final byte STROKE_RECT       = OP_BASE + 1;
    public static final byte CLEAR_RECT        = OP_BASE + 2;
    public static final byte STROKE_LINE       = OP_BASE + 3;
    public static final byte FILL_OVAL         = OP_BASE + 4;
    public static final byte STROKE_OVAL       = OP_BASE + 5;
    public static final byte FILL_ROUND_RECT   = OP_BASE + 6;
    public static final byte STROKE_ROUND_RECT = OP_BASE + 7;
    public static final byte FILL_ARC          = OP_BASE + 8;
    public static final byte STROKE_ARC        = OP_BASE + 9;
    public static final byte FILL_TEXT         = OP_BASE + 10;
    public static final byte STROKE_TEXT       = OP_BASE + 11;

    public static final byte                PATH_BASE = 40;
    public static final byte PATHSTART    = PATH_BASE + 0;
    public static final byte MOVETO       = PATH_BASE + 1;
    public static final byte LINETO       = PATH_BASE + 2;
    public static final byte QUADTO       = PATH_BASE + 3;
    public static final byte CUBICTO      = PATH_BASE + 4;
    public static final byte CLOSEPATH    = PATH_BASE + 5;
    public static final byte PATHEND      = PATH_BASE + 6;
    public static final byte FILL_PATH    = PATH_BASE + 7;
    public static final byte STROKE_PATH  = PATH_BASE + 8;

    public static final byte                   IMG_BASE = 50;
    public static final byte DRAW_IMAGE      = IMG_BASE + 0;
    public static final byte DRAW_SUBIMAGE   = IMG_BASE + 1;
    public static final byte PUT_ARGB        = IMG_BASE + 2;
    public static final byte PUT_ARGBPRE_BUF = IMG_BASE + 3;

    public static final byte                   FX_BASE = 60;
    public static final byte FX_APPLY_EFFECT = FX_BASE + 0;

    public static final byte                   UTIL_BASE = 70;
    public static final byte RESET           = UTIL_BASE + 0;
    public static final byte SET_DIMS        = UTIL_BASE + 1;

    public static final byte CAP_BUTT   = 0;
    public static final byte CAP_ROUND  = 1;
    public static final byte CAP_SQUARE = 2;

    public static final byte JOIN_MITER = 0;
    public static final byte JOIN_ROUND = 1;
    public static final byte JOIN_BEVEL = 2;

    public static final byte ARC_OPEN   = 0;
    public static final byte ARC_CHORD  = 1;
    public static final byte ARC_PIE    = 2;

    public static final byte SMOOTH_GRAY = (byte) FontSmoothingType.GRAY.ordinal();
    public static final byte SMOOTH_LCD  = (byte) FontSmoothingType.LCD.ordinal();

    public static final byte ALIGN_LEFT       = 0;
    public static final byte ALIGN_CENTER     = 1;
    public static final byte ALIGN_RIGHT      = 2;
<A NAME="24"></A>    public static final byte ALIGN_JUSTIFY    = 3;

    public static final byte BASE_TOP        = 0;
    <FONT color="#ada96e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#24',2,'match37-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>public static final byte BASE_MIDDLE     = 1;
    public static final byte BASE_ALPHABETIC = 2;
    public static final byte BASE_BOTTOM     = 3;

    public static final byte FILL_RULE_NON_ZERO = 0;
    public static final byte FILL_RULE_EVEN_ODD = 1;

    static enum InitType {
        CLEAR,
        FILL_WHITE,
        PRESERVE_UPPER_LEFT
    }</B></FONT>

    static class RenderBuf {
        final InitType init_type;
        RTTexture tex;
        Graphics g;
        EffectInput input;
        private PixelData savedPixelData = null;

        public RenderBuf(InitType init_type) {
            this.init_type = init_type;
        }

        public void dispose() {
            if (tex != null) tex.dispose();

            tex = null;
            g = null;
            input = null;
        }

        public boolean validate(Graphics resg, int tw, int th) {
            int cw, ch;
            boolean create;
            if (tex == null) {
                cw = ch = 0;
                create = true;
            } else {
                cw = tex.getContentWidth();
                ch = tex.getContentHeight();
                tex.lock();
                create = tex.isSurfaceLost() || cw &lt; tw || ch &lt; th;
            }
            if (create) {
                RTTexture oldtex = tex;
                ResourceFactory factory = (resg == null)
                    ? GraphicsPipeline.getDefaultResourceFactory()
                    : resg.getResourceFactory();
                RTTexture newtex =
                    factory.createRTTexture(tw, th, WrapMode.CLAMP_TO_ZERO);
                this.tex = newtex;
                this.g = newtex.createGraphics();
                this.input = new EffectInput(newtex);
                if (oldtex != null) {
                    if (init_type == InitType.PRESERVE_UPPER_LEFT) {
                        g.setCompositeMode(CompositeMode.SRC);
                        if (oldtex.isSurfaceLost()) {
                            if (savedPixelData != null) {
                                savedPixelData.restore(g, cw, ch);
                            }
                        } else {
                            g.drawTexture(oldtex, 0, 0, cw, ch);
                        }
                        g.setCompositeMode(CompositeMode.SRC_OVER);
                    }
                    oldtex.unlock();
                    oldtex.dispose();
                }
                if (init_type == InitType.FILL_WHITE) {
                    g.clear(Color.WHITE);
                }
                return true;
            } else {
                if (this.g == null) {
                    this.g = tex.createGraphics();
                    if (this.g == null) {
                        tex.dispose();
                        ResourceFactory factory = (resg == null)
                            ? GraphicsPipeline.getDefaultResourceFactory()
                            : resg.getResourceFactory();
                        tex = factory.createRTTexture(tw, th, WrapMode.CLAMP_TO_ZERO);
                        this.g = tex.createGraphics();
                        this.input = new EffectInput(tex);
                        if (savedPixelData != null) {
                            g.setCompositeMode(CompositeMode.SRC);
                            savedPixelData.restore(g, tw, th);
                            g.setCompositeMode(CompositeMode.SRC_OVER);
                        } else if (init_type == InitType.FILL_WHITE) {
                            g.clear(Color.WHITE);
                        }
                        return true;
                    }
                }
            }
            if (init_type == InitType.CLEAR) {
                g.clear();
            }
            return false;
        }

        private void save(int tw, int th) {
            if (tex.isVolatile()) {
                if (savedPixelData == null) {
                    savedPixelData = new PixelData(tw, th);
                }
                savedPixelData.save(tex);
            }
        }
    }

    // Saved pixel data used to preserve the image that backs the canvas if the
    // RTT is volatile.
    private static class PixelData {
        private IntBuffer pixels = null;
        private boolean validPixels = false;
        private int cw, ch;

        private PixelData(int cw, int ch) {
            this.cw = cw;
            this.ch = ch;
            pixels = IntBuffer.allocate(cw*ch);
        }

        private void save(RTTexture tex) {
            int tw = tex.getContentWidth();
            int th = tex.getContentHeight();
            if (cw &lt; tw || ch &lt; th) {
                cw = tw;
                ch = th;
                pixels = IntBuffer.allocate(cw*ch);
            }
            pixels.rewind();
            tex.readPixels(pixels);
            validPixels = true;
        }

        private void restore(Graphics g, int tw, int th) {
            if (validPixels) {
                Image img = Image.fromIntArgbPreData(pixels, tw, th);
                ResourceFactory factory = g.getResourceFactory();
                Texture tempTex =
                    factory.createTexture(img,
                                          Texture.Usage.DEFAULT,
                                          Texture.WrapMode.CLAMP_TO_EDGE);
                g.drawTexture(tempTex, 0, 0, tw, th);
                tempTex.dispose();
            }
        }
    }

    private static Blend BLENDER = new MyBlend(Mode.SRC_OVER, null, null);

    private GrowableDataBuffer thebuf;

    private final float highestPixelScale;
    private int tw, th;
    private int cw, ch;
    private RenderBuf cv;
    private RenderBuf temp;
    private RenderBuf clip;

    private float globalAlpha;
    private Blend.Mode blendmode;
    private Paint fillPaint, strokePaint;
    private float linewidth;
    private int linecap, linejoin;
    private float miterlimit;
    private double[] dashes;
    private float dashOffset;
    private BasicStroke stroke;
    private Path2D path;
    private NGText ngtext;
    private PrismTextLayout textLayout;
    private PGFont pgfont;
    private int smoothing;
    private int align;
    private int baseline;
    private Affine2D transform;
    private Affine2D inverseTransform;
    private boolean inversedirty;
    private LinkedList&lt;Path2D&gt; clipStack;
    private int clipsRendered;
    private boolean clipIsRect;
    private Rectangle clipRect;
    private Effect effect;
    private int arctype;

    static float TEMP_COORDS[] = new float[6];
    private static Arc2D TEMP_ARC = new Arc2D();
    private static RectBounds TEMP_RECTBOUNDS = new RectBounds();

    public NGCanvas() {
        Toolkit tk = Toolkit.getToolkit();
        ScreenConfigurationAccessor screenAccessor = tk.getScreenConfigurationAccessor();
        float hPS = 1.0f;
        for (Object screen : tk.getScreens()) {
            hPS = Math.max(screenAccessor.getRecommendedOutputScaleX(screen), hPS);
            hPS = Math.max(screenAccessor.getRecommendedOutputScaleY(screen), hPS);
        }
        highestPixelScale = (float) Math.ceil(hPS);

        cv = new RenderBuf(InitType.PRESERVE_UPPER_LEFT);
        temp = new RenderBuf(InitType.CLEAR);
        clip = new RenderBuf(InitType.FILL_WHITE);

        path = new Path2D();
        ngtext = new NGText();
        textLayout = new PrismTextLayout();
        transform = new Affine2D();
        clipStack = new LinkedList&lt;Path2D&gt;();
        initAttributes();
    }

    private void initAttributes() {
        globalAlpha = 1.0f;
        blendmode = Mode.SRC_OVER;
        fillPaint = Color.BLACK;
        strokePaint = Color.BLACK;
        linewidth = 1.0f;
        linecap = BasicStroke.CAP_SQUARE;
        linejoin = BasicStroke.JOIN_MITER;
        miterlimit = 10f;
        dashes = null;
        dashOffset = 0.0f;
        stroke = null;
        path.setWindingRule(Path2D.WIND_NON_ZERO);
        // ngtext stores no state between render operations
        // textLayout stores no state between render operations
        pgfont = (PGFont) FontHelper.getNativeFont(Font.getDefault());
        smoothing = SMOOTH_GRAY;
        align = ALIGN_LEFT;
        baseline = VPos.BASELINE.ordinal();
        transform.setToScale(highestPixelScale, highestPixelScale);
        clipStack.clear();
        resetClip(false);
    }

    static final Affine2D TEMP_PATH_TX = new Affine2D();
    static final int numCoords[] = { 2, 2, 4, 6, 0 };
    Shape untransformedPath = new Shape() {

        @Override
        public RectBounds getBounds() {
            if (transform.isTranslateOrIdentity()) {
                RectBounds rb = path.getBounds();
                if (transform.isIdentity()) {
                    return rb;
                } else {
                    float tx = (float) transform.getMxt();
                    float ty = (float) transform.getMyt();
                    return new RectBounds(rb.getMinX() - tx, rb.getMinY() - ty,
                                          rb.getMaxX() - tx, rb.getMaxY() - ty);
                }
            }
            // We could use Shape.accumulate, but that method optimizes the
            // bounds for curves and the optimized code above will simply ask
            // the path for its bounds - which in this case of a Path2D would
            // simply accumulate all of the coordinates in the buffer.  So,
            // we write a simpler accumulator loop here to be consistent with
            // the optimized case above.
            float x0 = Float.POSITIVE_INFINITY;
            float y0 = Float.POSITIVE_INFINITY;
            float x1 = Float.NEGATIVE_INFINITY;
            float y1 = Float.NEGATIVE_INFINITY;
            PathIterator pi = path.getPathIterator(getInverseTransform());
            while (!pi.isDone()) {
                int ncoords = numCoords[pi.currentSegment(TEMP_COORDS)];
                for (int i = 0; i &lt; ncoords; i += 2) {
                    if (x0 &gt; TEMP_COORDS[i+0]) x0 = TEMP_COORDS[i+0];
                    if (x1 &lt; TEMP_COORDS[i+0]) x1 = TEMP_COORDS[i+0];
                    if (y0 &gt; TEMP_COORDS[i+1]) y0 = TEMP_COORDS[i+1];
                    if (y1 &lt; TEMP_COORDS[i+1]) y1 = TEMP_COORDS[i+1];
                }
                pi.next();
            }
            return new RectBounds(x0, y0, x1, y1);
        }

        @Override
        public boolean contains(float x, float y) {
            TEMP_COORDS[0] = x;
            TEMP_COORDS[1] = y;
            transform.transform(TEMP_COORDS, 0, TEMP_COORDS, 0, 1);
            x = TEMP_COORDS[0];
            y = TEMP_COORDS[1];
            return path.contains(x, y);
        }

        @Override
        public boolean intersects(float x, float y, float w, float h) {
            if (transform.isTranslateOrIdentity()) {
                x += transform.getMxt();
                y += transform.getMyt();
                return path.intersects(x, y, w, h);
            }
            PathIterator pi = path.getPathIterator(getInverseTransform());
            int crossings = Shape.rectCrossingsForPath(pi, x, y, x+w, y+h);
            // int mask = (windingRule == WIND_NON_ZERO ? -1 : 2);
            // return (crossings == Shape.RECT_INTERSECTS ||
            //             (crossings &amp; mask) != 0);
            // with wind == NON_ZERO, then mask == -1 and
            // since REC_INTERSECTS != 0, we simplify to:
            return (crossings != 0);
        }

        @Override
        public boolean contains(float x, float y, float w, float h) {
            if (transform.isTranslateOrIdentity()) {
                x += transform.getMxt();
                y += transform.getMyt();
                return path.contains(x, y, w, h);
            }
            PathIterator pi = path.getPathIterator(getInverseTransform());
            int crossings = Shape.rectCrossingsForPath(pi, x, y, x+w, y+h);
            // int mask = (windingRule == WIND_NON_ZERO ? -1 : 2);
            // return (crossings != Shape.RECT_INTERSECTS &amp;&amp;
            //             (crossings &amp; mask) != 0);
            // with wind == NON_ZERO, then mask == -1 we simplify to:
            return (crossings != Shape.RECT_INTERSECTS &amp;&amp; crossings != 0);
        }

        public BaseTransform getCombinedTransform(BaseTransform tx) {
            if (transform.isIdentity()) return tx;
            if (transform.equals(tx)) return null;
            Affine2D inv = getInverseTransform();
            if (tx == null || tx.isIdentity()) return inv;
            TEMP_PATH_TX.setTransform(tx);
            TEMP_PATH_TX.concatenate(inv);
            return TEMP_PATH_TX;
        }

        @Override
        public PathIterator getPathIterator(BaseTransform tx) {
            return path.getPathIterator(getCombinedTransform(tx));
        }

        @Override
        public PathIterator getPathIterator(BaseTransform tx, float flatness) {
            return path.getPathIterator(getCombinedTransform(tx), flatness);
        }

        @Override
        public Shape copy() {
            throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
        }
    };

    private Affine2D getInverseTransform() {
        if (inverseTransform == null) {
            inverseTransform = new Affine2D();
            inversedirty = true;
        }
        if (inversedirty) {
            inverseTransform.setTransform(transform);
            try {
                inverseTransform.invert();
            } catch (NoninvertibleTransformException e) {
                inverseTransform.setToScale(0, 0);
            }
            inversedirty = false;
        }
        return inverseTransform;
    }

    @Override
    protected boolean hasOverlappingContents() {
        return true;
    }

    private static void shapebounds(Shape shape, RectBounds bounds,
                                    BaseTransform transform)
    {
        TEMP_COORDS[0] = TEMP_COORDS[1] = Float.POSITIVE_INFINITY;
        TEMP_COORDS[2] = TEMP_COORDS[3] = Float.NEGATIVE_INFINITY;
        Shape.accumulate(TEMP_COORDS, shape, transform);
        bounds.setBounds(TEMP_COORDS[0], TEMP_COORDS[1],
                         TEMP_COORDS[2], TEMP_COORDS[3]);
    }

    private static void strokebounds(BasicStroke stroke, Shape shape,
                                     RectBounds bounds, BaseTransform transform)
    {
        TEMP_COORDS[0] = TEMP_COORDS[1] = Float.POSITIVE_INFINITY;
        TEMP_COORDS[2] = TEMP_COORDS[3] = Float.NEGATIVE_INFINITY;
        stroke.accumulateShapeBounds(TEMP_COORDS, shape, transform);
        bounds.setBounds(TEMP_COORDS[0], TEMP_COORDS[1],
                            TEMP_COORDS[2], TEMP_COORDS[3]);
    }

    private static void runOnRenderThread(final Runnable r) {
        // We really need a standard mechanism to detect the render thread !
        if (Thread.currentThread().getName().startsWith(&quot;QuantumRenderer&quot;)) {
            r.run();
        } else {
            FutureTask&lt;Void&gt; f = new FutureTask&lt;Void&gt;(r, null);
            Toolkit.getToolkit().addRenderJob(new RenderJob(f));
            try {
                // block until job is complete
                f.get();
            } catch (ExecutionException ex) {
                throw new AssertionError(ex);
            } catch (InterruptedException ex) {
                // ignore; recovery is impossible
            }
        }
    }

    private boolean printedCanvas(Graphics g) {
       final RTTexture localTex = cv.tex;
       if (!(g instanceof PrinterGraphics) || localTex  == null) {
          return false;
        }
        ResourceFactory factory = g.getResourceFactory();
        boolean isCompatTex = factory.isCompatibleTexture(localTex);
        if (isCompatTex) {
            return false;
        }

        final int tw = localTex.getContentWidth();
        final int th = localTex.getContentHeight();
        final RTTexture tmpTex =
              factory.createRTTexture(tw, th, WrapMode.CLAMP_TO_ZERO);
        final Graphics texg = tmpTex.createGraphics();
        texg.setCompositeMode(CompositeMode.SRC);
        if (cv.savedPixelData == null) {
            final PixelData pd = new PixelData(cw, ch);
            runOnRenderThread(() -&gt; {
              pd.save(localTex);
              pd.restore(texg, tw, th);
            });
        } else {
            cv.savedPixelData.restore(texg, tw, th);
        }
        g.drawTexture(tmpTex, 0, 0, tw, th);
        tmpTex.unlock();
        tmpTex.dispose();
        return true;
    }

    @Override
    protected void renderContent(Graphics g) {
        if (printedCanvas(g)) return;
        initCanvas(g);
        if (cv.tex != null) {
            if (thebuf != null) {
                renderStream(thebuf);
                GrowableDataBuffer.returnBuffer(thebuf);
                thebuf = null;
            }
            float dw = tw / highestPixelScale;
            float dh = th / highestPixelScale;
            g.drawTexture(cv.tex,
                          0, 0, dw, dh,
                          0, 0, tw, th);
            // Must save the pixels every frame if RTT is volatile.
            cv.save(tw, th);
        }
        this.temp.g = this.clip.g = this.cv.g = null;
    }

    @Override
    public void renderForcedContent(Graphics gOptional) {
        if (thebuf != null) {
            initCanvas(gOptional);
            if (cv.tex != null) {
                renderStream(thebuf);
                GrowableDataBuffer.returnBuffer(thebuf);
                thebuf = null;
                cv.save(tw, th);
            }
            this.temp.g = this.clip.g = this.cv.g = null;
        }
    }

    private void initCanvas(Graphics g) {
        if (tw &lt;= 0 || th &lt;= 0) {
            cv.dispose();
            return;
        }
        if (cv.validate(g, tw, th)) {
            // If the texture was recreated then we add a permanent
            // &quot;useful&quot; and extra &quot;lock&quot; status to it.
            cv.tex.contentsUseful();
            cv.tex.makePermanent();
            cv.tex.lock();
        }
    }

    private void clearCanvas(int x, int y, int w, int h) {
        cv.g.setCompositeMode(CompositeMode.CLEAR);
        cv.g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
        cv.g.fillQuad(x, y, x+w, y+h);
        cv.g.setCompositeMode(CompositeMode.SRC_OVER);
    }

    private void resetClip(boolean andDispose) {
        if (andDispose) clip.dispose();
        clipsRendered = 0;
        clipIsRect = true;
        clipRect = null;
    }

    private static final float CLIPRECT_TOLERANCE = 1.0f / 256.0f;
    private static final Rectangle TEMP_RECT = new Rectangle();
    private boolean initClip() {
        boolean clipValidated;
        if (clipIsRect) {
            clipValidated = false;
        } else {
            clipValidated = true;
            if (clip.validate(cv.g, tw, th)) {
                clip.tex.contentsUseful();
                // Reset, but do not dispose - we just validated (and cleared) it...
                resetClip(false);
            }
        }
        int clipSize = clipStack.size();
        while (clipsRendered &lt; clipSize) {
            Path2D clippath = clipStack.get(clipsRendered++);
            if (clipIsRect) {
                if (clippath.checkAndGetIntRect(TEMP_RECT, CLIPRECT_TOLERANCE)) {
                    if (clipRect == null) {
                        clipRect = new Rectangle(TEMP_RECT);
                    } else {
                        clipRect.intersectWith(TEMP_RECT);
                    }
                    continue;
                }
                clipIsRect = false;
                if (!clipValidated) {
                    clipValidated = true;
                    if (clip.validate(cv.g, tw, th)) {
                        clip.tex.contentsUseful();
                        // No need to reset, this is our first fill.
                    }
                }
                if (clipRect != null) {
                    renderClip(new RoundRectangle2D(clipRect.x, clipRect.y,
                                                    clipRect.width, clipRect.height,
                                                    0, 0));
                }
            }
            shapebounds(clippath, TEMP_RECTBOUNDS, BaseTransform.IDENTITY_TRANSFORM);
            TEMP_RECT.setBounds(TEMP_RECTBOUNDS);
            if (clipRect == null) {
                clipRect = new Rectangle(TEMP_RECT);
            } else {
                clipRect.intersectWith(TEMP_RECT);
            }
            renderClip(clippath);
        }
        if (clipValidated &amp;&amp; clipIsRect) {
            clip.tex.unlock();
        }
        return !clipIsRect;
    }

    private void renderClip(Shape clippath) {
        temp.validate(cv.g, tw, th);
        temp.g.setPaint(Color.WHITE);
        temp.g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
        temp.g.fill(clippath);
        blendAthruBintoC(temp, Mode.SRC_IN, clip, null, CompositeMode.SRC, clip);
        temp.tex.unlock();
    }

    private Rectangle applyEffectOnAintoC(Effect definput,
                                          Effect effect,
                                          BaseTransform transform,
                                          Rectangle outputClip,
                                          CompositeMode comp,
                                          RenderBuf destbuf)
    {
        FilterContext fctx =
            PrFilterContext.getInstance(destbuf.tex.getAssociatedScreen());
        ImageData id =
            effect.filter(fctx, transform, outputClip, null, definput);
        Rectangle r = id.getUntransformedBounds();
        Filterable f = id.getUntransformedImage();
        Texture tex = ((PrTexture) f).getTextureObject();
        destbuf.g.setTransform(id.getTransform());
        destbuf.g.setCompositeMode(comp);
        destbuf.g.drawTexture(tex, r.x, r.y, r.width, r.height);
        destbuf.g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
        destbuf.g.setCompositeMode(CompositeMode.SRC_OVER);
        Rectangle resultBounds = id.getTransformedBounds(outputClip);
        id.unref();
        return resultBounds;
    }

    private void blendAthruBintoC(RenderBuf drawbuf,
                                  Mode mode,
                                  RenderBuf clipbuf,
                                  RectBounds bounds,
                                  CompositeMode comp,
                                  RenderBuf destbuf)
    {
        BLENDER.setTopInput(drawbuf.input);
        BLENDER.setBottomInput(clipbuf.input);
        BLENDER.setMode(mode);
        Rectangle blendclip;
        if (bounds != null) {
            blendclip = new Rectangle(bounds);
        } else {
            blendclip = null;
        }
        applyEffectOnAintoC(null, BLENDER,
                            BaseTransform.IDENTITY_TRANSFORM, blendclip,
                            comp, destbuf);
    }

    private void setupFill(Graphics gr) {
        gr.setPaint(fillPaint);
    }

    private BasicStroke getStroke() {
        if (stroke == null) {
            stroke = new BasicStroke(linewidth, linecap, linejoin,
                                     miterlimit, dashes, dashOffset);
        }
        return stroke;
    }

    private void setupStroke(Graphics gr) {
        gr.setStroke(getStroke());
        gr.setPaint(strokePaint);
    }

    private static final int prcaps[] = {
        BasicStroke.CAP_BUTT,
        BasicStroke.CAP_ROUND,
        BasicStroke.CAP_SQUARE,
    };
    private static final int prjoins[] = {
        BasicStroke.JOIN_MITER,
        BasicStroke.JOIN_ROUND,
        BasicStroke.JOIN_BEVEL,
    };
    private static final int prbases[] = {
        VPos.TOP.ordinal(),
        VPos.CENTER.ordinal(),
        VPos.BASELINE.ordinal(),
        VPos.BOTTOM.ordinal(),
    };
    private static final Affine2D TEMP_TX = new Affine2D();
    private void renderStream(GrowableDataBuffer buf) {
        while (buf.hasValues()) {
            int token = buf.getByte();
            switch (token) {
                case RESET:
                    initAttributes();
                    // RESET is always followed by SET_DIMS
                    // Setting cwh = twh avoids unnecessary double clears
                    this.cw = this.tw;
                    this.ch = this.th;
                    clearCanvas(0, 0, this.tw, this.th);
                    break;
                case SET_DIMS:
                    int neww = (int) Math.ceil(buf.getFloat() * highestPixelScale);
                    int newh = (int) Math.ceil(buf.getFloat() * highestPixelScale);
                    int clearx = Math.min(neww, this.cw);
                    int cleary = Math.min(newh, this.ch);
                    if (clearx &lt; this.tw) {
                        // tw is set to the final width, we simulate all of
                        // the intermediate changes in size by making sure
                        // that all pixels outside of any size change are
                        // cleared at the stream point where they happened
                        clearCanvas(clearx, 0, this.tw-clearx, this.th);
                    }
                    if (cleary &lt; this.th) {
                        // th is set to the final width, we simulate all of
                        // the intermediate changes in size by making sure
                        // that all pixels outside of any size change are
                        // cleared at the stream point where they happened
                        clearCanvas(0, cleary, this.tw, this.th-cleary);
                    }
                    this.cw = neww;
                    this.ch = newh;
                    break;
                case PATHSTART:
                    path.reset();
                    break;
                case MOVETO:
                    path.moveTo(buf.getFloat(), buf.getFloat());
                    break;
                case LINETO:
                    path.lineTo(buf.getFloat(), buf.getFloat());
                    break;
                case QUADTO:
                    path.quadTo(buf.getFloat(), buf.getFloat(),
                                buf.getFloat(), buf.getFloat());
                    break;
                case CUBICTO:
                    path.curveTo(buf.getFloat(), buf.getFloat(),
                                 buf.getFloat(), buf.getFloat(),
                                 buf.getFloat(), buf.getFloat());
                    break;
                case CLOSEPATH:
                    path.closePath();
                    break;
                case PATHEND:
                    if (highestPixelScale != 1.0f) {
                        TEMP_TX.setToScale(highestPixelScale, highestPixelScale);
                        path.transform(TEMP_TX);
                    }
                    break;
                case PUSH_CLIP:
                {
                    Path2D clippath = (Path2D) buf.getObject();
                    if (highestPixelScale != 1.0f) {
                        TEMP_TX.setToScale(highestPixelScale, highestPixelScale);
                        clippath.transform(TEMP_TX);
                    }
                    clipStack.addLast(clippath);
                    break;
                }
                case POP_CLIP:
                    // Let it be recreated when next needed
                    resetClip(true);
                    clipStack.removeLast();
                    break;
                case ARC_TYPE:
                {
                    byte type = buf.getByte();
                    switch (type) {
                        case ARC_OPEN:  arctype = Arc2D.OPEN;  break;
                        case ARC_CHORD: arctype = Arc2D.CHORD; break;
                        case ARC_PIE:   arctype = Arc2D.PIE;   break;
                    }
                    break;
                }
                case PUT_ARGB:
                {
                    float dx1 = buf.getInt();
                    float dy1 = buf.getInt();
                    int argb = buf.getInt();
                    Graphics gr = cv.g;
                    gr.setExtraAlpha(1.0f);
                    gr.setCompositeMode(CompositeMode.SRC);
                    gr.setTransform(BaseTransform.IDENTITY_TRANSFORM);
                    dx1 *= highestPixelScale;
                    dy1 *= highestPixelScale;
                    float a = ((argb) &gt;&gt;&gt; 24) / 255.0f;
                    float r = (((argb) &gt;&gt; 16) &amp; 0xff) / 255.0f;
                    float g = (((argb) &gt;&gt;  8) &amp; 0xff) / 255.0f;
                    float b = (((argb)      ) &amp; 0xff) / 255.0f;
                    gr.setPaint(new Color(r, g, b, a));
                    // Note that we cannot use fillRect here because SRC
                    // mode does not interact well with antialiasing.
                    // fillQuad does hard edges which matches the concept
                    // of setting adjacent abutting, non-overlapping &quot;pixels&quot;
                    gr.fillQuad(dx1, dy1, dx1+highestPixelScale, dy1+highestPixelScale);
                    gr.setCompositeMode(CompositeMode.SRC_OVER);
                    break;
                }
                case PUT_ARGBPRE_BUF:
                {
                    float dx1 = buf.getInt();
                    float dy1 = buf.getInt();
                    int w  = buf.getInt();
                    int h  = buf.getInt();
                    byte[] data = (byte[]) buf.getObject();
                    Image img = Image.fromByteBgraPreData(data, w, h);
                    Graphics gr = cv.g;
                    ResourceFactory factory = gr.getResourceFactory();
                    Texture tex =
                        factory.getCachedTexture(img, Texture.WrapMode.CLAMP_TO_EDGE);
                    gr.setTransform(BaseTransform.IDENTITY_TRANSFORM);
                    gr.setCompositeMode(CompositeMode.SRC);
                    float dx2 = dx1 + w;
                    float dy2 = dy1 + h;
                    dx1 *= highestPixelScale;
                    dy1 *= highestPixelScale;
                    dx2 *= highestPixelScale;
                    dy2 *= highestPixelScale;
                    gr.drawTexture(tex,
                                   dx1, dy1, dx2, dy2,
                                   0, 0, w, h);
                    tex.contentsNotUseful();
                    tex.unlock();
                    gr.setCompositeMode(CompositeMode.SRC_OVER);
                    break;
                }
                case TRANSFORM:
                {
                    double mxx = buf.getDouble() * highestPixelScale;
                    double mxy = buf.getDouble() * highestPixelScale;
                    double mxt = buf.getDouble() * highestPixelScale;
                    double myx = buf.getDouble() * highestPixelScale;
                    double myy = buf.getDouble() * highestPixelScale;
                    double myt = buf.getDouble() * highestPixelScale;
                    transform.setTransform(mxx, myx, mxy, myy, mxt, myt);
                    inversedirty = true;
                    break;
                }
                case GLOBAL_ALPHA:
                    globalAlpha = buf.getFloat();
                    break;
                case FILL_RULE:
                    if (buf.getByte() == FILL_RULE_NON_ZERO) {
                        path.setWindingRule(Path2D.WIND_NON_ZERO);
                    } else {
                        path.setWindingRule(Path2D.WIND_EVEN_ODD);
                    }
                    break;
                case COMP_MODE:
                    blendmode = (Blend.Mode)buf.getObject();
                    break;
                case FILL_PAINT:
                    fillPaint = (Paint) buf.getObject();
                    break;
                case STROKE_PAINT:
                    strokePaint = (Paint) buf.getObject();
                    break;
                case LINE_WIDTH:
                    linewidth = buf.getFloat();
                    stroke = null;
                    break;
                case LINE_CAP:
                    linecap = prcaps[buf.getUByte()];
                    stroke = null;
                    break;
                case LINE_JOIN:
                    linejoin = prjoins[buf.getUByte()];
                    stroke = null;
                    break;
                case MITER_LIMIT:
                    miterlimit = buf.getFloat();
                    stroke = null;
                    break;
                case DASH_ARRAY:
                    dashes = (double[]) buf.getObject();
                    stroke = null;
                    break;
                case DASH_OFFSET:
                    dashOffset = buf.getFloat();
                    stroke = null;
                    break;
                case FONT:
                    pgfont = (PGFont) buf.getObject();
                    break;
                case FONT_SMOOTH:
                    smoothing = buf.getUByte();
                    break;
                case TEXT_ALIGN:
                    align = buf.getUByte();
                    break;
                case TEXT_BASELINE:
                    baseline = prbases[buf.getUByte()];
                    break;
                case FX_APPLY_EFFECT:
                {
                    Effect e = (Effect) buf.getObject();
                    RenderBuf dest = clipStack.isEmpty() ? cv : temp;
                    BaseTransform tx;
                    if (highestPixelScale != 1.0f) {
                        TEMP_TX.setToScale(highestPixelScale, highestPixelScale);
                        tx = TEMP_TX;
                        cv.input.setPixelScale(highestPixelScale);
                    } else {
                        tx = BaseTransform.IDENTITY_TRANSFORM;
                    }
                    applyEffectOnAintoC(cv.input, e,
                                        tx, null,
                                        CompositeMode.SRC, dest);
                    cv.input.setPixelScale(1.0f);
                    if (dest != cv) {
                        blendAthruBintoC(dest, Mode.SRC_IN, clip,
                                         null, CompositeMode.SRC, cv);
                    }
                    break;
                }
                case EFFECT:
                    effect = (Effect) buf.getObject();
                    break;
                case FILL_PATH:
                case STROKE_PATH:
                case STROKE_LINE:
                case FILL_RECT:
                case CLEAR_RECT:
                case STROKE_RECT:
                case FILL_OVAL:
                case STROKE_OVAL:
                case FILL_ROUND_RECT:
                case STROKE_ROUND_RECT:
                case FILL_ARC:
                case STROKE_ARC:
                case DRAW_IMAGE:
                case DRAW_SUBIMAGE:
                case FILL_TEXT:
                case STROKE_TEXT:
                {
                    RenderBuf dest;
                    boolean tempvalidated;
                    boolean clipvalidated = initClip();
                    if (clipvalidated) {
                        temp.validate(cv.g, tw, th);
                        tempvalidated = true;
                        dest = temp;
                    } else if (blendmode != Blend.Mode.SRC_OVER) {
                        temp.validate(cv.g, tw, th);
                        tempvalidated = true;
                        dest = temp;
                    } else {
                        tempvalidated = false;
                        dest = cv;
                    }
                    if (effect != null) {
                        buf.save();
                        handleRenderOp(token, buf, null, TEMP_RECTBOUNDS);
                        RenderInput ri =
                            new RenderInput(token, buf, transform, TEMP_RECTBOUNDS);
                        // If we are rendering to cv then we need the results of
                        // the effect to be applied &quot;SRC_OVER&quot; onto the canvas.
                        // If we are rendering to temp then either SRC or SRC_OVER
                        // would work since we know it would have been freshly
                        // erased above, but using the more common SRC_OVER may save
                        // having to update the hardware blend equations.
                        Rectangle resultBounds =
                            applyEffectOnAintoC(ri, effect,
                                                transform, clipRect,
                                                CompositeMode.SRC_OVER, dest);
                        if (dest != cv) {
                            TEMP_RECTBOUNDS.setBounds(resultBounds.x, resultBounds.y,
                                                      resultBounds.x + resultBounds.width,
                                                      resultBounds.y + resultBounds.height);
                        }
                    } else {
                        Graphics g = dest.g;
                        g.setExtraAlpha(globalAlpha);
                        g.setTransform(transform);
                        g.setClipRect(clipRect);
                        // If we are not rendering directly to the canvas then
                        // we need to save the bounds for the later stages.
                        RectBounds optSaveBounds =
                            (dest != cv) ? TEMP_RECTBOUNDS : null;
                        handleRenderOp(token, buf, g, optSaveBounds);
                        g.setClipRect(null);
                    }
                    if (clipvalidated) {
                        CompositeMode compmode;
                        if (blendmode == Blend.Mode.SRC_OVER) {
                            // For the SRC_OVER case we can point the clip
                            // operation directly to the screen with the Prism
                            // SRC_OVER composite mode.
                            dest = cv;
                            compmode = CompositeMode.SRC_OVER;
                        } else {
                            // Here we are blending the rendered pixels that
                            // were output to the temp buffer above against the
                            // pixels of the canvas and we need to put them
                            // back into the temp buffer.  We must use SRC
                            // mode here so that the erased (or reduced) pixels
                            // actually get reduced to their new alpha.
                            // assert: dest == temp;
                            compmode = CompositeMode.SRC;
                        }
                        if (clipRect != null) {
                            TEMP_RECTBOUNDS.intersectWith(clipRect);
                        }
                        if (!TEMP_RECTBOUNDS.isEmpty()) {
                            if (dest == cv &amp;&amp; cv.g instanceof MaskTextureGraphics) {
                                MaskTextureGraphics mtg = (MaskTextureGraphics) cv.g;
                                int dx = (int) Math.floor(TEMP_RECTBOUNDS.getMinX());
                                int dy = (int) Math.floor(TEMP_RECTBOUNDS.getMinY());
                                int dw = (int) Math.ceil(TEMP_RECTBOUNDS.getMaxX()) - dx;
                                int dh = (int) Math.ceil(TEMP_RECTBOUNDS.getMaxY()) - dy;
                                mtg.drawPixelsMasked(temp.tex, clip.tex,
                                                     dx, dy, dw, dh,
                                                     dx, dy, dx, dy);
                            } else {
                                blendAthruBintoC(temp, Mode.SRC_IN, clip,
                                                 TEMP_RECTBOUNDS, compmode, dest);
                            }
                        }
                    }
                    if (blendmode != Blend.Mode.SRC_OVER) {
                        // We always use SRC mode here because the results of
                        // the blend operation are final and must replace
                        // the associated pixel in the canvas with no further
                        // blending math.
                        if (clipRect != null) {
                            TEMP_RECTBOUNDS.intersectWith(clipRect);
                        }
                        blendAthruBintoC(temp, blendmode, cv,
                                         TEMP_RECTBOUNDS, CompositeMode.SRC, cv);
                    }
                    if (clipvalidated) {
                        clip.tex.unlock();
                    }
                    if (tempvalidated) {
                        temp.tex.unlock();
                    }
                    break;
                }
                default:
                    throw new InternalError(&quot;Unrecognized PGCanvas token: &quot;+token);
            }
        }
    }

    /**
     * Calculate bounds and/or render one single rendering operation.
     * All of the data for the rendering operation should be consumed
     * so that the buffer is left at the next token in the stream.
     *
     * @param token the stream token for the rendering op
     * @param buf the GrowableDataBuffer to get rendering info from
     * @param gr  the Graphics to render to, if not null
     * @param bounds the RectBounds to accumulate bounds into, if not null
     */
    public void handleRenderOp(int token, GrowableDataBuffer buf,
                               Graphics gr, RectBounds bounds)
    {
        boolean strokeBounds = false;
        boolean transformBounds = false;
        switch (token) {
            case FILL_PATH:
            {
                if (bounds != null) {
                    shapebounds(path, bounds, BaseTransform.IDENTITY_TRANSFORM);
                }
                if (gr != null) {
                    setupFill(gr);
                    gr.fill(untransformedPath);
                }
                break;
            }
            case STROKE_PATH:
            {
                if (bounds != null) {
                    strokebounds(getStroke(), untransformedPath, bounds, transform);
                }
                if (gr != null) {
                    setupStroke(gr);
                    gr.draw(untransformedPath);
                }
                break;
            }
            case STROKE_LINE:
            {
                float x1 = buf.getFloat();
                float y1 = buf.getFloat();
                float x2 = buf.getFloat();
                float y2 = buf.getFloat();
                if (bounds != null) {
                    bounds.setBoundsAndSort(x1, y1, x2, y2);
                    strokeBounds = true;
                    transformBounds = true;
                }
                if (gr != null) {
                    setupStroke(gr);
                    gr.drawLine(x1, y1, x2, y2);
                }
                break;
            }
            case STROKE_RECT:
            case STROKE_OVAL:
                strokeBounds = true;
            case FILL_RECT:
            case CLEAR_RECT:
            case FILL_OVAL:
            {
                float x = buf.getFloat();
                float y = buf.getFloat();
                float w = buf.getFloat();
                float h = buf.getFloat();
                if (bounds != null) {
                    bounds.setBounds(x, y, x+w, y+h);
                    transformBounds = true;
                }
                if (gr != null) {
                    switch (token) {
                        case FILL_RECT:
                            setupFill(gr);
                            gr.fillRect(x, y, w, h);
                            break;
                        case FILL_OVAL:
                            setupFill(gr);
                            gr.fillEllipse(x, y, w, h);
                            break;
                        case STROKE_RECT:
                            setupStroke(gr);
                            gr.drawRect(x, y, w, h);
                            break;
                        case STROKE_OVAL:
                            setupStroke(gr);
                            gr.drawEllipse(x, y, w, h);
                            break;
                        case CLEAR_RECT:
                            gr.setCompositeMode(CompositeMode.CLEAR);
                            gr.fillRect(x, y, w, h);
                            gr.setCompositeMode(CompositeMode.SRC_OVER);
                            break;
                    }
                }
                break;
            }
            case STROKE_ROUND_RECT:
                strokeBounds = true;
            case FILL_ROUND_RECT:
            {
                float x = buf.getFloat();
                float y = buf.getFloat();
                float w = buf.getFloat();
                float h = buf.getFloat();
                float aw = buf.getFloat();
                float ah = buf.getFloat();
                if (bounds != null) {
                    bounds.setBounds(x, y, x+w, y+h);
                    transformBounds = true;
                }
                if (gr != null) {
                    if (token == FILL_ROUND_RECT) {
                        setupFill(gr);
                        gr.fillRoundRect(x, y, w, h, aw, ah);
                    } else {
                        setupStroke(gr);
                        gr.drawRoundRect(x, y, w, h, aw, ah);
                    }
                }
                break;
            }
            case FILL_ARC:
            case STROKE_ARC:
            {
                float x = buf.getFloat();
                float y = buf.getFloat();
                float w = buf.getFloat();
                float h = buf.getFloat();
                float as = buf.getFloat();
                float ae = buf.getFloat();
                TEMP_ARC.setArc(x, y, w, h, as, ae, arctype);
                if (token == FILL_ARC) {
                    if (bounds != null) {
                        shapebounds(TEMP_ARC, bounds, transform);
                    }
                    if (gr != null) {
                        setupFill(gr);
                        gr.fill(TEMP_ARC);
                    }
                } else {
                    if (bounds != null) {
                        strokebounds(getStroke(), TEMP_ARC, bounds, transform);
                    }
                    if (gr != null) {
                        setupStroke(gr);
                        gr.draw(TEMP_ARC);
                    }
                }
                break;
            }
            case DRAW_IMAGE:
            case DRAW_SUBIMAGE:
            {
                float dx = buf.getFloat();
                float dy = buf.getFloat();
                float dw = buf.getFloat();
                float dh = buf.getFloat();
                Image img = (Image) buf.getObject();
                float sx, sy, sw, sh;
                if (token == DRAW_IMAGE) {
                    sx = sy = 0f;
                    sw = img.getWidth();
                    sh = img.getHeight();
                } else {
                    sx = buf.getFloat();
                    sy = buf.getFloat();
                    sw = buf.getFloat();
                    sh = buf.getFloat();
                    float ps = img.getPixelScale();
                    if (ps != 1.0f) {
                        sx *= ps;
                        sy *= ps;
                        sw *= ps;
                        sh *= ps;
                    }
                }
                if (bounds != null) {
                    bounds.setBounds(dx, dy, dx+dw, dy+dh);
                    transformBounds = true;
                }
                if (gr != null) {
                    ResourceFactory factory = gr.getResourceFactory();
                    Texture tex =
                        factory.getCachedTexture(img, Texture.WrapMode.CLAMP_TO_EDGE);
                    gr.drawTexture(tex,
                                   dx, dy, dx+dw, dy+dh,
                                   sx, sy, sx+sw, sy+sh);
                    tex.unlock();
                }
                break;
            }
            case FILL_TEXT:
            case STROKE_TEXT:
            {
                float x = buf.getFloat();
                float y = buf.getFloat();
                float maxWidth = buf.getFloat();
                boolean rtl = buf.getBoolean();
                String string = (String) buf.getObject();
                int dir = rtl ? PrismTextLayout.DIRECTION_RTL :
                                PrismTextLayout.DIRECTION_LTR;

                textLayout.setContent(string, pgfont);
                textLayout.setAlignment(align);
                textLayout.setDirection(dir);
                float xAlign = 0, yAlign = 0;
                BaseBounds layoutBounds = textLayout.getBounds();
                float layoutWidth = layoutBounds.getWidth();
                float layoutHeight = layoutBounds.getHeight();
                switch (align) {
                    case ALIGN_RIGHT: xAlign = layoutWidth; break;
                    case ALIGN_CENTER: xAlign = layoutWidth / 2; break;
                }
                switch (baseline) {
                    case BASE_ALPHABETIC: yAlign = -layoutBounds.getMinY(); break;
                    case BASE_MIDDLE: yAlign = layoutHeight / 2; break;
                    case BASE_BOTTOM: yAlign = layoutHeight; break;
                }
                float scaleX = 1;
                float layoutX = 0;
                float layoutY = y - yAlign;
                if (maxWidth &gt; 0.0 &amp;&amp; layoutWidth &gt; maxWidth) {
                    float sx = maxWidth / layoutWidth;
                    if (rtl) {
                        layoutX = -((x + maxWidth) / sx - xAlign);
                        scaleX = -sx;
                    } else {
                        layoutX = x / sx - xAlign;
                        scaleX = sx;
                    }
                } else {
                    if (rtl) {
                        layoutX = -(x - xAlign + layoutWidth);
                        scaleX = -1;
                    } else {
                        layoutX = x - xAlign;
                    }
                }
                if (bounds != null) {
                    computeTextLayoutBounds(bounds, transform, scaleX, layoutX, layoutY, token);
                }
                if (gr != null) {
                    if (scaleX != 1) {
                        gr.scale(scaleX, 1);
                    }
                    ngtext.setLayoutLocation(-layoutX, -layoutY);
                    if (token == FILL_TEXT) {
                        ngtext.setMode(NGShape.Mode.FILL);
                        ngtext.setFillPaint(fillPaint);
                        if (fillPaint.isProportional() || smoothing == SMOOTH_LCD) {
                            RectBounds textBounds = new RectBounds();
                            computeTextLayoutBounds(textBounds, BaseTransform.IDENTITY_TRANSFORM,
                                                    1, layoutX, layoutY, token);
                            ngtext.setContentBounds(textBounds);
                        }
                    } else {
                        // SMOOTH_LCD does not apply to stroked text
                        if (strokePaint.isProportional() /* || smoothing == SMOOTH_LCD */) {
                            RectBounds textBounds = new RectBounds();
                            computeTextLayoutBounds(textBounds, BaseTransform.IDENTITY_TRANSFORM,
                                                    1, layoutX, layoutY, token);
                            ngtext.setContentBounds(textBounds);
                        }
                        ngtext.setMode(NGShape.Mode.STROKE);
                        ngtext.setDrawStroke(getStroke());
                        ngtext.setDrawPaint(strokePaint);
                    }
                    ngtext.setFont(pgfont);
                    ngtext.setFontSmoothingType(smoothing);
                    ngtext.setGlyphs(textLayout.getRuns());
                    ngtext.renderContent(gr);
                }
                break;
            }
            default:
                throw new InternalError(&quot;Unrecognized PGCanvas rendering token: &quot;+token);
        }
        if (bounds != null) {
            if (strokeBounds) {
                BasicStroke s = getStroke();
                if (s.getType() != BasicStroke.TYPE_INNER) {
                    float lw = s.getLineWidth();
                    if (s.getType() == BasicStroke.TYPE_CENTERED) {
                        lw /= 2f;
                    }
                    bounds.grow(lw, lw);
                }
            }
            if (transformBounds) {
                txBounds(bounds, transform);
            }
        }
    }

    void computeTextLayoutBounds(RectBounds bounds, BaseTransform transform,
                                 float scaleX, float layoutX, float layoutY,
                                 int token)
    {
        textLayout.getBounds(null, bounds);
        TEMP_TX.setTransform(transform);
        TEMP_TX.scale(scaleX, 1);
        TEMP_TX.translate(layoutX, layoutY);
        TEMP_TX.transform(bounds, bounds);
        if (token == STROKE_TEXT) {
            int flag = PrismTextLayout.TYPE_TEXT;
            Shape textShape = textLayout.getShape(flag, null);
            RectBounds shapeBounds = new RectBounds();
            strokebounds(getStroke(), textShape, shapeBounds, TEMP_TX);
            bounds.unionWith(shapeBounds);
        }
    }

    static void txBounds(RectBounds bounds, BaseTransform transform) {
        switch (transform.getType()) {
            case BaseTransform.TYPE_IDENTITY:
                break;
            case BaseTransform.TYPE_TRANSLATION:
                float tx = (float) transform.getMxt();
                float ty = (float) transform.getMyt();
                bounds.setBounds(bounds.getMinX() + tx, bounds.getMinY() + ty,
                                 bounds.getMaxX() + tx, bounds.getMaxY() + ty);
                break;
            default:
                BaseBounds txbounds = transform.transform(bounds, bounds);
                if (txbounds != bounds) {
                    bounds.setBounds(txbounds.getMinX(), txbounds.getMinY(),
                                     txbounds.getMaxX(), txbounds.getMaxY());
                }
                break;
        }
    }

    static void inverseTxBounds(RectBounds bounds, BaseTransform transform) {
        switch (transform.getType()) {
            case BaseTransform.TYPE_IDENTITY:
                break;
            case BaseTransform.TYPE_TRANSLATION:
                float tx = (float) transform.getMxt();
                float ty = (float) transform.getMyt();
                bounds.setBounds(bounds.getMinX() - tx, bounds.getMinY() - ty,
                                 bounds.getMaxX() - tx, bounds.getMaxY() - ty);
                break;
            default:
                try {
                    BaseBounds txbounds = transform.inverseTransform(bounds, bounds);
                    if (txbounds != bounds) {
                        bounds.setBounds(txbounds.getMinX(), txbounds.getMinY(),
                                        txbounds.getMaxX(), txbounds.getMaxY());
                    }
                } catch (NoninvertibleTransformException e) {
                    bounds.makeEmpty();
                }
                break;
        }
    }

    public void updateBounds(float w, float h) {
        this.tw = (int) Math.ceil(w * highestPixelScale);
        this.th = (int) Math.ceil(h * highestPixelScale);
        geometryChanged();
    }

    // Returns true if we are falling behind in rendering (i.e. we
    // have unrendered data at the time of the synch.  This tells
    // the FX layer that it should consider emitting a RESET if it
    // detects a full-canvas clear command even if it looks like it
    // is superfluous.
    public boolean updateRendering(GrowableDataBuffer buf) {
        if (buf.isEmpty()) {
            GrowableDataBuffer.returnBuffer(buf);
            return (this.thebuf != null);
        }
        boolean reset = (buf.peekByte(0) == RESET);
        GrowableDataBuffer retbuf;
        if (reset || this.thebuf == null) {
            retbuf = this.thebuf;
            this.thebuf = buf;
        } else {
            this.thebuf.append(buf);
            retbuf = buf;
        }
        geometryChanged();
        if (retbuf != null) {
            GrowableDataBuffer.returnBuffer(retbuf);
            return true;
        }
        return false;
    }

    class RenderInput extends Effect {
        float x, y, w, h;
        int token;
        GrowableDataBuffer buf;
        Affine2D savedBoundsTx = new Affine2D();

        public RenderInput(int token, GrowableDataBuffer buf,
                           BaseTransform boundsTx, RectBounds rb)
        {
            this.token = token;
            this.buf = buf;
            savedBoundsTx.setTransform(boundsTx);
            this.x = rb.getMinX();
            this.y = rb.getMinY();
            this.w = rb.getWidth();
            this.h = rb.getHeight();
        }

        @Override
        public ImageData filter(FilterContext fctx, BaseTransform transform,
                                Rectangle outputClip, Object renderHelper,
                                Effect defaultInput)
        {
            BaseBounds bounds = getBounds(transform, defaultInput);
            if (outputClip != null) {
                bounds.intersectWith(outputClip);
            }
            Rectangle r = new Rectangle(bounds);
            if (r.width &lt; 1) r.width = 1;
            if (r.height &lt; 1) r.height = 1;
            PrDrawable ret = (PrDrawable) Effect.getCompatibleImage(fctx, r.width, r.height);
            if (ret != null) {
                Graphics g = ret.createGraphics();
                g.setExtraAlpha(globalAlpha);
                g.translate(-r.x, -r.y);
                if (transform != null) {
                    g.transform(transform);
                }
                buf.restore();
                handleRenderOp(token, buf, g, null);
            }
            return new ImageData(fctx, ret, r);
        }

        @Override
        public AccelType getAccelType(FilterContext fctx) {
            throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
        }

        @Override
        public BaseBounds getBounds(BaseTransform transform, Effect defaultInput) {
            RectBounds ret = new RectBounds(x, y, x + w, y + h);
            if (!transform.equals(savedBoundsTx)) {
                inverseTxBounds(ret, savedBoundsTx);
                txBounds(ret, transform);
            }
            return ret;
        }

        @Override
        public boolean reducesOpaquePixels() {
            return false;
        }

        @Override
        public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
            return null; // Never called
        }

    }

    static class MyBlend extends Blend {
        public MyBlend(Mode mode, Effect bottomInput, Effect topInput) {
            super(mode, bottomInput, topInput);
        }

        @Override
        public Rectangle getResultBounds(BaseTransform transform,
                                         Rectangle outputClip,
                                         ImageData... inputDatas)
        {
            // There is a bug in the ImageData class that means that the
            // outputClip will not be taken into account, so we override
            // here and apply it ourselves.
            Rectangle r = super.getResultBounds(transform, outputClip, inputDatas);
            r.intersectWith(outputClip);
            return r;
        }
    }

    static class EffectInput extends Effect {
        RTTexture tex;
        float pixelscale;

        EffectInput(RTTexture tex) {
            this.tex = tex;
            this.pixelscale = 1.0f;
        }

        public void setPixelScale(float scale) {
            this.pixelscale = scale;
        }

        @Override
        public ImageData filter(FilterContext fctx, BaseTransform transform,
                                Rectangle outputClip, Object renderHelper,
                                Effect defaultInput)
        {
            Filterable f = PrDrawable.create(fctx, tex);
            Rectangle r = new Rectangle(tex.getContentWidth(), tex.getContentHeight());
            f.lock();
            ImageData id = new ImageData(fctx, f, r);
            id.setReusable(true);
            if (pixelscale != 1.0f || !transform.isIdentity()) {
                Affine2D a2d = new Affine2D();
                a2d.scale(1.0f / pixelscale, 1.0f / pixelscale);
                a2d.concatenate(transform);
                id = id.transform(a2d);
            }
            return id;
        }

        @Override
        public AccelType getAccelType(FilterContext fctx) {
            throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
        }

        @Override
        public BaseBounds getBounds(BaseTransform transform, Effect defaultInput) {
            Rectangle r = new Rectangle(tex.getContentWidth(), tex.getContentHeight());
            return transformBounds(transform, new RectBounds(r));
        }

        @Override
        public boolean reducesOpaquePixels() {
            return false;
        }

        @Override
        public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
            return null; // Never called
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/sg/prism/NGExternalNode.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.sg.prism;

import java.nio.Buffer;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.ReentrantLock;
import com.sun.javafx.geom.Rectangle;
import com.sun.prism.Graphics;
import com.sun.prism.PixelFormat;
import com.sun.prism.ResourceFactory;
import com.sun.prism.Texture;

public class NGExternalNode extends NGNode {

    private Texture dsttexture;

    private BufferData bufferData;
    private final AtomicReference&lt;RenderData&gt; renderData = new AtomicReference&lt;RenderData&gt;(null);
    private RenderData rd; // last rendered data

    private volatile ReentrantLock bufferLock;

    @Override
    protected void renderContent(Graphics g) {

        RenderData curRenderData = renderData.getAndSet(null);

        if (curRenderData != null) {
            rd = curRenderData;
        }
        if (rd == null) return;

        int x = rd.bdata.srcbounds.x;
        int y = rd.bdata.srcbounds.y;
        int w = rd.bdata.srcbounds.width;
        int h = rd.bdata.srcbounds.height;

        if (dsttexture != null) {

            dsttexture.lock();

            if (dsttexture.isSurfaceLost() ||
               (dsttexture.getContentWidth() != w) ||
               (dsttexture.getContentHeight() != h))
            {
                dsttexture.unlock();
                dsttexture.dispose();
                rd = rd.copyAddDirtyRect(0, 0, w, h);
                dsttexture = createTexture(g, rd);
            }
        } else {
            dsttexture = createTexture(g, rd);
        }
        if (dsttexture == null) {
            return;
        }
        try {
            if (curRenderData != null) {
                bufferLock.lock();
                try {
                    dsttexture.update(rd.bdata.srcbuffer,
                                      PixelFormat.INT_ARGB_PRE,
                                      rd.dirtyRect.x, rd.dirtyRect.y, // dst
                                      x + rd.dirtyRect.x, y + rd.dirtyRect.y,  // src
                                      rd.dirtyRect.width, rd.dirtyRect.height, // src
                                      rd.bdata.linestride * 4,
                                      false);
                } finally {
                    bufferLock.unlock();
                }
                if (rd.clearTarget) {
                    g.clearQuad(0, 0, rd.bdata.usrwidth, rd.bdata.usrheight);
                }
            }

            g.drawTexture(dsttexture,
                          0, 0, rd.bdata.usrwidth, rd.bdata.usrheight, // dst
                          0, 0, w, h); // src
        } finally {
            dsttexture.unlock();
        }
    }

    private Texture createTexture(Graphics g, RenderData rd) {
        ResourceFactory factory = g.getResourceFactory();
        if (!factory.isDeviceReady()) {
            return null;
        }
        Texture txt = factory.createTexture(PixelFormat.INT_ARGB_PRE,
                                            Texture.Usage.DYNAMIC,
                                            Texture.WrapMode.CLAMP_NOT_NEEDED,
                                            rd.bdata.srcbounds.width, rd.bdata.srcbounds.height);
        if (txt != null) {
            txt.contentsUseful();
        } else {
            System.err.println(&quot;NGExternalNode: failed to create a texture&quot;);
        }
        return txt;
    }

    public void setLock(ReentrantLock lock) {
        this.bufferLock = lock;
    }
<A NAME="48"></A>
    private static class BufferData {
        // the source pixel buffer
        <FONT color="#c57726"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#48',2,'match37-top.html#48',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>final Buffer srcbuffer;

        // source buffer line stride
        final int linestride;

        // source image physical bounds
        final Rectangle srcbounds;

        // source image user space (logical) size
        final float usrwidth;
        final float usrheight;

        // source image scale factor
        final double scaleX;
        final double scaleY;

        BufferData(Buffer srcbuffer, int linestride,
                   int x, int y, int width, int height,
                   float usrWidth, float usrHeight,
                   double scaleX, double scaleY)
        {
            this.srcbuffer = srcbuffer;
            this.scaleX = scaleX;
            this.scaleY = scaleY;
            this.linestride = linestride;
            t</B></FONT>his.srcbounds = scale(new Rectangle(x, y, width, height));
            this.usrwidth = usrWidth;
            this.usrheight = usrHeight;
        }

        Rectangle scale(Rectangle r) {
            int x = r.x;
            r.x = (int)Math.round(x * scaleX);
            int y = r.y;
            r.y = (int)Math.round(y * scaleY);
            r.width = (int)Math.round(r.width * scaleX);
            r.height = (int)Math.round(r.height * scaleY);
            return r;
        }

        BufferData copyWithBounds(int x, int y, int width, int height,
                                  float usrWidth, float usrHeight)
        {
            return new BufferData(this.srcbuffer, this.linestride,
                                 x, y, width, height,
                                 usrWidth, usrHeight, this.scaleX, this.scaleY);
        }
    }

    private static class RenderData {
        final BufferData bdata;
        final Rectangle dirtyRect;
        final boolean clearTarget;

        RenderData(BufferData bdata,
                   int dirtyX, int dirtyY, int dirtyWidth, int dirtyHeight,
                   boolean clearTarget)
        {
            this(bdata, dirtyX, dirtyY, dirtyWidth, dirtyHeight, clearTarget, true);
        }

        RenderData(BufferData bdata,
                   int dirtyX, int dirtyY, int dirtyWidth, int dirtyHeight,
                   boolean clearTarget, boolean applyScale)
        {
            this.bdata = bdata;
            Rectangle r = new Rectangle(dirtyX, dirtyY, dirtyWidth, dirtyHeight);
            this.dirtyRect = applyScale ? bdata.scale(r) : r;
            this.dirtyRect.intersectWith(bdata.srcbounds);
            this.clearTarget = clearTarget;
        }

        RenderData copyAddDirtyRect(int dirtyX, int dirtyY, int dirtyWidth, int dirtyHeight) {

            Rectangle r = bdata.scale(new Rectangle(dirtyX, dirtyY, dirtyWidth, dirtyHeight));
            r.add(this.dirtyRect);
            return new RenderData(this.bdata, r.x, r.y, r.width, r.height,
                                  this.clearTarget, false);
        }
    }

    public void setImageBuffer(Buffer buffer,
                               int x, int y, int width, int height,
                               float usrWidth, float usrHeight,
                               int linestride,
                               double scaleX, double scaleY)
    {
        bufferData = new BufferData(buffer, linestride, x, y, width, height,
                                           usrWidth, usrHeight, scaleX, scaleY);
        renderData.set(new RenderData(bufferData, x, y, width, height, true));
    }

    public void setImageBounds(final int x, final int y, final int width, final int height,
                               final float usrWidth, final float usrHeight)
    {

        final boolean shrinked = width &lt; bufferData.usrwidth || height &lt; bufferData.usrheight;

        bufferData = bufferData.copyWithBounds(x, y, width, height, usrWidth, usrHeight);
        renderData.updateAndGet(prev -&gt; {
            boolean clearTarget = (prev != null ? prev.clearTarget : false);
            return new RenderData(bufferData, x, y, width, height, clearTarget | shrinked);
        });
    }

    public void repaintDirtyRegion(final int dirtyX, final int dirtyY,
                                   final int dirtyWidth, final int dirtyHeight)
    {
        renderData.updateAndGet(prev -&gt; {
            if (prev != null) {
                return prev.copyAddDirtyRect(dirtyX, dirtyY, dirtyWidth, dirtyHeight);
            } else {
                return new RenderData(bufferData, dirtyX, dirtyY, dirtyWidth, dirtyHeight, false);
            }
        });
    }

    public void markContentDirty() {
        visualsChanged();
    }

    @Override
    protected boolean hasOverlappingContents() {  return false; }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/marlin/RendererStats.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.marlin;

import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ConcurrentLinkedQueue;
import com.sun.marlin.ArrayCacheConst.CacheStats;
import static com.sun.marlin.MarlinUtils.logInfo;
import com.sun.marlin.stats.Histogram;
import com.sun.marlin.stats.Monitor;
import com.sun.marlin.stats.StatLong;

/**
 * This class gathers global rendering statistics for debugging purposes only
 */
public final class RendererStats implements MarlinConst {

    static RendererStats createInstance(final Object parent, final String name)
    {
        final RendererStats stats = new RendererStats(name);

        // Keep a strong reference to dump it later:
        RendererStatsHolder.getInstance().add(parent, stats);

        return stats;
    }

    public static void dumpStats() {
        RendererStatsHolder.dumpStats();
    }

    // context name (debugging purposes)
    final String name;
    // stats
    final StatLong stat_cache_rowAA
        = new StatLong(&quot;cache.rowAA&quot;);
    final StatLong stat_cache_rowAAChunk
        = new StatLong(&quot;cache.rowAAChunk&quot;);
    final StatLong stat_cache_tiles
        = new StatLong(&quot;cache.tiles&quot;);
    final StatLong stat_rdr_addLine
        = new StatLong(&quot;renderer.addLine&quot;);
    final StatLong stat_rdr_addLine_skip
        = new StatLong(&quot;renderer.addLine.skip&quot;);
    final StatLong stat_rdr_curveBreak
        = new StatLong(&quot;renderer.curveBreakIntoLinesAndAdd&quot;);
    final StatLong stat_rdr_curveBreak_dec
        = new StatLong(&quot;renderer.curveBreakIntoLinesAndAdd.dec&quot;);
    final StatLong stat_rdr_curveBreak_inc
        = new StatLong(&quot;renderer.curveBreakIntoLinesAndAdd.inc&quot;);
    final StatLong stat_rdr_quadBreak
        = new StatLong(&quot;renderer.quadBreakIntoLinesAndAdd&quot;);
    final StatLong stat_rdr_quadBreak_dec
        = new StatLong(&quot;renderer.quadBreakIntoLinesAndAdd.dec&quot;);
    final StatLong stat_rdr_edges
        = new StatLong(&quot;renderer.edges&quot;);
    final StatLong stat_rdr_edges_count
        = new StatLong(&quot;renderer.edges.count&quot;);
    final StatLong stat_rdr_edges_resizes
        = new StatLong(&quot;renderer.edges.resize&quot;);
    final StatLong stat_rdr_activeEdges
        = new StatLong(&quot;renderer.activeEdges&quot;);
    final StatLong stat_rdr_activeEdges_updates
        = new StatLong(&quot;renderer.activeEdges.updates&quot;);
    final StatLong stat_rdr_activeEdges_adds
        = new StatLong(&quot;renderer.activeEdges.adds&quot;);
    final StatLong stat_rdr_activeEdges_adds_high
        = new StatLong(&quot;renderer.activeEdges.adds_high&quot;);
    final StatLong stat_rdr_crossings_updates
        = new StatLong(&quot;renderer.crossings.updates&quot;);
    final StatLong stat_rdr_crossings_sorts
        = new StatLong(&quot;renderer.crossings.sorts&quot;);
    final StatLong stat_rdr_crossings_bsearch
        = new StatLong(&quot;renderer.crossings.bsearch&quot;);
    final StatLong stat_rdr_crossings_msorts
        = new StatLong(&quot;renderer.crossings.msorts&quot;);
    final StatLong stat_str_polystack_curves
        = new StatLong(&quot;stroker.polystack.curves&quot;);
    final StatLong stat_str_polystack_types
        = new StatLong(&quot;stroker.polystack.types&quot;);
    final StatLong stat_cpd_polystack_curves
        = new StatLong(&quot;closedPathDetector.polystack.curves&quot;);
    final StatLong stat_cpd_polystack_types
        = new StatLong(&quot;closedPathDetector.polystack.types&quot;);
    final StatLong stat_pcf_idxstack_indices
        = new StatLong(&quot;pathClipFilter.stack.indices&quot;);
    // growable arrays
    final StatLong stat_array_dasher_dasher
        = new StatLong(&quot;array.dasher.dasher.d_float&quot;);
    final StatLong stat_array_dasher_firstSegmentsBuffer
        = new StatLong(&quot;array.dasher.firstSegmentsBuffer.d_float&quot;);
    final StatLong stat_array_marlincache_rowAAChunk
        = new StatLong(&quot;array.marlincache.rowAAChunk.resize&quot;);
    final StatLong stat_array_marlincache_touchedTile
        = new StatLong(&quot;array.marlincache.touchedTile.int&quot;);
    final StatLong stat_array_renderer_alphaline
        = new StatLong(&quot;array.renderer.alphaline.int&quot;);
    final StatLong stat_array_renderer_crossings
        = new StatLong(&quot;array.renderer.crossings.int&quot;);
    final StatLong stat_array_renderer_aux_crossings
        = new StatLong(&quot;array.renderer.aux_crossings.int&quot;);
    final StatLong stat_array_renderer_edgeBuckets
        = new StatLong(&quot;array.renderer.edgeBuckets.int&quot;);
    final StatLong stat_array_renderer_edgeBucketCounts
        = new StatLong(&quot;array.renderer.edgeBucketCounts.int&quot;);
    final StatLong stat_array_renderer_edgePtrs
        = new StatLong(&quot;array.renderer.edgePtrs.int&quot;);
    final StatLong stat_array_renderer_aux_edgePtrs
        = new StatLong(&quot;array.renderer.aux_edgePtrs.int&quot;);
    final StatLong stat_array_str_polystack_curves
        = new StatLong(&quot;array.stroker.polystack.curves.d_float&quot;);
    final StatLong stat_array_str_polystack_types
        = new StatLong(&quot;array.stroker.polystack.curveTypes.d_byte&quot;);
    final StatLong stat_array_cpd_polystack_curves
        = new StatLong(&quot;array.closedPathDetector.polystack.curves.d_float&quot;);
    final StatLong stat_array_cpd_polystack_types
        = new StatLong(&quot;array.closedPathDetector.polystack.curveTypes.d_byte&quot;);
    final StatLong stat_array_pcf_idxstack_indices
        = new StatLong(&quot;array.pathClipFilter.stack.indices.d_int&quot;);
    // histograms
    final Histogram hist_rdr_edges_count
        = new Histogram(&quot;renderer.edges.count&quot;);
    final Histogram hist_rdr_crossings
        = new Histogram(&quot;renderer.crossings&quot;);
    final Histogram hist_rdr_crossings_ratio
        = new Histogram(&quot;renderer.crossings.ratio&quot;);
    final Histogram hist_rdr_crossings_adds
        = new Histogram(&quot;renderer.crossings.adds&quot;);
    final Histogram hist_rdr_crossings_msorts
        = new Histogram(&quot;renderer.crossings.msorts&quot;);
    final Histogram hist_rdr_crossings_msorts_adds
        = new Histogram(&quot;renderer.crossings.msorts.adds&quot;);
    final Histogram hist_str_polystack_curves
        = new Histogram(&quot;stroker.polystack.curves&quot;);
    final Histogram hist_tile_generator_alpha
        = new Histogram(&quot;tile_generator.alpha&quot;);
    final Histogram hist_tile_generator_encoding
        = new Histogram(&quot;tile_generator.encoding&quot;);
    final Histogram hist_tile_generator_encoding_dist
        = new Histogram(&quot;tile_generator.encoding.dist&quot;);
    final Histogram hist_tile_generator_encoding_ratio
        = new Histogram(&quot;tile_generator.encoding.ratio&quot;);
    final Histogram hist_tile_generator_encoding_runLen
        = new Histogram(&quot;tile_generator.encoding.runLen&quot;);
    final Histogram hist_cpd_polystack_curves
        = new Histogram(&quot;closedPathDetector.polystack.curves&quot;);
    final Histogram hist_pcf_idxstack_indices
        = new Histogram(&quot;pathClipFilter.stack.indices&quot;);
    // all stats
    final StatLong[] statistics = new StatLong[]{
        stat_cache_rowAA,
        stat_cache_rowAAChunk,
        stat_cache_tiles,
        stat_rdr_addLine,
        stat_rdr_addLine_skip,
        stat_rdr_curveBreak,
        stat_rdr_curveBreak_dec,
        stat_rdr_curveBreak_inc,
        stat_rdr_quadBreak,
        stat_rdr_quadBreak_dec,
        stat_rdr_edges,
        stat_rdr_edges_count,
        stat_rdr_edges_resizes,
        stat_rdr_activeEdges,
        stat_rdr_activeEdges_updates,
        stat_rdr_activeEdges_adds,
        stat_rdr_activeEdges_adds_high,
        stat_rdr_crossings_updates,
        stat_rdr_crossings_sorts,
        stat_rdr_crossings_bsearch,
        stat_rdr_crossings_msorts,
        stat_str_polystack_types,
        stat_str_polystack_curves,
        stat_cpd_polystack_curves,
        stat_cpd_polystack_types,
        stat_pcf_idxstack_indices,
        hist_rdr_edges_count,
        hist_rdr_crossings,
        hist_rdr_crossings_ratio,
        hist_rdr_crossings_adds,
        hist_rdr_crossings_msorts,
        hist_rdr_crossings_msorts_adds,
        hist_tile_generator_alpha,
        hist_tile_generator_encoding,
        hist_tile_generator_encoding_dist,
        hist_tile_generator_encoding_ratio,
        hist_tile_generator_encoding_runLen,
        hist_str_polystack_curves,
        hist_cpd_polystack_curves,
        hist_pcf_idxstack_indices,
        stat_array_dasher_dasher,
        stat_array_dasher_firstSegmentsBuffer,
        stat_array_marlincache_rowAAChunk,
        stat_array_marlincache_touchedTile,
        stat_array_renderer_alphaline,
        stat_array_renderer_crossings,
        stat_array_renderer_aux_crossings,
        stat_array_renderer_edgeBuckets,
        stat_array_renderer_edgeBucketCounts,
        stat_array_renderer_edgePtrs,
        stat_array_renderer_aux_edgePtrs,
        stat_array_str_polystack_curves,
        stat_array_str_polystack_types,
        stat_array_cpd_polystack_curves,
        stat_array_cpd_polystack_types,
        stat_array_pcf_idxstack_indices
    };
    // monitors
    final Monitor mon_pre_getAATileGenerator
        = new Monitor(&quot;MarlinRenderingEngine.getAATileGenerator()&quot;);
    final Monitor mon_rdr_addLine
        = new Monitor(&quot;Renderer.addLine()&quot;);
    final Monitor mon_rdr_endRendering
        = new Monitor(&quot;Renderer.endRendering()&quot;);
    final Monitor mon_rdr_endRendering_Y
        = new Monitor(&quot;Renderer._endRendering(Y)&quot;);
    final Monitor mon_rdr_copyAARow
        = new Monitor(&quot;Renderer.copyAARow()&quot;);
    final Monitor mon_pipe_renderTiles
        = new Monitor(&quot;AAShapePipe.renderTiles()&quot;);
    final Monitor mon_ptg_getAlpha
        = new Monitor(&quot;MarlinTileGenerator.getAlpha()&quot;);
    final Monitor mon_debug
        = new Monitor(&quot;DEBUG()&quot;);
    // all monitors
    final Monitor[] monitors = new Monitor[]{
        mon_pre_getAATileGenerator,
        mon_rdr_addLine,
        mon_rdr_endRendering,
        mon_rdr_endRendering_Y,
        mon_rdr_copyAARow,
        mon_pipe_renderTiles,
        mon_ptg_getAlpha,
        mon_debug
    };
    // offheap stats
    long totalOffHeapInitial = 0L;
     // live accumulator
    long totalOffHeap = 0L;
    long totalOffHeapMax = 0L;
    // cache stats
    CacheStats[] cacheStats = null;

    private RendererStats(final String name) {
        this.name = name;
    }

    void dump() {
        logInfo(&quot;RendererContext: &quot; + name);

        if (DO_MONITORS) {
            for (Monitor monitor : monitors) {
                if (monitor.count != 0) {
                    logInfo(monitor.toString());
                }
            }
            // As getAATileGenerator percents:
            final long total = mon_pre_getAATileGenerator.sum;
            if (total != 0L) {
                for (Monitor monitor : monitors) {
                    logInfo(monitor.name + &quot; : &quot;
                            + ((100d * monitor.sum) / total) + &quot; %&quot;);
                }
            }
            if (DO_FLUSH_MONITORS) {
                for (Monitor m : monitors) {
                    m.reset();
                }
            }
        }

        if (DO_STATS) {
            for (StatLong stat : statistics) {
                if (stat.count != 0) {
                    logInfo(stat.toString());
                    if (DO_FLUSH_STATS) {
                        stat.reset();
                    }
                }
            }

            logInfo(&quot;OffHeap footprint: initial: &quot; + totalOffHeapInitial
                + &quot; bytes - max: &quot; + totalOffHeapMax + &quot; bytes&quot;);
            if (DO_FLUSH_STATS) {
                totalOffHeapMax = 0L;
            }

            logInfo(&quot;Array caches for RendererContext: &quot; + name);

            long totalInitialBytes = totalOffHeapInitial;
            long totalCacheBytes   = 0L;

            if (cacheStats != null) {
                for (CacheStats stat : cacheStats) {
                    totalCacheBytes   += stat.dumpStats();
                    totalInitialBytes += stat.getTotalInitialBytes();
                    if (DO_FLUSH_STATS) {
                        stat.reset();
                    }
                }
            }
            logInfo(&quot;Heap footprint: initial: &quot; + totalInitialBytes
                    + &quot; bytes - cache: &quot; + totalCacheBytes + &quot; bytes&quot;);
        }
    }

    static final class RendererStatsHolder {

        // singleton
        private static volatile RendererStatsHolder SINGLETON = null;

        static synchronized RendererStatsHolder getInstance() {
            if (SINGLETON == null) {
                SINGLETON = new RendererStatsHolder();
            }
            return SINGLETON;
        }

        static void dumpStats() {
            if (SINGLETON != null) {
                SINGLETON.dump();
            }
        }

        /* RendererStats collection as hard references
           (only used for debugging purposes) */
        private final ConcurrentLinkedQueue&lt;RendererStats&gt; allStats
            = new ConcurrentLinkedQueue&lt;RendererStats&gt;();
<A NAME="40"></A>
        private RendererStatsHolder() {
            AccessController.doPrivileged(
                (PrivilegedAction&lt;Void&gt;) () -&gt; <FONT color="#347235"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#40',2,'match37-top.html#40',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
                    final Thread hook = new Thread(
                        MarlinUtils.getRootThreadGroup(),
                        new Runnable() {
                            @Override
                            public void run() {
                                dump</B></FONT>();
                            }
                        },
                        &quot;MarlinStatsHook&quot;
                    );
                    hook.setContextClassLoader(null);
                    Runtime.getRuntime().addShutdownHook(hook);

                    if (USE_DUMP_THREAD) {
                        final Timer statTimer = new Timer(&quot;RendererStats&quot;);
                        statTimer.scheduleAtFixedRate(new TimerTask() {
                            @Override
                            public void run() {
                                dump();
                            }
                        }, DUMP_INTERVAL, DUMP_INTERVAL);
                    }
                    return null;
                }
            );
        }

        void add(final Object parent, final RendererStats stats) {
            allStats.add(stats);

            // Register a cleaning function to ensure removing dead entries:
            MarlinUtils.getCleaner().register(parent, () -&gt; remove(stats));
        }

        void remove(final RendererStats stats) {
            stats.dump(); // dump anyway
            allStats.remove(stats);
        }

        void dump() {
            for (RendererStats stats : allStats) {
                stats.dump();
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/PhongMaterial.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism;

/**
 * TODO: 3D - Need documentation
 * This class represents a phong material for retained mode rendering
 */
<A NAME="28"></A>
public interface PhongMaterial extends Material {

    <FONT color="#717d7d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#28',2,'match37-top.html#28',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>public enum MapType {DIFFUSE, SPECULAR, BUMP, SELF_ILLUM};
    public static final int DIFFUSE = MapType.DIFFUSE.ordinal()</B></FONT>;
    public static final int SPECULAR = MapType.SPECULAR.ordinal();
    public static final int BUMP = MapType.BUMP.ordinal();
    public static final int SELF_ILLUM = MapType.SELF_ILLUM.ordinal();
    public static final int MAX_MAP_TYPE = MapType.values().length;

    public void setDiffuseColor(float r, float g, float b, float a);
    public void setSpecularColor(boolean set, float r, float g, float b, float a);

    public void setTextureMap(TextureMap map);

    public void lockTextureMaps();

    public void unlockTextureMaps();
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/d3d/D3DResourceFactory.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.d3d;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Map;

import com.sun.glass.ui.Screen;
import com.sun.prism.Image;
import com.sun.prism.MediaFrame;
import com.sun.prism.Mesh;
import com.sun.prism.MeshView;
import com.sun.prism.MultiTexture;
import com.sun.prism.PhongMaterial;
import com.sun.prism.PixelFormat;
import com.sun.prism.Presentable;
import com.sun.prism.PresentableState;
import com.sun.prism.Texture;
import com.sun.prism.Texture.Usage;
import com.sun.prism.Texture.WrapMode;
import com.sun.prism.d3d.D3DResource.D3DRecord;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.impl.ps.BaseShaderFactory;
import com.sun.prism.impl.TextureResourcePool;
import com.sun.prism.ps.Shader;
import com.sun.prism.ps.ShaderFactory;
import java.util.WeakHashMap;

class D3DResourceFactory extends BaseShaderFactory {
    private static final Map&lt;Image,Texture&gt; clampTexCache = new WeakHashMap&lt;&gt;();
    private static final Map&lt;Image,Texture&gt; repeatTexCache = new WeakHashMap&lt;&gt;();
    private static final Map&lt;Image,Texture&gt; mipmapTexCache = new WeakHashMap&lt;&gt;();

    private final D3DContext context;
    private final int maxTextureSize;

    /**
     * List of disposer records for d3d resources created by the pipeline.
     * @see D3DResource
     */
    private final LinkedList&lt;D3DResource.D3DRecord&gt; records =
        new LinkedList&lt;D3DResource.D3DRecord&gt;();

    D3DResourceFactory(long pContext, Screen screen) {
<A NAME="22"></A>        super(clampTexCache, repeatTexCache, mipmapTexCache);
        context = new D3DContext(pContext, screen, this);
        context.initState();
        <FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#22',2,'match37-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>maxTextureSize = computeMaxTextureSize();

        if (PrismSettings.noClampToZero &amp;&amp; PrismSettings.verbose) {
            System.out.println(&quot;prism.noclamptozero not supported by D3D&quot;);
        }
    }

    D3DContext getContext() {</B></FONT>
        return context;
    }

    public TextureResourcePool getTextureResourcePool() {
        return D3DVramPool.instance;
    }

    static final int STATS_FREQUENCY = PrismSettings.prismStatFrequency;
    private int nFrame = -1;
    private D3DFrameStats frameStats;

    private void displayPrismStatistics() {
        if (STATS_FREQUENCY &gt; 0) {
            if (++nFrame == STATS_FREQUENCY) {
                nFrame = 0;
                frameStats = context.getFrameStats(true, frameStats);
                if (frameStats != null) {
                    System.err.println(frameStats.toDebugString(STATS_FREQUENCY));
                }
            }
        }
    }

    @Override
    public boolean isDeviceReady() {
        displayPrismStatistics();
        return context.testLostStateAndReset();
    }

    static int nextPowerOfTwo(int val, int max) {
        if (val &gt; max) {
            return 0;
        }
        int i = 1;
        while (i &lt; val) {
            i *= 2;
        }
        return i;
    }

    @Override
    public boolean isCompatibleTexture(Texture tex) {
        return tex instanceof D3DTexture;
    }

    @Override
    public D3DTexture createTexture(PixelFormat format, Usage usagehint,
            WrapMode wrapMode, int w, int h) {
        return createTexture(format, usagehint, wrapMode, w, h, false);
    }

    @Override
    public D3DTexture createTexture(PixelFormat format, Usage usagehint,
            WrapMode wrapMode, int w, int h, boolean useMipmap) {
        if (!isFormatSupported(format)) {
            throw new UnsupportedOperationException(
                &quot;Pixel format &quot; + format +
                &quot; not supported on this device&quot;);
        }

        if (format == PixelFormat.MULTI_YCbCr_420) {
            throw new UnsupportedOperationException(&quot;MULTI_YCbCr_420 textures require a MediaFrame&quot;);
        }

        int allocw, alloch;
        if (PrismSettings.forcePow2) {
            allocw = nextPowerOfTwo(w, Integer.MAX_VALUE);
            alloch = nextPowerOfTwo(h, Integer.MAX_VALUE);
        } else {
            allocw = w;
            alloch = h;
        }
        D3DVramPool pool = D3DVramPool.instance;
        long size = pool.estimateTextureSize(allocw, alloch, format);
        if (!pool.prepareForAllocation(size)) {
            return null;
        }
        long pResource = nCreateTexture(context.getContextHandle(),
                                        format.ordinal(), usagehint.ordinal(),
                                        false /*isRTT*/, allocw, alloch, 0, useMipmap);
        if (pResource == 0L) {
            return null;
        }

        int texw = nGetTextureWidth(pResource);
        int texh = nGetTextureHeight(pResource);
        if (wrapMode != WrapMode.CLAMP_NOT_NEEDED &amp;&amp; (w &lt; texw || h &lt; texh)) {
            wrapMode = wrapMode.simulatedVersion();
        }
        return new D3DTexture(context, format, wrapMode, pResource, texw, texh, w, h, useMipmap);
    }

    @Override
    public Texture createTexture(MediaFrame frame) {
        frame.holdFrame();

        int width = frame.getWidth();
        int height = frame.getHeight();
        int texWidth = frame.getEncodedWidth();
        int texHeight = frame.getEncodedHeight();
        PixelFormat texFormat = frame.getPixelFormat();

        if (texFormat == PixelFormat.MULTI_YCbCr_420) {
            // Create a MultiTexture instead
            MultiTexture tex = new MultiTexture(texFormat, WrapMode.CLAMP_TO_EDGE, width, height);

            // create/add the subtextures
            // plane indices: 0 = luma, 1 = Cb, 2 = Cr, 3 (optional) = alpha
            for (int index = 0; index &lt; frame.planeCount(); index++) {
                int subWidth = texWidth;
                int subHeight =  texHeight; // might not match height if height is odd

                if (index == PixelFormat.YCBCR_PLANE_CHROMABLUE
                        || index == PixelFormat.YCBCR_PLANE_CHROMARED)
                {
                    subWidth /= 2;
                    subHeight /= 2;
                }

                D3DTexture subTex = createTexture(PixelFormat.BYTE_ALPHA, Usage.DYNAMIC, WrapMode.CLAMP_TO_EDGE,
                                                  subWidth, subHeight);
                if (subTex == null) {
                    tex.dispose();
                    return null;
                }
                tex.setTexture(subTex, index);
            }

            frame.releaseFrame();
            return tex;
        } else {
            D3DVramPool pool = D3DVramPool.instance;
            long size = pool.estimateTextureSize(texWidth, texHeight, texFormat);
            if (!pool.prepareForAllocation(size)) {
                return null;
            }
            long pResource = nCreateTexture(context.getContextHandle(),
                    texFormat.ordinal(), Usage.DYNAMIC.ordinal(),
                    false, texWidth, texHeight, 0, false);
            if (0 == pResource) {
                return null;
            }

            int physWidth = nGetTextureWidth(pResource);
            int physHeight = nGetTextureHeight(pResource);
            WrapMode wrapMode = (texWidth &lt; physWidth || texHeight &lt; physHeight)
                    ? WrapMode.CLAMP_TO_EDGE_SIMULATED : WrapMode.CLAMP_TO_EDGE;
            D3DTexture tex = new D3DTexture(context, texFormat, wrapMode, pResource,
                                            physWidth, physHeight, width, height, false);
            frame.releaseFrame();
            return tex;
        }
    }

    public int getRTTWidth(int w, WrapMode wrapMode) {
        // D3DRTTexture returns the requested dimension as the content dimension
        // so the answer here is just &quot;w&quot; despite the fact that a pow2 adjustment
        // is made for the actual allocation.  Typically, D3D supports non-pow2
        // textures on every implementation so the pow2 code below is not really
        // encountered in practice anyway (it's only supported for &quot;debugging&quot;).
//        if (PrismSettings.forcePow2) {
//            w = nextPowerOfTwo(w, Integer.MAX_VALUE);
//        }
        return w;
    }

    public int getRTTHeight(int h, WrapMode wrapMode) {
        // D3DRTTexture returns the requested dimension as the content dimension
        // so the answer here is just &quot;h&quot; despite the fact that a pow2 adjustment
        // is made for the actual allocation.  Typically, D3D supports non-pow2
        // textures on every implementation so the pow2 code below is not really
        // encountered in practice anyway (it's only supported for &quot;debugging&quot;).
//        if (PrismSettings.forcePow2) {
//            h = nextPowerOfTwo(h, Integer.MAX_VALUE);
//        }
        return h;
    }

    @Override
    public D3DRTTexture createRTTexture(int width, int height, WrapMode wrapMode) {
        return createRTTexture(width, height, wrapMode, false);
    }

    @Override
    public D3DRTTexture createRTTexture(int width, int height, WrapMode wrapMode, boolean msaa) {
        if (PrismSettings.verbose &amp;&amp; context.isLost()) {
            System.err.println(&quot;RT Texture allocation while the device is lost&quot;);
        }

        int createw = width;
        int createh = height;
        int cx = 0;
        int cy = 0;
        if (PrismSettings.forcePow2) {
            createw = nextPowerOfTwo(createw, Integer.MAX_VALUE);
            createh = nextPowerOfTwo(createh, Integer.MAX_VALUE);
        }
        D3DVramPool pool = D3DVramPool.instance;
        int aaSamples;
        if (msaa) {
            int maxSamples = D3DPipeline.getInstance().getMaxSamples();
            aaSamples =  maxSamples &lt; 2 ? 0 : (maxSamples &lt; 4 ? 2 : 4);
        } else {
            aaSamples = 0;
        }
        // TODO: 3D - Improve estimate to include if multisample rtt
        long size = pool.estimateRTTextureSize(width, height, false);
        if (!pool.prepareForAllocation(size)) {
            return null;
        }

        long pResource = nCreateTexture(context.getContextHandle(),
                                        PixelFormat.INT_ARGB_PRE.ordinal(),
                                        Usage.DEFAULT.ordinal(),
                                        true /*isRTT*/, createw, createh, aaSamples, false);
        if (pResource == 0L) {
            return null;
        }

        int texw = nGetTextureWidth(pResource);
        int texh = nGetTextureHeight(pResource);
        D3DRTTexture rtt = new D3DRTTexture(context, wrapMode, pResource, texw, texh,
                                            cx, cy, width, height, aaSamples);
        // ensure the RTTexture is cleared to all zeros before returning
        // (Decora relies on the Java2D behavior, where an image is expected
        // to be fully transparent after initialization)
        rtt.createGraphics().clear();
        return rtt;
    }

    public Presentable createPresentable(PresentableState pState) {
        if (PrismSettings.verbose &amp;&amp; context.isLost()) {
            System.err.println(&quot;SwapChain allocation while the device is lost&quot;);
        }

        long pResource = nCreateSwapChain(context.getContextHandle(),
                                          pState.getNativeView(),
                                          PrismSettings.isVsyncEnabled);

        if (pResource != 0L) {
            int width = pState.getRenderWidth();
            int height = pState.getRenderHeight();
            D3DRTTexture rtt = createRTTexture(width, height, WrapMode.CLAMP_NOT_NEEDED, pState.isMSAA());
            if (PrismSettings.dirtyOptsEnabled) {
                rtt.contentsUseful();
            }

            if (rtt != null) {
                return new D3DSwapChain(context, pResource, rtt, pState.getRenderScaleX(), pState.getRenderScaleY());
            }

            D3DResourceFactory.nReleaseResource(context.getContextHandle(), pResource);
        }
        return null;

    }

    private static ByteBuffer getBuffer(InputStream is) {
        if (is == null) {
           throw new RuntimeException(&quot;InputStream must be non-null&quot;);
        }
        try {
            int len = 4096;
            byte[] data = new byte[len];
            BufferedInputStream bis = new BufferedInputStream(is, len);
            int offset = 0;
            int readBytes = -1;
            while ((readBytes = bis.read(data, offset, len - offset)) != -1) {
                offset += readBytes;
                if (len - offset == 0) {
                    // grow the array
                    len *= 2;
                    // was
                    // data = Arrays.copyOf(data, len);
                    //
                    byte[] newdata = new byte[len];
                    System.arraycopy(data, 0, newdata, 0, data.length);
                    data = newdata;
                }
            }
            bis.close();
            // NOTE: for now the D3DShader native code only knows how to
            // deal with direct ByteBuffers, so we have to dump the byte[]
            // into a newly allocated direct buffer...
            ByteBuffer buf = ByteBuffer.allocateDirect(offset);
            buf.put(data, 0, offset);
            return buf;
        } catch (IOException e) {
            throw new RuntimeException(&quot;Error loading D3D shader object&quot;, e);
        }
    }

    public Shader createShader(InputStream pixelShaderCode,
                               Map&lt;String, Integer&gt; samplers,
                               Map&lt;String, Integer&gt; params,
                               int maxTexCoordIndex,
                               boolean isPixcoordUsed,
                               boolean isPerVertexColorUsed)
    {
        long shaderHandle = D3DShader.init(
                context.getContextHandle(), getBuffer(pixelShaderCode),
                maxTexCoordIndex, isPixcoordUsed, isPerVertexColorUsed);

        return new D3DShader(context, shaderHandle, params);
    }

    public Shader createStockShader(final String name) {
        if (name == null) {
            throw new IllegalArgumentException(&quot;Shader name must be non-null&quot;);
        }
        try {
            InputStream stream = AccessController.doPrivileged(
                    (PrivilegedAction&lt;InputStream&gt;) () -&gt; D3DResourceFactory.class.
                           getResourceAsStream(&quot;hlsl/&quot; + name + &quot;.obj&quot;)
            );
            Class klass = Class.forName(&quot;com.sun.prism.shader.&quot; + name + &quot;_Loader&quot;);
            Method m = klass.getMethod(&quot;loadShader&quot;,
                new Class[] { ShaderFactory.class, InputStream.class });
            return (Shader)m.invoke(null, new Object[] { this, stream });
        } catch (Throwable e) {
            e.printStackTrace();
            throw new InternalError(&quot;Error loading stock shader &quot; + name);
        }
    }

    @Override
    public void dispose() {
        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
    }

    @Override
    public boolean isFormatSupported(PixelFormat format) {
        return true;
    }

    private int computeMaxTextureSize() {
        int size = nGetMaximumTextureSize(context.getContextHandle());
        if (PrismSettings.verbose) {
            System.err.println(&quot;Maximum supported texture size: &quot; + size);
        }
        if (size &gt; PrismSettings.maxTextureSize) {
            size = PrismSettings.maxTextureSize;
            if (PrismSettings.verbose) {
                System.err.println(&quot;Maximum texture size clamped to &quot; + size);
            }
        }
        return size;
    }

    public int getMaximumTextureSize() {
        return maxTextureSize;
    }

    @Override
    protected void notifyReset() {
        for (ListIterator&lt;D3DRecord&gt; it = records.listIterator(); it.hasNext();) {
            D3DRecord r = it.next();
            if (r.isDefaultPool()) {
                r.markDisposed();
                it.remove();
            }
        }
        super.notifyReset();
    }

    @Override
    protected void notifyReleased() {
        for (ListIterator&lt;D3DRecord&gt; it = records.listIterator(); it.hasNext();) {
            D3DRecord r = it.next();
            r.markDisposed();
        }
        records.clear();
        super.notifyReleased();
    }

    void addRecord(D3DRecord record) {
        records.add(record);
    }

    void removeRecord(D3DRecord record) {
        records.remove(record);
    }

    public PhongMaterial createPhongMaterial() {
        return D3DPhongMaterial.create(context);
    }

    public MeshView createMeshView(Mesh mesh) {
        return D3DMeshView.create(context, (D3DMesh) mesh);

    }

    public Mesh createMesh() {
        return D3DMesh.create(context);
    }

    static native long nGetContext(int adapterOrdinal);
    static native boolean nIsDefaultPool(long pResource);
    static native int nTestCooperativeLevel(long pContext);
    static native int nResetDevice(long pContext);
    static native long nCreateTexture(long pContext,
                                      int format, int hint,
                                      boolean isRTT,
                                      int width, int height, int samples,
                                      boolean useMipmap);
    static native long nCreateSwapChain(long pContext, long hwnd,
                                        boolean isVsyncEnabled);
    static native int nReleaseResource(long pContext, long resource);
    static native int nGetMaximumTextureSize(long pContext);
    static native int nGetTextureWidth(long pResource);
    static native int nGetTextureHeight(long pResource);
    static native int nReadPixelsI(long pContext, long pResource,
                                    long length,
                                    Buffer pixels, int[] arr,
                                    int contentWidth, int contentHeight);
    static native int nReadPixelsB(long pContext, long pResource,
                                    long length,
                                    Buffer pixels, byte[] arr,
                                    int contentWidth, int contentHeight);
    static native int nUpdateTextureI(long contextHandle, long pResource,
                                      IntBuffer buf, int[] pixels,
                                      int dstx, int dsty,
                                      int srcx, int srcy,
                                      int srcw, int srch, int srcscan);
    static native int nUpdateTextureF(long contextHandle, long pResource,
                                      FloatBuffer buf, float[] pixels,
                                      int dstx, int dsty,
                                      int srcx, int srcy,
                                      int srcw, int srch, int srcscan);
    static native int nUpdateTextureB(long contextHandle, long pResource,
                                      ByteBuffer buf, byte[] pixels,
                                      int formatHint,
                                      int dstx, int dsty,
                                      int srcx, int srcy,
                                      int srcw, int srch, int srcscan);

    static native long nGetDevice(long pContext);
    static native long nGetNativeTextureObject(long pResource);
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/es2/GLFactory.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.es2;

import com.sun.prism.impl.PrismSettings;
import com.sun.javafx.PlatformUtil;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.HashMap;

abstract class GLFactory {

    private static native boolean
            nIsGLExtensionSupported(long nativeContextObject, String glExtStr);
    private static native String nGetGLVendor(long nativeCtxInfo);
    private static native String nGetGLRenderer(long nativeCtxInfo);
    private static native String nGetGLVersion(long nativeCtxInfo);

    private static final GLFactory platformFactory;

    /* Note: We are only storing the string information of a driver in this
     * object. We are assuming a system with a single or homogeneous GPUs.
     * For the case of heterogeneous GPUs system the string information
     * will need to move to GLContext class. */
    long nativeCtxInfo;
    boolean gl2 = false;
    private GLContext shareCtx = null;

    /**
     * Creates a new GLFactory instance. End users do not need
     * to call this method.
     */
    GLFactory() {
    }

    /**
     * Instantiate singleton factories if available, the OS native ones.
     */
    static {

        final String factoryClassName;
        if (PlatformUtil.isUnix()) {
            if (&quot;eglx11&quot;.equals(PlatformUtil.getEmbeddedType()))
                factoryClassName = &quot;com.sun.prism.es2.EGLX11GLFactory&quot;;
            else if (&quot;eglfb&quot;.equals(PlatformUtil.getEmbeddedType()))
                factoryClassName = &quot;com.sun.prism.es2.EGLFBGLFactory&quot;;
            else if (&quot;monocle&quot;.equals(PlatformUtil.getEmbeddedType()))
                factoryClassName = &quot;com.sun.prism.es2.MonocleGLFactory&quot;;
            else
                factoryClassName = &quot;com.sun.prism.es2.X11GLFactory&quot;;
        } else if (PlatformUtil.isWindows()) {
            factoryClassName = &quot;com.sun.prism.es2.WinGLFactory&quot;;
        } else if (PlatformUtil.isMac()) {
            factoryClassName = &quot;com.sun.prism.es2.MacGLFactory&quot;;
        } else if (PlatformUtil.isIOS()) {
            factoryClassName = &quot;com.sun.prism.es2.IOSGLFactory&quot;;
        } else if (PlatformUtil.isAndroid()) {
            if (&quot;eglfb&quot;.equals(PlatformUtil.getEmbeddedType())) {
                factoryClassName = &quot;com.sun.prism.es2.EGLFBGLFactory&quot;;
            } else if (&quot;monocle&quot;.equals(PlatformUtil.getEmbeddedType()))
                 factoryClassName = &quot;com.sun.prism.es2.MonocleGLFactory&quot;;
            else {
                factoryClassName = null;
                System.err.println(&quot;GLFactory.static - Only eglfb supported for Android!&quot;);
            }
        } else {
            factoryClassName = null;
            System.err.println(&quot;GLFactory.static - No Platform Factory for: &quot; + System.getProperty(&quot;os.name&quot;));
        }
        if (PrismSettings.verbose) {
            System.out.println(&quot;GLFactory using &quot; + factoryClassName);
        }
        platformFactory = factoryClassName == null ? null :
            AccessController.doPrivileged(new FactoryLoader(factoryClassName));
    }

    private static class FactoryLoader implements PrivilegedAction&lt;GLFactory&gt; {
        private final String factoryClassName;
        FactoryLoader(String factoryClassName) {
            this.factoryClassName = factoryClassName;
        }
        public GLFactory run() {
            GLFactory factory = null;
            try {
                factory = (GLFactory) Class.forName(factoryClassName).newInstance();
            } catch (Throwable t) {
                System.err.println(&quot;GLFactory.static - Platform: &quot;
                        + System.getProperty(&quot;os.name&quot;)
                        + &quot; - not available: &quot;
                        + factoryClassName);
                t.printStackTrace();
            }
            return factory;
        }
    }

    /**
     * Returns the sole GLFactory instance.
     */
    static GLFactory getFactory() throws RuntimeException {
        if (null != platformFactory) {
            return platformFactory;
        }
        throw new RuntimeException(&quot;No native platform GLFactory available.&quot;);
    }

    // Consists of a list of prequalifying GPUs that we may use for the es2 pipe.
    // A null preQualificationFilter implies we may consider any GPU
    abstract GLGPUInfo[] getPreQualificationFilter();

    // Consists of a list of GPUs that we will block from using the es2 pipe.
    abstract GLGPUInfo[] getBlackList();

    private static GLGPUInfo readGPUInfo(long nativeCtxInfo) {
        String glVendor = nGetGLVendor(nativeCtxInfo);
        String glRenderer = nGetGLRenderer(nativeCtxInfo);
        return new GLGPUInfo(glVendor.toLowerCase(),
                glRenderer.toLowerCase());
    }

    private static boolean matches(GLGPUInfo gpuInfo, GLGPUInfo[] gpuInfoArr) {
        if (gpuInfoArr != null) {
            for (int i = 0; i &lt; gpuInfoArr.length; i++) {
                if (gpuInfo.matches(gpuInfoArr[i])) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean inPreQualificationFilter(GLGPUInfo gpuInfo) {
        GLGPUInfo[] preQualificationFilter = getPreQualificationFilter();
        if (preQualificationFilter == null) {
            // We will consider any GPU if preQualificationFilter is null
            return true;
        }
        return matches(gpuInfo, preQualificationFilter);
    }

    private boolean inBlackList(GLGPUInfo gpuInfo) {
        return matches(gpuInfo, getBlackList());
    }

    boolean isQualified(long nativeCtxInfo) {
        // Read the GPU (graphics hardware) information and qualifying it by
        // checking against the preQualificationFilter and the &quot;blocking&quot;
        // blackLis.
        GLGPUInfo gpuInfo = readGPUInfo(nativeCtxInfo);

        if (gpuInfo.vendor == null || gpuInfo.model == null
                || gpuInfo.vendor.contains(&quot;unknown&quot;)
                || gpuInfo.model.contains(&quot;unknown&quot;)) {
            // Return false if we can't determine the vendor and model of the
            // gpu installed on the system
            return false;
        }

        return inPreQualificationFilter(gpuInfo) &amp;&amp; !inBlackList(gpuInfo);
    }

    abstract GLContext createGLContext(long nativeCtxInfo);

    abstract GLContext createGLContext(GLDrawable drawable,
            GLPixelFormat pixelFormat, GLContext shareCtx, boolean vSyncRequest);

    abstract GLDrawable createGLDrawable(long nativeWindow, GLPixelFormat pixelFormat);

    abstract GLDrawable createDummyGLDrawable(GLPixelFormat pixelFormat);

    abstract GLPixelFormat createGLPixelFormat(long nativeScreen, GLPixelFormat.Attributes attrs);

    boolean isGLGPUQualify() {
        return isQualified(nativeCtxInfo);
    }

    abstract boolean initialize(Class psClass, GLPixelFormat.Attributes attrs);
<A NAME="15"></A>
    GLContext getShareContext() {
        if (shareCtx == null) {
            shareCtx = <FONT color="#3bb9ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#15',2,'match37-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>createGLContext(nativeCtxInfo);
        }
        return shareCtx;
    }

    // Returns true if this pipe supports GL2 profile, false for GLES2
    boolean isGL2() {
        return gl2;
    }

    boolean isGLExtensionSupported(String sglExtStr) {</B></FONT>
        return nIsGLExtensionSupported(nativeCtxInfo, sglExtStr);
    }

    boolean isNPOTSupported() {
        return (isGLExtensionSupported(&quot;GL_ARB_texture_non_power_of_two&quot;)
                    || isGLExtensionSupported(&quot;GL_OES_texture_npot&quot;));
    }

    abstract int getAdapterCount();

    abstract int getAdapterOrdinal(long nativeScreen);

    abstract void updateDeviceDetails(HashMap deviceDetails);

    void printDriverInformation(int adapter) {
        /* We are assuming a system with a single or homogeneous GPUs. */
        System.out.println(&quot;Graphics Vendor: &quot; + nGetGLVendor(nativeCtxInfo));
        System.out.println(&quot;       Renderer: &quot; + nGetGLRenderer(nativeCtxInfo));
        System.out.println(&quot;        Version: &quot; + nGetGLVersion(nativeCtxInfo));
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/impl/ManagedResource.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.impl;

import com.sun.prism.GraphicsResource;
import java.util.ArrayList;

public abstract class ManagedResource&lt;T&gt; implements GraphicsResource {
    static final boolean trackLockSources = false;

    static boolean _isgone(ManagedResource&lt;?&gt; mr) {
        if (mr == null) return true;
        if (mr.disposalRequested) {
            mr.free();
            mr.resource = null;
            mr.disposalRequested = false;
            return true;
        }
        return !mr.isValid();
    }

    protected T resource;
    private final ResourcePool&lt;T&gt; pool;
    private int lockcount;
    private int employcount;
    ArrayList&lt;Throwable&gt; lockedFrom;
    private boolean permanent;
    private boolean mismatchDetected;
    private boolean disposalRequested;
    private int age;

    protected ManagedResource(T resource, ResourcePool&lt;T&gt; pool) {
        this.resource = resource;
        this.pool = pool;
        if (trackLockSources) {
            this.lockedFrom = new ArrayList&lt;Throwable&gt;();
        }
        manage();
        lock();
    }

    private void manage() {
        pool.resourceManaged(this);
    }

    public final T getResource() {
        assertLocked();
        return resource;
    }

    public final ResourcePool&lt;T&gt; getPool() {
        return pool;
    }

    public boolean isValid() {
        return resource != null &amp;&amp; !disposalRequested;
    }

    public boolean isDisposalRequested() {
        return disposalRequested;
    }

    public final boolean isLocked() {
        return lockcount &gt; 0;
    }

    public final int getLockCount() {
        return lockcount;
    }

    public final void assertLocked() {
        if (lockcount &lt;= 0) {
            throw new IllegalStateException(&quot;Operation requires resource lock&quot;);
        }
    }

    public final boolean isPermanent() {
        return permanent;
<A NAME="5"></A>    }

    public final boolean isInteresting() {
        <FONT color="#c8c2a7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#5',2,'match37-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return employcount &gt; 0;
    }

    public final int getInterestCount() {
        return employcount;
    }

    public void free() {
    }

    public int getAge() {
        return age;
    }

    @Overri</B></FONT>de
    public final void dispose() {
        if (pool.isManagerThread()) {
            T r = resource;
            if (r != null) {
                free();
                disposalRequested = false;
                resource = null;
                pool.resourceFreed(this);
            }
        } else {
            disposalRequested = true;
        }
    }

    public final void makePermanent() {
        assertLocked();
        permanent = true;
    }

    public final T lock() {
        lockcount++;
        age = 0;
        if (trackLockSources &amp;&amp; !permanent) {
            lockedFrom.add(new Throwable(Integer.toString(lockcount)));
        }
        return resource;
    }

    void unlockall() {
        lockcount = 0;
        if (trackLockSources &amp;&amp; !permanent) {
            lockedFrom.clear();
        }
    }

    public final void unlock() {
        assertLocked();
        lockcount--;
        if (trackLockSources &amp;&amp; !permanent &amp;&amp; lockcount == 0) {
            lockedFrom.clear();
        }
    }

    public final void contentsUseful() {
        assertLocked();
        employcount++;
    }

    public final void contentsNotUseful() {
        if (employcount &lt;= 0) {
            throw new IllegalStateException(&quot;Resource obsoleted too many times&quot;);
        }
        employcount--;
    }

    public final boolean wasMismatched() {
        return mismatchDetected;
    }

    public final void setMismatched() {
        mismatchDetected = true;
    }

    public final void bumpAge(int forever) {
        int a = this.age;
        if (a &lt; forever) {
            this.age = a + 1;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/impl/ps/BaseShaderContext.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.impl.ps;

import com.sun.glass.ui.Screen;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.prism.CompositeMode;
import com.sun.prism.PixelFormat;
import com.sun.prism.RTTexture;
import com.sun.prism.RenderTarget;
import com.sun.prism.ResourceFactory;
import com.sun.prism.Texture;
import com.sun.prism.impl.BaseContext;
import com.sun.prism.impl.BaseGraphics;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.Gradient;
import com.sun.prism.paint.ImagePattern;
import com.sun.prism.paint.LinearGradient;
import com.sun.prism.paint.Paint;
import com.sun.prism.paint.RadialGradient;
import com.sun.prism.ps.Shader;
import com.sun.prism.ps.ShaderFactory;

/**
 * Maintains resources such as Shaders and GlyphCaches that are intended to
 * be cached on a per-Screen basis, and provides methods that are called by
 * BaseShaderGraphics to validate current state.  The inner State class is
 * used to encapsulate the current and previously validated state (such as
 * texture bindings) so that the validation routines can avoid redundant
 * state changes.  There should be only one BaseShaderContext per Screen,
 * however there may be one or more State instances per BaseShaderContext.
 * &lt;p&gt;
 * A note about State objects... The JOGL architecture creates a GLContext
 * for each GLDrawable (one GLContext per GLDrawable, and one GLDrawable
 * per onscreen window).  Resources such as textures and shaders can be
 * shared between those GLContext instances, but other state (texture bindings,
 * scissor rect, etc) cannot be shared.  Therefore we need to maintain
 * one State instance per GLContext instance, which means there may be more
 * than one State instance per BaseShaderContext.  The currentState variable
 * holds the current State instance corresponding to the current RenderTarget,
 * and is revalidated as part of the updateRenderTarget() method.  The ES2
 * backend will create a new State instance for each window, but the D3D
 * backend is free to create a single State instance that can be shared for
 * the entire Screen.
 */
public abstract class BaseShaderContext extends BaseContext {
    private static final int CHECK_SHADER    = (0x01     );
    private static final int CHECK_TRANSFORM = (0x01 &lt;&lt; 1);
    private static final int CHECK_CLIP      = (0x01 &lt;&lt; 2);
    private static final int CHECK_COMPOSITE = (0x01 &lt;&lt; 3);
    private static final int CHECK_PAINT_OP_MASK =
        (CHECK_SHADER | CHECK_TRANSFORM | CHECK_CLIP | CHECK_COMPOSITE);
    private static final int CHECK_TEXTURE_OP_MASK =
        (CHECK_SHADER | CHECK_TRANSFORM | CHECK_CLIP | CHECK_COMPOSITE);
    private static final int CHECK_CLEAR_OP_MASK =
        (CHECK_CLIP);

    public enum MaskType {
        SOLID          (&quot;Solid&quot;),
        TEXTURE        (&quot;Texture&quot;),
        ALPHA_ONE           (&quot;AlphaOne&quot;, true),
        ALPHA_TEXTURE       (&quot;AlphaTexture&quot;, true),
        ALPHA_TEXTURE_DIFF  (&quot;AlphaTextureDifference&quot;, true),
        FILL_PGRAM     (&quot;FillPgram&quot;),
        DRAW_PGRAM     (&quot;DrawPgram&quot;, FILL_PGRAM),
        FILL_CIRCLE    (&quot;FillCircle&quot;),
        DRAW_CIRCLE    (&quot;DrawCircle&quot;, FILL_CIRCLE),
        FILL_ELLIPSE   (&quot;FillEllipse&quot;),
        DRAW_ELLIPSE   (&quot;DrawEllipse&quot;, FILL_ELLIPSE),
        FILL_ROUNDRECT (&quot;FillRoundRect&quot;),
        DRAW_ROUNDRECT (&quot;DrawRoundRect&quot;, FILL_ROUNDRECT),
        DRAW_SEMIROUNDRECT(&quot;DrawSemiRoundRect&quot;);

        private String name;
        private MaskType filltype;
        private boolean newPaintStyle;
        private MaskType(String name) {
            this.name = name;
        }
        private MaskType(String name, boolean newstyle) {
            this.name = name;
            this.newPaintStyle = newstyle;
        }
        private MaskType(String name, MaskType filltype) {
            this.name = name;
            this.filltype = filltype;
        }
        public String getName() {
            return name;
        }
        public MaskType getFillType() {
            return filltype;
        }
        public boolean isNewPaintStyle() {
            return newPaintStyle;
        }
    }

    // mask type     4 bits (14 types)
    // paint type    2 bits
    // paint opts    2 bits
    private static final int NUM_STOCK_SHADER_SLOTS =
        MaskType.values().length &lt;&lt; 4;
    // TODO: need to dispose these when the context is disposed... (RT-27379)
    private final Shader[] stockShaders = new Shader[NUM_STOCK_SHADER_SLOTS];
    // stockShaders with alpha test
    private final Shader[] stockATShaders = new Shader[NUM_STOCK_SHADER_SLOTS];

    public enum SpecialShaderType {
        TEXTURE_RGB          (&quot;Solid_TextureRGB&quot;),
        TEXTURE_MASK_RGB     (&quot;Mask_TextureRGB&quot;),
        TEXTURE_YV12         (&quot;Solid_TextureYV12&quot;),
        TEXTURE_First_LCD    (&quot;Solid_TextureFirstPassLCD&quot;),
        TEXTURE_SECOND_LCD   (&quot;Solid_TextureSecondPassLCD&quot;),
        SUPER                (&quot;Mask_TextureSuper&quot;);

        private String name;
        private SpecialShaderType(String name) {
            this.name = name;
        }
        public String getName() {
            return name;
        }
    }
    private final Shader[] specialShaders = new Shader[SpecialShaderType.values().length];
    // specialShaders with alpha test
    private final Shader[] specialATShaders = new Shader[SpecialShaderType.values().length];

    private Shader externalShader;

    private RTTexture lcdBuffer;
    private final ShaderFactory factory;

    private State state;

    protected BaseShaderContext(Screen screen, ShaderFactory factory, int vbQuads) {
        super(screen, factory, vbQuads);
        this.factory = factory;
        init();
    }

    protected void init() {
        state = null;
        if (externalShader != null &amp;&amp; !externalShader.isValid()) {
            externalShader.dispose();
            externalShader = null;
        }
        // the rest of the shaders will be re-validated as they are used
   }

    public static class State {
        private Shader lastShader;
        private RenderTarget lastRenderTarget;
        private NGCamera lastCamera;
        private boolean lastDepthTest;
        private BaseTransform lastTransform = new Affine3D();
        private Rectangle lastClip;
        private CompositeMode lastComp;
        private Texture[] lastTextures = new Texture[4];
        private boolean isXformValid;
        private float lastConst1 = Float.NaN;
        private float lastConst2 = Float.NaN;
        private float lastConst3 = Float.NaN;
        private float lastConst4 = Float.NaN;
        private float lastConst5 = Float.NaN;
        private float lastConst6 = Float.NaN;
        private boolean lastState3D = false;
    }

    @Override
    protected void setPerspectiveTransform(GeneralTransform3D transform) {
        state.isXformValid = false;
        super.setPerspectiveTransform(transform);
    }

    protected void resetLastClip(State state) {
        state.lastClip = null;
    }

    protected abstract State updateRenderTarget(RenderTarget target, NGCamera camera,
                                                boolean depthTest);

    protected abstract void updateTexture(int texUnit, Texture tex);

    protected abstract void updateShaderTransform(Shader shader,
                                                  BaseTransform xform);

    protected abstract void updateWorldTransform(BaseTransform xform);

    protected abstract void updateClipRect(Rectangle clipRect);

    protected abstract void updateCompositeMode(CompositeMode mode);

    private static int getStockShaderIndex(MaskType maskType, Paint paint) {
        int paintType;
        int paintOption;
        if (paint == null) {
            paintType = 0;
            paintOption = 0;
        } else {
            paintType = paint.getType().ordinal();
            if (paint.getType().isGradient()) {
                paintOption = ((Gradient)paint).getSpreadMethod();
            } else {
                paintOption = 0;
            }
        }
        return (maskType.ordinal() &lt;&lt; 4) | (paintType &lt;&lt; 2) | (paintOption &lt;&lt; 0);
    }

    private Shader getPaintShader(boolean alphaTest, MaskType maskType, Paint paint) {
        int index = getStockShaderIndex(maskType, paint);
        Shader shaders[] = alphaTest ? stockATShaders : stockShaders;
        Shader shader = shaders[index];
        if (shader != null &amp;&amp; !shader.isValid()) {
            shader.dispose();
            shader = null;
        }
        if (shader == null) {
            String shaderName =
                maskType.getName() + &quot;_&quot; + paint.getType().getName();
            if (paint.getType().isGradient() &amp;&amp; !maskType.isNewPaintStyle()) {
                Gradient grad = (Gradient) paint;
                int spreadMethod = grad.getSpreadMethod();
                if (spreadMethod == Gradient.PAD) {
                    shaderName += &quot;_PAD&quot;;
                } else if (spreadMethod == Gradient.REFLECT) {
                    shaderName += &quot;_REFLECT&quot;;
                } else if (spreadMethod == Gradient.REPEAT) {
                    shaderName += &quot;_REPEAT&quot;;
                }
            }
            if (alphaTest) {
                shaderName += &quot;_AlphaTest&quot;;
            }
            shader = shaders[index] = factory.createStockShader(shaderName);
        }
        return shader;
    }

    private void updatePaintShader(BaseShaderGraphics g, Shader shader,
                                   MaskType maskType, Paint paint,
                                   float bx, float by, float bw, float bh)
    {
        Paint.Type paintType = paint.getType();
        if (paintType == Paint.Type.COLOR || maskType.isNewPaintStyle()) {
            return;
        }

        float rx, ry, rw, rh;
        if (paint.isProportional()) {
            rx = bx; ry = by; rw = bw; rh = bh;
        } else {
            rx = 0f; ry = 0f; rw = 1f; rh = 1f;
        }

        switch (paintType) {
        case LINEAR_GRADIENT:
            PaintHelper.setLinearGradient(g, shader,
                                          (LinearGradient)paint,
                                          rx, ry, rw, rh);
            break;
        case RADIAL_GRADIENT:
            PaintHelper.setRadialGradient(g, shader,
                                          (RadialGradient)paint,
                                          rx, ry, rw, rh);
            break;
        case IMAGE_PATTERN:
            PaintHelper.setImagePattern(g, shader,
                                        (ImagePattern)paint,
                                        rx, ry, rw, rh);
        default:
            break;
        }
    }

    private Shader getSpecialShader(BaseGraphics g, SpecialShaderType sst) {
        // We do alpha test if depth test is enabled
        boolean alphaTest = g.isAlphaTestShader();
        Shader shaders[] = alphaTest ? specialATShaders : specialShaders;
        Shader shader = shaders[sst.ordinal()];
        if (shader != null &amp;&amp; !shader.isValid()) {
            shader.dispose();
            shader = null;
        }
        if (shader == null) {
            String shaderName = sst.getName();
            if (alphaTest) {
                shaderName += &quot;_AlphaTest&quot;;
            }
            shaders[sst.ordinal()] = shader = factory.createStockShader(shaderName);
        }
        return shader;
    }

    @Override
    public boolean isSuperShaderEnabled() {
        return state.lastShader == specialATShaders[SpecialShaderType.SUPER.ordinal()]
<A NAME="31"></A>                || state.lastShader == specialShaders[SpecialShaderType.SUPER.ordinal()];
    }

    private void updatePerVertexColor(Paint paint, float extraAlpha) <FONT color="#3ea99f"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#31',2,'match37-top.html#31',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        if (paint != null &amp;&amp; paint.getType() == Paint.Type.COLOR) {
            getVertexBuffer().setPerVertexColor((Color)paint, extraAlpha);
        } else {
            getVertexBuffer().setPerVertexColor(extraAlpha);
        }
    }

    @</B></FONT>Override
    public void validateClearOp(BaseGraphics g) {
        checkState((BaseShaderGraphics) g, CHECK_CLEAR_OP_MASK, null, null);
    }

    @Override
    public void validatePaintOp(BaseGraphics g, BaseTransform xform,
                                Texture maskTex,
                                float bx, float by, float bw, float bh)
    {
        validatePaintOp((BaseShaderGraphics)g, xform,
                        maskTex, bx, by, bw, bh);
    }

    Shader validatePaintOp(BaseShaderGraphics g, BaseTransform xform,
                           MaskType maskType,
                           float bx, float by, float bw, float bh)
    {
        return validatePaintOp(g, xform, maskType, null, bx, by, bw, bh);
    }

    Shader validatePaintOp(BaseShaderGraphics g, BaseTransform xform,
                           MaskType maskType,
                           float bx, float by, float bw, float bh,
                           float k1, float k2, float k3, float k4, float k5, float k6)
    {
        // this is not ideal, but will have to do for now (tm).
        // various paint primitives use shader parameters, and we have to flush
        // the vertex buffer if those change.  Ideally we would do this in
        // checkState but there is no mechanism to pass this info through.
        if (state.lastConst1 != k1 || state.lastConst2 != k2 ||
            state.lastConst3 != k3 || state.lastConst4 != k4 ||
            state.lastConst5 != k5 || state.lastConst6 != k6)
        {
            flushVertexBuffer();

            state.lastConst1 = k1;
            state.lastConst2 = k2;
            state.lastConst3 = k3;
            state.lastConst4 = k4;
            state.lastConst5 = k5;
            state.lastConst6 = k6;
        }

        return validatePaintOp(g, xform, maskType, null, bx, by, bw, bh);
    }

    Shader validatePaintOp(BaseShaderGraphics g, BaseTransform xform,
                           MaskType maskType, Texture maskTex,
                           float bx, float by, float bw, float bh,
                           float k1, float k2, float k3, float k4, float k5, float k6)
    {
        // this is not ideal, but will have to do for now (tm).
        // various paint primitives use shader parameters, and we have to flush
        // the vertex buffer if those change.  Ideally we would do this in
        // checkState but there is no mechanism to pass this info through.
        if (state.lastConst1 != k1 || state.lastConst2 != k2 ||
            state.lastConst3 != k3 || state.lastConst4 != k4 ||
            state.lastConst5 != k5 || state.lastConst6 != k6)
        {
            flushVertexBuffer();

            state.lastConst1 = k1;
            state.lastConst2 = k2;
            state.lastConst3 = k3;
            state.lastConst4 = k4;
            state.lastConst5 = k5;
            state.lastConst6 = k6;
        }

        return validatePaintOp(g, xform, maskType, maskTex, bx, by, bw, bh);
    }

    Shader validatePaintOp(BaseShaderGraphics g, BaseTransform xform,
                           Texture maskTex,
                           float bx, float by, float bw, float bh)
    {
        return validatePaintOp(g, xform, MaskType.TEXTURE,
                               maskTex, bx, by, bw, bh);
    }

    Shader validatePaintOp(BaseShaderGraphics g, BaseTransform xform,
                           MaskType maskType, Texture maskTex,
                           float bx, float by, float bw, float bh)
    {
        if (maskType == null) {
            throw new InternalError(&quot;maskType must be non-null&quot;);
        }

        if (externalShader == null) {
            Paint paint = g.getPaint();
            Texture paintTex = null;
            Texture tex0;
            Texture tex1;
            if (paint.getType().isGradient()) {
                // we need to flush here in case the paint shader is staying
                // the same but the paint parameters are changing; we do this
                // unconditionally for now (in theory we could keep track
                // of the last validated paint, and the shape bounds in the
                // case of proportional gradients, but the case where the
                // same paint parameters are used multiple times in a row
                // is so rare that it's not worth optimizing this any further)
                flushVertexBuffer();
                // we have to fetch the texture containing the gradient
                // colors in advance since checkState() is responsible for
                // binding the texture(s)
                if (maskType.isNewPaintStyle()) {
                    paintTex = PaintHelper.getWrapGradientTexture(g);
                } else {
                    paintTex = PaintHelper.getGradientTexture(g, (Gradient)paint);
                }
            } else if (paint.getType() == Paint.Type.IMAGE_PATTERN) {
                // We need to flush here. See comment above about paint parameters changing.
                flushVertexBuffer();
                ImagePattern texPaint = (ImagePattern)paint;
                ResourceFactory rf = g.getResourceFactory();
                paintTex = rf.getCachedTexture(texPaint.getImage(), Texture.WrapMode.REPEAT);
            }
            Shader shader;
            if (factory.isSuperShaderAllowed() &amp;&amp;
                paintTex == null &amp;&amp;
                maskTex == factory.getGlyphTexture())
            {
                // Enabling the super shader to be used to render text.
                // The texture pointed by tex0 is the region cache texture
                // and it does not affect text rendering
                shader = getSpecialShader(g, SpecialShaderType.SUPER);
                tex0 = factory.getRegionTexture();
                tex1 = maskTex;
            } else {
                // NOTE: We are making assumptions here about which texture
                // corresponds to which texture unit.  In a JSL file the
                // first sampler mentioned will correspond to texture unit 0,
                // the second sampler will correspond to texture unit 1,
                // and so on, and there's currently no way to explicitly
                // associate a sampler with a texture unit in the JSL file.
                // So for now we assume that mask-related samplers are
                // declared before any paint-related samplers in the
                // composed JSL files.
                if (maskTex != null) {
                    tex0 = maskTex;
                    tex1 = paintTex;
                } else {
                    tex0 = paintTex;
                    tex1 = null;
                }
                // We do alpha test if depth test is enabled
                shader = getPaintShader(g.isAlphaTestShader(), maskType, paint);
            }
            checkState(g, CHECK_PAINT_OP_MASK, xform, shader);
            setTexture(0, tex0);
            setTexture(1, tex1);
            updatePaintShader(g, shader, maskType, paint, bx, by, bw, bh);
            updatePerVertexColor(paint, g.getExtraAlpha());
            if (paintTex != null) paintTex.unlock();
            return shader;
        } else {
            // note that paint is assumed to be a simple Color in this case
            checkState(g, CHECK_PAINT_OP_MASK, xform, externalShader);
            setTexture(0, maskTex);
            setTexture(1, null);  // Needed?
            updatePerVertexColor(null, g.getExtraAlpha());
            return externalShader;
        }
    }

    @Override
    public void validateTextureOp(BaseGraphics g, BaseTransform xform,
                                  Texture tex0, PixelFormat format)
    {
        validateTextureOp((BaseShaderGraphics)g, xform, tex0, null, format);
    }

    //This function sets the first LCD sample shader.
    public Shader validateLCDOp(BaseShaderGraphics g, BaseTransform xform,
                                Texture tex0, Texture tex1, boolean firstPass,
                                Paint fillColor)
    {
        Shader shader = firstPass ? getSpecialShader(g, SpecialShaderType.TEXTURE_First_LCD) :
                                    getSpecialShader(g, SpecialShaderType.TEXTURE_SECOND_LCD);

        checkState(g, CHECK_TEXTURE_OP_MASK, xform, shader);
        setTexture(0, tex0);
        setTexture(1, tex1);
        updatePerVertexColor(fillColor, g.getExtraAlpha());
        return shader;
    }

    Shader validateTextureOp(BaseShaderGraphics g, BaseTransform xform,
                             Texture[] textures, PixelFormat format)
    {
        Shader shader;

        if (format == PixelFormat.MULTI_YCbCr_420) {
            // must have at least three textures, any more than four are ignored
            if (textures.length &lt; 3) {
                return null;
            }

            if (externalShader == null) {
                shader = getSpecialShader(g, SpecialShaderType.TEXTURE_YV12);
            } else {
                shader = externalShader;
            }
        } else { // add more multitexture shaders here
            return null;
        }

        if (null != shader) {
            checkState(g, CHECK_TEXTURE_OP_MASK, xform, shader);
            // clamp to 0..4 textures for now, expand on this later if we need to
            int texCount = Math.max(0, Math.min(textures.length, 4));
            for (int index = 0; index &lt; texCount; index++) {
                setTexture(index, textures[index]);
            }
            updatePerVertexColor(null, g.getExtraAlpha());
        }
        return shader;
    }

    Shader validateTextureOp(BaseShaderGraphics g, BaseTransform xform,
                             Texture tex0, Texture tex1, PixelFormat format)
    {
        Shader shader;
        if (externalShader == null) {
            switch (format) {
            case INT_ARGB_PRE:
            case BYTE_BGRA_PRE:
            case BYTE_RGB:
            case BYTE_GRAY:
            case BYTE_APPLE_422: // uses GL_RGBA as internal format
                if (factory.isSuperShaderAllowed() &amp;&amp;
                    tex0 == factory.getRegionTexture() &amp;&amp;
                    tex1 == null)
                {
                    // Enabling the super shader to be used for texture rendering.
                    // The shader was designed to render many Regions (from the Region
                    // texture cache) and text (from the glyph cache texture) without
                    // changing the state in the context.
                    shader = getSpecialShader(g, SpecialShaderType.SUPER);
                    tex1 = factory.getGlyphTexture();
                } else {
                    shader = getSpecialShader(g, SpecialShaderType.TEXTURE_RGB);
                }
                break;
            case MULTI_YCbCr_420: // Must use multitexture method
            case BYTE_ALPHA:
            default:
                throw new InternalError(&quot;Pixel format not supported: &quot; + format);
            }
        } else {
            shader = externalShader;
        }
        checkState(g, CHECK_TEXTURE_OP_MASK, xform, shader);
        setTexture(0, tex0);
        setTexture(1, tex1);
        updatePerVertexColor(null, g.getExtraAlpha());
        return shader;
    }

    Shader validateMaskTextureOp(BaseShaderGraphics g, BaseTransform xform,
                                 Texture tex0, Texture tex1, PixelFormat format)
    {
        Shader shader;
        if (externalShader == null) {
            switch (format) {
            case INT_ARGB_PRE:
            case BYTE_BGRA_PRE:
            case BYTE_RGB:
            case BYTE_GRAY:
            case BYTE_APPLE_422: // uses GL_RGBA as internal format
                shader = getSpecialShader(g, SpecialShaderType.TEXTURE_MASK_RGB);
                break;
            case MULTI_YCbCr_420: // Must use multitexture method
            case BYTE_ALPHA:
            default:
                throw new InternalError(&quot;Pixel format not supported: &quot; + format);
            }
        } else {
            shader = externalShader;
        }
        checkState(g, CHECK_TEXTURE_OP_MASK, xform, shader);
        setTexture(0, tex0);
        setTexture(1, tex1);
        updatePerVertexColor(null, g.getExtraAlpha());
        return shader;
    }

    void setExternalShader(BaseShaderGraphics g, Shader shader) {
        // Note that this method is called when the user calls
        // ShaderGraphics.setExternalShader().  We flush any pending
        // operations and synchronously enable the given shader here
        // because the caller (i.e., decora-prism-ps peer) needs to be
        // able to call shader.setConstant() after calling setExternalShader().
        // (In the ES2 backend, setConstant() bottoms out in glUniform(),
        // which can only be called when the program is active, i.e., after
        // shader.enable() is called.  Kind of gross, but that's why the
        // external shader mechanism is setup the way it is currently.)
        // So here we enable the shader just so that the user can update
        // shader constants, and we set the externalShader instance variable.
        // Later in checkState(), we will set the externalShader and
        // update the current transform state &quot;for real&quot;.
        flushVertexBuffer();
        if (shader != null) {
            shader.enable();
        }
        externalShader = shader;
    }

    private void checkState(BaseShaderGraphics g,
                            int checkFlags,
                            BaseTransform xform,
                            Shader shader)
    {
        setRenderTarget(g);

        if ((checkFlags &amp; CHECK_SHADER) != 0) {
            if (shader != state.lastShader) {
                flushVertexBuffer();
                shader.enable();
                state.lastShader = shader;
                // the transform matrix is part of the state of each shader
                // (in ES2 at least), so we need to make sure the transform
                // is updated for the current shader by setting isXformValid=false
                state.isXformValid = false;
                checkFlags |= CHECK_TRANSFORM;
            }
        }

        if ((checkFlags &amp; CHECK_TRANSFORM) != 0) {
            if (!state.isXformValid || !xform.equals(state.lastTransform)) {
                flushVertexBuffer();
                updateShaderTransform(shader, xform);
                state.lastTransform.setTransform(xform);
                state.isXformValid = true;
            }
        }

        if ((checkFlags &amp; CHECK_CLIP) != 0) {
            Rectangle clip = g.getClipRectNoClone();
            if (clip != state.lastClip) {
                flushVertexBuffer();
                updateClipRect(clip);
                state.lastClip = clip;
            }
        }

        if ((checkFlags &amp; CHECK_COMPOSITE) != 0) {
            CompositeMode mode = g.getCompositeMode();
            if (mode != state.lastComp) {
                flushVertexBuffer();
                updateCompositeMode(mode);
                state.lastComp = mode;
            }
        }
    }

    private void setTexture(int texUnit, Texture tex) {
        if (tex != null) tex.assertLocked();
        if (tex != state.lastTextures[texUnit]) {
            flushVertexBuffer();
            updateTexture(texUnit, tex);
            state.lastTextures[texUnit] = tex;
        }
    }

    //Current RenderTarget is the lcdBuffer after this method.
    public void initLCDBuffer(int width, int height) {
        lcdBuffer = factory.createRTTexture(width, height, Texture.WrapMode.CLAMP_NOT_NEEDED);
        // TODO: RT-29488 we need to track the uses of the LCD buffer,
        // but the flow of control through the text methods is
        // not straight-forward enough for a simple set of lock/unlock
        // fixes at this time.
        lcdBuffer.makePermanent();
    }

    public void disposeLCDBuffer() {
        if (lcdBuffer != null) {
            lcdBuffer.dispose();
            lcdBuffer = null;
        }
    }

    @Override
    public RTTexture getLCDBuffer() {
        return lcdBuffer;
    }

    //Current RenderTarget is undefined after this method.
    public void validateLCDBuffer(RenderTarget renderTarget) {
        if (lcdBuffer == null ||
                lcdBuffer.getPhysicalWidth() &lt; renderTarget.getPhysicalWidth() ||
                lcdBuffer.getPhysicalHeight() &lt; renderTarget.getPhysicalHeight())
        {
            disposeLCDBuffer();
            initLCDBuffer(renderTarget.getPhysicalWidth(), renderTarget.getPhysicalHeight());
        }
    }

    abstract public void blit(RTTexture srcRTT, RTTexture dstRTT,
                          int srcX0, int srcY0, int srcX1, int srcY1,
                          int dstX0, int dstY0, int dstX1, int dstY1);

    @Override
    protected void setRenderTarget(RenderTarget target, NGCamera camera,
            boolean depthTest, boolean state3D)
    {
        if (target instanceof Texture) {
            ((Texture) target).assertLocked();
        }
        if (state == null ||
            state3D != state.lastState3D ||
            target != state.lastRenderTarget ||
            camera != state.lastCamera ||
            depthTest != state.lastDepthTest)
        {
            flushVertexBuffer();
            state = updateRenderTarget(target, camera, depthTest);
            state.lastRenderTarget = target;
            state.lastCamera = camera;
            state.lastDepthTest = depthTest;

            // the projection matrix is set in updateShaderTransform()
            // because it depends on the dimensions of the destination surface,
            // so if the RenderTarget is changing we force a call to the
            // updateShaderTransform() method by setting isXformValid=false
            state.isXformValid = false;

            // True if we switch between 2D and 3D primitives
            if (state3D != state.lastState3D) {
                state.lastState3D = state3D;
                state.lastShader = null;
                state.lastConst1 = Float.NaN;
                state.lastConst2 = Float.NaN;
                state.lastConst3 = Float.NaN;
                state.lastConst4 = Float.NaN;
                state.lastConst5 = Float.NaN;
                state.lastConst6 = Float.NaN;
                state.lastComp = null;
                state.lastClip = null;
                for (int i = 0; i != state.lastTextures.length; i++) {
                    state.lastTextures[i] = null;
                }
                if (state3D) {
                    // switch to 3D state
                    setDeviceParametersFor3D();
                } else {
                    // switch to 2D state
                    setDeviceParametersFor2D();
                }
            }
        }
    }

    @Override
    protected void releaseRenderTarget() {
        // Null out hard references that cause memory leak reported in RT-17304
        if (state != null) {
            state.lastRenderTarget = null;
            for (int i=0; i&lt;state.lastTextures.length; i++) {
                state.lastTextures[i] = null;
            }
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/impl/ps/BaseShaderGraphics.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.impl.ps;

import java.security.AccessController;
import java.security.PrivilegedAction;
import com.sun.javafx.font.FontResource;
import com.sun.javafx.font.FontStrike;
import com.sun.javafx.font.Metrics;
import com.sun.javafx.font.PrismFontFactory;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.Point2D;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.AffineBase;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.javafx.scene.text.GlyphList;
import com.sun.javafx.sg.prism.NGLightBase;
import com.sun.prism.BasicStroke;
import com.sun.prism.CompositeMode;
import com.sun.prism.MaskTextureGraphics;
import com.sun.prism.MultiTexture;
import com.sun.prism.PixelFormat;
import com.sun.prism.RTTexture;
import com.sun.prism.ReadbackGraphics;
import com.sun.prism.ReadbackRenderTarget;
import com.sun.prism.RenderTarget;
import com.sun.prism.Texture;
import com.sun.prism.impl.BaseGraphics;
import com.sun.prism.impl.GlyphCache;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.impl.VertexBuffer;
import com.sun.prism.impl.ps.BaseShaderContext.MaskType;
import com.sun.prism.impl.shape.MaskData;
import com.sun.prism.impl.shape.ShapeUtil;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.Gradient;
import com.sun.prism.paint.ImagePattern;
import com.sun.prism.paint.LinearGradient;
import com.sun.prism.paint.Paint;
import com.sun.prism.paint.RadialGradient;
import com.sun.prism.ps.Shader;
import com.sun.prism.ps.ShaderGraphics;

public abstract class BaseShaderGraphics
    extends BaseGraphics
    implements ShaderGraphics, ReadbackGraphics, MaskTextureGraphics
{
    private static Affine2D TEMP_TX2D = new Affine2D();
    private static Affine3D TEMP_TX3D = new Affine3D();

    private final BaseShaderContext context;
    private Shader externalShader;
    private boolean isComplexPaint;

    protected BaseShaderGraphics(BaseShaderContext context,
                                 RenderTarget renderTarget)
    {
        super(context, renderTarget);
        this.context = context;
    }

    BaseShaderContext getContext() {
        return context;
    }

    boolean isComplexPaint() {
        return isComplexPaint;
    }

    public void getPaintShaderTransform(Affine3D ret) {
        ret.setTransform(getTransformNoClone());
    }

    public Shader getExternalShader() {
        return externalShader;
    }

    public void setExternalShader(Shader shader) {
        this.externalShader = shader;
        context.setExternalShader(this, shader);
    }

    @Override
    public void setPaint(Paint paint) {
        if (paint.getType().isGradient()) {
            Gradient grad = (Gradient)paint;
            isComplexPaint = grad.getNumStops() &gt; PaintHelper.MULTI_MAX_FRACTIONS;
        } else {
            isComplexPaint = false;
        }
        super.setPaint(paint);
    }

    private NGLightBase lights[] = null;

    public void setLights(NGLightBase lights[]) { this.lights = lights; }

    public final NGLightBase[] getLights() { return this.lights; }

    @Override
    public void drawTexture(Texture tex,
                            float dx1, float dy1, float dx2, float dy2,
                            float sx1, float sy1, float sx2, float sy2)
    {
        // intercept MultiTexture operations
        // FIXME: this should be pushed up to Graphics interface so that non-shader
        //        renderers can use MultiTexture too
        if (tex instanceof MultiTexture) {
            drawMultiTexture((MultiTexture)tex, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2);
        } else {
            super.drawTexture(tex, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2);
        }
    }

    @Override
    public void drawTexture3SliceH(Texture tex,
                                   float dx1, float dy1, float dx2, float dy2,
                                   float sx1, float sy1, float sx2, float sy2,
                                   float dh1, float dh2, float sh1, float sh2)
    {
        if (!(tex instanceof MultiTexture)) {
            super.drawTexture3SliceH(tex,
                                     dx1, dy1, dx2, dy2,
                                     sx1, sy1, sx2, sy2,
                                     dh1, dh2, sh1, sh2);
            return;
        }
        MultiTexture mtex = (MultiTexture) tex;
        drawMultiTexture(mtex, dx1, dy1, dh1, dy2, sx1, sy1, sh1, sy2);
        drawMultiTexture(mtex, dh1, dy1, dh2, dy2, sh1, sy1, sh2, sy2);
        drawMultiTexture(mtex, dh2, dy1, dx2, dy2, sh2, sy1, sx2, sy2);
    }

    @Override
    public void drawTexture3SliceV(Texture tex,
                                   float dx1, float dy1, float dx2, float dy2,
                                   float sx1, float sy1, float sx2, float sy2,
                                   float dv1, float dv2, float sv1, float sv2)
    {
        if (!(tex instanceof MultiTexture)) {
            super.drawTexture3SliceV(tex,
                                     dx1, dy1, dx2, dy2,
                                     sx1, sy1, sx2, sy2,
                                     dv1, dv2, sv1, sv2);
            return;
        }
        MultiTexture mtex = (MultiTexture) tex;
        drawMultiTexture(mtex, dx1, dy1, dx2, dv1, sx1, sy1, sx2, sv1);
        drawMultiTexture(mtex, dx1, dv1, dx2, dv2, sx1, sv1, sx2, sv2);
        drawMultiTexture(mtex, dx1, dv2, dx2, dy2, sx1, sv2, sx2, sy2);
    }

    @Override
    public void drawTexture9Slice(Texture tex,
                                  float dx1, float dy1, float dx2, float dy2,
                                  float sx1, float sy1, float sx2, float sy2,
                                  float dh1, float dv1, float dh2, float dv2,
                                  float sh1, float sv1, float sh2, float sv2)
    {
        if (!(tex instanceof MultiTexture)) {
            super.drawTexture9Slice(tex,
                                    dx1, dy1, dx2, dy2,
                                    sx1, sy1, sx2, sy2,
                                    dh1, dv1, dh2, dv2,
                                    sh1, sv1, sh2, sv2);
            return;
        }
        MultiTexture mtex = (MultiTexture) tex;
        drawMultiTexture(mtex, dx1, dy1, dh1, dv1, sx1, sy1, sh1, sv1);
        drawMultiTexture(mtex, dh1, dy1, dh2, dv1, sh1, sy1, sh2, sv1);
        drawMultiTexture(mtex, dh2, dy1, dx2, dv1, sh2, sy1, sx2, sv1);

        drawMultiTexture(mtex, dx1, dv1, dh1, dv2, sx1, sv1, sh1, sv2);
        drawMultiTexture(mtex, dh1, dv1, dh2, dv2, sh1, sv1, sh2, sv2);
        drawMultiTexture(mtex, dh2, dv1, dx2, dv2, sh2, sv1, sx2, sv2);

        drawMultiTexture(mtex, dx1, dv2, dh1, dy2, sx1, sv2, sh1, sy2);
        drawMultiTexture(mtex, dh1, dv2, dh2, dy2, sh1, sv2, sh2, sy2);
        drawMultiTexture(mtex, dh2, dv2, dx2, dy2, sh2, sv2, sx2, sy2);
    }

    private static float calculateScaleFactor(float contentDim, float physicalDim) {
        if (contentDim == physicalDim) {
            return 1f;
        }
        // we have to subtract 1 to eliminate the &quot;green line of death&quot;
        return (contentDim-1) / physicalDim;
    }

    protected void drawMultiTexture(MultiTexture tex,
                                  float dx1, float dy1, float dx2, float dy2,
                                  float sx1, float sy1, float sx2, float sy2)
    {
        // The following is safe; this method does not mutate the transform
        BaseTransform xform = getTransformNoClone();
        if (isSimpleTranslate) {
            xform = IDENT;
            dx1 += transX;
            dy1 += transY;
            dx2 += transX;
            dy2 += transY;
        }

        Texture textures[] = ((MultiTexture)tex).getTextures();
        Shader shader = context.validateTextureOp(this, xform, textures, tex.getPixelFormat());

        if (null == shader) {
            // FIXME: throw exception?? We can't do anything without the shader..
            return;
        }

        if (tex.getPixelFormat() == PixelFormat.MULTI_YCbCr_420) {
            Texture lumaTex = textures[PixelFormat.YCBCR_PLANE_LUMA];
            Texture cbTex = textures[PixelFormat.YCBCR_PLANE_CHROMABLUE];
            Texture crTex = textures[PixelFormat.YCBCR_PLANE_CHROMARED];

            // sampler scaling factors
            float imgWidth = (float)tex.getContentWidth();
            float imgHeight = (float)tex.getContentHeight();
            float lumaScaleX, lumaScaleY;
            float alphaScaleX, alphaScaleY;
            float cbScaleX, cbScaleY;
            float crScaleX, crScaleY;

            lumaScaleX = calculateScaleFactor(imgWidth, (float)lumaTex.getPhysicalWidth());
            lumaScaleY = calculateScaleFactor(imgHeight, (float)lumaTex.getPhysicalHeight());

            if (textures.length &gt; 3) {
                Texture alphaTex = textures[PixelFormat.YCBCR_PLANE_ALPHA];
                alphaScaleX = calculateScaleFactor(imgWidth, (float)alphaTex.getPhysicalWidth());
                alphaScaleY = calculateScaleFactor(imgHeight, (float)alphaTex.getPhysicalHeight());
            } else {
                alphaScaleX = alphaScaleY = 0f;
            }

            float chromaWidth = (float)Math.floor((double)imgWidth/2.0);
            float chromaHeight = (float)Math.floor((double)imgHeight/2.0);

            cbScaleX = calculateScaleFactor(chromaWidth, (float)cbTex.getPhysicalWidth());
            cbScaleY = calculateScaleFactor(chromaHeight, (float)cbTex.getPhysicalHeight());
            crScaleX = calculateScaleFactor(chromaWidth, (float)crTex.getPhysicalWidth());
            crScaleY = calculateScaleFactor(chromaHeight, (float)crTex.getPhysicalHeight());

            shader.setConstant(&quot;lumaAlphaScale&quot;, lumaScaleX, lumaScaleY, alphaScaleX, alphaScaleY);
            shader.setConstant(&quot;cbCrScale&quot;, cbScaleX, cbScaleY, crScaleX, crScaleY);

            float tx1 = sx1 / imgWidth;
            float ty1 = sy1 / imgHeight;
            float tx2 = sx2 / imgWidth;
            float ty2 = sy2 / imgHeight;

            VertexBuffer vb = context.getVertexBuffer();
            vb.addQuad(dx1, dy1, dx2, dy2, tx1, ty1, tx2, ty2);
        } else {
            // should have been caught by validateTextureOp, but just in case
            throw new UnsupportedOperationException(&quot;Unsupported multitexture format &quot;+tex.getPixelFormat());
        }
    }

    public void drawTextureRaw2(Texture src1, Texture src2,
                                float dx1, float dy1, float dx2, float dy2,
                                float t1x1, float t1y1, float t1x2, float t1y2,
                                float t2x1, float t2y1, float t2x2, float t2y2)
    {
        // The following is safe; this method does not mutate the transform
        BaseTransform xform = getTransformNoClone();
        if (isSimpleTranslate) {
            xform = IDENT;
            dx1 += transX;
            dy1 += transY;
            dx2 += transX;
            dy2 += transY;
        }
        context.validateTextureOp(this, xform, src1, src2,
                                  PixelFormat.INT_ARGB_PRE);

        VertexBuffer vb = context.getVertexBuffer();
        vb.addQuad(dx1, dy1, dx2, dy2,
                   t1x1, t1y1, t1x2, t1y2,
                   t2x1, t2y1, t2x2, t2y2);
    }

    public void drawMappedTextureRaw2(Texture src1, Texture src2,
                                      float dx1, float dy1, float dx2, float dy2,
                                      float t1x11, float t1y11, float t1x21, float t1y21,
                                      float t1x12, float t1y12, float t1x22, float t1y22,
                                      float t2x11, float t2y11, float t2x21, float t2y21,
                                      float t2x12, float t2y12, float t2x22, float t2y22)
    {
        // The following is safe; this method does not mutate the transform
        BaseTransform xform = getTransformNoClone();
        if (isSimpleTranslate) {
            xform = IDENT;
            dx1 += transX;
            dy1 += transY;
            dx2 += transX;
            dy2 += transY;
        }
        context.validateTextureOp(this, xform, src1, src2,
                                  PixelFormat.INT_ARGB_PRE);

        VertexBuffer vb = context.getVertexBuffer();
        vb.addMappedQuad(dx1, dy1, dx2, dy2,
                         t1x11, t1y11, t1x21, t1y21,
                         t1x12, t1y12, t1x22, t1y22,
                         t2x11, t2y11, t2x21, t2y21,
                         t2x12, t2y12, t2x22, t2y22);
    }

    public void drawPixelsMasked(RTTexture imgtex, RTTexture masktex,
                                 int dx, int dy, int dw, int dh,
                                 int ix, int iy, int mx, int my)
    {
        if (dw &lt;= 0 || dh &lt;= 0) return;
        float iw = imgtex.getPhysicalWidth();
        float ih = imgtex.getPhysicalHeight();
        float mw = masktex.getPhysicalWidth();
        float mh = masktex.getPhysicalHeight();
        float dx1 = dx;
        float dy1 = dy;
        float dx2 = dx + dw;
        float dy2 = dy + dh;
        float ix1 = ix / iw;
        float iy1 = iy / ih;
        float ix2 = (ix + dw) / iw;
        float iy2 = (iy + dh) / ih;
        float mx1 = mx / mw;
        float my1 = my / mh;
        float mx2 = (mx + dw) / mw;
        float my2 = (my + dh) / mh;
        context.validateMaskTextureOp(this, IDENT, imgtex, masktex,
                                      PixelFormat.INT_ARGB_PRE);
        VertexBuffer vb = context.getVertexBuffer();
        vb.addQuad(dx1, dy1, dx2, dy2,
                   ix1, iy1, ix2, iy2,
                   mx1, my1, mx2, my2);
    }

    public void maskInterpolatePixels(RTTexture imgtex, RTTexture masktex,
                                      int dx, int dy, int dw, int dh,
                                      int ix, int iy, int mx, int my)
    {
        if (dw &lt;= 0 || dh &lt;= 0) return;
        float iw = imgtex.getPhysicalWidth();
        float ih = imgtex.getPhysicalHeight();
        float mw = masktex.getPhysicalWidth();
        float mh = masktex.getPhysicalHeight();
        float dx1 = dx;
        float dy1 = dy;
        float dx2 = dx + dw;
        float dy2 = dy + dh;
        float ix1 = ix / iw;
        float iy1 = iy / ih;
        float ix2 = (ix + dw) / iw;
        float iy2 = (iy + dh) / ih;
        float mx1 = mx / mw;
        float my1 = my / mh;
        float mx2 = (mx + dw) / mw;
        float my2 = (my + dh) / mh;
        CompositeMode oldmode = getCompositeMode();
        setCompositeMode(CompositeMode.DST_OUT);
        context.validateTextureOp(this, IDENT, masktex,
                                  PixelFormat.INT_ARGB_PRE);
        VertexBuffer vb = context.getVertexBuffer();
        vb.addQuad(dx1, dy1, dx2, dy2,
                   mx1, my1, mx2, my2);

        setCompositeMode(CompositeMode.ADD);
        context.validateMaskTextureOp(this, IDENT, imgtex, masktex,
                                      PixelFormat.INT_ARGB_PRE);
        vb.addQuad(dx1, dy1, dx2, dy2,
                   ix1, iy1, ix2, iy2,
                   mx1, my1, mx2, my2);

        setCompositeMode(oldmode);
    }

    private void renderWithComplexPaint(Shape shape, BasicStroke stroke,
                                        float bx, float by, float bw, float bh)
    {
        // creating/updating the mask texture may unset the current
        // texture used by pending vertices, so flush the vertex buffer first
        context.flushVertexBuffer();

        // The following is safe; this method does not mutate the transform
        BaseTransform xform = getTransformNoClone();
        MaskData maskData =
            ShapeUtil.rasterizeShape(shape, stroke, getFinalClipNoClone(), xform, true, isAntialiasedShape());
        int maskW = maskData.getWidth();
        int maskH = maskData.getHeight();

        float dx1 = maskData.getOriginX();
        float dy1 = maskData.getOriginY();
        float dx2 = dx1 + maskW;
        float dy2 = dy1 + maskH;

        // Note that we could use multitexturing here (upload mask
        // data to texture unit 0 and paint data to texture unit 1
        // then set the texture mode to modulate) but this operation is
        // already plenty slow and not worth optimizing at this time,
        // so for now we will merge the mask with the paint data in software.
        Gradient grad = (Gradient)paint;
        TEMP_TX2D.setToTranslation(-dx1, -dy1);
        TEMP_TX2D.concatenate(xform);
        Texture tex = context.getGradientTexture(grad, TEMP_TX2D,
                                                 maskW, maskH, maskData,
                                                 bx, by, bw, bh);

        float tx1 = 0f;
        float ty1 = 0f;
        float tx2 = tx1 + ((float)maskW) / tex.getPhysicalWidth();
        float ty2 = ty1 + ((float)maskH) / tex.getPhysicalHeight();

        // the mask has been generated in device space, so we use
        // identity transform here
        VertexBuffer vb = context.getVertexBuffer();
        context.validateTextureOp(this, IDENT, tex, null, tex.getPixelFormat());
        vb.addQuad(dx1, dy1, dx2, dy2, tx1, ty1, tx2, ty2);
        tex.unlock();
    }

    private static RectBounds TMP_BOUNDS = new RectBounds();
    @Override
    protected void renderShape(Shape shape, BasicStroke stroke,
                               float bx, float by, float bw, float bh)
    {
        if (isComplexPaint) {
            renderWithComplexPaint(shape, stroke, bx, by, bw, bh);
            return;
        }

        // The following is safe; this method does not mutate the transform
        BaseTransform xform = getTransformNoClone();
        MaskData maskData =
            ShapeUtil.rasterizeShape(shape, stroke, getFinalClipNoClone(), xform, true, isAntialiasedShape());
        Texture maskTex = context.validateMaskTexture(maskData, false);

        AffineBase paintTx;
        if (PrismSettings.primTextureSize != 0) {
            // the mask has been generated in device space, so we use
            // identity transform here
            Shader shader =
                context.validatePaintOp(this, IDENT, MaskType.ALPHA_TEXTURE, maskTex,
                                        bx, by, bw, bh);

            paintTx = getPaintTextureTx(xform, shader, bx, by, bw, bh);
        } else {
            // the mask has been generated in device space, so we use
            // identity transform here
            context.validatePaintOp(this, IDENT, maskTex, bx, by, bw, bh);
            paintTx = null;
        }

        context.updateMaskTexture(maskData, TMP_BOUNDS, false);

        float dx1 = maskData.getOriginX();
        float dy1 = maskData.getOriginY();
        float dx2 = dx1 + maskData.getWidth();
        float dy2 = dy1 + maskData.getHeight();
        float tx1 = TMP_BOUNDS.getMinX();
        float ty1 = TMP_BOUNDS.getMinY();
        float tx2 = TMP_BOUNDS.getMaxX();
        float ty2 = TMP_BOUNDS.getMaxY();

        VertexBuffer vb = context.getVertexBuffer();
        vb.addQuad(dx1, dy1, dx2, dy2, tx1, ty1, tx2, ty2, paintTx);

        maskTex.unlock();
    }

    private static float getStrokeExpansionFactor(BasicStroke stroke) {
        if (stroke.getType() == BasicStroke.TYPE_OUTER) {
            return 1f;
        } else if (stroke.getType() == BasicStroke.TYPE_CENTERED) {
            return 0.5f;
        } else {
            return 0f;
<A NAME="6"></A>        }
    }

    <FONT color="#50ebec"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#6',2,'match37-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private static final float FRINGE_FACTOR;
    static {
        String v = (String) AccessController.doPrivileged((PrivilegedAction) () -&gt; System.getProperty(&quot;prism.primshaderpad&quot;));
        if (v == null) {
            FRINGE_FACTOR = -0.5f;
        } else {</B></FONT>
            FRINGE_FACTOR = -Float.valueOf(v);
            System.out.println(&quot;Prism ShaderGraphics primitive shader pad = &quot;+FRINGE_FACTOR);
        }
    }

    private BaseTransform extract3Dremainder(BaseTransform xform) {
        if (xform.is2D()) {
            return IDENT;
        }
        TEMP_TX3D.setTransform(xform);
        TEMP_TX2D.setTransform(xform.getMxx(), xform.getMyx(),
                               xform.getMxy(), xform.getMyy(),
                               xform.getMxt(), xform.getMyt());
        try {
            TEMP_TX2D.invert();
            TEMP_TX3D.concatenate(TEMP_TX2D);
        } catch (NoninvertibleTransformException ex) {
        }
        return TEMP_TX3D;
    }

    private void renderGeneralRoundedRect(float rx, float ry, float rw, float rh,
                                          float arcw, float arch,
                                          MaskType type, BasicStroke stroke)
    {
        // NOTE: using floats here for now, not sure if it's a problem yet...
        float bx, by, bw, bh, ifractw, ifracth;
        float ox, oy, wdx, wdy, hdx, hdy;
        if (stroke == null) {
            bx = rx;
            by = ry;
            bw = rw;
            bh = rh;
            ifractw = ifracth = 0f;
        } else {
            float sw = stroke.getLineWidth();
            float ow = getStrokeExpansionFactor(stroke) * sw;
            bx = rx - ow;
            by = ry - ow;
            ow *= 2f;
            bw = rw + ow;
            bh = rh + ow;
            if (arcw &gt; 0 &amp;&amp; arch &gt; 0) {
                arcw += ow;
                arch += ow;
            } else {
                if (stroke.getLineJoin() == BasicStroke.JOIN_ROUND) {
                    arcw = arch = ow;
                    type = MaskType.DRAW_ROUNDRECT;
                } else {
                    arcw = arch = 0f;
                }
            }
            ifractw = (bw - sw * 2f) / bw;
            ifracth = (bh - sw * 2f) / bh;
            if (ifractw &lt;= 0f || ifracth &lt;= 0f) {
                type = type.getFillType();
            }
        }

        // The following is safe; this method does not mutate the transform
        BaseTransform xform = getTransformNoClone();
        BaseTransform rendertx;
        if (isSimpleTranslate) {
            wdx = hdy = 1f;
            wdy = hdx = 0f;
            ox = bx + transX;
            oy = by + transY;
            rendertx = IDENT;
        } else {
            rendertx = extract3Dremainder(xform);
            wdx = (float)xform.getMxx();
            hdx = (float)xform.getMxy();
            wdy = (float)xform.getMyx();
            hdy = (float)xform.getMyy();
            ox = (bx * wdx) + (by * hdx) + (float)xform.getMxt();
            oy = (bx * wdy) + (by * hdy) + (float)xform.getMyt();
        }

        wdx *= bw;
        wdy *= bw;
        hdx *= bh;
        hdy *= bh;

        float arcfractw = arcw / bw;
        float arcfracth = arch / bh;
        renderGeneralRoundedPgram(ox, oy, wdx, wdy, hdx, hdy,
                                  arcfractw, arcfracth, ifractw, ifracth,
                                  rendertx, type, rx, ry, rw, rh);
    }

    private void renderGeneralRoundedPgram(float ox, float oy,
                                           float wvecx, float wvecy,
                                           float hvecx, float hvecy,
                                           float arcfractw, float arcfracth,
                                           float ifractw, float ifracth,
                                           BaseTransform rendertx, MaskType type,
                                           float rx, float ry, float rw, float rh)
    {
        float wlen = len(wvecx, wvecy);
        float hlen = len(hvecx, hvecy);
        if (wlen == 0 || hlen == 0) {
            // parallelogram has collapsed to a line or point
            return;
        }

        // Calculate the 4 corners of the pgram in device space.
        // Note that the UL,UR,LL,LR (Upper/Lower Left/Right) designations
        // are virtual since the wdxy and hdxy vectors can point in any
        // direction depending on the transform being applied.
        float xUL = ox;
        float yUL = oy;
        float xUR = ox + wvecx;
        float yUR = oy + wvecy;
        float xLL = ox + hvecx;
        float yLL = oy + hvecy;
        float xLR = xUR + hvecx;
        float yLR = yUR + hvecy;

        // Calculate the unit vectors along each side of the pgram as well
        // as the device space perpendicular dimension across the pgram
        // (which is different than the lengths of the two pairs of sides
        //  since it is measured perpendicular to the &quot;other&quot; sides, not
        //  along the original sides).
        // The perpendicular dimension is the dot product of the perpendicular
        // of the unit vector for one pair of sides with the displacement
        // vector for the other pair of sides.
        // The unit vector perpendicular to (dx,dy) is given by:
        // normx = dx / len(dx, dy);
        // normy = dy / len(dx, dy);
        // The (ccw) perpendicular vectors would then be:
        // unitperpx = +normy = +dy / len;
        // unitperpy = -normx = -dx / len;
        // Thus the perpendicular width and height distances are:
        // pwdist = wvec.uphvec = wvecx * (hvecy/hlen) - wvecy * (hvecx/hlen)
        // phdist = hvec.upwvec = hvecx * (wvecy/wlen) - hvecy * (wvecx/wlen)
        // If we factor out the divide by the lengths then we are left
        // with numerators that are simply negations of each other:
        // pwdist = (wvecx * hvecy - wvecy * hvecx) / hlen
        // phdist = (hvecx * wvecy - hvecy * wvecx) / wlen
        // Finally we multiply by 0.5 since we want the distance to the
        // edges of the parallelgram from the center point, not across the
        // whole pgram.  And, since we want the absolute value, we can
        // ignore the fact that the numerator is negated between the two
        // formulas since we will just have to negate one of the 2 values
        // afterwards anyway to make them both positive.
        // Note that the numerators are the formula for the area of the
        // parallelogram (without the abs() operation).  Dividing by the
        // length of one of the sides would then give the length of the
        // perpendicular across to the other side.
        float halfarea = (wvecx * hvecy - wvecy * hvecx) * 0.5f;
        float pwdist = halfarea / hlen;
        float phdist = halfarea / wlen;
        if (pwdist &lt; 0) pwdist = -pwdist;
        if (phdist &lt; 0) phdist = -phdist;

        // Now we calculate the normalized unit vectors.
        float nwvecx = wvecx / wlen;
        float nwvecy = wvecy / wlen;
        float nhvecx = hvecx / hlen;
        float nhvecy = hvecy / hlen;

        // Bias the parallelogram corner coordinates &quot;outward&quot; by half a
        // pixel distance.
        // The most general way to do this is to move each parallelogram
        // edge outward by a specified distance and then find the new
        // intersection point.
        // The general form for the intersection of 2 lines is:
        // line1 = (x1,y1) -&gt; (x2,y2)
        // line2 = (x3,y3) -&gt; (x4,y4)
        // t = ((x4-x3)(y1-y3) - (y4-y3)(x1-x3))
        //   / ((y4-y3)(x2-x1) - (x4-x3)(y2-y1))
        // intersection point = (x1 + t*(x2-x1), y1 + t*(y2-y1))
        // Now consider if these lines are displaced versions of 2
        // other lines which share a common end point (such as is the
        // case of pushing 2 adjacent edges of the pgram outward:
        // line1 = (xa+dx1, ya+dy1) -&gt; (xb+dx1, yb+dy1)
        // line2 = (xa+dx2, ya+dy2) -&gt; (xc+dx2, yc+dy2)
        // &quot;x4-x3&quot; = (xc+dx2) - (xa+dx2) = xc-xa
        // &quot;y4-y3&quot; = (yc+dy2) - (ya+dy2) = yc-ya
        // &quot;x2-x1&quot; = (xb+dx1) - (xa+dx1) = xb-xa
        // &quot;y2-y1&quot; = (yb+dy1) - (ya+dy1) = yb-ya
        // &quot;y1-y3&quot; = (y1+dy1) - (y1+dy2) = dy1 - dy2
        // &quot;x1-x3&quot; = (xa+dx1) - (xa+dx2) = dx1 - dx2
        // t = ((xc-xa)(dy1-dy2) - ((yc-ya)(dx1-dx2))
        //   / ((yc-ya)(xb-xa) - (xc-xa)(yb-ya))
        // Now we need to displace these 2 lines &quot;outward&quot; by half a
        // pixel distance.  We will start by looking at applying a unit
        // pixel distance and then cutting the adjustment in half (it
        // can be seen to scale linearly when you look at the final
        // equations).  This is achieved by applying one of our unit
        // vectors with a cw rotation to one line and the other unit
        // vector with a ccw rotation to the other line.  Ideally we
        // would choose which to apply cw vs. ccw by the way that this
        // corner of the pgram is turning, but as it turns out, the
        // consequences of getting it backward is that our &quot;t&quot; will
        // turn out negative (just negate all of the d[xy][12] values
        // in the t equation above and you will see that it changes
        // sign.  Since we are calculating the new corner using the
        // equation newx = (xa+dx1) + t*(xb-xa), we want the value of
        // t that drives the point &quot;away from xb,yb&quot;, in other words,
        // we want the negative t.  So, if t is positive then we want
        // to use negative t and reverse the perpendicular offset we
        // applied to xa:
        // t &lt; 0 =&gt; newx = (xa+dx) + t*(xb-xa) = xa + (dx + t*(xb-xa))
        // t &gt; 0 =&gt; newx = (xa-dx) - t*(xb-xa) = xa - (dx + t*(xb-xa))
        // where (copying t equation from above again):
        // t = ((xc-xa)(dy1-dy2) - ((yc-ya)(dx1-dx2))
        //   / ((yc-ya)(xb-xa) - (xc-xa)(yb-ya))
        // For xa,ya = xUL,yUL and xb,yb = xUR,yUR and xc,yc = xLL,yLL:
        // [xy]b - [xy]a = [xy]UR - [xy]UL = wvec
        // [xy]c - [xy]a = [xy]LL - [xy]UL = hvec
        // dx1,dy1 = +nwvecy, -nwvecx  // ccw on xa-&gt;xb
        // dx2,dy2 = -nhvecy, +nhvecx  //  cw on xa-&gt;xc
        // dx1 - dx2 = +nwvecy - -nhvecy = nwvecy + nhvecy
        // dy1 - dy2 = -nwvecx - +nhvecx = -(nwvecx + nhvecx)
        float num = -hvecx*(nwvecx + nhvecx) - hvecy*(nwvecy + nhvecy);
        float den = hvecy*wvecx - hvecx*wvecy;
        float t = num / den;
        // Negating the sign of t and multiplying by 0.5 gets us the
        // proper sign for the offset and cuts it down to half a pixel
        float factor = FRINGE_FACTOR * Math.signum(t);
        float offx = (t * wvecx + nwvecy) * factor;
        float offy = (t * wvecy - nwvecx) * factor;
        xUL += offx; yUL += offy;
        // x22 is offset by the reverse amounts
        xLR -= offx; yLR -= offy;
        // For xa,ya = xUR,yUR and xb,yb = xLR,yLR and xc,yc = xUL,yUL
        // Note that xa,ya =&gt; xc,yc is negative of wvec
        // [xy]b - [xy]a = [xy]LR - [xy]UR = +hvec
        // [xy]c - [xy]a = [xy]UL - [xy]UR = -wvec
        // dx1,dy1                          = +nhvecy, -nhvecx
        // dx2,dy2 = -(-nwvecy), +(-nwvecx) = +nwvecy, -nwvecx
        // dx1 - dx2                     = nhvecy - nwvecy
        // dy1 - dy2 = -nhvecx - -nwvecx = nwvecx - nhvecx
        // den = -wvecy * hvecx - -wvecx * hvecy
        //     = hvecy * wvecx - hvecx * wvecy (already computed)
        // num = -wvecx * (nwvecx - nhvecx) - -wvecy * (nhvecy - nwvecy)
        //     = wvecy * (nhvecy - nwvecy) - wvecx * (nwvecx - nhvecx)
        num = wvecy * (nhvecy - nwvecy) - wvecx * (nwvecx - nhvecx);
        t = num / den;
        factor = FRINGE_FACTOR * Math.signum(t);
        offx = (t * hvecx + nhvecy) * factor;
        offy = (t * hvecy - nhvecx) * factor;
        xUR += offx; yUR += offy;
        xLL -= offx; yLL -= offy;

        // texture coordinates (uv) will be calculated using a transform
        // by the perpendicular unit vectors so that the texture U
        // coordinates measure our progress along the pwdist axis (i.e.
        // perpendicular to hvec and the texture V coordinates measure
        // our progress along phdist (perpendicular to wvec):
        // u = x * nhvecy - y * nhvecx;
        // v = x * nwvecy - y * nwvecx;

        // We now calculate the uv paramters for the 4 corners such that
        //     uv(cx,cy) = 0,0
        //     uv(corners - center) = +/-(wlen/2), +/-(hlen/2)
        // Note that:
        //     uv(corner - center) = uv(corner) - uv(center)
        // Calculate the center of the parallelogram and its uv values
        float xC = (xUL + xLR) * 0.5f;
        float yC = (yUL + yLR) * 0.5f;
        float uC = xC * nhvecy - yC * nhvecx;
        float vC = xC * nwvecy - yC * nwvecx;
        // Now use that to calculate the corner values relative to the center
        float uUL = xUL * nhvecy - yUL * nhvecx - uC;
        float vUL = xUL * nwvecy - yUL * nwvecx - vC;
        float uUR = xUR * nhvecy - yUR * nhvecx - uC;
        float vUR = xUR * nwvecy - yUR * nwvecx - vC;
        float uLL = xLL * nhvecy - yLL * nhvecx - uC;
        float vLL = xLL * nwvecy - yLL * nwvecx - vC;
        float uLR = xLR * nhvecy - yLR * nhvecx - uC;
        float vLR = xLR * nwvecy - yLR * nwvecx - vC;

        // the pgram params have been calculated in device space, so we use
        // identity transform here
        if (type == MaskType.DRAW_ROUNDRECT || type == MaskType.FILL_ROUNDRECT) {
            float oarcw = pwdist * arcfractw;
            float oarch = phdist * arcfracth;
            if (oarcw &lt; 0.5 || oarch &lt; 0.5) {
                // The pgram renderer fades the entire primitive if the arc
                // sizes fall below 0.5 pixels since the interiors act as if
                // they are sampled at the center of the indicated circle and
                // radii smaller than that produce less than full coverage
                // even at the circle center.  If the arcwh are less than
                // 0.5 then the difference in area of the corner pixels
                // compared to a PGRAM primitive of the same size is just the
                // tiny corner cutout of area (4-PI)/16 which is less than
                // .06 pixels.  Thus, we can convert the primitive to a
                // PGRAM without any loss of precision.
                type = (type == MaskType.DRAW_ROUNDRECT)
                    ? MaskType.DRAW_PGRAM : MaskType.FILL_PGRAM;
            } else {
                float flatw = pwdist - oarcw;
                float flath = phdist - oarch;
                float ivalw, ivalh;
                if (type == MaskType.DRAW_ROUNDRECT) {
                    float iwdist = pwdist * ifractw;
                    float ihdist = phdist * ifracth;
                    // First we calculate the inner arc radii and see if they
                    // are large enough to render.
                    ivalw = iwdist - flatw;
                    ivalh = ihdist - flath;
                    // As above we need to fix things if we get inner arc
                    // radii below half a pixel.  We have a special shader
                    // for doing a &quot;semi round&quot; rect which has a round outer
                    // shell and a rectangular (pgram) inner shell...
                    if (ivalw &lt; 0.5f || ivalh &lt; 0.5f) {
                        // inner val is idim
                        ivalw = iwdist;
                        ivalh = ihdist;
                        type = MaskType.DRAW_SEMIROUNDRECT;
                    } else {
                        // inner val is invarcradii
                        ivalw = 1.0f / ivalw;
                        ivalh = 1.0f / ivalh;
                    }
                } else {
                    // Not used by FILL_ROUNDRECT, but we need constant
                    // values that will not cause an unnecessary vertex
                    // buffer flush in the validateOp below.
                    ivalw = ivalh = 0f;
                }
                oarcw = 1.0f / oarcw;
                oarch = 1.0f / oarch;
                Shader shader =
                    context.validatePaintOp(this, rendertx, type,
                                            rx, ry, rw, rh,
                                            oarcw, oarch,
                                            ivalw, ivalh, 0, 0);
                shader.setConstant(&quot;oinvarcradii&quot;, oarcw, oarch);
                if (type == MaskType.DRAW_ROUNDRECT) {
                    shader.setConstant(&quot;iinvarcradii&quot;, ivalw, ivalh);
                } else if (type == MaskType.DRAW_SEMIROUNDRECT) {
                    shader.setConstant(&quot;idim&quot;, ivalw, ivalh);
                }
                pwdist = flatw;
                phdist = flath;
            }
        } // no else here as we may have converted an RRECT to a PGRAM above
        if (type == MaskType.DRAW_PGRAM || type == MaskType.DRAW_ELLIPSE) {
            float idimw = pwdist * ifractw;
            float idimh = phdist * ifracth;
            if (type == MaskType.DRAW_ELLIPSE) {
                if (Math.abs(pwdist - phdist) &lt; .01) {
                    type = MaskType.DRAW_CIRCLE;
                    // The phdist and idimh parameters will not be used by this
                    // shader, but we do need the maximum single pixel coverage
                    // so we coopt them to be min(1.0, area):
                    phdist = (float) Math.min(1.0, phdist * phdist * Math.PI);
                    idimh = (float) Math.min(1.0, idimh * idimh * Math.PI);
                } else {
                    // the ellipse drawing shader uses inverted arc dimensions
                    // to turn divides into multiplies
                    pwdist = 1.0f / pwdist;
                    phdist = 1.0f / phdist;
                    idimw = 1.0f / idimw;
                    idimh = 1.0f / idimh;
                }
            }
            Shader shader =
                context.validatePaintOp(this, rendertx, type,
                                        rx, ry, rw, rh,
                                        idimw, idimh, 0f, 0f, 0f, 0f);
            shader.setConstant(&quot;idim&quot;, idimw, idimh);
        } else if (type == MaskType.FILL_ELLIPSE) {
            if (Math.abs(pwdist - phdist) &lt; .01) {
                type = MaskType.FILL_CIRCLE;
                // The phdist parameter will not be used by this shader,
                // but we do need the maximum single pixel contribution
                // so we coopt the value to be min(1.0, area):
                phdist = (float) Math.min(1.0, phdist * phdist * Math.PI);
            } else {
                // the ellipse filling shader uses inverted arc dimensions to
                // turn divides into multiplies:
                pwdist = 1.0f / pwdist;
                phdist = 1.0f / phdist;
                uUL *= pwdist;    vUL *= phdist;
                uUR *= pwdist;    vUR *= phdist;
                uLL *= pwdist;    vLL *= phdist;
                uLR *= pwdist;    vLR *= phdist;
            }
            context.validatePaintOp(this, rendertx, type, rx, ry, rw, rh);
        } else if (type == MaskType.FILL_PGRAM) {
            context.validatePaintOp(this, rendertx, type, rx, ry, rw, rh);
        }

        context.getVertexBuffer().addMappedPgram(xUL, yUL, xUR, yUR,
                                                 xLL, yLL, xLR, yLR,
                                                 uUL, vUL, uUR, vUR,
                                                 uLL, vLL, uLR, vLR,
                                                 pwdist, phdist);
    }

    AffineBase getPaintTextureTx(BaseTransform renderTx, Shader shader,
                                 float rx, float ry, float rw, float rh)
    {
        switch (paint.getType()) {
            case COLOR:
                return null;
            case LINEAR_GRADIENT:
                return PaintHelper.getLinearGradientTx((LinearGradient) paint,
                                                       shader, renderTx,
                                                       rx, ry, rw, rh);
            case RADIAL_GRADIENT:
                return PaintHelper.getRadialGradientTx((RadialGradient) paint,
                                                       shader, renderTx,
                                                       rx, ry, rw, rh);
            case IMAGE_PATTERN:
                return PaintHelper.getImagePatternTx(this, (ImagePattern) paint,
                                                     shader, renderTx,
                                                     rx, ry, rw, rh);
        }
        throw new InternalError(&quot;Unrecogized paint type: &quot;+paint);
    }

    // The second set of rectangular bounds are for validating a
    // proportional paint.  They should be identical to the first
    // set for a fillRect() operation, but they may be different
    // for a vertical or horizontal drawLine() operation.
    boolean fillPrimRect(float x, float y, float w, float h,
                         Texture rectTex, Texture wrapTex,
                         float bx, float by, float bw, float bh)
    {
        BaseTransform xform = getTransformNoClone();
        float mxx = (float) xform.getMxx();
        float mxy = (float) xform.getMxy();
        float mxt = (float) xform.getMxt();
        float myx = (float) xform.getMyx();
        float myy = (float) xform.getMyy();
        float myt = (float) xform.getMyt();
        float dxdist = len(mxx, myx);
        float dydist = len(mxy, myy);
        if (dxdist == 0.0f || dydist == 0.0f) {
            // entire path has collapsed and occupies no area
            return true;
        }
        float pixelw = 1.0f / dxdist;
        float pixelh = 1.0f / dydist;
        float x0 = x - pixelw * 0.5f;
        float y0 = y - pixelh * 0.5f;
        float x1 = x + w + pixelw * 0.5f;
        float y1 = y + h + pixelh * 0.5f;
        int cellw = (int) Math.ceil(w * dxdist - 1.0f/512.0f);
        int cellh = (int) Math.ceil(h * dydist - 1.0f/512.0f);
        VertexBuffer vb = context.getVertexBuffer();
        int max = context.getRectTextureMaxSize();
        if (cellw &lt;= max &amp;&amp; cellh &lt;= max) {
            float u0 = ((cellw * (cellw + 1)) / 2) - 0.5f;
            float v0 = ((cellh * (cellh + 1)) / 2) - 0.5f;
            float u1 = u0 + cellw + 1.0f;
            float v1 = v0 + cellh + 1.0f;
            u0 /= rectTex.getPhysicalWidth();
            v0 /= rectTex.getPhysicalHeight();
            u1 /= rectTex.getPhysicalWidth();
            v1 /= rectTex.getPhysicalHeight();
            if (xform.isTranslateOrIdentity()) {
                x0 += mxt;
                y0 += myt;
                x1 += mxt;
                y1 += myt;
                xform = IDENT;
            } else if (xform.is2D()) {
                Shader shader =
                    context.validatePaintOp(this, IDENT, MaskType.ALPHA_TEXTURE, rectTex,
                                            bx, by, bw, bh);
                AffineBase paintTx = getPaintTextureTx(IDENT, shader, bx, by, bw, bh);
                if (paintTx == null) {
                    vb.addMappedPgram(x0 * mxx + y0 * mxy + mxt, x0 * myx + y0 * myy + myt,
                                      x1 * mxx + y0 * mxy + mxt, x1 * myx + y0 * myy + myt,
                                      x0 * mxx + y1 * mxy + mxt, x0 * myx + y1 * myy + myt,
                                      x1 * mxx + y1 * mxy + mxt, x1 * myx + y1 * myy + myt,
                                      u0, v0, u1, v0, u0, v1, u1, v1, 0, 0);
                } else {
                    vb.addMappedPgram(x0 * mxx + y0 * mxy + mxt, x0 * myx + y0 * myy + myt,
                                      x1 * mxx + y0 * mxy + mxt, x1 * myx + y0 * myy + myt,
                                      x0 * mxx + y1 * mxy + mxt, x0 * myx + y1 * myy + myt,
                                      x1 * mxx + y1 * mxy + mxt, x1 * myx + y1 * myy + myt,
                                      u0, v0, u1, v0, u0, v1, u1, v1,
                                      x0, y0, x1, y1, paintTx);
                }
                return true;
            } else {
                System.out.println(&quot;Not a 2d transform!&quot;);
                mxt = myt = 0.0f;
            }
            Shader shader =
                context.validatePaintOp(this, xform, MaskType.ALPHA_TEXTURE, rectTex,
                                        bx, by, bw, bh);
            AffineBase paintTx = getPaintTextureTx(IDENT, shader, bx, by, bw, bh);
            if (paintTx == null) {
                vb.addQuad(x0, y0, x1, y1,
                           u0, v0, u1, v1);
            } else {
                paintTx.translate(-mxt, -myt);
                vb.addQuad(x0, y0, x1, y1,
                           u0, v0, u1, v1,
                           paintTx);
            }
            return true;
        }
        if (wrapTex == null) {
            return false;
        }
        float u0 = 0.5f / wrapTex.getPhysicalWidth();
        float v0 = 0.5f / wrapTex.getPhysicalHeight();
        float uc = (cellw * 0.5f + 1.0f) / wrapTex.getPhysicalWidth();
        float vc = (cellh * 0.5f + 1.0f) / wrapTex.getPhysicalHeight();
        float xc = x + w * 0.5f;
        float yc = y + h * 0.5f;
        if (xform.isTranslateOrIdentity()) {
            x0 += mxt;
            y0 += myt;
            xc += mxt;
            yc += myt;
            x1 += mxt;
            y1 += myt;
            xform = IDENT;
        } else if (xform.is2D()) {
            Shader shader =
                context.validatePaintOp(this, IDENT, MaskType.ALPHA_TEXTURE, wrapTex,
                                        bx, by, bw, bh);
            AffineBase paintTx = getPaintTextureTx(IDENT, shader, bx, by, bw, bh);
            float mxx_x0 = mxx * x0, myx_x0 = myx * x0;
            float mxy_y0 = mxy * y0, myy_y0 = myy * y0;
            float mxx_xc = mxx * xc, myx_xc = myx * xc;
            float mxy_yc = mxy * yc, myy_yc = myy * yc;
            float mxx_x1 = mxx * x1, myx_x1 = myx * x1;
            float mxy_y1 = mxy * y1, myy_y1 = myy * y1;
            // xcc,ycc used in all 4 quads
            float xcc = mxx_xc + mxy_yc + mxt;
            float ycc = myx_xc + myy_yc + myt;
            // xcn, ycn and xnc, ync all used in 2 quads each
            float xc0 = mxx_xc + mxy_y0 + mxt;
            float yc0 = myx_xc + myy_y0 + myt;
            float x0c = mxx_x0 + mxy_yc + mxt;
            float y0c = myx_x0 + myy_yc + myt;
            float xc1 = mxx_xc + mxy_y1 + mxt;
            float yc1 = myx_xc + myy_y1 + myt;
            float x1c = mxx_x1 + mxy_yc + mxt;
            float y1c = myx_x1 + myy_yc + myt;
            // Note that all quads use same 00-&gt;c0-&gt;0c-&gt;cc coordinates for
            // the inner and outer uv texture coordinates regardless of the
            // reflection of the quad of vertex coordinates

            if (paintTx == null) {
                // quad1 - 00 -&gt; c0 -&gt; 0c -&gt; cc
                vb.addMappedPgram(x0 * mxx + y0 * mxy + mxt, x0 * myx + y0 * myy + myt,
                                           xc0, yc0, x0c, y0c, xcc, ycc,
                                  u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc, 0, 0);
                // quad2 - 10 -&gt; c0 -&gt; 1c -&gt; cc (reflect quad1 around x=c)
                vb.addMappedPgram(x1 * mxx + y0 * mxy + mxt, x1 * myx + y0 * myy + myt,
                                           xc0, yc0, x1c, y1c, xcc, ycc,
                                  u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc, 0, 0);
                // quad3 - 01 -&gt; c1 -&gt; 0c -&gt; cc (reflect quad1 around y=c)
                vb.addMappedPgram(x0 * mxx + y1 * mxy + mxt, x0 * myx + y1 * myy + myt,
                                           xc1, yc1, x0c, y0c, xcc, ycc,
                                  u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc, 0, 0);
                // quad4 - 11 -&gt; c1 -&gt; 1c -&gt; cc (reflect quad1 around x=c and y=c)
                vb.addMappedPgram(x1 * mxx + y1 * mxy + mxt, x1 * myx + y1 * myy + myt,
                                           xc1, yc1, x1c, y1c, xcc, ycc,
                                  u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc, 0, 0);
            } else {
                // quad1 - 00 -&gt; c0 -&gt; 0c -&gt; cc
                vb.addMappedPgram(x0 * mxx + y0 * mxy + mxt, x0 * myx + y0 * myy + myt,
                                           xc0, yc0, x0c, y0c, xcc, ycc,
                                  u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc,
                                  x0, y0, xc, yc, paintTx);
                // quad2 - 10 -&gt; c0 -&gt; 1c -&gt; cc (reflect quad1 around x=c)
                vb.addMappedPgram(x1 * mxx + y0 * mxy + mxt, x1 * myx + y0 * myy + myt,
                                           xc0, yc0, x1c, y1c, xcc, ycc,
                                  u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc,
                                  x1, y0, xc, yc, paintTx);
                // quad3 - 01 -&gt; c1 -&gt; 0c -&gt; cc (reflect quad1 around y=c)
                vb.addMappedPgram(x0 * mxx + y1 * mxy + mxt, x0 * myx + y1 * myy + myt,
                                           xc1, yc1, x0c, y0c, xcc, ycc,
                                  u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc,
                                  x0, y1, xc, yc, paintTx);
                // quad4 - 11 -&gt; c1 -&gt; 1c -&gt; cc (reflect quad1 around x=c and y=c)
                vb.addMappedPgram(x1 * mxx + y1 * mxy + mxt, x1 * myx + y1 * myy + myt,
                                           xc1, yc1, x1c, y1c, xcc, ycc,
                                  u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc,
                                  x1, y1, xc, yc, paintTx);
            }
            return true;
        } else {
            System.out.println(&quot;Not a 2d transform!&quot;);
            mxt = myt = 0;
        }
        Shader shader =
            context.validatePaintOp(this, xform, MaskType.ALPHA_TEXTURE, wrapTex,
                                    bx, by, bw, bh);
        AffineBase paintTx = getPaintTextureTx(IDENT, shader, bx, by, bw, bh);
        if (paintTx != null) {
            paintTx.translate(-mxt, -myt);
        }
        vb.addQuad(x0, y0, xc, yc,
                   u0, v0, uc, vc,
                   paintTx);
        vb.addQuad(x1, y0, xc, yc,
                   u0, v0, uc, vc,
                   paintTx);
        vb.addQuad(x0, y1, xc, yc,
                   u0, v0, uc, vc,
                   paintTx);
        vb.addQuad(x1, y1, xc, yc,
                   u0, v0, uc, vc,
                   paintTx);
        return true;
    }

    boolean drawPrimRect(float x, float y, float w, float h) {
        float lw = stroke.getLineWidth();
        float pad = getStrokeExpansionFactor(stroke) * lw;
        BaseTransform xform = getTransformNoClone();
        float mxx = (float) xform.getMxx();
        float mxy = (float) xform.getMxy();
        float mxt = (float) xform.getMxt();
        float myx = (float) xform.getMyx();
        float myy = (float) xform.getMyy();
        float myt = (float) xform.getMyt();
        float dxdist = len(mxx, myx);
        float dydist = len(mxy, myy);
        if (dxdist == 0.0f || dydist == 0.0f) {
            // entire path has collapsed and occupies no area
            return true;
        }
        float pixelw = 1.0f / dxdist;
        float pixelh = 1.0f / dydist;
        float x0 = x - pad - pixelw * 0.5f;
        float y0 = y - pad - pixelh * 0.5f;
        float xc = x + w * 0.5f;
        float yc = y + h * 0.5f;
        float x1 = x + w + pad + pixelw * 0.5f;
        float y1 = y + h + pad + pixelh * 0.5f;
        Texture rTex = context.getWrapRectTexture();
        float wscale = 1.0f / rTex.getPhysicalWidth();
        float hscale = 1.0f / rTex.getPhysicalHeight();
        float ou0 = 0.5f * wscale;
        float ov0 = 0.5f * hscale;
        float ouc = ((w * 0.5f + pad) * dxdist + 1.0f) * wscale;
        float ovc = ((h * 0.5f + pad) * dydist + 1.0f) * hscale;
        float offsetx = lw * dxdist * wscale;
        float offsety = lw * dydist * hscale;
        VertexBuffer vb = context.getVertexBuffer();
        if (xform.isTranslateOrIdentity()) {
            x0 += mxt;
            y0 += myt;
            xc += mxt;
            yc += myt;
            x1 += mxt;
            y1 += myt;
            xform = IDENT;
        } else if (xform.is2D()) {
            Shader shader =
                context.validatePaintOp(this, IDENT, MaskType.ALPHA_TEXTURE_DIFF,
                                        rTex, x, y, w, h,
                                        offsetx, offsety, 0, 0, 0, 0);
            shader.setConstant(&quot;innerOffset&quot;, offsetx, offsety);
            AffineBase paintTx = getPaintTextureTx(IDENT, shader, x, y, w, h);
            float mxx_x0 = mxx * x0, myx_x0 = myx * x0;
            float mxy_y0 = mxy * y0, myy_y0 = myy * y0;
            float mxx_xc = mxx * xc, myx_xc = myx * xc;
            float mxy_yc = mxy * yc, myy_yc = myy * yc;
            float mxx_x1 = mxx * x1, myx_x1 = myx * x1;
            float mxy_y1 = mxy * y1, myy_y1 = myy * y1;

            // xcc,ycc used in all 4 quads
            float xcc = mxx_xc + mxy_yc + mxt;
            float ycc = myx_xc + myy_yc + myt;
            // xcn, ycn and xnc, ync all used in 2 quads each
            float xc0 = mxx_xc + mxy_y0 + mxt;
            float yc0 = myx_xc + myy_y0 + myt;
            float x0c = mxx_x0 + mxy_yc + mxt;
            float y0c = myx_x0 + myy_yc + myt;
            float xc1 = mxx_xc + mxy_y1 + mxt;
            float yc1 = myx_xc + myy_y1 + myt;
            float x1c = mxx_x1 + mxy_yc + mxt;
            float y1c = myx_x1 + myy_yc + myt;
            // Note that all quads use same 00-&gt;c0-&gt;0c-&gt;cc coordinates for
            // the inner and outer uv texture coordinates regardless of the
            // reflection of the quad of vertex coordinates

            if (paintTx == null) {
                // quad1 - 00 -&gt; c0 -&gt; 0c -&gt; cc
                vb.addMappedPgram(mxx_x0 + mxy_y0 + mxt, myx_x0 + myy_y0 + myt,
                                            xc0, yc0, x0c, y0c, xcc, ycc,
                                  ou0, ov0, ouc, ov0, ou0, ovc, ouc, ovc,
                                  0, 0);
                // quad2 - 10 -&gt; c0 -&gt; 1c -&gt; cc (reflect quad1 around x=c)
                vb.addMappedPgram(mxx_x1 + mxy_y0 + mxt, myx_x1 + myy_y0 + myt,
                                            xc0, yc0, x1c, y1c, xcc, ycc,
                                  ou0, ov0, ouc, ov0, ou0, ovc, ouc, ovc,
                                  0, 0);
                // quad3 - 01 -&gt; c1 -&gt; 0c -&gt; cc (reflect quad1 around y=c)
                vb.addMappedPgram(mxx_x0 + mxy_y1 + mxt, myx_x0 + myy_y1 + myt,
                                            xc1, yc1, x0c, y0c, xcc, ycc,
                                  ou0, ov0, ouc, ov0, ou0, ovc, ouc, ovc,
                                  0, 0);
                // quad4 - 11 -&gt; c1 -&gt; 1c -&gt; cc (reflect quad1 around x=c and y=c)
                vb.addMappedPgram(mxx_x1 + mxy_y1 + mxt, myx_x1 + myy_y1 + myt,
                                            xc1, yc1, x1c, y1c, xcc, ycc,
                                  ou0, ov0, ouc, ov0, ou0, ovc, ouc, ovc,
                                  0, 0);
            } else {
                // quad1 - 00 -&gt; c0 -&gt; 0c -&gt; cc
                vb.addMappedPgram(mxx_x0 + mxy_y0 + mxt, myx_x0 + myy_y0 + myt,
                                            xc0, yc0, x0c, y0c, xcc, ycc,
                                  ou0, ov0, ouc, ov0, ou0, ovc, ouc, ovc,
                                  x0, y0, xc, yc, paintTx);
                // quad2 - 10 -&gt; c0 -&gt; 1c -&gt; cc (reflect quad1 around x=c)
                vb.addMappedPgram(mxx_x1 + mxy_y0 + mxt, myx_x1 + myy_y0 + myt,
                                            xc0, yc0, x1c, y1c, xcc, ycc,
                                  ou0, ov0, ouc, ov0, ou0, ovc, ouc, ovc,
                                  x1, y0, xc, yc, paintTx);
                // quad3 - 01 -&gt; c1 -&gt; 0c -&gt; cc (reflect quad1 around y=c)
                vb.addMappedPgram(mxx_x0 + mxy_y1 + mxt, myx_x0 + myy_y1 + myt,
                                            xc1, yc1, x0c, y0c, xcc, ycc,
                                  ou0, ov0, ouc, ov0, ou0, ovc, ouc, ovc,
                                  x0, y1, xc, yc, paintTx);
                // quad4 - 11 -&gt; c1 -&gt; 1c -&gt; cc (reflect quad1 around x=c and y=c)
                vb.addMappedPgram(mxx_x1 + mxy_y1 + mxt, myx_x1 + myy_y1 + myt,
                                            xc1, yc1, x1c, y1c, xcc, ycc,
                                  ou0, ov0, ouc, ov0, ou0, ovc, ouc, ovc,
                                  x1, y1, xc, yc, paintTx);
            }
            rTex.unlock();
            return true;
        } else {
            System.out.println(&quot;Not a 2d transform!&quot;);
            mxt = myt = 0.0f;
        }
        Shader shader =
            context.validatePaintOp(this, xform, MaskType.ALPHA_TEXTURE_DIFF,
                                    rTex, x, y, w, h,
                                    offsetx, offsety, 0, 0, 0, 0);
        shader.setConstant(&quot;innerOffset&quot;, offsetx, offsety);
        AffineBase paintTx = getPaintTextureTx(IDENT, shader, x, y, w, h);
        if (paintTx != null) {
            paintTx.translate(-mxt, -myt);
        }
        vb.addQuad( x0,  y0,  xc,  yc,
                   ou0, ov0, ouc, ovc,
                   paintTx);
        vb.addQuad( x1,  y0,  xc,  yc,
                   ou0, ov0, ouc, ovc,
                   paintTx);
        vb.addQuad( x0,  y1,  xc,  yc,
                   ou0, ov0, ouc, ovc,
                   paintTx);
        vb.addQuad( x1,  y1,  xc,  yc,
                   ou0, ov0, ouc, ovc,
                   paintTx);
        rTex.unlock();
        return true;
    }

    boolean drawPrimDiagonal(float x1, float y1, float x2, float y2,
                             float lw, int cap,
                             float bx, float by, float bw, float bh)
    {
        // assert x1 != x2 &amp;&amp; y1 != y2, otherwise caller would have
        // vectored us to fillPrimRect()
        if (stroke.getType() == BasicStroke.TYPE_CENTERED) {
            lw *= 0.5f;
        }
        float dx = x2 - x1;
        float dy = y2 - y1;
        float len = len(dx, dy);
        dx /= len;
        dy /= len;
        float ldx = dx * lw;
        float ldy = dy * lw;
        // First expand perpendicularly using (ldy, -ldx)
        float xUL = x1 + ldy,  yUL = y1 - ldx;
        float xUR = x2 + ldy,  yUR = y2 - ldx;
        float xLL = x1 - ldy,  yLL = y1 + ldx;
        float xLR = x2 - ldy,  yLR = y2 + ldx;
        if (cap == BasicStroke.CAP_SQUARE) {
            // Then add SQUARE end caps using (ldx, ldy) if needed
            xUL -= ldx;  yUL -= ldy;
            xLL -= ldx;  yLL -= ldy;
            xUR += ldx;  yUR += ldy;
            xLR += ldx;  yLR += ldy;
        }

        float hdx, hdy, vdx, vdy;
        int cellw, cellh;
        BaseTransform xform = getTransformNoClone();
        float mxt = (float) xform.getMxt();
        float myt = (float) xform.getMyt();
        if (xform.isTranslateOrIdentity()) {
            hdx = dx;  hdy =  dy;
            vdx = dy;  vdy = -dx;
            cellw = (int) Math.ceil(len(xUR - xUL, yUR - yUL));
            cellh = (int) Math.ceil(len(xLL - xUL, yLL - yUL));
            xform = IDENT;
        } else if (xform.is2D()) {
            float mxx = (float) xform.getMxx();
            float mxy = (float) xform.getMxy();
            float myx = (float) xform.getMyx();
            float myy = (float) xform.getMyy();
            float tx, ty;
            tx = mxx * xUL + mxy * yUL;
            ty = myx * xUL + myy * yUL;
            xUL = tx;  yUL = ty;
            tx = mxx * xUR + mxy * yUR;
            ty = myx * xUR + myy * yUR;
            xUR = tx;  yUR = ty;
            tx = mxx * xLL + mxy * yLL;
            ty = myx * xLL + myy * yLL;
            xLL = tx;  yLL = ty;
            tx = mxx * xLR + mxy * yLR;
            ty = myx * xLR + myy * yLR;
            xLR = tx;  yLR = ty;
            // hdx, hdy are transformed unit vectors along the line
            hdx = mxx * dx + mxy * dy;
            hdy = myx * dx + myy * dy;
            float dlen = len(hdx, hdy);
            if (dlen == 0.0f) return true;
            hdx /= dlen;
            hdy /= dlen;
            // vdx, vdy are transformed perpendicular unit vectors
            // (perpendicular to the line in user space, but then transformed)
            vdx = mxx * dy - mxy * dx;
            vdy = myx * dy - myy * dx;
            dlen = len(vdx, vdy);
            if (dlen == 0.0f) return true;
            vdx /= dlen;
            vdy /= dlen;
            cellw = (int) Math.ceil(Math.abs((xUR - xUL) * hdx + (yUR - yUL) * hdy));
            cellh = (int) Math.ceil(Math.abs((xLL - xUL) * vdx + (yLL - yUL) * vdy));
            xform = IDENT;
        } else {
            System.out.println(&quot;Not a 2d transform!&quot;);
            return false;
        }
        hdx *= 0.5f;
        hdy *= 0.5f;
        vdx *= 0.5f;
        vdy *= 0.5f;
        xUL = xUL + mxt + vdx - hdx;
        yUL = yUL + myt + vdy - hdy;
        xUR = xUR + mxt + vdx + hdx;
        yUR = yUR + myt + vdy + hdy;
        xLL = xLL + mxt - vdx - hdx;
        yLL = yLL + myt - vdy - hdy;
        xLR = xLR + mxt - vdx + hdx;
        yLR = yLR + myt - vdy + hdy;
        VertexBuffer vb = context.getVertexBuffer();
        int cellmax = context.getRectTextureMaxSize();
        if (cellh &lt;= cellmax) {
            float v0 = ((cellh * (cellh + 1)) / 2) - 0.5f;
            float v1 = v0 + cellh + 1.0f;
            Texture rTex = context.getRectTexture();
            v0 /= rTex.getPhysicalHeight();
            v1 /= rTex.getPhysicalHeight();
            if (cellw &lt;= cellmax) {
                float u0 = ((cellw * (cellw + 1)) / 2) - 0.5f;
                float u1 = u0 + cellw + 1.0f;
                u0 /= rTex.getPhysicalWidth();
                u1 /= rTex.getPhysicalWidth();
                context.validatePaintOp(this, xform, MaskType.ALPHA_TEXTURE, rTex,
                                        bx, by, bw, bh);
                vb.addMappedPgram(xUL, yUL, xUR, yUR, xLL, yLL, xLR, yLR,
                                   u0,  v0,  u1,  v0,  u0,  v1,  u1,  v1,
                                  0, 0);
//                System.out.print(&quot;1&quot;); System.out.flush();
                rTex.unlock();
                return true;
            }
            // long thin line (cellw is along the line, cellh is across it)
            if (cellw &lt;= cellmax * 2 - 1) {
                // 2-slice the line at its midpoint.
                // use the cellmax,cellh cell for maximum coverage of each half
                // we can use at most (cellmax-0.5) per half so that we do not
                // see the antialias drop off on the last half pixel of the far
                // end of the cell.  This lets us support a line of &quot;length&quot; up
                // to (cellmax-0.5 + cellmax-0.5) or (cellmax*2-1).
                float xUC = (xUL + xUR) * 0.5f;
                float yUC = (yUL + yUR) * 0.5f;
                float xLC = (xLL + xLR) * 0.5f;
                float yLC = (yLL + yLR) * 0.5f;
                float u0 = ((cellmax * (cellmax + 1)) / 2) - 0.5f;
                float u1 = u0 + 0.5f + cellw * 0.5f;
                u0 /= rTex.getPhysicalWidth();
                u1 /= rTex.getPhysicalWidth();
                context.validatePaintOp(this, xform, MaskType.ALPHA_TEXTURE, rTex,
                                        bx, by, bw, bh);
                // first half of line x1,y1 -&gt; midpoint
                vb.addMappedPgram(xUL, yUL, xUC, yUC, xLL, yLL, xLC, yLC,
                                   u0,  v0,  u1,  v0,  u0,  v1,  u1,  v1,
                                  0, 0);
                // second half of line midpoint -&gt; x2,y2
                vb.addMappedPgram(xUR, yUR, xUC, yUC, xLR, yLR, xLC, yLC,
                                   u0,  v0,  u1,  v0,  u0,  v1,  u1,  v1,
                                  0, 0);
//                System.out.print(&quot;2&quot;); System.out.flush();
                rTex.unlock();
                return true;
            }
            // Finally, 3-slice the line (left edge, huge middle, right edge)
            float u0 = 0.5f / rTex.getPhysicalWidth();
            float u1 = 1.5f / rTex.getPhysicalWidth();
            // The lower case L or R indicates &quot;inner left&quot; or &quot;inner right&quot;
            hdx *= 2.0f;
            hdy *= 2.0f;
            float xUl = xUL + hdx;
            float yUl = yUL + hdy;
            float xUr = xUR - hdx;
            float yUr = yUR - hdy;
            float xLl = xLL + hdx;
            float yLl = yLL + hdy;
            float xLr = xLR - hdx;
            float yLr = yLR - hdy;
            context.validatePaintOp(this, xform, MaskType.ALPHA_TEXTURE, rTex,
                                    bx, by, bw, bh);
            // first pixel of line x1,y1 -&gt; x1,y1+pixel
            vb.addMappedPgram(xUL, yUL, xUl, yUl, xLL, yLL, xLl, yLl,
                               u0,  v0,  u1,  v0,  u0,  v1,  u1,  v1,
                              0, 0);
            // middle part of line x1,y1+pixel -&gt; x2,y2-pixel
            vb.addMappedPgram(xUl, yUl, xUr, yUr, xLl, yLl, xLr, yLr,
                               u1,  v0,  u1,  v0,  u1,  v1,  u1,  v1,
                              0, 0);
            // last part of line x2,y2-pixel -&gt; x2,y2
            vb.addMappedPgram(xUr, yUr, xUR, yUR, xLr, yLr, xLR, yLR,
                               u1,  v0,  u0,  v0,  u1,  v1,  u0,  v1,
                              0, 0);
//            System.out.print(&quot;3&quot;); System.out.flush();
            rTex.unlock();
            return true;
        }
        // we could 2 and 3 slice extremely wide short lines, but they
        // are very rare in practice so we just jump straight to a
        // standard 4-slice off of the wrap-rect texture
        float xUC = (xUL + xUR) * 0.5f;
        float yUC = (yUL + yUR) * 0.5f;
        float xLC = (xLL + xLR) * 0.5f;
        float yLC = (yLL + yLR) * 0.5f;
        float xCL = (xUL + xLL) * 0.5f;
        float yCL = (yUL + yLL) * 0.5f;
        float xCR = (xUR + xLR) * 0.5f;
        float yCR = (yUR + yLR) * 0.5f;
        float xCC = (xUC + xLC) * 0.5f;
        float yCC = (yUC + yLC) * 0.5f;
        Texture rTex = context.getWrapRectTexture();
        float u0 = 0.5f / rTex.getPhysicalWidth();
        float v0 = 0.5f / rTex.getPhysicalHeight();
        float uc = (cellw * 0.5f + 1.0f) / rTex.getPhysicalWidth();
        float vc = (cellh * 0.5f + 1.0f) / rTex.getPhysicalHeight();
        context.validatePaintOp(this, xform, MaskType.ALPHA_TEXTURE, rTex,
                                bx, by, bw, bh);
        vb.addMappedPgram(xUL, yUL, xUC, yUC, xCL, yCL, xCC, yCC,
                            u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc,
                            0, 0);
        vb.addMappedPgram(xUR, yUR, xUC, yUC, xCR, yCR, xCC, yCC,
                            u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc,
                            0, 0);
        vb.addMappedPgram(xLL, yLL, xLC, yLC, xCL, yCL, xCC, yCC,
                            u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc,
                            0, 0);
        vb.addMappedPgram(xLR, yLR, xLC, yLC, xCR, yCR, xCC, yCC,
                            u0,  v0,  uc,  v0,  u0,  vc,  uc,  vc,
                            0, 0);
//        System.out.print(&quot;4&quot;); System.out.flush();
        rTex.unlock();
        return true;
    }

    public void fillRect(float x, float y, float w, float h) {
        if (w &lt;= 0 || h &lt;= 0) {
            return;
        }
        if (!isAntialiasedShape()) {
           fillQuad(x, y, x + w, y + h);
           return;
        }
        if (isComplexPaint) {
            scratchRRect.setRoundRect(x, y, w, h, 0, 0);
            renderWithComplexPaint(scratchRRect, null, x, y, w, h);
            return;
        }
        if (PrismSettings.primTextureSize != 0) {
            Texture rTex = context.getRectTexture();
            Texture wTex = context.getWrapRectTexture();
            boolean success = fillPrimRect(x, y, w, h, rTex, wTex, x, y, w, h);
            rTex.unlock();
            wTex.unlock();
            if (success) return;
        }
        renderGeneralRoundedRect(x, y, w, h, 0f, 0f,
                                 MaskType.FILL_PGRAM, null);
    }

    public void fillEllipse(float x, float y, float w, float h) {
        if (w &lt;= 0 || h &lt;= 0) {
            return;
        }
        if (isComplexPaint) {
            scratchEllipse.setFrame(x, y, w, h);
            renderWithComplexPaint(scratchEllipse, null, x, y, w, h);
            return;
        }
        if (!isAntialiasedShape()) {
            scratchEllipse.setFrame(x, y, w, h);
            renderShape(scratchEllipse, null, x, y, w, h);
            return;
        }
        if (PrismSettings.primTextureSize != 0) {
            if (fillPrimRect(x, y, w, h,
                             context.getOvalTexture(),
                             null,
                             x, y, w, h))
            {
                return;
            }
        }
        renderGeneralRoundedRect(x, y, w, h, w, h,
                                 MaskType.FILL_ELLIPSE, null);
    }

    public void fillRoundRect(float x, float y, float w, float h,
                              float arcw, float arch)
    {
        arcw = Math.min(Math.abs(arcw), w);
        arch = Math.min(Math.abs(arch), h);

        if (w &lt;= 0 || h &lt;= 0) {
            return;
        }
        if (isComplexPaint) {
            scratchRRect.setRoundRect(x, y, w, h, arcw, arch);
            renderWithComplexPaint(scratchRRect, null, x, y, w, h);
            return;
        }
        if (!isAntialiasedShape()) {
            scratchRRect.setRoundRect(x, y, w, h, arcw, arch);
            renderShape(scratchRRect, null, x, y, w, h);
            return;
        }
        renderGeneralRoundedRect(x, y, w, h, arcw, arch,
                                 MaskType.FILL_ROUNDRECT, null);
    }

    public void fillQuad(float x1, float y1, float x2, float y2) {
        float bx, by, bw, bh;
        if (x1 &lt;= x2) {
            bx = x1;
            bw = x2 - x1;
        } else {
            bx = x2;
            bw = x1 - x2;
        }
        if (y1 &lt;= y2) {
            by = y1;
            bh = y2 - y1;
        } else {
            by = y2;
            bh = y1 - y2;
        }

        if (isComplexPaint) {
            scratchRRect.setRoundRect(bx, by, bw, bh, 0, 0);
            renderWithComplexPaint(scratchRRect, null, bx, by, bw, bh);
            return;
        }

        BaseTransform xform = getTransformNoClone();
        if (PrismSettings.primTextureSize != 0) {
            float mxt, myt;
            if (xform.isTranslateOrIdentity()) {
                mxt = (float) xform.getMxt();
                myt = (float) xform.getMyt();
                xform = IDENT;
                x1 += mxt;
                y1 += myt;
                x2 += mxt;
                y2 += myt;
            } else {
                mxt = myt = 0.0f;
            }
            Shader shader =
                context.validatePaintOp(this, xform, MaskType.ALPHA_ONE, null,
                                        bx, by, bw, bh);
            AffineBase paintTx = getPaintTextureTx(IDENT, shader, bx, by, bw, bh);
            if (paintTx != null) {
                paintTx.translate(-mxt, -myt);
            }
            context.getVertexBuffer().addQuad(x1, y1, x2, y2, 0, 0, 0, 0, paintTx);
            return;
        }
        if (isSimpleTranslate) {
            xform = IDENT;
            bx += transX;
            by += transY;
        }
        context.validatePaintOp(this, xform, MaskType.SOLID, bx, by, bw, bh);

        VertexBuffer vb = context.getVertexBuffer();
        vb.addQuad(bx, by, bx+bw, by+bh);
    }

    private static final double SQRT_2 = Math.sqrt(2.0);
    private static boolean canUseStrokeShader(BasicStroke bs) {
        // RT-27378
        // TODO: Expand the cases that renderGeneralRoundRect() can handle...
        return (!bs.isDashed() &amp;&amp;
                (bs.getType() == BasicStroke.TYPE_INNER ||
                 bs.getLineJoin() == BasicStroke.JOIN_ROUND ||
                 (bs.getLineJoin() == BasicStroke.JOIN_MITER &amp;&amp;
                  bs.getMiterLimit() &gt;= SQRT_2)));
    }

    public void blit(RTTexture srcTex, RTTexture dstTex,
                     int srcX0, int srcY0, int srcX1, int srcY1,
                     int dstX0, int dstY0, int dstX1, int dstY1) {
        if (dstTex == null) {
            context.setRenderTarget(this);
        } else {
            context.setRenderTarget((BaseGraphics)dstTex.createGraphics());
        }
        context.blit(srcTex, dstTex, srcX0, srcY0, srcX1, srcY1,
                dstX0, dstY0, dstX1, dstY1);
    }

    public void drawRect(float x, float y, float w, float h) {
        if (w &lt; 0 || h &lt; 0) {
            return;
        }
        if (w == 0 || h == 0) {
            drawLine(x, y, x + w, y + h);
            return;
        }
        if (isComplexPaint) {
            scratchRRect.setRoundRect(x, y, w, h, 0, 0);
            renderWithComplexPaint(scratchRRect, stroke, x, y, w, h);
            return;
        }
        if (!isAntialiasedShape()) {
            scratchRRect.setRoundRect(x, y, w, h, 0, 0);
            renderShape(scratchRRect, stroke, x, y, w, h);
            return;
        }
        if (canUseStrokeShader(stroke)) {
            if (PrismSettings.primTextureSize != 0 &amp;&amp;
                stroke.getLineJoin() != BasicStroke.CAP_ROUND)
            {
                if (drawPrimRect(x, y, w, h)) {
                    return;
                }
            }
            renderGeneralRoundedRect(x, y, w, h, 0f, 0f,
                                     MaskType.DRAW_PGRAM, stroke);
            return;
        }
        scratchRRect.setRoundRect(x, y, w, h, 0, 0);
        renderShape(scratchRRect, stroke, x, y, w, h);
    }

    private boolean checkInnerCurvature(float arcw, float arch) {
        // Test to see if inner ellipse satisfies (flattening &lt; 0.5)
        // otherwise it will not be approximated by a &quot;parallel ellipse&quot;
        // very well and we should just use shape rendering.

        // RT-27378
        // TODO: Implement better &quot;distance to ellipse&quot; formulas in the shaders
        float inset = stroke.getLineWidth() *
            (1f - getStrokeExpansionFactor(stroke));
        arcw -= inset;
        arch -= inset;
        // Note that if either inset arcw,h go to &lt;= 0 then we will invoke the
        // fill primitive for ellipse, or the round rect primitive will
        // invoke its &quot;tiny inner corner&quot; fixes and we will be safe
        return (arcw &lt;= 0 || arch &lt;= 0 ||
                (arcw * 2f &gt; arch &amp;&amp; arch * 2f &gt; arcw));
    }

    public void drawEllipse(float x, float y, float w, float h) {
        if (w &lt; 0 || h &lt; 0) {
            return;
        }
        if (!isComplexPaint &amp;&amp; !stroke.isDashed() &amp;&amp;
            checkInnerCurvature(w, h) &amp;&amp; isAntialiasedShape())
        {
            renderGeneralRoundedRect(x, y, w, h, w, h,
                                     MaskType.DRAW_ELLIPSE, stroke);
            return;
        }
        scratchEllipse.setFrame(x, y, w, h);
        renderShape(scratchEllipse, stroke, x, y, w, h);
    }

    public void drawRoundRect(float x, float y, float w, float h,
                              float arcw, float arch)
    {
        arcw = Math.min(Math.abs(arcw), w);
        arch = Math.min(Math.abs(arch), h);

        if (w &lt; 0 || h &lt; 0) {
            return;
        }
        if (!isComplexPaint &amp;&amp; !stroke.isDashed() &amp;&amp;
            checkInnerCurvature(arcw, arch) &amp;&amp; isAntialiasedShape())
        {
            renderGeneralRoundedRect(x, y, w, h, arcw, arch,
                                     MaskType.DRAW_ROUNDRECT, stroke);
            return;
        }
        scratchRRect.setRoundRect(x, y, w, h, arcw, arch);
        renderShape(scratchRRect, stroke, x, y, w, h);
    }

    public void drawLine(float x1, float y1, float x2, float y2) {
        float bx, by, bw, bh;
        if (x1 &lt;= x2) {
            bx = x1;
            bw = x2 - x1;
        } else {
            bx = x2;
            bw = x1 - x2;
        }
        if (y1 &lt;= y2) {
            by = y1;
            bh = y2 - y1;
        } else {
            by = y2;
            bh = y1 - y2;
        }

        // RT-27378
        // TODO: casting down to floats everywhere here; evaluate later
        // to see if this is enough precision...
        // TODO: stroke normalization control?
        if (stroke.getType() == BasicStroke.TYPE_INNER) {
            return;
        }
        if (isComplexPaint) {
            scratchLine.setLine(x1, y1, x2, y2);
            renderWithComplexPaint(scratchLine, stroke, bx, by, bw, bh);
            return;
        }
        if (!isAntialiasedShape()) {
            scratchLine.setLine(x1, y1, x2, y2);
            renderShape(scratchLine, stroke, bx, by, bw, bh);
            return;
        }
        int cap = stroke.getEndCap();
        if (stroke.isDashed()) {
            // NOTE: we could construct the GeneralPath directly
            // for CAP_ROUND and save a lot of processing in that case...
            // And again, we would need to deal with dropout control...
            scratchLine.setLine(x1, y1, x2, y2);
            renderShape(scratchLine, stroke, bx, by, bw, bh);
            return;
        }
        float lw = stroke.getLineWidth();
        if (PrismSettings.primTextureSize != 0 &amp;&amp;
            cap != BasicStroke.CAP_ROUND)
        {
            float pad = lw;
            if (stroke.getType() == BasicStroke.TYPE_CENTERED) {
                pad *= 0.5f;
            }
            if (bw == 0.0f || bh == 0.0f) {
                float padx, pady;
                if (cap == BasicStroke.CAP_SQUARE) {
                    // CAP_SQUARE pads the same on all sides
                    padx = pady = pad;
//                    System.out.print(&quot;S&quot;); System.out.flush();
                } else if (bw != 0.0f) {
                    // Horizontal CAP_BUTT line - widen vertically
                    padx = 0.0f;
                    pady = pad;
//                    System.out.print(&quot;H&quot;); System.out.flush();
                } else if (bh != 0.0f) {
                    // Vertical CAP_BUTT line - widen horizontally
                    padx = pad;
                    pady = 0.0f;
//                    System.out.print(&quot;V&quot;); System.out.flush();
                } else {
//                    System.out.print(&quot;0&quot;); System.out.flush();
                    // Zero length line - NOP for CAP_BUTT
                    return;
                }
                Texture rTex = context.getRectTexture();
                Texture wTex = context.getWrapRectTexture();
                boolean success = fillPrimRect(bx - padx,        by - pady,
                                               bw + padx + padx, bh + pady + pady,
                                               rTex, wTex, bx, by, bw, bh);
                rTex.unlock();
                wTex.unlock();
                if (success) return;
            } else {
                if (drawPrimDiagonal(x1, y1, x2, y2, lw, cap,
                                     bx, by, bw, bh))
                {
                    return;
                }
            }
        }
//        System.out.print(&quot;#&quot;); System.out.flush();
        if (stroke.getType() == BasicStroke.TYPE_OUTER) {
            lw *= 2f;
        }
        float dx = x2 - x1;
        float dy = y2 - y1;
        float len = len(dx, dy);
        float ldx, ldy;  // lw length vector in direction of line in user space
        if (len == 0) {
            if (cap == BasicStroke.CAP_BUTT) {
                return;
            }
            ldx = lw;
            ldy = 0;
        } else {
            ldx = lw * dx / len;
            ldy = lw * dy / len;
        }
        // The following is safe; this method does not mutate the transform
        BaseTransform xform = getTransformNoClone();
        BaseTransform rendertx;
        float pdx, pdy;  // ldx,ldy rotated 90 in user space then transformed
        if (isSimpleTranslate) {
            double tx = xform.getMxt();
            double ty = xform.getMyt();
            x1 += tx;
            y1 += ty;
            x2 += tx;
            y2 += ty;
            pdx = ldy;
            pdy = -ldx;
            rendertx = IDENT;
        } else {
            rendertx = extract3Dremainder(xform);
            double coords[] = {x1, y1, x2, y2};
            xform.transform(coords, 0, coords, 0, 2);
            x1 = (float)coords[0];
            y1 = (float)coords[1];
            x2 = (float)coords[2];
            y2 = (float)coords[3];
            dx = x2 - x1;
            dy = y2 - y1;
            coords[0] = ldx;
            coords[1] = ldy;
            coords[2] = ldy;
            coords[3] = -ldx;
            xform.deltaTransform(coords, 0, coords, 0, 2);
            ldx = (float) coords[0];
            ldy = (float) coords[1];
            pdx = (float) coords[2];
            pdy = (float) coords[3];
        }
        float px = x1 - pdx / 2f;
        float py = y1 - pdy / 2f;
        float arcfractw, arcfracth;
        MaskType type;
        if (cap != BasicStroke.CAP_BUTT) {
            px -= ldx / 2f;
            py -= ldy / 2f;
            dx += ldx;
            dy += ldy;
            if (cap == BasicStroke.CAP_ROUND) {
                arcfractw = len(ldx, ldy) / len(dx, dy);
                arcfracth = 1f;
                type = MaskType.FILL_ROUNDRECT;
            } else {
                arcfractw = arcfracth = 0f;
                type = MaskType.FILL_PGRAM;
            }
        } else {
            arcfractw = arcfracth = 0f;
            type = MaskType.FILL_PGRAM;
        }
        renderGeneralRoundedPgram(px, py, dx, dy, pdx, pdy,
                                  arcfractw, arcfracth, 0f, 0f,
                                  rendertx, type,
                                  bx, by, bw, bh);
    }

    private static float len(float x, float y) {
        return ((x == 0f) ? Math.abs(y)
                : ((y == 0f) ? Math.abs(x)
                   : (float)Math.sqrt(x * x + y * y)));
    }

    private boolean lcdSampleInvalid = false;

    public void setNodeBounds(RectBounds bounds) {
        nodeBounds = bounds;
        lcdSampleInvalid = bounds != null;
    }

    private void initLCDSampleRT() {
        if (lcdSampleInvalid) {
            RectBounds textBounds = new RectBounds();
            getTransformNoClone().transform(nodeBounds, textBounds);
            Rectangle clipRect = getClipRectNoClone();
            if (clipRect != null &amp;&amp; !clipRect.isEmpty()) {
                // Reduce sample area if there is any clipping bounds set
                textBounds.intersectWith(clipRect);
            }
            // LCD mixing with background will often lead to extra pixel at edge
            // thus adding a single pixel, as padding, at edges and bottom.
            float bx = textBounds.getMinX() - 1.0f;
            float by = textBounds.getMinY() - 1.0f;
            float bw = textBounds.getWidth() + 2.0f;
            float bh = textBounds.getHeight() + 2.0f;

            context.validateLCDBuffer(getRenderTarget());

            // Create a graphics for us to render into the LCDBuffer
            // Note this also sets the current RenderTarget as the LCDBuffer
            BaseShaderGraphics bsg = (BaseShaderGraphics) context.getLCDBuffer().createGraphics();
            bsg.setCompositeMode(CompositeMode.SRC);
            context.validateLCDOp(bsg, IDENT, (Texture) getRenderTarget(), null, true, null);

            int srch = getRenderTarget().getPhysicalHeight();
            int srcw = getRenderTarget().getPhysicalWidth();
            float tx1 = bx / srcw;
            float ty1 = by / srch;
            float tx2 = (bx + bw) / srcw;
            float ty2 = (by + bh) / srch;

            //sample the source RT in the following bounds and store it in the LCDBuffer RT.
            bsg.drawLCDBuffer(bx, by, bw, bh, tx1, ty1, tx2, ty2);
            context.setRenderTarget(this);
        }
        lcdSampleInvalid = false;
    }

    public void drawString(GlyphList gl, FontStrike strike, float x, float y,
                           Color selectColor, int selectStart, int selectEnd) {

        if (isComplexPaint ||
            paint.getType().isImagePattern() ||
            strike.drawAsShapes())
        {
            // FontStrike.drawAsShapes() may be true for very large font sizes
            // in which case so no glyph images are cached.
            // The Prism Text node handles such cases directly, but Webnode relies
            // upon Prism's drawString method, so we need to handle it here too.

            // this is not a very optimal approach and may not hit exactly
            // the same pixels that we would hit in the case where the
            // glyph cache is used, but the complex paint case is not
            // common enough to warrant further optimization
            BaseTransform xform = BaseTransform.getTranslateInstance(x, y);
            Shape shape = strike.getOutline(gl, xform);
            fill(shape);
            return;
        }

        BaseTransform xform = getTransformNoClone();

        Paint textPaint = getPaint();
        Color textColor = textPaint.getType() == Paint.Type.COLOR ?
                          (Color) textPaint : null;

        CompositeMode blendMode = getCompositeMode();
        // LCD support requires several attributes to function:
        // FontStrike supports LCD, SRC_OVER CompositeMode and Paint is a COLOR
        boolean lcdSupported = blendMode == CompositeMode.SRC_OVER &amp;&amp;
                               textColor != null &amp;&amp;
                               xform.is2D() &amp;&amp;
                               !getRenderTarget().isMSAA();

        /* If the surface can't support LCD text we need to replace an
         * LCD mode strike with the equivalent grey scale one.
         */
        if (strike.getAAMode() == FontResource.AA_LCD &amp;&amp; !lcdSupported) {
            FontResource fr = strike.getFontResource();
            float size = strike.getSize();
            BaseTransform tx = strike.getTransform();
            strike = fr.getStrike(size, tx, FontResource.AA_GREYSCALE);
        }

        float bx = 0f, by = 0f, bw = 0f, bh = 0f;
        if (paint.getType().isGradient() &amp;&amp; ((Gradient)paint).isProportional()) {
            // If drawString is called directly without using setNodeBounds,
            // then nodeBounds is null, and we must determine the bounds based
            // on the str(vs. the node).
            RectBounds textBounds = nodeBounds;
            if (textBounds == null) {
                Metrics m = strike.getMetrics();
                float pad = -m.getAscent() * 0.4f;
                textBounds = new RectBounds(-pad,
                                            m.getAscent(),
                                            gl.getWidth() + 2.0f *pad,
                                            m.getDescent() + m.getLineGap());
                bx = x;
                by = y;
            }

            bx += textBounds.getMinX();
            by += textBounds.getMinY();
            bw = textBounds.getWidth();
            bh = textBounds.getHeight();
        }

        BaseBounds clip = null;
        Point2D p2d = new Point2D(x, y);
        if (isSimpleTranslate) {
            /* Only use clip for simple transforms so that coordinates in the
             * glyph list (user space) and the coordinates of the clip
             * (device space) can be intersected.
             */
            clip = getFinalClipNoClone();
            xform = IDENT;
            p2d.x += transX;
            p2d.y += transY;
        }

        /* Cache look up needs to be on the font as rendered, including
         * AA mode, metrics mode, glyph transform (pt size combined with
         * the full graphics transform). Most of this info is expected to
         * be in the font, which here is close to being a full strike
         * description.
         */
        GlyphCache glyphCache = context.getGlyphCache(strike);
        Texture cacheTex = glyphCache.getBackingStore();

        //Since we currently cannot support LCD text on transparant surfaces, we
        //verify that we are drawing to an opaque surface.
        if (strike.getAAMode() == FontResource.AA_LCD) {
            if (nodeBounds == null) {
                // If drawString is called directly without using
                // setNodeBounds then we must determine the bounds of the str,
                // before we render background to texture.
                // This is slow, but required by webnode.

                Metrics m = strike.getMetrics();
                // Ruff guess for padding, since lots of glyphs exceed advance
                RectBounds textBounds =
                        new RectBounds(x - 2,
                                       y + m.getAscent(),
                                       x + 2 + gl.getWidth(),
                                       y + 1 + m.getDescent() + m.getLineGap());

                setNodeBounds(textBounds);
                initLCDSampleRT();
                setNodeBounds(null);
            } else {
                initLCDSampleRT();
            }
            float invgamma = PrismFontFactory.getLCDContrast();
            float gamma = 1.0f/invgamma;
            textColor = new Color((float)Math.pow(textColor.getRed(),   invgamma),
                                  (float)Math.pow(textColor.getGreen(), invgamma),
                                  (float)Math.pow(textColor.getBlue(),  invgamma),
                                  (float)Math.pow(textColor.getAlpha(), invgamma));
            if (selectColor != null) {
                selectColor = new Color(
                        (float)Math.pow(selectColor.getRed(),   invgamma),
                        (float)Math.pow(selectColor.getGreen(), invgamma),
                        (float)Math.pow(selectColor.getBlue(),  invgamma),
                        (float)Math.pow(selectColor.getAlpha(), invgamma));
            }

            // In order to handle transparency, the LCD shader need to manually
            // composite source with destination. Thus, SRC_OVER compositing
            // needs to be set to SRC, while shader is active.
            setCompositeMode(CompositeMode.SRC);

            //set our 2nd LCD shader.
            Shader shader = context.validateLCDOp(this, IDENT,
                                                context.getLCDBuffer(),
                                                cacheTex, false, textColor);

            float unitXCoord = 1.0f/((float)cacheTex.getPhysicalWidth());
            shader.setConstant(&quot;gamma&quot;, gamma, invgamma, unitXCoord);
            setCompositeMode(blendMode); // Restore composite mode
        } else {
            context.validatePaintOp(this, IDENT, cacheTex, bx, by, bw, bh);
        }
        if (isSimpleTranslate) {
            // Applying this rounding allows for smoother text animation,
            // when animating simple translated text.
            // Asking glyph textures to be rendered at non-integral
            // locations produces very poor text. This doesn't solve
            // the problem for scaled (etc) cases, but addresses a
            // common case.
            p2d.y = Math.round(p2d.y);
            p2d.x = Math.round(p2d.x);
        }
        glyphCache.render(context, gl, p2d.x, p2d.y, selectStart, selectEnd,
                          selectColor, textColor, xform, clip);
    }

    //This function is used by the LCD path to render a quad into the
    //LCD RTT Texture. here the presentable is set as input and
    //sampled using texture coordinates. This is later used in a
    //second pass to provide the dst color as input.
    private void drawLCDBuffer(float bx, float by, float bw, float bh,
            float tx1, float ty1, float tx2, float ty2)
    {
        context.setRenderTarget(this);
        context.getVertexBuffer().addQuad(bx, by, bx + bw, by + bh, tx1, ty1, tx2, ty2);
    }

    public boolean canReadBack() {
        RenderTarget rt = getRenderTarget();
        return rt instanceof ReadbackRenderTarget &amp;&amp;
            ((ReadbackRenderTarget) rt).getBackBuffer() != null;
    }

    public RTTexture readBack(Rectangle view) {
        RenderTarget rt = getRenderTarget();
        context.flushVertexBuffer();
        context.validateLCDBuffer(rt);
        RTTexture lcdrtt = context.getLCDBuffer();
        Texture bbtex = ((ReadbackRenderTarget) rt).getBackBuffer();

        float x1 = view.x;
        float y1 = view.y;
        float x2 = x1 + view.width;
        float y2 = y1 + view.height;

        // Create a graphics for us to render into the LCDBuffer
        // Note this also sets the current RenderTarget as the LCDBuffer
        BaseShaderGraphics bsg = (BaseShaderGraphics) lcdrtt.createGraphics();
        bsg.setCompositeMode(CompositeMode.SRC);
        context.validateTextureOp(bsg, IDENT, bbtex, bbtex.getPixelFormat());

        // sample the source RT in the following bounds and store it in the LCDBuffer RT.
        bsg.drawTexture(bbtex, 0, 0, view.width, view.height, x1, y1, x2, y2);
        context.flushVertexBuffer();

        // set the RenderTarget back to this.
        context.setRenderTarget(this);
        return lcdrtt;
    }

    public void releaseReadBackBuffer(RTTexture rtt) {
        // This will be needed when we track LCD buffer locks and uses.
        // (See RT-29488)
//        context.releaseLCDBuffer();
    }

    public void setup3DRendering() {
        context.setRenderTarget(this);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/j2d/print/J2DPrinterJob.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.j2d.print;

import javafx.print.Collation;
import javafx.print.JobSettings;
import javafx.print.PageLayout;
import javafx.print.PageOrientation;
import javafx.print.PageRange;
import javafx.print.Paper;
import javafx.print.PaperSource;
import javafx.print.PrintColor;
import javafx.print.PrintResolution;
import javafx.print.PrintSides;
import javafx.print.Printer;
import javafx.print.Printer.MarginType;
import javafx.print.PrinterAttributes;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Window;
import javax.print.PrintService;
import javax.print.attribute.HashPrintRequestAttributeSet;
import javax.print.attribute.PrintRequestAttribute;
import javax.print.attribute.PrintRequestAttributeSet;
import javax.print.attribute.ResolutionSyntax;
import javax.print.attribute.Size2DSyntax;
import javax.print.attribute.standard.Chromaticity;
import javax.print.attribute.standard.Copies;
import javax.print.attribute.standard.DialogTypeSelection;
import javax.print.attribute.standard.Media;
import javax.print.attribute.standard.MediaPrintableArea;
import javax.print.attribute.standard.MediaSize;
import javax.print.attribute.standard.MediaSizeName;
import javax.print.attribute.standard.MediaTray;
import javax.print.attribute.standard.OrientationRequested;
import javax.print.attribute.standard.PageRanges;
import javax.print.attribute.standard.PrintQuality;
import javax.print.attribute.standard.PrinterResolution;
import javax.print.attribute.standard.SheetCollate;
import javax.print.attribute.standard.Sides;
import java.awt.*;
import java.awt.print.PageFormat;
import java.awt.print.Pageable;
import java.awt.print.Printable;
import java.awt.print.PrinterException;
import java.util.ArrayList;
import java.util.Set;
import com.sun.glass.ui.Application;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.print.PrintHelper;
import com.sun.javafx.print.PrinterImpl;
import com.sun.javafx.print.PrinterJobImpl;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.stage.WindowHelper;
import com.sun.javafx.tk.TKStage;
import com.sun.javafx.tk.Toolkit;
import com.sun.glass.utils.NativeLibLoader;
import com.sun.prism.impl.PrismSettings;

import com.sun.prism.j2d.PrismPrintGraphics;

import java.lang.reflect.Constructor;
import java.security.AccessController;
import java.security.PrivilegedAction;

public class J2DPrinterJob implements PrinterJobImpl {

    static {
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            String libName = &quot;prism_common&quot;;

            if (PrismSettings.verbose) {
                System.out.println(&quot;Loading Prism common native library ...&quot;);
            }
            NativeLibLoader.loadLibrary(libName);
            if (PrismSettings.verbose) {
                System.out.println(&quot;\tsucceeded.&quot;);
            }
            return null;
        });
    }

    javafx.print.PrinterJob fxPrinterJob;
    java.awt.print.PrinterJob pJob2D;
    javafx.print.Printer fxPrinter;
    J2DPrinter j2dPrinter;

    private JobSettings settings;
    private PrintRequestAttributeSet printReqAttrSet;
    private volatile Object elo = null;

    private static Class onTopClass = null;
    PrintRequestAttribute getAlwaysOnTop(final long id) {
        return AccessController.doPrivileged(
            (PrivilegedAction&lt;PrintRequestAttribute&gt;) () -&gt; {

            PrintRequestAttribute alwaysOnTop = null;
            try {
                if (onTopClass == null) {
                    onTopClass =
                        Class.forName(&quot;javax.print.attribute.standard.DialogOwner&quot;);
                }
                if (id == 0) {
                    Constructor&lt;PrintRequestAttribute&gt;
                         cons = onTopClass.getConstructor();
                    alwaysOnTop = cons.newInstance();
                } else {
                    alwaysOnTop = getAlwaysOnTop(onTopClass, id);
                }
            } catch (Throwable t) {
            }
            return alwaysOnTop;
        });
    }

    private static native
        PrintRequestAttribute getAlwaysOnTop(Class onTopClass, long id);

    public J2DPrinterJob(javafx.print.PrinterJob fxJob) {

        fxPrinterJob = fxJob;
        fxPrinter = fxPrinterJob.getPrinter();
        j2dPrinter = getJ2DPrinter(fxPrinter);
        settings = fxPrinterJob.getJobSettings();
        pJob2D = java.awt.print.PrinterJob.getPrinterJob();
        try {
            pJob2D.setPrintService(j2dPrinter.getService());
        } catch (PrinterException pe) {
        }
        printReqAttrSet = new HashPrintRequestAttributeSet();
        printReqAttrSet.add(DialogTypeSelection.NATIVE);
        j2dPageable = new J2DPageable();
        pJob2D.setPageable(j2dPageable);
    }

    private void setEnabledState(Window owner, boolean state) {
        if (owner == null) {
           return;
        }
        final TKStage stage = WindowHelper.getPeer(owner);
        if (stage == null) { // just in case.
            return;
        }
        Application.invokeAndWait(() -&gt; stage.setEnabled(state));
    }

    public boolean showPrintDialog(Window owner) {

        if (jobRunning || jobDone) {
            return false;
        }

        if (GraphicsEnvironment.isHeadless()) {
            return true;
        }

        if (onTopClass != null) {
            printReqAttrSet.remove(onTopClass);
        }
        if (owner != null) {
            long id = 0L;
            if (PlatformUtil.isWindows()) {
                id = WindowHelper.getPeer(owner).getRawHandle();
            }
            PrintRequestAttribute alwaysOnTop = getAlwaysOnTop(id);
            if (alwaysOnTop != null) {
                printReqAttrSet.add(alwaysOnTop);
            }
        }

        boolean rv = false;
        syncSettingsToAttributes();
        try {
            setEnabledState(owner, false);
            if (!Toolkit.getToolkit().isFxUserThread()) {
                rv = pJob2D.printDialog(printReqAttrSet);
            } else {
                // If we are on the event thread, we need to check whether
                // we are allowed to call a nested event handler.
                if (!Toolkit.getToolkit().canStartNestedEventLoop()) {
                    throw new IllegalStateException(
              &quot;Printing is not allowed during animation or layout processing&quot;);
                }
                rv = showPrintDialogWithNestedLoop(owner);
            }
            if (rv) {
                updateSettingsFromDialog();
            }
        } finally {
            setEnabledState(owner, true);
        }
        return rv;
    }

    private class PrintDialogRunnable implements Runnable {

        public void run() {
            boolean rv = false;
            try {
                rv = pJob2D.printDialog(printReqAttrSet);
            } catch (Exception e) {
            } finally {
                Application.invokeLater(new ExitLoopRunnable(this, rv));
            }
        }
    }

    private boolean showPrintDialogWithNestedLoop(Window owner) {
        PrintDialogRunnable dr = new PrintDialogRunnable();
        Thread prtThread = new Thread(dr, &quot;FX Print Dialog Thread&quot;);
        prtThread.start();
        // the nested event loop will return after the runnable exits.
        Object rv = Toolkit.getToolkit().enterNestedEventLoop(dr);

        boolean rvbool = false;
        try {
            rvbool = ((Boolean)rv).booleanValue();
        } catch (Exception e) {
        }
        return rvbool;
    }

    public boolean showPageDialog(Window owner) {
        if (jobRunning || jobDone) {
            return false;
        }
        if (GraphicsEnvironment.isHeadless()) {
            return true;
        }

        if (onTopClass != null) {
            printReqAttrSet.remove(onTopClass);
        }
        if (owner != null) {
            long id = 0L;
            if (PlatformUtil.isWindows()) {
                id = WindowHelper.getPeer(owner).getRawHandle();
            }
            PrintRequestAttribute alwaysOnTop = getAlwaysOnTop(id);
            if (alwaysOnTop != null) {
                printReqAttrSet.add(alwaysOnTop);
            }
        }

        boolean rv = false;
        syncSettingsToAttributes();
        try {
            setEnabledState(owner, false);
            if (!Toolkit.getToolkit().isFxUserThread()) {
                PageFormat pf = pJob2D.pageDialog(printReqAttrSet);
                rv = pf != null;
            } else {
                // If we are on the event thread, we need to check whether
                // we are allowed to call a nested event handler.
                if (!Toolkit.getToolkit().canStartNestedEventLoop()) {
                    throw new IllegalStateException(
               &quot;Printing is not allowed during animation or layout processing&quot;);
                }
                rv = showPageDialogFromNestedLoop(owner);
            }
        } finally {
            setEnabledState(owner, true);
        }
        if (rv) {
            updateSettingsFromDialog();
        }
        return rv;
    }

    private class PageDialogRunnable implements Runnable {

        public void run() {
            PageFormat pf = null;
            try {
                pf = pJob2D.pageDialog(printReqAttrSet);
            } catch (Exception e) {
            } finally {
                Boolean rv = Boolean.valueOf(pf != null);
                Application.invokeLater(new ExitLoopRunnable(this, rv));
            }
        }
    }

    private boolean showPageDialogFromNestedLoop(Window owner) {

        PageDialogRunnable dr = new PageDialogRunnable();
        Thread prtThread = new Thread(dr, &quot;FX Page Setup Dialog Thread&quot;);
        prtThread.start();
        // the nested event loop will return after the runnable exits.
        Object rv = Toolkit.getToolkit().enterNestedEventLoop(dr);
        boolean rvbool = false;
        try {
            rvbool = ((Boolean)rv).booleanValue();
        } catch (Exception e) {
        }
        return rvbool;
    }

    /*
     * The update-Foo methods here are only used to update the
     * FX JobSettings as a result of changes by user interaction
     * with a print dialog. The new values are stored in the
     * PrintRequestAttributeSet and pulled from there in to the
     * equivalent FX public API JobSettings.
     */
    private void updateJobName() {
        String name =  pJob2D.getJobName();
        if (!name.equals(settings.getJobName())) {
            settings.setJobName(name);
        }
    }
    private void updateCopies() {
        int nCopies = pJob2D.getCopies();
        if (settings.getCopies() != nCopies) {
            settings.setCopies(nCopies);
        }
    }

    private void updatePageRanges() {
        PageRanges ranges = (PageRanges)printReqAttrSet.get(PageRanges.class);
        // JDK sets default to 1,Integer.MAX_VALUE
        // So in this case I think we can just check for non-null and
        // only set if its non-null.
        if (ranges != null) {
            int[][] members = ranges.getMembers();
            if (members.length == 1) {
                PageRange range = new PageRange(members[0][0], members[0][1]);
                settings.setPageRanges(range);
            } else if (members.length &gt; 0) {
                try {
                    ArrayList&lt;PageRange&gt; prList = new ArrayList&lt;PageRange&gt;();
                    int last = 0;
                    for (int i=0; i&lt;members.length;i++) {
                        int s = members[i][0];
                        int e = members[i][1];
                        if (s &lt;= last || e &lt; s) {
                            return;
                        }
                        last = e;
                        prList.add(new PageRange(s, e));
                    }
                    settings.setPageRanges(prList.toArray(new PageRange[0]));
                } catch (Exception e) {
                }
            }
        }
    }

    private void updateSides() {
        Sides sides = (Sides)printReqAttrSet.get(Sides.class);
        if (sides == null) {
            sides = (Sides)j2dPrinter.getService().
                getDefaultAttributeValue(Sides.class);
        }
        if (sides == Sides.ONE_SIDED) {
            settings.setPrintSides(PrintSides.ONE_SIDED);
        } else if (sides == Sides.DUPLEX) {
            settings.setPrintSides(PrintSides.DUPLEX);
        } else if (sides == Sides.TUMBLE) {
            settings.setPrintSides(PrintSides.TUMBLE);
        }
    }

    /* If the attribute set has an explicit setting for
     * collation, then its been set by the user at some point,
     * even if the current value is the printer default.
     * If there is no value for collation in the attribute set,
     * it means that we are u  sing the printer default.
     */
    private void updateCollation() {
        SheetCollate collate =
            (SheetCollate)printReqAttrSet.get(SheetCollate.class);
        if (collate == null) {
            collate = j2dPrinter.getDefaultSheetCollate();
        }
        if (collate == SheetCollate.UNCOLLATED) {
            settings.setCollation(Collation.UNCOLLATED);
        } else {
            settings.setCollation(Collation.COLLATED);
        }
    }

    private void updateColor() {
        Chromaticity color =
            (Chromaticity)printReqAttrSet.get(Chromaticity.class);
        if (color == null) {
            color = j2dPrinter.getDefaultChromaticity();
        }
        if (color == Chromaticity.COLOR) {
            settings.setPrintColor(PrintColor.COLOR);
        } else {
            settings.setPrintColor(PrintColor.MONOCHROME);
        }
    }

    private void updatePrintQuality() {
        PrintQuality quality =
            (PrintQuality)printReqAttrSet.get(PrintQuality.class);
        if (quality == null) {
            quality = j2dPrinter.getDefaultPrintQuality();
        }

        if (quality == PrintQuality.DRAFT) {
            settings.
                setPrintQuality(javafx.print.PrintQuality.DRAFT);
        } else if (quality == PrintQuality.HIGH) {
            settings.
                setPrintQuality(javafx.print.PrintQuality.HIGH);
        } else {
            settings.
                setPrintQuality(javafx.print.PrintQuality.NORMAL);
        }
    }

    private void updatePrintResolution() {
        PrinterResolution res =
            (PrinterResolution)printReqAttrSet.get(PrinterResolution.class);
        if (res == null) {
            res = j2dPrinter.getDefaultPrinterResolution();
        }
        int cfr = res.getCrossFeedResolution(ResolutionSyntax.DPI);
        int fr = res.getFeedResolution(ResolutionSyntax.DPI);
        settings.setPrintResolution(PrintHelper.createPrintResolution(cfr, fr));
    }

    private void updatePageLayout() {
        Media media = (Media)printReqAttrSet.get(Media.class);
        Paper paper = j2dPrinter.getPaperForMedia(media);
        OrientationRequested o = (OrientationRequested)
            printReqAttrSet.get(OrientationRequested.class);
        PageOrientation orient = J2DPrinter.reverseMapOrientation(o);
        MediaPrintableArea mpa =
            (MediaPrintableArea)printReqAttrSet.get(MediaPrintableArea.class);
        PageLayout newLayout;
        if (mpa == null) {
            newLayout = fxPrinter.createPageLayout(paper, orient,
                                                   MarginType.DEFAULT);
        } else {
            double pWid = paper.getWidth();
            double pHgt = paper.getHeight();
            int INCH = MediaPrintableArea.INCH;
            double mpaX = mpa.getX(INCH) * 72;
            double mpaY = mpa.getY(INCH) * 72;
            double mpaW = mpa.getWidth(INCH) * 72;
            double mpaH = mpa.getHeight(INCH) * 72;
            double lm=0, rm=0, tm=0, bm=0;
            switch (orient) {
            case PORTRAIT:
                lm = mpaX;
                rm = pWid - mpaX - mpaW;
                tm = mpaY;
                bm = pHgt - mpaY - mpaH;
                break;
            case REVERSE_PORTRAIT:
                lm = pWid - mpaX - mpaW;
                rm = mpaX;
                tm = pHgt - mpaY - mpaH;
                bm = mpaY;
                break;
            case LANDSCAPE:
                lm = mpaY;
                rm = pHgt - mpaY - mpaH;
                tm = pWid - mpaX - mpaW;
                bm = mpaX;
                break;
            case REVERSE_LANDSCAPE:
                lm = pHgt - mpaY - mpaH;
                tm = mpaX;
                rm = mpaY;
                bm = pWid - mpaX - mpaW;
                break;
            }
            if (Math.abs(lm) &lt; 0.01) lm = 0;
            if (Math.abs(rm) &lt; 0.01) rm = 0;
            if (Math.abs(tm) &lt; 0.01) tm = 0;
            if (Math.abs(bm) &lt; 0.01) bm = 0;
            newLayout = fxPrinter.createPageLayout(paper, orient,
                                                   lm, rm, tm, bm);
        }
        settings.setPageLayout(newLayout);
    }

    private void updatePaperSource() {
        Media m = (Media)printReqAttrSet.get(Media.class);
        if (m instanceof MediaTray) {
            PaperSource s = j2dPrinter.getPaperSource((MediaTray)m);
            if (s != null) {
                settings.setPaperSource(s);
            }
        }
    }

    private Printer getFXPrinterForService(PrintService service) {
        Set&lt;Printer&gt; printerSet = Printer.getAllPrinters();
        for (Printer p : printerSet) {
            J2DPrinter p2d = (J2DPrinter)PrintHelper.getPrinterImpl(p);
            PrintService s = p2d.getService();
            if (s.equals(service)) {
                return p;
            }
        }
        return fxPrinter; // current printer.
    }

    public void setPrinterImpl(PrinterImpl impl) {
        j2dPrinter = (J2DPrinter)impl;
        fxPrinter = j2dPrinter.getPrinter();
        try {
            pJob2D.setPrintService(j2dPrinter.getService());
        } catch (PrinterException pe) {
        }
    }

    public PrinterImpl getPrinterImpl() {
        return j2dPrinter;
    }

    private J2DPrinter getJ2DPrinter(Printer printer) {
        return (J2DPrinter)PrintHelper.getPrinterImpl(printer);
    }

    public Printer getPrinter() {
        return fxPrinter;
    }

    public void setPrinter(Printer printer) {
        fxPrinter = printer;
        j2dPrinter = getJ2DPrinter(printer);
        try {
            pJob2D.setPrintService(j2dPrinter.getService());
        } catch (PrinterException pe) {
        }
    }

    private void updatePrinter() {
        PrintService currService = j2dPrinter.getService();
        PrintService jobService = pJob2D.getPrintService();
        if (currService.equals(jobService)) {
            return; // no change
        }
        Printer newFXPrinter = getFXPrinterForService(jobService);
        // The public setPrinter call also updates the job to be valid for
        // the new printer. Any old values not supported will be updated
        // to supported values. If we do that, then apply the new user
        // settings, any listener will see both sets of changes.
        // Its best to just see the single transition.
        fxPrinterJob.setPrinter(newFXPrinter);
    }

    private void updateSettingsFromDialog() {
        updatePrinter();
        updateJobName();
        updateCopies();
        updatePageRanges();
        updateSides();
        updateCollation();
        updatePageLayout();
        updatePaperSource();
        updateColor();
        updatePrintQuality();
        updatePrintResolution();
    }

    private void syncSettingsToAttributes() {
        syncJobName();
        syncCopies();
        syncPageRanges();
        syncSides();
        syncCollation();
        syncPageLayout();
        syncPaperSource();
        syncColor();
        syncPrintQuality();
        syncPrintResolution();
    }

    private void syncJobName() {
        pJob2D.setJobName(settings.getJobName());
    }

    private void syncCopies() {
        pJob2D.setCopies(settings.getCopies());
        printReqAttrSet.add(new Copies(settings.getCopies()));
    }

    private void syncPageRanges() {
        printReqAttrSet.remove(PageRanges.class);
        PageRange[] prArr = settings.getPageRanges();
        if (prArr != null &amp;&amp; prArr.length&gt;0) {
            int len = prArr.length;
            int[][] ranges = new int[len][2];
            for (int i=0;i&lt;len;i++) {
                ranges[i][0] = prArr[i].getStartPage();
                ranges[i][1] = prArr[i].getEndPage();
            }
            printReqAttrSet.add(new PageRanges(ranges));
        }
    }

    private void syncSides() {
        Sides j2dSides = Sides.ONE_SIDED;
        PrintSides sides = settings.getPrintSides();
        if (sides == PrintSides.DUPLEX) {
            j2dSides = Sides.DUPLEX;
        } else if (sides == PrintSides.TUMBLE) {
            j2dSides = Sides.TUMBLE;
        }
        printReqAttrSet.add(j2dSides);
    }

    private void syncCollation() {
        if (settings.getCollation() == Collation.UNCOLLATED) {
            printReqAttrSet.add(SheetCollate.UNCOLLATED);
        } else {
            printReqAttrSet.add(SheetCollate.COLLATED);
        }

    }

    private void syncPageLayout() {
        PageLayout layout = settings.getPageLayout();
        PageOrientation orient = layout.getPageOrientation();
        printReqAttrSet.add(J2DPrinter.mapOrientation(orient));
        double pWid = layout.getPaper().getWidth();
        double pHgt = layout.getPaper().getHeight();
        float widthInInches = (float)(pWid/72.0);
        float heightInInches = (float)(pHgt/72.0);
        MediaSizeName media = MediaSize.findMedia(widthInInches,
                                                  heightInInches,
                                                  Size2DSyntax.INCH);
        if (media == null) {
            media = MediaSizeName.NA_LETTER;
        }
        printReqAttrSet.add(media);
        double ix=0, iy=0, iw=pWid, ih=pHgt;
        switch (orient) {
        case PORTRAIT:
            ix = layout.getLeftMargin();
            iy = layout.getTopMargin();
            iw = pWid - ix - layout.getRightMargin();
            ih = pHgt - iy - layout.getBottomMargin();
            break;
        case REVERSE_PORTRAIT:
            ix = layout.getRightMargin();
            iy = layout.getBottomMargin();
            iw = pWid - ix - layout.getLeftMargin();
            ih = pHgt - iy - layout.getTopMargin();
            break;
        case LANDSCAPE:
            ix = layout.getBottomMargin();
            iy = layout.getLeftMargin();
            iw = pWid - ix - layout.getTopMargin();
            ih = pHgt - iy - layout.getRightMargin();
            break;
        case REVERSE_LANDSCAPE:
            ix = layout.getTopMargin();
            iy = layout.getRightMargin();
            iw = pWid - ix - layout.getBottomMargin();
            ih = pHgt - iy - layout.getLeftMargin();
        }
        ix /= 72.0;
        iy /= 72.0;
        ih /= 72.0;
        iw /= 72.0;
        MediaPrintableArea mpa =
            new MediaPrintableArea((float)ix, (float)iy,
                                   (float)iw, (float)ih,
                                   MediaPrintableArea.INCH);
        printReqAttrSet.add(mpa);
    }

    private void syncPaperSource() {
        Media m = (Media)printReqAttrSet.get(Media.class);
        if (m != null &amp;&amp; m instanceof MediaTray) {
            printReqAttrSet.remove(Media.class);
        }
        PaperSource source = settings.getPaperSource();
        if (!source.equals(j2dPrinter.defaultPaperSource())) {
            MediaTray tray = j2dPrinter.getTrayForPaperSource(source);
            if (tray != null) {
                printReqAttrSet.add(tray);
            }
        }
    }

    private void syncColor() {
        if (settings.getPrintColor() == PrintColor.MONOCHROME) {
            printReqAttrSet.add(Chromaticity.MONOCHROME);
        } else {
            printReqAttrSet.add(Chromaticity.COLOR);
        }
    }

    private void syncPrintQuality() {
        javafx.print.PrintQuality
            quality = settings.getPrintQuality();
        PrintQuality j2DQuality;
        if (quality == javafx.print.PrintQuality.DRAFT) {
            j2DQuality = PrintQuality.DRAFT;
        } else if (quality == javafx.print.PrintQuality.HIGH) {
          j2DQuality = PrintQuality.HIGH;
        } else {
            j2DQuality = PrintQuality.NORMAL;
        }
        printReqAttrSet.add(j2DQuality);
    }

    private void syncPrintResolution() {
        /* An unsupported resolution results in incorrect scaling by J2D, so
         * remove any unsupported value, and only replace with a supported value.
         */
        PrintService ps = pJob2D.getPrintService();
        if (!ps.isAttributeCategorySupported(PrinterResolution.class)) {
            printReqAttrSet.remove(PrinterResolution.class);
            return;
        }
        PrinterResolution pres =
            (PrinterResolution)printReqAttrSet.get(PrinterResolution.class);
        if (pres != null &amp;&amp; !ps.isAttributeValueSupported(pres, null, null)) {
            printReqAttrSet.remove(PrinterResolution.class);
        };

        // Any resolution is now at least known to be supported for this device.
        PrintResolution res = settings.getPrintResolution();
        if (res == null) {
            return;
        }
        int cfRes = res.getCrossFeedResolution();
        int fRes = res.getFeedResolution();
        pres = new PrinterResolution(cfRes, fRes, ResolutionSyntax.DPI);
        if (!ps.isAttributeValueSupported(pres, null, null)) {
            return;
<A NAME="42"></A>        }
        // We have validated its a supported value, so add it.
        printReqAttrSet.add(pres);
    <FONT color="#c57717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#42',2,'match37-top.html#42',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    public PageLayout validatePageLayout(PageLayout pageLayout) {
        boolean needsNewLayout = false;
        PrinterAttributes caps = fxPrinter.getPrinterAttributes();
        Paper p = pageLayout.getPaper();
        if</B></FONT> (!caps.getSupportedPapers().contains(p)) {
            needsNewLayout = true;
            p = caps.getDefaultPaper();
        }
        PageOrientation o = pageLayout.getPageOrientation();
        if (!caps.getSupportedPageOrientations().contains(o)) {
            needsNewLayout = true;
            o = caps.getDefaultPageOrientation();
        }
        if (needsNewLayout) {
            pageLayout = fxPrinter.createPageLayout(p, o, MarginType.DEFAULT);
        }
        return pageLayout;
    }

    private boolean jobRunning = false;
    private boolean jobError = false;
    private boolean jobDone = false;
    private J2DPageable j2dPageable = null;

    /*
     * Permissions were already checked when creating the job,
     * and when setting output file, but this is a final check
     * to be made before we start the underlying native job.
     */
    private void checkPermissions() {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkPrintJobAccess();
        }
    }

    /*
     * 2D uses a call back model. So the 2D PrinterJob needs to run
     * on a different thread than the one that the FX app uses.
     * This gets really interesting if the FX Node is attached to a
     * scene, as you are only supposed to update it on the FX thread
     * and the PG code can only access it during sync.
     */
    public boolean print(PageLayout pageLayout, Node node) {
        if (Toolkit.getToolkit().isFxUserThread()) {
            // If we are on the event thread, we need to check whether we are
            // allowed to call a nested event handler.
            if (!Toolkit.getToolkit().canStartNestedEventLoop()) {
                throw new IllegalStateException(&quot;Printing is not allowed during animation or layout processing&quot;);
            }
        }

        if (jobError || jobDone) {
            return false;
        }

        if (!jobRunning) {
            checkPermissions();
            syncSettingsToAttributes();
            PrintJobRunnable runnable = new PrintJobRunnable();
            Thread prtThread = new Thread(runnable, &quot;Print Job Thread&quot;);
            prtThread.start();
            jobRunning = true;
        }
        try {
            j2dPageable.implPrintPage(pageLayout, node);
        } catch (Throwable t) {
            if (com.sun.prism.impl.PrismSettings.debug) {
                System.err.println(&quot;printPage caught exception.&quot;);
                t.printStackTrace();
            }
            jobError = true;
            jobDone = true;
        }
        return !jobError;
    }

    private class PrintJobRunnable implements Runnable {

        public void run() {

            try {
                pJob2D.print(printReqAttrSet);
                jobDone = true;
            } catch (Throwable t) { /* subsumes declared PrinterException */
                if (com.sun.prism.impl.PrismSettings.debug) {
                    System.err.println(&quot;print caught exception.&quot;);
                    t.printStackTrace();
                }
                jobError = true;
                jobDone = true;
            }
            /*
             * If the job ends because its reached a page range limit
             * rather than calling getPage() we need to exit the nested loop.
             */
            if (elo != null) {
                Application.invokeLater(new ExitLoopRunnable(elo, null));
            }
        }
    }

    static class LayoutRunnable implements Runnable {
        PageInfo pageInfo;

        LayoutRunnable(PageInfo info) {
            pageInfo = info;
        }

        public void run() {
            if (pageInfo.tempScene &amp;&amp; pageInfo.root.getScene() == null) {
                new Scene(pageInfo.root);
            }
            NodeHelper.layoutNodeForPrinting(pageInfo.root);
        }
    }

    static class ClearSceneRunnable implements Runnable {
        PageInfo pageInfo;

        ClearSceneRunnable(PageInfo info) {
            pageInfo = info;
        }

        public void run() {
            pageInfo.clearScene();
        }
    }

    private static class PageInfo {

        private PageLayout pageLayout;
        private Node node;
        private Parent root;
        private Node topNode;
        private Group group;
        private boolean tempGroup;
        private boolean tempScene;
        private boolean sceneInited;

        PageInfo(PageLayout pageLayout, Node node) {
            this.pageLayout = pageLayout;
            this.node = node;
        }

        Node getNode() {
            initScene();
            return node;
        }

        PageLayout getPageLayout() {
            return pageLayout;
        }

        /*
         * There are 4 scenarios here.
         * 1. We are passed the root node of a Scene.
         * 2. We are passed a child node of a Scene, but not the root
         * 3. We are passed a root node (no parent) but its not attached
         * to a Scene.
         * 4. We are passed a child node, but its not part of a Scene.
         * In addition we may be called on the FX thread, or not.
         * The code here is trying to make all of these work without
         * the application needing to do anything special, and hopefully
         * without affecting the application.
         * The application should not be surprised if we request layout for it,
         * since we can't display or print an unlaid out hiearchy.
         *
         * If this is the FX thread, then we can do everything directly.
         * If not, we must add the node to a scene (if needed) and
         * request layout on another thread.
         * I am assuming here that layout will be a quick no-op if
         * everything is already laid out.
         * Eventually all of this should be able to be performed on any
         * thread, and without attaching to a scene, so this is largely
         * workaround. One part I'm not so sure about is whether it
         * will ever be the case that being passed a node that is part
         * of a hierarchy, but not its root, will be able to be laid out
         * directly, or if you need to traverse to the root.
         */
        void initScene() {
            if (sceneInited) {
               return;
            }
            if (node.getScene() == null) {
                tempScene = true;
                Node topNode = node;
                while (topNode.getParent() != null) {
                    topNode = topNode.getParent();
                }
                if (topNode instanceof Group) {
                    group = (Group)topNode;
                } else {
                    tempGroup = true;
                    group = new Group();
                    group.getChildren().add(topNode);
                }
                root = group;
            } else {
                root = node.getScene().getRoot();
            }
            if (Toolkit.getToolkit().isFxUserThread()) {
                if (tempScene &amp;&amp; root.getScene() == null) {
                    new Scene(root); // don't need to keep the scene variable
                }
                NodeHelper.layoutNodeForPrinting(root);
            } else {
                Application.invokeAndWait(new LayoutRunnable(this));
            }
            sceneInited = true;
        }

        private void clearScene() {
            if (tempGroup) {
                group.getChildren().removeAll(root);
            }
            tempGroup = false;
            tempScene = false;
            root = null;
            group = null;
            topNode = null;
            sceneInited = false;
        }
    }

    private Object monitor = new Object();

    static class ExitLoopRunnable implements Runnable {
        Object elo, rv;

        ExitLoopRunnable(Object elo, Object rv) {
            this.elo = elo;
            this.rv = rv;
        }

        public void run() {
            Toolkit.getToolkit().exitNestedEventLoop(elo, rv);
        }
    }

    private class J2DPageable implements Pageable, Printable {

        private volatile boolean pageDone;

        private int currPageIndex = -1;

        private volatile PageInfo newPageInfo = null;
        private PageInfo currPageInfo;
        private PageFormat currPageFormat;


        private boolean waitForNextPage(int pageIndex) {

            if (elo != null &amp;&amp; currPageInfo != null) {
                Application.invokeLater(new ExitLoopRunnable(elo, null));
            }

            if (currPageInfo != null) {
                if (Toolkit.getToolkit().isFxUserThread()) {
                    currPageInfo.clearScene();
                } else {
                    Application.
                        invokeAndWait(new ClearSceneRunnable(currPageInfo));
                }
            }
            currPageInfo = null;
            pageDone = true;
            synchronized (monitor) {
                if (newPageInfo == null) {
                    monitor.notify(); // page is printed and no new page to print
                }
                while (newPageInfo == null &amp;&amp; !jobDone &amp;&amp; !jobError) {
                    try {
                        monitor.wait(1000);
                    } catch (InterruptedException e) {
                    }
                }
            }
            if (jobDone || jobError) {
                return false;
            }
            currPageInfo = newPageInfo;
            newPageInfo = null;
            currPageIndex = pageIndex;
            currPageFormat = getPageFormatFromLayout(currPageInfo.getPageLayout());
            return true;
        }

        private PageFormat getPageFormatFromLayout(PageLayout layout) {
            java.awt.print.Paper paper = new java.awt.print.Paper();
            double pWid = layout.getPaper().getWidth();
            double pHgt = layout.getPaper().getHeight();
            double ix=0, iy=0, iw=pWid, ih=pHgt;
            PageOrientation orient = layout.getPageOrientation();
            switch (orient) {
            case PORTRAIT:
                ix = layout.getLeftMargin();
                iy = layout.getTopMargin();
                iw = pWid - ix - layout.getRightMargin();
                ih = pHgt - iy - layout.getBottomMargin();
                break;
            case REVERSE_PORTRAIT:
                ix = layout.getRightMargin();
                iy = layout.getBottomMargin();
                iw = pWid - ix - layout.getLeftMargin();
                ih = pHgt - iy - layout.getTopMargin();
                break;
            case LANDSCAPE:
                ix = layout.getBottomMargin();
                iy = layout.getLeftMargin();
                iw = pWid - ix - layout.getTopMargin();
                ih = pHgt - iy - layout.getRightMargin();
                break;
            case REVERSE_LANDSCAPE:
                ix = layout.getTopMargin();
                iy = layout.getRightMargin();
                iw = pWid - ix - layout.getBottomMargin();
                ih = pHgt - iy - layout.getLeftMargin();
            }
            paper.setSize(pWid, pHgt);
            paper.setImageableArea(ix, iy, iw, ih);
            PageFormat format = new PageFormat();
            format.setOrientation(J2DPrinter.getOrientID(orient));
            format.setPaper(paper);
            return format;
        }

        private boolean getPage(int pageIndex) {
            if (pageIndex == currPageIndex) {
                return true;
            }
            boolean nextPage = false;
            if (pageIndex &gt; currPageIndex) {
                nextPage = waitForNextPage(pageIndex);
            }
            return nextPage;
        }

        public int print(Graphics g, PageFormat pf, int pageIndex) {
            if (jobError || jobDone || !getPage(pageIndex)) {
                return Printable.NO_SUCH_PAGE;
            }
            int x = (int)pf.getImageableX();
            int y = (int)pf.getImageableY();
            int w = (int)pf.getImageableWidth();
            int h = (int)pf.getImageableHeight();
            Node appNode = currPageInfo.getNode();
            g.translate(x, y);
            printNode(appNode, g, w, h);
            return Printable.PAGE_EXISTS;
        }

        private void printNode(Node node, Graphics g, int w, int h) {
            PrismPrintGraphics ppg =
                    new PrismPrintGraphics((Graphics2D) g, w, h);
            NGNode pgNode = NodeHelper.getPeer(node);
            boolean errored = false;
            try {
                pgNode.render(ppg);
            } catch (Throwable t) {
                if (com.sun.prism.impl.PrismSettings.debug) {
                    System.err.println(&quot;printNode caught exception.&quot;);
                    t.printStackTrace();
                }
                errored = true;
            }
            ppg.getResourceFactory()
                    .getTextureResourcePool()
                    .freeDisposalRequestedAndCheckResources(errored);
        }

        public Printable getPrintable(int pageIndex) {
            getPage(pageIndex);
            return this;
        }

        public PageFormat getPageFormat(int pageIndex) {
            getPage(pageIndex);
            return currPageFormat;
        }

        /*
         * Since we return unknown number of pages, then
         * the behaviour must be that we can only signal
         * end of the job by returning NO_SUCH_PAGE from
         * the print(..) method.
         */
        public int getNumberOfPages() {
            return Pageable.UNKNOWN_NUMBER_OF_PAGES;
        }

        /*
         * Executed on the application's thread.
         * Messages over to the printing thread.
         */
        private void implPrintPage(PageLayout pageLayout, Node node) {

            /* The public API printPage() is synchronized, so we know
             * that the app can't call it from 2 threads at the same
             * time, not that this is encouraged either.
             * Therefore when we are in this code, we know that any
             * previous page rendering has completed.
             * We also know that this means the app can't have 'queued up'
             * pages.
             * So, when we are in here, we know that the app is providing
             * the info for the next page.
             */
            pageDone = false;
            synchronized (monitor) {
                newPageInfo = new PageInfo(pageLayout, node);
                monitor.notify();
            }
            if (Toolkit.getToolkit().isFxUserThread()) {
                elo = new Object();
                Toolkit.getToolkit().enterNestedEventLoop(elo);
                elo = null;
            } else {
                while (!pageDone &amp;&amp; !jobDone &amp;&amp; !jobError) {
                    synchronized (monitor) {
                        try {
                            if (!pageDone) {
                                monitor.wait(1000);
                            }
                        } catch (InterruptedException e) {
                        }
                    }
                }
            }
        }

    } /* END J2DPageable class */


    public boolean endJob() {
        if (jobRunning &amp;&amp; !jobDone &amp;&amp; !jobError) {
            jobDone = true;
            try {
                synchronized (monitor) {
                    monitor.notify();
                    return jobDone;
                }
            } catch (IllegalStateException e) {
                if (com.sun.prism.impl.PrismSettings.debug) {
                    System.err.println(&quot;Internal Error &quot; + e);
                }
            }
        } else {
            return jobDone &amp;&amp; !jobError;
        }
        return jobDone;
    }

    public void cancelJob() {
        if (!pJob2D.isCancelled()) {
            pJob2D.cancel();
        }
        jobDone = true;
        if (jobRunning) {
            jobRunning = false;
            try {
                synchronized (monitor) {
                    monitor.notify();
                }
            } catch (IllegalStateException e) {
                if (com.sun.prism.impl.PrismSettings.debug) {
                    System.err.println(&quot;Internal Error &quot; + e);
                }
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/sw/SWRTTexture.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="27"></A> * questions.
 */

<FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#27',2,'match37-top.html#27',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.prism.sw;

import com.sun.glass.ui.Screen;
import com.sun.javafx.geom.Rectangle;
import com.sun.pisces.JavaSurface;
import com.sun.pisces.PiscesRenderer;
import com.sun.pisces.RendererBase;
import com.sun.prism.Graphics;
import com.sun.prism.RTTexture;
import com.sun.prism.impl.PrismSettings;

import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;

class SWRTTexture extends SWArgbPreTexture implements RTTexture {

    private PiscesRenderer pr;
    private JavaSurface surface;
    private final Rectangle dimensions = new</B></FONT> Rectangle();
    private boolean isOpaque;

    SWRTTexture(SWResourceFactory factory, int w, int h) {
        super(factory, WrapMode.CLAMP_TO_ZERO, w, h);
        this.allocate();
        this.surface = new JavaSurface(getDataNoClone(), RendererBase.TYPE_INT_ARGB_PRE, w, h);
        this.dimensions.setBounds(0, 0, w, h);
    }

    JavaSurface getSurface() {
        return this.surface;
    }

    @Override
    public int[] getPixels() {
        if (contentWidth == physicalWidth) {
            return getDataNoClone();
        } else {
            return null;
        }
    }

    @Override
    public boolean readPixels(Buffer pixels, int x, int y, int width, int height) {
        if (x != getContentX() || y != getContentY()
                || width != getContentWidth() || height != getContentHeight())
        {
            throw new IllegalArgumentException(&quot;reading subtexture not yet supported!&quot;);
        }
        return readPixels(pixels);
    }

    @Override
    public boolean readPixels(Buffer pixels) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ SWRTT.readPixels: this: &quot; + this);
        }

        final int pixbuf[] = getDataNoClone();
        pixels.clear();
        // REMIND: This assumes that the caller wants BGRA PRE data...?
        if (pixels instanceof IntBuffer) {
            final IntBuffer iPixels = (IntBuffer)pixels;
            for (int i = 0; i &lt; contentHeight; i++) {
                iPixels.put(pixbuf, i*physicalWidth, contentWidth);
            }
        } else if (pixels instanceof ByteBuffer) {
            final ByteBuffer bPixels = (ByteBuffer)pixels;
            for (int i = 0; i &lt; contentHeight; i++) {
                for (int j = 0; j &lt; contentWidth; j++) {
                    final int argb = pixbuf[i*physicalWidth + j];
                    final byte a = (byte) (argb &gt;&gt; 24);
                    final byte r = (byte) (argb &gt;&gt; 16);
                    final byte g = (byte) (argb &gt;&gt;  8);
                    final byte b = (byte) (argb      );
                    bPixels.put(b).put(g).put(r).put(a);
                }
            }
        } else {
            return false;
        }
        pixels.rewind();
        return true;
    }

    public Screen getAssociatedScreen() {
        return getResourceFactory().getScreen();
    }

    public Graphics createGraphics() {
        if (pr == null) {
            pr = new PiscesRenderer(this.surface);
        }
        return new SWGraphics(this, getResourceFactory().getContext(), pr);
    }

    public boolean isOpaque() {
        return isOpaque;
    }

    public void setOpaque(boolean opaque) {
        this.isOpaque = opaque;
    }

    Rectangle getDimensions() { return dimensions; }

    public boolean isVolatile() {
        return false;
    }

    @Override
    public boolean isMSAA() {
        return false;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/scenario/Settings.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.scenario;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;

import com.sun.javafx.tk.Toolkit;
import javafx.util.Callback;

/**
 * A simple class to store and retrieve internal Scenario settings in the form
 * of String key/value pairs. It is meant to be used in a similar way to System
 * Properties, but without the security restrictions. This class is designed
 * primarily to aid in testing and benchmarking Scenario itself.
 *
 * If you are running in an environment that allows System Property access, this
 * class will attempt to look for a key's value in the System Properties if none
 * is found in Settings. This allows Settings to be set on the command line as
 * well as via the Settings API.
 *
 */
public class Settings {

    private final Map&lt;String, String&gt; settings = new HashMap&lt;&gt;(5);
    private final CopyOnWriteArrayList&lt;Callback&lt;String, Void&gt;&gt; listeners = new CopyOnWriteArrayList&lt;&gt;();
    private static final Object SETTINGS_KEY;
    static {
        SETTINGS_KEY = new StringBuilder(&quot;SettingsKey&quot;);

        // It seems no longer necessary to force loading of MasterTimer to pick
        // up the hi-res timer workaround. Also, this is causing some init
        // order problems (RT-5572), so it's being commented out.
        // Object obj = ToolkitAccessor.getMasterTimer();
    }

    private static synchronized Settings getInstance() {
        Map&lt;Object, Object&gt; contextMap = Toolkit.getToolkit().getContextMap();
        Settings instance = (Settings) contextMap.get(SETTINGS_KEY);
        if (instance == null) {
            instance = new Settings();
            contextMap.put(SETTINGS_KEY, instance);
        }
        return instance;
    }

    /**
     * Add a new key-value setting.
     *
     * Passing a value of null indicates that the value for this key should be
     * looked for in the System Properties.
     *
     * If PropertyChangeListeners have been registered for the given key, they
     * will be notified of a change in value.
     *
     * If key is &quot;&quot; or null, this methods throws an IllegalArgumentException.
     */
    public static void set(String key, String value) {
        getInstance().setImpl(key, value);
    }

    private void setImpl(String key, String value) {
        checkKeyArg(key);
        settings.put(key, value);
        for (Callback&lt;String, Void&gt; l : listeners) {
            l.call(key);
        }
     }

    /**
     * Retrieve the value for the given key.
     *
     * If the key is not present in Settings or its value is null, this methods
     * then checks to see if a value for this key is present in the System
     * Properties (provided you have sufficient privileges).
     *
     * If no value can be found for the given key, this method returns null.
     *
     * If key is &quot;&quot; or null, this methods throws an IllegalArgumentException.
     */
    public static String get(String key) {
        return getInstance().getImpl(key);
    }

    private String getImpl(String key) {
        checkKeyArg(key);
        String retVal = settings.get(key);
        if (retVal == null) {
            try {
                retVal = System.getProperty(key);
<A NAME="13"></A>            } catch (SecurityException ignore) {
            }
        }
        <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#13',2,'match37-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return retVal;
    }

    /**
     * Convenience method for boolean settings.
     *
     * If the setting exists and its value is &quot;true&quot;, true is returned.
     * Otherwise, false is returned.
     *
     * If key is &quot;&quot; or null, this methods throws an IllegalArgumentException.
     */
    public static boolean getBoolean(String key) {
        return getInstance().getBooleanImpl(key);
    }

    private boolean getBooleanImpl(String key) {
        // get() will call checkKeyArg(), so don't check it here
        String value = getImpl(key);
        return &quot;true&quot;.equals(value);
    }

    /**
     * Convenience method for boolean settings.
     *
     * If the setting is set to &quot;true&quot;, true is returned. If the setting is set
     * to &quot;false&quot;, false is returned. It the setting is set to anything else,
     * defaultVal is returned.
     *
     * If key is &quot;&quot; or null, this methods throws an IllegalArgumentException.
     */
    public static boolean getBoolean(String key, boolean defaultVal) {</B></FONT>
        return getInstance().getBooleanImpl(key, defaultVal);
    }

    private boolean getBooleanImpl(String key, boolean defaultVal) {
        // get() will call checkKeyArg(), so don't check it here
        String value = getImpl(key);
        boolean retVal = defaultVal;
        if (value != null) {
            if (&quot;false&quot;.equals(value)) {
                retVal = false;
            } else if (&quot;true&quot;.equals(value)) {
                retVal = true;
            }
        }
        return retVal;
    }

    /**
     * Convenience method for int settings.
     *
     * If the setting exists and its value can be parsed to an int, the int
     * value is returned. Otherwise, the default value is returned.
     *
     * If key is &quot;&quot; or null, this methods throws an IllegalArgumentException.
     */
    public static int getInt(String key, int defaultVal) {
        return getInstance().getIntImpl(key, defaultVal);
    }

    private int getIntImpl(String key, int defaultVal) {
        // get() will call checkKeyArg(), so don't check it here
        String value = getImpl(key);
        int retVal = defaultVal;
        try {
            retVal = Integer.parseInt(value);
        } catch (NumberFormatException ignore) {
            // ignore.printStackTrace();
        }
        return retVal;
    }

    /**
     * Add a PropertyChangeListener for the specified setting
     *
     * Note that the PropertyChangeEvent will contain old and new values as they
     * would be returned from get(), meaning they may come from the System
     * Properties.
     *
     * If key is &quot;&quot; or null, this methods throws an IllegalArgumentException. If
     * listener is null no exception is thrown and no action is taken.
     */
    public static void addPropertyChangeListener(Callback&lt;String, Void&gt; pcl) {
        getInstance().addPropertyChangeListenerImpl(pcl);
    }

    private void addPropertyChangeListenerImpl(Callback&lt;String, Void&gt; pcl) {
        listeners.add(pcl);
    }

    /**
     * Remove the specified PropertyChangeListener.
     *
     * If listener is null, or was never added, no exception is thrown and no
     * action is taken.
     */
    public static void removePropertyChangeListener(Callback&lt;String, Void&gt; pcl) {
        getInstance().removePropertyChangeListenerImpl(pcl);
    }

    private void removePropertyChangeListenerImpl(Callback&lt;String, Void&gt; pcl) {
        listeners.remove(pcl);
    }

    /*
     * Check that key is a valid Settings key. If not, throw an
     * IllegalArgumentException.
     */
    private void checkKeyArg(String key) {
        if (null == key || &quot;&quot;.equals(key)) {
            throw new IllegalArgumentException(&quot;null key not allowed&quot;);
        }
    }

    private Settings() {
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/animation/SequentialTransition.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.animation;

import com.sun.javafx.animation.TickCalculation;
import static com.sun.javafx.animation.TickCalculation.*;

import java.util.Arrays;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.ListChangeListener.Change;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.util.Duration;

import com.sun.javafx.collections.TrackableObservableList;
import com.sun.javafx.collections.VetoableListDecorator;
import com.sun.scenario.animation.AbstractMasterTimer;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;

/**
 * This {@link Transition} plays a list of {@link javafx.animation.Animation
 * Animations} in sequential order.
 * &lt;p&gt;
 * Children of this {@code Transition} inherit {@link #nodeProperty() node}, if their
 * {@code node} property is not specified.
 *
 * &lt;p&gt;
 * Code Segment Example:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * &lt;code&gt;
 *     Rectangle rect = new Rectangle (100, 40, 100, 100);
 *     rect.setArcHeight(50);
 *     rect.setArcWidth(50);
 *     rect.setFill(Color.VIOLET);
 *
 *     final Duration SEC_2 = Duration.millis(2000);
 *     final Duration SEC_3 = Duration.millis(3000);
 *
 *     PauseTransition pt = new PauseTransition(Duration.millis(1000));
 *     FadeTransition ft = new FadeTransition(SEC_3);
 *     ft.setFromValue(1.0f);
 *     ft.setToValue(0.3f);
 *     ft.setCycleCount(2f);
 *     ft.setAutoReverse(true);
 *     TranslateTransition tt = new TranslateTransition(SEC_2);
 *     tt.setFromX(-100f);
 *     tt.setToX(100f);
 *     tt.setCycleCount(2f);
 *     tt.setAutoReverse(true);
 *     RotateTransition rt = new RotateTransition(SEC_3);
 *     rt.setByAngle(180f);
 *     rt.setCycleCount(4f);
 *     rt.setAutoReverse(true);
 *     ScaleTransition st = new ScaleTransition(SEC_2);
 *     st.setByX(1.5f);
 *     st.setByY(1.5f);
 *     st.setCycleCount(2f);
 *     st.setAutoReverse(true);
 *
 *     SequentialTransition seqT = new SequentialTransition (rect, pt, ft, tt, rt, st);
 *     seqT.play();
 * &lt;/code&gt;
 * &lt;/pre&gt;
 *
 * @see Transition
 * @see Animation
 *
 * @since JavaFX 2.0
 */
public final class SequentialTransition extends Transition {

    private static final Animation[] EMPTY_ANIMATION_ARRAY = new Animation[0];
    private static final int BEFORE = -1;
    private static final double EPSILON = 1e-12;

    private Animation[] cachedChildren = EMPTY_ANIMATION_ARRAY;
    private long[] startTimes;
    private long[] durations;
    private long[] delays;
    private double[] rates;
    private boolean[] forceChildSync;
    private int end;
    private int curIndex = BEFORE;
    private long oldTicks = 0L;
    private long offsetTicks;
    private boolean childrenChanged = true;
    private boolean toggledRate;

    private final InvalidationListener childrenListener = observable -&gt; {
        childrenChanged = true;
        if (getStatus() == Status.STOPPED) {
            setCycleDuration(computeCycleDuration());
        }
    };

    private final ChangeListener&lt;Number&gt; rateListener = new ChangeListener&lt;Number&gt;() {

        @Override
        public void changed(ObservableValue&lt;? extends Number&gt; observable, Number oldValue, Number newValue) {
            if (oldValue.doubleValue() * newValue.doubleValue() &lt; 0) {
                for (int i = 0; i &lt; cachedChildren.length; ++i) {
                    Animation child = cachedChildren[i];
                    child.clipEnvelope.setRate(rates[i] * Math.signum(getCurrentRate()));
                }
                toggledRate = true;
            }
        }

    };

    /**
     * This {@link javafx.scene.Node} is used in all child {@link Transition
     * Transitions}, that do not define a target {@code Node} themselves. This
     * can be used if a number of {@code Transitions} should be applied to a
     * single {@code Node}.
     * &lt;p&gt;
     * It is not possible to change the target {@code node} of a running
     * {@code Transition}. If the value of {@code node} is changed for a
     * running {@code Transition}, the animation has to be stopped and started again to
     * pick up the new value.
     */
    private ObjectProperty&lt;Node&gt; node;
    private static final Node DEFAULT_NODE = null;

    public final void setNode(Node value) {
        if ((node != null) || (value != null /* DEFAULT_NODE */)) {
            nodeProperty().set(value);
        }
    }

    public final Node getNode() {
        return (node == null)? DEFAULT_NODE : node.get();
    }

    public final ObjectProperty&lt;Node&gt; nodeProperty() {
        if (node == null) {
            node = new SimpleObjectProperty&lt;Node&gt;(this, &quot;node&quot;, DEFAULT_NODE);
        }
        return node;
    }

    private final Set&lt;Animation&gt; childrenSet = new HashSet&lt;Animation&gt;();

    private final ObservableList&lt;Animation&gt; children = new VetoableListDecorator&lt;Animation&gt;(new TrackableObservableList&lt;Animation&gt;() {
        @Override
        protected void onChanged(Change&lt;Animation&gt; c) {
            while (c.next()) {
                for (final Animation animation : c.getRemoved()) {
                    animation.parent = null;
                    animation.rateProperty().removeListener(childrenListener);
                    animation.totalDurationProperty().removeListener(childrenListener);
                    animation.delayProperty().removeListener(childrenListener);
                }
                for (final Animation animation : c.getAddedSubList()) {
                    animation.parent = SequentialTransition.this;
                    animation.rateProperty().addListener(childrenListener);
                    animation.totalDurationProperty().addListener(childrenListener);
                    animation.delayProperty().addListener(childrenListener);
                }
            }
            childrenListener.invalidated(children);
        }
    }) {

        @Override
        protected void onProposedChange(List&lt;Animation&gt; toBeAdded, int... indexes) {
            IllegalArgumentException exception = null;
            for (int i = 0; i &lt; indexes.length; i+=2) {
                for (int idx = indexes[i]; idx &lt; indexes[i+1]; ++idx) {
                    childrenSet.remove(children.get(idx));
                }
            }
            for (Animation child : toBeAdded) {
                if (child == null) {
                    exception = new IllegalArgumentException(&quot;Child cannot be null&quot;);
                    break;
                }
                if (!childrenSet.add(child)) {
                    exception = new IllegalArgumentException(&quot;Attempting to add a duplicate to the list of children&quot;);
                    break;
                }
                if (checkCycle(child, SequentialTransition.this)) {
                    exception = new IllegalArgumentException(&quot;This change would create cycle&quot;);
                    break;
                }
            }

            if (exception != null) {
                childrenSet.clear();
                childrenSet.addAll(children);
                throw exception;
            }
        }

    };

    private static boolean checkCycle(Animation child, Animation parent) {
        Animation a = parent;
        while (a != child) {
            if (a.parent != null) {
                a = a.parent;
            } else {
                return false;
            }
        }
        return true;
    }

    /**
     * A list of {@link javafx.animation.Animation Animations} that will be
     * played sequentially.
     * &lt;p&gt;
     * It is not possible to change the children of a running
     * {@code SequentialTransition}. If the children are changed for a running
     * {@code SequentialTransition}, the animation has to be stopped and started
     * again to pick up the new value.
     * @return a list of Animations that will be played sequentially
     */
    public final ObservableList&lt;Animation&gt; getChildren() {
        return children;
    }

    /**
     * The constructor of {@code SequentialTransition}.
     *
     * @param node
     *            The target {@link javafx.scene.Node} to be used in child
     *            {@link Transition Transitions} that have no {@code Node} specified
     *            themselves
     * @param children
     *            The child {@link javafx.animation.Animation Animations} of
     *            this {@code SequentialTransition}
     */
    public SequentialTransition(Node node, Animation... children) {
        setInterpolator(Interpolator.LINEAR);
        setNode(node);
        getChildren().setAll(children);
    }

    /**
     * The constructor of {@code SequentialTransition}.
     *
     * @param children
     *            The child {@link javafx.animation.Animation Animations} of
     *            this {@code SequentialTransition}
     */
    public SequentialTransition(Animation... children) {
        this(null, children);
    }

    /**
     * The constructor of {@code SequentialTransition}.
     *
     * @param node
     *            The target {@link javafx.scene.Node} to be used in child
     *            {@link Transition Transitions} that have no {@code Node} specified
     *            themselves
     */
    public SequentialTransition(Node node) {
        setInterpolator(Interpolator.LINEAR);
        setNode(node);
    }

    /**
     * The constructor of {@code SequentialTransition}.
     */
    public SequentialTransition() {
        this((Node) null);
    }

    // For testing purposes
    SequentialTransition(AbstractMasterTimer timer) {
        super(timer);
        setInterpolator(Interpolator.LINEAR);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected Node getParentTargetNode() {
        final Node _node = getNode();
        return (_node != null) ? _node : ((parent != null &amp;&amp; parent instanceof Transition) ?
                ((Transition)parent).getParentTargetNode() : null);
    }

    private Duration computeCycleDuration() {
        Duration currentDur = Duration.ZERO;

        for (final Animation animation : getChildren()) {
            currentDur = currentDur.add(animation.getDelay());
<A NAME="16"></A>            final double absRate = Math.abs(animation.getRate());
            currentDur = currentDur.add((absRate &lt; EPSILON) ?
                    animation.getTotalDuration() : animation.getTotalDuration().divide(absRate));
            if (<FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#16',2,'match37-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>currentDur.isIndefinite()) {
                break;
            }
        }
        return currentDur;
    }</B></FONT>

    private double calculateFraction(long currentTicks, long cycleTicks) {
        final double frac = (double) currentTicks / cycleTicks;
        return (frac &lt;= 0.0) ? 0 : (frac &gt;= 1.0) ? 1.0 : frac;
    }

    private int findNewIndex(long ticks) {
        if ((curIndex != BEFORE)
                &amp;&amp; (curIndex != end)
                &amp;&amp; (startTimes[curIndex] &lt;= ticks)
                &amp;&amp; (ticks &lt;= startTimes[curIndex + 1])) {
            return curIndex;
        }

        final boolean indexUndefined = (curIndex == BEFORE) || (curIndex == end);
        final int fromIndex = (indexUndefined || (ticks &lt; oldTicks)) ? 0 : curIndex + 1;
        final int toIndex = (indexUndefined || (oldTicks &lt; ticks)) ? end : curIndex;
        final int index = Arrays.binarySearch(startTimes, fromIndex, toIndex, ticks);
        return (index &lt; 0) ? -index - 2 : (index &gt; 0) ? index - 1 : 0;
    }

    @Override
    void sync(boolean forceSync) {
        super.sync(forceSync);

        if ((forceSync &amp;&amp; childrenChanged) || (startTimes == null)) {
            cachedChildren = getChildren().toArray(EMPTY_ANIMATION_ARRAY);
            end = cachedChildren.length;
            startTimes = new long[end + 1];
            durations = new long[end];
            delays = new long[end];
            rates = new double[end];
            forceChildSync = new boolean[end];
            long cycleTicks = 0L;
            int i = 0;
            for (final Animation animation : cachedChildren) {
                startTimes[i] = cycleTicks;
                rates[i] = Math.abs(animation.getRate());
                if (rates[i] &lt; EPSILON) {
                    rates[i] = 1;
                }
                durations[i] = fromDuration(animation.getTotalDuration(), rates[i]);
                delays[i] = fromDuration(animation.getDelay());
                if ((durations[i] == Long.MAX_VALUE) || (delays[i] == Long.MAX_VALUE) || (cycleTicks == Long.MAX_VALUE)) {
                    cycleTicks = Long.MAX_VALUE;
                } else {
                    cycleTicks = add(cycleTicks, add(durations[i], delays[i]));
                }
                forceChildSync[i] = true;
                i++;
            }
            startTimes[end] = cycleTicks;
            childrenChanged = false;
        } else if (forceSync) {
            final int n = forceChildSync.length;
            for (int i=0; i&lt;n; i++) {
                forceChildSync[i] = true;
            }
        }
    }

    @Override
    void doStart(boolean forceSync) {
        super.doStart(forceSync);
        toggledRate = false;
        rateProperty().addListener(rateListener);
        offsetTicks = 0L;
        double curRate = getCurrentRate();
        final long currentTicks = TickCalculation.fromDuration(getCurrentTime());
        if (curRate &lt; 0) {
            jumpToEnd();
            curIndex = end;
            if (currentTicks &lt; startTimes[end]) {
                doJumpTo(currentTicks, startTimes[end], false);
            }
        } else {
            jumpToBefore();
            curIndex = BEFORE;
            if (currentTicks &gt; 0) {
                doJumpTo(currentTicks, startTimes[end], false);
            }
        }
    }

    @Override
    void doPause() {
        super.doPause();
        if ((curIndex != BEFORE) &amp;&amp; (curIndex != end)) {
            final Animation current = cachedChildren[curIndex];
            if (current.getStatus() == Status.RUNNING) {
                current.doPause();
            }
        }
    }

    @Override
    void doResume() {
        super.doResume();
        if ((curIndex != BEFORE) &amp;&amp; (curIndex != end)) {
            final Animation current = cachedChildren[curIndex];
            if (current.getStatus() == Status.PAUSED) {
                current.doResume();
                current.clipEnvelope.setRate(rates[curIndex] * Math.signum(getCurrentRate()));
            }
        }
    }

    @Override
    void doStop() {
        super.doStop();
        if ((curIndex != BEFORE) &amp;&amp; (curIndex != end)) {
            final Animation current = cachedChildren[curIndex];
            if (current.getStatus() != Status.STOPPED) {
                current.doStop();
            }
        }
        if (childrenChanged) {
            setCycleDuration(computeCycleDuration());
        }
        rateProperty().removeListener(rateListener);
    }

    private boolean startChild(Animation child, int index) {
        final boolean forceSync = forceChildSync[index];
        if (child.startable(forceSync)) {
            child.clipEnvelope.setRate(rates[index] * Math.signum(getCurrentRate()));
            child.doStart(forceSync);
            forceChildSync[index] = false;
            return true;
        }
        return false;
    }

    @Override void doPlayTo(long currentTicks, long cycleTicks) {
        setCurrentTicks(currentTicks);
        final double frac = calculateFraction(currentTicks, cycleTicks);
        final long newTicks = Math.max(0, Math.min(getCachedInterpolator().interpolate(0, cycleTicks, frac), cycleTicks));
        final int newIndex = findNewIndex(newTicks);
        final Animation current = ((curIndex == BEFORE) || (curIndex == end)) ? null : cachedChildren[curIndex];
        if (toggledRate) {
            if (current != null &amp;&amp; current.getStatus() == Status.RUNNING) {
                offsetTicks -= Math.signum(getCurrentRate()) * (durations[curIndex] - 2 * (oldTicks - delays[curIndex] - startTimes[curIndex]));
            }
            toggledRate = false;
        }
        if (curIndex == newIndex) {
            if (getCurrentRate() &gt; 0) {
                final long currentDelay = add(startTimes[curIndex], delays[curIndex]);
                if (newTicks &gt;= currentDelay) {
                    if ((oldTicks &lt;= currentDelay) || (current.getStatus() == Status.STOPPED)) {
                        final boolean enteringCycle = oldTicks &lt;= currentDelay;
                        if (enteringCycle) {
                            current.clipEnvelope.jumpTo(0);
                        }
                        if (!startChild(current, curIndex)) {
                            if (enteringCycle) {
                                final EventHandler&lt;ActionEvent&gt; handler = current.getOnFinished();
                                if (handler != null) {
                                    handler.handle(new ActionEvent(this, null));
                                }
                            }
                            oldTicks = newTicks;
                            return;
                        }
                    }
                    if (newTicks &gt;= startTimes[curIndex+1]) {
                        current.doTimePulse(sub(durations[curIndex], offsetTicks));
                        if (newTicks == cycleTicks) {
                            curIndex = end;
                        }
                    } else {
                        final long localTicks = sub(newTicks - currentDelay, offsetTicks);
                        current.doTimePulse(localTicks);
                    }
                }
            } else { // getCurrentRate() &lt; 0
                final long currentDelay = add(startTimes[curIndex], delays[curIndex]);
                if ((oldTicks &gt;= startTimes[curIndex+1]) || ((oldTicks &gt;= currentDelay) &amp;&amp; (current.getStatus() == Status.STOPPED))){
                    final boolean enteringCycle = oldTicks &gt;= startTimes[curIndex+1];
                    if (enteringCycle) {
                        current.clipEnvelope.jumpTo(Math.round(durations[curIndex] * rates[curIndex]));
                    }
                    if (!startChild(current, curIndex)) {
                        if (enteringCycle) {
                            final EventHandler&lt;ActionEvent&gt; handler = current.getOnFinished();
                            if (handler != null) {
                                handler.handle(new ActionEvent(this, null));
                            }
                        }
                        oldTicks = newTicks;
                        return;
                    }
                }
                if (newTicks &lt;= currentDelay) {
                    current.doTimePulse(sub(durations[curIndex], offsetTicks));
                    if (newTicks == 0) {
                        curIndex = BEFORE;
                    }
                } else {
                    final long localTicks = sub(startTimes[curIndex + 1] - newTicks, offsetTicks);
                    current.doTimePulse(localTicks);
                }
            }
        } else { // curIndex != newIndex
            if (curIndex &lt; newIndex) {
                if (current != null) {
                    final long oldDelay = add(startTimes[curIndex], delays[curIndex]);
                    if ((oldTicks &lt;= oldDelay) || ((current.getStatus() == Status.STOPPED) &amp;&amp; (oldTicks != startTimes[curIndex + 1]))) {
                        final boolean enteringCycle = oldTicks &lt;= oldDelay;
                        if (enteringCycle) {
                            current.clipEnvelope.jumpTo(0);
                        }
                        if (!startChild(current, curIndex)) {
                            if (enteringCycle) {
                                final EventHandler&lt;ActionEvent&gt; handler = current.getOnFinished();
                                if (handler != null) {
                                    handler.handle(new ActionEvent(this, null));
                                }
                            }
                        }
                    }
                    if (current.getStatus() == Status.RUNNING) {
                        current.doTimePulse(sub(durations[curIndex], offsetTicks));
                    }
                    oldTicks = startTimes[curIndex + 1];
                }
                offsetTicks = 0;
                curIndex++;
                for (; curIndex &lt; newIndex; curIndex++) {
                    final Animation animation = cachedChildren[curIndex];
                    animation.clipEnvelope.jumpTo(0);
                    if (startChild(animation, curIndex)) {
                        animation.doTimePulse(durations[curIndex]); // No need to subtract offsetTicks ( == 0)
                    } else {
                        final EventHandler&lt;ActionEvent&gt; handler = animation.getOnFinished();
                        if (handler != null) {
                            handler.handle(new ActionEvent(this, null));
                        }
                    }
                    oldTicks = startTimes[curIndex + 1];
                }
                final Animation newAnimation = cachedChildren[curIndex];
                newAnimation.clipEnvelope.jumpTo(0);
                if (startChild(newAnimation, curIndex)) {
                    if (newTicks &gt;= startTimes[curIndex+1]) {
                        newAnimation.doTimePulse(durations[curIndex]); // No need to subtract offsetTicks ( == 0)
                        if (newTicks == cycleTicks) {
                            curIndex = end;
                        }
                    } else {
                        final long localTicks = sub(newTicks, add(startTimes[curIndex], delays[curIndex]));
                        newAnimation.doTimePulse(localTicks);
                    }
                } else {
                    final EventHandler&lt;ActionEvent&gt; handler = newAnimation.getOnFinished();
                    if (handler != null) {
                        handler.handle(new ActionEvent(this, null));
                    }
                }
            } else {
                if (current != null) {
                    final long oldDelay = add(startTimes[curIndex], delays[curIndex]);
                    if ((oldTicks &gt;= startTimes[curIndex+1]) || ((oldTicks &gt; oldDelay) &amp;&amp; (current.getStatus() == Status.STOPPED))){
                        final boolean enteringCycle = oldTicks &gt;= startTimes[curIndex+1];
                        if (enteringCycle) {
                            current.clipEnvelope.jumpTo(Math.round(durations[curIndex] * rates[curIndex]));
                        }
                        if (!startChild(current, curIndex)) {
                            if (enteringCycle) {
                                final EventHandler&lt;ActionEvent&gt; handler = current.getOnFinished();
                                if (handler != null) {
                                    handler.handle(new ActionEvent(this, null));
                                }
                            }
                        }
                    }
                    if (current.getStatus() == Status.RUNNING) {
                        current.doTimePulse(sub(durations[curIndex], offsetTicks));
                    }
                    oldTicks = startTimes[curIndex];
                }
                offsetTicks = 0;
                curIndex--;
                for (; curIndex &gt; newIndex; curIndex--) {
                    final Animation animation = cachedChildren[curIndex];
                    animation.clipEnvelope.jumpTo(Math.round(durations[curIndex] * rates[curIndex]));
                    if (startChild(animation, curIndex)) {
                        animation.doTimePulse(durations[curIndex]); // No need to subtract offsetTicks ( == 0)
                    } else {
                        final EventHandler&lt;ActionEvent&gt; handler = animation.getOnFinished();
                        if (handler != null) {
                            handler.handle(new ActionEvent(this, null));
                        }
                    }
                    oldTicks = startTimes[curIndex];
                }
                final Animation newAnimation = cachedChildren[curIndex];
                newAnimation.clipEnvelope.jumpTo(Math.round(durations[curIndex] * rates[curIndex]));
                if (startChild(newAnimation, curIndex)) {
                    if (newTicks &lt;= add(startTimes[curIndex], delays[curIndex])) {
                        newAnimation.doTimePulse(durations[curIndex]); // No need to subtract offsetTicks ( == 0)
                        if (newTicks == 0) {
                            curIndex = BEFORE;
                        }
                    } else {
                        final long localTicks = sub(startTimes[curIndex + 1], newTicks);
                        newAnimation.doTimePulse(localTicks);
                    }
                } else {
                    final EventHandler&lt;ActionEvent&gt; handler = newAnimation.getOnFinished();
                    if (handler != null) {
                        handler.handle(new ActionEvent(this, null));
                    }
                }
            }
        }
        oldTicks = newTicks;
    }

    @Override void doJumpTo(long currentTicks, long cycleTicks, boolean forceJump) {
        setCurrentTicks(currentTicks);
        final Status status = getStatus();

        if (status == Status.STOPPED &amp;&amp; !forceJump) {
            return;
        }

        sync(false);
        final double frac = calculateFraction(currentTicks, cycleTicks);
        final long newTicks = Math.max(0, Math.min(getCachedInterpolator().interpolate(0, cycleTicks, frac), cycleTicks));
        final int oldIndex = curIndex;
        curIndex = findNewIndex(newTicks);
        final Animation newAnimation = cachedChildren[curIndex];
        final double currentRate = getCurrentRate();
        final long currentDelay = add(startTimes[curIndex], delays[curIndex]);
        if (curIndex != oldIndex) {
            if (status != Status.STOPPED) {
                if ((oldIndex != BEFORE) &amp;&amp; (oldIndex != end)) {
                    final Animation oldChild = cachedChildren[oldIndex];
                    if (oldChild.getStatus() != Status.STOPPED) {
                        cachedChildren[oldIndex].doStop();
                    }
                }
                if (curIndex &lt; oldIndex) {
                    for (int i = oldIndex == end ? end - 1 : oldIndex; i &gt; curIndex; --i) {
                        cachedChildren[i].doJumpTo(0, durations[i], true);
                    }
                } else { //curIndex &gt; oldIndex as curIndex != oldIndex
                    for (int i = oldIndex == BEFORE? 0 : oldIndex; i &lt; curIndex; ++i) {
                        cachedChildren[i].doJumpTo(durations[i], durations[i], true);
                    }
                }
                if (newTicks &gt;= currentDelay) {
                    startChild(newAnimation, curIndex);
                    if (status == Status.PAUSED) {
                        newAnimation.doPause();
                    }
                }
            }
        }
        if (oldIndex == curIndex) {
            if (currentRate == 0) {
                offsetTicks += (newTicks - oldTicks) * Math.signum(this.clipEnvelope.getCurrentRate());
            } else {
                offsetTicks += currentRate &gt; 0 ? newTicks - oldTicks : oldTicks - newTicks;
            }
        } else {
            if (currentRate == 0) {
                if (this.clipEnvelope.getCurrentRate() &gt; 0) {
                    offsetTicks = Math.max(0, newTicks - currentDelay);
                } else {
                    offsetTicks = startTimes[curIndex] + durations[curIndex] - newTicks;
                }
            } else {
                offsetTicks = currentRate &gt; 0 ? Math.max(0, newTicks - currentDelay) : startTimes[curIndex + 1] - newTicks;
            }
        }
        newAnimation.clipEnvelope.jumpTo(Math.round(sub(newTicks, currentDelay) * rates[curIndex]));
        oldTicks = newTicks;
    }

    private void jumpToEnd() {
        for (int i = 0 ; i &lt; end; ++i) {
            if (forceChildSync[i]) {
                cachedChildren[i].sync(true);
                //NOTE: do not clean up forceChildSync[i] here. Another sync will be needed during the play
                // The reason is we have 2 different use-cases for jumping (1)play from start, (2)play next cycle.
                // and 2 different types of sub-transitions (A)&quot;by&quot; transitions that need to synchronize on
                // the current state and move property by certain value and (B)&quot;from-to&quot; transitions that
                // move from one point to another on each play/cycle. We can't query if transition is A or B.
                //
                // Now for combination 1A we need to synchronize here, as the subsequent jump would move
                // the property to the previous value. 1B doesn't need to sync here, but it's not unsafe to
                // do it. As forceChildSync is set only in case (1) and not in case (2), the cycles are always equal.
                //
                // Now the reason why we cannot clean forceChildSync[i] here is that while we need to sync here,
                // there might be children of (A)-&quot;by&quot; type that operate on the same property, but fail to synchronize
                // them when they start would mean they all would have the same value at the beginning.
            }
            cachedChildren[i].doJumpTo(durations[i], durations[i], true);

        }
    }

    private void jumpToBefore() {
        for (int i = end - 1 ; i &gt;= 0; --i) {
            if (forceChildSync[i]) {
                cachedChildren[i].sync(true);
                //NOTE: do not clean up forceChildSync[i] here. Another sync will be needed during the play
                // See explanation in jumpToEnd
            }
            cachedChildren[i].doJumpTo(0, durations[i], true);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected void interpolate(double frac) {
        // no-op
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/Node.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene;


import com.sun.javafx.geometry.BoundsUtils;
import javafx.application.Platform;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.binding.BooleanExpression;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.BooleanPropertyBase;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyBooleanPropertyBase;
import javafx.beans.property.ReadOnlyBooleanWrapper;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectPropertyBase;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.property.StringPropertyBase;
import javafx.beans.value.ChangeListener;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener.Change;
import javafx.collections.ObservableList;
import javafx.collections.ObservableMap;
import javafx.collections.ObservableSet;
import javafx.css.CssMetaData;
import javafx.css.ParsedValue;
import javafx.css.PseudoClass;
import javafx.css.StyleConverter;
import javafx.css.Styleable;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.event.Event;
import javafx.event.EventDispatchChain;
import javafx.event.EventDispatcher;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.event.EventType;
import javafx.geometry.BoundingBox;
import javafx.geometry.Bounds;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Orientation;
import javafx.geometry.Point2D;
import javafx.geometry.Point3D;
import javafx.geometry.Rectangle2D;
import javafx.scene.effect.BlendMode;
import javafx.scene.effect.Effect;
import javafx.scene.image.WritableImage;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.DragEvent;
import javafx.scene.input.Dragboard;
import javafx.scene.input.InputEvent;
import javafx.scene.input.InputMethodEvent;
import javafx.scene.input.InputMethodRequests;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.PickResult;
import javafx.scene.input.RotateEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.input.SwipeEvent;
import javafx.scene.input.TouchEvent;
import javafx.scene.input.TransferMode;
import javafx.scene.input.ZoomEvent;
import javafx.scene.text.Font;
import javafx.scene.transform.Rotate;
import javafx.scene.transform.Transform;
import javafx.stage.Window;
import javafx.util.Callback;
import java.security.AccessControlContext;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.sun.glass.ui.Accessible;
import com.sun.glass.ui.Application;
import com.sun.javafx.util.Logging;
import com.sun.javafx.util.TempState;
import com.sun.javafx.util.Utils;
import com.sun.javafx.beans.IDProperty;
import com.sun.javafx.beans.event.AbstractNotifyListener;
import com.sun.javafx.binding.ExpressionHelper;
import com.sun.javafx.collections.TrackableObservableList;
import com.sun.javafx.collections.UnmodifiableListSet;
import com.sun.javafx.css.PseudoClassState;
import javafx.css.Selector;
import javafx.css.Style;
import javafx.css.converter.BooleanConverter;
import javafx.css.converter.CursorConverter;
import javafx.css.converter.EffectConverter;
import javafx.css.converter.EnumConverter;
import javafx.css.converter.SizeConverter;
import com.sun.javafx.effect.EffectDirtyBits;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.BoxBounds;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.javafx.perf.PerformanceTracker;
import com.sun.javafx.scene.BoundsAccessor;
import com.sun.javafx.scene.CameraHelper;
import com.sun.javafx.scene.CssFlags;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.EventHandlerProperties;
import com.sun.javafx.scene.LayoutFlags;
import com.sun.javafx.scene.NodeEventDispatcher;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.SceneHelper;
import com.sun.javafx.scene.SceneUtils;
import com.sun.javafx.scene.input.PickResultChooser;
import com.sun.javafx.scene.transform.TransformHelper;
import com.sun.javafx.scene.transform.TransformUtils;
import com.sun.javafx.scene.traversal.Direction;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.tk.Toolkit;
import com.sun.prism.impl.PrismSettings;
import com.sun.scenario.effect.EffectHelper;

import javafx.scene.shape.Shape3D;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;

/**
 * Base class for scene graph nodes. A scene graph is a set of tree data structures
 * where every item has zero or one parent, and each item is either
 * a &quot;leaf&quot; with zero sub-items or a &quot;branch&quot; with zero or more sub-items.
 * &lt;p&gt;
 * Each item in the scene graph is called a {@code Node}. Branch nodes are
 * of type {@link Parent}, whose concrete subclasses are {@link Group},
 * {@link javafx.scene.layout.Region}, and {@link javafx.scene.control.Control},
 * or subclasses thereof.
 * &lt;p&gt;
 * Leaf nodes are classes such as
 * {@link javafx.scene.shape.Rectangle}, {@link javafx.scene.text.Text},
 * {@link javafx.scene.image.ImageView}, {@link javafx.scene.media.MediaView},
 * or other such leaf classes which cannot have children. Only a single node within
 * each scene graph tree will have no parent, which is referred to as the &quot;root&quot; node.
 * &lt;p&gt;
 * There may be several trees in the scene graph. Some trees may be part of
 * a {@link Scene}, in which case they are eligible to be displayed.
 * Other trees might not be part of any {@link Scene}.
 * &lt;p&gt;
 * A node may occur at most once anywhere in the scene graph. Specifically,
 * a node must appear no more than once in all of the following:
 * as the root node of a {@link Scene},
 * the children ObservableList of a {@link Parent},
 * or as the clip of a {@link Node}.
 * &lt;p&gt;
 * The scene graph must not have cycles. A cycle would exist if a node is
 * an ancestor of itself in the tree, considering the {@link Group} content
 * ObservableList, {@link Parent} children ObservableList, and {@link Node} clip relationships
 * mentioned above.
 * &lt;p&gt;
 * If a program adds a child node to a Parent (including Group, Region, etc)
 * and that node is already a child of a different Parent or the root of a Scene,
 * the node is automatically (and silently) removed from its former parent.
 * If a program attempts to modify the scene graph in any other way that violates
 * the above rules, an exception is thrown, the modification attempt is ignored
 * and the scene graph is restored to its previous state.
 * &lt;p&gt;
 * It is possible to rearrange the structure of the scene graph, for
 * example, to move a subtree from one location in the scene graph to
 * another. In order to do this, one would normally remove the subtree from
 * its old location before inserting it at the new location. However, the
 * subtree will be automatically removed as described above if the application
 * doesn't explicitly remove it.
 * &lt;p&gt;
 * Node objects may be constructed and modified on any thread as long they are
 * not yet attached to a {@link Scene} in a {@link Window} that is
 * {@link Window#isShowing showing}.
 * An application must attach nodes to such a Scene or modify them on the JavaFX
 * Application Thread.
 *
 * &lt;p&gt;
 * The JavaFX Application Thread is created as part of the startup process for
 * the JavaFX runtime. See the {@link javafx.application.Application} class and
 * the {@link Platform#startup(Runnable)} method for more information.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * An application should not extend the Node class directly. Doing so may lead to
 * an UnsupportedOperationException being thrown.
 * &lt;/p&gt;
 *
 * &lt;h3&gt;String ID&lt;/h3&gt;
 * &lt;p&gt;
 * Each node in the scene graph can be given a unique {@link #idProperty id}. This id is
 * much like the &quot;id&quot; attribute of an HTML tag in that it is up to the designer
 * and developer to ensure that the {@code id} is unique within the scene graph.
 * A convenience function called {@link #lookup(String)} can be used to find
 * a node with a unique id within the scene graph, or within a subtree of the
 * scene graph. The id can also be used identify nodes for applying styles; see
 * the CSS section below.
 *
 * &lt;h3&gt;Coordinate System&lt;/h3&gt;
 * &lt;p&gt;
 * The {@code Node} class defines a traditional computer graphics &quot;local&quot;
 * coordinate system in which the {@code x} axis increases to the right and the
 * {@code y} axis increases downwards.  The concrete node classes for shapes
 * provide variables for defining the geometry and location of the shape
 * within this local coordinate space.  For example,
 * {@link javafx.scene.shape.Rectangle} provides {@code x}, {@code y},
 * {@code width}, {@code height} variables while
 * {@link javafx.scene.shape.Circle} provides {@code centerX}, {@code centerY},
 * and {@code radius}.
 * &lt;p&gt;
 * At the device pixel level, integer coordinates map onto the corners and
 * cracks between the pixels and the centers of the pixels appear at the
 * midpoints between integer pixel locations.  Because all coordinate values
 * are specified with floating point numbers, coordinates can precisely
 * point to these corners (when the floating point values have exact integer
 * values) or to any location on the pixel.  For example, a coordinate of
 * {@code (0.5, 0.5)} would point to the center of the upper left pixel on the
 * {@code Stage}.  Similarly, a rectangle at {@code (0, 0)} with dimensions
 * of {@code 10} by {@code 10} would span from the upper left corner of the
 * upper left pixel on the {@code Stage} to the lower right corner of the
 * 10th pixel on the 10th scanline.  The pixel center of the last pixel
 * inside that rectangle would be at the coordinates {@code (9.5, 9.5)}.
 * &lt;p&gt;
 * In practice, most nodes have transformations applied to their coordinate
 * system as mentioned below.  As a result, the information above describing
 * the alignment of device coordinates to the pixel grid is relative to
 * the transformed coordinates, not the local coordinates of the nodes.
 * The {@link javafx.scene.shape.Shape Shape} class describes some additional
 * important context-specific information about coordinate mapping and how
 * it can affect rendering.
 *
 * &lt;h3&gt;Transformations&lt;/h3&gt;
 * &lt;p&gt;
 * Any {@code Node} can have transformations applied to it. These include
 * translation, rotation, scaling, or shearing.
 * &lt;p&gt;
 * A &lt;b&gt;translation&lt;/b&gt; transformation is one which shifts the origin of the
 * node's coordinate space along either the x or y axis. For example, if you
 * create a {@link javafx.scene.shape.Rectangle} which is drawn at the origin
 * (x=0, y=0) and has a width of 100 and a height of 50, and then apply a
 * {@link javafx.scene.transform.Translate} with a shift of 10 along the x axis
 * (x=10), then the rectangle will appear drawn at (x=10, y=0) and remain
 * 100 points wide and 50 tall. Note that the origin was shifted, not the
 * {@code x} variable of the rectangle.
 * &lt;p&gt;
 * A common node transform is a translation by an integer distance, most often
 * used to lay out nodes on the stage.  Such integer translations maintain the
 * device pixel mapping so that local coordinates that are integers still
 * map to the cracks between pixels.
 * &lt;p&gt;
 * A &lt;b&gt;rotation&lt;/b&gt; transformation is one which rotates the coordinate space of
 * the node about a specified &quot;pivot&quot; point, causing the node to appear rotated.
 * For example, if you create a {@link javafx.scene.shape.Rectangle} which is
 * drawn at the origin (x=0, y=0) and has a width of 100 and height of 30 and
 * you apply a {@link javafx.scene.transform.Rotate} with a 90 degree rotation
 * (angle=90) and a pivot at the origin (pivotX=0, pivotY=0), then
 * the rectangle will be drawn as if its x and y were zero but its height was
 * 100 and its width -30. That is, it is as if a pin is being stuck at the top
 * left corner and the rectangle is rotating 90 degrees clockwise around that
 * pin. If the pivot point is instead placed in the center of the rectangle
 * (at point x=50, y=15) then the rectangle will instead appear to rotate about
 * its center.
 * &lt;p&gt;
 * Note that as with all transformations, the x, y, width, and height variables
 * of the rectangle (which remain relative to the local coordinate space) have
 * not changed, but rather the transformation alters the entire coordinate space
 * of the rectangle.
 * &lt;p&gt;
 * A &lt;b&gt;scaling&lt;/b&gt; transformation causes a node to either appear larger or
 * smaller depending on the scaling factor. Scaling alters the coordinate space
 * of the node such that each unit of distance along the axis in local
 * coordinates is multiplied by the scale factor. As with rotation
 * transformations, scaling transformations are applied about a &quot;pivot&quot; point.
 * You can think of this as the point in the Node around which you &quot;zoom&quot;.  For
 * example, if you create a {@link javafx.scene.shape.Rectangle} with a
 * {@code strokeWidth} of 5, and a width and height of 50, and you apply a
 * {@link javafx.scene.transform.Scale} with scale factors (x=2.0, y=2.0) and
 * a pivot at the origin (pivotX=0, pivotY=0), the entire rectangle
 * (including the stroke) will double in size, growing to the right and
 * downwards from the origin.
 * &lt;p&gt;
 * A &lt;b&gt;shearing&lt;/b&gt; transformation, sometimes called a skew, effectively
 * rotates one axis so that the x and y axes are no longer perpendicular.
 * &lt;p&gt;
 * Multiple transformations may be applied to a node by specifying an ordered
 * chain of transforms.  The order in which the transforms are applied is
 * defined by the ObservableList specified in the {@link #getTransforms transforms} variable.
 *
 * &lt;h3&gt;Bounding Rectangles&lt;/h3&gt;
 * &lt;p&gt;
 * Since every {@code Node} has transformations, every Node's geometric
 * bounding rectangle can be described differently depending on whether
 * transformations are accounted for or not.
 * &lt;p&gt;
 * Each {@code Node} has a read-only {@link #boundsInLocalProperty boundsInLocal}
 * variable which specifies the bounding rectangle of the {@code Node} in
 * untransformed local coordinates. {@code boundsInLocal} includes the
 * Node's shape geometry, including any space required for a
 * non-zero stroke that may fall outside the local position/size variables,
 * and its {@link #clipProperty clip} and {@link #effectProperty effect} variables.
 * &lt;p&gt;
 * Each {@code Node} also has a read-only {@link #boundsInParentProperty boundsInParent} variable which
 * specifies the bounding rectangle of the {@code Node} after all transformations
 * have been applied, including those set in {@link #getTransforms transforms},
 * {@link #scaleXProperty scaleX}/{@link #scaleYProperty scaleY}, {@link #rotateProperty rotate},
 * {@link #translateXProperty translateX}/{@link #translateYProperty translateY}, and {@link #layoutXProperty layoutX}/{@link #layoutYProperty layoutY}.
 * It is called &quot;boundsInParent&quot; because the rectangle will be relative to the
 * parent's coordinate system.  This is the 'visual' bounds of the node.
 * &lt;p&gt;
 * Finally, the {@link #layoutBoundsProperty layoutBounds} variable defines the rectangular bounds of
 * the {@code Node} that should be used as the basis for layout calculations and
 * may differ from the visual bounds of the node.  For shapes, Text, and ImageView,
 * layoutBounds by default includes only the shape geometry, including space required
 * for a non-zero {@code strokeWidth}, but does &lt;i&gt;not&lt;/i&gt; include the effect,
 * clip, or any transforms. For resizable classes (Regions and Controls)
 * layoutBounds will always map to {@code 0,0 width x height}.
 *
 * &lt;p&gt; The image shows a node without any transformation and its {@code boundsInLocal}:
 * &lt;p&gt; &lt;img src=&quot;doc-files/boundsLocal.png&quot; alt=&quot;A sine wave shape enclosed by
 * an axis-aligned rectangular bounds&quot;&gt; &lt;/p&gt;
 * If we rotate the image by 20 degrees we get following result:
 * &lt;p&gt; &lt;img src=&quot;doc-files/boundsParent.png&quot; alt=&quot;An axis-aligned rectangular
 * bounds that encloses the shape rotated by 20 degrees&quot;&gt; &lt;/p&gt;
 * The red rectangle represents {@code boundsInParent} in the
 * coordinate space of the Node's parent. The {@code boundsInLocal} stays the same
 * as in the first image, the green rectangle in this image represents {@code boundsInLocal}
 * in the coordinate space of the Node.
 *
 * &lt;p&gt; The images show a filled and stroked rectangle and their bounds. The
 * first rectangle {@code [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:0]}
 * has the following bounds bounds: {@code [x:10.0 y:10.0 width:100.0 height:100.0]}.
 *
 * The second rectangle {@code [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:5]}
 * has the following bounds: {@code [x:7.5 y:7.5 width:105 height:105]}
 * (the stroke is centered by default, so only half of it is outside
 * of the original bounds; it is also possible to create inside or outside
 * stroke).
 *
 * Since neither of the rectangles has any transformation applied,
 * {@code boundsInParent} and {@code boundsInLocal} are the same. &lt;/p&gt;
 * &lt;p&gt; &lt;img src=&quot;doc-files/bounds.png&quot; alt=&quot;The rectangles are enclosed by their
 * respective bounds&quot;&gt; &lt;/p&gt;
 *
 *
 * &lt;h3&gt;CSS&lt;/h3&gt;
 * &lt;p&gt;
 * The {@code Node} class contains {@code id}, {@code styleClass}, and
 * {@code style} variables that are used in styling this node from
 * CSS. The {@code id} and {@code styleClass} variables are used in
 * CSS style sheets to identify nodes to which styles should be
 * applied. The {@code style} variable contains style properties and
 * values that are applied directly to this node.
 * &lt;p&gt;
 * For further information about CSS and how to apply CSS styles
 * to nodes, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
 * Guide&lt;/a&gt;.
 * @since JavaFX 2.0
 */
@IDProperty(&quot;id&quot;)
public abstract class Node implements EventTarget, Styleable {

    /*
     * Store the singleton instance of the NodeHelper subclass corresponding
     * to the subclass of this instance of Node
     */
    private NodeHelper nodeHelper = null;

    static {
        PerformanceTracker.logEvent(&quot;Node class loaded&quot;);

        // This is used by classes in different packages to get access to
        // private and package private methods.
        NodeHelper.setNodeAccessor(new NodeHelper.NodeAccessor() {
            @Override
            public NodeHelper getHelper(Node node) {
                return node.nodeHelper;
            }

            @Override
            public void setHelper(Node node, NodeHelper nodeHelper) {
                node.nodeHelper = nodeHelper;
            }

            @Override
            public void doMarkDirty(Node node, DirtyBits dirtyBit) {
                node.doMarkDirty(dirtyBit);
            }

            @Override
            public void doUpdatePeer(Node node) {
                node.doUpdatePeer();
            }

            @Override
            public BaseTransform getLeafTransform(Node node) {
                return node.getLeafTransform();
            }

            @Override
            public Bounds doComputeLayoutBounds(Node node) {
                return node.doComputeLayoutBounds();
            }

            @Override
            public void doTransformsChanged(Node node) {
                node.doTransformsChanged();
            }

            @Override
            public void doPickNodeLocal(Node node, PickRay localPickRay,
                    PickResultChooser result) {
                node.doPickNodeLocal(localPickRay, result);
            }

            @Override
            public boolean doComputeIntersects(Node node, PickRay pickRay,
                    PickResultChooser pickResult) {
                return node.doComputeIntersects(pickRay, pickResult);
            }

            @Override
            public void doGeomChanged(Node node) {
                node.doGeomChanged();
            }

            @Override
            public void doNotifyLayoutBoundsChanged(Node node) {
                node.doNotifyLayoutBoundsChanged();
            }

            @Override
            public void doProcessCSS(Node node) {
                node.doProcessCSS();
            }

            @Override
            public boolean isDirty(Node node, DirtyBits dirtyBit) {
                return node.isDirty(dirtyBit);
            }

            @Override
            public boolean isDirtyEmpty(Node node) {
                return node.isDirtyEmpty();
            }

            @Override
            public void syncPeer(Node node) {
                node.syncPeer();
            }

            @Override
            public void layoutBoundsChanged(Node node) {
                node.layoutBoundsChanged();
            }

            @Override
            public &lt;P extends NGNode&gt; P getPeer(Node node) {
                return node.getPeer();
            }

            @Override
            public void setShowMnemonics(Node node, boolean value) {
                node.setShowMnemonics(value);
            }

            @Override
            public boolean isShowMnemonics(Node node) {
                return node.isShowMnemonics();
            }

            @Override
            public BooleanProperty showMnemonicsProperty(Node node) {
                return node.showMnemonicsProperty();
            }

            @Override
            public boolean traverse(Node node, Direction direction) {
                return node.traverse(direction);
            }

            @Override
            public double getPivotX(Node node) {
                return node.getPivotX();
            }

            @Override
            public double getPivotY(Node node) {
                return node.getPivotY();
            }

            @Override
            public double getPivotZ(Node node) {
                return node.getPivotZ();
            }

            @Override
            public void pickNode(Node node,PickRay pickRay,
                    PickResultChooser result) {
                node.pickNode(pickRay, result);
            }

            @Override
            public boolean intersects(Node node, PickRay pickRay,
                    PickResultChooser pickResult) {
                return node.intersects(pickRay, pickResult);
            }

            @Override
            public double intersectsBounds(Node node, PickRay pickRay) {
                return node.intersectsBounds(pickRay);
            }

            @Override
            public void layoutNodeForPrinting(Node node) {
                node.doCSSLayoutSyncForSnapshot();
            }

            @Override
            public boolean isDerivedDepthTest(Node node) {
                return node.isDerivedDepthTest();
            }

            @Override
            public SubScene getSubScene(Node node) {
                return node.getSubScene();
            }

            @Override
            public void setLabeledBy(Node node, Node labeledBy) {
                node.labeledBy = labeledBy;
            }

            @Override
            public Accessible getAccessible(Node node) {
                return node.getAccessible();
            }

            @Override
            public void reapplyCSS(Node node) {
                node.reapplyCSS();
            }

            @Override
            public boolean isTreeVisible(Node node) {
                return node.isTreeVisible();
            }

            @Override
            public BooleanExpression treeVisibleProperty(Node node) {
                return node.treeVisibleProperty();
            }

            @Override
            public boolean isTreeShowing(Node node) {
                return node.isTreeShowing();
            }

            @Override
            public BooleanExpression treeShowingProperty(Node node) {
                return node.treeShowingProperty();
            }

            @Override
            public List&lt;Style&gt; getMatchingStyles(CssMetaData cssMetaData,
                    Styleable styleable) {
                return Node.getMatchingStyles(cssMetaData, styleable);
            }

            @Override
            public Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; findStyles(Node node,
                    Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; styleMap) {
                return node.findStyles(styleMap);
            }
        });
    }

    /**************************************************************************
     *                                                                        *
     * Methods and state for managing the dirty bits of a Node. The dirty     *
     * bits are flags used to keep track of what things are dirty on the      *
     * node and therefore need processing on the next pulse. Since the pulse  *
     * happens asynchronously to the change that made the node dirty (for     *
     * performance reasons), we need to keep track of what things have        *
     * changed.                                                               *
     *                                                                        *
     *************************************************************************/

    /*
     * Set of dirty bits that are set when state is invalidated and cleared by
     * the updateState method, which is called from the synchronizer.
     */
    private int dirtyBits;

    /*
     * Mark the specified bit as dirty, and add this node to the scene's dirty list.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doMarkDirty(DirtyBits dirtyBit) {
        if (isDirtyEmpty()) {
            addToSceneDirtyList();
        }

        dirtyBits |= dirtyBit.getMask();
    }

    private void addToSceneDirtyList() {
        Scene s = getScene();
        if (s != null) {
            s.addToDirtyList(this);
            if (getSubScene() != null) {
                getSubScene().setDirty(this);
            }
        }
    }

    /*
     * Test whether the specified dirty bit is set
     */
    final boolean isDirty(DirtyBits dirtyBit) {
        return (dirtyBits &amp; dirtyBit.getMask()) != 0;
    }

    /*
     * Clear the specified dirty bit
     */
    final void clearDirty(DirtyBits dirtyBit) {
        dirtyBits &amp;= ~dirtyBit.getMask();
    }

    /*
     * Set all dirty bits
     */
    private void setDirty() {
        dirtyBits = ~0;
    }

    /*
     * Clear all dirty bits
     */
    private void clearDirty() {
        dirtyBits = 0;
    }

    /*
     * Test whether the set of dirty bits is empty
     */
    final boolean isDirtyEmpty() {
        return dirtyBits == 0;
    }

    /**************************************************************************
     *                                                                        *
     * Methods for synchronizing state from this Node to its PG peer. This    *
     * should only *ever* be called during synchronization initialized as a   *
     * result of a pulse. Any attempt to synchronize at any other time may    *
     * cause rendering artifacts.                                             *
     *                                                                        *
     *************************************************************************/

    /*
     * Called by the synchronizer to update the state and
     * clear dirtybits of this node in the PG graph
     */
    final void syncPeer() {
        // Do not synchronize invisible nodes unless their visibility has changed
        // or they have requested a forced synchronization
        if (!isDirtyEmpty() &amp;&amp; (treeVisible
                                     || isDirty(DirtyBits.NODE_VISIBLE)
                                     || isDirty(DirtyBits.NODE_FORCE_SYNC)))
        {
            NodeHelper.updatePeer(this);
            clearDirty();
        }
    }

    /**
     * A temporary rect used for computing bounds by the various bounds
     * variables. This bounds starts life as a RectBounds, but may be promoted
     * to a BoxBounds if there is a 3D transform mixed into its computation.
     * These two fields were held in a thread local, but were then pulled
     * out of it so that we could compute bounds before holding the
     * synchronization lock. These objects have to be per-instance so
     * that we can pass the right data down to the PG side later during
     * synchronization (rather than statics as they were before).
     */
    private BaseBounds _geomBounds = new RectBounds(0, 0, -1, -1);
    private BaseBounds _txBounds = new RectBounds(0, 0, -1, -1);

    private boolean pendingUpdateBounds = false;

    // Happens before we hold the sync lock
    void updateBounds() {
        // Note: the clip must be handled before the visibility is checked. This is because the visiblity might be
        // changing in the clip and it is going to be synchronized, so it needs to recompute the bounds.
        Node n = getClip();
        if (n != null) {
            n.updateBounds();
        }

        // See syncPeer()
        if (!treeVisible &amp;&amp; !isDirty(DirtyBits.NODE_VISIBLE)) {

            // Need to save the dirty bits since they will be cleared even for the
            // case of short circuiting dirty bit processing.
            if (isDirty(DirtyBits.NODE_TRANSFORM)
                    || isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)
                    || isDirty(DirtyBits.NODE_BOUNDS)) {
                pendingUpdateBounds = true;
            }

            return;
        }

        // Set transform and bounds dirty bits when this node becomes visible
        if (pendingUpdateBounds) {
            NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORM);
            NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORMED_BOUNDS);
            NodeHelper.markDirty(this, DirtyBits.NODE_BOUNDS);

            pendingUpdateBounds = false;
        }

        if (isDirty(DirtyBits.NODE_TRANSFORM) || isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)) {
            if (isDirty(DirtyBits.NODE_TRANSFORM)) {
                updateLocalToParentTransform();
            }
            _txBounds = getTransformedBounds(_txBounds,
                                             BaseTransform.IDENTITY_TRANSFORM);
        }

        if (isDirty(DirtyBits.NODE_BOUNDS)) {
            _geomBounds = getGeomBounds(_geomBounds,
                    BaseTransform.IDENTITY_TRANSFORM);
        }

    }

    /*
     * This function is called during synchronization to update the state of the
     * NG Node from the FX Node. Subclasses of Node should override this method
     * and must call NodeHelper.updatePeer(this)
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        final NGNode peer = getPeer();

        // For debug / diagnostic purposes, we will copy across a name for this node down to
        // the NG layer, where we can use the name to figure out what the NGNode represents.
        // An alternative would be to have a back-reference from the NGNode back to the Node it
        // is a peer to, however it was felt that this would make it too easy to communicate back
        // to the Node and possibly violate thread invariants. But of course, we only need to do this
        // if we're going to print the render graph (otherwise all the work we'd do to keep the name
        // properly updated would be a waste).
        if (PrismSettings.printRenderGraph &amp;&amp; isDirty(DirtyBits.DEBUG)) {
            final String id = getId();
            String className = getClass().getSimpleName();
            if (className.isEmpty()) {
                className = getClass().getName();
            }
            peer.setName(id == null ? className : id + &quot;(&quot; + className + &quot;)&quot;);
        }

        if (isDirty(DirtyBits.NODE_TRANSFORM)) {
            peer.setTransformMatrix(localToParentTx);
        }

        if (isDirty(DirtyBits.NODE_VIEW_ORDER)) {
            peer.setViewOrder(getViewOrder());
        }

        if (isDirty(DirtyBits.NODE_BOUNDS)) {
            peer.setContentBounds(_geomBounds);
        }

        if (isDirty(DirtyBits.NODE_TRANSFORMED_BOUNDS)) {
            peer.setTransformedBounds(_txBounds, !isDirty(DirtyBits.NODE_BOUNDS));
        }

        if (isDirty(DirtyBits.NODE_OPACITY)) {
            peer.setOpacity((float)Utils.clamp(0, getOpacity(), 1));
        }

        if (isDirty(DirtyBits.NODE_CACHE)) {
            peer.setCachedAsBitmap(isCache(), getCacheHint());
        }

        if (isDirty(DirtyBits.NODE_CLIP)) {
            peer.setClipNode(getClip() != null ? getClip().getPeer() : null);
        }

        if (isDirty(DirtyBits.EFFECT_EFFECT)) {
            if (getEffect() != null) {
                EffectHelper.sync(getEffect());
                peer.effectChanged();
            }
        }

        if (isDirty(DirtyBits.NODE_EFFECT)) {
            peer.setEffect(getEffect() != null ? EffectHelper.getPeer(getEffect()) : null);
        }

        if (isDirty(DirtyBits.NODE_VISIBLE)) {
            peer.setVisible(isVisible());
        }

        if (isDirty(DirtyBits.NODE_DEPTH_TEST)) {
            peer.setDepthTest(isDerivedDepthTest());
        }

        if (isDirty(DirtyBits.NODE_BLENDMODE)) {
            BlendMode mode = getBlendMode();
            peer.setNodeBlendMode((mode == null)
                                  ? null
                                  : EffectHelper.getToolkitBlendMode(mode));
        }
    }

    /*************************************************************************
    *                                                                        *
    *                                                                        *
    *                                                                        *
    *************************************************************************/

    private static final Object USER_DATA_KEY = new Object();
    // A map containing a set of properties for this node
    private ObservableMap&lt;Object, Object&gt; properties;

    /**
      * Returns an observable map of properties on this node for use primarily
      * by application developers.
      *
      * @return an observable map of properties on this node for use primarily
      * by application developers
      */
     public final ObservableMap&lt;Object, Object&gt; getProperties() {
        if (properties == null) {
            properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
        }
        return properties;
    }

    /**
     * Tests if Node has properties.
     * @return true if node has properties.
     */
     public boolean hasProperties() {
        return properties != null &amp;&amp; !properties.isEmpty();
    }

    /**
     * Convenience method for setting a single Object property that can be
     * retrieved at a later date. This is functionally equivalent to calling
     * the getProperties().put(Object key, Object value) method. This can later
     * be retrieved by calling {@link Node#getUserData()}.
     *
     * @param value The value to be stored - this can later be retrieved by calling
     *          {@link Node#getUserData()}.
     */
    public void setUserData(Object value) {
        getProperties().put(USER_DATA_KEY, value);
    }

    /**
     * Returns a previously set Object property, or null if no such property
     * has been set using the {@link Node#setUserData(java.lang.Object)} method.
     *
     * @return The Object that was previously set, or null if no property
     *          has been set or if null was set.
     */
    public Object getUserData() {
        return getProperties().get(USER_DATA_KEY);
    }

    /**************************************************************************
     *                                                                        *
     *
     *                                                                        *
     *************************************************************************/

    /**
     * The parent of this {@code Node}. If this {@code Node} has not been added
     * to a scene graph, then parent will be null.
     *
     * @defaultValue null
     */
    private ReadOnlyObjectWrapper&lt;Parent&gt; parent;

    final void setParent(Parent value) {
        parentPropertyImpl().set(value);
    }

    public final Parent getParent() {
        return parent == null ? null : parent.get();
    }

    public final ReadOnlyObjectProperty&lt;Parent&gt; parentProperty() {
        return parentPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyObjectWrapper&lt;Parent&gt; parentPropertyImpl() {
        if (parent == null) {
            parent = new ReadOnlyObjectWrapper&lt;Parent&gt;() {
                private Parent oldParent;

                @Override
                protected void invalidated() {
                    if (oldParent != null) {
                        oldParent.disabledProperty().removeListener(parentDisabledChangedListener);
                        oldParent.treeVisibleProperty().removeListener(parentTreeVisibleChangedListener);
                        if (nodeTransformation != null &amp;&amp; nodeTransformation.listenerReasons &gt; 0) {
                            ((Node) oldParent).localToSceneTransformProperty().removeListener(
                                    nodeTransformation.getLocalToSceneInvalidationListener());
                        }
                    }
                    updateDisabled();
                    computeDerivedDepthTest();
                    final Parent newParent = get();
                    if (newParent != null) {
                        newParent.disabledProperty().addListener(parentDisabledChangedListener);
                        newParent.treeVisibleProperty().addListener(parentTreeVisibleChangedListener);
                        if (nodeTransformation != null &amp;&amp; nodeTransformation.listenerReasons &gt; 0) {
                            ((Node) newParent).localToSceneTransformProperty().addListener(
                                    nodeTransformation.getLocalToSceneInvalidationListener());
                        }
                        //
                        // if parent changed, then CSS needs to be reapplied so
                        // that this node will get the right styles. This used
                        // to be done from Parent.children's onChanged method.
                        // See the comments there, also.
                        //
                        reapplyCSS();
                    } else {
                        // RT-31168: reset CssFlag to clean so css will be reapplied if the node is added back later.
                        // If flag is REAPPLY, then reapplyCSS() will just return and the call to
                        // notifyParentsOfInvalidatedCSS() will be skipped thus leaving the node un-styled.
                        cssFlag = CssFlags.CLEAN;
                    }
                    updateTreeVisible(true);
                    oldParent = newParent;
                    invalidateLocalToSceneTransform();
                    parentResolvedOrientationInvalidated();
                    notifyAccessibleAttributeChanged(AccessibleAttribute.PARENT);
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;parent&quot;;
                }
            };
        }
        return parent;
    }

    private final InvalidationListener parentDisabledChangedListener = valueModel -&gt; updateDisabled();

    private final InvalidationListener parentTreeVisibleChangedListener = valueModel -&gt; updateTreeVisible(true);

    private final ChangeListener&lt;Boolean&gt; windowShowingChangedListener
            = (win, oldVal, newVal) -&gt; updateTreeShowing();

    private final ChangeListener&lt;Window&gt; sceneWindowChangedListener = (scene, oldWindow, newWindow) -&gt; {
        // Replace the windowShowingListener and call updateTreeShowing()
        if (oldWindow != null) {
            oldWindow.showingProperty().removeListener(windowShowingChangedListener);
        }
        if (newWindow != null) {
            newWindow.showingProperty().addListener(windowShowingChangedListener);
        }
        updateTreeShowing();
    };

    private SubScene subScene = null;

    /**
     * The {@link Scene} that this {@code Node} is part of. If the Node is not
     * part of a scene, then this variable will be null.
     *
     * @defaultValue null
     */
    private ReadOnlyObjectWrapperManualFire&lt;Scene&gt; scene = new ReadOnlyObjectWrapperManualFire&lt;Scene&gt;();

    private class ReadOnlyObjectWrapperManualFire&lt;T&gt; extends ReadOnlyObjectWrapper&lt;T&gt; {
        @Override
        public Object getBean() {
            return Node.this;
        }

        @Override
        public String getName() {
            return &quot;scene&quot;;
        }

        @Override
        protected void fireValueChangedEvent() {
            /*
             * Note: This method has been intentionally made into a no-op. In
             * order to override the default set behavior. By default calling
             * set(...) on a different scene will trigger:
             * - invalidated();
             * - fireValueChangedEvent();
             * Both of the above are no-ops, but are handled manually via
             * - Node.this.setScenes(...)
             * - Node.this.invalidatedScenes(...)
             * - forceValueChangedEvent()
             */
        }

        public void fireSuperValueChangedEvent() {
            super.fireValueChangedEvent();
        }
    }

    private void invalidatedScenes(Scene oldScene, SubScene oldSubScene) {
        Scene newScene = sceneProperty().get();
        boolean sceneChanged = oldScene != newScene;
        SubScene newSubScene = subScene;

        if (getClip() != null) {
            getClip().setScenes(newScene, newSubScene);
        }
        if (sceneChanged) {
            updateCanReceiveFocus();
            if (isFocusTraversable()) {
                if (newScene != null) {
                    newScene.initializeInternalEventDispatcher();
                }
            }
            focusSetDirty(oldScene);
            focusSetDirty(newScene);
        }
        scenesChanged(newScene, newSubScene, oldScene, oldSubScene);

        // isTreeShowing needs to take into account of Window's showing
        if (oldScene != null) {
            oldScene.windowProperty().removeListener(sceneWindowChangedListener);
        }
        if (newScene != null) {
            newScene.windowProperty().addListener(sceneWindowChangedListener);
        }
        updateTreeShowing();

        if (sceneChanged) reapplyCSS();

        if (sceneChanged &amp;&amp; !isDirtyEmpty()) {
            //Note: no need to remove from scene's dirty list
            //Scene's is checking if the node's scene is correct
            /* TODO: looks like an existing bug when a node is moved from one
             * location to another, setScenes will be called twice by
             * Parent.VetoableListDecorator onProposedChange and onChanged
             * respectively. Removing the node and setting setScense(null,null)
             * then adding it back to potentially the same scene. Causing the
             * same node to being added twice to the same scene.
             */
            addToSceneDirtyList();
        }

        if (newScene == null &amp;&amp; peer != null) {
            peer.release();
        }

        if (oldScene != null) {
            oldScene.clearNodeMnemonics(this);
        }
        if (getParent() == null) {
            // if we are the root we need to handle scene change
            parentResolvedOrientationInvalidated();
        }

        if (sceneChanged) { scene.fireSuperValueChangedEvent(); }

        /* Dispose the accessible peer, if any. If AT ever needs this node again
         * a new accessible peer is created. */
        if (accessible != null) {
            /* Generally accessibility does not retain any state, therefore deleting objects
             * generally does not cause problems (AT just asks everything back).
             * The exception to this rule is when the object sends a notifications to the AT,
             * in which case it is expected to be around to answer request for the new values.
             * It is possible that a object is reparented (within the scene) in the middle of
             * this process. For example, when a tree item is expanded, the notification is
             * sent to the AT by the cell. But when the TreeView relayouts the cell can be
             * reparented before AT can query the relevant information about the expand event.
             * If the accessible was disposed, AT can't properly report the event.
             *
             * The fix is to defer the disposal of the accessible to the next pulse.
             * If at that time the node is placed back to the scene, then the accessible is hooked
             * to Node and AT requests are processed. Otherwise the accessible is disposed.
             */
            if (oldScene != null &amp;&amp; oldScene != newScene &amp;&amp; newScene == null) {
                // Strictly speaking we need some type of accessible.thaw() at this point.
                oldScene.addAccessible(Node.this, accessible);
            } else {
                accessible.dispose();
            }
            /* Always set to null to ensure this accessible is never on more than one
             * Scene#accMap at the same time (At lest not with the same accessible).
             */
            accessible = null;
        }
    }

    final void setScenes(Scene newScene, SubScene newSubScene) {
        Scene oldScene = sceneProperty().get();
        if (newScene != oldScene || newSubScene != subScene) {
            scene.set(newScene);
            SubScene oldSubScene = subScene;
            subScene = newSubScene;
            invalidatedScenes(oldScene, oldSubScene);
            if (this instanceof SubScene) { // TODO: find better solution
                SubScene thisSubScene = (SubScene)this;
                thisSubScene.getRoot().setScenes(newScene, thisSubScene);
            }
        }
    }

    final SubScene getSubScene() {
        return subScene;
    }

    public final Scene getScene() {
        return scene.get();
    }

    public final ReadOnlyObjectProperty&lt;Scene&gt; sceneProperty() {
        return scene.getReadOnlyProperty();
    }

    /**
     * Exists for Parent and LightBase
     */
    void scenesChanged(final Scene newScene, final SubScene newSubScene,
                       final Scene oldScene, final SubScene oldSubScene) { }


    /**
     * The id of this {@code Node}. This simple string identifier is useful for
     * finding a specific Node within the scene graph. While the id of a Node
     * should be unique within the scene graph, this uniqueness is not enforced.
     * This is analogous to the &quot;id&quot; attribute on an HTML element
     * (&lt;a href=&quot;http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier&quot;&gt;CSS ID Specification&lt;/a&gt;).
     * &lt;p&gt;
     *     For example, if a Node is given the id of &quot;myId&quot;, then the lookup method can
     *     be used to find this node as follows: &lt;code&gt;scene.lookup(&quot;#myId&quot;);&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @defaultValue null
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     */
    private StringProperty id;

    public final void setId(String value) {
        idProperty().set(value);
    }

    //TODO: this is copied from the property in order to add the @return statement.
    //      We should have a better, general solution without the need to copy it.
    /**
     * The id of this {@code Node}. This simple string identifier is useful for
     * finding a specific Node within the scene graph. While the id of a Node
     * should be unique within the scene graph, this uniqueness is not enforced.
     * This is analogous to the &quot;id&quot; attribute on an HTML element
     * (&lt;a href=&quot;http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier&quot;&gt;CSS ID Specification&lt;/a&gt;).
     *
     * @return the id assigned to this {@code Node} using the {@code setId}
     *         method or {@code null}, if no id has been assigned.
     * @defaultValue null
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
     */
    public final String getId() {
        return id == null ? null : id.get();
    }

    public final StringProperty idProperty() {
        if (id == null) {
            id = new StringPropertyBase() {

                @Override
                protected void invalidated() {
                    reapplyCSS();
                    if (PrismSettings.printRenderGraph) {
                        NodeHelper.markDirty(Node.this, DirtyBits.DEBUG);
                    }
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;id&quot;;
                }
            };
        }
        return id;
    }

    /**
     * A list of String identifiers which can be used to logically group
     * Nodes, specifically for an external style engine. This variable is
     * analogous to the &quot;class&quot; attribute on an HTML element and, as such,
     * each element of the list is a style class to which this Node belongs.
     *
     * @see &lt;a href=&quot;http://www.w3.org/TR/css3-selectors/#class-html&quot;&gt;CSS3 class selectors&lt;/a&gt;
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     * @defaultValue null
     */
    private ObservableList&lt;String&gt; styleClass = new TrackableObservableList&lt;String&gt;() {
        @Override
        protected void onChanged(Change&lt;String&gt; c) {
            reapplyCSS();
        }

        @Override
        public String toString() {
            if (size() == 0) {
                return &quot;&quot;;
            } else if (size() == 1) {
                return get(0);
            } else {
                StringBuilder buf = new StringBuilder();
                for (int i = 0; i &lt; size(); i++) {
                    buf.append(get(i));
                    if (i + 1 &lt; size()) {
                        buf.append(' ');
                    }
                }
                return buf.toString();
            }
        }
    };

    @Override
    public final ObservableList&lt;String&gt; getStyleClass() {
        return styleClass;
    }

    /**
     * A string representation of the CSS style associated with this
     * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
     * HTML element. Note that, like the HTML style attribute, this
     * variable contains style properties and values and not the
     * selector portion of a style rule.
     * @defaultValue empty string
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     */
    private StringProperty style;

    /**
     * A string representation of the CSS style associated with this
     * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
     * HTML element. Note that, like the HTML style attribute, this
     * variable contains style properties and values and not the
     * selector portion of a style rule.
     * @param value The inline CSS style to use for this {@code Node}.
     *         {@code null} is implicitly converted to an empty String.
     * @defaultValue empty string
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
     */
    public final void setStyle(String value) {
        styleProperty().set(value);
    }

    // TODO: javadoc copied from property for the sole purpose of providing a return tag
    /**
     * A string representation of the CSS style associated with this
     * specific {@code Node}. This is analogous to the &quot;style&quot; attribute of an
     * HTML element. Note that, like the HTML style attribute, this
     * variable contains style properties and values and not the
     * selector portion of a style rule.
     * @defaultValue empty string
     * @return The inline CSS style associated with this {@code Node}.
     *         If this {@code Node} does not have an inline style,
     *         an empty String is returned.
     * @see &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;
     */
    public final String getStyle() {
        return style == null ? &quot;&quot; : style.get();
    }

    public final StringProperty styleProperty() {
        if (style == null) {
            style = new StringPropertyBase(&quot;&quot;) {

                @Override public void set(String value) {
                    // getStyle returns an empty string if the style property
                    // is null. To be consistent, getStyle should also return
                    // an empty string when the style property's value is null.
                    super.set((value != null) ? value : &quot;&quot;);
                }

                @Override
                protected void invalidated() {
                    // If the style has changed, then styles of this node
                    // and child nodes might be affected.
                    reapplyCSS();
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;style&quot;;
                }
            };
        }
        return style;
    }

    /**
     * Specifies whether this {@code Node} and any subnodes should be rendered
     * as part of the scene graph. A node may be visible and yet not be shown
     * in the rendered scene if, for instance, it is off the screen or obscured
     * by another Node. Invisible nodes never receive mouse events or
     * keyboard focus and never maintain keyboard focus when they become
     * invisible.
     *
     * @defaultValue true
     */
    private BooleanProperty visible;

    public final void setVisible(boolean value) {
        visibleProperty().set(value);
    }

    public final boolean isVisible() {
        return visible == null ? true : visible.get();
    }

    public final BooleanProperty visibleProperty() {
        if (visible == null) {
            visible = new StyleableBooleanProperty(true) {
                boolean oldValue = true;
                @Override
                protected void invalidated() {
                    if (oldValue != get()) {
                        NodeHelper.markDirty(Node.this, DirtyBits.NODE_VISIBLE);
                        NodeHelper.geomChanged(Node.this);
                        updateTreeVisible(false);
                        if (getParent() != null) {
                            // notify the parent of the potential change in visibility
                            // of this node, since visibility affects bounds of the
                            // parent node
                            getParent().childVisibilityChanged(Node.this);
                        }
                        oldValue = get();
                    }
                }

                @Override
                public CssMetaData getCssMetaData() {
                    return StyleableProperties.VISIBILITY;
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;visible&quot;;
                }
            };
        }
        return visible;
    }

    public final void setCursor(Cursor value) {
        cursorProperty().set(value);
    }

    public final Cursor getCursor() {
        return (miscProperties == null) ? DEFAULT_CURSOR
                                        : miscProperties.getCursor();
    }

    /**
     * Defines the mouse cursor for this {@code Node} and subnodes. If null,
     * then the cursor of the first parent node with a non-null cursor will be
     * used. If no Node in the scene graph defines a cursor, then the cursor
     * of the {@code Scene} will be used.
     *
     * @return the mouse cursor for this {@code Node} and subnodes
     * @defaultValue null
     */
    public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
        return getMiscProperties().cursorProperty();
    }

    /**
     * Specifies how opaque (that is, solid) the {@code Node} appears. A Node
     * with 0% opacity is fully translucent. That is, while it is still
     * {@link #visibleProperty visible} and rendered, you generally won't be able to see it. The
     * exception to this rule is when the {@code Node} is combined with a
     * blending mode and blend effect in which case a translucent Node may still
     * have an impact in rendering. An opacity of 50% will render the node as
     * being 50% transparent.
     * &lt;p&gt;
     * A {@link #visibleProperty visible} node with any opacity setting still receives mouse
     * events and can receive keyboard focus. For example, if you want to have
     * a large invisible rectangle overlay all {@code Node}s in the scene graph
     * in order to intercept mouse events but not be visible to the user, you could
     * create a large {@code Rectangle} that had an opacity of 0%.
     * &lt;p&gt;
     * Opacity is specified as a value between 0 and 1. Values less than 0 are
     * treated as 0, values greater than 1 are treated as 1.
     * &lt;p&gt;
     * On some platforms ImageView might not support opacity variable.
     *
     * &lt;p&gt;
     * There is a known limitation of mixing opacity &amp;lt; 1.0 with a 3D Transform.
     * Opacity/Blending is essentially a 2D image operation. The result of
     * an opacity &amp;lt; 1.0 set on a {@link Group} node with 3D transformed children
     * will cause its children to be rendered in order without Z-buffering
     * applied between those children.
     *
     * @defaultValue 1.0
     */
    private DoubleProperty opacity;

    public final void setOpacity(double value) {
        opacityProperty().set(value);
    }
    public final double getOpacity() {
        return opacity == null ? 1 : opacity.get();
    }

    public final DoubleProperty opacityProperty() {
        if (opacity == null) {
            opacity = new StyleableDoubleProperty(1) {

                @Override
                public void invalidated() {
                    NodeHelper.markDirty(Node.this, DirtyBits.NODE_OPACITY);
                }

                @Override
                public CssMetaData getCssMetaData() {
                    return StyleableProperties.OPACITY;
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;opacity&quot;;
                }
            };
        }
        return opacity;
    }

    /**
     * The {@link javafx.scene.effect.BlendMode} used to blend this individual node
     * into the scene behind it. If this node happens to be a Group then all of the
     * children will be composited individually into a temporary buffer using their
     * own blend modes and then that temporary buffer will be composited into the
     * scene using the specified blend mode.
     *
     * A value of {@code null} is treated as pass-though this means no effect on a
     * parent such as a Group and the equivalent of SRC_OVER for a single Node.
     *
     * @defaultValue null
     */
    private javafx.beans.property.ObjectProperty&lt;BlendMode&gt; blendMode;

    public final void setBlendMode(BlendMode value) {
        blendModeProperty().set(value);
    }
    public final BlendMode getBlendMode() {
        return blendMode == null ? null : blendMode.get();
    }

    public final ObjectProperty&lt;BlendMode&gt; blendModeProperty() {
        if (blendMode == null) {
            blendMode = new StyleableObjectProperty&lt;BlendMode&gt;(null) {
                @Override public void invalidated() {
                    NodeHelper.markDirty(Node.this, DirtyBits.NODE_BLENDMODE);
                }

                @Override
                public CssMetaData getCssMetaData() {
                    return StyleableProperties.BLEND_MODE;
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;blendMode&quot;;
                }
            };
        }
        return blendMode;
    }

    public final void setClip(Node value) {
        clipProperty().set(value);
    }

    public final Node getClip() {
        return (miscProperties == null) ? DEFAULT_CLIP
                                        : miscProperties.getClip();
    }

    /**
     * Specifies a {@code Node} to use to define the the clipping shape for this
     * Node. This clipping Node is not a child of this {@code Node} in the scene
     * graph sense. Rather, it is used to define the clip for this {@code Node}.
     * &lt;p&gt;
     * For example, you can use an {@link javafx.scene.image.ImageView} Node as
     * a mask to represent the Clip. Or you could use one of the geometric shape
     * Nodes such as {@link javafx.scene.shape.Rectangle} or
     * {@link javafx.scene.shape.Circle}. Or you could use a
     * {@link javafx.scene.text.Text} node to represent the Clip.
     * &lt;p&gt;
     * See the class documentation for {@link Node} for scene graph structure
     * restrictions on setting the clip. If these restrictions are violated by
     * a change to the clip variable, the change is ignored and the
     * previous value of the clip variable is restored.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SHAPE_CLIP ConditionalFeature.SHAPE_CLIP}
     * for more information.
     * &lt;p&gt;
     * There is a known limitation of mixing Clip with a 3D Transform.
     * Clipping is essentially a 2D image operation. The result of
     * a Clip set on a {@link Group} node with 3D transformed children
     * will cause its children to be rendered in order without Z-buffering
     * applied between those children.
     *
     * @return the the clipping shape for this {@code Node}
     * @defaultValue null
     */
    public final ObjectProperty&lt;Node&gt; clipProperty() {
        return getMiscProperties().clipProperty();
    }

    public final void setCache(boolean value) {
        cacheProperty().set(value);
    }

    public final boolean isCache() {
        return (miscProperties == null) ? DEFAULT_CACHE
                                        : miscProperties.isCache();
    }

    /**
     * A performance hint to the system to indicate that this {@code Node}
     * should be cached as a bitmap. Rendering a bitmap representation of a node
     * will be faster than rendering primitives in many cases, especially in the
     * case of primitives with effects applied (such as a blur). However, it
     * also increases memory usage. This hint indicates whether that trade-off
     * (increased memory usage for increased performance) is worthwhile. Also
     * note that on some platforms such as GPU accelerated platforms there is
     * little benefit to caching Nodes as bitmaps when blurs and other effects
     * are used since they are very fast to render on the GPU.
     *
     * The {@link #cacheHintProperty} variable provides additional options for enabling
     * more aggressive bitmap caching.
     *
     * &lt;p&gt;
     * Caching may be disabled for any node that has a 3D transform on itself,
     * any of its ancestors, or any of its descendants.
     *
     * @return the hint to cache for this {@code Node}
     * @see #cacheHintProperty
     * @defaultValue false
     */
    public final BooleanProperty cacheProperty() {
        return getMiscProperties().cacheProperty();
    }

    public final void setCacheHint(CacheHint value) {
        cacheHintProperty().set(value);
    }

    public final CacheHint getCacheHint() {
        return (miscProperties == null) ? DEFAULT_CACHE_HINT
                                        : miscProperties.getCacheHint();
    }

    /**
     * Additional hint for controlling bitmap caching.
     * &lt;p&gt;
     * Under certain circumstances, such as animating nodes that are very
     * expensive to render, it is desirable to be able to perform
     * transformations on the node without having to regenerate the cached
     * bitmap.  An option in such cases is to perform the transforms on the
     * cached bitmap itself.
     * &lt;p&gt;
     * This technique can provide a dramatic improvement to animation
     * performance, though may also result in a reduction in visual quality.
     * The {@code cacheHint} variable provides a hint to the system about how
     * and when that trade-off (visual quality for animation performance) is
     * acceptable.
     * &lt;p&gt;
     * It is possible to enable the cacheHint only at times when your node is
     * animating.  In this way, expensive nodes can appear on screen with full
     * visual quality, yet still animate smoothly.
     * &lt;p&gt;
     * Example:
     * &lt;pre&gt;{@code
        expensiveNode.setCache(true);
        expensiveNode.setCacheHint(CacheHint.QUALITY);
        ...
        // Do an animation
        expensiveNode.setCacheHint(CacheHint.SPEED);
        new Timeline(
            new KeyFrame(Duration.seconds(2),
                new KeyValue(expensiveNode.scaleXProperty(), 2.0),
                new KeyValue(expensiveNode.scaleYProperty(), 2.0),
                new KeyValue(expensiveNode.rotateProperty(), 360),
                new KeyValue(expensiveNode.cacheHintProperty(), CacheHint.QUALITY)
            )
        ).play();
     }&lt;/pre&gt;
     *
     * Note that {@code cacheHint} is only a hint to the system.  Depending on
     * the details of the node or the transform, this hint may be ignored.
     *
     * &lt;p&gt;
     * If {@code Node.cache} is false, cacheHint is ignored.
     * Caching may be disabled for any node that has a 3D transform on itself,
     * any of its ancestors, or any of its descendants.
     *
     * @return the {@code CacheHint} for this {@code Node}
     * @see #cacheProperty
     * @defaultValue CacheHint.DEFAULT
     */
    public final ObjectProperty&lt;CacheHint&gt; cacheHintProperty() {
        return getMiscProperties().cacheHintProperty();
    }

    public final void setEffect(Effect value) {
        effectProperty().set(value);
    }

    public final Effect getEffect() {
        return (miscProperties == null) ? DEFAULT_EFFECT
                                        : miscProperties.getEffect();
    }

    /**
     * Specifies an effect to apply to this {@code Node}.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#EFFECT ConditionalFeature.EFFECT}
     * for more information.
     *
     * &lt;p&gt;
     * There is a known limitation of mixing Effect with a 3D Transform. Effect is
     * essentially a 2D image operation. The result of an Effect set on
     * a {@link Group} node with 3D transformed children will cause its children
     * to be rendered in order without Z-buffering applied between those
     * children.
     *
     * @return the effect for this {@code Node}
     * @defaultValue null
     */
    public final ObjectProperty&lt;Effect&gt; effectProperty() {
        return getMiscProperties().effectProperty();
    }

    public final void setDepthTest(DepthTest value) {
        depthTestProperty().set(value);
    }

    public final DepthTest getDepthTest() {
        return (miscProperties == null) ? DEFAULT_DEPTH_TEST
                                        : miscProperties.getDepthTest();
    }

    /**
     * Indicates whether depth testing is used when rendering this node.
     * If the depthTest flag is {@code DepthTest.DISABLE}, then depth testing
     * is disabled for this node.
     * If the depthTest flag is {@code DepthTest.ENABLE}, then depth testing
     * is enabled for this node.
     * If the depthTest flag is {@code DepthTest.INHERIT}, then depth testing
     * is enabled for this node if it is enabled for the parent node or the
     * parent node is null.
     * &lt;p&gt;
     * The depthTest flag is only used when the depthBuffer flag for
     * the {@link Scene} is true (meaning that the
     * {@link Scene} has an associated depth buffer)
     * &lt;p&gt;
     * Depth test comparison is only done among nodes with depthTest enabled.
     * A node with depthTest disabled does not read, test, or write the depth buffer,
     * that is to say its Z value will not be considered for depth testing
     * with other nodes.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     * &lt;p&gt;
     * See the constructor in Scene with depthBuffer as one of its input
     * arguments.
     *
     * @return the depth test setting for this {@code Node}
     * @see javafx.scene.Scene
     * @defaultValue INHERIT
     */
    public final ObjectProperty&lt;DepthTest&gt; depthTestProperty() {
        return getMiscProperties().depthTestProperty();
    }

    /**
     * Recompute the derived depth test flag. This flag is true
     * if the depthTest flag for this node is true and the
     * depth test flag for each ancestor node is true. It is false
     * otherwise. Equivalently, the derived depth flag is true
     * if the depthTest flag for this node is true and the derivedDepthTest
     * flag for its parent is true.
     */
    void computeDerivedDepthTest() {
        boolean newDDT;
        if (getDepthTest() == DepthTest.INHERIT) {
            if (getParent() != null) {
                newDDT = getParent().isDerivedDepthTest();
            } else {
                newDDT = true;
            }
        } else if (getDepthTest() == DepthTest.ENABLE) {
            newDDT = true;
        } else {
            newDDT = false;
        }

        if (isDerivedDepthTest() != newDDT) {
            NodeHelper.markDirty(this, DirtyBits.NODE_DEPTH_TEST);
            setDerivedDepthTest(newDDT);
        }
    }

    // This is the derived depthTest value to pass to PG level
    private boolean derivedDepthTest = true;

    void setDerivedDepthTest(boolean value) {
        derivedDepthTest = value;
    }

    boolean isDerivedDepthTest() {
        return derivedDepthTest;
    }

    public final void setDisable(boolean value) {
        disableProperty().set(value);
    }

    public final boolean isDisable() {
        return (miscProperties == null) ? DEFAULT_DISABLE
                                        : miscProperties.isDisable();
    }

    /**
     * Defines the individual disabled state of this {@code Node}. Setting
     * {@code disable} to true will cause this {@code Node} and any subnodes to
     * become disabled. This property should be used only to set the disabled
     * state of a {@code Node}.  For querying the disabled state of a
     * {@code Node}, the {@link #disabledProperty disabled} property should instead be used,
     * since it is possible that a {@code Node} was disabled as a result of an
     * ancestor being disabled even if the individual {@code disable} state on
     * this {@code Node} is {@code false}.
     *
     * @return the disabled state for this {@code Node}
     * @defaultValue false
     */
    public final BooleanProperty disableProperty() {
        return getMiscProperties().disableProperty();
    }


//    /**
//     * TODO document - null by default, could be non-null in subclasses (e.g. Control)
//     */
//    public final ObjectProperty&lt;InputMap&lt;?&gt;&gt; inputMapProperty() {
//        if (inputMap == null) {
//            inputMap = new SimpleObjectProperty&lt;InputMap&lt;?&gt;&gt;(this, &quot;inputMap&quot;) {
//                private InputMap&lt;?&gt; currentMap = get();
//                @Override protected void invalidated() {
//                    if (currentMap != null) {
//                        currentMap.dispose();
//                    }
//                    currentMap = get();
//                }
//            };
//        }
//        return inputMap;
//    }
//    public final void setInputMap(InputMap&lt;?&gt; value) { inputMapProperty().set(value); }
//    public final InputMap&lt;?&gt; getInputMap() { return inputMapProperty().getValue(); }
//    private ObjectProperty&lt;InputMap&lt;?&gt;&gt; inputMap;


    /**************************************************************************
     *                                                                        *
     *
     *                                                                        *
     *************************************************************************/
    /**
     * Defines how the picking computation is done for this node when
     * triggered by a {@code MouseEvent} or a {@code contains} function call.
     *
     * If {@code pickOnBounds} is {@code true}, then picking is computed by
     * intersecting with the bounds of this node, else picking is computed
     * by intersecting with the geometric shape of this node.
     *
     * The default value of this property is {@code false} unless
     * overridden by a subclass. The default value is {@code true}
     * for {@link javafx.scene.layout.Region}.
     *
     * @defaultValue false; true for {@code Region}
     */
    private BooleanProperty pickOnBounds;

    public final void setPickOnBounds(boolean value) {
        pickOnBoundsProperty().set(value);
    }

    public final boolean isPickOnBounds() {
        return pickOnBounds == null ? false : pickOnBounds.get();
    }

    public final BooleanProperty pickOnBoundsProperty() {
        if (pickOnBounds == null) {
            pickOnBounds = new SimpleBooleanProperty(this, &quot;pickOnBounds&quot;);
        }
        return pickOnBounds;
    }

    /**
     * Indicates whether or not this {@code Node} is disabled.  A {@code Node}
     * will become disabled if {@link #disableProperty disable} is set to {@code true} on either
     * itself or one of its ancestors in the scene graph.
     * &lt;p&gt;
     * A disabled {@code Node} should render itself differently to indicate its
     * disabled state to the user.
     * Such disabled rendering is dependent on the implementation of the
     * {@code Node}. The shape classes contained in {@code javafx.scene.shape}
     * do not implement such rendering by default, therefore applications using
     * shapes for handling input must implement appropriate disabled rendering
     * themselves. The user-interface controls defined in
     * {@code javafx.scene.control} will implement disabled-sensitive rendering,
     * however.
     * &lt;p&gt;
     * A disabled {@code Node} does not receive mouse or key events.
     *
     * @defaultValue false
     */
    private ReadOnlyBooleanWrapper disabled;

    protected final void setDisabled(boolean value) {
        disabledPropertyImpl().set(value);
    }

    public final boolean isDisabled() {
        return disabled == null ? false : disabled.get();
    }

    public final ReadOnlyBooleanProperty disabledProperty() {
        return disabledPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyBooleanWrapper disabledPropertyImpl() {
        if (disabled == null) {
            disabled = new ReadOnlyBooleanWrapper() {

                @Override
                protected void invalidated() {
                    pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, get());
                    updateCanReceiveFocus();
                    focusSetDirty(getScene());
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;disabled&quot;;
                }
            };
        }
        return disabled;
    }

    private void updateDisabled() {
        boolean isDisabled = isDisable();
        if (!isDisabled) {
            isDisabled = getParent() != null ? getParent().isDisabled() :
                    getSubScene() != null &amp;&amp; getSubScene().isDisabled();
        }
        setDisabled(isDisabled);
        if (this instanceof SubScene) {
            ((SubScene)this).getRoot().setDisabled(isDisabled);
        }
    }

    /**
     * Finds this {@code Node}, or the first sub-node, based on the given CSS selector.
     * If this node is a {@code Parent}, then this function will traverse down
     * into the branch until it finds a match. If more than one sub-node matches the
     * specified selector, this function returns the first of them.
     * &lt;p&gt;
     *     For example, if a Node is given the id of &quot;myId&quot;, then the lookup method can
     *     be used to find this node as follows: &lt;code&gt;scene.lookup(&quot;#myId&quot;);&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param selector The css selector of the node to find
     * @return The first node, starting from this {@code Node}, which matches
     *         the CSS {@code selector}, null if none is found.
     */
    public Node lookup(String selector) {
        if (selector == null) return null;
        Selector s = Selector.createSelector(selector);
        return s != null &amp;&amp; s.applies(this) ? this : null;
    }

    /**
     * Finds all {@code Node}s, including this one and any children, which match
     * the given CSS selector. If no matches are found, an empty unmodifiable set is
     * returned. The set is explicitly unordered.
     *
     * @param selector The css selector of the nodes to find
     * @return All nodes, starting from and including this {@code Node}, which match
     *         the CSS {@code selector}. The returned set is always unordered and
     *         unmodifiable, and never null.
     */
    public Set&lt;Node&gt; lookupAll(String selector) {
        final Selector s = Selector.createSelector(selector);
        final Set&lt;Node&gt; empty = Collections.emptySet();
        if (s == null) return empty;
        List&lt;Node&gt; results = lookupAll(s, null);
        return results == null ? empty : new UnmodifiableListSet&lt;Node&gt;(results);
    }

    /**
     * Used by Node and Parent for traversing the tree and adding all nodes which
     * match the given selector.
     *
     * @param selector The Selector. This will never be null.
     * @param results The results. This will never be null.
     */
    List&lt;Node&gt; lookupAll(Selector selector, List&lt;Node&gt; results) {
        if (selector.applies(this)) {
            // Lazily create the set to reduce some trash.
            if (results == null) {
                results = new LinkedList&lt;Node&gt;();
            }
            results.add(this);
        }
        return results;
    }

    /**
     * Moves this {@code Node} to the back of its sibling nodes in terms of
     * z-order.  This is accomplished by moving this {@code Node} to the
     * first position in its parent's {@code content} ObservableList.
     * This function has no effect if this {@code Node} is not part of a group.
     */
    public void toBack() {
        if (getParent() != null) {
            getParent().toBack(this);
        }
    }

    /**
     * Moves this {@code Node} to the front of its sibling nodes in terms of
     * z-order.  This is accomplished by moving this {@code Node} to the
     * last position in its parent's {@code content} ObservableList.
     * This function has no effect if this {@code Node} is not part of a group.
     */
    public void toFront() {
        if (getParent() != null) {
            getParent().toFront(this);
        }
    }

    // TODO: need to verify whether this is OK to do starting from a node in
    // the scene graph other than the root.
    private void doCSSPass() {
        if (this.cssFlag != CssFlags.CLEAN) {
            // The dirty bit isn't checked but we must ensure it is cleared.
            // The cssFlag is set to clean in either Node.processCSS or
            // NodeHelper.processCSS

            // Don't clear the dirty bit in case it will cause problems
            // with a full CSS pass on the scene.
            // TODO: is this the right thing to do?
            // this.clearDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);

            this.processCSS();
        }
    }

    /**
     * Recursive function for synchronizing a node and all descendents
     */
    private static void syncAll(Node node) {
        node.syncPeer();
        if (node instanceof Parent) {
            Parent p = (Parent) node;
            final int childrenCount = p.getChildren().size();

            for (int i = 0; i &lt; childrenCount; i++) {
                Node n = p.getChildren().get(i);
                if (n != null) {
                    syncAll(n);
                }
            }
        }
        if (node.getClip() != null) {
            syncAll(node.getClip());
        }
    }

    private void doLayoutPass() {
        if (this instanceof Parent) {
            // TODO: As an optimization we only need to layout those dirty
            // roots that are descendants of this node
            Parent p = (Parent)this;
            for (int i = 0; i &lt; 3; i++) {
                p.layout();
            }
        }
    }

    private void doCSSLayoutSyncForSnapshot() {
        doCSSPass();
        doLayoutPass();
        updateBounds();
        Scene.setAllowPGAccess(true);
        syncAll(this);
        Scene.setAllowPGAccess(false);
    }

    private WritableImage doSnapshot(SnapshotParameters params, WritableImage img) {
        if (getScene() != null) {
            getScene().doCSSLayoutSyncForSnapshot(this);
        } else {
            doCSSLayoutSyncForSnapshot();
        }

        BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;
        if (params.getTransform() != null) {
            Affine3D tempTx = new Affine3D();
            TransformHelper.apply(params.getTransform(), tempTx);
            transform = tempTx;
        }
        double x;
        double y;
        double w;
        double h;
        Rectangle2D viewport = params.getViewport();
        if (viewport != null) {
            // Use the specified viewport
            x = viewport.getMinX();
            y = viewport.getMinY();
            w = viewport.getWidth();
            h = viewport.getHeight();
        } else {
            // Get the bounds in parent of this node, transformed by the
            // specified transform.
            BaseBounds tempBounds = TempState.getInstance().bounds;
            tempBounds = getTransformedBounds(tempBounds, transform);
            x = tempBounds.getMinX();
            y = tempBounds.getMinY();
            w = tempBounds.getWidth();
            h = tempBounds.getHeight();
        }
        WritableImage result = Scene.doSnapshot(getScene(), x, y, w, h,
                this, transform, params.isDepthBufferInternal(),
                params.getFill(), params.getEffectiveCamera(), img);

        return result;
    }

    /**
     * Takes a snapshot of this node and returns the rendered image when
     * it is ready.
     * CSS and layout processing will be done for the node, and any of its
     * children, prior to rendering it.
     * The entire destination image is cleared to the fill {@code Paint}
     * specified by the SnapshotParameters. This node is then rendered to
     * the image.
     * If the viewport specified by the SnapshotParameters is null, the
     * upper-left pixel of the {@code boundsInParent} of this
     * node, after first applying the transform specified by the
     * SnapshotParameters,
     * is mapped to the upper-left pixel (0,0) in the image.
     * If a non-null viewport is specified,
     * the upper-left pixel of the viewport is mapped to upper-left pixel
     * (0,0) in the image.
     * In both cases, this mapping to (0,0) of the image is done with an integer
     * translation. The portion of the node that is outside of the rendered
     * image will be clipped by the image.
     *
     * &lt;p&gt;
     * When taking a snapshot of a scene that is being animated, either
     * explicitly by the application or implicitly (such as chart animation),
     * the snapshot will be rendered based on the state of the scene graph at
     * the moment the snapshot is taken and will not reflect any subsequent
     * animation changes.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * NOTE: In order for CSS and layout to function correctly, the node
     * must be part of a Scene (the Scene may be attached to a Stage, but need
     * not be).
     * &lt;/p&gt;
     *
     * @param params the snapshot parameters containing attributes that
     * will control the rendering. If the SnapshotParameters object is null,
     * then the Scene's attributes will be used if this node is part of a scene,
     * or default attributes will be used if this node is not part of a scene.
     *
     * @param image the writable image that will be used to hold the rendered node.
     * It may be null in which case a new WritableImage will be constructed.
     * The new image is constructed using integer width and
     * height values that are derived either from the transformed bounds of this
     * Node or from the size of the viewport as specified in the
     * SnapShotParameters. These integer values are chosen such that the image
     * will wholly contain the bounds of this Node or the specified viewport.
     * If the image is non-null, the node will be rendered into the
     * existing image.
     * In this case, the width and height of the image determine the area
     * that is rendered instead of the width and height of the bounds or
     * viewport.
     *
     * @throws IllegalStateException if this method is called on a thread
     *     other than the JavaFX Application Thread.
     *
     * @return the rendered image
     * @since JavaFX 2.2
     */
    public WritableImage snapshot(SnapshotParameters params, WritableImage image) {
        Toolkit.getToolkit().checkFxUserThread();

        if (params == null) {
            params = new SnapshotParameters();
            Scene s = getScene();
            if (s != null) {
                params.setCamera(s.getEffectiveCamera());
                params.setDepthBuffer(s.isDepthBufferInternal());
                params.setFill(s.getFill());
            }
        }

        return doSnapshot(params, image);
    }

    /**
     * Takes a snapshot of this node at the next frame and calls the
     * specified callback method when the image is ready.
     * CSS and layout processing will be done for the node, and any of its
     * children, prior to rendering it.
     * The entire destination image is cleared to the fill {@code Paint}
     * specified by the SnapshotParameters. This node is then rendered to
     * the image.
     * If the viewport specified by the SnapshotParameters is null, the
     * upper-left pixel of the {@code boundsInParent} of this
     * node, after first applying the transform specified by the
     * SnapshotParameters,
     * is mapped to the upper-left pixel (0,0) in the image.
     * If a non-null viewport is specified,
     * the upper-left pixel of the viewport is mapped to upper-left pixel
     * (0,0) in the image.
     * In both cases, this mapping to (0,0) of the image is done with an integer
     * translation. The portion of the node that is outside of the rendered
     * image will be clipped by the image.
     *
     * &lt;p&gt;
     * This is an asynchronous call, which means that other
     * events or animation might be processed before the node is rendered.
     * If any such events modify the node, or any of its children, that
     * modification will be reflected in the rendered image (just like it
     * will also be reflected in the frame rendered to the Stage, if this node
     * is part of a live scene graph).
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * When taking a snapshot of a node that is being animated, either
     * explicitly by the application or implicitly (such as chart animation),
     * the snapshot will be rendered based on the state of the scene graph at
     * the moment the snapshot is taken and will not reflect any subsequent
     * animation changes.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * NOTE: In order for CSS and layout to function correctly, the node
     * must be part of a Scene (the Scene may be attached to a Stage, but need
     * not be).
     * &lt;/p&gt;
     *
     * @param callback a class whose call method will be called when the image
     * is ready. The SnapshotResult that is passed into the call method of
     * the callback will contain the rendered image, the source node
     * that was rendered, and a copy of the SnapshotParameters.
     * The callback parameter must not be null.
     *
     * @param params the snapshot parameters containing attributes that
     * will control the rendering. If the SnapshotParameters object is null,
     * then the Scene's attributes will be used if this node is part of a scene,
     * or default attributes will be used if this node is not part of a scene.
     *
     * @param image the writable image that will be used to hold the rendered node.
     * It may be null in which case a new WritableImage will be constructed.
     * The new image is constructed using integer width and
     * height values that are derived either from the transformed bounds of this
     * Node or from the size of the viewport as specified in the
     * SnapShotParameters. These integer values are chosen such that the image
     * will wholly contain the bounds of this Node or the specified viewport.
     * If the image is non-null, the node will be rendered into the
     * existing image.
     * In this case, the width and height of the image determine the area
     * that is rendered instead of the width and height of the bounds or
     * viewport.
     *
     * @throws IllegalStateException if this method is called on a thread
     *     other than the JavaFX Application Thread.
     *
     * @throws NullPointerException if the callback parameter is null.
     * @since JavaFX 2.2
     */
    public void snapshot(Callback&lt;SnapshotResult, Void&gt; callback,
            SnapshotParameters params, WritableImage image) {

        Toolkit.getToolkit().checkFxUserThread();
        if (callback == null) {
            throw new NullPointerException(&quot;The callback must not be null&quot;);
        }

        if (params == null) {
            params = new SnapshotParameters();
            Scene s = getScene();
            if (s != null) {
                params.setCamera(s.getEffectiveCamera());
                params.setDepthBuffer(s.isDepthBufferInternal());
                params.setFill(s.getFill());
            }
        } else {
            params = params.copy();
        }

        final SnapshotParameters theParams = params;
        final Callback&lt;SnapshotResult, Void&gt; theCallback = callback;
        final WritableImage theImage = image;

        // Create a deferred runnable that will be run from a pulse listener
        // that is called after all of the scenes have been synced but before
        // any of them have been rendered.
        final Runnable snapshotRunnable = () -&gt; {
            WritableImage img = doSnapshot(theParams, theImage);
            SnapshotResult result = new SnapshotResult(img, Node.this, theParams);
//                System.err.println(&quot;Calling snapshot callback&quot;);
            try {
                Void v = theCallback.call(result);
            } catch (Throwable th) {
                System.err.println(&quot;Exception in snapshot callback&quot;);
                th.printStackTrace(System.err);
            }
        };

//        System.err.println(&quot;Schedule a snapshot in the future&quot;);
        Scene.addSnapshotRunnable(snapshotRunnable);
    }

    /* ************************************************************************
     *                                                                        *
     *
     *                                                                        *
     *************************************************************************/

    public final void setOnDragEntered(
            EventHandler&lt;? super DragEvent&gt; value) {
        onDragEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragEntered() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragEntered();
    }

    /**
     * Defines a function to be called when drag gesture
     * enters this {@code Node}.
     * @return the event handler that is called when drag gesture enters this
     * {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
            onDragEnteredProperty() {
        return getEventHandlerProperties().onDragEnteredProperty();
    }

    public final void setOnDragExited(
            EventHandler&lt;? super DragEvent&gt; value) {
        onDragExitedProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragExited() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragExited();
    }

    /**
     * Defines a function to be called when drag gesture
     * exits this {@code Node}.
     * @return the event handler that is called when drag gesture exits this
     * {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
            onDragExitedProperty() {
        return getEventHandlerProperties().onDragExitedProperty();
    }

    public final void setOnDragOver(
            EventHandler&lt;? super DragEvent&gt; value) {
        onDragOverProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragOver() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragOver();
    }

    /**
     * Defines a function to be called when drag gesture progresses within
     * this {@code Node}.
     * @return the event handler that is called when drag gesture progresses
     * within this {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
            onDragOverProperty() {
        return getEventHandlerProperties().onDragOverProperty();
    }

    // Do we want DRAG_TRANSFER_MODE_CHANGED event?
//    public final void setOnDragTransferModeChanged(
//            EventHandler&lt;? super DragEvent&gt; value) {
//        onDragTransferModeChangedProperty().set(value);
//    }
//
//    public final EventHandler&lt;? super DragEvent&gt; getOnDragTransferModeChanged() {
//        return (eventHandlerProperties == null)
//                ? null : eventHandlerProperties.getOnDragTransferModeChanged();
//    }
//
//    /**
//     * Defines a function to be called this {@code Node} if it is a potential
//     * drag-and-drop target when the user takes action to change the intended
//     * {@code TransferMode}.
//     * The user can change the intended {@link TransferMode} by holding down
//     * or releasing key modifiers.
//     */
//    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
//            onDragTransferModeChangedProperty() {
//        return getEventHandlerProperties().onDragTransferModeChangedProperty();
//    }

    public final void setOnDragDropped(
            EventHandler&lt;? super DragEvent&gt; value) {
        onDragDroppedProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragDropped() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragDropped();
    }

    /**
     * Defines a function to be called when the mouse button is released
     * on this {@code Node} during drag and drop gesture. Transfer of data from
     * the {@link DragEvent}'s {@link DragEvent#getDragboard() dragboard} should
     * happen in this function.
     * @return the event handler that is called when the mouse button is
     * released on this {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
            onDragDroppedProperty() {
        return getEventHandlerProperties().onDragDroppedProperty();
    }

    public final void setOnDragDone(
            EventHandler&lt;? super DragEvent&gt; value) {
        onDragDoneProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragDone() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragDone();
    }

    /**
     * Defines a function to be called when this {@code Node} is a
     * drag and drop gesture source after its data has
     * been dropped on a drop target. The {@code transferMode} of the
     * event shows what just happened at the drop target.
     * If {@code transferMode} has the value {@code MOVE}, then the source can
     * clear out its data. Clearing the source's data gives the appropriate
     * appearance to a user that the data has been moved by the drag and drop
     * gesture. A {@code transferMode} that has the value {@code NONE}
     * indicates that no data was transferred during the drag and drop gesture.
     * @return the event handler that is called when this {@code Node} is a drag
     * and drop gesture source after its data has been dropped on a drop target
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;
            onDragDoneProperty() {
        return getEventHandlerProperties().onDragDoneProperty();
    }

    /**
     * Confirms a potential drag and drop gesture that is recognized over this
     * {@code Node}.
     * Can be called only from a DRAG_DETECTED event handler. The returned
     * {@link Dragboard} is used to transfer data during
     * the drag and drop gesture. Placing this {@code Node}'s data on the
     * {@link Dragboard} also identifies this {@code Node} as the source of
     * the drag and drop gesture.
     * More detail about drag and drop gestures is described in the overivew
     * of {@link DragEvent}.
     *
     * @see DragEvent
     * @param transferModes The supported {@code TransferMode}(s) of this {@code Node}
     * @return A {@code Dragboard} to place this {@code Node}'s data on
     * @throws IllegalStateException if drag and drop cannot be started at this
     * moment (it's called outside of {@code DRAG_DETECTED} event handling or
     * this node is not in scene).
     */
    public Dragboard startDragAndDrop(TransferMode... transferModes) {
        if (getScene() != null) {
            return getScene().startDragAndDrop(this, transferModes);
        }

        throw new IllegalStateException(&quot;Cannot start drag and drop on node &quot;
                + &quot;that is not in scene&quot;);
    }

    /**
     * Starts a full press-drag-release gesture with this node as gesture
     * source. This method can be called only from a {@code DRAG_DETECTED} mouse
     * event handler. More detail about dragging gestures can be found
     * in the overview of {@link MouseEvent} and {@link MouseDragEvent}.
     *
     * @see MouseEvent
     * @see MouseDragEvent
     * @throws IllegalStateException if the full press-drag-release gesture
     * cannot be started at this moment (it's called outside of
     * {@code DRAG_DETECTED} event handling or this node is not in scene).
     * @since JavaFX 2.1
     */
    public void startFullDrag() {
        if (getScene() != null) {
            getScene().startFullDrag(this);
            return;
        }

        throw new IllegalStateException(&quot;Cannot start full drag on node &quot;
                + &quot;that is not in scene&quot;);
    }

    ////////////////////////////
    //  Private Implementation
    ////////////////////////////

    /**
     * If this Node is being used as the clip of another Node, that other node
     * is referred to as the clipParent. If the boundsInParent of this Node
     * changes, it must update the clipParent's bounds as well.
     */
    private Node clipParent;
    // Use a getter function instead of giving clipParent package access,
    // so that clipParent doesn't get turned into a Location.
    final Node getClipParent() {
        return clipParent;
    }

    /**
     * Determines whether this node is connected anywhere in the scene graph.
     */
    boolean isConnected() {
        // don't need to check scene, because if scene is non-null
        // parent must also be non-null
        return getParent() != null || clipParent != null;
    }

    /**
     * Tests whether creating a parent-child relationship between these
     * nodes would cause a cycle. The parent relationship includes not only
     * the &quot;real&quot; parent (child of Group) but also the clipParent.
     */
    boolean wouldCreateCycle(Node parent, Node child) {
        if (child != null &amp;&amp; child.getClip() == null &amp;&amp; (!(child instanceof Parent))) {
            return false;
    }

        Node n = parent;
        while (n != child) {
            if (n.getParent() != null) {
                n = n.getParent();
            } else if (n.getSubScene() != null) {
                n = n.getSubScene();
            } else if (n.clipParent != null) {
                n = n.clipParent;
            } else {
                return false;
            }
        }
        return true;
    }

    /**
     * The peer node created by the graphics Toolkit/Pipeline implementation
     */
    private NGNode peer;

    @SuppressWarnings(&quot;CallToPrintStackTrace&quot;)
    &lt;P extends NGNode&gt; P getPeer() {
        if (Utils.assertionEnabled()) {
            // Assertion checking code
            if (getScene() != null &amp;&amp; !Scene.isPGAccessAllowed()) {
                java.lang.System.err.println();
                java.lang.System.err.println(&quot;*** unexpected PG access&quot;);
                java.lang.Thread.dumpStack();
            }
        }

        if (peer == null) {
            //if (PerformanceTracker.isLoggingEnabled()) {
            //    PerformanceTracker.logEvent(&quot;Creating NGNode for [{this}, id=\&quot;{id}\&quot;]&quot;);
            //}
            peer = NodeHelper.createPeer(this);
            //if (PerformanceTracker.isLoggingEnabled()) {
            //    PerformanceTracker.logEvent(&quot;NGNode created&quot;);
            //}
        }
        return (P) peer;
    }

    /***************************************************************************
     *                                                                         *
     *                              Initialization                             *
     *                                                                         *
     *  To Note limit the number of bounds computations and improve startup    *
     *  performance.                                                           *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new instance of Node.
     */
    protected Node() {
        //if (PerformanceTracker.isLoggingEnabled()) {
        //    PerformanceTracker.logEvent(&quot;Node.init for [{this}, id=\&quot;{id}\&quot;]&quot;);
        //}
        setDirty();
        updateTreeVisible(false);
        //if (PerformanceTracker.isLoggingEnabled()) {
        //    PerformanceTracker.logEvent(&quot;Node.postinit &quot; +
        //                                &quot;for [{this}, id=\&quot;{id}\&quot;] finished&quot;);
        //}
    }

    /***************************************************************************
     *                                                                         *
     * Layout related APIs.                                                    *
     *                                                                         *
     **************************************************************************/
    /**
     * Defines whether or not this node's layout will be managed by it's parent.
     * If the node is managed, it's parent will factor the node's geometry
     * into its own preferred size and {@link #layoutBoundsProperty layoutBounds}
     * calculations and will lay it
     * out during the scene's layout pass.  If a managed node's layoutBounds
     * changes, it will automatically trigger relayout up the scene-graph
     * to the nearest layout root (which is typically the scene's root node).
     * &lt;p&gt;
     * If the node is unmanaged, its parent will ignore the child in both preferred
     * size computations and layout.   Changes in layoutBounds will not trigger
     * relayout above it.   If an unmanaged node is of type {@link javafx.scene.Parent Parent},
     * it will act as a &quot;layout root&quot;, meaning that calls to {@link Parent#requestLayout()}
     * beneath it will cause only the branch rooted by the node to be relayed out,
     * thereby isolating layout changes to that root and below.  It's the application's
     * responsibility to set the size and position of an unmanaged node.
     * &lt;p&gt;
     * By default all nodes are managed.
     * &lt;/p&gt;
     *
     * @see #isResizable()
     * @see #layoutBoundsProperty()
     * @see Parent#requestLayout()
     *
     */
    private BooleanProperty managed;

    public final void setManaged(boolean value) {
        managedProperty().set(value);
    }

    public final boolean isManaged() {
        return managed == null ? true : managed.get();
    }

    public final BooleanProperty managedProperty() {
        if (managed == null) {
            managed = new BooleanPropertyBase(true) {

                @Override
                protected void invalidated() {
                    final Parent parent = getParent();
                    if (parent != null) {
                        parent.managedChildChanged();
                    }
                    notifyManagedChanged();
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;managed&quot;;
                }

            };
        }
        return managed;
    }

    /**
     * Called whenever the &quot;managed&quot; flag has changed. This is only
     * used by Parent as an optimization to keep track of whether a
     * Parent node is a layout root or not.
     */
    void notifyManagedChanged() { }

    /**
     * Defines the x coordinate of the translation that is added to this {@code Node}'s
     * transform for the purpose of layout. The value should be computed as the
     * offset required to adjust the position of the node from its current
     * {@link #layoutBoundsProperty() layoutBounds minX} position (which might not be 0) to the desired location.
     *
     * &lt;p&gt;For example, if {@code textnode} should be positioned at {@code finalX}
     * &lt;pre&gt;{@code
     *     textnode.setLayoutX(finalX - textnode.getLayoutBounds().getMinX());
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * Failure to subtract {@code layoutBounds minX} may result in misplacement
     * of the node.  The {@link #relocate(double, double) relocate(x, y)} method will automatically do the
     * correct computation and should generally be used over setting layoutX directly.
     * &lt;p&gt;
     * The node's final translation will be computed as {@code layoutX} + {@link #translateXProperty translateX},
     * where {@code layoutX} establishes the node's stable position
     * and {@code translateX} optionally makes dynamic adjustments to that
     * position.
     * &lt;p&gt;
     * If the node is managed and has a {@link javafx.scene.layout.Region}
     * as its parent, then the layout region will set {@code layoutX} according to its
     * own layout policy.   If the node is unmanaged or parented by a {@link Group},
     * then the application may set {@code layoutX} directly to position it.
     *
     * @see #relocate(double, double)
     * @see #layoutBoundsProperty()
     *
     */
    private DoubleProperty layoutX;

    public final void setLayoutX(double value) {
        layoutXProperty().set(value);
    }

    public final double getLayoutX() {
        return layoutX == null ? 0.0 : layoutX.get();
    }

    public final DoubleProperty layoutXProperty() {
        if (layoutX == null) {
            layoutX = new DoublePropertyBase(0.0) {

                @Override
                protected void invalidated() {
                    NodeHelper.transformsChanged(Node.this);
                    final Parent p = getParent();

                    // Propagate layout if this change isn't triggered by its parent
                    if (p != null &amp;&amp; !p.isCurrentLayoutChild(Node.this)) {
                        if (isManaged()) {
                            // Force its parent to fix the layout since it is a managed child.
                            p.requestLayout(true);
                        } else {
                            // Parent size changed, parent's parent might need to re-layout
                            p.clearSizeCache();
                            p.requestParentLayout();
                        }
                    }
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;layoutX&quot;;
                }
            };
        }
        return layoutX;
    }

    /**
     * Defines the y coordinate of the translation that is added to this {@code Node}'s
     * transform for the purpose of layout. The value should be computed as the
     * offset required to adjust the position of the node from its current
     * {@link #layoutBoundsProperty() layoutBounds minY} position (which might not be 0) to the desired location.
     *
     * &lt;p&gt;For example, if {@code textnode} should be positioned at {@code finalY}
     * &lt;pre&gt;{@code
     *     textnode.setLayoutY(finalY - textnode.getLayoutBounds().getMinY());
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * Failure to subtract {@code layoutBounds minY} may result in misplacement
     * of the node.  The {@link #relocate(double, double) relocate(x, y)} method will automatically do the
     * correct computation and should generally be used over setting layoutY directly.
     * &lt;p&gt;
     * The node's final translation will be computed as {@code layoutY} + {@link #translateYProperty translateY},
     * where {@code layoutY} establishes the node's stable position
     * and {@code translateY} optionally makes dynamic adjustments to that
     * position.
     * &lt;p&gt;
     * If the node is managed and has a {@link javafx.scene.layout.Region}
     * as its parent, then the region will set {@code layoutY} according to its
     * own layout policy.   If the node is unmanaged or parented by a {@link Group},
     * then the application may set {@code layoutY} directly to position it.
     *
     * @see #relocate(double, double)
     * @see #layoutBoundsProperty()
     */
    private DoubleProperty layoutY;

    public final void setLayoutY(double value) {
        layoutYProperty().set(value);
    }

    public final double getLayoutY() {
        return layoutY == null ? 0.0 : layoutY.get();
    }

    public final DoubleProperty layoutYProperty() {
        if (layoutY == null) {
            layoutY = new DoublePropertyBase(0.0) {

                @Override
                protected void invalidated() {
                    NodeHelper.transformsChanged(Node.this);
                    final Parent p = getParent();

                    // Propagate layout if this change isn't triggered by its parent
                    if (p != null &amp;&amp; !p.isCurrentLayoutChild(Node.this)) {
                        if (isManaged()) {
                            // Force its parent to fix the layout since it is a managed child.
                            p.requestLayout(true);
                        } else {
                            // Parent size changed, parent's parent might need to re-layout
                            p.clearSizeCache();
                            p.requestParentLayout();
                        }
                    }
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;layoutY&quot;;
                }

            };
        }
        return layoutY;
    }

    /**
     * Sets the node's layoutX and layoutY translation properties in order to
     * relocate this node to the x,y location in the parent.
     * &lt;p&gt;
     * This method does not alter translateX or translateY, which if also set
     * will be added to layoutX and layoutY, adjusting the final location by
     * corresponding amounts.
     *
     * @param x the target x coordinate location
     * @param y the target y coordinate location
     */
    public void relocate(double x, double y) {
        setLayoutX(x - getLayoutBounds().getMinX());
        setLayoutY(y - getLayoutBounds().getMinY());

        PlatformLogger logger = Logging.getLayoutLogger();
        if (logger.isLoggable(Level.FINER)) {
            logger.finer(this.toString()+&quot; moved to (&quot;+x+&quot;,&quot;+y+&quot;)&quot;);
        }
    }

    /**
     * Indicates whether this node is a type which can be resized by its parent.
     * If this method returns true, then the parent will resize the node (ideally
     * within its size range) by calling node.resize(width,height) during the
     * layout pass.  All Regions, Controls, and WebView are resizable classes
     * which depend on their parents resizing them during layout once all sizing
     * and CSS styling information has been applied.
     * &lt;p&gt;
     * If this method returns false, then the parent cannot resize it during
     * layout (resize() is a no-op) and it should return its layoutBounds for
     * minimum, preferred, and maximum sizes.  Group, Text, and all Shapes are not
     * resizable and hence depend on the application to establish their sizing
     * by setting appropriate properties (e.g.  width/height for Rectangle,
     * text on Text, and so on).  Non-resizable nodes may still be relocated
     * during layout.
     *
     * @see #getContentBias()
     * @see #minWidth(double)
     * @see #minHeight(double)
     * @see #prefWidth(double)
     * @see #prefHeight(double)
     * @see #maxWidth(double)
     * @see #maxHeight(double)
     * @see #resize(double, double)
     * @see #getLayoutBounds()
     *
     * @return whether or not this node type can be resized by its parent during layout
     */
    public boolean isResizable() {
        return false;
    }

    /**
     * Returns the orientation of a node's resizing bias for layout purposes.
     * If the node type has no bias, returns null.  If the node is resizable and
     * it's height depends on its width, returns HORIZONTAL, else if its width
     * depends on its height, returns VERTICAL.
     * &lt;p&gt;
     * Resizable subclasses should override this method to return an
     * appropriate value.
     *
     * @see #isResizable()
     * @see #minWidth(double)
     * @see #minHeight(double)
     * @see #prefWidth(double)
     * @see #prefHeight(double)
     * @see #maxWidth(double)
     * @see #maxHeight(double)
     *
     * @return orientation of width/height dependency or null if there is none
     */
    public Orientation getContentBias() {
        return null;
    }

    /**
     * Returns the node's minimum width for use in layout calculations.
     * If the node is resizable, its parent should not resize its width any
     * smaller than this value.  If the node is not resizable, returns its
     * layoutBounds width.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a vertical content-bias, then callers
     * should pass in a height value that the minimum width should be based on.
     * If the node has either a horizontal or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a vertical content-bias should honor the height
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the height parameter (which will likely be -1).
     * &lt;p&gt;
     * If Node's {@link #maxWidth(double)} is lower than this number,
     * {@code minWidth} takes precedence. This means the Node should never be resized below {@code minWidth}.
     *
     * @see #isResizable()
     * @see #getContentBias()
     *
     * @param height the height that should be used if minimum width depends on it
     * @return the minimum width that the node should be resized to during layout.
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double minWidth(double height) {
        return prefWidth(height);
    }

    /**
     * Returns the node's minimum height for use in layout calculations.
     * If the node is resizable, its parent should not resize its height any
     * smaller than this value.  If the node is not resizable, returns its
     * layoutBounds height.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a horizontal content-bias, then callers
     * should pass in a width value that the minimum height should be based on.
     * If the node has either a vertical or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a horizontal content-bias should honor the width
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the width parameter (which will likely be -1).
     * &lt;p&gt;
     * If Node's {@link #maxHeight(double)} is lower than this number,
     * {@code minHeight} takes precedence. This means the Node should never be resized below {@code minHeight}.
     *
     * @see #isResizable()
     * @see #getContentBias()
     *
     * @param width the width that should be used if minimum height depends on it
     * @return the minimum height that the node should be resized to during layout
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double minHeight(double width) {
        return prefHeight(width);
    }

    /**
     * Returns the node's preferred width for use in layout calculations.
     * If the node is resizable, its parent should treat this value as the
     * node's ideal width within its range.  If the node is not resizable,
     * just returns its layoutBounds width, which should be treated as the rigid
     * width of the node.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a vertical content-bias, then callers
     * should pass in a height value that the preferred width should be based on.
     * If the node has either a horizontal or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a vertical content-bias should honor the height
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the height parameter (which will likely be -1).
     *
     * @see #isResizable()
     * @see #getContentBias()
     * @see #autosize()
     *
     * @param height the height that should be used if preferred width depends on it
     * @return the preferred width that the node should be resized to during layout
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double prefWidth(double height) {
        final double result = getLayoutBounds().getWidth();
        return Double.isNaN(result) || result &lt; 0 ? 0 : result;
    }

    /**
     * Returns the node's preferred height for use in layout calculations.
     * If the node is resizable, its parent should treat this value as the
     * node's ideal height within its range.  If the node is not resizable,
     * just returns its layoutBounds height, which should be treated as the rigid
     * height of the node.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a horizontal content-bias, then callers
     * should pass in a width value that the preferred height should be based on.
     * If the node has either a vertical or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a horizontal content-bias should honor the height
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the height parameter (which will likely be -1).
     *
     * @see #getContentBias()
     * @see #autosize()
     *
     * @param width the width that should be used if preferred height depends on it
     * @return the preferred height that the node should be resized to during layout
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double prefHeight(double width) {
        final double result = getLayoutBounds().getHeight();
        return Double.isNaN(result) || result &lt; 0 ? 0 : result;
    }

    /**
     * Returns the node's maximum width for use in layout calculations.
     * If the node is resizable, its parent should not resize its width any
     * larger than this value.  A value of Double.MAX_VALUE indicates the
     * parent may expand the node's width beyond its preferred without limits.
     * &lt;p&gt;
     * If the node is not resizable, returns its layoutBounds width.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a vertical content-bias, then callers
     * should pass in a height value that the maximum width should be based on.
     * If the node has either a horizontal or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a vertical content-bias should honor the height
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the height parameter (which will likely be -1).
     * &lt;p&gt;
     * If Node's {@link #minWidth(double)} is greater, it should take precedence
     * over the {@code maxWidth}. This means the Node should never be resized below {@code minWidth}.
     *
     * @see #isResizable()
     * @see #getContentBias()
     *
     * @param height the height that should be used if maximum width depends on it
     * @return the maximum width that the node should be resized to during layout
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double maxWidth(double height) {
        return prefWidth(height);
    }

    /**
     * Returns the node's maximum height for use in layout calculations.
     * If the node is resizable, its parent should not resize its height any
     * larger than this value.  A value of Double.MAX_VALUE indicates the
     * parent may expand the node's height beyond its preferred without limits.
     * &lt;p&gt;
     * If the node is not resizable, returns its layoutBounds height.
     * &lt;p&gt;
     * Layout code which calls this method should first check the content-bias
     * of the node.  If the node has a horizontal content-bias, then callers
     * should pass in a width value that the maximum height should be based on.
     * If the node has either a vertical or null content-bias, then the caller
     * should pass in -1.
     * &lt;p&gt;
     * Node subclasses with a horizontal content-bias should honor the width
     * parameter whether -1 or a positive value.   All other subclasses may ignore
     * the width parameter (which will likely be -1).
     * &lt;p&gt;
     * If Node's {@link #minHeight(double)} is greater, it should take precedence
     * over the {@code maxHeight}.  This means the Node should never be resized below {@code minHeight}.
     *
     * @see #isResizable()
     * @see #getContentBias()
     *
     * @param width the width that should be used if maximum height depends on it
     * @return the maximum height that the node should be resized to during layout
     *         The result will never be NaN, nor will it ever be negative.
     */
    public double maxHeight(double width) {
        return prefHeight(width);
    }

    /**
     * If the node is resizable, will set its layout bounds to the specified
     * width and height.   If the node is not resizable, this method is a no-op.
     * &lt;p&gt;
     * This method should generally only be called by parent nodes from their
     * layoutChildren() methods.   All Parent classes will automatically resize
     * resizable children, so resizing done directly by the application will be
     * overridden by the node's parent, unless the child is unmanaged.
     * &lt;p&gt;
     * Parents are responsible for ensuring the width and height values fall
     * within the resizable node's preferred range.  The autosize() method may
     * be used if the parent just needs to resize the node to its preferred size.
     *
     * @see #isResizable()
     * @see #getContentBias()
     * @see #autosize()
     * @see #minWidth(double)
     * @see #minHeight(double)
     * @see #prefWidth(double)
     * @see #prefHeight(double)
     * @see #maxWidth(double)
     * @see #maxHeight(double)
     * @see #getLayoutBounds()
     *
     * @param width the target layout bounds width
     * @param height the target layout bounds height
     */
    public void resize(double width, double height) {
    }

    /**
     * If the node is resizable, will set its layout bounds to its current preferred
     * width and height. If the node is not resizable, this method is a no-op.
     * &lt;p&gt;
     * This method automatically queries the node's content-bias and if it's
     * horizontal, will pass in the node's preferred width to get the preferred
     * height; if vertical, will pass in the node's preferred height to get the width,
     * and if null, will compute the preferred width/height independently.
     * &lt;/p&gt;
     *
     * @see #isResizable()
     * @see #getContentBias()
     *
     */
    public final void autosize() {
        if (isResizable()) {
            Orientation contentBias = getContentBias();
            double w, h;
            if (contentBias == null) {
                w = boundedSize(prefWidth(-1), minWidth(-1), maxWidth(-1));
                h = boundedSize(prefHeight(-1), minHeight(-1), maxHeight(-1));
            } else if (contentBias == Orientation.HORIZONTAL) {
                w = boundedSize(prefWidth(-1), minWidth(-1), maxWidth(-1));
                h = boundedSize(prefHeight(w), minHeight(w), maxHeight(w));
            } else { // bias == VERTICAL
                h = boundedSize(prefHeight(-1), minHeight(-1), maxHeight(-1));
                w = boundedSize(prefWidth(h), minWidth(h), maxWidth(h));
            }
            resize(w,h);
        }
    }

    double boundedSize(double value, double min, double max) {
        // if max &lt; value, return max
        // if min &gt; value, return min
        // if min &gt; max, return min
        return Math.min(Math.max(value, min), Math.max(min,max));
    }

    /**
     * If the node is resizable, will set its layout bounds to the specified
     * width and height.   If the node is not resizable, the resize step is skipped.
     * &lt;p&gt;
     * Once the node has been resized (if resizable) then sets the node's layoutX
     * and layoutY translation properties in order to relocate it to x,y in the
     * parent's coordinate space.
     * &lt;p&gt;
     * This method should generally only be called by parent nodes from their
     * layoutChildren() methods.   All Parent classes will automatically resize
     * resizable children, so resizing done directly by the application will be
     * overridden by the node's parent, unless the child is unmanaged.
     * &lt;p&gt;
     * Parents are responsible for ensuring the width and height values fall
     * within the resizable node's preferred range.  The autosize() and relocate()
     * methods may be used if the parent just needs to resize the node to its
     * preferred size and reposition it.
     *
     * @see #isResizable()
     * @see #getContentBias()
     * @see #autosize()
     * @see #minWidth(double)
     * @see #minHeight(double)
     * @see #prefWidth(double)
     * @see #prefHeight(double)
     * @see #maxWidth(double)
     * @see #maxHeight(double)
     *
     * @param x the target x coordinate location
     * @param y the target y coordinate location
     * @param width the target layout bounds width
     * @param height the target layout bounds height
     *
     */
    public void resizeRelocate(double x, double y, double width, double height) {
        resize(width, height);
        relocate(x,y);
    }

    /**
     * This is a special value that might be returned by {@link #getBaselineOffset()}.
     * This means that the Parent (layout Pane) of this Node should use the height of this Node as a baseline.
     */
    public static final double BASELINE_OFFSET_SAME_AS_HEIGHT = Double.NEGATIVE_INFINITY;

    /**
     * The 'alphabetic' (or 'roman') baseline offset from the node's layoutBounds.minY location
     * that should be used when this node is being vertically aligned by baseline with
     * other nodes.  By default this returns {@link #BASELINE_OFFSET_SAME_AS_HEIGHT} for resizable Nodes
     * and layoutBounds height for non-resizable.  Subclasses
     * which contain text should override this method to return their actual text baseline offset.
     *
     * @return offset of text baseline from layoutBounds.minY for non-resizable Nodes or {@link #BASELINE_OFFSET_SAME_AS_HEIGHT} otherwise
     */
    public double getBaselineOffset() {
        if (isResizable()) {
            return BASELINE_OFFSET_SAME_AS_HEIGHT;
        } else {
            return getLayoutBounds().getHeight();
        }
    }

    /**
     * Returns the area of this {@code Node} projected onto the
     * physical screen in pixel units.
     * @return the area of this {@code Node} projected onto the physical screen
     * @since JavaFX 8.0
     */
    public double computeAreaInScreen() {
        return doComputeAreaInScreen();
    }

    /*
     * Help application or utility to implement LOD support by returning the
     * projected area of a Node in pixel unit. The projected area is not clipped.
     *
     * For perspective camera, this method first exams node's bounds against
     * camera's clipping plane to cut off those out of viewing frustrum. After
     * computing areaInScreen, it applies a tight viewing frustrum check using
     * canonical view volume.
     *
     * The result of areaInScreen comes from the product of
     * (projViewTx x localToSceneTransform x localBounds).
     *
     * Returns 0 for those fall outside viewing frustrum.
     */
    private double doComputeAreaInScreen() {
        Scene tmpScene = getScene();
        if (tmpScene != null) {
            Bounds bounds = getBoundsInLocal();
            Camera camera = tmpScene.getEffectiveCamera();
            boolean isPerspective = camera instanceof PerspectiveCamera ? true : false;
            Transform localToSceneTx = getLocalToSceneTransform();
            Affine3D tempTx = TempState.getInstance().tempTx;
            BaseBounds localBounds = new BoxBounds((float) bounds.getMinX(),
                                                   (float) bounds.getMinY(),
                                                   (float) bounds.getMinZ(),
                                                   (float) bounds.getMaxX(),
                                                   (float) bounds.getMaxY(),
                                                   (float) bounds.getMaxZ());

            // NOTE: Viewing frustrum check on camera's clipping plane is now only
            // for perspective camera.
            // TODO: Need to hook up parallel camera's nearClip and farClip.
            if (isPerspective) {
                Transform cameraL2STx = camera.getLocalToSceneTransform();

                // If camera transform only contains translate, compare in scene
                // coordinate. Otherwise, compare in camera coordinate.
                if (cameraL2STx.getMxx() == 1.0
                        &amp;&amp; cameraL2STx.getMxy() == 0.0
                        &amp;&amp; cameraL2STx.getMxz() == 0.0
                        &amp;&amp; cameraL2STx.getMyx() == 0.0
                        &amp;&amp; cameraL2STx.getMyy() == 1.0
                        &amp;&amp; cameraL2STx.getMyz() == 0.0
                        &amp;&amp; cameraL2STx.getMzx() == 0.0
                        &amp;&amp; cameraL2STx.getMzy() == 0.0
                        &amp;&amp; cameraL2STx.getMzz() == 1.0) {

                    double minZ, maxZ;

                    // If node transform only contains translate, only convert
                    // minZ and maxZ to scene coordinate. Otherwise, convert
                    // node bounds to scene coordinate.
                    if (localToSceneTx.getMxx() == 1.0
                            &amp;&amp; localToSceneTx.getMxy() == 0.0
                            &amp;&amp; localToSceneTx.getMxz() == 0.0
                            &amp;&amp; localToSceneTx.getMyx() == 0.0
                            &amp;&amp; localToSceneTx.getMyy() == 1.0
                            &amp;&amp; localToSceneTx.getMyz() == 0.0
                            &amp;&amp; localToSceneTx.getMzx() == 0.0
                            &amp;&amp; localToSceneTx.getMzy() == 0.0
                            &amp;&amp; localToSceneTx.getMzz() == 1.0) {

                        Vec3d tempV3D = TempState.getInstance().vec3d;
                        tempV3D.set(0, 0, bounds.getMinZ());
                        localToScene(tempV3D);
                        minZ = tempV3D.z;

                        tempV3D.set(0, 0, bounds.getMaxZ());
                        localToScene(tempV3D);
                        maxZ = tempV3D.z;
                    } else {
                        Bounds nodeInSceneBounds = localToScene(bounds);
                        minZ = nodeInSceneBounds.getMinZ();
                        maxZ = nodeInSceneBounds.getMaxZ();
                    }

                    if (minZ &gt; camera.getFarClipInScene()
                            || maxZ &lt; camera.getNearClipInScene()) {
                        return 0;
                    }

                } else {
                    BaseBounds nodeInCameraBounds = new BoxBounds();

                    // We need to set tempTx to identity since it is a recycled transform.
                    // This is because TransformHelper.apply() is a matrix concatenation operation.
                    tempTx.setToIdentity();
                    TransformHelper.apply(localToSceneTx, tempTx);

                    // Convert node from local coordinate to camera coordinate
                    tempTx.preConcatenate(camera.getSceneToLocalTransform());
                    tempTx.transform(localBounds, nodeInCameraBounds);

                    // Compare in camera coordinate
                    if (nodeInCameraBounds.getMinZ() &gt; camera.getFarClip()
                            || nodeInCameraBounds.getMaxZ() &lt; camera.getNearClip()) {
                        return 0;
                    }
                }
            }

            GeneralTransform3D projViewTx = TempState.getInstance().projViewTx;
            projViewTx.set(camera.getProjViewTransform());

            // We need to set tempTx to identity since it is a recycled transform.
            // This is because TransformHelper.apply() is a matrix concatenation operation.
            tempTx.setToIdentity();
            TransformHelper.apply(localToSceneTx, tempTx);

            // The product of projViewTx * localToSceneTransform
            GeneralTransform3D tx = projViewTx.mul(tempTx);

            // Transform localBounds to projected bounds
            localBounds = tx.transform(localBounds, localBounds);
            double area = localBounds.getWidth() * localBounds.getHeight();

            // Use canonical view volume to check whether object is outside the
            // viewing frustrum
            if (isPerspective) {
                localBounds.intersectWith(-1, -1, 0, 1, 1, 1);
                area = (localBounds.getWidth() &lt; 0 || localBounds.getHeight() &lt; 0) ? 0 : area;
            }
            return area * (camera.getViewWidth() / 2 * camera.getViewHeight() / 2);
        }
        return 0;
    }

    /* *************************************************************************
     *                                                                         *
     * Bounds related APIs                                                     *
     *                                                                         *
     **************************************************************************/

    public final Bounds getBoundsInParent() {
        return boundsInParentProperty().get();
    }

    /**
     * The rectangular bounds of this {@code Node} which include its transforms.
     * {@code boundsInParent} is calculated by
     * taking the local bounds (defined by {@link #boundsInLocalProperty boundsInLocal}) and applying
     * the transform created by setting the following additional variables
     * &lt;ol&gt;
     * &lt;li&gt;{@link #getTransforms transforms} ObservableList&lt;/li&gt;
     * &lt;li&gt;{@link #scaleXProperty scaleX}, {@link #scaleYProperty scaleY}, {@link #scaleZProperty scaleZ}&lt;/li&gt;
     * &lt;li&gt;{@link #rotateProperty rotate}&lt;/li&gt;
     * &lt;li&gt;{@link #layoutXProperty layoutX}, {@link #layoutYProperty layoutY}&lt;/li&gt;
     * &lt;li&gt;{@link #translateXProperty translateX}, {@link #translateYProperty translateY},
     * {@link #translateZProperty translateZ}&lt;/li&gt;
     * &lt;/ol&gt;
     * &lt;p&gt;
     * The resulting bounds will be conceptually in the coordinate space of the
     * {@code Node}'s parent, however the node need not have a parent to calculate
     * these bounds.
     * &lt;p&gt;
     * Note that this method does not take the node's visibility into account;
     * the computation is based on the geometry of this {@code Node} only.
     * &lt;p&gt;
     * This property will always have a non-null value.
     * &lt;p&gt;
     * Note that {@code boundsInParent} is automatically recomputed whenever the
     * geometry of a node changes, or when any of the following the change:
     * transforms {@code ObservableList}, any of the translate, layout or scale
     * variables, or the rotate variable. For this reason, it is an error
     * to bind any of these values in a node to an expression that depends upon
     * this variable. For example, the x or y variables of a shape, or
     * {@code translateX}, {@code translateY} should never be bound to
     * {@code boundsInParent} for the purpose of positioning the node.
     * @return the boundsInParent for this {@code Node}
     */
    public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInParentProperty() {
        return getMiscProperties().boundsInParentProperty();
    }

    private void invalidateBoundsInParent() {
        if (miscProperties != null) {
            miscProperties.invalidateBoundsInParent();
        }
    }

    public final Bounds getBoundsInLocal() {
        return boundsInLocalProperty().get();
    }

    /**
     * The rectangular bounds of this {@code Node} in the node's
     * untransformed local coordinate space.  For nodes that extend
     * {@link javafx.scene.shape.Shape}, the local bounds will also include
     * space required for a non-zero stroke that may fall outside the shape's
     * geometry that is defined by position and size attributes.
     * The local bounds will also include any clipping set with {@link #clipProperty clip}
     * as well as effects set with {@link #effectProperty effect}.
     *
     * &lt;p&gt;
     * Note that this method does not take the node's visibility into account;
     * the computation is based on the geometry of this {@code Node} only.
     * &lt;p&gt;
     * This property will always have a non-null value.
     * &lt;p&gt;
     * Note that boundsInLocal is automatically recomputed whenever the
     * geometry of a node changes. For this reason, it is an error to bind any
     * of these values in a node to an expression that depends upon this variable.
     * For example, the x or y variables of a shape should never be bound
     * to boundsInLocal for the purpose of positioning the node.
     * @return the boundsInLocal for this {@code Node}
     */
    public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInLocalProperty() {
        return getMiscProperties().boundsInLocalProperty();
    }

    private void invalidateBoundsInLocal() {
        if (miscProperties != null) {
            miscProperties.invalidateBoundsInLocal();
        }
    }

    /**
     * The rectangular bounds that should be used for layout calculations for
     * this node. {@code layoutBounds} may differ from the visual bounds
     * of the node and is computed differently depending on the node type.
     * &lt;p&gt;
     * If the node type is resizable ({@link javafx.scene.layout.Region Region},
     * {@link javafx.scene.control.Control Control}, or {@link javafx.scene.web.WebView WebView})
     * then the layoutBounds will always be {@code 0,0 width x height}.
     * If the node type is not resizable ({@link javafx.scene.shape.Shape Shape},
     * {@link javafx.scene.text.Text Text}, or {@link Group}), then the {@code layoutBounds}
     * are computed based on the node's geometric properties and does not include the
     * node's clip, effect, or transforms.  See individual class documentation
     * for details.
     * &lt;p&gt;
     * Note that the {@link #layoutXProperty layoutX}, {@link #layoutYProperty layoutY},
     * {@link #translateXProperty translateX}, and {@link #translateYProperty translateY}
     * variables are not included in the layoutBounds.
     * This is important because layout code must first determine the current
     * size and location of the node (using {@code layoutBounds}) and then set
     * {@code layoutX} and {@code layoutY} to adjust the translation of the
     * node so that it will have the desired layout position.
     * &lt;p&gt;
     * Because the computation of layoutBounds is often tied to a node's
     * geometric variables, it is an error to bind any such variables to an
     * expression that depends upon {@code layoutBounds}. For example, the
     * x or y variables of a shape should never be bound to {@code layoutBounds}
     * for the purpose of positioning the node.
     * &lt;p&gt;
     * Note that for 3D shapes, the layout bounds is actually a rectangular box
     * with X, Y, and Z values, although only X and Y are used in layout calculations.
     * &lt;p&gt;
     * The {@code layoutBounds} will never be null.
     *
     */
    private LazyBoundsProperty layoutBounds = new LazyBoundsProperty() {
        @Override
        protected Bounds computeBounds() {
            return NodeHelper.computeLayoutBounds(Node.this);
        }

        @Override
        public Object getBean() {
            return Node.this;
        }

        @Override
        public String getName() {
            return &quot;layoutBounds&quot;;
        }
    };

    public final Bounds getLayoutBounds() {
        return layoutBoundsProperty().get();
    }

    public final ReadOnlyObjectProperty&lt;Bounds&gt; layoutBoundsProperty() {
        return layoutBounds;
    }

    /*
     *                  Bounds And Transforms Computation
     *
     *  This section of the code is responsible for computing and caching
     *  various bounds and transforms. For optimal performance and minimal
     *  recomputation of bounds (which can be quite expensive), we cache
     *  values on two different levels. We expose two public immutable
     *  Bounds boundsInParent objects and boundsInLocal. Because they are
     *  immutable and because they may change quite frequently (especially
     *  in the case of a Parent whose children are animated), it is
     *  important that the system does not rely on these variables, because
     *  doing so would produce a large amount of garbage. Rather, these
     *  variables are provided solely for the convenience of application
     *  developers and, being lazily bound, should generally be created at
     *  most once per frame.
     *
     *  The second level of caching are within local Bounds2D variables.
     *  These variables, txBounds and geomBounds, are mutable and as such
     *  can be cached and updated as frequently as necessary without creating
     *  excessive garbage. However, since the computation of bounds is still
     *  expensive, it is desirable to cache both the geometric bounds and
     *  the &quot;complete&quot; transformed bounds (essentially, boundsInParent).
     *  Cached txBounds is particularly useful when computing the geometric
     *  bounds of a Parent since it would not require complete or partial
     *  recomputation of each child.
     *
     *  Finally, we cache the complete transform for this node which converts
     *  its coord system from local to parent coords. This is useful both for
     *  minimizing bounds recomputations in the case of the geometry having
     *  changed but the transform not having changed, and also because the tx
     *  is required for several different computations (for example, it must
     *  be computed once during state synchronization with the PG peer, and
     *  must also be computed when the pivot point changes, and also when
     *  deriving the txBounds of the Node).
     *
     *  As with any caching system, a subtle and non-trivial amount of code
     *  is devoted to invalidating the bounds / transforms at appropriate
     *  times and in appropriate places to make sure bounds / transforms
     *  are recomputed at all necessary times.
     *
     *  There are three computeXXX functions. One is for computing the
     *  boundsInParent, the second for computing boundsInLocal, and the
     *  third for computing the default layout bounds (which, by default,
     *  is based on the geometric bounds). These functions are all prefixed
     *  with &quot;compute&quot; because they create and return new immutable
     *  Bounds objects.
     *
     *  There are three getXXXBounds functions. One is for returning the
     *  complete transformed bounds. The second is for returning the
     *  local bounds. The last is for returning the geometric bounds. These
     *  functions are all prefixed with &quot;get&quot; because they may well return
     *  a cached value, or may actually compute the bounds if necessary. These
     *  functions all have the same signature. They take a Bounds2D and
     *  BaseTransform, and return a Bounds2D (the same as they took). These
     *  functions essentially populate the supplied bounds2D with the
     *  appropriate bounds information, leveraging cached bounds if possible.
     *
     *  There is a single NodeHelper.computeGeomBoundsImpl function which is abstract.
     *  This must be implemented in each subclass, and is responsible for
     *  computing the actual geometric bounds for the Node. For example, Parent
     *  is written such that this function is the union of the transformed
     *  bounds of each child. Rectangle is written such that this takes into
     *  account the size and stroke. Text is written such that it is computed
     *  based on the actual glyphs.
     *
     *  There are two updateXXX functions, updateGeomBounds and updateTxBounds.
     *  These functions are for ensuring that geomBounds and txBounds are
     *  valid. They only execute in the case of the cached value being invalid,
     *  so the function call is very cheap in cases where the cached bounds
     *  values are still valid.
     */

    /**
     * An affine transform that holds the computed local-to-parent transform.
     * This is the concatenation of all transforms in this node, including all
     * of the convenience transforms.
     */
    private BaseTransform localToParentTx = BaseTransform.IDENTITY_TRANSFORM;

    /**
     * This flag is used to indicate that localToParentTx is dirty and needs
     * to be recomputed.
     */
    private boolean transformDirty = true;

    /**
     * The cached transformed bounds. This is never null, but is frequently set
     * to be invalid whenever the bounds for the node have changed. These are
     * &quot;complete&quot; bounds, that is, with transforms and effect and clip applied.
     * Note that this is equivalent to boundsInParent
     */
    private BaseBounds txBounds = new RectBounds();

    /**
     * The cached bounds. This is never null, but is frequently set to be
     * invalid whenever the bounds for the node have changed. These are the
     * &quot;content&quot; bounds, that is, without transforms or effects applied.
     */
    private BaseBounds geomBounds = new RectBounds();

    /**
     * The cached local bounds (without transforms, with clip and effects).
     * If there is neither clip nor effect
     * local bounds are equal to geom bounds, so in this case we don't keep
     * the extra instance and set null to this variable.
     */
    private BaseBounds localBounds = null;

    /**
     * This special flag is used only by Parent to flag whether or not
     * the *parent* has processed the fact that bounds have changed for this
     * child Node. We need some way of flagging this on a per-node basis to
     * enable the significant performance optimizations and fast paths that
     * are in the Parent code.
     * &lt;p&gt;
     * To reduce confusion, although this variable is defined on Node, it
     * really belongs to the Parent of the node and should *only* be modified
     * by the parent.
     */
    boolean boundsChanged;

    /*
     * Returns geometric bounds, but may be over-ridden by a subclass.
     */
    private Bounds doComputeLayoutBounds() {
        BaseBounds tempBounds = TempState.getInstance().bounds;
        tempBounds = getGeomBounds(tempBounds,
                                   BaseTransform.IDENTITY_TRANSFORM);
        return new BoundingBox(tempBounds.getMinX(),
                               tempBounds.getMinY(),
                               tempBounds.getMinZ(),
                               tempBounds.getWidth(),
                               tempBounds.getHeight(),
                               tempBounds.getDepth());
    }

    /*
     * Subclasses may customize the layoutBounds by means of overriding the
     * NodeHelper.computeLayoutBoundsImpl method. If the layout bounds need to be
     * recomputed, the subclass must notify the Node implementation of this
     * fact so that appropriate notifications and internal state can be
     * kept in sync. Subclasses must call NodeHelper.layoutBoundsChanged to
     * let Node know that the layout bounds are invalid and need to be
     * recomputed.
     */
    final void layoutBoundsChanged() {
        if (!layoutBounds.valid) {
            return;
        }
        layoutBounds.invalidate();
        if ((nodeTransformation != null &amp;&amp; nodeTransformation.hasScaleOrRotate()) || hasMirroring()) {
            // if either the scale or rotate convenience variables are used,
            // then we need a valid pivot point. Since the layoutBounds
            // affects the pivot we need to invalidate the transform
            NodeHelper.transformsChanged(this);
        }
    }

    /**
     * Loads the given bounds object with the transformed bounds relative to,
     * and based on, the given transform. That is, this is the local bounds
     * with the local-to-parent transform applied.
     *
     * We *never* pass null in as a bounds. This method will
     * NOT take a null bounds object. The returned value may be
     * the same bounds object passed in, or it may be a new object.
     * The reason for this object promotion is in the case of needing
     * to promote from a RectBounds to a BoxBounds (3D).
     */
    BaseBounds getTransformedBounds(BaseBounds bounds, BaseTransform tx) {
        updateLocalToParentTransform();
        if (tx.isTranslateOrIdentity()) {
            updateTxBounds();
            bounds = bounds.deriveWithNewBounds(txBounds);
            if (!tx.isIdentity()) {
                final double translateX = tx.getMxt();
                final double translateY = tx.getMyt();
                final double translateZ = tx.getMzt();
                bounds = bounds.deriveWithNewBounds(
                                    (float) (bounds.getMinX() + translateX),
                                    (float) (bounds.getMinY() + translateY),
                                    (float) (bounds.getMinZ() + translateZ),
                                    (float) (bounds.getMaxX() + translateX),
                                    (float) (bounds.getMaxY() + translateY),
                                    (float) (bounds.getMaxZ() + translateZ));
            }
            return bounds;
        } else if (localToParentTx.isIdentity()) {
            return getLocalBounds(bounds, tx);
        } else {
            double mxx = tx.getMxx();
            double mxy = tx.getMxy();
            double mxz = tx.getMxz();
            double mxt = tx.getMxt();
            double myx = tx.getMyx();
            double myy = tx.getMyy();
            double myz = tx.getMyz();
            double myt = tx.getMyt();
            double mzx = tx.getMzx();
            double mzy = tx.getMzy();
            double mzz = tx.getMzz();
            double mzt = tx.getMzt();
            BaseTransform boundsTx = tx.deriveWithConcatenation(localToParentTx);
            bounds = getLocalBounds(bounds, boundsTx);
            if (boundsTx == tx) {
                tx.restoreTransform(mxx, mxy, mxz, mxt,
                                    myx, myy, myz, myt,
                                    mzx, mzy, mzz, mzt);
            }
            return bounds;
        }
    }

    /**
     * Loads the given bounds object with the local bounds relative to,
     * and based on, the given transform. That is, these are the geometric
     * bounds + clip and effect.
     *
     * We *never* pass null in as a bounds. This method will
     * NOT take a null bounds object. The returned value may be
     * the same bounds object passed in, or it may be a new object.
     * The reason for this object promotion is in the case of needing
     * to promote from a RectBounds to a BoxBounds (3D).
     */
    BaseBounds getLocalBounds(BaseBounds bounds, BaseTransform tx) {
        if (getEffect() == null &amp;&amp; getClip() == null) {
            return getGeomBounds(bounds, tx);
        }

        if (tx.isTranslateOrIdentity()) {
            // we can take a fast path since we know tx is either a simple
            // translation or is identity
            updateLocalBounds();
            bounds = bounds.deriveWithNewBounds(localBounds);
            if (!tx.isIdentity()) {
                double translateX = tx.getMxt();
                double translateY = tx.getMyt();
                double translateZ = tx.getMzt();
                bounds = bounds.deriveWithNewBounds((float) (bounds.getMinX() + translateX),
                        (float) (bounds.getMinY() + translateY),
                        (float) (bounds.getMinZ() + translateZ),
                        (float) (bounds.getMaxX() + translateX),
                        (float) (bounds.getMaxY() + translateY),
                        (float) (bounds.getMaxZ() + translateZ));
            }
            return bounds;
        } else if (tx.is2D()
                &amp;&amp; (tx.getType()
                &amp; ~(BaseTransform.TYPE_UNIFORM_SCALE | BaseTransform.TYPE_TRANSLATION
                | BaseTransform.TYPE_FLIP | BaseTransform.TYPE_QUADRANT_ROTATION)) != 0) {
            // this is a non-uniform scale / non-quadrant rotate / skew transform
            return computeLocalBounds(bounds, tx);
        } else {
            // 3D transformations and
            // selected 2D transformations (uniform transform, flip, quadrant rotation).
            // These 2D transformation will yield tight bounds when applied on the pre-computed
            // geomBounds
            // Note: Transforming the local bounds into a 3D space will yield a bounds
            // that isn't as tight as transforming its geometry and compute it bounds.
            updateLocalBounds();
            return tx.transform(localBounds, bounds);
        }
    }

    /**
     * Loads the given bounds object with the geometric bounds relative to,
     * and based on, the given transform.
     *
     * We *never* pass null in as a bounds. This method will
     * NOT take a null bounds object. The returned value may be
     * the same bounds object passed in, or it may be a new object.
     * The reason for this object promotion is in the case of needing
     * to promote from a RectBounds to a BoxBounds (3D).
     */
    BaseBounds getGeomBounds(BaseBounds bounds, BaseTransform tx) {
        if (tx.isTranslateOrIdentity()) {
            // we can take a fast path since we know tx is either a simple
            // translation or is identity
            updateGeomBounds();
            bounds = bounds.deriveWithNewBounds(geomBounds);
            if (!tx.isIdentity()) {
                double translateX = tx.getMxt();
                double translateY = tx.getMyt();
                double translateZ = tx.getMzt();
                bounds = bounds.deriveWithNewBounds((float) (bounds.getMinX() + translateX),
                        (float) (bounds.getMinY() + translateY),
                        (float) (bounds.getMinZ() + translateZ),
                        (float) (bounds.getMaxX() + translateX),
                        (float) (bounds.getMaxY() + translateY),
                        (float) (bounds.getMaxZ() + translateZ));
            }
            return bounds;
        } else if (tx.is2D()
                &amp;&amp; (tx.getType()
                &amp; ~(BaseTransform.TYPE_UNIFORM_SCALE | BaseTransform.TYPE_TRANSLATION
                | BaseTransform.TYPE_FLIP | BaseTransform.TYPE_QUADRANT_ROTATION)) != 0) {
            // this is a non-uniform scale / non-quadrant rotate / skew transform
            return NodeHelper.computeGeomBounds(this, bounds, tx);
        } else {
            // 3D transformations and
            // selected 2D transformations (unifrom transform, flip, quadrant rotation).
            // These 2D transformation will yield tight bounds when applied on the pre-computed
            // geomBounds
            // Note: Transforming the local geomBounds into a 3D space will yield a bounds
            // that isn't as tight as transforming its geometry and compute it bounds.
            updateGeomBounds();
            return tx.transform(geomBounds, bounds);
        }
    }

    /**
     * If necessary, recomputes the cached geom bounds. If the bounds are not
     * invalid, then this method is a no-op.
     */
    void updateGeomBounds() {
        if (geomBoundsInvalid) {
            geomBounds = NodeHelper.computeGeomBounds(this, geomBounds, BaseTransform.IDENTITY_TRANSFORM);
            geomBoundsInvalid = false;
        }
    }

    /**
     * Computes the local bounds of this Node.
     */
    private BaseBounds computeLocalBounds(BaseBounds bounds, BaseTransform tx) {
        // We either get the bounds of the effect (if it isn't null)
        // or we get the geom bounds (if effect is null). We will then
        // intersect this with the clip.
        if (getEffect() != null) {
            BaseBounds b = EffectHelper.getBounds(getEffect(), bounds, tx, this, boundsAccessor);
            bounds = bounds.deriveWithNewBounds(b);
        } else {
            bounds = getGeomBounds(bounds, tx);
        }
        // intersect with the clip. Take care with &quot;bounds&quot; as it may
        // actually be TEMP_BOUNDS, so we save off state
        if (getClip() != null
                // FIXME: All 3D picking is currently ignored by rendering.
                // Until this is fixed or defined differently (RT-28510),
                // we follow this behavior.
                &amp;&amp; !(this instanceof Shape3D) &amp;&amp; !(getClip() instanceof Shape3D)) {
            double x1 = bounds.getMinX();
            double y1 = bounds.getMinY();
            double x2 = bounds.getMaxX();
            double y2 = bounds.getMaxY();
            double z1 = bounds.getMinZ();
            double z2 = bounds.getMaxZ();
            bounds = getClip().getTransformedBounds(bounds, tx);
            bounds.intersectWith((float)x1, (float)y1, (float)z1,
                    (float)x2, (float)y2, (float)z2);
        }
        return bounds;
    }


    /**
     * If necessary, recomputes the cached local bounds. If the bounds are not
     * invalid, then this method is a no-op.
     */
    private void updateLocalBounds() {
        if (localBoundsInvalid) {
            if (getClip() != null || getEffect() != null) {
                localBounds = computeLocalBounds(
                        localBounds == null ? new RectBounds() : localBounds,
                        BaseTransform.IDENTITY_TRANSFORM);
            } else {
                localBounds = null;
            }
            localBoundsInvalid = false;
        }
    }

    /**
     * If necessary, recomputes the cached transformed bounds.
     * If the cached transformed bounds are not invalid, then
     * this method is a no-op.
     */
    void updateTxBounds() {
        if (txBoundsInvalid) {
            updateLocalToParentTransform();
            txBounds = getLocalBounds(txBounds, localToParentTx);
            txBoundsInvalid = false;
        }
    }

    /*
     *                   Bounds Invalidation And Notification
     *
     *  The goal of this section is to efficiently propagate bounds
     *  invalidation through the scenegraph while also being semantically
     *  correct.
     *
     *  The code path for invalidation of layout bounds is somewhat confusing
     *  primarily due to performance enhancements and the desire to reduce the
     *  number of requestLayout() calls that are performed when layout bounds
     *  change. Before diving into layout bounds, I will first describe how
     *  normal bounds invalidation occurs.
     *
     *  When a node's geometry changes (for example, if the width of a
     *  Rectangle is changed) then the Node must call NodeHelper.geomChanged().
     *  Invoking this function will eventually clear all cached bounds and
     *  notify to each parent up the tree that their bounds may have changed.
     *
     *  After invalidating geomBounds (and after kicking off layout bounds
     *  notification), NodeHelper.geomChanged calls localBoundsChanged(). It should
     *  be noted that NodeHelper.geomChanged should only be called when the geometry
     *  of the node has changed such that it may result in the geom bounds
     *  actually changing.
     *
     *  localBoundsChanged() simply invalidates boundsInLocal and then calls
     *  transformedBoundsChanged().
     *
     *  transformedBoundsChanged() is responsible for invalidating
     *  boundsInParent and txBounds. If the Node is not visible, then there is
     *  no need to notify the parent of the bounds change because the parent's
     *  bounds do not include invisible nodes. If the node is visible, then
     *  it must tell the parent that this child node's bounds have changed.
     *  It is up to the parent to eventually invoke its own NodeHelper.geomChanged
     *  function. If instead of a parent this node has a clipParent, then the
     *  clipParent's localBoundsChanged() is called instead.
     *
     *  There are a few other ways in which we enter the invalidate steps
     *  beyond just the geometry changes. If the visibility of a Node changes,
     *  its own bounds are not affected but its parent's bounds are. So a
     *  special call to parent.childVisibilityChanged is made so the parent
     *  can react accordingly.
     *
     *  If a transform is changed (layoutX, layoutY, rotate, transforms, etc)
     *  then the transform must be invalidated. When a transform is invalidated,
     *  it must also invalidate the txBounds by invoking
     *  transformedBoundsChanged, which will in turn notify the parent as
     *  before.
     *
     *  If an effect is changed or replaced then the local bounds must be
     *  invalidated, as well as the transformedBounds and the parent notified
     *  of the change in bounds.
     *
     *  layoutBound is somewhat unique in that it can be redefined in
     *  subclasses. By default, the layoutBounds is the geomBounds, and so
     *  whenever the geomBounds() function is called the layoutBounds
     *  must be invalidated. However in subclasses, especially Resizables,
     *  the layout bounds may not be defined to be the same as the geometric
     *  bounds. This is both useful and provides a very nice performance
     *  optimization for regions and controls. In this case, subclasses
     *  need some way to interpose themselves such that a call to
     *  NodeHelper.geomChanged() *does not* invalidate the layout bounds.
     *
     *  This interposition happens by providing the
     *  NodeHelper.notifyLayoutBoundsChanged function. The default implementation
     *  simply invalidates boundsInLocal. Subclasses (such as Region and
     *  Control) can override this function so that it does not invalidate
     *  the layout bounds.
     *
     *  An on invalidate trigger on layoutBounds handles kicking off the rest
     *  of the invalidate process for layoutBounds. Because the layout bounds
     *  define the pivot point, if scaleX, scaleY, or rotate contain
     *  non-identity values then whenever the layoutBounds change the
     *  transformed bounds also change. Finally, if this node's parent is
     *  a Region and if the Node is being managed by the Region, then
     *  we must call requestLayout on the Region whenever the layout bounds
     *  have changed.
     */

    /*
     * Invoked by subclasses whenever their geometric bounds have changed.
     * Because the default layout bounds is based on the node geometry, this
     * function will invoke NodeHelper.notifyLayoutBoundsChanged. The default
     * implementation of NodeHelper.notifyLayoutBoundsChanged() will simply invalidate
     * layoutBounds. Resizable subclasses will want to override this function
     * in most cases to be a no-op.
     *
     * This function will also invalidate the cached geom bounds, and then
     * invoke localBoundsChanged() which will eventually end up invoking a
     * chain of functions up the tree to ensure that each parent of this
     * Node is notified that its bounds may have also changed.
     *
     * This function should be treated as though it were final. It is not
     * intended to be overridden by subclasses.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doGeomChanged() {
        if (geomBoundsInvalid) {
            // GeomBoundsInvalid is false when node geometry changed and
            // the untransformed node bounds haven't been recalculated yet.
            // Most of the time, the recalculation of layout and transformed
            // node bounds don't require validation of untransformed bounds
            // and so we can not skip the following notifications.
            NodeHelper.notifyLayoutBoundsChanged(this);
            transformedBoundsChanged();
            return;
        }
        geomBounds.makeEmpty();
        geomBoundsInvalid = true;
        NodeHelper.markDirty(this, DirtyBits.NODE_BOUNDS);
        NodeHelper.notifyLayoutBoundsChanged(this);
        localBoundsChanged();
    }

    private boolean geomBoundsInvalid = true;
    private boolean localBoundsInvalid = true;
    private boolean txBoundsInvalid = true;

    /**
     * Responds to changes in the local bounds by invalidating boundsInLocal
     * and notifying this node that its transformed bounds have changed.
     */
    void localBoundsChanged() {
        localBoundsInvalid = true;
        invalidateBoundsInLocal();
        transformedBoundsChanged();
    }

    /**
     * Responds to changes in the transformed bounds by invalidating txBounds
     * and boundsInParent. If this Node is not visible, then we have no need
     * to walk further up the tree but can instead simply invalidate state.
     * Otherwise, this function will notify parents (either the parent or the
     * clipParent) that this child Node's bounds have changed.
     */
    void transformedBoundsChanged() {
        if (!txBoundsInvalid) {
            txBounds.makeEmpty();
            txBoundsInvalid = true;
            invalidateBoundsInParent();
            NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORMED_BOUNDS);
        }
        if (isVisible()) {
            notifyParentOfBoundsChange();
        }
    }

    /*
     * Invoked by geomChanged(). Since layoutBounds is by default based
     * on the geometric bounds, the default implementation of this function will
     * invalidate the layoutBounds. Resizable Node subclasses generally base
     * layoutBounds on the width/height instead of the geometric bounds, and so
     * will generally want to override this function to be a no-op.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doNotifyLayoutBoundsChanged() {
        layoutBoundsChanged();
        // notify the parent
        // Group instanceof check a little hoaky, but it allows us to disable
        // unnecessary layout for the case of a non-resizable within a group
        Parent p = getParent();

        // Need to propagate layout if parent isn't part of performing layout
        if (isManaged() &amp;&amp; (p != null) &amp;&amp; !(p instanceof Group &amp;&amp; !isResizable())
                &amp;&amp; !p.isPerformingLayout()) {
            // Force its parent to fix the layout since it is a managed child.
            p.requestLayout(true);
        }
    }

    /**
     * Notifies both the real parent and the clip parent (if they exist) that
     * the bounds of the child has changed. Note that since FX doesn't throw
     * NPE's, things actually are faster if we don't check twice for Null
     * (we check once, the compiler checks again)
     */
    void notifyParentOfBoundsChange() {
        // let the parent know which node has changed and the parent will
        // deal with marking itself invalid correctly
        Parent p = getParent();
        if (p != null) {
            p.childBoundsChanged(this);
        }
        // since the clip is used to compute the local bounds (and not the
        // geom bounds), we just need to notify that local bounds on the
        // clip parent have changed
        if (clipParent != null) {
            clipParent.localBoundsChanged();
        }
    }

    /***************************************************************************
     *                                                                         *
     * Geometry and coordinate system related APIs. For example, methods       *
     * related to containment, intersection, coordinate space conversion, etc. *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns {@code true} if the given point (specified in the local
     * coordinate space of this {@code Node}) is contained within the shape of
     * this {@code Node}. Note that this method does not take visibility into
     * account; the test is based on the geometry of this {@code Node} only.
     * @param localX the x coordinate of the point in Node's space
     * @param localY the y coordinate of the point in Node's space
     * @return the result of contains for this {@code Node}
     */
    public boolean contains(double localX, double localY) {
        if (containsBounds(localX, localY)) {
            return (isPickOnBounds() || NodeHelper.computeContains(this, localX, localY));
        }
        return false;
    }

    /*
     * This method only does the contains check based on the bounds, clip and
     * effect of this node, excluding its shape (or geometry).
     *
     * Returns true if the given point (specified in the local
     * coordinate space of this {@code Node}) is contained within the bounds,
     * clip and effect of this node.
     */
    private boolean containsBounds(double localX, double localY) {
        final TempState tempState = TempState.getInstance();
        BaseBounds tempBounds = tempState.bounds;

        // first, we do a quick test to see if the point is contained in
        // our local bounds. If so, then we will go the next step and check
        // the clip, effect, and geometry for containment.
        tempBounds = getLocalBounds(tempBounds,
                                    BaseTransform.IDENTITY_TRANSFORM);
        if (tempBounds.contains((float)localX, (float)localY)) {
            // if the clip is defined, then check it for containment, being
            // sure to convert from this node's local coordinate system
            // to the local coordinate system of the clip node
            if (getClip() != null) {
                tempState.point.x = (float)localX;
                tempState.point.y = (float)localY;
                try {
                    getClip().parentToLocal(tempState.point);
                } catch (NoninvertibleTransformException e) {
                    return false;
                }
                if (!getClip().contains(tempState.point.x, tempState.point.y)) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Returns {@code true} if the given point (specified in the local
     * coordinate space of this {@code Node}) is contained within the shape of
     * this {@code Node}. Note that this method does not take visibility into
     * account; the test is based on the geometry of this {@code Node} only.
     * @param localPoint the 2D point in Node's space
     * @return the result of contains for this {@code Node}
     */
    public boolean contains(Point2D localPoint) {
        return contains(localPoint.getX(), localPoint.getY());
    }

    /**
     * Returns {@code true} if the given rectangle (specified in the local
     * coordinate space of this {@code Node}) intersects the shape of this
     * {@code Node}. Note that this method does not take visibility into
     * account; the test is based on the geometry of this {@code Node} only.
     * The default behavior of this function is simply to check if the
     * given coordinates intersect with the local bounds.
     * @param localX the x coordinate of a rectangle in Node's space
     * @param localY the y coordinate of a rectangle in Node's space
     * @param localWidth the width of a rectangle in Node's space
     * @param localHeight the height of a rectangle in Node's space
     * @return the result of intersects for this {@code Node}
     */
    public boolean intersects(double localX, double localY, double localWidth, double localHeight) {
        BaseBounds tempBounds = TempState.getInstance().bounds;
        tempBounds = getLocalBounds(tempBounds,
                                    BaseTransform.IDENTITY_TRANSFORM);
        return tempBounds.intersects((float)localX,
                                     (float)localY,
                                     (float)localWidth,
                                     (float)localHeight);
    }

    /**
     * Returns {@code true} if the given bounds (specified in the local
     * coordinate space of this {@code Node}) intersects the shape of this
     * {@code Node}. Note that this method does not take visibility into
     * account; the test is based on the geometry of this {@code Node} only.
     * The default behavior of this function is simply to check if the
     * given coordinates intersect with the local bounds.
     * @param localBounds the bounds
     * @return the result of intersects for this {@code Node}
     */
    public boolean intersects(Bounds localBounds) {
        return intersects(localBounds.getMinX(), localBounds.getMinY(), localBounds.getWidth(), localBounds.getHeight());
    }

    /**
     * Transforms a point from the coordinate space of the {@link javafx.stage.Screen}
     * into the local coordinate space of this {@code Node}.
     * @param screenX x coordinate of a point on a Screen
     * @param screenY y coordinate of a point on a Screen
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     * @since JavaFX 8.0
     */
    public Point2D screenToLocal(double screenX, double screenY) {
        Scene scene = getScene();
        if (scene == null) return null;
        Window window = scene.getWindow();
        if (window == null) return null;

        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;

        tempPt.setLocation((float)(screenX - scene.getX() - window.getX()),
                           (float)(screenY - scene.getY() - window.getY()));

        final SubScene subScene = getSubScene();
        if (subScene != null) {
            final Point2D ssCoord = SceneUtils.sceneToSubScenePlane(subScene,
                    new Point2D(tempPt.x, tempPt.y));
            if (ssCoord == null) {
                return null;
            }
            tempPt.setLocation((float) ssCoord.getX(), (float) ssCoord.getY());
        }

        final Point3D ppIntersect =
                scene.getEffectiveCamera().pickProjectPlane(tempPt.x, tempPt.y);
        tempPt.setLocation((float) ppIntersect.getX(), (float) ppIntersect.getY());

        try {
            sceneToLocal(tempPt);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
        return new Point2D(tempPt.x, tempPt.y);
    }

    /**
     * Transforms a point from the coordinate space of the {@link javafx.stage.Screen}
     * into the local coordinate space of this {@code Node}.
     * @param screenPoint a point on a Screen
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     * @since JavaFX 8.0
     */
    public Point2D screenToLocal(Point2D screenPoint) {
        return screenToLocal(screenPoint.getX(), screenPoint.getY());
    }

    /**
     * Transforms a rectangle from the coordinate space of the
     * {@link javafx.stage.Screen} into the local coordinate space of this
     * {@code Node}. Returns reasonable result only in 2D space.
     * @param screenBounds bounds on a Screen
     * @return bounds in the local Node'space or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     * @since JavaFX 8.0
     */
    public Bounds screenToLocal(Bounds screenBounds) {
        final Point2D p1 = screenToLocal(screenBounds.getMinX(), screenBounds.getMinY());
        final Point2D p2 = screenToLocal(screenBounds.getMinX(), screenBounds.getMaxY());
        final Point2D p3 = screenToLocal(screenBounds.getMaxX(), screenBounds.getMinY());
        final Point2D p4 = screenToLocal(screenBounds.getMaxX(), screenBounds.getMaxY());

        return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
    }


    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #sceneToLocal(double, double)}.
     *
     * @param x the x coordinate
     * @param y the y coordinate
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return local coordinates of the point
     * @since JavaFX 8u40
     */
    public Point2D sceneToLocal(double x, double y, boolean rootScene) {
        if (!rootScene) {
            return sceneToLocal(x, y);
        }
        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;

        tempPt.setLocation((float)(x), (float)y);

        final SubScene subScene = getSubScene();
        if (subScene != null) {
            final Point2D ssCoord = SceneUtils.sceneToSubScenePlane(subScene,
                    new Point2D(tempPt.x, tempPt.y));
            if (ssCoord == null) {
                return null;
            }
            tempPt.setLocation((float) ssCoord.getX(), (float) ssCoord.getY());
        }

        try {
            sceneToLocal(tempPt);
            return new Point2D(tempPt.x, tempPt.y);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
    }

    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #sceneToLocal(javafx.geometry.Point2D)}.
     *
     * @param point the point
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return local coordinates of the point
     * @since JavaFX 8u40
     */
    public Point2D sceneToLocal(Point2D point, boolean rootScene) {
        return sceneToLocal(point.getX(), point.getY(), rootScene);
    }

    /**
     * Transforms a bounds from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * arguments are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #sceneToLocal(javafx.geometry.Bounds)}.
     * &lt;p&gt;
     *     Since 3D bounds cannot be converted with {@code rootScene} set to {@code true}, trying to convert 3D bounds will yield {@code null}.
     * &lt;/p&gt;
     * @param bounds the bounds
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return local coordinates of the bounds
     * @since JavaFX 8u40
     */
    public Bounds sceneToLocal(Bounds bounds, boolean rootScene) {
        if (!rootScene) {
            return sceneToLocal(bounds);
        }
        if (bounds.getMinZ() != 0 || bounds.getMaxZ() != 0) {
            return null;
        }
        final Point2D p1 = sceneToLocal(bounds.getMinX(), bounds.getMinY(), true);
        final Point2D p2 = sceneToLocal(bounds.getMinX(), bounds.getMaxY(), true);
        final Point2D p3 = sceneToLocal(bounds.getMaxX(), bounds.getMinY(), true);
        final Point2D p4 = sceneToLocal(bounds.getMaxX(), bounds.getMaxY(), true);

        return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
    }

    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     *
     * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     *
     * @param sceneX x coordinate of a point on a Scene
     * @param sceneY y coordinate of a point on a Scene
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     */
    public Point2D sceneToLocal(double sceneX, double sceneY) {
        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;
        tempPt.setLocation((float)sceneX, (float)sceneY);
        try {
            sceneToLocal(tempPt);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
        return new Point2D(tempPt.x, tempPt.y);
    }

    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     *
     * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     *
     * @param scenePoint a point on a Scene
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     */
    public Point2D sceneToLocal(Point2D scenePoint) {
        return sceneToLocal(scenePoint.getX(), scenePoint.getY());
    }

    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     *
     * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     *
     * @param scenePoint a point on a Scene
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     * @since JavaFX 8.0
     */
    public Point3D sceneToLocal(Point3D scenePoint) {
        return sceneToLocal(scenePoint.getX(), scenePoint.getY(), scenePoint.getZ());
    }

    /**
     * Transforms a point from the coordinate space of the scene
     * into the local coordinate space of this {@code Node}.
     *
     * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     *
     * @param sceneX x coordinate of a point on a Scene
     * @param sceneY y coordinate of a point on a Scene
     * @param sceneZ z coordinate of a point on a Scene
     * @return local Node's coordinates of the point or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     * @since JavaFX 8.0
     */
    public Point3D sceneToLocal(double sceneX, double sceneY, double sceneZ) {
        try {
            return sceneToLocal0(sceneX, sceneY, sceneZ);
        } catch (NoninvertibleTransformException ex) {
            return null;
        }
    }

    /**
     * Internal method to transform a point from scene to local coordinates.
     */
    private Point3D sceneToLocal0(double x, double y, double z) throws NoninvertibleTransformException {
        final com.sun.javafx.geom.Vec3d tempV3D =
                TempState.getInstance().vec3d;
        tempV3D.set(x, y, z);
        sceneToLocal(tempV3D);
        return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
    }

    /**
     * Transforms a rectangle from the coordinate space of the
     * scene into the local coordinate space of this
     * {@code Node}.
     *
     * Note that if this node is in a {@link SubScene}, the arguments should be in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     *
     * @param sceneBounds bounds on a Scene
     * @return bounds in the local Node'space or null if Node is not in a {@link Window}.
     * Null is also returned if the transformation from local to Scene is not invertible.
     */
    public Bounds sceneToLocal(Bounds sceneBounds) {
        // Do a quick update of localToParentTransform so that we can determine
        // if this tx is 2D transform
        updateLocalToParentTransform();
        if (localToParentTx.is2D() &amp;&amp; (sceneBounds.getMinZ() == 0) &amp;&amp; (sceneBounds.getMaxZ() == 0)) {
            Point2D p1 = sceneToLocal(sceneBounds.getMinX(), sceneBounds.getMinY());
            Point2D p2 = sceneToLocal(sceneBounds.getMaxX(), sceneBounds.getMinY());
            Point2D p3 = sceneToLocal(sceneBounds.getMaxX(), sceneBounds.getMaxY());
            Point2D p4 = sceneToLocal(sceneBounds.getMinX(), sceneBounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        try {
            Point3D p1 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMinY(), sceneBounds.getMinZ());
            Point3D p2 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMinY(), sceneBounds.getMaxZ());
            Point3D p3 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMaxY(), sceneBounds.getMinZ());
            Point3D p4 = sceneToLocal0(sceneBounds.getMinX(), sceneBounds.getMaxY(), sceneBounds.getMaxZ());
            Point3D p5 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMaxY(), sceneBounds.getMinZ());
            Point3D p6 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMaxY(), sceneBounds.getMaxZ());
            Point3D p7 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMinY(), sceneBounds.getMinZ());
            Point3D p8 = sceneToLocal0(sceneBounds.getMaxX(), sceneBounds.getMinY(), sceneBounds.getMaxZ());
            return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its {@link javafx.stage.Screen}.
     * @param localX x coordinate of a point in Node's space
     * @param localY y coordinate of a point in Node's space
     * @return screen coordinates of the point or null if Node is not in a {@link Window}
     * @since JavaFX 8.0
     */
    public Point2D localToScreen(double localX, double localY) {
        return localToScreen(localX, localY, 0.0);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its {@link javafx.stage.Screen}.
     * @param localPoint a point in Node's space
     * @return screen coordinates of the point or null if Node is not in a {@link Window}
     * @since JavaFX 8.0
     */
    public Point2D localToScreen(Point2D localPoint) {
        return localToScreen(localPoint.getX(), localPoint.getY());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its {@link javafx.stage.Screen}.
     * @param localX x coordinate of a point in Node's space
     * @param localY y coordinate of a point in Node's space
     * @param localZ z coordinate of a point in Node's space
     * @return screen coordinates of the point or null if Node is not in a {@link Window}
     * @since JavaFX 8.0
     */
    public Point2D localToScreen(double localX, double localY, double localZ) {
        Scene scene = getScene();
        if (scene == null) return null;
        Window window = scene.getWindow();
        if (window == null) return null;

        Point3D pt = localToScene(localX, localY, localZ);
        final SubScene subScene = getSubScene();
        if (subScene != null) {
            pt = SceneUtils.subSceneToScene(subScene, pt);
        }
        final Point2D projection = CameraHelper.project(
                SceneHelper.getEffectiveCamera(getScene()), pt);

        return new Point2D(projection.getX() + scene.getX() + window.getX(),
                           projection.getY() + scene.getY() + window.getY());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its {@link javafx.stage.Screen}.
     * @param localPoint a point in Node's space
     * @return screen coordinates of the point or null if Node is not in a {@link Window}
     * @since JavaFX 8.0
     */
    public Point2D localToScreen(Point3D localPoint) {
        return localToScreen(localPoint.getX(), localPoint.getY(), localPoint.getZ());
    }

    /**
     * Transforms a bounds from the local coordinate space of this
     * {@code Node} into the coordinate space of its {@link javafx.stage.Screen}.
     * @param localBounds bounds in Node's space
     * @return the bounds in screen coordinates or null if Node is not in a {@link Window}
     * @since JavaFX 8.0
     */
    public Bounds localToScreen(Bounds localBounds) {
        final Point2D p1 = localToScreen(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
        final Point2D p2 = localToScreen(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
        final Point2D p3 = localToScreen(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
        final Point2D p4 = localToScreen(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
        final Point2D p5 = localToScreen(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
        final Point2D p6 = localToScreen(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
        final Point2D p7 = localToScreen(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
        final Point2D p8 = localToScreen(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());

        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     * @param localX x coordinate of a point in Node's space
     * @param localY y coordinate of a point in Node's space
     * @return scene coordinates of the point or null if Node is not in a {@link Window}
     */
    public Point2D localToScene(double localX, double localY) {
        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;
        tempPt.setLocation((float)localX, (float)localY);
        localToScene(tempPt);
        return new Point2D(tempPt.x, tempPt.y);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     * @param localPoint a point in Node's space
     * @return scene coordinates of the point or null if Node is not in a {@link Window}
     */
    public Point2D localToScene(Point2D localPoint) {
        return localToScene(localPoint.getX(), localPoint.getY());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     * @param localPoint a 3D point in Node's space
     * @return the transformed 3D point in Scene's space
     * @see #localToScene(javafx.geometry.Point3D, boolean)
     * @since JavaFX 8.0
     */
    public Point3D localToScene(Point3D localPoint) {
        return localToScene(localPoint.getX(), localPoint.getY(), localPoint.getZ());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     * @param x the x coordinate of a point in Node's space
     * @param y the y coordinate of a point in Node's space
     * @param z the z coordinate of a point in Node's space
     * @return the transformed 3D point in Scene's space
     * @see #localToScene(double, double, double, boolean)
     * @since JavaFX 8.0
     */
    public Point3D localToScene(double x, double y, double z) {
        final com.sun.javafx.geom.Vec3d tempV3D =
                TempState.getInstance().vec3d;
        tempV3D.set(x, y, z);
        localToScene(tempV3D);
        return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #localToScene(javafx.geometry.Point3D)}.
     *
     * @param localPoint the point in local coordinates
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return transformed point
     *
     * @see #localToScene(javafx.geometry.Point3D)
     * @since JavaFX 8u40
     */
    public Point3D localToScene(Point3D localPoint, boolean rootScene) {
        Point3D pt = localToScene(localPoint);
        if (rootScene) {
            final SubScene subScene = getSubScene();
            if (subScene != null) {
                pt = SceneUtils.subSceneToScene(subScene, pt);
            }
        }
        return pt;
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #localToScene(double, double, double)}.
     *
     * @param x the x coordinate of the point in local coordinates
     * @param y the y coordinate of the point in local coordinates
     * @param z the z coordinate of the point in local coordinates
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return transformed point
     *
     * @see #localToScene(double, double, double)
     * @since JavaFX 8u40
     */
    public Point3D localToScene(double x, double y, double z, boolean rootScene) {
        return localToScene(new Point3D(x, y, z), rootScene);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #localToScene(javafx.geometry.Point2D)}.
     *
     * @param localPoint the point in local coordinates
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return transformed point
     *
     * @see #localToScene(javafx.geometry.Point2D)
     * @since JavaFX 8u40
     */
    public Point2D localToScene(Point2D localPoint, boolean rootScene) {
        if (!rootScene) {
            return localToScene(localPoint);
        }
        Point3D pt = localToScene(localPoint.getX(), localPoint.getY(), 0, rootScene);
        return new Point2D(pt.getX(), pt.getY());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * result point is in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #localToScene(double, double)}.
     *
     * @param x the x coordinate of the point in local coordinates
     * @param y the y coordinate of the point in local coordinates
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return transformed point
     *
     * @see #localToScene(double, double)
     * @since JavaFX 8u40
     */
    public Point2D localToScene(double x, double y, boolean rootScene) {
        return localToScene(new Point2D(x, y), rootScene);
    }

    /**
     * Transforms a bounds from the local coordinate space of this {@code Node}
     * into the coordinate space of its scene.
     * If the Node does not have any {@link SubScene} or {@code rootScene} is set to true, the
     * result bounds are in {@link Scene} coordinates of the Node returned by {@link #getScene()}.
     * Otherwise, the subscene coordinates are used, which is equivalent to calling
     * {@link #localToScene(javafx.geometry.Bounds)}.
     *
     * @param localBounds the bounds in local coordinates
     * @param rootScene whether Scene coordinates should be used even if the Node is in a SubScene
     * @return transformed bounds
     *
     * @see #localToScene(javafx.geometry.Bounds)
     * @since JavaFX 8u40
     */
    public Bounds localToScene(Bounds localBounds, boolean rootScene) {
        if (!rootScene) {
            return localToScene(localBounds);
        }
        Point3D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ(), true);
        Point3D p2 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ(), true);
        Point3D p3 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ(), true);
        Point3D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ(), true);
        Point3D p5 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ(), true);
        Point3D p6 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ(), true);
        Point3D p7 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ(), true);
        Point3D p8 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ(), true);
        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
    }

    /**
     * Transforms a bounds from the local coordinate space of this
     * {@code Node} into the coordinate space of its scene.
     * Note that if this node is in a {@link SubScene}, the result is in the subscene coordinates,
     * not that of {@link javafx.scene.Scene}.
     * @param localBounds bounds in Node's space
     * @return the bounds in the scene coordinates or null if Node is not in a {@link Window}
     * @see #localToScene(javafx.geometry.Bounds, boolean)
     */
    public Bounds localToScene(Bounds localBounds) {
        // Do a quick update of localToParentTransform so that we can determine
        // if this tx is 2D transform
        updateLocalToParentTransform();
        if (localToParentTx.is2D() &amp;&amp; (localBounds.getMinZ() == 0) &amp;&amp; (localBounds.getMaxZ() == 0)) {
            Point2D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY());
            Point2D p2 = localToScene(localBounds.getMaxX(), localBounds.getMinY());
            Point2D p3 = localToScene(localBounds.getMaxX(), localBounds.getMaxY());
            Point2D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        Point3D p1 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
        Point3D p2 = localToScene(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
        Point3D p3 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
        Point3D p4 = localToScene(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
        Point3D p5 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
        Point3D p6 = localToScene(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
        Point3D p7 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
        Point3D p8 = localToScene(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());
        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);

    }

    /**
     * Transforms a point from the coordinate space of the parent into the
     * local coordinate space of this {@code Node}.
     * @param parentX the x coordinate in Parent's space
     * @param parentY the y coordinate in Parent's space
     * @return the transformed 2D point in Node's space
     */
    public Point2D parentToLocal(double parentX, double parentY) {
        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;
        tempPt.setLocation((float)parentX, (float)parentY);
        try {
            parentToLocal(tempPt);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
        return new Point2D(tempPt.x, tempPt.y);
    }

    /**
     * Transforms a point from the coordinate space of the parent into the
     * local coordinate space of this {@code Node}.
     * @param parentPoint the 2D point in Parent's space
     * @return the transformed 2D point in Node's space
     */
    public Point2D parentToLocal(Point2D parentPoint) {
        return parentToLocal(parentPoint.getX(), parentPoint.getY());
    }

    /**
     * Transforms a point from the coordinate space of the parent into the
     * local coordinate space of this {@code Node}.
     * @param parentPoint parentPoint the 3D point in Parent's space
     * @return the transformed 3D point in Node's space
     * @since JavaFX 8.0
     */
    public Point3D parentToLocal(Point3D parentPoint) {
        return parentToLocal(parentPoint.getX(), parentPoint.getY(), parentPoint.getZ());
    }

    /**
     * Transforms a point from the coordinate space of the parent into the
     * local coordinate space of this {@code Node}.
     * @param parentX the x coordinate in Parent's space
     * @param parentY the y coordinate in Parent's space
     * @param parentZ the z coordinate in Parent's space
     * @return the transformed 3D point in Node's space
     * @since JavaFX 8.0
     */
    public Point3D parentToLocal(double parentX, double parentY, double parentZ) {
        final com.sun.javafx.geom.Vec3d tempV3D =
                TempState.getInstance().vec3d;
        tempV3D.set(parentX, parentY, parentZ);
        try {
            parentToLocal(tempV3D);
        } catch (NoninvertibleTransformException e) {
            return null;
        }
        return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
    }

    /**
     * Transforms a rectangle from the coordinate space of the parent into the
     * local coordinate space of this {@code Node}.
     * @param parentBounds the bounds in Parent's space
     * @return the transformed bounds in Node's space
     */
    public Bounds parentToLocal(Bounds parentBounds) {
        // Do a quick update of localToParentTransform so that we can determine
        // if this tx is 2D transform
        updateLocalToParentTransform();
        if (localToParentTx.is2D() &amp;&amp; (parentBounds.getMinZ() == 0) &amp;&amp; (parentBounds.getMaxZ() == 0)) {
            Point2D p1 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY());
            Point2D p2 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY());
            Point2D p3 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY());
            Point2D p4 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        Point3D p1 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY(), parentBounds.getMinZ());
        Point3D p2 = parentToLocal(parentBounds.getMinX(), parentBounds.getMinY(), parentBounds.getMaxZ());
        Point3D p3 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY(), parentBounds.getMinZ());
        Point3D p4 = parentToLocal(parentBounds.getMinX(), parentBounds.getMaxY(), parentBounds.getMaxZ());
        Point3D p5 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY(), parentBounds.getMinZ());
        Point3D p6 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMaxY(), parentBounds.getMaxZ());
        Point3D p7 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY(), parentBounds.getMinZ());
        Point3D p8 = parentToLocal(parentBounds.getMaxX(), parentBounds.getMinY(), parentBounds.getMaxZ());
        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its parent.
     * @param localX the x coordinate of the point in Node's space
     * @param localY the y coordinate of the point in Node's space
     * @return the transformed 2D point in Parent's space
     */
    public Point2D localToParent(double localX, double localY) {
        final com.sun.javafx.geom.Point2D tempPt =
                TempState.getInstance().point;
        tempPt.setLocation((float)localX, (float)localY);
        localToParent(tempPt);
        return new Point2D(tempPt.x, tempPt.y);
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its parent.
     * @param localPoint the 2D point in Node's space
     * @return the transformed 2D point in Parent's space
     */
    public Point2D localToParent(Point2D localPoint) {
        return localToParent(localPoint.getX(), localPoint.getY());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its parent.
     * @param localPoint the 3D point in Node's space
     * @return the transformed 3D point in Parent's space
     * @since JavaFX 8.0
     */
    public Point3D localToParent(Point3D localPoint) {
        return localToParent(localPoint.getX(), localPoint.getY(), localPoint.getZ());
    }

    /**
     * Transforms a point from the local coordinate space of this {@code Node}
     * into the coordinate space of its parent.
     * @param x the x coordinate of the point in Node's space
     * @param y the y coordinate of the point in Node's space
     * @param z the z coordinate of the point in Node's space
     * @return the transformed 3D point in Parent's space
     * @since JavaFX 8.0
     */
    public Point3D localToParent(double x, double y, double z) {
        final com.sun.javafx.geom.Vec3d tempV3D =
                TempState.getInstance().vec3d;
        tempV3D.set(x, y, z);
        localToParent(tempV3D);
        return new Point3D(tempV3D.x, tempV3D.y, tempV3D.z);
    }

    /**
     * Transforms a bounds from the local coordinate space of this
     * {@code Node} into the coordinate space of its parent.
     * @param localBounds the bounds in Node's space
     * @return the transformed bounds in Parent's space
     */
    public Bounds localToParent(Bounds localBounds) {
        // Do a quick update of localToParentTransform so that we can determine
        // if this tx is 2D transform
        updateLocalToParentTransform();
        if (localToParentTx.is2D() &amp;&amp; (localBounds.getMinZ() == 0) &amp;&amp; (localBounds.getMaxZ() == 0)) {
            Point2D p1 = localToParent(localBounds.getMinX(), localBounds.getMinY());
            Point2D p2 = localToParent(localBounds.getMaxX(), localBounds.getMinY());
            Point2D p3 = localToParent(localBounds.getMaxX(), localBounds.getMaxY());
            Point2D p4 = localToParent(localBounds.getMinX(), localBounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        Point3D p1 = localToParent(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMinZ());
        Point3D p2 = localToParent(localBounds.getMinX(), localBounds.getMinY(), localBounds.getMaxZ());
        Point3D p3 = localToParent(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMinZ());
        Point3D p4 = localToParent(localBounds.getMinX(), localBounds.getMaxY(), localBounds.getMaxZ());
        Point3D p5 = localToParent(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMinZ());
        Point3D p6 = localToParent(localBounds.getMaxX(), localBounds.getMaxY(), localBounds.getMaxZ());
        Point3D p7 = localToParent(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMinZ());
        Point3D p8 = localToParent(localBounds.getMaxX(), localBounds.getMinY(), localBounds.getMaxZ());
        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
    }

    /**
     * Copy the localToParent transform into specified transform.
     */
    BaseTransform getLocalToParentTransform(BaseTransform tx) {
        updateLocalToParentTransform();
        tx.setTransform(localToParentTx);
        return tx;
    }

    /*
     * Currently used only by PathTransition
     */
    final BaseTransform getLeafTransform() {
        return getLocalToParentTransform(TempState.getInstance().leafTx);
    }

    /*
     * Invoked whenever the transforms[] ObservableList changes, or by the transforms
     * in that ObservableList whenever they are changed.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doTransformsChanged() {
        if (!transformDirty) {
            NodeHelper.markDirty(this, DirtyBits.NODE_TRANSFORM);
            transformDirty = true;
            transformedBoundsChanged();
        }
        invalidateLocalToParentTransform();
        invalidateLocalToSceneTransform();
    }

    final double getPivotX() {
        final Bounds bounds = getLayoutBounds();
        return bounds.getMinX() + bounds.getWidth()/2;
    }

    final double getPivotY() {
        final Bounds bounds = getLayoutBounds();
        return bounds.getMinY() + bounds.getHeight()/2;
    }

    final double getPivotZ() {
        final Bounds bounds = getLayoutBounds();
        return bounds.getMinZ() + bounds.getDepth()/2;
    }

    /**
     * This helper function will update the transform matrix on the peer based
     * on the &quot;complete&quot; transform for this node.
     */
    void updateLocalToParentTransform() {
        if (transformDirty) {
            localToParentTx.setToIdentity();

            boolean mirror = false;
            double mirroringCenter = 0;
            if (hasMirroring()) {
                final Scene sceneValue = getScene();
                if ((sceneValue != null) &amp;&amp; (sceneValue.getRoot() == this)) {
                    // handle scene mirroring in this branch
                    // (must be the last transformation)
                    mirroringCenter = sceneValue.getWidth() / 2;
                    if (mirroringCenter == 0.0) {
                        mirroringCenter = getPivotX();
                    }

                    localToParentTx = localToParentTx.deriveWithTranslation(
                            mirroringCenter, 0.0);
                    localToParentTx = localToParentTx.deriveWithScale(
                            -1.0, 1.0, 1.0);
                    localToParentTx = localToParentTx.deriveWithTranslation(
                            -mirroringCenter, 0.0);
                } else {
                    // mirror later
                    mirror = true;
                    mirroringCenter = getPivotX();
                }
            }

            if (getScaleX() != 1 || getScaleY() != 1 || getScaleZ() != 1 || getRotate() != 0) {
                // recompute pivotX, pivotY and pivotZ
                double pivotX = getPivotX();
                double pivotY = getPivotY();
                double pivotZ = getPivotZ();

                localToParentTx = localToParentTx.deriveWithTranslation(
                        getTranslateX() + getLayoutX() + pivotX,
                        getTranslateY() + getLayoutY() + pivotY,
                        getTranslateZ() + pivotZ);
                localToParentTx = localToParentTx.deriveWithRotation(
                        Math.toRadians(getRotate()), getRotationAxis().getX(),
                        getRotationAxis().getY(), getRotationAxis().getZ());
                localToParentTx = localToParentTx.deriveWithScale(
                        getScaleX(), getScaleY(), getScaleZ());
                localToParentTx = localToParentTx.deriveWithTranslation(
                        -pivotX, -pivotY, -pivotZ);
            } else {
                localToParentTx = localToParentTx.deriveWithTranslation(
                        getTranslateX() + getLayoutX(),
                        getTranslateY() + getLayoutY(),
                        getTranslateZ());
            }

            if (hasTransforms()) {
                for (Transform t : getTransforms()) {
                    localToParentTx = TransformHelper.derive(t, localToParentTx);
                }
            }

            // Check to see whether the node requires mirroring
            if (mirror) {
                localToParentTx = localToParentTx.deriveWithTranslation(
                        mirroringCenter, 0);
                localToParentTx = localToParentTx.deriveWithScale(
                        -1.0, 1.0, 1.0);
                localToParentTx = localToParentTx.deriveWithTranslation(
                        -mirroringCenter, 0);
            }

            transformDirty = false;
        }
    }

    /**
     * Transforms in place the specified point from parent coords to local
     * coords. Made package private for the sake of testing.
     */
    void parentToLocal(com.sun.javafx.geom.Point2D pt) throws NoninvertibleTransformException {
        updateLocalToParentTransform();
        localToParentTx.inverseTransform(pt, pt);
    }

    void parentToLocal(com.sun.javafx.geom.Vec3d pt) throws NoninvertibleTransformException {
        updateLocalToParentTransform();
        localToParentTx.inverseTransform(pt, pt);
    }

    void sceneToLocal(com.sun.javafx.geom.Point2D pt) throws NoninvertibleTransformException {
        if (getParent() != null) {
            getParent().sceneToLocal(pt);
        }
        parentToLocal(pt);
<A NAME="44"></A>    }

    void sceneToLocal(com.sun.javafx.geom.Vec3d pt) throws NoninvertibleTransformException {
        if (<FONT color="#e57ded"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#44',2,'match37-top.html#44',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getParent() != null) {
            getParent().sceneToLocal(pt);
        }
        parentToLocal(pt);
    }

    void localToScene(com.sun.javafx.geom.Point2D pt) {
        localToParent</B></FONT>(pt);
        if (getParent() != null) {
            getParent().localToScene(pt);
        }
    }

    void localToScene(com.sun.javafx.geom.Vec3d pt) {
        localToParent(pt);
        if (getParent() != null) {
            getParent().localToScene(pt);
        }
    }

    /***************************************************************************
     *                                                                         *
     * Mouse event related APIs                                                *
     *                                                                         *
     **************************************************************************/

    /**
     * Transforms in place the specified point from local coords to parent
     * coords. Made package private for the sake of testing.
     */
    void localToParent(com.sun.javafx.geom.Point2D pt) {
        updateLocalToParentTransform();
        localToParentTx.transform(pt, pt);
    }

    void localToParent(com.sun.javafx.geom.Vec3d pt) {
        updateLocalToParentTransform();
        localToParentTx.transform(pt, pt);
    }

    /*
     * Finds a top-most child node that contains the given local coordinates.
     *
     * The result argument is used for storing the picking result.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doPickNodeLocal(PickRay localPickRay, PickResultChooser result) {
        intersects(localPickRay, result);
    }

    /*
     * Finds a top-most child node that intersects the given ray.
     *
     * The result argument is used for storing the picking result.
     */
    final void pickNode(PickRay pickRay, PickResultChooser result) {

        // In some conditions we can omit picking this node or subgraph
        if (!isVisible() || isDisable() || isMouseTransparent()) {
            return;
        }

        final Vec3d o = pickRay.getOriginNoClone();
        final double ox = o.x;
        final double oy = o.y;
        final double oz = o.z;
        final Vec3d d = pickRay.getDirectionNoClone();
        final double dx = d.x;
        final double dy = d.y;
        final double dz = d.z;

        updateLocalToParentTransform();
        try {
            localToParentTx.inverseTransform(o, o);
            localToParentTx.inverseDeltaTransform(d, d);

            // Delegate to a function which can be overridden by subclasses which
            // actually does the pick. The implementation is markedly different
            // for leaf nodes vs. parent nodes vs. region nodes.
            NodeHelper.pickNodeLocal(this, pickRay, result);
        } catch (NoninvertibleTransformException e) {
            // in this case we just don't pick anything
        }

        pickRay.setOrigin(ox, oy, oz);
        pickRay.setDirection(dx, dy, dz);
    }

    /*
     * Returns {@code true} if the given ray (start, dir), specified in the
     * local coordinate space of this {@code Node}, intersects the
     * shape of this {@code Node}. Note that this method does not take visibility
     * into account; the test is based on the geometry of this {@code Node} only.
     * &lt;p&gt;
     * The pickResult is updated if the found intersection is closer than
     * the currently held one.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     */
    final boolean intersects(PickRay pickRay, PickResultChooser pickResult) {
        double boundsDistance = intersectsBounds(pickRay);
        if (!Double.isNaN(boundsDistance)) {
            if (isPickOnBounds()) {
                if (pickResult != null) {
                    pickResult.offer(this, boundsDistance, PickResultChooser.computePoint(pickRay, boundsDistance));
                }
                return true;
            } else {
                return NodeHelper.computeIntersects(this, pickRay, pickResult);
            }
        }
        return false;
    }

    /*
     * Computes the intersection of the pickRay with this node.
     * The pickResult argument is updated if the found intersection
     * is closer than the passed one. On the other hand, the return value
     * specifies whether the intersection exists, regardless of its comparison
     * with the given pickResult.
     */
    private boolean doComputeIntersects(PickRay pickRay, PickResultChooser pickResult) {
        double origZ = pickRay.getOriginNoClone().z;
        double dirZ = pickRay.getDirectionNoClone().z;
        // Handle the case where pickRay is almost parallel to the Z-plane
        if (almostZero(dirZ)) {
            return false;
        }
        double t = -origZ / dirZ;
        if (t &lt; pickRay.getNearClip() || t &gt; pickRay.getFarClip()) {
            return false;
        }
        double x = pickRay.getOriginNoClone().x + (pickRay.getDirectionNoClone().x * t);
        double y = pickRay.getOriginNoClone().y + (pickRay.getDirectionNoClone().y * t);

        if (contains((float) x, (float) y)) {
            if (pickResult != null) {
                pickResult.offer(this, t, PickResultChooser.computePoint(pickRay, t));
            }
            return true;
        }
        return false;
    }

    /*
     * Computes the intersection of the pickRay with the bounds of this node.
     * The return value is the distance between the camera and the intersection
     * point, measured in pickRay direction magnitudes. If there is
     * no intersection, it returns NaN.
     *
     * @param pickRay The pick ray
     * @return Distance of the intersection point, a NaN if there
     *         is no intersection
     */
    final double intersectsBounds(PickRay pickRay) {

        final Vec3d dir = pickRay.getDirectionNoClone();
        double tmin, tmax;

        final Vec3d origin = pickRay.getOriginNoClone();
        final double originX = origin.x;
        final double originY = origin.y;
        final double originZ = origin.z;

        final TempState tempState = TempState.getInstance();
        BaseBounds tempBounds = tempState.bounds;

        tempBounds = getLocalBounds(tempBounds,
                                    BaseTransform.IDENTITY_TRANSFORM);

        if (dir.x == 0.0 &amp;&amp; dir.y == 0.0) {
            // fast path for the usual 2D picking

            if (dir.z == 0.0) {
                return Double.NaN;
            }

            if (originX &lt; tempBounds.getMinX() ||
                    originX &gt; tempBounds.getMaxX() ||
                    originY &lt; tempBounds.getMinY() ||
                    originY &gt; tempBounds.getMaxY()) {
                return Double.NaN;
            }

            final double invDirZ = 1.0 / dir.z;
            final boolean signZ = invDirZ &lt; 0.0;

            final double minZ = tempBounds.getMinZ();
            final double maxZ = tempBounds.getMaxZ();
            tmin = ((signZ ? maxZ : minZ) - originZ) * invDirZ;
            tmax = ((signZ ? minZ : maxZ) - originZ) * invDirZ;

        } else if (tempBounds.getDepth() == 0.0) {
            // fast path for 3D picking of 2D bounds

            if (almostZero(dir.z)) {
                return Double.NaN;
            }

            final double t = (tempBounds.getMinZ() - originZ) / dir.z;
            final double x = originX + (dir.x * t);
            final double y = originY + (dir.y * t);

            if (x &lt; tempBounds.getMinX() ||
                    x &gt; tempBounds.getMaxX() ||
                    y &lt; tempBounds.getMinY() ||
                    y &gt; tempBounds.getMaxY()) {
                return Double.NaN;
            }

            tmin = tmax = t;

        } else {

            final double invDirX = dir.x == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.x);
            final double invDirY = dir.y == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.y);
            final double invDirZ = dir.z == 0.0 ? Double.POSITIVE_INFINITY : (1.0 / dir.z);
            final boolean signX = invDirX &lt; 0.0;
            final boolean signY = invDirY &lt; 0.0;
            final boolean signZ = invDirZ &lt; 0.0;
            final double minX = tempBounds.getMinX();
            final double minY = tempBounds.getMinY();
            final double maxX = tempBounds.getMaxX();
            final double maxY = tempBounds.getMaxY();

            tmin = Double.NEGATIVE_INFINITY;
            tmax = Double.POSITIVE_INFINITY;
            if (Double.isInfinite(invDirX)) {
                if (minX &lt;= originX &amp;&amp; maxX &gt;= originX) {
                    // move on, we are inside for the whole length
                } else {
                    return Double.NaN;
                }
            } else {
                tmin = ((signX ? maxX : minX) - originX) * invDirX;
                tmax = ((signX ? minX : maxX) - originX) * invDirX;
            }

            if (Double.isInfinite(invDirY)) {
                if (minY &lt;= originY &amp;&amp; maxY &gt;= originY) {
                    // move on, we are inside for the whole length
                } else {
                    return Double.NaN;
                }
            } else {
                final double tymin = ((signY ? maxY : minY) - originY) * invDirY;
                final double tymax = ((signY ? minY : maxY) - originY) * invDirY;

                if ((tmin &gt; tymax) || (tymin &gt; tmax)) {
                    return Double.NaN;
                }
                if (tymin &gt; tmin) {
                    tmin = tymin;
                }
                if (tymax &lt; tmax) {
                    tmax = tymax;
                }
            }

            final double minZ = tempBounds.getMinZ();
            final double maxZ = tempBounds.getMaxZ();
            if (Double.isInfinite(invDirZ)) {
                if (minZ &lt;= originZ &amp;&amp; maxZ &gt;= originZ) {
                    // move on, we are inside for the whole length
                } else {
                    return Double.NaN;
                }
            } else {
                final double tzmin = ((signZ ? maxZ : minZ) - originZ) * invDirZ;
                final double tzmax = ((signZ ? minZ : maxZ) - originZ) * invDirZ;

                if ((tmin &gt; tzmax) || (tzmin &gt; tmax)) {
                    return Double.NaN;
                }
                if (tzmin &gt; tmin) {
                    tmin = tzmin;
                }
                if (tzmax &lt; tmax) {
                    tmax = tzmax;
                }
            }
        }

        // For clip we use following semantics: pick the node normally
        // if there is an intersection with the clip node. We don't consider
        // clip node distance.
        Node clip = getClip();
        if (clip != null
                // FIXME: All 3D picking is currently ignored by rendering.
                // Until this is fixed or defined differently (RT-28510),
                // we follow this behavior.
                &amp;&amp; !(this instanceof Shape3D) &amp;&amp; !(clip instanceof Shape3D)) {
            final double dirX = dir.x;
            final double dirY = dir.y;
            final double dirZ = dir.z;

            clip.updateLocalToParentTransform();

            boolean hitClip = true;
            try {
                clip.localToParentTx.inverseTransform(origin, origin);
                clip.localToParentTx.inverseDeltaTransform(dir, dir);
            } catch (NoninvertibleTransformException e) {
                hitClip = false;
            }
            hitClip = hitClip &amp;&amp; clip.intersects(pickRay, null);
            pickRay.setOrigin(originX, originY, originZ);
            pickRay.setDirection(dirX, dirY, dirZ);

            if (!hitClip) {
                return Double.NaN;
            }
        }

        if (Double.isInfinite(tmin) || Double.isNaN(tmin)) {
            // We've got a nonsense pick ray or bounds.
            return Double.NaN;
        }

        final double minDistance = pickRay.getNearClip();
        final double maxDistance = pickRay.getFarClip();
        if (tmin &lt; minDistance) {
            if (tmax &gt;= minDistance) {
                // we are inside bounds
                return 0.0;
            } else {
                return Double.NaN;
            }
        } else if (tmin &gt; maxDistance) {
            return Double.NaN;
        }

        return tmin;
    }


    // Good to find a home for commonly use util. code such as EPS.
    // and almostZero. This code currently defined in multiple places,
    // such as Affine3D and GeneralTransform3D.
    private static final double EPSILON_ABSOLUTE = 1.0e-5;

    static boolean almostZero(double a) {
        return ((a &lt; EPSILON_ABSOLUTE) &amp;&amp; (a &gt; -EPSILON_ABSOLUTE));
    }

    /***************************************************************************
     *                                                                         *
     *                      viewOrder property handling                        *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines the rendering and picking order of this {@code Node} within its
     * parent.
     * &lt;p&gt;
     * This property is used to alter the rendering and picking order of a node
     * within its parent without reordering the parent's {@code children} list.
     * For example, this can be used as a more efficient way to implement
     * transparency sorting. To do this, an application can assign the viewOrder
     * value of each node to the computed distance between that node and the
     * viewer.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The parent will traverse its {@code children} in decreasing
     * {@code viewOrder} order. This means that a child with a lower
     * {@code viewOrder} will be in front of a child with a higher
     * {@code viewOrder}. If two children have the same {@code viewOrder}, the
     * parent will traverse them in the order they appear in the parent's
     * {@code children} list.
     * &lt;/p&gt;
     * &lt;p&gt;
     * However, {@code viewOrder} does not alter the layout and focus traversal
     * order of this Node within its parent. A parent always traverses its
     * {@code children} list in order when doing layout or focus traversal.
     * &lt;/p&gt;
     *
     * @return the view order for this {@code Node}
     * @defaultValue 0.0
     *
     * @since 9
     */
    public final DoubleProperty viewOrderProperty() {
        return getMiscProperties().viewOrderProperty();
    }

    public final void setViewOrder(double value) {
        viewOrderProperty().set(value);
    }

    public final double getViewOrder() {
        return (miscProperties == null) ? DEFAULT_VIEW_ORDER
                : miscProperties.getViewOrder();
    }

    /***************************************************************************
     *                                                                         *
     *                             Transformations                             *
     *                                                                         *
     **************************************************************************/
    /**
     * Defines the ObservableList of {@link javafx.scene.transform.Transform} objects
     * to be applied to this {@code Node}. This ObservableList of transforms is applied
     * before {@link #translateXProperty translateX}, {@link #translateYProperty translateY}, {@link #scaleXProperty scaleX}, and
     * {@link #scaleYProperty scaleY}, {@link #rotateProperty rotate} transforms.
     *
     * @return the transforms for this {@code Node}
     * @defaultValue empty
     */
    public final ObservableList&lt;Transform&gt; getTransforms() {
        return transformsProperty();
    }

    private ObservableList&lt;Transform&gt; transformsProperty() {
        return getNodeTransformation().getTransforms();
    }

    public final void setTranslateX(double value) {
        translateXProperty().set(value);
    }

    public final double getTranslateX() {
        return (nodeTransformation == null)
                ? DEFAULT_TRANSLATE_X
                : nodeTransformation.getTranslateX();
    }

    /**
     * Defines the x coordinate of the translation that is added to this {@code Node}'s
     * transform.
     * &lt;p&gt;
     * The node's final translation will be computed as {@link #layoutXProperty layoutX} + {@code translateX},
     * where {@code layoutX} establishes the node's stable position and {@code translateX}
     * optionally makes dynamic adjustments to that position.
     *&lt;p&gt;
     * This variable can be used to alter the location of a node without disturbing
     * its {@link #layoutBoundsProperty layoutBounds}, which makes it useful for animating a node's location.
     *
     * @return the translateX for this {@code Node}
     * @defaultValue 0
     */
    public final DoubleProperty translateXProperty() {
        return getNodeTransformation().translateXProperty();
    }

    public final void setTranslateY(double value) {
        translateYProperty().set(value);
    }

    public final double getTranslateY() {
        return (nodeTransformation == null)
                ? DEFAULT_TRANSLATE_Y
                : nodeTransformation.getTranslateY();
    }

    /**
     * Defines the y coordinate of the translation that is added to this {@code Node}'s
     * transform.
     * &lt;p&gt;
     * The node's final translation will be computed as {@link #layoutYProperty layoutY} + {@code translateY},
     * where {@code layoutY} establishes the node's stable position and {@code translateY}
     * optionally makes dynamic adjustments to that position.
     * &lt;p&gt;
     * This variable can be used to alter the location of a node without disturbing
     * its {@link #layoutBoundsProperty layoutBounds}, which makes it useful for animating a node's location.
     *
     * @return the translateY for this {@code Node}
     * @defaultValue 0
     */
    public final DoubleProperty translateYProperty() {
        return getNodeTransformation().translateYProperty();
    }

    public final void setTranslateZ(double value) {
        translateZProperty().set(value);
    }

    public final double getTranslateZ() {
        return (nodeTransformation == null)
                ? DEFAULT_TRANSLATE_Z
                : nodeTransformation.getTranslateZ();
    }

    /**
     * Defines the Z coordinate of the translation that is added to the
     * transformed coordinates of this {@code Node}.  This value will be added
     * to any translation defined by the {@code transforms} ObservableList and
     * {@code layoutZ}.
     * &lt;p&gt;
     * This variable can be used to alter the location of a Node without
     * disturbing its layout bounds, which makes it useful for animating a
     * node's location.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @return the translateZ for this {@code Node}
     * @defaultValue 0
     */
    public final DoubleProperty translateZProperty() {
        return getNodeTransformation().translateZProperty();
    }

    public final void setScaleX(double value) {
        scaleXProperty().set(value);
    }

    public final double getScaleX() {
        return (nodeTransformation == null) ? DEFAULT_SCALE_X
                                            : nodeTransformation.getScaleX();
    }

    /**
     * Defines the factor by which coordinates are scaled about the center of the
     * object along the X axis of this {@code Node}. This is used to stretch or
     * shrink the node either manually or by using an animation.
     * &lt;p&gt;
     * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
     * default, which makes it ideal for scaling the entire node after
     * all effects and transforms have been taken into account.
     * &lt;p&gt;
     * The pivot point about which the scale occurs is the center of the
     * untransformed {@link #layoutBoundsProperty layoutBounds}.
     *
     * @return the scaleX for this {@code Node}
     * @defaultValue 1.0
     */
    public final DoubleProperty scaleXProperty() {
        return getNodeTransformation().scaleXProperty();
    }

    public final void setScaleY(double value) {
        scaleYProperty().set(value);
    }

    public final double getScaleY() {
        return (nodeTransformation == null) ? DEFAULT_SCALE_Y
                                            : nodeTransformation.getScaleY();
    }

    /**
     * Defines the factor by which coordinates are scaled about the center of the
     * object along the Y axis of this {@code Node}. This is used to stretch or
     * shrink the node either manually or by using an animation.
     * &lt;p&gt;
     * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
     * default, which makes it ideal for scaling the entire node after
     * all effects and transforms have been taken into account.
     * &lt;p&gt;
     * The pivot point about which the scale occurs is the center of the
     * untransformed {@link #layoutBoundsProperty layoutBounds}.
     *
     * @return the scaleY for this {@code Node}
     * @defaultValue 1.0
     */
    public final DoubleProperty scaleYProperty() {
        return getNodeTransformation().scaleYProperty();
    }

    public final void setScaleZ(double value) {
        scaleZProperty().set(value);
    }

    public final double getScaleZ() {
        return (nodeTransformation == null) ? DEFAULT_SCALE_Z
                                            : nodeTransformation.getScaleZ();
    }

    /**
     * Defines the factor by which coordinates are scaled about the center of the
     * object along the Z axis of this {@code Node}. This is used to stretch or
     * shrink the node either manually or by using an animation.
     * &lt;p&gt;
     * This scale factor is not included in {@link #layoutBoundsProperty layoutBounds} by
     * default, which makes it ideal for scaling the entire node after
     * all effects and transforms have been taken into account.
     * &lt;p&gt;
     * The pivot point about which the scale occurs is the center of the
     * rectangular bounds formed by taking {@link #boundsInLocalProperty boundsInLocal} and applying
     * all the transforms in the {@link #getTransforms transforms} ObservableList.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @return the scaleZ for this {@code Node}
     * @defaultValue 1.0
     */
    public final DoubleProperty scaleZProperty() {
        return getNodeTransformation().scaleZProperty();
    }

    public final void setRotate(double value) {
        rotateProperty().set(value);
    }

    public final double getRotate() {
        return (nodeTransformation == null) ? DEFAULT_ROTATE
                                            : nodeTransformation.getRotate();
    }

    /**
     * Defines the angle of rotation about the {@code Node}'s center, measured in
     * degrees. This is used to rotate the {@code Node}.
     * &lt;p&gt;
     * This rotation factor is not included in {@link #layoutBoundsProperty layoutBounds} by
     * default, which makes it ideal for rotating the entire node after
     * all effects and transforms have been taken into account.
     * &lt;p&gt;
     * The pivot point about which the rotation occurs is the center of the
     * untransformed {@link #layoutBoundsProperty layoutBounds}.
     * &lt;p&gt;
     * Note that because the pivot point is computed as the center of this
     * {@code Node}'s layout bounds, any change to the layout bounds will cause
     * the pivot point to change, which can move the object. For a leaf node,
     * any change to the geometry will cause the layout bounds to change.
     * For a group node, any change to any of its children, including a
     * change in a child's geometry, clip, effect, position, orientation, or
     * scale, will cause the group's layout bounds to change. If this movement
     * of the pivot point is not
     * desired, applications should instead use the Node's {@link #getTransforms transforms}
     * ObservableList, and add a {@link javafx.scene.transform.Rotate} transform,
     * which has a user-specifiable pivot point.
     *
     * @return the rotate for this {@code Node}
     * @defaultValue 0.0
     */
    public final DoubleProperty rotateProperty() {
        return getNodeTransformation().rotateProperty();
    }

    public final void setRotationAxis(Point3D value) {
        rotationAxisProperty().set(value);
    }

    public final Point3D getRotationAxis() {
        return (nodeTransformation == null)
                ? DEFAULT_ROTATION_AXIS
                : nodeTransformation.getRotationAxis();
    }

    /**
     * Defines the axis of rotation of this {@code Node}.
     * &lt;p&gt;
     * Note that this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @return the rotationAxis for this {@code Node}
     * @defaultValue Rotate.Z_AXIS
     */
    public final ObjectProperty&lt;Point3D&gt; rotationAxisProperty() {
        return getNodeTransformation().rotationAxisProperty();
    }

    /**
     * An affine transform that holds the computed local-to-parent transform.
     * This is the concatenation of all transforms in this node, including all
     * of the convenience transforms.
     * @return the localToParent transform for this {@code Node}
     * @since JavaFX 2.2
     */
    public final ReadOnlyObjectProperty&lt;Transform&gt; localToParentTransformProperty() {
        return getNodeTransformation().localToParentTransformProperty();
    }

    private void invalidateLocalToParentTransform() {
        if (nodeTransformation != null) {
            nodeTransformation.invalidateLocalToParentTransform();
        }
    }

    public final Transform getLocalToParentTransform() {
        return localToParentTransformProperty().get();
    }

    /**
     * An affine transform that holds the computed local-to-scene transform.
     * This is the concatenation of all transforms in this node's parents and
     * in this node, including all of the convenience transforms up to the root.
     * If this node is in a {@link javafx.scene.SubScene}, this property represents
     * transforms up to the subscene, not the root scene.
     *
     * &lt;p&gt;
     * Note that when you register a listener or a binding to this property,
     * it needs to listen for invalidation on all its parents to the root node.
     * This means that registering a listener on this
     * property on many nodes may negatively affect performance of
     * transformation changes in their common parents.
     * &lt;/p&gt;
     *
     * @return the localToScene transform for this {@code Node}
     * @since JavaFX 2.2
     */
    public final ReadOnlyObjectProperty&lt;Transform&gt; localToSceneTransformProperty() {
        return getNodeTransformation().localToSceneTransformProperty();
    }

    private void invalidateLocalToSceneTransform() {
        if (nodeTransformation != null) {
            nodeTransformation.invalidateLocalToSceneTransform();
        }
    }

    public final Transform getLocalToSceneTransform() {
        return localToSceneTransformProperty().get();
    }

    private NodeTransformation nodeTransformation;

    private NodeTransformation getNodeTransformation() {
        if (nodeTransformation == null) {
            nodeTransformation = new NodeTransformation();
        }

        return nodeTransformation;
    }

    private boolean hasTransforms() {
        return (nodeTransformation != null)
                &amp;&amp; nodeTransformation.hasTransforms();
    }

    // for tests only
    Transform getCurrentLocalToSceneTransformState() {
        if (nodeTransformation == null ||
                nodeTransformation.localToSceneTransform == null) {
            return null;
        }

        return nodeTransformation.localToSceneTransform.transform;
    }

    private static final double DEFAULT_TRANSLATE_X = 0;
    private static final double DEFAULT_TRANSLATE_Y = 0;
    private static final double DEFAULT_TRANSLATE_Z = 0;
    private static final double DEFAULT_SCALE_X = 1;
    private static final double DEFAULT_SCALE_Y = 1;
    private static final double DEFAULT_SCALE_Z = 1;
    private static final double DEFAULT_ROTATE = 0;
    private static final Point3D DEFAULT_ROTATION_AXIS = Rotate.Z_AXIS;

    private final class NodeTransformation {
        private DoubleProperty translateX;
        private DoubleProperty translateY;
        private DoubleProperty translateZ;
        private DoubleProperty scaleX;
        private DoubleProperty scaleY;
        private DoubleProperty scaleZ;
        private DoubleProperty rotate;
        private ObjectProperty&lt;Point3D&gt; rotationAxis;
        private ObservableList&lt;Transform&gt; transforms;
        private LazyTransformProperty localToParentTransform;
        private LazyTransformProperty localToSceneTransform;
        private int listenerReasons = 0;
        private InvalidationListener localToSceneInvLstnr;

        private InvalidationListener getLocalToSceneInvalidationListener() {
            if (localToSceneInvLstnr == null) {
                localToSceneInvLstnr = observable -&gt; invalidateLocalToSceneTransform();
            }
            return localToSceneInvLstnr;
        }

        public void incListenerReasons() {
            if (listenerReasons == 0) {
                Node n = Node.this.getParent();
                if (n != null) {
                    n.localToSceneTransformProperty().addListener(
                            getLocalToSceneInvalidationListener());
                }
            }
            listenerReasons++;
        }

        public void decListenerReasons() {
            listenerReasons--;
            if (listenerReasons == 0) {
                Node n = Node.this.getParent();
                if (n != null) {
                    n.localToSceneTransformProperty().removeListener(
                            getLocalToSceneInvalidationListener());
                }
                if (localToSceneTransform != null) {
                    localToSceneTransform.validityUnknown();
                }
            }
        }

        public final Transform getLocalToParentTransform() {
            return localToParentTransformProperty().get();
        }

        public final ReadOnlyObjectProperty&lt;Transform&gt; localToParentTransformProperty() {
            if (localToParentTransform == null) {
                localToParentTransform = new LazyTransformProperty() {
                    @Override
                    protected Transform computeTransform(Transform reuse) {
                        updateLocalToParentTransform();
                        return TransformUtils.immutableTransform(reuse,
                                localToParentTx.getMxx(), localToParentTx.getMxy(), localToParentTx.getMxz(), localToParentTx.getMxt(),
                                localToParentTx.getMyx(), localToParentTx.getMyy(), localToParentTx.getMyz(), localToParentTx.getMyt(),
                                localToParentTx.getMzx(), localToParentTx.getMzy(), localToParentTx.getMzz(), localToParentTx.getMzt());
                    }

                    @Override
                    protected boolean validityKnown() {
                        return true;
                    }

                    @Override
                    protected int computeValidity() {
                        return valid;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;localToParentTransform&quot;;
                    }
                };
            }

            return localToParentTransform;
        }

        public void invalidateLocalToParentTransform() {
            if (localToParentTransform != null) {
                localToParentTransform.invalidate();
            }
        }

        public final Transform getLocalToSceneTransform() {
            return localToSceneTransformProperty().get();
        }

        class LocalToSceneTransformProperty extends LazyTransformProperty {
            // need this to track number of listeners
            private List localToSceneListeners;
            // stamps to watch for parent changes when the listeners
            // are not present
            private long stamp, parentStamp;

            @Override
            protected Transform computeTransform(Transform reuse) {
                stamp++;
                updateLocalToParentTransform();

                Node parentNode = Node.this.getParent();
                if (parentNode != null) {
                    final LocalToSceneTransformProperty parentProperty =
                            (LocalToSceneTransformProperty) parentNode.localToSceneTransformProperty();
                    final Transform parentTransform = parentProperty.getInternalValue();

                    parentStamp = parentProperty.stamp;

                    return TransformUtils.immutableTransform(reuse,
                            parentTransform,
                            ((LazyTransformProperty) localToParentTransformProperty()).getInternalValue());
                } else {
                    return TransformUtils.immutableTransform(reuse,
                            ((LazyTransformProperty) localToParentTransformProperty()).getInternalValue());
                }
            }

            @Override
            public Object getBean() {
                return Node.this;
            }

            @Override
            public String getName() {
                return &quot;localToSceneTransform&quot;;
            }

            @Override
            protected boolean validityKnown() {
                return listenerReasons &gt; 0;
            }

            @Override
            protected int computeValidity() {
                if (valid != VALIDITY_UNKNOWN) {
                    return valid;
                }

                Node n = (Node) getBean();
                Node parent = n.getParent();

                if (parent != null) {
                    final LocalToSceneTransformProperty parentProperty =
                            (LocalToSceneTransformProperty) parent.localToSceneTransformProperty();

                    if (parentStamp != parentProperty.stamp) {
                        valid = INVALID;
                        return INVALID;
                    }

                    int parentValid = parentProperty.computeValidity();
                    if (parentValid == INVALID) {
                        valid = INVALID;
                    }
                    return parentValid;
                }

                // Validity unknown for root means it is valid
                return VALID;
            }

            @Override
            public void addListener(InvalidationListener listener) {
                incListenerReasons();
                if (localToSceneListeners == null) {
                    localToSceneListeners = new LinkedList&lt;Object&gt;();
                }
                localToSceneListeners.add(listener);
                super.addListener(listener);
            }

            @Override
            public void addListener(ChangeListener&lt;? super Transform&gt; listener) {
                incListenerReasons();
                if (localToSceneListeners == null) {
                    localToSceneListeners = new LinkedList&lt;Object&gt;();
                }
                localToSceneListeners.add(listener);
                super.addListener(listener);
            }

            @Override
            public void removeListener(InvalidationListener listener) {
                if (localToSceneListeners != null &amp;&amp;
                        localToSceneListeners.remove(listener)) {
                    decListenerReasons();
                }
                super.removeListener(listener);
            }

            @Override
            public void removeListener(ChangeListener&lt;? super Transform&gt; listener) {
                if (localToSceneListeners != null &amp;&amp;
                        localToSceneListeners.remove(listener)) {
                    decListenerReasons();
                }
                super.removeListener(listener);
            }
        }

        public final ReadOnlyObjectProperty&lt;Transform&gt; localToSceneTransformProperty() {
            if (localToSceneTransform == null) {
                localToSceneTransform = new LocalToSceneTransformProperty();
            }

            return localToSceneTransform;
        }

        public void invalidateLocalToSceneTransform() {
            if (localToSceneTransform != null) {
                localToSceneTransform.invalidate();
            }
        }

        public double getTranslateX() {
            return (translateX == null) ? DEFAULT_TRANSLATE_X
                                        : translateX.get();
        }

        public final DoubleProperty translateXProperty() {
            if (translateX == null) {
                translateX = new StyleableDoubleProperty(DEFAULT_TRANSLATE_X) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.TRANSLATE_X;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;translateX&quot;;
                    }
                };
            }
            return translateX;
        }

        public double getTranslateY() {
            return (translateY == null) ? DEFAULT_TRANSLATE_Y : translateY.get();
        }

        public final DoubleProperty translateYProperty() {
            if (translateY == null) {
                translateY = new StyleableDoubleProperty(DEFAULT_TRANSLATE_Y) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.TRANSLATE_Y;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;translateY&quot;;
                    }
                };
            }
            return translateY;
        }

        public double getTranslateZ() {
            return (translateZ == null) ? DEFAULT_TRANSLATE_Z : translateZ.get();
        }

        public final DoubleProperty translateZProperty() {
            if (translateZ == null) {
                translateZ = new StyleableDoubleProperty(DEFAULT_TRANSLATE_Z) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.TRANSLATE_Z;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;translateZ&quot;;
                    }
                };
            }
            return translateZ;
        }

        public double getScaleX() {
            return (scaleX == null) ? DEFAULT_SCALE_X : scaleX.get();
        }

        public final DoubleProperty scaleXProperty() {
            if (scaleX == null) {
                scaleX = new StyleableDoubleProperty(DEFAULT_SCALE_X) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.SCALE_X;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;scaleX&quot;;
                    }
                };
            }
            return scaleX;
        }

        public double getScaleY() {
            return (scaleY == null) ? DEFAULT_SCALE_Y : scaleY.get();
        }

        public final DoubleProperty scaleYProperty() {
            if (scaleY == null) {
                scaleY = new StyleableDoubleProperty(DEFAULT_SCALE_Y) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.SCALE_Y;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;scaleY&quot;;
                    }
                };
            }
            return scaleY;
        }

        public double getScaleZ() {
            return (scaleZ == null) ? DEFAULT_SCALE_Z : scaleZ.get();
        }

        public final DoubleProperty scaleZProperty() {
            if (scaleZ == null) {
                scaleZ = new StyleableDoubleProperty(DEFAULT_SCALE_Z) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.SCALE_Z;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;scaleZ&quot;;
                    }
                };
            }
            return scaleZ;
        }

        public double getRotate() {
            return (rotate == null) ? DEFAULT_ROTATE : rotate.get();
        }

        public final DoubleProperty rotateProperty() {
            if (rotate == null) {
                rotate = new StyleableDoubleProperty(DEFAULT_ROTATE) {
                    @Override
                    public void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.ROTATE;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;rotate&quot;;
                    }
                };
            }
            return rotate;
        }

        public Point3D getRotationAxis() {
            return (rotationAxis == null) ? DEFAULT_ROTATION_AXIS
                                          : rotationAxis.get();
        }

        public final ObjectProperty&lt;Point3D&gt; rotationAxisProperty() {
            if (rotationAxis == null) {
                rotationAxis = new ObjectPropertyBase&lt;Point3D&gt;(
                                           DEFAULT_ROTATION_AXIS) {
                    @Override
                    protected void invalidated() {
                        NodeHelper.transformsChanged(Node.this);
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;rotationAxis&quot;;
                    }
                };
            }
            return rotationAxis;
        }

        public ObservableList&lt;Transform&gt; getTransforms() {
            if (transforms == null) {
                transforms = new TrackableObservableList&lt;Transform&gt;() {
                    @Override
                    protected void onChanged(Change&lt;Transform&gt; c) {
                        while (c.next()) {
                            for (Transform t : c.getRemoved()) {
                                TransformHelper.remove(t, Node.this);
                            }
                            for (Transform t : c.getAddedSubList()) {
                                TransformHelper.add(t, Node.this);
                            }
                        }

                        NodeHelper.transformsChanged(Node.this);
                    }
                };
            }

            return transforms;
        }

        public boolean canSetTranslateX() {
            return (translateX == null) || !translateX.isBound();
        }

        public boolean canSetTranslateY() {
            return (translateY == null) || !translateY.isBound();
        }

        public boolean canSetTranslateZ() {
            return (translateZ == null) || !translateZ.isBound();
        }

        public boolean canSetScaleX() {
            return (scaleX == null) || !scaleX.isBound();
        }

        public boolean canSetScaleY() {
            return (scaleY == null) || !scaleY.isBound();
        }

        public boolean canSetScaleZ() {
            return (scaleZ == null) || !scaleZ.isBound();
        }

        public boolean canSetRotate() {
            return (rotate == null) || !rotate.isBound();
        }

        public boolean hasTransforms() {
            return (transforms != null &amp;&amp; !transforms.isEmpty());
        }

        public boolean hasScaleOrRotate() {
            if (scaleX != null &amp;&amp; scaleX.get() != DEFAULT_SCALE_X) {
                return true;
            }
            if (scaleY != null &amp;&amp; scaleY.get() != DEFAULT_SCALE_Y) {
                return true;
            }
            if (scaleZ != null &amp;&amp; scaleZ.get() != DEFAULT_SCALE_Z) {
                return true;
            }
            if (rotate != null &amp;&amp; rotate.get() != DEFAULT_ROTATE) {
                return true;
            }
            return false;
        }

    }

    ////////////////////////////
    //  Private Implementation
    ////////////////////////////

    /***************************************************************************
     *                                                                         *
     *                        Event Handler Properties                         *
     *                                                                         *
     **************************************************************************/

    private EventHandlerProperties eventHandlerProperties;

    private EventHandlerProperties getEventHandlerProperties() {
        if (eventHandlerProperties == null) {
            eventHandlerProperties =
                    new EventHandlerProperties(
                        getInternalEventDispatcher().getEventHandlerManager(),
                        this);
        }

        return eventHandlerProperties;
    }

    /***************************************************************************
     *                                                                         *
     *                       Component Orientation Properties                  *
     *                                                                         *
     **************************************************************************/

    private ObjectProperty&lt;NodeOrientation&gt; nodeOrientation;
    private EffectiveOrientationProperty effectiveNodeOrientationProperty;

    private static final byte EFFECTIVE_ORIENTATION_LTR = 0;
    private static final byte EFFECTIVE_ORIENTATION_RTL = 1;
    private static final byte EFFECTIVE_ORIENTATION_MASK = 1;
    private static final byte AUTOMATIC_ORIENTATION_LTR = 0;
    private static final byte AUTOMATIC_ORIENTATION_RTL = 2;
    private static final byte AUTOMATIC_ORIENTATION_MASK = 2;

    private byte resolvedNodeOrientation =
            EFFECTIVE_ORIENTATION_LTR | AUTOMATIC_ORIENTATION_LTR;

    public final void setNodeOrientation(NodeOrientation orientation) {
        nodeOrientationProperty().set(orientation);
    }

    public final NodeOrientation getNodeOrientation() {
        return nodeOrientation == null ? NodeOrientation.INHERIT : nodeOrientation.get();
    }
    /**
     * Property holding NodeOrientation.
     * &lt;p&gt;
     * Node orientation describes the flow of visual data within a node.
     * In the English speaking world, visual data normally flows from
     * left-to-right. In an Arabic or Hebrew world, visual data flows
     * from right-to-left.  This is consistent with the reading order
     * of text in both worlds.  The default value is left-to-right.
     * &lt;/p&gt;
     *
     * @return NodeOrientation
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;NodeOrientation&gt; nodeOrientationProperty() {
        if (nodeOrientation == null) {
            nodeOrientation = new StyleableObjectProperty&lt;NodeOrientation&gt;(NodeOrientation.INHERIT) {
                @Override
                protected void invalidated() {
                    nodeResolvedOrientationInvalidated();
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;nodeOrientation&quot;;
                }

                @Override
                public CssMetaData getCssMetaData() {
                    //TODO - not supported
                    throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
                }

            };
        }
        return nodeOrientation;
    }

    public final NodeOrientation getEffectiveNodeOrientation() {
        return (getEffectiveOrientation(resolvedNodeOrientation)
                    == EFFECTIVE_ORIENTATION_LTR)
                       ? NodeOrientation.LEFT_TO_RIGHT
                       : NodeOrientation.RIGHT_TO_LEFT;
    }

    /**
     * The effective orientation of a node resolves the inheritance of
     * node orientation, returning either left-to-right or right-to-left.
     * @return the node orientation for this {@code Node}
     * @since JavaFX 8.0
     */
    public final ReadOnlyObjectProperty&lt;NodeOrientation&gt;
            effectiveNodeOrientationProperty() {
        if (effectiveNodeOrientationProperty == null) {
            effectiveNodeOrientationProperty =
                    new EffectiveOrientationProperty();
        }

        return effectiveNodeOrientationProperty;
    }

    /**
     * Determines whether a node should be mirrored when node orientation
     * is right-to-left.
     * &lt;p&gt;
     * When a node is mirrored, the origin is automatically moved to the
     * top right corner causing the node to layout children and draw from
     * right to left using a mirroring transformation.  Some nodes may wish
     * to draw from right to left without using a transformation.  These
     * nodes will will answer {@code false} and implement right-to-left
     * orientation without using the automatic transformation.
     * &lt;/p&gt;
     * @return true if this {@code Node} should be mirrored
     * @since JavaFX 8.0
     */
    public boolean usesMirroring() {
        return true;
    }

    final void parentResolvedOrientationInvalidated() {
        if (getNodeOrientation() == NodeOrientation.INHERIT) {
            nodeResolvedOrientationInvalidated();
        } else {
            // mirroring changed
            NodeHelper.transformsChanged(this);
        }
    }

    final void nodeResolvedOrientationInvalidated() {
        final byte oldResolvedNodeOrientation =
                resolvedNodeOrientation;

        resolvedNodeOrientation =
                (byte) (calcEffectiveNodeOrientation()
                            | calcAutomaticNodeOrientation());

        if ((effectiveNodeOrientationProperty != null)
                &amp;&amp; (getEffectiveOrientation(resolvedNodeOrientation)
                        != getEffectiveOrientation(
                               oldResolvedNodeOrientation))) {
            effectiveNodeOrientationProperty.invalidate();
        }

        // mirroring changed
        NodeHelper.transformsChanged(this);

        if (resolvedNodeOrientation != oldResolvedNodeOrientation) {
            nodeResolvedOrientationChanged();
        }
    }

    void nodeResolvedOrientationChanged() {
        // overriden in Parent
    }

    private Node getMirroringOrientationParent() {
        Node parentValue = getParent();
        while (parentValue != null) {
            if (parentValue.usesMirroring()) {
                return parentValue;
            }
            parentValue = parentValue.getParent();
        }

        final Node subSceneValue = getSubScene();
        if (subSceneValue != null) {
            return subSceneValue;
        }

        return null;
    }

    private Node getOrientationParent() {
        final Node parentValue = getParent();
        if (parentValue != null) {
            return parentValue;
        }

        final Node subSceneValue = getSubScene();
        if (subSceneValue != null) {
            return subSceneValue;
        }

        return null;
    }

    private byte calcEffectiveNodeOrientation() {
        final NodeOrientation nodeOrientationValue = getNodeOrientation();
        if (nodeOrientationValue != NodeOrientation.INHERIT) {
            return (nodeOrientationValue == NodeOrientation.LEFT_TO_RIGHT)
                       ? EFFECTIVE_ORIENTATION_LTR
                       : EFFECTIVE_ORIENTATION_RTL;
        }

        final Node parentValue = getOrientationParent();
        if (parentValue != null) {
            return getEffectiveOrientation(parentValue.resolvedNodeOrientation);
        }

        final Scene sceneValue = getScene();
        if (sceneValue != null) {
            return (sceneValue.getEffectiveNodeOrientation()
                        == NodeOrientation.LEFT_TO_RIGHT)
                           ? EFFECTIVE_ORIENTATION_LTR
                           : EFFECTIVE_ORIENTATION_RTL;
        }

        return EFFECTIVE_ORIENTATION_LTR;
    }

    private byte calcAutomaticNodeOrientation() {
        if (!usesMirroring()) {
            return AUTOMATIC_ORIENTATION_LTR;
        }

        final NodeOrientation nodeOrientationValue = getNodeOrientation();
        if (nodeOrientationValue != NodeOrientation.INHERIT) {
            return (nodeOrientationValue == NodeOrientation.LEFT_TO_RIGHT)
                       ? AUTOMATIC_ORIENTATION_LTR
                       : AUTOMATIC_ORIENTATION_RTL;
        }

        final Node parentValue = getMirroringOrientationParent();
        if (parentValue != null) {
            // automatic node orientation is inherited
            return getAutomaticOrientation(parentValue.resolvedNodeOrientation);
        }

        final Scene sceneValue = getScene();
        if (sceneValue != null) {
            return (sceneValue.getEffectiveNodeOrientation()
                        == NodeOrientation.LEFT_TO_RIGHT)
                           ? AUTOMATIC_ORIENTATION_LTR
                           : AUTOMATIC_ORIENTATION_RTL;
        }

        return AUTOMATIC_ORIENTATION_LTR;
    }

    // Return true if the node needs to be mirrored.
    // A node has mirroring if the orientation differs from the parent
    // package private for testing
    final boolean hasMirroring() {
        final Node parentValue = getOrientationParent();

        final byte thisOrientation =
                getAutomaticOrientation(resolvedNodeOrientation);
        final byte parentOrientation =
                (parentValue != null)
                    ? getAutomaticOrientation(
                          parentValue.resolvedNodeOrientation)
                    : AUTOMATIC_ORIENTATION_LTR;

        return thisOrientation != parentOrientation;
    }

    private static byte getEffectiveOrientation(
            final byte resolvedNodeOrientation) {
        return (byte) (resolvedNodeOrientation &amp; EFFECTIVE_ORIENTATION_MASK);
    }

    private static byte getAutomaticOrientation(
            final byte resolvedNodeOrientation) {
        return (byte) (resolvedNodeOrientation &amp; AUTOMATIC_ORIENTATION_MASK);
    }

    private final class EffectiveOrientationProperty
            extends ReadOnlyObjectPropertyBase&lt;NodeOrientation&gt; {
        @Override
        public NodeOrientation get() {
            return getEffectiveNodeOrientation();
        }

        @Override
        public Object getBean() {
            return Node.this;
        }

        @Override
        public String getName() {
            return &quot;effectiveNodeOrientation&quot;;
        }

        public void invalidate() {
            fireValueChangedEvent();
        }
    }

    /***************************************************************************
     *                                                                         *
     *                       Misc Seldom Used Properties                       *
     *                                                                         *
     **************************************************************************/

    private MiscProperties miscProperties;

    private MiscProperties getMiscProperties() {
        if (miscProperties == null) {
            miscProperties = new MiscProperties();
        }

        return miscProperties;
    }

    private static final double DEFAULT_VIEW_ORDER = 0;
    private static final boolean DEFAULT_CACHE = false;
    private static final CacheHint DEFAULT_CACHE_HINT = CacheHint.DEFAULT;
    private static final Node DEFAULT_CLIP = null;
    private static final Cursor DEFAULT_CURSOR = null;
    private static final DepthTest DEFAULT_DEPTH_TEST = DepthTest.INHERIT;
    private static final boolean DEFAULT_DISABLE = false;
    private static final Effect DEFAULT_EFFECT = null;
    private static final InputMethodRequests DEFAULT_INPUT_METHOD_REQUESTS =
            null;
    private static final boolean DEFAULT_MOUSE_TRANSPARENT = false;

    private final class MiscProperties {
        private LazyBoundsProperty boundsInParent;
        private LazyBoundsProperty boundsInLocal;
        private BooleanProperty cache;
        private ObjectProperty&lt;CacheHint&gt; cacheHint;
        private ObjectProperty&lt;Node&gt; clip;
        private ObjectProperty&lt;Cursor&gt; cursor;
        private ObjectProperty&lt;DepthTest&gt; depthTest;
        private BooleanProperty disable;
        private ObjectProperty&lt;Effect&gt; effect;
        private ObjectProperty&lt;InputMethodRequests&gt; inputMethodRequests;
        private BooleanProperty mouseTransparent;
        private DoubleProperty viewOrder;

        public double getViewOrder() {
            return (viewOrder == null) ? DEFAULT_VIEW_ORDER : viewOrder.get();
        }

        public final DoubleProperty viewOrderProperty() {
            if (viewOrder == null) {
                viewOrder = new StyleableDoubleProperty(DEFAULT_VIEW_ORDER) {
                    @Override
                    public void invalidated() {
                        Parent p = getParent();
                        if (p != null) {
                            // Parent will be responsible to update sorted children list
                            p.markViewOrderChildrenDirty();
                        }
                        NodeHelper.markDirty(Node.this, DirtyBits.NODE_VIEW_ORDER);
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.VIEW_ORDER;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;viewOrder&quot;;
                    }
                };
            }
            return viewOrder;
        }

        public final Bounds getBoundsInParent() {
            return boundsInParentProperty().get();
        }

        public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInParentProperty() {
            if (boundsInParent == null) {
                boundsInParent = new LazyBoundsProperty() {
                    /**
                     * Computes the bounds including the clip, effects, and all
                     * transforms. This function is essentially how to compute
                     * the boundsInParent. Optimizations are made to compute as
                     * little as possible and create as little trash as
                     * possible.
                     */
                    @Override
                    protected Bounds computeBounds() {
                        BaseBounds tempBounds = TempState.getInstance().bounds;
                        tempBounds = getTransformedBounds(
                                             tempBounds,
                                             BaseTransform.IDENTITY_TRANSFORM);
                        return new BoundingBox(tempBounds.getMinX(),
                                               tempBounds.getMinY(),
                                               tempBounds.getMinZ(),
                                               tempBounds.getWidth(),
                                               tempBounds.getHeight(),
                                               tempBounds.getDepth());
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;boundsInParent&quot;;
                    }
                };
            }

            return boundsInParent;
        }

        public void invalidateBoundsInParent() {
            if (boundsInParent != null) {
                boundsInParent.invalidate();
            }
        }

        public final Bounds getBoundsInLocal() {
            return boundsInLocalProperty().get();
        }

        public final ReadOnlyObjectProperty&lt;Bounds&gt; boundsInLocalProperty() {
            if (boundsInLocal == null) {
                boundsInLocal = new LazyBoundsProperty() {
                    @Override
                    protected Bounds computeBounds() {
                        BaseBounds tempBounds = TempState.getInstance().bounds;
                        tempBounds = getLocalBounds(
                                             tempBounds,
                                             BaseTransform.IDENTITY_TRANSFORM);
                        return new BoundingBox(tempBounds.getMinX(),
                                               tempBounds.getMinY(),
                                               tempBounds.getMinZ(),
                                               tempBounds.getWidth(),
                                               tempBounds.getHeight(),
                                               tempBounds.getDepth());
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;boundsInLocal&quot;;
                    }
                };
            }

            return boundsInLocal;
        }

        public void invalidateBoundsInLocal() {
            if (boundsInLocal != null) {
                boundsInLocal.invalidate();
            }
        }

        public final boolean isCache() {
            return (cache == null) ? DEFAULT_CACHE
                                   : cache.get();
        }

        public final BooleanProperty cacheProperty() {
            if (cache == null) {
                cache = new BooleanPropertyBase(DEFAULT_CACHE) {
                    @Override
                    protected void invalidated() {
                        NodeHelper.markDirty(Node.this, DirtyBits.NODE_CACHE);
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;cache&quot;;
                    }
                };
            }
            return cache;
        }

        public final CacheHint getCacheHint() {
            return (cacheHint == null) ? DEFAULT_CACHE_HINT
                                       : cacheHint.get();
        }

        public final ObjectProperty&lt;CacheHint&gt; cacheHintProperty() {
            if (cacheHint == null) {
                cacheHint = new ObjectPropertyBase&lt;CacheHint&gt;(DEFAULT_CACHE_HINT) {
                    @Override
                    protected void invalidated() {
                        NodeHelper.markDirty(Node.this, DirtyBits.NODE_CACHE);
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;cacheHint&quot;;
                    }
                };
            }
            return cacheHint;
        }

        public final Node getClip() {
            return (clip == null) ? DEFAULT_CLIP : clip.get();
        }

        public final ObjectProperty&lt;Node&gt; clipProperty() {
            if (clip == null) {
                clip = new ObjectPropertyBase&lt;Node&gt;(DEFAULT_CLIP) {

                    //temp variables used when clip was invalid to rollback to
                    // last value
                    private Node oldClip;

                    @Override
                    protected void invalidated() {
                        final Node newClip = get();
                        if ((newClip != null)
                                &amp;&amp; ((newClip.isConnected()
                                           &amp;&amp; newClip.clipParent != Node.this)
                                       || wouldCreateCycle(Node.this,
                                                           newClip))) {
                            // Assigning this node to clip is illegal.
                            // Roll back to the previous state and throw an
                            // exception.
                            final String cause =
                                    newClip.isConnected()
                                        &amp;&amp; (newClip.clipParent != Node.this)
                                            ? &quot;node already connected&quot;
                                            : &quot;cycle detected&quot;;

                            if (isBound()) {
                                unbind();
                                set(oldClip);
                                throw new IllegalArgumentException(
                                        &quot;Node's clip set to incorrect value &quot;
                                            + &quot; through binding&quot;
                                            + &quot; (&quot; + cause + &quot;, node  = &quot;
                                                   + Node.this + &quot;, clip = &quot;
                                                   + clip + &quot;).&quot;
                                            + &quot; Binding has been removed.&quot;);
                            } else {
                                set(oldClip);
                                throw new IllegalArgumentException(
                                        &quot;Node's clip set to incorrect value&quot;
                                            + &quot; (&quot; + cause + &quot;, node  = &quot;
                                                   + Node.this + &quot;, clip = &quot;
                                                   + clip + &quot;).&quot;);
                            }
                        } else {
                            if (oldClip != null) {
                                oldClip.clipParent = null;
                                oldClip.setScenes(null, null);
                                oldClip.updateTreeVisible(false);
                            }

                            if (newClip != null) {
                                newClip.clipParent = Node.this;
                                newClip.setScenes(getScene(), getSubScene());
                                newClip.updateTreeVisible(true);
                            }

                            NodeHelper.markDirty(Node.this, DirtyBits.NODE_CLIP);

                            // the local bounds have (probably) changed
                            localBoundsChanged();

                            oldClip = newClip;
                        }
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;clip&quot;;
                    }
                };
            }
            return clip;
        }

        public final Cursor getCursor() {
            return (cursor == null) ? DEFAULT_CURSOR : cursor.get();
        }

        public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
            if (cursor == null) {
                cursor = new StyleableObjectProperty&lt;Cursor&gt;(DEFAULT_CURSOR) {

                    @Override
                    protected void invalidated() {
                        final Scene sceneValue = getScene();
                        if (sceneValue != null) {
                            sceneValue.markCursorDirty();
                        }
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.CURSOR;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;cursor&quot;;
                    }

                };
            }
            return cursor;
        }

        public final DepthTest getDepthTest() {
            return (depthTest == null) ? DEFAULT_DEPTH_TEST
                                       : depthTest.get();
        }

        public final ObjectProperty&lt;DepthTest&gt; depthTestProperty() {
            if (depthTest == null) {
                depthTest = new ObjectPropertyBase&lt;DepthTest&gt;(DEFAULT_DEPTH_TEST) {
                    @Override protected void invalidated() {
                        computeDerivedDepthTest();
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;depthTest&quot;;
                    }
                };
            }
            return depthTest;
        }

        public final boolean isDisable() {
            return (disable == null) ? DEFAULT_DISABLE : disable.get();
        }

        public final BooleanProperty disableProperty() {
            if (disable == null) {
                disable = new BooleanPropertyBase(DEFAULT_DISABLE) {
                    @Override
                    protected void invalidated() {
                        updateDisabled();
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;disable&quot;;
                    }
                };
            }
            return disable;
        }

        public final Effect getEffect() {
            return (effect == null) ? DEFAULT_EFFECT : effect.get();
        }

        public final ObjectProperty&lt;Effect&gt; effectProperty() {
            if (effect == null) {
                effect = new StyleableObjectProperty&lt;Effect&gt;(DEFAULT_EFFECT) {
                    private Effect oldEffect = null;
                    private int oldBits;

                    private final AbstractNotifyListener effectChangeListener =
                            new AbstractNotifyListener() {

                        @Override
                        public void invalidated(Observable valueModel) {
                            int newBits = ((IntegerProperty) valueModel).get();
                            int changedBits = newBits ^ oldBits;
                            oldBits = newBits;
                            if (EffectDirtyBits.isSet(
                                    changedBits,
                                    EffectDirtyBits.EFFECT_DIRTY)
                                &amp;&amp; EffectDirtyBits.isSet(
                                       newBits,
                                       EffectDirtyBits.EFFECT_DIRTY)) {
                                NodeHelper.markDirty(Node.this, DirtyBits.EFFECT_EFFECT);
                            }
                            if (EffectDirtyBits.isSet(
                                    changedBits,
                                    EffectDirtyBits.BOUNDS_CHANGED)) {
                                localBoundsChanged();
                            }
                        }
                    };

                    @Override
                    protected void invalidated() {
                        Effect _effect = get();
                        if (oldEffect != null) {
                            EffectHelper.effectDirtyProperty(oldEffect).removeListener(
                                    effectChangeListener.getWeakListener());
                        }
                        oldEffect = _effect;
                        if (_effect != null) {
                            EffectHelper.effectDirtyProperty(_effect)
                                   .addListener(
                                       effectChangeListener.getWeakListener());
                            if (EffectHelper.isEffectDirty(_effect)) {
                                NodeHelper.markDirty(Node.this, DirtyBits.EFFECT_EFFECT);
                            }
                            oldBits = EffectHelper.effectDirtyProperty(_effect).get();
                        }

                        NodeHelper.markDirty(Node.this, DirtyBits.NODE_EFFECT);
                        // bounds may have changed regardless whether
                        // the dirty flag on effect is set
                        localBoundsChanged();
                    }

                    @Override
                    public CssMetaData getCssMetaData() {
                        return StyleableProperties.EFFECT;
                    }

                    @Override
                    public Object getBean() {
                        return Node.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;effect&quot;;
                    }
                };
            }
            return effect;
        }

        public final InputMethodRequests getInputMethodRequests() {
            return (inputMethodRequests == null) ? DEFAULT_INPUT_METHOD_REQUESTS
                                                 : inputMethodRequests.get();
        }

        public ObjectProperty&lt;InputMethodRequests&gt;
                inputMethodRequestsProperty() {
            if (inputMethodRequests == null) {
                inputMethodRequests =
                        new SimpleObjectProperty&lt;InputMethodRequests&gt;(
                                Node.this,
                                &quot;inputMethodRequests&quot;,
                                DEFAULT_INPUT_METHOD_REQUESTS);
            }
            return inputMethodRequests;
        }

        public final boolean isMouseTransparent() {
            return (mouseTransparent == null) ? DEFAULT_MOUSE_TRANSPARENT
                                              : mouseTransparent.get();
        }

        public final BooleanProperty mouseTransparentProperty() {
            if (mouseTransparent == null) {
                mouseTransparent =
                        new SimpleBooleanProperty(
                                Node.this,
                                &quot;mouseTransparent&quot;,
                                DEFAULT_MOUSE_TRANSPARENT);
            }
            return mouseTransparent;
        }

        public boolean canSetCursor() {
            return (cursor == null) || !cursor.isBound();
        }

        public boolean canSetEffect() {
            return (effect == null) || !effect.isBound();
        }
    }

    /* *************************************************************************
     *                                                                         *
     *                             Mouse Handling                              *
     *                                                                         *
     **************************************************************************/

    public final void setMouseTransparent(boolean value) {
        mouseTransparentProperty().set(value);
    }

    public final boolean isMouseTransparent() {
        return (miscProperties == null) ? DEFAULT_MOUSE_TRANSPARENT
                                        : miscProperties.isMouseTransparent();
    }

    /**
     * If {@code true}, this node (together with all its children) is completely
     * transparent to mouse events. When choosing target for mouse event, nodes
     * with {@code mouseTransparent} set to {@code true} and their subtrees
     * won't be taken into account.
     * @return is this {@code Node} (together with all its children) is completely
     * transparent to mouse events.
     */
    public final BooleanProperty mouseTransparentProperty() {
        return getMiscProperties().mouseTransparentProperty();
    }

    /**
     * Whether or not this {@code Node} is being hovered over. Typically this is
     * due to the mouse being over the node, though it could be due to a pen
     * hovering on a graphics tablet or other form of input.
     *
     * &lt;p&gt;Note that current implementation of hover relies on mouse enter and
     * exit events to determine whether this Node is in the hover state; this
     * means that this feature is currently supported only on systems that
     * have a mouse. Future implementations may provide alternative means of
     * supporting hover.
     *
     * @defaultValue false
     */
    private ReadOnlyBooleanWrapper hover;

    protected final void setHover(boolean value) {
        hoverPropertyImpl().set(value);
    }

    public final boolean isHover() {
        return hover == null ? false : hover.get();
    }

    public final ReadOnlyBooleanProperty hoverProperty() {
        return hoverPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyBooleanWrapper hoverPropertyImpl() {
        if (hover == null) {
            hover = new ReadOnlyBooleanWrapper() {

                @Override
                protected void invalidated() {
                    PlatformLogger logger = Logging.getInputLogger();
                    if (logger.isLoggable(Level.FINER)) {
                        logger.finer(this + &quot; hover=&quot; + get());
                    }
                    pseudoClassStateChanged(HOVER_PSEUDOCLASS_STATE, get());
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;hover&quot;;
                }
            };
        }
        return hover;
    }

    /**
     * Whether or not the {@code Node} is pressed. Typically this is true when
     * the primary mouse button is down, though subclasses may define other
     * mouse button state or key state to cause the node to be &quot;pressed&quot;.
     *
     * @defaultValue false
     */
    private ReadOnlyBooleanWrapper pressed;

    protected final void setPressed(boolean value) {
        pressedPropertyImpl().set(value);
    }

    public final boolean isPressed() {
        return pressed == null ? false : pressed.get();
    }

    public final ReadOnlyBooleanProperty pressedProperty() {
        return pressedPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyBooleanWrapper pressedPropertyImpl() {
        if (pressed == null) {
            pressed = new ReadOnlyBooleanWrapper() {

                @Override
                protected void invalidated() {
                    PlatformLogger logger = Logging.getInputLogger();
                    if (logger.isLoggable(Level.FINER)) {
                        logger.finer(this + &quot; pressed=&quot; + get());
                    }
                    pseudoClassStateChanged(PRESSED_PSEUDOCLASS_STATE, get());
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;pressed&quot;;
                }
            };
        }
        return pressed;
    }

    public final void setOnContextMenuRequested(
            EventHandler&lt;? super ContextMenuEvent&gt; value) {
        onContextMenuRequestedProperty().set(value);
    }

    public final EventHandler&lt;? super ContextMenuEvent&gt; getOnContextMenuRequested() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.onContextMenuRequested();
    }

    /**
     * Defines a function to be called when a context menu
     * has been requested on this {@code Node}.
     * @return the event handler that is called when a context menu has been
     * requested on this {@code Node}
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt;
            onContextMenuRequestedProperty() {
        return getEventHandlerProperties().onContextMenuRequestedProperty();
    }

    public final void setOnMouseClicked(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseClickedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseClicked() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseClicked();
    }

    /**
     * Defines a function to be called when a mouse button has been clicked
     * (pressed and released) on this {@code Node}.
     * @return the event handler that is called when a mouse button has been
     * clicked (pressed and released) on this {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseClickedProperty() {
        return getEventHandlerProperties().onMouseClickedProperty();
    }

    public final void setOnMouseDragged(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseDraggedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseDragged() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseDragged();
    }

    /**
     * Defines a function to be called when a mouse button is pressed
     * on this {@code Node} and then dragged.
     * @return the event handler that is called when a mouse button is pressed
     * on this {@code Node} and then dragged
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseDraggedProperty() {
        return getEventHandlerProperties().onMouseDraggedProperty();
    }

    public final void setOnMouseEntered(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseEntered() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseEntered();
    }

    /**
     * Defines a function to be called when the mouse enters this {@code Node}.
     * @return the event handler that is called when a mouse enters this
     * {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseEnteredProperty() {
        return getEventHandlerProperties().onMouseEnteredProperty();
    }

    public final void setOnMouseExited(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseExitedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseExited() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseExited();
    }

    /**
     * Defines a function to be called when the mouse exits this {@code Node}.
     * @return the event handler that is called when a mouse exits this
     * {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseExitedProperty() {
        return getEventHandlerProperties().onMouseExitedProperty();
    }

    public final void setOnMouseMoved(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseMovedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseMoved() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseMoved();
    }

    /**
     * Defines a function to be called when mouse cursor moves within
     * this {@code Node} but no buttons have been pushed.
     * @return the event handler that is called when a mouse cursor moves
     * within this {@code Node} but no buttons have been pushed
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseMovedProperty() {
        return getEventHandlerProperties().onMouseMovedProperty();
    }

    public final void setOnMousePressed(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMousePressedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMousePressed() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMousePressed();
    }

    /**
     * Defines a function to be called when a mouse button
     * has been pressed on this {@code Node}.
     * @return the event handler that is called when a mouse button has been
     * pressed on this {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMousePressedProperty() {
        return getEventHandlerProperties().onMousePressedProperty();
    }

    public final void setOnMouseReleased(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseReleased() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseReleased();
    }

    /**
     * Defines a function to be called when a mouse button
     * has been released on this {@code Node}.
     * @return the event handler that is called when a mouse button has been
     * released on this {@code Node}
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onMouseReleasedProperty() {
        return getEventHandlerProperties().onMouseReleasedProperty();
    }

    public final void setOnDragDetected(
            EventHandler&lt;? super MouseEvent&gt; value) {
        onDragDetectedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnDragDetected() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnDragDetected();
    }

    /**
     * Defines a function to be called when drag gesture has been
     * detected. This is the right place to start drag and drop operation.
     * @return the event handler that is called when drag gesture has been
     * detected
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt;
            onDragDetectedProperty() {
        return getEventHandlerProperties().onDragDetectedProperty();
    }

    public final void setOnMouseDragOver(
            EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragOverProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragOver() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseDragOver();
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * progresses within this {@code Node}.
     * @return the event handler that is called when a full press-drag-release
     * gesture progresses within this {@code Node}
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
            onMouseDragOverProperty() {
        return getEventHandlerProperties().onMouseDragOverProperty();
    }

    public final void setOnMouseDragReleased(
            EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragReleased() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseDragReleased();
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * ends (by releasing mouse button) within this {@code Node}.
     * @return the event handler that is called when a full press-drag-release
     * gesture ends (by releasing mouse button) within this {@code Node}
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
            onMouseDragReleasedProperty() {
        return getEventHandlerProperties().onMouseDragReleasedProperty();
    }

    public final void setOnMouseDragEntered(
            EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragEntered() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseDragEntered();
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * enters this {@code Node}.
     * @return the event handler that is called when a full press-drag-release
     * gesture enters this {@code Node}
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
            onMouseDragEnteredProperty() {
        return getEventHandlerProperties().onMouseDragEnteredProperty();
    }

    public final void setOnMouseDragExited(
            EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragExitedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragExited() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnMouseDragExited();
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * leaves this {@code Node}.
     * @return the event handler that is called when a full press-drag-release
     * gesture leaves this {@code Node}
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;
            onMouseDragExitedProperty() {
        return getEventHandlerProperties().onMouseDragExitedProperty();
    }


    /* *************************************************************************
     *                                                                         *
     *                           Gestures Handling                             *
     *                                                                         *
     **************************************************************************/

    public final void setOnScrollStarted(
            EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollStartedProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollStarted() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnScrollStarted();
    }

    /**
     * Defines a function to be called when a scrolling gesture is detected.
     * @return the event handler that is called when a scrolling gesture is
     * detected
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
            onScrollStartedProperty() {
        return getEventHandlerProperties().onScrollStartedProperty();
    }

    public final void setOnScroll(
            EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScroll() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnScroll();
    }

    /**
     * Defines a function to be called when user performs a scrolling action.
     * @return the event handler that is called when user performs a scrolling
     * action
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
            onScrollProperty() {
        return getEventHandlerProperties().onScrollProperty();
    }

    public final void setOnScrollFinished(
            EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollFinished() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnScrollFinished();
    }

    /**
     * Defines a function to be called when a scrolling gesture ends.
     * @return the event handler that is called when a scrolling gesture ends
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;
            onScrollFinishedProperty() {
        return getEventHandlerProperties().onScrollFinishedProperty();
    }

    public final void setOnRotationStarted(
            EventHandler&lt;? super RotateEvent&gt; value) {
        onRotationStartedProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotationStarted() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnRotationStarted();
    }

    /**
     * Defines a function to be called when a rotation gesture is detected.
     * @return the event handler that is called when a rotation gesture is
     * detected
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
            onRotationStartedProperty() {
        return getEventHandlerProperties().onRotationStartedProperty();
    }

    public final void setOnRotate(
            EventHandler&lt;? super RotateEvent&gt; value) {
        onRotateProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotate() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnRotate();
    }

    /**
     * Defines a function to be called when user performs a rotation action.
     * @return the event handler that is called when user performs a rotation
     * action
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
            onRotateProperty() {
        return getEventHandlerProperties().onRotateProperty();
    }

    public final void setOnRotationFinished(
            EventHandler&lt;? super RotateEvent&gt; value) {
        onRotationFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotationFinished() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnRotationFinished();
    }

    /**
     * Defines a function to be called when a rotation gesture ends.
     * @return the event handler that is called when a rotation gesture ends
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt;
            onRotationFinishedProperty() {
        return getEventHandlerProperties().onRotationFinishedProperty();
    }

    public final void setOnZoomStarted(
            EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomStartedProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomStarted() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnZoomStarted();
    }

    /**
     * Defines a function to be called when a zooming gesture is detected.
     * @return the event handler that is called when a zooming gesture is
     * detected
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
            onZoomStartedProperty() {
        return getEventHandlerProperties().onZoomStartedProperty();
    }

    public final void setOnZoom(
            EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoom() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnZoom();
    }

    /**
     * Defines a function to be called when user performs a zooming action.
     * @return the event handler that is called when user performs a zooming
     * action
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
            onZoomProperty() {
        return getEventHandlerProperties().onZoomProperty();
    }

    public final void setOnZoomFinished(
            EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomFinished() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnZoomFinished();
    }

    /**
     * Defines a function to be called when a zooming gesture ends.
     * @return the event handler that is called when a zooming gesture ends
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;
            onZoomFinishedProperty() {
        return getEventHandlerProperties().onZoomFinishedProperty();
    }

    public final void setOnSwipeUp(
            EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeUpProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeUp() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnSwipeUp();
    }

    /**
     * Defines a function to be called when an upward swipe gesture
     * centered over this node happens.
     * @return the event handler that is called when an upward swipe gesture
     * centered over this node happens
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
            onSwipeUpProperty() {
        return getEventHandlerProperties().onSwipeUpProperty();
    }

    public final void setOnSwipeDown(
            EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeDownProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeDown() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnSwipeDown();
    }

    /**
     * Defines a function to be called when a downward swipe gesture
     * centered over this node happens.
     * @return the event handler that is called when a downward swipe gesture
     * centered over this node happens
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
            onSwipeDownProperty() {
        return getEventHandlerProperties().onSwipeDownProperty();
    }

    public final void setOnSwipeLeft(
            EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeLeftProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeLeft() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnSwipeLeft();
    }

    /**
     * Defines a function to be called when a leftward swipe gesture
     * centered over this node happens.
     * @return the event handler that is called when a leftward swipe gesture
     * centered over this node happens
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
            onSwipeLeftProperty() {
        return getEventHandlerProperties().onSwipeLeftProperty();
    }

    public final void setOnSwipeRight(
            EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeRightProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeRight() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnSwipeRight();
    }

    /**
     * Defines a function to be called when an rightward swipe gesture
     * centered over this node happens.
     * @return the event handler that is called when an rightward swipe gesture
     * centered over this node happens
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;
            onSwipeRightProperty() {
        return getEventHandlerProperties().onSwipeRightProperty();
    }


    /* *************************************************************************
     *                                                                         *
     *                             Touch Handling                              *
     *                                                                         *
     **************************************************************************/

    public final void setOnTouchPressed(
            EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchPressedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchPressed() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnTouchPressed();
    }

    /**
     * Defines a function to be called when a new touch point is pressed.
     * @return the event handler that is called when a new touch point is pressed
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
            onTouchPressedProperty() {
        return getEventHandlerProperties().onTouchPressedProperty();
    }

    public final void setOnTouchMoved(
            EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchMovedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchMoved() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnTouchMoved();
    }

    /**
     * Defines a function to be called when a touch point is moved.
     * @return the event handler that is called when a touch point is moved
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
            onTouchMovedProperty() {
        return getEventHandlerProperties().onTouchMovedProperty();
    }

    public final void setOnTouchReleased(
            EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchReleased() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnTouchReleased();
    }

    /**
     * Defines a function to be called when a touch point is released.
     * @return the event handler that is called when a touch point is released
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
            onTouchReleasedProperty() {
        return getEventHandlerProperties().onTouchReleasedProperty();
    }

    public final void setOnTouchStationary(
            EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchStationaryProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchStationary() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnTouchStationary();
    }

    /**
     * Defines a function to be called when a touch point stays pressed and
     * still.
     * @return the event handler that is called when a touch point stays pressed
     * and still
     * @since JavaFX 2.2
     */
    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt;
            onTouchStationaryProperty() {
        return getEventHandlerProperties().onTouchStationaryProperty();
    }

    /* *************************************************************************
     *                                                                         *
     *                           Keyboard Handling                             *
     *                                                                         *
     **************************************************************************/

    public final void setOnKeyPressed(
            EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyPressedProperty().set(value);
    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyPressed() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnKeyPressed();
    }

    /**
     * Defines a function to be called when this {@code Node} or its child
     * {@code Node} has input focus and a key has been pressed. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     * @return the event handler that is called when this {@code Node} or its
     * child {@code Node} has input focus and a key has been pressed
     */
    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
            onKeyPressedProperty() {
        return getEventHandlerProperties().onKeyPressedProperty();
    }

    public final void setOnKeyReleased(
            EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyReleased() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnKeyReleased();
    }

    /**
     * Defines a function to be called when this {@code Node} or its child
     * {@code Node} has input focus and a key has been released. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     * @return the event handler that is called when this {@code Node} or its
     * child {@code Node} has input focus and a key has been released
     */
    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
            onKeyReleasedProperty() {
        return getEventHandlerProperties().onKeyReleasedProperty();
    }

    public final void setOnKeyTyped(
            EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyTypedProperty().set(value);
    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyTyped() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnKeyTyped();
    }

    /**
     * Defines a function to be called when this {@code Node} or its child
     * {@code Node} has input focus and a key has been typed. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     * @return the event handler that is called when this {@code Node} or its
     * child {@code Node} has input focus and a key has been typed
     */
    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt;
            onKeyTypedProperty() {
        return getEventHandlerProperties().onKeyTypedProperty();
    }

    /* *************************************************************************
     *                                                                         *
     *                           Input Method Handling                         *
     *                                                                         *
     **************************************************************************/

    public final void setOnInputMethodTextChanged(
            EventHandler&lt;? super InputMethodEvent&gt; value) {
        onInputMethodTextChangedProperty().set(value);
    }

    public final EventHandler&lt;? super InputMethodEvent&gt;
            getOnInputMethodTextChanged() {
        return (eventHandlerProperties == null)
                ? null : eventHandlerProperties.getOnInputMethodTextChanged();
    }

    /**
     * Defines a function to be called when this {@code Node}
     * has input focus and the input method text has changed.  If this
     * function is not defined in this {@code Node}, then it
     * receives the result string of the input method composition as a
     * series of {@code onKeyTyped} function calls.
     * &lt;p&gt;
     * When the {@code Node} loses the input focus, the JavaFX runtime
     * automatically commits the existing composed text if any.
     * &lt;/p&gt;
     * @return the event handler that is called when this {@code Node} has input
     * focus and the input method text has changed
     */
    public final ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt;
            onInputMethodTextChangedProperty() {
        return getEventHandlerProperties().onInputMethodTextChangedProperty();
    }

    public final void setInputMethodRequests(InputMethodRequests value) {
        inputMethodRequestsProperty().set(value);
    }

    public final InputMethodRequests getInputMethodRequests() {
        return (miscProperties == null)
                       ? DEFAULT_INPUT_METHOD_REQUESTS
                       : miscProperties.getInputMethodRequests();
    }

    /**
     * Property holding InputMethodRequests.
     *
     * @return InputMethodRequestsProperty
     */
    public final ObjectProperty&lt;InputMethodRequests&gt; inputMethodRequestsProperty() {
        return getMiscProperties().inputMethodRequestsProperty();
    }

    /***************************************************************************
     *                                                                         *
     *                             Focus Traversal                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Special boolean property which allows for atomic focus change.
     * Focus change means defocusing the old focus owner and focusing a new
     * one. With a usual property, defocusing the old node fires the value
     * changed event and user code can react with something that breaks
     * focusability of the new node, or even remove the new node from the scene.
     * This leads to various error states. This property allows for setting
     * the state without firing the event. The focus change first sets both
     * properties and then fires both events. This makes the focus change look
     * like an atomic operation - when the old node is notified to loose focus,
     * the new node is already focused.
     */
    final class FocusedProperty extends ReadOnlyBooleanPropertyBase {
        private boolean value;
        private boolean valid = true;
        private boolean needsChangeEvent = false;

        public void store(final boolean value) {
            if (value != this.value) {
                this.value = value;
                markInvalid();
            }
        }

        public void notifyListeners() {
            if (needsChangeEvent) {
                fireValueChangedEvent();
                needsChangeEvent = false;
            }
        }

        private void markInvalid() {
            if (valid) {
                valid = false;

                pseudoClassStateChanged(FOCUSED_PSEUDOCLASS_STATE, get());
                PlatformLogger logger = Logging.getFocusLogger();
                if (logger.isLoggable(Level.FINE)) {
                    logger.fine(this + &quot; focused=&quot; + get());
                }

                needsChangeEvent = true;

                notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUSED);
            }
        }

        @Override
        public boolean get() {
            valid = true;
            return value;
        }

        @Override
        public Object getBean() {
            return Node.this;
        }

        @Override
        public String getName() {
            return &quot;focused&quot;;
        }
    }

    /**
     * Indicates whether this {@code Node} currently has the input focus.
     * To have the input focus, a node must be the {@code Scene}'s focus
     * owner, and the scene must be in a {@code Stage} that is visible
     * and active. See {@link #requestFocus()} for more information.
     *
     * @see #requestFocus()
     * @defaultValue false
     */
    private FocusedProperty focused;

    protected final void setFocused(boolean value) {
        FocusedProperty fp = focusedPropertyImpl();
        if (fp.value != value) {
            fp.store(value);
            fp.notifyListeners();
        }
    }

    public final boolean isFocused() {
        return focused == null ? false : focused.get();
    }

    public final ReadOnlyBooleanProperty focusedProperty() {
        return focusedPropertyImpl();
    }

    private FocusedProperty focusedPropertyImpl() {
        if (focused == null) {
            focused = new FocusedProperty();
        }
        return focused;
    }

    /**
     * Specifies whether this {@code Node} should be a part of focus traversal
     * cycle. When this property is {@code true} focus can be moved to this
     * {@code Node} and from this {@code Node} using regular focus traversal
     * keys. On a desktop such keys are usually {@code TAB} for moving focus
     * forward and {@code SHIFT+TAB} for moving focus backward.
     *
     * When a {@code Scene} is created, the system gives focus to a
     * {@code Node} whose {@code focusTraversable} variable is true
     * and that is eligible to receive the focus,
     * unless the focus had been set explicitly via a call
     * to {@link #requestFocus()}.
     *
     * @see #requestFocus()
     * @defaultValue false
     */
    private BooleanProperty focusTraversable;

    public final void setFocusTraversable(boolean value) {
        focusTraversableProperty().set(value);
    }
    public final boolean isFocusTraversable() {
        return focusTraversable == null ? false : focusTraversable.get();
    }

    public final BooleanProperty focusTraversableProperty() {
        if (focusTraversable == null) {
            focusTraversable = new StyleableBooleanProperty(false) {

                @Override
                public void invalidated() {
                    Scene _scene = getScene();
                    if (_scene != null) {
                        if (get()) {
                            _scene.initializeInternalEventDispatcher();
                        }
                        focusSetDirty(_scene);
                    }
                }

                @Override
                public CssMetaData getCssMetaData() {
                    return StyleableProperties.FOCUS_TRAVERSABLE;
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;focusTraversable&quot;;
                }
            };
        }
        return focusTraversable;
    }

    /**
     * Called when something has changed on this node that *may* have made the
     * scene's focus dirty. This covers the cases where this node is the focus
     * owner and it may have lost eligibility, or it's traversable and it may
     * have gained eligibility. Note that we do not want to use disabled
     * or treeVisible here, as this function is called from their
     * &quot;on invalidate&quot; triggers, and using them will cause them to be
     * revalidated. The pulse will revalidate everything and make the final
     * determination.
     */
    private void focusSetDirty(Scene s) {
        if (s != null &amp;&amp;
            (this == s.getFocusOwner() || isFocusTraversable())) {
                s.setFocusDirty(true);
        }
    }

    /**
     * Requests that this {@code Node} get the input focus, and that this
     * {@code Node}'s top-level ancestor become the focused window. To be
     * eligible to receive the focus, the node must be part of a scene, it and
     * all of its ancestors must be visible, and it must not be disabled.
     * If this node is eligible, this function will cause it to become this
     * {@code Scene}'s &quot;focus owner&quot;. Each scene has at most one focus owner
     * node. The focus owner will not actually have the input focus, however,
     * unless the scene belongs to a {@code Stage} that is both visible
     * and active.
     */
    public void requestFocus() {
        if (getScene() != null) {
            getScene().requestFocus(this);
        }
    }

    /**
     * Traverses from this node in the direction indicated. Note that this
     * node need not actually have the focus, nor need it be focusTraversable.
     * However, the node must be part of a scene, otherwise this request
     * is ignored.
     */
    final boolean traverse(Direction dir) {
        if (getScene() == null) {
            return false;
        }
        return getScene().traverse(this, dir);
    }

    ////////////////////////////
    //  Private Implementation
    ////////////////////////////

     /**
      * Returns a string representation for the object.
      * @return a string representation for the object.
      */
    @Override
    public String toString() {
        String klassName = getClass().getName();
        String simpleName = klassName.substring(klassName.lastIndexOf('.')+1);
        StringBuilder sbuf = new StringBuilder(simpleName);
        boolean hasId = id != null &amp;&amp; !&quot;&quot;.equals(getId());
        boolean hasStyleClass = !getStyleClass().isEmpty();

        if (!hasId) {
            sbuf.append('@');
            sbuf.append(Integer.toHexString(hashCode()));
        } else {
            sbuf.append(&quot;[id=&quot;);
            sbuf.append(getId());
            if (!hasStyleClass) sbuf.append(&quot;]&quot;);
        }
        if (hasStyleClass) {
            if (!hasId) sbuf.append('[');
            else sbuf.append(&quot;, &quot;);
            sbuf.append(&quot;styleClass=&quot;);
            sbuf.append(getStyleClass());
            sbuf.append(&quot;]&quot;);
        }
        return sbuf.toString();
    }

    private void preprocessMouseEvent(MouseEvent e) {
        final EventType&lt;?&gt; eventType = e.getEventType();
        if (eventType == MouseEvent.MOUSE_PRESSED) {
            for (Node n = this; n != null; n = n.getParent()) {
                n.setPressed(e.isPrimaryButtonDown());
            }
            return;
        }
        if (eventType == MouseEvent.MOUSE_RELEASED) {
            for (Node n = this; n != null; n = n.getParent()) {
                n.setPressed(e.isPrimaryButtonDown());
            }
            return;
        }

        if (e.getTarget() == this) {
            // the mouse event types are translated only when the node uses
            // its internal event dispatcher, so both entered / exited variants
            // are possible here

            if ((eventType == MouseEvent.MOUSE_ENTERED)
                    || (eventType == MouseEvent.MOUSE_ENTERED_TARGET)) {
                setHover(true);
                return;
            }

            if ((eventType == MouseEvent.MOUSE_EXITED)
                    || (eventType == MouseEvent.MOUSE_EXITED_TARGET)) {
                setHover(false);
                return;
            }
        }
    }

    void markDirtyLayoutBranch() {
        Parent p = getParent();
        while (p != null &amp;&amp; p.layoutFlag == LayoutFlags.CLEAN) {
            p.setLayoutFlag(LayoutFlags.DIRTY_BRANCH);
            if (p.isSceneRoot()) {
                Toolkit.getToolkit().requestNextPulse();
                if (getSubScene() != null) {
                    getSubScene().setDirtyLayout(p);
                }
            }
            p = p.getParent();
        }

    }

    private boolean isWindowShowing() {
        Scene s = getScene();
        if (s == null) return false;
        Window w = s.getWindow();
        return w != null &amp;&amp; w.isShowing();
    }

    private void updateTreeShowing() {
        setTreeShowing(isTreeVisible() &amp;&amp; isWindowShowing());
    }

    private boolean treeShowing;
    private TreeShowingPropertyReadOnly treeShowingRO;

    final void setTreeShowing(boolean value) {
        if (treeShowing != value) {
            treeShowing = value;
            ((TreeShowingPropertyReadOnly) treeShowingProperty()).invalidate();
        }
    }

    final boolean isTreeShowing() {
        return treeShowingProperty().get();
    }

    final BooleanExpression treeShowingProperty() {
        if (treeShowingRO == null) {
            treeShowingRO = new TreeShowingPropertyReadOnly();
        }
        return treeShowingRO;
    }

    class TreeShowingPropertyReadOnly extends BooleanExpression {

        private ExpressionHelper&lt;Boolean&gt; helper;
        private boolean valid;

        @Override
        public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        protected void invalidate() {
            if (valid) {
                valid = false;
                ExpressionHelper.fireValueChangedEvent(helper);
            }
        }

        @Override
        public boolean get() {
            valid = true;
            return Node.this.treeShowing;
        }

    }

    private void updateTreeVisible(boolean parentChanged) {
        boolean isTreeVisible = isVisible();
        final Node parentNode = getParent() != null ? getParent() :
                    clipParent != null ? clipParent :
                    getSubScene() != null ? getSubScene() : null;
        if (isTreeVisible) {
            isTreeVisible = parentNode == null || parentNode.isTreeVisible();
        }
        // When the parent has changed to visible and we have unsynchronized visibility,
        // we have to synchronize, because the rendering will now pass through the newly-visible parent
        // Otherwise an invisible Node might get rendered
        if (parentChanged &amp;&amp; parentNode != null &amp;&amp; parentNode.isTreeVisible()
                &amp;&amp; isDirty(DirtyBits.NODE_VISIBLE)) {
            addToSceneDirtyList();
        }
        setTreeVisible(isTreeVisible);

        updateTreeShowing();
    }

    private boolean treeVisible;
    private TreeVisiblePropertyReadOnly treeVisibleRO;

    final void setTreeVisible(boolean value) {
        if (treeVisible != value) {
            treeVisible = value;
            updateCanReceiveFocus();
            focusSetDirty(getScene());
            if (getClip() != null) {
                getClip().updateTreeVisible(true);
            }
            if (treeVisible &amp;&amp; !isDirtyEmpty()) {
                addToSceneDirtyList();
            }
            ((TreeVisiblePropertyReadOnly) treeVisibleProperty()).invalidate();
            if (Node.this instanceof SubScene) {
                Node subSceneRoot = ((SubScene)Node.this).getRoot();
                if (subSceneRoot != null) {
                    // SubScene.getRoot() is only null if it's constructor
                    // has not finished.
                    subSceneRoot.setTreeVisible(value &amp;&amp; subSceneRoot.isVisible());
                }
            }
        }
    }

    final boolean isTreeVisible() {
        return treeVisibleProperty().get();
    }

    final BooleanExpression treeVisibleProperty() {
        if (treeVisibleRO == null) {
            treeVisibleRO = new TreeVisiblePropertyReadOnly();
        }
        return treeVisibleRO;
    }

    class TreeVisiblePropertyReadOnly extends BooleanExpression {

        private ExpressionHelper&lt;Boolean&gt; helper;
        private boolean valid;

        @Override
        public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        protected void invalidate() {
            if (valid) {
                valid = false;
                ExpressionHelper.fireValueChangedEvent(helper);
            }
        }

        @Override
        public boolean get() {
            valid = true;
            return Node.this.treeVisible;
        }

    }

    private boolean canReceiveFocus = false;

    private void setCanReceiveFocus(boolean value) {
        canReceiveFocus = value;
    }

    final boolean isCanReceiveFocus() {
        return canReceiveFocus;
    }

    private void updateCanReceiveFocus() {
        setCanReceiveFocus(getScene() != null
          &amp;&amp; !isDisabled()
          &amp;&amp; isTreeVisible());
    }

    // for indenting messages based on scene-graph depth
    String indent() {
        String indent = &quot;&quot;;
        Parent p = this.getParent();
        while (p != null) {
            indent += &quot;  &quot;;
            p = p.getParent();
        }
        return indent;
    }

    /*
     * Should we underline the mnemonic character?
     */
    private BooleanProperty showMnemonics;

    final void setShowMnemonics(boolean value) {
        showMnemonicsProperty().set(value);
    }

    final boolean isShowMnemonics() {
        return showMnemonics == null ? false : showMnemonics.get();
    }

    final BooleanProperty showMnemonicsProperty() {
        if (showMnemonics == null) {
            showMnemonics = new BooleanPropertyBase(false) {

                @Override
                protected void invalidated() {
                    pseudoClassStateChanged(SHOW_MNEMONICS_PSEUDOCLASS_STATE, get());
                }

                @Override
                public Object getBean() {
                    return Node.this;
                }

                @Override
                public String getName() {
                    return &quot;showMnemonics&quot;;
                }
            };
        }
        return showMnemonics;
    }


    /**
     * References a node that is a labelFor this node.
     * Accessible via a NodeAccessor. See Label.labelFor for details.
     */
    private Node labeledBy = null;


    /***************************************************************************
     *                                                                         *
     *                         Event Dispatch                                  *
     *                                                                         *
     **************************************************************************/

    // PENDING_DOC_REVIEW
    /**
     * Specifies the event dispatcher for this node. The default event
     * dispatcher sends the received events to the registered event handlers and
     * filters. When replacing the value with a new {@code EventDispatcher},
     * the new dispatcher should forward events to the replaced dispatcher
     * to maintain the node's default event handling behavior.
     */
    private ObjectProperty&lt;EventDispatcher&gt; eventDispatcher;

    public final void setEventDispatcher(EventDispatcher value) {
        eventDispatcherProperty().set(value);
    }

    public final EventDispatcher getEventDispatcher() {
        return eventDispatcherProperty().get();
    }

    public final ObjectProperty&lt;EventDispatcher&gt; eventDispatcherProperty() {
        initializeInternalEventDispatcher();
        return eventDispatcher;
    }

    private NodeEventDispatcher internalEventDispatcher;

    // PENDING_DOC_REVIEW
    /**
     * Registers an event handler to this node. The handler is called when the
     * node receives an {@code Event} of the specified type during the bubbling
     * phase of event delivery.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the type of the events to receive by the handler
     * @param eventHandler the handler to register
     * @throws NullPointerException if the event type or handler is null
     */
    public final &lt;T extends Event&gt; void addEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .addEventHandler(eventType, eventHandler);
    }

    // PENDING_DOC_REVIEW
    /**
     * Unregisters a previously registered event handler from this node. One
     * handler might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the handler.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type from which to unregister
     * @param eventHandler the handler to unregister
     * @throws NullPointerException if the event type or handler is null
     */
    public final &lt;T extends Event&gt; void removeEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher()
                .getEventHandlerManager()
                .removeEventHandler(eventType, eventHandler);
    }

    // PENDING_DOC_REVIEW
    /**
     * Registers an event filter to this node. The filter is called when the
     * node receives an {@code Event} of the specified type during the capturing
     * phase of event delivery.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the type of the events to receive by the filter
     * @param eventFilter the filter to register
     * @throws NullPointerException if the event type or filter is null
     */
    public final &lt;T extends Event&gt; void addEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .addEventFilter(eventType, eventFilter);
    }

    // PENDING_DOC_REVIEW
    /**
     * Unregisters a previously registered event filter from this node. One
     * filter might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the filter.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the event type from which to unregister
     * @param eventFilter the filter to unregister
     * @throws NullPointerException if the event type or filter is null
     */
    public final &lt;T extends Event&gt; void removeEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .removeEventFilter(eventType, eventFilter);
    }

    /**
     * Sets the handler to use for this event type. There can only be one such handler
     * specified at a time. This handler is guaranteed to be called as the last, after
     * handlers added using {@link #addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}.
     * This is used for registering the user-defined onFoo event handlers.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type to associate with the given eventHandler
     * @param eventHandler the handler to register, or null to unregister
     * @throws NullPointerException if the event type is null
     */
    protected final &lt;T extends Event&gt; void setEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .setEventHandler(eventType, eventHandler);
    }

    private NodeEventDispatcher getInternalEventDispatcher() {
        initializeInternalEventDispatcher();
        return internalEventDispatcher;
    }

    private void initializeInternalEventDispatcher() {
        if (internalEventDispatcher == null) {
            internalEventDispatcher = createInternalEventDispatcher();
            eventDispatcher = new SimpleObjectProperty&lt;EventDispatcher&gt;(
                                          Node.this,
                                          &quot;eventDispatcher&quot;,
                                          internalEventDispatcher);
        }
    }

    private NodeEventDispatcher createInternalEventDispatcher() {
        return new NodeEventDispatcher(this);
    }

    /**
     * Event dispatcher for invoking preprocessing of mouse events
     */
    private EventDispatcher preprocessMouseEventDispatcher;

    // PENDING_DOC_REVIEW
    /**
     * Construct an event dispatch chain for this node. The event dispatch chain
     * contains all event dispatchers from the stage to this node.
     *
     * @param tail the initial chain to build from
     * @return the resulting event dispatch chain for this node
     */
    @Override
    public EventDispatchChain buildEventDispatchChain(
            EventDispatchChain tail) {

        if (preprocessMouseEventDispatcher == null) {
            preprocessMouseEventDispatcher = (event, tail1) -&gt; {
                event = tail1.dispatchEvent(event);
                if (event instanceof MouseEvent) {
                    preprocessMouseEvent((MouseEvent) event);
                }

                return event;
            };
        }

        tail = tail.prepend(preprocessMouseEventDispatcher);

        // prepend all event dispatchers from this node to the root
        Node curNode = this;
        do {
            if (curNode.eventDispatcher != null) {
                final EventDispatcher eventDispatcherValue =
                        curNode.eventDispatcher.get();
                if (eventDispatcherValue != null) {
                    tail = tail.prepend(eventDispatcherValue);
                }
            }
            final Node curParent = curNode.getParent();
            curNode = curParent != null ? curParent : curNode.getSubScene();
        } while (curNode != null);

        if (getScene() != null) {
            // prepend scene's dispatch chain
            tail = getScene().buildEventDispatchChain(tail);
        }

        return tail;
    }

    // PENDING_DOC_REVIEW
    /**
     * Fires the specified event. By default the event will travel through the
     * hierarchy from the stage to this node. Any event filter encountered will
     * be notified and can consume the event. If not consumed by the filters,
     * the event handlers on this node are notified. If these don't consume the
     * event either, the event will travel back the same path it arrived to
     * this node. All event handlers encountered are called and can consume the
     * event.
     * &lt;p&gt;
     * This method must be called on the FX user thread.
     *
     * @param event the event to fire
     */
    public final void fireEvent(Event event) {

        /* Log input events.  We do a coarse filter for at least the FINE
         * level and then granularize from there.
         */
        if (event instanceof InputEvent) {
            PlatformLogger logger = Logging.getInputLogger();
            if (logger.isLoggable(Level.FINE)) {
                EventType eventType = event.getEventType();
                if (eventType == MouseEvent.MOUSE_ENTERED ||
                    eventType == MouseEvent.MOUSE_EXITED) {
                    logger.finer(event.toString());
                } else if (eventType == MouseEvent.MOUSE_MOVED ||
                           eventType == MouseEvent.MOUSE_DRAGGED) {
                    logger.finest(event.toString());
                } else {
                    logger.fine(event.toString());
                }
            }
        }

        Event.fireEvent(this, event);
    }

    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/


    /**
     * {@inheritDoc}
     * @return {@code getClass().getName()} without the package name
     * @since JavaFX 8.0
     */
    @Override
    public String getTypeSelector() {

        final Class&lt;?&gt; clazz = getClass();
        final Package pkg = clazz.getPackage();

        // package could be null. not likely, but could be.
        int plen = 0;
        if (pkg != null) {
            plen = pkg.getName().length();
        }

        final int clen = clazz.getName().length();
        final int pos = (0 &lt; plen &amp;&amp; plen &lt; clen) ? plen + 1 : 0;

        return clazz.getName().substring(pos);
    }

    /**
     * {@inheritDoc}
     * @return {@code getParent()}
     * @since JavaFX 8.0
     */
    @Override
    public Styleable getStyleableParent() {
        return getParent();
    }


    /**
     * Returns the initial focus traversable state of this node, for use
     * by the JavaFX CSS engine to correctly set its initial value. This method
     * can be overridden by subclasses in instances where focus traversable should
     * initially be true (as the default implementation of this method is to return
     * false).
     *
     * @return the initial focus traversable state for this {@code Node}.
     * @since 9
     */
    protected Boolean getInitialFocusTraversable() {
        return Boolean.FALSE;
    }

    /**
     * Returns the initial cursor state of this node, for use
     * by the JavaFX CSS engine to correctly set its initial value. This method
     * can be overridden by subclasses in instances where the cursor should
     * initially be non-null (as the default implementation of this method is to return
     * null).
     *
     * @return the initial cursor state for this {@code Node}.
     * @since 9
     */
    protected Cursor getInitialCursor() {
        return null;
    }

     /**
      * Super-lazy instantiation pattern from Bill Pugh.
      */
     private static class StyleableProperties {

        private static final CssMetaData&lt;Node,Cursor&gt; CURSOR =
            new CssMetaData&lt;Node,Cursor&gt;(&quot;-fx-cursor&quot;, CursorConverter.getInstance()) {

                @Override
                public boolean isSettable(Node node) {
                    return node.miscProperties == null || node.miscProperties.canSetCursor();
                }

                @Override
                public StyleableProperty&lt;Cursor&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Cursor&gt;)node.cursorProperty();
                }

                @Override
                public Cursor getInitialValue(Node node) {
                    // Most controls default focusTraversable to true.
                    // Give a way to have them return the correct default value.
                    return node.getInitialCursor();
                }

            };
        private static final CssMetaData&lt;Node,Effect&gt; EFFECT =
            new CssMetaData&lt;Node,Effect&gt;(&quot;-fx-effect&quot;, EffectConverter.getInstance()) {

                @Override
                public boolean isSettable(Node node) {
                    return node.miscProperties == null || node.miscProperties.canSetEffect();
                }

                @Override
                public StyleableProperty&lt;Effect&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Effect&gt;)node.effectProperty();
                }
            };
        private static final CssMetaData&lt;Node,Boolean&gt; FOCUS_TRAVERSABLE =
            new CssMetaData&lt;Node,Boolean&gt;(&quot;-fx-focus-traversable&quot;,
                BooleanConverter.getInstance(), Boolean.FALSE) {

                @Override
                public boolean isSettable(Node node) {
                    return node.focusTraversable == null || !node.focusTraversable.isBound();
                }

                @Override
                public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Boolean&gt;)node.focusTraversableProperty();
                }

                @Override
                public Boolean getInitialValue(Node node) {
                    // Most controls default focusTraversable to true.
                    // Give a way to have them return the correct default value.
                    return node.getInitialFocusTraversable();
                }

            };
        private static final CssMetaData&lt;Node,Number&gt; OPACITY =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-opacity&quot;,
                SizeConverter.getInstance(), 1.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.opacity == null || !node.opacity.isBound();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.opacityProperty();
                }
            };
        private static final CssMetaData&lt;Node,BlendMode&gt; BLEND_MODE =
            new CssMetaData&lt;Node,BlendMode&gt;(&quot;-fx-blend-mode&quot;, new EnumConverter&lt;BlendMode&gt;(BlendMode.class)) {

                @Override
                public boolean isSettable(Node node) {
                    return node.blendMode == null || !node.blendMode.isBound();
                }

                @Override
                public StyleableProperty&lt;BlendMode&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;BlendMode&gt;)node.blendModeProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; ROTATE =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-rotate&quot;,
                SizeConverter.getInstance(), 0.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.rotate == null
                        || node.nodeTransformation.canSetRotate();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.rotateProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; SCALE_X =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-x&quot;,
                SizeConverter.getInstance(), 1.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.scaleX == null
                        || node.nodeTransformation.canSetScaleX();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.scaleXProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; SCALE_Y =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-y&quot;,
                SizeConverter.getInstance(), 1.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.scaleY == null
                        || node.nodeTransformation.canSetScaleY();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.scaleYProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; SCALE_Z =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-scale-z&quot;,
                SizeConverter.getInstance(), 1.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.scaleZ == null
                        || node.nodeTransformation.canSetScaleZ();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.scaleZProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_X =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-x&quot;,
                SizeConverter.getInstance(), 0.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.translateX == null
                        || node.nodeTransformation.canSetTranslateX();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.translateXProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_Y =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-y&quot;,
                SizeConverter.getInstance(), 0.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.translateY == null
                        || node.nodeTransformation.canSetTranslateY();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.translateYProperty();
                }
            };
        private static final CssMetaData&lt;Node,Number&gt; TRANSLATE_Z =
            new CssMetaData&lt;Node,Number&gt;(&quot;-fx-translate-z&quot;,
                SizeConverter.getInstance(), 0.0) {

                @Override
                public boolean isSettable(Node node) {
                    return node.nodeTransformation == null
                        || node.nodeTransformation.translateZ == null
                        || node.nodeTransformation.canSetTranslateZ();
                }

                @Override
                public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Number&gt;)node.translateZProperty();
                }
            };
         private static final CssMetaData&lt;Node, Number&gt; VIEW_ORDER
                 = new CssMetaData&lt;Node, Number&gt;(&quot;-fx-view-order&quot;,
                         SizeConverter.getInstance(), 0.0) {

                     @Override
                     public boolean isSettable(Node node) {
                         return node.miscProperties == null
                         || node.miscProperties.viewOrder == null
                         || !node.miscProperties.viewOrder.isBound();
                     }

                     @Override
                     public StyleableProperty&lt;Number&gt; getStyleableProperty(Node node) {
                         return (StyleableProperty&lt;Number&gt;) node.viewOrderProperty();
                     }
                 };
        private static final CssMetaData&lt;Node,Boolean&gt; VISIBILITY =
            new CssMetaData&lt;Node,Boolean&gt;(&quot;visibility&quot;,
                new StyleConverter&lt;String,Boolean&gt;() {

                    @Override
                    // [ visible | hidden | collapse | inherit ]
                    public Boolean convert(ParsedValue&lt;String, Boolean&gt; value, Font font) {
                        final String sval = value != null ? value.getValue() : null;
                        return &quot;visible&quot;.equalsIgnoreCase(sval);
                    }

                },
                Boolean.TRUE) {

                @Override
                public boolean isSettable(Node node) {
                    return node.visible == null || !node.visible.isBound();
                }

                @Override
                public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Node node) {
                    return (StyleableProperty&lt;Boolean&gt;)node.visibleProperty();
                }
            };

         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;

         static {

             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                     new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;();
             styleables.add(CURSOR);
             styleables.add(EFFECT);
             styleables.add(FOCUS_TRAVERSABLE);
             styleables.add(OPACITY);
             styleables.add(BLEND_MODE);
             styleables.add(ROTATE);
             styleables.add(SCALE_X);
             styleables.add(SCALE_Y);
             styleables.add(SCALE_Z);
             styleables.add(VIEW_ORDER);
             styleables.add(TRANSLATE_X);
             styleables.add(TRANSLATE_Y);
             styleables.add(TRANSLATE_Z);
             styleables.add(VISIBILITY);
             STYLEABLES = Collections.unmodifiableList(styleables);

         }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        //
        // Super-lazy instantiation pattern from Bill Pugh. StyleableProperties
        // is referenced no earlier (and therefore loaded no earlier by the
        // class loader) than the moment that  getClassCssMetaData() is called.
        // This avoids loading the CssMetaData instances until the point at
        // which CSS needs the data.
        //
        return StyleableProperties.STYLEABLES;
    }

    /**
     * This method should delegate to {@link Node#getClassCssMetaData()} so that
     * a Node's CssMetaData can be accessed without the need for reflection.
     *
     * @return The CssMetaData associated with this node, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */

    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    /*
     * @return  The Styles that match this CSS property for the given Node. The
     * list is sorted by descending specificity.
     */
    // SB-dependency: RT-21096 has been filed to track this
    static List&lt;Style&gt; getMatchingStyles(CssMetaData cssMetaData, Styleable styleable) {
         return CssStyleHelper.getMatchingStyles(styleable, cssMetaData);
    }

    final ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; getStyleMap() {
         ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; map =
                 (ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;)getProperties().get(&quot;STYLEMAP&quot;);
         Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; ret = CssStyleHelper.getMatchingStyles(map, this);
         if (ret != null) {
             if (ret instanceof ObservableMap) return (ObservableMap)ret;
             return FXCollections.observableMap(ret);
         }
         return FXCollections.&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;emptyObservableMap();
     }

     /*
      * RT-17293
      */
     // SB-dependency: RT-21096 has been filed to track this
     final void setStyleMap(ObservableMap&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; styleMap) {
         if (styleMap != null) getProperties().put(&quot;STYLEMAP&quot;, styleMap);
         else getProperties().remove(&quot;STYLEMAP&quot;);
     }

    /*
     * Find CSS styles that were used to style this Node in its current pseudo-class state. The map will contain the styles from this node and,
     * if the node is a Parent, its children. The node corresponding to an entry in the Map can be obtained by casting a StyleableProperty key to a
     * javafx.beans.property.Property and calling getBean(). The List contains only those styles used to style the property and will contain
     * styles used to resolve lookup values.
     *
     * @param styleMap A Map to be populated with the styles. If null, a new Map will be allocated.
     * @return The Map populated with matching styles.
     */
    // SB-dependency: RT-21096 has been filed to track this
    Map&lt;StyleableProperty&lt;?&gt;,List&lt;Style&gt;&gt; findStyles(Map&lt;StyleableProperty&lt;?&gt;,List&lt;Style&gt;&gt; styleMap) {

        Map&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt; ret = CssStyleHelper.getMatchingStyles(styleMap, this);
        return (ret != null) ? ret : Collections.&lt;StyleableProperty&lt;?&gt;, List&lt;Style&gt;&gt;emptyMap();
    }

    /**
     * Flags used to indicate in which way this node is dirty (or whether it
     * is clean) and what must happen during the next CSS cycle on the
     * scenegraph.
     */
    CssFlags cssFlag = CssFlags.CLEAN;

    /**
     * Needed for testing.
     */
    final CssFlags getCSSFlags() { return cssFlag; }

    /**
     * Called when a CSS pseudo-class change would cause styles to be reapplied.
     */
    private void requestCssStateTransition() {
        // If there is no scene, then we cannot make it dirty, so we'll leave
        // the flag alone
        if (getScene() == null) return;
        // Don't bother doing anything if the cssFlag is not CLEAN.
        // If the flag indicates a DIRTY_BRANCH, the flag needs to be changed
        // to UPDATE to ensure that NodeHelper.processCSS is called on the node.
        if (cssFlag == CssFlags.CLEAN || cssFlag == CssFlags.DIRTY_BRANCH) {
            cssFlag = CssFlags.UPDATE;
            notifyParentsOfInvalidatedCSS();
        }
    }

    /**
     * Used to specify that a pseudo-class of this Node has changed. If the
     * pseudo-class is used in a CSS selector that matches this Node, CSS will
     * be reapplied. Typically, this method is called from the {@code invalidated}
     * method of a property that is used as a pseudo-class. For example:
     * &lt;pre&gt;&lt;code&gt;
     *
     *     private static final PseudoClass MY_PSEUDO_CLASS_STATE = PseudoClass.getPseudoClass(&quot;my-state&quot;);
     *
     *     BooleanProperty myPseudoClassState = new BooleanPropertyBase(false) {
     *
     *           {@literal @}Override public void invalidated() {
     *                pseudoClassStateChanged(MY_PSEUDO_CLASS_STATE, get());
     *           }
     *
     *           {@literal @}Override public Object getBean() {
     *               return MyControl.this;
     *           }
     *
     *           {@literal @}Override public String getName() {
     *               return &quot;myPseudoClassState&quot;;
     *           }
     *       };
     * &lt;/code&gt;&lt;/pre&gt;
     * @param pseudoClass the pseudo-class that has changed state
     * @param active whether or not the state is active
     * @since JavaFX 8.0
     */
    public final void pseudoClassStateChanged(PseudoClass pseudoClass, boolean active) {

        final boolean modified = active
                ? pseudoClassStates.add(pseudoClass)
                : pseudoClassStates.remove(pseudoClass);

        if (modified &amp;&amp; styleHelper != null) {
            final boolean isTransition = styleHelper.pseudoClassStateChanged(pseudoClass);
            if (isTransition) {
                requestCssStateTransition();
            }
        }
   }

    // package so that StyleHelper can get at it
    final ObservableSet&lt;PseudoClass&gt; pseudoClassStates = new PseudoClassState();
    /**
     * @return The active pseudo-class states of this Node, wrapped in an unmodifiable ObservableSet
     * @since JavaFX 8.0
     */
    public final ObservableSet&lt;PseudoClass&gt; getPseudoClassStates() {

        return FXCollections.unmodifiableObservableSet(pseudoClassStates);

    }

    // Walks up the tree telling each parent that the pseudo class state of
    // this node has changed.
    final void notifyParentsOfInvalidatedCSS() {
        SubScene subScene = getSubScene();
        Parent root = (subScene != null) ?
                subScene.getRoot() : getScene().getRoot();

        if (!root.isDirty(DirtyBits.NODE_CSS)) {
            // Ensure that Scene.root is marked as dirty. If the scene isn't
            // dirty, nothing will get repainted. This bit is cleared from
            // Scene in doCSSPass().
            NodeHelper.markDirty(root, DirtyBits.NODE_CSS);
            if (subScene != null) {
                // If the node is part of a subscene, then we must ensure that
                // the we not only mark subScene.root dirty, but continue and
                // call subScene.notifyParentsOfInvalidatedCSS() until
                // Scene.root gets marked dirty, via the recursive call:
                subScene.cssFlag = CssFlags.UPDATE;
                subScene.notifyParentsOfInvalidatedCSS();
            }
        }
        Parent _parent = getParent();
        while (_parent != null) {
            if (_parent.cssFlag == CssFlags.CLEAN) {
                _parent.cssFlag = CssFlags.DIRTY_BRANCH;
                _parent = _parent.getParent();
            } else {
                _parent = null;
            }
        }
    }

    final void reapplyCSS() {

        if (getScene() == null) return;

        if (cssFlag == CssFlags.REAPPLY) return;

        // RT-36838 - don't reapply CSS in the middle of an update
        if (cssFlag == CssFlags.UPDATE) {
            cssFlag = CssFlags.REAPPLY;
            notifyParentsOfInvalidatedCSS();
            return;
        }

        reapplyCss();

        //
        // One idiom employed by developers is to, during the layout pass,
        // add or remove nodes from the scene. For example, a ScrollPane
        // might add scroll bars to itself if it determines during layout
        // that it needs them, or a ListView might add cells to itself if
        // it determines that it needs to. In such situations we must
        // apply the CSS immediately and not add it to the scene's queue
        // for deferred action.
        //
        if (getParent() != null &amp;&amp; getParent().isPerformingLayout()) {
            NodeHelper.processCSS(this);
        } else {
            notifyParentsOfInvalidatedCSS();
        }

    }

    //
    // This method &quot;reapplies&quot; CSS to this node and all of its children. Reapplying CSS
    // means that new style maps are calculated for the node. The process of reapplying
    // CSS may reset the CSS properties of a node to their initial state, but the _new_
    // styles are not applied as part of this process.
    //
    // There is no check of the CSS state of a child since reapply takes precedence
    // over other CSS states.
    //
    private void reapplyCss() {

        // Hang on to current styleHelper so we can know whether
        // createStyleHelper returned the same styleHelper
        final CssStyleHelper oldStyleHelper = styleHelper;

        // CSS state is &quot;REAPPLY&quot;
        cssFlag = CssFlags.REAPPLY;

        styleHelper = CssStyleHelper.createStyleHelper(this);

        // REAPPLY to my children, too.
        if (this instanceof Parent) {

            // minor optimization to avoid calling createStyleHelper on children
            // when we know there will not be any change in the style maps.
            final boolean visitChildren =
                    // If we don't have a styleHelper, then we should visit the children of this parent
                    // since there might be styles that depend on being a child of this parent.
                    // In other words, we have .a &gt; .b { blah: blort; }, but no styles for &quot;.a&quot; itself.
                    styleHelper == null ||
                    // if the styleHelper changed, then we definitely need to visit the children
                    // since the new styles may have an effect on the children's styles calculated values.
                    (oldStyleHelper != styleHelper) ||
                    // If our parent is null, then we're the root of a scene or sub-scene, most likely,
                    // and we'll visit children because elsewhere the code depends on root.reapplyCSS()
                    // to force css to be reapplied (whether it needs to be or not).
                    (getParent() == null) ||
                    // If our parent's cssFlag is other than clean, then the parent may have just had
                    // CSS reapplied. If the parent just had CSS reapplied, then some of its styles
                    // may affect my children's styles.
                    (getParent().cssFlag != CssFlags.CLEAN);

            if (visitChildren) {

                List&lt;Node&gt; children = ((Parent) this).getChildren();
                for (int n = 0, nMax = children.size(); n &lt; nMax; n++) {
                    Node child = children.get(n);
                    child.reapplyCss();
                }
            }

        } else if (this instanceof SubScene) {

            // SubScene root is a Parent, but reapplyCss is a private method in Node
            final Node subSceneRoot = ((SubScene)this).getRoot();
            if (subSceneRoot != null) {
                subSceneRoot.reapplyCss();
            }

        } else if (styleHelper == null) {
            //
            // If this is not a Parent and there is no styleHelper, then the CSS state is &quot;CLEAN&quot;
            // since there are no styles to apply or children to update.
            //
            cssFlag = CssFlags.CLEAN;
            return;
        }

        cssFlag = CssFlags.UPDATE;

    }

    void processCSS() {
        switch (cssFlag) {
            case CLEAN:
                break;
            case DIRTY_BRANCH:
            {
                Parent me = (Parent)this;
                // clear the flag first in case the flag is set to something
                // other than clean by downstream processing.
                me.cssFlag = CssFlags.CLEAN;
                List&lt;Node&gt; children = me.getChildren();
                for (int i=0, max=children.size(); i&lt;max; i++) {
                    children.get(i).processCSS();
                }
                break;
            }
            case REAPPLY:
            case UPDATE:
            default:
                NodeHelper.processCSS(this);
        }
    }

    /**
     * If required, apply styles to this Node and its children, if any. This method does not normally need to
     * be invoked directly but may be used in conjunction with {@link Parent#layout()} to size a Node before the
     * next pulse, or if the {@link #getScene() Scene} is not in a {@link javafx.stage.Stage}.
     * &lt;p&gt;Provided that the Node&amp;#39;s {@link #getScene() Scene} is not null, CSS is applied to this Node regardless
     * of whether this Node&amp;#39;s CSS state is clean. CSS styles are applied from the top-most parent
     * of this Node whose CSS state is other than clean, which may affect the styling of other nodes.
     * This method is a no-op if the Node is not in a Scene. The Scene does not have to be in a Stage.&lt;/p&gt;
     * &lt;p&gt;This method does not invoke the {@link Parent#layout()} method. Typically, the caller will use the
     * following sequence of operations.&lt;/p&gt;
     * &lt;pre&gt;{@code
     *     parentNode.applyCss();
     *     parentNode.layout();
     * }&lt;/pre&gt;
     * &lt;p&gt;As a more complete example, the following code uses {@code applyCss()} and {@code layout()} to find
     * the width and height of the Button before the Stage has been shown. If either the call to {@code applyCss()}
     * or the call to {@code layout()} is commented out, the calls to {@code getWidth()} and {@code getHeight()}
     * will return zero (until some time after the Stage is shown). &lt;/p&gt;
     * &lt;pre&gt;&lt;code&gt;
     * {@literal @}Override
     * public void start(Stage stage) throws Exception {
     *
     *    Group root = new Group();
     *    Scene scene = new Scene(root);
     *
     *    Button button = new Button(&quot;Hello World&quot;);
     *    root.getChildren().add(button);
     *
     *    root.applyCss();
     *    root.layout();
     *
     *    double width = button.getWidth();
     *    double height = button.getHeight();
     *
     *    System.out.println(width + &quot;, &quot; + height);
     *
     *    stage.setScene(scene);
     *    stage.show();
     * }
     * &lt;/code&gt;&lt;/pre&gt;
     * @since JavaFX 8.0
     */
    public final void applyCss() {

        if (getScene() == null) {
            return;
        }

        // update, unless reapply
        if (cssFlag != CssFlags.REAPPLY) cssFlag = CssFlags.UPDATE;

        //
        // RT-28394 - need to see if any ancestor has a flag UPDATE
        // If so, process css from the top-most CssFlags.UPDATE node
        // since my ancestor's styles may affect mine.
        //
        // If the scene-graph root isn't NODE_CSS dirty, then all my
        // ancestor flags should be CLEAN and I can skip this lookup.
        //
        Node topMost = this;

        final boolean dirtyRoot = getScene().getRoot().isDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
        if (dirtyRoot) {

            Node _parent = getParent();
            while (_parent != null) {
                if (_parent.cssFlag == CssFlags.UPDATE || _parent.cssFlag == CssFlags.REAPPLY) {
                    topMost = _parent;
                }
                _parent = _parent.getParent();
            }

            // Note: this code used to mark the parent nodes with DIRTY_BRANCH,
            // but that isn't necessary since UPDATE will apply css to all of
            // a Parent's children.

            // If we're at the root of the scene-graph, make sure the NODE_CSS
            // dirty bit is cleared (see Scene#doCSSPass())
            if (topMost == getScene().getRoot()) {
                getScene().getRoot().clearDirty(DirtyBits.NODE_CSS);
            }
        }

        topMost.processCSS();

    }

    /*
     * If invoked, will update styles from here on down. This method should not be called directly. If
     * overridden, the overriding method must at some point call {@code super.processCSSImpl} to ensure that
     * this Node's CSS state is properly updated.
     *
     * Note that the difference between this method and {@link #applyCss()} is that this method
     * updates styles for this node on down; whereas, {@code applyCss()} looks for the top-most ancestor that needs
     * CSS update and apply styles from that node on down.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doProcessCSS() {

        // Nothing to do...
        if (cssFlag == CssFlags.CLEAN) return;

        // if REAPPLY was deferred, process it now...
        if (cssFlag == CssFlags.REAPPLY) {
            reapplyCss();
        }

        // Clear the flag first in case the flag is set to something
        // other than clean by downstream processing.
        cssFlag = CssFlags.CLEAN;

        // Transition to the new state and apply styles
        if (styleHelper != null &amp;&amp; getScene() != null) {
            styleHelper.transitionToState(this);
        }
    }


    /**
     * A StyleHelper for this node.
     * A StyleHelper contains all the css styles for this node
     * and knows how to apply them when our state changes.
     */
    CssStyleHelper styleHelper;

    private static final PseudoClass HOVER_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;hover&quot;);
    private static final PseudoClass PRESSED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;pressed&quot;);
    private static final PseudoClass DISABLED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;disabled&quot;);
    private static final PseudoClass FOCUSED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;focused&quot;);
    private static final PseudoClass SHOW_MNEMONICS_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;show-mnemonics&quot;);

    private static abstract class LazyTransformProperty
            extends ReadOnlyObjectProperty&lt;Transform&gt; {

        protected static final int VALID = 0;
        protected static final int INVALID = 1;
        protected static final int VALIDITY_UNKNOWN = 2;
        protected int valid = INVALID;

        private ExpressionHelper&lt;Transform&gt; helper;

        private Transform transform;
        private boolean canReuse = false;

        @Override
        public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public void addListener(ChangeListener&lt;? super Transform&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(ChangeListener&lt;? super Transform&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        protected Transform getInternalValue() {
            if (valid == INVALID ||
                    (valid == VALIDITY_UNKNOWN &amp;&amp; computeValidity() == INVALID)) {
                transform = computeTransform(canReuse ? transform : null);
                canReuse = true;
                valid = validityKnown() ? VALID : VALIDITY_UNKNOWN;
            }

            return transform;
        }

        @Override
        public Transform get() {
            transform = getInternalValue();
            canReuse = false;
            return transform;
        }

        public void validityUnknown() {
            if (valid == VALID) {
                valid = VALIDITY_UNKNOWN;
            }
        }

        public void invalidate() {
            if (valid != INVALID) {
                valid = INVALID;
                ExpressionHelper.fireValueChangedEvent(helper);
            }
        }

        protected abstract boolean validityKnown();
        protected abstract int computeValidity();
        protected abstract Transform computeTransform(Transform reuse);
    }

    private static abstract class LazyBoundsProperty
            extends ReadOnlyObjectProperty&lt;Bounds&gt; {
        private ExpressionHelper&lt;Bounds&gt; helper;
        private boolean valid;

        private Bounds bounds;

        @Override
        public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public void addListener(ChangeListener&lt;? super Bounds&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(ChangeListener&lt;? super Bounds&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public Bounds get() {
            if (!valid) {
                bounds = computeBounds();
                valid = true;
            }

            return bounds;
        }

        public void invalidate() {
            if (valid) {
                valid = false;
                ExpressionHelper.fireValueChangedEvent(helper);
            }
        }

        protected abstract Bounds computeBounds();
    }

    private static final BoundsAccessor boundsAccessor = (bounds, tx, node) -&gt; node.getGeomBounds(bounds, tx);

    /**
     * The accessible role for this {@code Node}.
     * &lt;p&gt;
     * The screen reader uses the role of a node to determine the
     * attributes and actions that are supported.
     *
     * @defaultValue {@link AccessibleRole#NODE}
     * @see AccessibleRole
     *
     * @since JavaFX 8u40
     */
    private ObjectProperty&lt;AccessibleRole&gt; accessibleRole;

    public final void setAccessibleRole(AccessibleRole value) {
        if (value == null) value = AccessibleRole.NODE;
        accessibleRoleProperty().set(value);
    }

    public final AccessibleRole getAccessibleRole() {
        if (accessibleRole == null) return AccessibleRole.NODE;
        return accessibleRoleProperty().get();
    }

    public final ObjectProperty&lt;AccessibleRole&gt; accessibleRoleProperty() {
        if (accessibleRole == null) {
            accessibleRole = new SimpleObjectProperty&lt;AccessibleRole&gt;(this, &quot;accessibleRole&quot;, AccessibleRole.NODE);
        }
        return accessibleRole;
    }

    public final void setAccessibleRoleDescription(String value) {
        accessibleRoleDescriptionProperty().set(value);
    }

    public final String getAccessibleRoleDescription() {
        if (accessibilityProperties == null) return null;
        if (accessibilityProperties.accessibleRoleDescription == null) return null;
        return accessibleRoleDescriptionProperty().get();
    }

    /**
     * The role description of this {@code Node}.
     * &lt;p&gt;
     * Normally, when a role is provided for a node, the screen reader
     * speaks the role as well as the contents of the node.  When this
     * value is set, it is possible to override the default.  This is
     * useful because the set of roles is predefined.  For example,
     * it is possible to set the role of a node to be a button, but
     * have the role description be arbitrary text.
     *
     * @return the role description of this {@code Node}.
     * @defaultValue null
     *
     * @since JavaFX 8u40
     */
    public final ObjectProperty&lt;String&gt; accessibleRoleDescriptionProperty() {
        return getAccessibilityProperties().getAccessibleRoleDescription();
    }

    public final void setAccessibleText(String value) {
        accessibleTextProperty().set(value);
    }

    public final String getAccessibleText() {
        if (accessibilityProperties == null) return null;
        if (accessibilityProperties.accessibleText == null) return null;
        return accessibleTextProperty().get();
    }

    /**
     * The accessible text for this {@code Node}.
     * &lt;p&gt;
     * This property is used to set the text that the screen
     * reader will speak.  If a node normally speaks text,
     * that text is overriden.  For example, a button
     * usually speaks using the text in the control but will
     * no longer do this when this value is set.
     *
     * @return accessible text for this {@code Node}.
     * @defaultValue null
     *
     * @since JavaFX 8u40
     */
    public final ObjectProperty&lt;String&gt; accessibleTextProperty() {
        return getAccessibilityProperties().getAccessibleText();
    }

    public final void setAccessibleHelp(String value) {
        accessibleHelpProperty().set(value);
    }

    public final String getAccessibleHelp() {
        if (accessibilityProperties == null) return null;
        if (accessibilityProperties.accessibleHelp == null) return null;
        return accessibleHelpProperty().get();
    }

    /**
     * The accessible help text for this {@code Node}.
     * &lt;p&gt;
     * The help text provides a more detailed description of the
     * accessible text for a node.  By default, if the node has
     * a tool tip, this text is used.
     *
     * @return the accessible help text for this {@code Node}.
     * @defaultValue null
     *
     * @since JavaFX 8u40
     */
    public final ObjectProperty&lt;String&gt; accessibleHelpProperty() {
        return getAccessibilityProperties().getAccessibleHelp();
    }

    AccessibilityProperties accessibilityProperties;
    private AccessibilityProperties getAccessibilityProperties() {
        if (accessibilityProperties == null) {
            accessibilityProperties = new AccessibilityProperties();
        }
        return accessibilityProperties;
    }

    private class AccessibilityProperties {
        ObjectProperty&lt;String&gt; accessibleRoleDescription;
        ObjectProperty&lt;String&gt; getAccessibleRoleDescription() {
            if (accessibleRoleDescription == null) {
                accessibleRoleDescription = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleRoleDescription&quot;, null);
            }
            return accessibleRoleDescription;
        }
        ObjectProperty&lt;String&gt; accessibleText;
        ObjectProperty&lt;String&gt; getAccessibleText() {
            if (accessibleText == null) {
                accessibleText = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleText&quot;, null);
            }
            return accessibleText;
        }
        ObjectProperty&lt;String&gt; accessibleHelp;
        ObjectProperty&lt;String&gt; getAccessibleHelp() {
            if (accessibleHelp == null) {
                accessibleHelp = new SimpleObjectProperty&lt;String&gt;(Node.this, &quot;accessibleHelp&quot;, null);
            }
            return accessibleHelp;
        }
    }

    /**
     * This method is called by the assistive technology to request
     * the value for an attribute.
     * &lt;p&gt;
     * This method is commonly overridden by subclasses to implement
     * attributes that are required for a specific role.&lt;br&gt;
     * If a particular attribute is not handled, the superclass implementation
     * must be called.
     * &lt;/p&gt;
     *
     * @param attribute the requested attribute
     * @param parameters optional list of parameters
     * @return the value for the requested attribute
     *
     * @see AccessibleAttribute
     *
     * @since JavaFX 8u40
     */
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case ROLE: return getAccessibleRole();
            case ROLE_DESCRIPTION: return getAccessibleRoleDescription();
            case TEXT: return getAccessibleText();
            case HELP: return getAccessibleHelp();
            case PARENT: return getParent();
            case SCENE: return getScene();
            case BOUNDS: return localToScreen(getBoundsInLocal());
            case DISABLED: return isDisabled();
            case FOCUSED: return isFocused();
            case VISIBLE: return isVisible();
            case LABELED_BY: return labeledBy;
            default: return null;
        }
    }

    /**
     * This method is called by the assistive technology to request the action
     * indicated by the argument should be executed.
     * &lt;p&gt;
     * This method is commonly overridden by subclasses to implement
     * action that are required for a specific role.&lt;br&gt;
     * If a particular action is not handled, the superclass implementation
     * must be called.
     * &lt;/p&gt;
     *
     * @param action the action to execute
     * @param parameters optional list of parameters
     *
     * @see AccessibleAction
     *
     * @since JavaFX 8u40
     */
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case REQUEST_FOCUS:
                if (isFocusTraversable()) {
                    requestFocus();
                }
                break;
            case SHOW_MENU: {
                Bounds b = getBoundsInLocal();
                Point2D pt = localToScreen(b.getMaxX(), b.getMaxY());
                ContextMenuEvent event =
                    new ContextMenuEvent(ContextMenuEvent.CONTEXT_MENU_REQUESTED,
                    b.getMaxX(), b.getMaxY(), pt.getX(), pt.getY(),
                    false, new PickResult(this, b.getMaxX(), b.getMaxY()));
                Event.fireEvent(this, event);
                break;
            }
            default:
        }
    }

    /**
     * This method is called by the application to notify the assistive
     * technology that the value for an attribute has changed.
     *
     * @param attributes the attribute whose value has changed
     *
     * @see AccessibleAttribute
     *
     * @since JavaFX 8u40
     */
    public final void notifyAccessibleAttributeChanged(AccessibleAttribute attributes) {
        if (accessible == null) {
            Scene scene = getScene();
            if (scene != null) {
                accessible = scene.removeAccessible(this);
            }
        }
        if (accessible != null) {
            accessible.sendNotification(attributes);
        }
    }

    Accessible accessible;
    Accessible getAccessible() {
        if (accessible == null) {
            Scene scene = getScene();
            /* It is possible the node was reparented and getAccessible()
             * is called before the pulse. Try to recycle the accessible
             * before creating a new one.
             * Note: this code relies that an accessible can never be on
             * more than one Scene#accMap. Thus, the only way
             * scene#removeAccessible() returns non-null is if the node
             * old scene and new scene are the same object.
             */
            if (scene != null) {
                accessible = scene.removeAccessible(this);
            }
        }
        if (accessible == null) {
            accessible = Application.GetApplication().createAccessible();
            accessible.setEventHandler(new Accessible.EventHandler() {
                @SuppressWarnings(&quot;deprecation&quot;)
                @Override public AccessControlContext getAccessControlContext() {
                    Scene scene = getScene();
                    if (scene == null) {
                        /* This can happen during the release process of an accessible object. */
                        throw new RuntimeException(&quot;Accessbility requested for node not on a scene&quot;);
                    }
                    if (scene.getPeer() != null) {
                        return scene.getPeer().getAccessControlContext();
                    } else {
                        /* In some rare cases the accessible for a Node is needed
                         * before its scene is made visible. For example, the screen reader
                         * might ask a Menu for its ContextMenu before the ContextMenu
                         * is made visible. That is a problem because the Window for the
                         * ContextMenu is only created immediately before the first time
                         * it is shown.
                         */
                        return scene.acc;
                    }
                }
                @Override public Object getAttribute(AccessibleAttribute attribute, Object... parameters) {
                    return queryAccessibleAttribute(attribute, parameters);
                }
                @Override public void executeAction(AccessibleAction action, Object... parameters) {
                    executeAccessibleAction(action, parameters);
                }
                @Override public String toString() {
                    String klassName = Node.this.getClass().getName();
                    return klassName.substring(klassName.lastIndexOf('.')+1);
                }
            });
        }
        return accessible;
    }

    void releaseAccessible() {
        Accessible acc = this.accessible;
        if (acc != null) {
            accessible = null;
            acc.dispose();
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/Parent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene;

import com.sun.javafx.scene.traversal.ParentTraversalEngine;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyBooleanWrapper;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener.Change;
import javafx.collections.ObservableList;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.sun.javafx.util.TempState;
import com.sun.javafx.util.Utils;
import com.sun.javafx.collections.TrackableObservableList;
import com.sun.javafx.collections.VetoableListDecorator;
import javafx.css.Selector;
import com.sun.javafx.css.StyleManager;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.Point2D;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.javafx.scene.CssFlags;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.input.PickResultChooser;
import com.sun.javafx.sg.prism.NGGroup;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.tk.Toolkit;
import com.sun.javafx.scene.LayoutFlags;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.ParentHelper;
import com.sun.javafx.stage.WindowHelper;
import java.util.Collections;
import javafx.stage.Window;

/**
 * The base class for all nodes that have children in the scene graph.
 * &lt;p&gt;
 * This class handles all hierarchical scene graph operations, including adding/removing
 * child nodes, marking branches dirty for layout and rendering, picking,
 * bounds calculations, and executing the layout pass on each pulse.
 * &lt;p&gt;
 * There are two direct concrete Parent subclasses
 * &lt;ul&gt;
 * &lt;li&gt;{@link Group} effects and transforms to be applied to a collection of child nodes.&lt;/li&gt;
 * &lt;li&gt;{@link javafx.scene.layout.Region} class for nodes that can be styled with CSS and layout children. &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @since JavaFX 2.0
 */
public abstract class Parent extends Node {
    // package private for testing
    static final int DIRTY_CHILDREN_THRESHOLD = 10;

    // If set to true, generate a warning message whenever adding a node to a
    // parent if it is currently a child of another parent.
    private static final boolean warnOnAutoMove = PropertyHelper.getBooleanProperty(&quot;javafx.sg.warn&quot;);

    /**
     * Threshold when it's worth to populate list of removed children.
     */
    private static final int REMOVED_CHILDREN_THRESHOLD = 20;

    /**
     * Do not populate list of removed children when its number exceeds threshold,
     * but mark whole parent dirty.
     */
    private boolean removedChildrenOptimizationDisabled = false;

    static {
        // This is used by classes in different packages to get access to
        // private and package private methods.
        ParentHelper.setParentAccessor(new ParentHelper.ParentAccessor() {
            @Override
            public NGNode doCreatePeer(Node node) {
                return ((Parent) node).doCreatePeer();
            }

            @Override
            public void doUpdatePeer(Node node) {
                ((Parent) node).doUpdatePeer();
            }

            @Override
            public BaseBounds doComputeGeomBounds(Node node,
                    BaseBounds bounds, BaseTransform tx) {
                return ((Parent) node).doComputeGeomBounds(bounds, tx);
            }

            @Override
            public boolean doComputeContains(Node node, double localX, double localY) {
                return ((Parent) node).doComputeContains(localX, localY);
            }

            @Override
            public void doProcessCSS(Node node) {
                ((Parent) node).doProcessCSS();
            }

            @Override
            public void doPickNodeLocal(Node node, PickRay localPickRay,
                    PickResultChooser result) {
                ((Parent) node).doPickNodeLocal(localPickRay, result);
            }

            @Override
            public boolean pickChildrenNode(Parent parent, PickRay pickRay, PickResultChooser result) {
                return parent.pickChildrenNode(pickRay, result);
            }

            @Override
            public void setTraversalEngine(Parent parent, ParentTraversalEngine value) {
                parent.setTraversalEngine(value);
            }

            @Override
            public ParentTraversalEngine getTraversalEngine(Parent parent) {
                return parent.getTraversalEngine();
            }

            @Override
            public List&lt;String&gt; doGetAllParentStylesheets(Parent parent) {
                return parent.doGetAllParentStylesheets();
            }
        });
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        final NGGroup peer = getPeer();

        if (Utils.assertionEnabled()) {
            List&lt;NGNode&gt; pgnodes = peer.getChildren();
            if (pgnodes.size() != pgChildrenSize) {
                java.lang.System.err.println(&quot;*** pgnodes.size() [&quot; + pgnodes.size() + &quot;] != pgChildrenSize [&quot; + pgChildrenSize + &quot;]&quot;);
            }
        }

        if (isDirty(DirtyBits.PARENT_CHILDREN)) {
            // Whether a permutation, or children having been added or
            // removed, we'll want to clear out the PG side starting
            // from startIdx. We know that everything up to but not
            // including startIdx is identical between the FX and PG
            // sides, so we only need to update the remaining portion.
            peer.clearFrom(startIdx);
            for (int idx = startIdx; idx &lt; children.size(); idx++) {
                peer.add(idx, children.get(idx).getPeer());
            }
            if (removedChildrenOptimizationDisabled) {
                peer.markDirty();
                removedChildrenOptimizationDisabled = false;
            } else {
                if (removed != null &amp;&amp; !removed.isEmpty()) {
                    for(int i = 0; i &lt; removed.size(); i++) {
                        peer.addToRemoved(removed.get(i).getPeer());
                    }
                }
            }
            if (removed != null) {
                removed.clear();
            }
            pgChildrenSize = children.size();
            startIdx = pgChildrenSize;
        }

        if (isDirty(DirtyBits.PARENT_CHILDREN_VIEW_ORDER)) {
            computeViewOrderChidrenAndUpdatePeer();
        }

        if (Utils.assertionEnabled()) validatePG();
    }


    /***********************************************************************
     *                        Scenegraph Structure                         *
     *                                                                     *
     *  Functions and variables related to the scenegraph structure,       *
     *  modifying the structure, and walking the structure.                *
     *                                                                     *
     **********************************************************************/

    // Used to check for duplicate nodes
    private final Set&lt;Node&gt; childSet = new HashSet&lt;Node&gt;();

    // starting child index from which we need to send the children to the PGGroup
    private int startIdx = 0;

    // double of children in the PGGroup as of the last update
    private int pgChildrenSize = 0;

    void validatePG() {
        boolean assertionFailed = false;
        final NGGroup peer = getPeer();
        List&lt;NGNode&gt; pgnodes = peer.getChildren();
        if (pgnodes.size() != children.size()) {
            java.lang.System.err.println(&quot;*** pgnodes.size validatePG() [&quot; + pgnodes.size() + &quot;] != children.size() [&quot; + children.size() + &quot;]&quot;);
            assertionFailed = true;
        } else {
            for (int idx = 0; idx &lt; children.size(); idx++) {
                Node n = children.get(idx);
                if (n.getParent() != this) {
                    java.lang.System.err.println(&quot;*** this=&quot; + this + &quot; validatePG children[&quot; + idx + &quot;].parent= &quot; + n.getParent());
                    assertionFailed = true;
                }
                if (n.getPeer() != pgnodes.get(idx)) {
                    java.lang.System.err.println(&quot;*** pgnodes[&quot; + idx + &quot;] validatePG != children[&quot; + idx + &quot;]&quot;);
                    assertionFailed = true;
                }
            }
        }
        if (assertionFailed) {
            throw new java.lang.AssertionError(&quot;validation of PGGroup children failed&quot;);
        }

    }

    void printSeq(String prefix, List&lt;Node&gt; nodes) {
        String str = prefix;
        for (Node nn : nodes) {
            str += nn + &quot; &quot;;
        }
        System.out.println(str);
    }

    /**
     * The viewOrderChildren is a list children sorted in decreasing viewOrder
     * order if it is not empty. Its size should always be equal to
     * children.size(). If viewOrderChildren is empty it implies that the
     * rendering order of the children is the same as the order in the children
     * list.
     */
    private final List&lt;Node&gt; viewOrderChildren = new ArrayList(1);

    void markViewOrderChildrenDirty() {
        NodeHelper.markDirty(this, DirtyBits.PARENT_CHILDREN_VIEW_ORDER);
    }

    private void computeViewOrderChidrenAndUpdatePeer() {
        boolean viewOrderSet = false;
        for (Node child : children) {
            double vo = child.getViewOrder();

            if (!viewOrderSet &amp;&amp; vo != 0) {
                viewOrderSet = true;
            }
        }

        viewOrderChildren.clear();
        if (viewOrderSet) {
            viewOrderChildren.addAll(children);

            // Sort in descending order (or big-to-small order)
            Collections.sort(viewOrderChildren, (Node a, Node b)
                    -&gt; a.getViewOrder() &lt; b.getViewOrder() ? 1
                            : a.getViewOrder() == b.getViewOrder() ? 0 : -1);
        }

        final NGGroup peer = getPeer();
        peer.setViewOrderChildren(viewOrderChildren);
    }

    // Call this method if children view order is needed for picking.
    // The returned list should be treated as read only.
    private List&lt;Node&gt; getOrderedChildren() {
        if (!viewOrderChildren.isEmpty()) {
            return viewOrderChildren;
        }
        return children;
    }

    // Variable used to indicate that the change to the children ObservableList is
    // a simple permutation as the result of a toFront or toBack operation.
    // We can avoid almost all of the processing of the on replace trigger in
    // this case.
    private boolean childrenTriggerPermutation = false;

    //accumulates all removed nodes between pulses, for dirty area calculation.
    private List&lt;Node&gt; removed;

    // set to true if either childRemoved or childAdded returns
    // true. These functions will indicate whether the geom
    // bounds for the parent have changed
    private boolean geomChanged;
    private boolean childSetModified;
    private final ObservableList&lt;Node&gt; children = new VetoableListDecorator&lt;Node&gt;(new TrackableObservableList&lt;Node&gt;() {


        protected void onChanged(Change&lt;Node&gt; c) {
            // proceed with updating the scene graph
            unmodifiableManagedChildren = null;
            boolean relayout = false;
            boolean viewOrderChildrenDirty = false;

            if (childSetModified) {
                while (c.next()) {
                    int from = c.getFrom();
                    int to = c.getTo();
                    for (int i = from; i &lt; to; ++i) {
                        Node n = children.get(i);
                        if (n.getParent() != null &amp;&amp; n.getParent() != Parent.this) {
                            if (warnOnAutoMove) {
                                java.lang.System.err.println(&quot;WARNING added to a new parent without first removing it from its current&quot;);
                                java.lang.System.err.println(&quot;    parent. It will be automatically removed from its current parent.&quot;);
                                java.lang.System.err.println(&quot;    node=&quot; + n + &quot; oldparent= &quot; + n.getParent() + &quot; newparent=&quot; + this);
                            }
                            n.getParent().children.remove(n);
                            if (warnOnAutoMove) {
                                Thread.dumpStack();
                            }
                        }
                    }

                    List&lt;Node&gt; removed = c.getRemoved();
                    int removedSize = removed.size();
                    for (int i = 0; i &lt; removedSize; ++i) {
                        final Node n = removed.get(i);
                        if (n.isManaged()) {
                            relayout = true;
                        }
                    }

                    // Mark viewOrderChildrenDirty if there is modification to children list
                    // and view order was set on one or more of the children prior to this change
                    if (((removedSize &gt; 0) || (to - from) &gt; 0) &amp;&amp; !viewOrderChildren.isEmpty()) {
                        viewOrderChildrenDirty = true;
                    }
                    // update the parent and scene for each new node
                    for (int i = from; i &lt; to; ++i) {
                        Node node = children.get(i);

                        // Newly added node has view order set.
                        if (node.getViewOrder() != 0) {
                            viewOrderChildrenDirty = true;
                        }
                        if (node.isManaged() || (node instanceof Parent &amp;&amp; ((Parent) node).layoutFlag != LayoutFlags.CLEAN)) {
                            relayout = true;
                        }
                        node.setParent(Parent.this);
                        node.setScenes(getScene(), getSubScene());
                        // assert !node.boundsChanged;
                        if (node.isVisible()) {
                            geomChanged = true;
                            childIncluded(node);
                        }
                    }
                }

                // check to see if the number of children exceeds
                // DIRTY_CHILDREN_THRESHOLD and dirtyChildren is null.
                // If so, then we need to create dirtyChildren and
                // populate it.
                if (dirtyChildren == null &amp;&amp; children.size() &gt; DIRTY_CHILDREN_THRESHOLD) {
                    dirtyChildren
                            = new ArrayList&lt;Node&gt;(2 * DIRTY_CHILDREN_THRESHOLD);
                    // only bother populating children if geom has
                    // changed, otherwise there is no need
                    if (dirtyChildrenCount &gt; 0) {
                        int size = children.size();
                        for (int i = 0; i &lt; size; ++i) {
                            Node ch = children.get(i);
                            if (ch.isVisible() &amp;&amp; ch.boundsChanged) {
                                dirtyChildren.add(ch);
                            }
                        }
                    }
                }
            } else {
                // If childSet was not modified, we still need to check whether the permutation
                // did change the layout
                layout_loop:while (c.next()) {
                    List&lt;Node&gt; removed = c.getRemoved();
                    for (int i = 0, removedSize = removed.size(); i &lt; removedSize; ++i) {
                        if (removed.get(i).isManaged()) {
                            relayout = true;
                            break layout_loop;
                        }
                    }

                    for (int i = c.getFrom(), to = c.getTo(); i &lt; to; ++i) {
                        if (children.get(i).isManaged()) {
                            relayout = true;
                            break layout_loop;
                        }
                    }
                }
            }


            //
            // Note that the styles of a child do not affect the parent or
            // its siblings. Thus, it is only necessary to reapply css to
            // the Node just added and not to this parent and all of its
            // children. So the following call to reapplyCSS was moved
            // to Node.parentProperty. The original comment and code were
            // purposely left here as documentation should there be any
            // question about how the code used to work and why the change
            // was made.
            //
            // if children have changed then I need to reapply
            // CSS from this node on down
//                reapplyCSS();
            //

            // request layout if a Group subclass has overridden doLayout OR
            // if one of the new children needs layout, in which case need to ensure
            // the needsLayout flag is set all the way to the root so the next layout
            // pass will reach the child.
            if (relayout) {
                requestLayout();
            }

            if (geomChanged) {
                NodeHelper.geomChanged(Parent.this);
            }

            // Note the starting index at which we need to update the
            // PGGroup on the next update, and mark the children dirty
            c.reset();
            c.next();
            if (startIdx &gt; c.getFrom()) {
                startIdx = c.getFrom();
            }

            NodeHelper.markDirty(Parent.this, DirtyBits.PARENT_CHILDREN);
            // Force synchronization to include the handling of invisible node
            // so that removed list will get cleanup to prevent memory leak.
            NodeHelper.markDirty(Parent.this, DirtyBits.NODE_FORCE_SYNC);

            if (viewOrderChildrenDirty) {
                NodeHelper.markDirty(Parent.this, DirtyBits.PARENT_CHILDREN_VIEW_ORDER);
            }
        }

    }) {
        @Override
        protected void onProposedChange(final List&lt;Node&gt; newNodes, int[] toBeRemoved) {
            final Scene scene = getScene();
            if (scene != null) {
                Window w = scene.getWindow();
                if (w != null &amp;&amp; WindowHelper.getPeer(w) != null) {
                    Toolkit.getToolkit().checkFxUserThread();
                }
            }
            geomChanged = false;

            long newLength = children.size() + newNodes.size();
            int removedLength = 0;
            for (int i = 0; i &lt; toBeRemoved.length; i += 2) {
                removedLength += toBeRemoved[i + 1] - toBeRemoved[i];
            }
            newLength -= removedLength;

            // If the childrenTriggerPermutation flag is set, then we know it
            // is a simple permutation and no further checking is needed.
            if (childrenTriggerPermutation) {
                childSetModified = false;
                return;
            }

            // If the childrenTriggerPermutation flag is not set, then we will
            // check to see whether any element in the ObservableList has changed,
            // or whether the new ObservableList is a permutation on the existing
            // ObservableList. Note that even if the childrenModified flag is false,
            // we still have to check for duplicates. If it is a simple
            // permutation, we can avoid checking for cycles or other parents.
            childSetModified = true;
            if (newLength == childSet.size()) {
                childSetModified = false;
                for (int i = newNodes.size() - 1; i &gt;= 0; --i ) {
                    Node n = newNodes.get(i);
                    if (!childSet.contains(n)) {
                        childSetModified = true;
                        break;
                    }
                }
            }

            // Enforce scene graph invariants, and check for structural errors.
            //
            // 1. If a child has been added to this parent more than once,
            // then it is an error
            //
            // 2. If a child is a target of a clip, then it is an error.
            //
            // 3. If a node would cause a cycle, then it is an error.
            //
            // 4. If a node is null
            //
            // Note that if a node is the child of another parent, we will
            // implicitly remove the node from its former Parent after first
            // checking for errors.

            // iterate over the nodes that were removed and remove them from
            // the hash set.
            for (int i = 0; i &lt; toBeRemoved.length; i += 2) {
                for (int j = toBeRemoved[i]; j &lt; toBeRemoved[i + 1]; j++) {
                    childSet.remove(children.get(j));
                }
            }

            try {
                if (childSetModified) {
                    // check individual children before duplication test
                    // if done in this order, the exception is more specific
                    for (int i = newNodes.size() - 1; i &gt;= 0; --i ) {
                        Node node = newNodes.get(i);
                        if (node == null) {
                            throw new NullPointerException(
                                    constructExceptionMessage(
                                        &quot;child node is null&quot;, null));
                        }
                        if (node.getClipParent() != null) {
                            throw new IllegalArgumentException(
                                    constructExceptionMessage(
                                        &quot;node already used as a clip&quot;, node));
                        }
                        if (wouldCreateCycle(Parent.this, node)) {
                            throw new IllegalArgumentException(
                                    constructExceptionMessage(
                                        &quot;cycle detected&quot;, node));
                        }
                    }
                }

                childSet.addAll(newNodes);
                if (childSet.size() != newLength) {
                    throw new IllegalArgumentException(
                            constructExceptionMessage(
                                &quot;duplicate children added&quot;, null));
                }
            } catch (RuntimeException e) {
                //Return children to it's original state
                childSet.clear();
                childSet.addAll(children);

                // rethrow
                throw e;
            }

            // Done with error checking

            if (!childSetModified) {
                return;
            }

            // iterate over the nodes that were removed and clear their
            // parent and scene. Add to them also to removed list for further
            // dirty regions calculation.
            if (removed == null) {
                removed = new ArrayList&lt;Node&gt;();
            }
            if (removed.size() + removedLength &gt; REMOVED_CHILDREN_THRESHOLD || !isTreeVisible()) {
                //do not populate too many children in removed list
                removedChildrenOptimizationDisabled = true;
            }
            for (int i = 0; i &lt; toBeRemoved.length; i += 2) {
                for (int j = toBeRemoved[i]; j &lt; toBeRemoved[i + 1]; j++) {
                    Node old = children.get(j);
                    final Scene oldScene = old.getScene();
                    if (oldScene != null) {
                        oldScene.generateMouseExited(old);
                    }
                    if (dirtyChildren != null) {
                        dirtyChildren.remove(old);
                    }
                    if (old.isVisible()) {
                        geomChanged = true;
                        childExcluded(old);
                    }
                    if (old.getParent() == Parent.this) {
                        old.setParent(null);
                        old.setScenes(null, null);
                    }
                    // Do not add node with null scene to the removed list.
                    // It will not be processed in the list and its memory
                    // will not be freed.
                    if (scene != null &amp;&amp; !removedChildrenOptimizationDisabled) {
                        removed.add(old);
                    }
                }
            }
        }

        private String constructExceptionMessage(
                String cause, Node offendingNode) {
            final StringBuilder sb = new StringBuilder(&quot;Children: &quot;);
            sb.append(cause);
            sb.append(&quot;: parent = &quot;).append(Parent.this);
            if (offendingNode != null) {
                sb.append(&quot;, node = &quot;).append(offendingNode);
            }

            return sb.toString();
        }
    };

    /**
     * A constant reference to an unmodifiable view of the children, such that every time
     * we ask for an unmodifiable list of children, we don't actually create a new
     * collection and return it. The memory overhead is pretty lightweight compared
     * to all the garbage we would otherwise generate.
     */
    private final ObservableList&lt;Node&gt; unmodifiableChildren =
            FXCollections.unmodifiableObservableList(children);

    /**
     * A cached reference to the unmodifiable managed children of this Parent. This is
     * created whenever first asked for, and thrown away whenever children are added
     * or removed or when their managed state changes. This could be written
     * differently, such that this list is essentially a filtered copy of the
     * main children, but that additional overhead might not be worth it.
     */
    private List&lt;Node&gt; unmodifiableManagedChildren = null;

    /**
     * Gets the list of children of this {@code Parent}.
     *
     * &lt;p&gt;
     * See the class documentation for {@link Node} for scene graph structure
     * restrictions on setting a {@link Parent}'s children list.
     * If these restrictions are violated by a change to the list of children,
     * the change is ignored and the previous value of the children list is
     * restored. An {@link IllegalArgumentException} is thrown in this case.
     *
     * &lt;p&gt;
     * If this {@link Parent} node is attached to a {@link Scene} attached to a {@link Window}
     * that is showning ({@link javafx.stage.Window#isShowing()}), then its
     * list of children must only be modified on the JavaFX Application Thread.
     * An {@link IllegalStateException} is thrown if this restriction is
     * violated.
     *
     * &lt;p&gt;
     * Note to subclasses: if you override this method, you must return from
     * your implementation the result of calling this super method. The actual
     * list instance returned from any getChildren() implementation must be
     * the list owned and managed by this Parent. The only typical purpose
     * for overriding this method is to promote the method to be public.
     *
     * @return the list of children of this {@code Parent}.
     */
    protected ObservableList&lt;Node&gt; getChildren() {
        return children;
    }

    /**
     * Gets the list of children of this {@code Parent} as a read-only
     * list.
     *
     * @return read-only access to this parent's children ObservableList
     */
    public ObservableList&lt;Node&gt; getChildrenUnmodifiable() {
        return unmodifiableChildren;
    }

    /**
     * Gets the list of all managed children of this {@code Parent}.
     *
     * @param &lt;E&gt; the type of the children nodes
     * @return list of all managed children in this parent
     */
    protected &lt;E extends Node&gt; List&lt;E&gt; getManagedChildren() {
        if (unmodifiableManagedChildren == null) {
            unmodifiableManagedChildren = new ArrayList&lt;Node&gt;();
            for (int i=0, max=children.size(); i&lt;max; i++) {
                Node e = children.get(i);
                if (e.isManaged()) {
                    unmodifiableManagedChildren.add(e);
                }
            }
        }
        return (List&lt;E&gt;)unmodifiableManagedChildren;
    }

    /**
     * Called by Node whenever its managed state may have changed, this
     * method will cause the view of managed children to be updated
     * such that it properly includes or excludes this child.
     */
    final void managedChildChanged() {
        requestLayout();
        unmodifiableManagedChildren = null;
    }

    // implementation of Node.toFront function
    final void toFront(Node node) {
        if (Utils.assertionEnabled()) {
            if (!childSet.contains(node)) {
                throw new java.lang.AssertionError(
                        &quot;specified node is not in the list of children&quot;);
            }
        }

        if (children.get(children.size() - 1) != node) {
            childrenTriggerPermutation = true;
            try {
                children.remove(node);
                children.add(node);
            } finally {
                childrenTriggerPermutation = false;
            }
        }
    }

    // implementation of Node.toBack function
    final void toBack(Node node) {
        if (Utils.assertionEnabled()) {
            if (!childSet.contains(node)) {
                throw new java.lang.AssertionError(
                        &quot;specified node is not in the list of children&quot;);
            }
        }

        if (children.get(0) != node) {
            childrenTriggerPermutation = true;
            try {
                children.remove(node);
                children.add(0, node);
            } finally {
                childrenTriggerPermutation = false;
            }
        }
    }

    @Override
    void scenesChanged(final Scene newScene, final SubScene newSubScene,
                       final Scene oldScene, final SubScene oldSubScene) {

        if (oldScene != null &amp;&amp; newScene == null) {
            // RT-34863 - clean up CSS cache when Parent is removed from scene-graph
            StyleManager.getInstance().forget(this);

            // Clear removed list on parent who is no longer in a scene
            if (removed != null) {
                removed.clear();
            }
        }

        for (int i=0; i&lt;children.size(); i++) {
            children.get(i).setScenes(newScene, newSubScene);
        }

        final boolean awaitingLayout = layoutFlag != LayoutFlags.CLEAN;

        sceneRoot = (newSubScene != null &amp;&amp; newSubScene.getRoot() == this) ||
                    (newScene != null &amp;&amp; newScene.getRoot() == this);
        layoutRoot = !isManaged() || sceneRoot;


        if (awaitingLayout) {
            // If this node is dirty and the new scene or subScene is not null
            // then add this node to the new scene's dirty list
            if (newScene != null &amp;&amp; layoutRoot) {
                if (newSubScene != null) {
                    newSubScene.setDirtyLayout(this);
                }
            }
        }
    }

    @Override
    void setDerivedDepthTest(boolean value) {
        super.setDerivedDepthTest(value);

        for (int i=0, max=children.size(); i&lt;max; i++) {
            final Node node = children.get(i);
            node.computeDerivedDepthTest();
        }
    }

    boolean pickChildrenNode(PickRay pickRay, PickResultChooser result) {
        List&lt;Node&gt; orderedChildren = getOrderedChildren();
        for (int i = orderedChildren.size() - 1; i &gt;= 0; i--) {
            orderedChildren.get(i).pickNode(pickRay, result);
            if (result.isClosed()) {
                return false;
            }
        }
        return true;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doPickNodeLocal(PickRay pickRay, PickResultChooser result) {
         double boundsDistance = intersectsBounds(pickRay);

        if (!Double.isNaN(boundsDistance) &amp;&amp; pickChildrenNode(pickRay, result)) {
            if (isPickOnBounds()) {
                result.offer(this, boundsDistance, PickResultChooser.computePoint(pickRay, boundsDistance));
            }
        }
    }

    @Override boolean isConnected() {
        return super.isConnected() || sceneRoot;
    }

    @Override public Node lookup(String selector) {
        Node n = super.lookup(selector);
        if (n == null) {
            for (int i=0, max=children.size(); i&lt;max; i++) {
                final Node node = children.get(i);
                n = node.lookup(selector);
                if (n != null) return n;
            }
        }
        return n;
    }

    /**
     * Please Note: This method should never create the results set,
     * let the Node class implementation do this!
     */
    @Override List&lt;Node&gt; lookupAll(Selector selector, List&lt;Node&gt; results) {
        results = super.lookupAll(selector, results);
        for (int i=0, max=children.size(); i&lt;max; i++) {
            final Node node = children.get(i);
            results = node.lookupAll(selector, results);
        }
        return results;
    }

    private ParentTraversalEngine traversalEngine;

    private final void setTraversalEngine(ParentTraversalEngine value) {
        this.traversalEngine = value;
    }

    private final ParentTraversalEngine getTraversalEngine() {
        return traversalEngine;
    }

    /***********************************************************************
     *                               Layout                                *
     *                                                                     *
     *  Functions and variables related to the layout scheme used by       *
     *  JavaFX. Includes both public and private API.                      *
     *                                                                     *
     **********************************************************************/
    /**
     * Indicates that this Node and its subnodes requires a layout pass on
     * the next pulse.
     */
    private ReadOnlyBooleanWrapper needsLayout;
    LayoutFlags layoutFlag = LayoutFlags.CLEAN;

    protected final void setNeedsLayout(boolean value) {
        if (value) {
            markDirtyLayout(true, false);
        } else if (layoutFlag == LayoutFlags.NEEDS_LAYOUT) {
            boolean hasBranch = false;
            for (int i = 0, max = children.size(); i &lt; max; i++) {
                final Node child = children.get(i);
                if (child instanceof Parent) {
                    if (((Parent)child).layoutFlag != LayoutFlags.CLEAN) {
                        hasBranch = true;
                        break;
                    }

                }
            }
            setLayoutFlag(hasBranch ? LayoutFlags.DIRTY_BRANCH : LayoutFlags.CLEAN);
        }
    }

    public final boolean isNeedsLayout() {
        return layoutFlag == LayoutFlags.NEEDS_LAYOUT;
    }

    public final ReadOnlyBooleanProperty needsLayoutProperty() {
        if (needsLayout == null) {
            needsLayout = new ReadOnlyBooleanWrapper(this, &quot;needsLayout&quot;, layoutFlag == LayoutFlags.NEEDS_LAYOUT);
        }
        return needsLayout;
    }

    /**
     * This is used only by CCS in Node. It is set to true while
     * the layout() function is processing and set to false on the conclusion.
     * It is used by the Node to decide whether to perform CSS updates
     * synchronously or asynchronously.
     */
    private boolean performingLayout = false;

    boolean isPerformingLayout() {
        return performingLayout;
    }

    private boolean sizeCacheClear = true;
    private double prefWidthCache = -1;
    private double prefHeightCache = -1;
    private double minWidthCache = -1;
    private double minHeightCache = -1;

    void setLayoutFlag(LayoutFlags flag) {
        if (needsLayout != null) {
            needsLayout.set(flag == LayoutFlags.NEEDS_LAYOUT);
        }
        layoutFlag = flag;
    }

    private void markDirtyLayout(boolean local, boolean forceParentLayout) {
        setLayoutFlag(LayoutFlags.NEEDS_LAYOUT);
        if (local || layoutRoot) {
            if (sceneRoot) {
                Toolkit.getToolkit().requestNextPulse();
                if (getSubScene() != null) {
                    getSubScene().setDirtyLayout(this);
                }
            } else {
                markDirtyLayoutBranch();
            }
        } else {
            requestParentLayout(forceParentLayout);
        }
    }

    /**
     * Requests a layout pass to be performed before the next scene is
     * rendered. This is batched up asynchronously to happen once per
     * &quot;pulse&quot;, or frame of animation.
     * &lt;p&gt;
     * If this parent is either a layout root or unmanaged, then it will be
     * added directly to the scene's dirty layout list, otherwise requestParentLayout
     * will be invoked.
     * @since JavaFX 8.0
     */
    public void requestLayout() {
        clearSizeCache();
        markDirtyLayout(false, forceParentLayout);
    }

    private boolean forceParentLayout = false;
    /**
     * A package scope method used by Node and serves as a helper method for
     * requestLayout() (see above). If forceParentLayout is true it will
     * propagate this force layout flag to its parent.
     */
    void requestLayout(boolean forceParentLayout) {
        boolean savedForceParentLayout = this.forceParentLayout;
        this.forceParentLayout = forceParentLayout;
        requestLayout();
        this.forceParentLayout = savedForceParentLayout;
    }

    /**
     * Requests a layout pass of the parent to be performed before the next scene is
     * rendered. This is batched up asynchronously to happen once per
     * &quot;pulse&quot;, or frame of animation.
     * &lt;p&gt;
     * This may be used when the current parent have changed it's min/max/preferred width/height,
     * but doesn't know yet if the change will lead to it's actual size change. This will be determined
     * when it's parent recomputes the layout with the new hints.
     */
    protected final void requestParentLayout() {
       requestParentLayout(false);
    }

    /**
     * A package scope method used by Node and serves as a helper method for
     * requestParentLayout() (see above). If forceParentLayout is true it will
     * force a request layout call on its parent if its parent is not null.
     */
    void requestParentLayout(boolean forceParentLayout) {
        if (!layoutRoot) {
            final Parent p = getParent();
            if (p != null &amp;&amp; (!p.performingLayout || forceParentLayout)) {
                p.requestLayout();
            }
        }
    }

    void clearSizeCache() {
        if (sizeCacheClear) {
            return;
        }
        sizeCacheClear = true;
        prefWidthCache = -1;
        prefHeightCache = -1;
        minWidthCache = -1;
        minHeightCache = -1;
    }

    @Override public double prefWidth(double height) {
        if (height == -1) {
            if (prefWidthCache == -1) {
                prefWidthCache = computePrefWidth(-1);
                if (Double.isNaN(prefWidthCache) || prefWidthCache &lt; 0) prefWidthCache = 0;
                sizeCacheClear = false;
            }
            return prefWidthCache;
        } else {
            double result = computePrefWidth(height);
            return Double.isNaN(result) || result &lt; 0 ? 0 : result;
        }
    }

    @Override public double prefHeight(double width) {
        if (width == -1) {
            if (prefHeightCache == -1) {
                prefHeightCache = computePrefHeight(-1);
                if (Double.isNaN(prefHeightCache) || prefHeightCache &lt; 0) prefHeightCache = 0;
                sizeCacheClear = false;
            }
            return prefHeightCache;
        } else {
            double result = computePrefHeight(width);
            return Double.isNaN(result) || result &lt; 0 ? 0 : result;
        }
    }

    @Override public double minWidth(double height) {
        if (height == -1) {
            if (minWidthCache == -1) {
                minWidthCache = computeMinWidth(-1);
                if (Double.isNaN(minWidthCache) || minWidthCache &lt; 0) minWidthCache = 0;
                sizeCacheClear = false;
            }
            return minWidthCache;
        } else {
            double result = computeMinWidth(height);
            return Double.isNaN(result) || result &lt; 0 ? 0 : result;
        }
    }

    @Override public double minHeight(double width) {
        if (width == -1) {
            if (minHeightCache == -1) {
                minHeightCache = computeMinHeight(-1);
                if (Double.isNaN(minHeightCache) || minHeightCache &lt; 0) minHeightCache = 0;
                sizeCacheClear = false;
            }
            return minHeightCache;
        } else {
            double result = computeMinHeight(width);
            return Double.isNaN(result) || result &lt; 0 ? 0 : result;
        }
    }

    // PENDING_DOC_REVIEW
    /**
     * Calculates the preferred width of this {@code Parent}. The default
     * implementation calculates this width as the width of the area occupied
     * by its managed children when they are positioned at their
     * current positions at their preferred widths.
     *
     * @param height the height that should be used if preferred width depends
     *      on it
     * @return the calculated preferred width
     */
    protected double computePrefWidth(double height) {
        double minX = 0;
        double maxX = 0;
        for (int i=0, max=children.size(); i&lt;max; i++) {
            Node node = children.get(i);
            if (node.isManaged()) {
                final double x = node.getLayoutBounds().getMinX() + node.getLayoutX();
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x + boundedSize(node.prefWidth(-1), node.minWidth(-1), node.maxWidth(-1)));
            }
        }
        return maxX - minX;
    }

    // PENDING_DOC_REVIEW
    /**
     * Calculates the preferred height of this {@code Parent}. The default
     * implementation calculates this height as the height of the area occupied
     * by its managed children when they are positioned at their current
     * positions at their preferred heights.
     *
     * @param width the width that should be used if preferred height depends
     *      on it
     * @return the calculated preferred height
     */
    protected double computePrefHeight(double width) {
        double minY = 0;
        double maxY = 0;
        for (int i=0, max=children.size(); i&lt;max; i++) {
            Node node = children.get(i);
            if (node.isManaged()) {
                final double y = node.getLayoutBounds().getMinY() + node.getLayoutY();
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y + boundedSize(node.prefHeight(-1), node.minHeight(-1), node.maxHeight(-1)));
            }
        }
        return maxY - minY;
    }

    /**
     * Calculates the minimum width of this {@code Parent}. The default
     * implementation simply returns the pref width.
     *
     * @param height the height that should be used if min width depends
     *      on it
     * @return the calculated min width
     * @since JavaFX 2.1
     */
    protected double computeMinWidth(double height) {
        return prefWidth(height);
    }

    // PENDING_DOC_REVIEW
    /**
     * Calculates the min height of this {@code Parent}. The default
     * implementation simply returns the pref height;
     *
     * @param width the width that should be used if min height depends
     *      on it
     * @return the calculated min height
     * @since JavaFX 2.1
     */
    protected double computeMinHeight(double width) {
        return prefHeight(width);
    }

    /**
     * Calculates the baseline offset based on the first managed child. If there
     * is no such child, returns {@link Node#getBaselineOffset()}.
     *
     * @return baseline offset
     */
    @Override public double getBaselineOffset() {
        for (int i=0, max=children.size(); i&lt;max; i++) {
            final Node child = children.get(i);
            if (child.isManaged()) {
                double offset = child.getBaselineOffset();
                if (offset == BASELINE_OFFSET_SAME_AS_HEIGHT) {
                    continue;
                }
                return child.getLayoutBounds().getMinY() + child.getLayoutY() + offset;
            }
        }
        return super.getBaselineOffset();
    }

    /***
     * It stores the reference to the current child being laid out by its parent.
     * This reference is important to differentiate whether a layout is triggered
     * by its parent or other events.
     */
    private Node currentLayoutChild = null;

    boolean isCurrentLayoutChild(Node node) {
        return node == currentLayoutChild;
    }

    /**
     * Executes a top-down layout pass on the scene graph under this parent.
     *
     * Calling this method while the Parent is doing layout is a no-op.
     */
    public final void layout() {
        // layoutFlag can be accessed or changed during layout processing.
        // Hence we need to cache and reset it before performing layout.
        LayoutFlags flag = layoutFlag;
        setLayoutFlag(LayoutFlags.CLEAN);
        switch(flag) {
            case CLEAN:
                break;
            case NEEDS_LAYOUT:
                if (performingLayout) {
                    /* This code is here mainly to avoid infinite loops as layout() is public and the call might be (indirectly) invoked accidentally
                     * while doing the layout.
                     * One example might be an invocation from Group layout bounds recalculation
                     *  (e.g. during the localToScene/localToParent calculation).
                     * The layout bounds will thus return layout bounds that are &quot;old&quot; (i.e. before the layout changes, that are just being done),
                     * which is likely what the code would expect.
                     * The changes will invalidate the layout bounds again however, so the layout bounds query after layout pass will return correct answer.
                     */
                    break;
                }
                performingLayout = true;
                layoutChildren();
                // Intended fall-through
            case DIRTY_BRANCH:
                for (int i = 0, max = children.size(); i &lt; max; i++) {
                    final Node child = children.get(i);
                    currentLayoutChild = child;
                    if (child instanceof Parent) {
                        ((Parent)child).layout();
                    } else if (child instanceof SubScene) {
                        ((SubScene)child).layoutPass();
                    }
                }
                currentLayoutChild = null;
                performingLayout = false;
                break;
        }
    }

    /**
     * Invoked during the layout pass to layout the children in this
     * {@code Parent}. By default it will only set the size of managed,
     * resizable content to their preferred sizes and does not do any node
     * positioning.
     * &lt;p&gt;
     * Subclasses should override this function to layout content as needed.
     */
    protected void layoutChildren() {
        for (int i=0, max=children.size(); i&lt;max; i++) {
            final Node node = children.get(i);
            currentLayoutChild = node;
            if (node.isResizable() &amp;&amp; node.isManaged()) {
                node.autosize();
            }
        }
        currentLayoutChild = null;
    }

    /**
     * This field is managed by the Scene, and set on any node which is the
     * root of a Scene.
     */
    private boolean sceneRoot = false;

    /**
     * Keeps track of whether this node is a layout root. This is updated
     * whenever the sceneRoot field changes, or whenever the managed
     * property changes.
     */
    boolean layoutRoot = false;
    @Override final void notifyManagedChanged() {
        layoutRoot = !isManaged() || sceneRoot;
    }

    final boolean isSceneRoot() {
        return sceneRoot;
    }

    /***********************************************************************
     *                                                                     *
     *                         Stylesheet Handling                         *
     *                                                                     *
     **********************************************************************/


    /**
     * A ObservableList of string URLs linking to the stylesheets to use with this scene's
     * contents. For additional information about using CSS with the
     * scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
     * Guide&lt;/a&gt;.
     */
    private final ObservableList&lt;String&gt; stylesheets = new TrackableObservableList&lt;String&gt;() {
        @Override
        protected void onChanged(Change&lt;String&gt; c) {
            final Scene scene = getScene();
            if (scene != null) {

                // Notify the StyleManager if stylesheets change. This Parent's
                // styleManager will get recreated in NodeHelper.processCSS.
                StyleManager.getInstance().stylesheetsChanged(Parent.this, c);

                // RT-9784 - if stylesheet is removed, reset styled properties to
                // their initial value.
                c.reset();
                while(c.next()) {
                    if (c.wasRemoved() == false) {
                        continue;
                    }
                    break; // no point in resetting more than once...
                }

                reapplyCSS();
            }
        }
    };

    /**
     * Gets an observable list of string URLs linking to the stylesheets to use
     * with this Parent's contents. See {@link Scene#getStylesheets()} for details.
     * &lt;p&gt;For additional information about using CSS
     * with the scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
     * Guide&lt;/a&gt;.&lt;/p&gt;
     *
     * @return the list of stylesheets to use with this Parent
     * @since JavaFX 2.1
     */
    public final ObservableList&lt;String&gt; getStylesheets() { return stylesheets; }

    /*
     * This method recurses up the parent chain until parent is null. As the
     * stack unwinds, if the Parent has stylesheets, they are added to the
     * list.
     *
     * It is possible to override this method to stop the recursion. This allows
     * a Parent to have a set of stylesheets distinct from its Parent.
     *
     * Note: This method MUST only be called via its accessor method.
     */
     // SB-dependency: RT-21247 has been filed to track this
    private List&lt;String&gt; doGetAllParentStylesheets() {

        List&lt;String&gt; list = null;
        final Parent myParent = getParent();
        if (myParent != null) {

            //
            // recurse so that stylesheets of Parents closest to the root are
            // added to the list first. The ensures that declarations for
            // stylesheets further down the tree (closer to the leaf) have
            // a higer ordinal in the cascade.
            //
            list = ParentHelper.getAllParentStylesheets(myParent);
        }

        if (stylesheets != null &amp;&amp; stylesheets.isEmpty() == false) {
            if (list == null) {
                list = new ArrayList&lt;String&gt;(stylesheets.size());
            }
            for (int n=0,nMax=stylesheets.size(); n&lt;nMax; n++) {
                list.add(stylesheets.get(n));
            }
        }

        return list;

    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doProcessCSS() {

        // Nothing to do...
        if (cssFlag == CssFlags.CLEAN) return;

        // RT-29254 - If DIRTY_BRANCH, pass control to Node#processCSS. This avoids calling NodeHelper.processCSS on
        // this node and all of its children when css doesn't need updated, recalculated, or reapplied.
        if (cssFlag == CssFlags.DIRTY_BRANCH) {
            super.processCSS();
            return;
        }

        // Let the super implementation handle CSS for this node
        ParentHelper.superProcessCSS(this);

        // avoid the following call to children.toArray if there are no children
        if (children.isEmpty()) return;

        //
        // RT-33103
        //
        // It is possible for a child to be removed from children in the middle of
        // the following loop. Iterating over the children may result in an IndexOutOfBoundsException.
        // So a copy is made and the copy is iterated over.
        //
        // Note that we don't want the fail-fast feature of an iterator, not to mention the general iterator overhead.
        //
        final Node[] childArray = children.toArray(new Node[children.size()]);

        // For each child, process CSS
        for (int i=0; i&lt;childArray.length; i++) {

            final Node child = childArray[i];

            //  If a child no longer has this as its parent, then it is skipped.
            final Parent childParent = child.getParent();
            if (childParent == null || childParent != this) continue;

            // If the parent styles are being updated, recalculated or
            // reapplied, then make sure the children get the same treatment.
            // Unless the child is already more dirty than this parent (RT-29074).
            if(CssFlags.UPDATE.compareTo(child.cssFlag) &gt; 0) {
                child.cssFlag = CssFlags.UPDATE;
            }
            NodeHelper.processCSS(child);
        }
    }

    /***********************************************************************
     *                               Misc                                  *
     *                                                                     *
     *  Initialization and other functions                                 *
     *                                                                     *
     **********************************************************************/
    {
        // To initialize the class helper at the begining each constructor of this class
        ParentHelper.initHelper(this);
    }

    /**
     * Constructs a new {@code Parent}.
     */
    protected Parent() {
        layoutFlag = LayoutFlags.NEEDS_LAYOUT;
        setAccessibleRole(AccessibleRole.PARENT);
    }

    private NGNode doCreatePeer() {
        return new NGGroup();
    }

    @Override
    void nodeResolvedOrientationChanged() {
        for (int i = 0, max = children.size(); i &lt; max; ++i) {
            children.get(i).parentResolvedOrientationInvalidated();
        }
    }

    /***************************************************************************
     *                                                                         *
     *                         Bounds Computations                             *
     *                                                                         *
     *  This code originated in GroupBoundsHelper (part of javafx-sg-common)   *
     *  but has been ported here to the FX side since we cannot rely on the PG *
     *  side for computing the bounds (due to the decoupling of the two        *
     *  scenegraphs for threading and other purposes).                         *
     *                                                                         *
     *  Unfortunately, we cannot simply reuse GroupBoundsHelper without some  *
     *  major (and hacky) modification due to the fact that GroupBoundsHelper  *
     *  relies on PG state and we need to do similar things here that rely on  *
     *  core scenegraph state. Unfortunately, that means we made a port.       *
     *                                                                         *
     **************************************************************************/

    private BaseBounds tmp = new RectBounds();

    /**
     * The cached bounds for the Group. If the cachedBounds are invalid
     * then we have no history of what the bounds are, or were.
     */
    private BaseBounds cachedBounds = new RectBounds();

    /**
     * Indicates that the cachedBounds is invalid (or old) and need to be recomputed.
     * If cachedBoundsInvalid is true and dirtyChildrenCount is non-zero,
     * then when we recompute the cachedBounds we can consider the
     * values in cachedBounds to represent the last valid bounds for the group.
     * This is useful for several fast paths.
     */
    private boolean cachedBoundsInvalid;

    /**
     * The number of dirty children which bounds haven't been incorporated
     * into the cached bounds yet. Can be used even when dirtyChildren is null.
     */
    private int dirtyChildrenCount;

    /**
     * This set is used to track all of the children of this group which are
     * dirty. It is only used in cases where the number of children is &gt; some
     * value (currently 10). For very wide trees, this can provide a very
     * important speed boost. For the sake of memory consumption, this is
     * null unless the number of children ever crosses the threshold where
     * it will be activated.
     */
    private ArrayList&lt;Node&gt; dirtyChildren;

    private Node top;
    private Node left;
    private Node bottom;
    private Node right;
    private Node near;
    private Node far;

    private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {
        // If we have no children, our bounds are invalid
        if (children.isEmpty()) {
            return bounds.makeEmpty();
        }

        if (tx.isTranslateOrIdentity()) {
            // this is a transform which is only doing translations, or nothing
            // at all (no scales, rotates, or shears)
            // so in this case we can easily use the cached bounds
            if (cachedBoundsInvalid) {
                recomputeBounds();

                if (dirtyChildren != null) {
                    dirtyChildren.clear();
                }
                cachedBoundsInvalid = false;
                dirtyChildrenCount = 0;
            }
            if (!tx.isIdentity()) {
                bounds = bounds.deriveWithNewBounds((float)(cachedBounds.getMinX() + tx.getMxt()),
                                 (float)(cachedBounds.getMinY() + tx.getMyt()),
                                 (float)(cachedBounds.getMinZ() + tx.getMzt()),
                                 (float)(cachedBounds.getMaxX() + tx.getMxt()),
                                 (float)(cachedBounds.getMaxY() + tx.getMyt()),
                                 (float)(cachedBounds.getMaxZ() + tx.getMzt()));
            } else {
                bounds = bounds.deriveWithNewBounds(cachedBounds);
            }

            return bounds;
        } else {
            // there is a scale, shear, or rotation happening, so need to
            // do the full transform!
            double minX = Double.MAX_VALUE, minY = Double.MAX_VALUE, minZ = Double.MAX_VALUE;
            double maxX = Double.MIN_VALUE, maxY = Double.MIN_VALUE, maxZ = Double.MIN_VALUE;
            boolean first = true;
            for (int i=0, max=children.size(); i&lt;max; i++) {
                final Node node = children.get(i);
                if (node.isVisible()) {
                    bounds = getChildTransformedBounds(node, tx, bounds);
                    // if the bounds of the child are invalid, we don't want
                    // to use those in the remaining computations.
                    if (bounds.isEmpty()) continue;
                    if (first) {
                        minX = bounds.getMinX();
                        minY = bounds.getMinY();
                        minZ = bounds.getMinZ();
                        maxX = bounds.getMaxX();
                        maxY = bounds.getMaxY();
                        maxZ = bounds.getMaxZ();
                        first = false;
                    } else {
                        minX = Math.min(bounds.getMinX(), minX);
                        minY = Math.min(bounds.getMinY(), minY);
                        minZ = Math.min(bounds.getMinZ(), minZ);
                        maxX = Math.max(bounds.getMaxX(), maxX);
                        maxY = Math.max(bounds.getMaxY(), maxY);
                        maxZ = Math.max(bounds.getMaxZ(), maxZ);
                    }
                }
            }
            // if &quot;first&quot; is still true, then we didn't have any children with
            // non-empty bounds and thus we must return an empty bounds,
            // otherwise we have non-empty bounds so go for it.
            if (first)
                bounds.makeEmpty();
            else
                bounds = bounds.deriveWithNewBounds((float)minX, (float)minY, (float)minZ,
                        (float)maxX, (float)maxY, (float)maxZ);

            return bounds;
        }
    }

    private void setChildDirty(final Node node, final boolean dirty) {
        if (node.boundsChanged == dirty) {
            return;
        }

        node.boundsChanged = dirty;
        if (dirty) {
            if (dirtyChildren != null) {
                dirtyChildren.add(node);
            }
            ++dirtyChildrenCount;
        } else {
            if (dirtyChildren != null) {
                dirtyChildren.remove(node);
            }
            --dirtyChildrenCount;
        }
    }

    private void childIncluded(final Node node) {
        // assert node.isVisible();
        cachedBoundsInvalid = true;
        setChildDirty(node, true);
    }

    // This is called when either the child is actually removed, OR IF IT IS
    // TOGGLED TO BE INVISIBLE. This is because in both cases it needs to be
    // cleared from the state which manages bounds.
    private void childExcluded(final Node node) {
        if (node == left) {
            left = null;
            cachedBoundsInvalid = true;
        }
        if (node == top) {
            top = null;
            cachedBoundsInvalid = true;
        }
        if (node == near) {
            near = null;
            cachedBoundsInvalid = true;
        }
        if (node == right) {
            right = null;
            cachedBoundsInvalid = true;
        }
        if (node == bottom) {
            bottom = null;
            cachedBoundsInvalid = true;
        }
        if (node == far) {
            far = null;
            cachedBoundsInvalid = true;
        }

        setChildDirty(node, false);
    }

    /**
     * Recomputes the bounds from scratch and saves the cached bounds.
     */
    private void recomputeBounds() {
        // fast path for case of no children
        if (children.isEmpty()) {
            cachedBounds.makeEmpty();
            return;
        }

        // fast path for case of 1 child
        if (children.size() == 1) {
            Node node = children.get(0);
            node.boundsChanged = false;
            if (node.isVisible()) {
                cachedBounds = getChildTransformedBounds(node, BaseTransform.IDENTITY_TRANSFORM, cachedBounds);
                top = left = bottom = right = near = far = node;
            } else {
                cachedBounds.makeEmpty();
                // no need to null edge nodes here, it was done in childExcluded
                // top = left = bottom = right = near = far = null;
            }
            return;
        }

        if ((dirtyChildrenCount == 0) ||
                !updateCachedBounds(dirtyChildren != null
                                        ? dirtyChildren : children,
                                    dirtyChildrenCount)) {
            // failed to update cached bounds, recreate them
            createCachedBounds(children);
        }
    }

    private final int LEFT_INVALID = 1;
    private final int TOP_INVALID = 1 &lt;&lt; 1;
    private final int NEAR_INVALID = 1 &lt;&lt; 2;
    private final int RIGHT_INVALID = 1 &lt;&lt; 3;
    private final int BOTTOM_INVALID = 1 &lt;&lt; 4;
    private final int FAR_INVALID = 1 &lt;&lt; 5;

    private boolean updateCachedBounds(final List&lt;Node&gt; dirtyNodes,
                                       int remainingDirtyNodes) {
        // fast path for untransformed bounds calculation
        if (cachedBounds.isEmpty()) {
            createCachedBounds(dirtyNodes);
            return true;
        }

        int invalidEdges = 0;

        if ((left == null) || left.boundsChanged) {
            invalidEdges |= LEFT_INVALID;
        }
        if ((top == null) || top.boundsChanged) {
            invalidEdges |= TOP_INVALID;
        }
        if ((near == null) || near.boundsChanged) {
            invalidEdges |= NEAR_INVALID;
        }
        if ((right == null) || right.boundsChanged) {
            invalidEdges |= RIGHT_INVALID;
        }
        if ((bottom == null) || bottom.boundsChanged) {
            invalidEdges |= BOTTOM_INVALID;
        }
        if ((far == null) || far.boundsChanged) {
            invalidEdges |= FAR_INVALID;
        }

        // These indicate the bounds of the Group as computed by this
        // function
        float minX = cachedBounds.getMinX();
        float minY = cachedBounds.getMinY();
        float minZ = cachedBounds.getMinZ();
        float maxX = cachedBounds.getMaxX();
        float maxY = cachedBounds.getMaxY();
        float maxZ = cachedBounds.getMaxZ();

        // this checks the newly added nodes first, so if dirtyNodes is the
        // whole children list, we can end early
        for (int i = dirtyNodes.size() - 1; remainingDirtyNodes &gt; 0; --i) {
            final Node node = dirtyNodes.get(i);
            if (node.boundsChanged) {
                // assert node.isVisible();
                node.boundsChanged = false;
                --remainingDirtyNodes;
                tmp = getChildTransformedBounds(node, BaseTransform.IDENTITY_TRANSFORM, tmp);
                if (!tmp.isEmpty()) {
                    float tmpx = tmp.getMinX();
                    float tmpy = tmp.getMinY();
                    float tmpz = tmp.getMinZ();
                    float tmpx2 = tmp.getMaxX();
                    float tmpy2 = tmp.getMaxY();
                    float tmpz2 = tmp.getMaxZ();

                    // If this node forms an edge, then we will set it to be the
                    // node for this edge and update the min/max values
                    if (tmpx &lt;= minX) {
                        minX = tmpx;
                        left = node;
                        invalidEdges &amp;= ~LEFT_INVALID;
                    }
                    if (tmpy &lt;= minY) {
                        minY = tmpy;
                        top = node;
                        invalidEdges &amp;= ~TOP_INVALID;
                    }
                    if (tmpz &lt;= minZ) {
                        minZ = tmpz;
                        near = node;
                        invalidEdges &amp;= ~NEAR_INVALID;
                    }
                    if (tmpx2 &gt;= maxX) {
                        maxX = tmpx2;
                        right = node;
                        invalidEdges &amp;= ~RIGHT_INVALID;
                    }
                    if (tmpy2 &gt;= maxY) {
                        maxY = tmpy2;
                        bottom = node;
                        invalidEdges &amp;= ~BOTTOM_INVALID;
                    }
                    if (tmpz2 &gt;= maxZ) {
                        maxZ = tmpz2;
                        far = node;
                        invalidEdges &amp;= ~FAR_INVALID;
                    }
                }
            }
        }

        if (invalidEdges != 0) {
            // failed to validate some edges
            return false;
        }

        cachedBounds = cachedBounds.deriveWithNewBounds(minX, minY, minZ,
                                                        maxX, maxY, maxZ);
        return true;
    }

    private void createCachedBounds(final List&lt;Node&gt; fromNodes) {
        // These indicate the bounds of the Group as computed by this function
        float minX, minY, minZ;
        float maxX, maxY, maxZ;

        final int nodeCount = fromNodes.size();
        int i;

        // handle first visible non-empty node
        for (i = 0; i &lt; nodeCount; ++i) {
            final Node node = fromNodes.get(i);
            node.boundsChanged = false;
            if (node.isVisible()) {
                tmp = node.getTransformedBounds(
                               tmp, BaseTransform.IDENTITY_TRANSFORM);
                if (!tmp.isEmpty()) {
                    left = top = near = right = bottom = far = node;
                    break;
                }
            }
        }

        if (i == nodeCount) {
            left = top = near = right = bottom = far = null;
            cachedBounds.makeEmpty();
            return;
        }

        minX = tmp.getMinX();
        minY = tmp.getMinY();
        minZ = tmp.getMinZ();
        maxX = tmp.getMaxX();
        maxY = tmp.getMaxY();
        maxZ = tmp.getMaxZ();

        // handle remaining visible non-empty nodes
        for (++i; i &lt; nodeCount; ++i) {
            final Node node = fromNodes.get(i);
            node.boundsChanged = false;
            if (node.isVisible()) {
                tmp = node.getTransformedBounds(
                               tmp, BaseTransform.IDENTITY_TRANSFORM);
                if (!tmp.isEmpty()) {
                    final float tmpx = tmp.getMinX();
                    final float tmpy = tmp.getMinY();
                    final float tmpz = tmp.getMinZ();
                    final float tmpx2 = tmp.getMaxX();
                    final float tmpy2 = tmp.getMaxY();
                    final float tmpz2 = tmp.getMaxZ();

                    if (tmpx &lt; minX) { minX = tmpx; left = node; }
                    if (tmpy &lt; minY) { minY = tmpy; top = node; }
                    if (tmpz &lt; minZ) { minZ = tmpz; near = node; }
                    if (tmpx2 &gt; maxX) { maxX = tmpx2; right = node; }
                    if (tmpy2 &gt; maxY) { maxY = tmpy2; bottom = node; }
                    if (tmpz2 &gt; maxZ) { maxZ = tmpz2; far = node; }
                }
            }
        }

        cachedBounds = cachedBounds.deriveWithNewBounds(minX, minY, minZ,
                                                        maxX, maxY, maxZ);
    }

    /**
     * Updates the bounds of this {@code Parent} and its children.
     */
    @Override protected void updateBounds() {
        for (int i=0, max=children.size(); i&lt;max; i++) {
            children.get(i).updateBounds();
        }
        super.updateBounds();
    }

    // Note: this marks the currently processed child in terms of transformed bounds. In rare situations like
    // in RT-37879, it might happen that the child bounds will be marked as invalid. Due to optimizations,
    // the invalidation must *always* be propagated to the parent, because the parent with some transformation
    // calls child's getTransformedBounds non-idenitity transform and the child's transformed bounds are thus not validated.
    // This does not apply to the call itself however, because the call will yield the correct result even if something
    // was invalidated during the computation. We can safely ignore such invalidations from that Node in this case
    private Node currentlyProcessedChild;

    private BaseBounds getChildTransformedBounds(Node node, BaseTransform tx, BaseBounds bounds) {
        currentlyProcessedChild = node;
        bounds = node.getTransformedBounds(bounds, tx);
        currentlyProcessedChild = null;
        return bounds;
    }

    /**
     * Called by Node whenever its bounds have changed.
     */
    void childBoundsChanged(Node node) {
        // See comment above at &quot;currentlyProcessedChild&quot; field
        if (node == currentlyProcessedChild) {
            return;
        }

        cachedBoundsInvalid = true;

        // mark the node such that the parent knows that the child's bounds
        // are not in sync with this parent. In this way, when the bounds
        // need to be computed, we'll come back and figure out the new bounds
        // for all the children which have boundsChanged set to true
        setChildDirty(node, true);

        // go ahead and indicate that the geom has changed for this parent,
        // even though once we figure it all out it may be that the bounds
        // have not changed
        NodeHelper.geomChanged(this);
    }

    /**
     * Called by node whenever the visibility of the node changes.
     */
    void childVisibilityChanged(Node node) {
        if (node.isVisible()) {
            childIncluded(node);
        } else {
            childExcluded(node);
        }

        NodeHelper.geomChanged(this);
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeContains(double localX, double localY) {
        final Point2D tempPt = TempState.getInstance().point;
        for (int i=0, max=children.size(); i&lt;max; i++) {
            final Node node = children.get(i);
            tempPt.x = (float)localX;
            tempPt.y = (float)localY;
            try {
                node.parentToLocal(tempPt);
            } catch (NoninvertibleTransformException e) {
                continue;
            }
            if (node.contains(tempPt.x, tempPt.y)) {
                return true;
            }
        }
        return false;
    }

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case CHILDREN: return getChildrenUnmodifiable();
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

<A NAME="3"></A>    void releaseAccessible() {
        for (int i=0, max=children.size(); i&lt;max; i++) {
            final Node node = children.get(i);
            <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#3',2,'match37-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>node.releaseAccessible();
        }
        super.releaseAccessible();
    }

    /**
     * Note: The only user of this method is in unit test: Parent_structure_sync_Test.
     */
    List&lt;Node&gt; test_getRemoved() {
        return removed;
    }

    /**
     * Note: The only user of this method is in unit test:
     * Parent_viewOrderChildren_sync_Test.
     */
    List&lt;Node&gt; test_getViewOrderChildren() {</B></FONT>
        return viewOrderChildren;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/Scene.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene;

import com.sun.glass.ui.Application;
import com.sun.glass.ui.Accessible;
import com.sun.javafx.util.Logging;
import com.sun.javafx.util.Utils;
import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.collections.TrackableObservableList;
import com.sun.javafx.css.StyleManager;
import com.sun.javafx.cursor.CursorFrame;
import com.sun.javafx.event.EventQueue;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.perf.PerformanceTracker;
import com.sun.javafx.scene.CssFlags;
import com.sun.javafx.scene.LayoutFlags;
import com.sun.javafx.scene.SceneEventDispatcher;
import com.sun.javafx.scene.SceneHelper;
import com.sun.javafx.scene.input.DragboardHelper;
import com.sun.javafx.scene.input.ExtendedInputMethodRequests;
import com.sun.javafx.scene.input.InputEventUtils;
import com.sun.javafx.scene.input.PickResultChooser;
import com.sun.javafx.scene.traversal.Direction;
import com.sun.javafx.scene.traversal.SceneTraversalEngine;
import com.sun.javafx.scene.traversal.TopMostTraversalEngine;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGLightBase;
import com.sun.javafx.tk.*;
import com.sun.prism.impl.PrismSettings;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.ConditionalFeature;
import javafx.application.Platform;
import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.NamedArg;
import javafx.beans.property.*;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener.Change;
import javafx.collections.ObservableList;
import javafx.collections.ObservableMap;
import javafx.css.CssMetaData;
import javafx.css.StyleableObjectProperty;
import javafx.event.*;
import javafx.geometry.*;
import javafx.scene.image.WritableImage;
import javafx.scene.input.*;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.stage.PopupWindow;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;
import javafx.util.Callback;
import javafx.util.Duration;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;

import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

import com.sun.javafx.logging.PulseLogger;

import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.stage.WindowHelper;
import com.sun.javafx.scene.input.ClipboardHelper;
import com.sun.javafx.scene.input.TouchPointHelper;
import java.lang.ref.WeakReference;

/**
 * The JavaFX {@code Scene} class is the container for all content in a scene graph.
 * The background of the scene is filled as specified by the {@code fill} property.
 * &lt;p&gt;
 * The application must specify the root {@code Node} for the scene graph by setting
 * the {@code root} property.   If a {@code Group} is used as the root, the
 * contents of the scene graph will be clipped by the scene's width and height and
 * changes to the scene's size (if user resizes the stage) will not alter the
 * layout of the scene graph.    If a resizable node (layout {@code Region} or
 * {@code Control} is set as the root, then the root's size will track the
 * scene's size, causing the contents to be relayed out as necessary.
 * &lt;p&gt;
 * The scene's size may be initialized by the application during construction.
 * If no size is specified, the scene will automatically compute its initial
 * size based on the preferred size of its content. If only one dimension is specified,
 * the other dimension is computed using the specified dimension, respecting content bias
 * of a root.
 * &lt;p&gt;
 * An application may request depth buffer support or scene anti-aliasing
 * support at the creation of a {@code Scene}. A scene with only 2D shapes and
 * without any 3D transforms does not need a depth buffer nor scene
 * anti-aliasing support. A scene containing 3D shapes or 2D shapes with 3D
 * transforms may use depth buffer support for proper depth sorted rendering; to
 * avoid depth fighting (also known as Z fighting), disable depth testing on 2D
 * shapes that have no 3D transforms. See
 * {@link Node#depthTestProperty() depthTest} for more information. A scene with
 * 3D shapes may enable scene anti-aliasing to improve its rendering quality.
 * &lt;p&gt;
 * The depthBuffer and antiAliasing flags are conditional features. With the
 * respective default values of: false and {@code SceneAntialiasing.DISABLED}.
 * See {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 * for more information.
 * &lt;p&gt;
 * A default headlight will be added to a scene that contains one or more
 * {@code Shape3D} nodes, but no light nodes. This light source is a
 * {@code Color.WHITE} {@code PointLight} placed at the camera position.
 *
 * &lt;p&gt;
 * A {@code Scene} may be created and modified on any thread until it is attached
 * to a {@link Window} that is {@link Window#isShowing() showing}.
 * After that, it must be modified only on the JavaFX Application Thread.
 * Note that {@code Scene} is not thread-safe; modifying a {@code Scene} on
 * multiple threads at the same time will lead to unpredictable results and
 * must be avoided.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The JavaFX Application Thread is created as part of the startup process for
 * the JavaFX runtime. See the {@link javafx.application.Application} class and
 * the {@link Platform#startup(Runnable)} method for more information.
 * &lt;/p&gt;
 *
 * &lt;p&gt;Example:&lt;/p&gt;
 *
 * &lt;pre&gt;
import javafx.scene.*;
import javafx.scene.paint.*;
import javafx.scene.shape.*;

Group root = new Group();
Scene s = new Scene(root, 300, 300, Color.BLACK);

Rectangle r = new Rectangle(25,25,250,250);
r.setFill(Color.BLUE);

root.getChildren().add(r);
 * &lt;/pre&gt;
 *
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;root&quot;)
public class Scene implements EventTarget {

    private double widthSetByUser = -1.0;
    private double heightSetByUser = -1.0;
    private boolean sizeInitialized = false;
    private final boolean depthBuffer;
    private final SceneAntialiasing antiAliasing;

    private int dirtyBits;

    final AccessControlContext acc = AccessController.getContext();

    private Camera defaultCamera;

    /**
     * A node that is temporarily responsible for the FOCUS_NODE
     * accessibility attribute. E.g. a currently active MenuBar.
     */
    private Node transientFocusContainer;

    //Neither width nor height are initialized and will be calculated according to content when this Scene
    //is shown for the first time.
//    public Scene() {
//        //this(-1, -1, (Parent) new Group());
//        this(-1, -1, (Parent)null);
//    }

    /**
     * Creates a Scene for a specific root Node.
     *
     * @param root The root node of the scene graph
     *
     * @throws NullPointerException if root is null
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root) {
        this(root, -1, -1, Color.WHITE, false, SceneAntialiasing.DISABLED);
    }

//Public constructor initializing public-init properties
//When width &lt; 0, and or height &lt; 0 is passed, then width and/or height are understood as unitialized
//Unitialized dimension is calculated when Scene is shown for the first time.
//    public Scene(
//            @Default(&quot;-1&quot;) double width,
//            @Default(&quot;-1&quot;) double height) {
//        //this(width, height, (Parent)new Group());
//        this(width, height, (Parent)null);
//    }
//
//    public Scene(double width, double height, Paint fill) {
//        //this(width, height, (Parent) new Group());
//        this(width, height, (Parent)null);
//        setFill(fill);
//    }

    /**
     * Creates a Scene for a specific root Node with a specific size.
     *
     * @param root The root node of the scene graph
     * @param width The width of the scene
     * @param height The height of the scene
     *
     * @throws NullPointerException if root is null
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height) {
        this(root, width, height, Color.WHITE, false, SceneAntialiasing.DISABLED);
    }

    /**
     * Creates a Scene for a specific root Node with a fill.
     *
     * @param root The parent
     * @param fill The fill
     *
     * @throws NullPointerException if root is null
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
        this(root, -1, -1, fill, false, SceneAntialiasing.DISABLED);
    }

    /**
     * Creates a Scene for a specific root Node with a specific size and fill.
     *
     * @param root The root node of the scene graph
     * @param width The width of the scene
     * @param height The height of the scene
     * @param fill The fill
     *
     * @throws NullPointerException if root is null
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height,
            @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
        this(root, width, height, fill, false, SceneAntialiasing.DISABLED);
    }

    /**
     * Constructs a scene consisting of a root, with a dimension of width and
     * height, and specifies whether a depth buffer is created for this scene.
     * &lt;p&gt;
     * A scene with only 2D shapes and without any 3D transforms does not need a
     * depth buffer. A scene containing 3D shapes or 2D shapes with 3D
     * transforms may use depth buffer support for proper depth sorted
     * rendering; to avoid depth fighting (also known as Z fighting), disable
     * depth testing on 2D shapes that have no 3D transforms. See
     * {@link Node#depthTestProperty() depthTest} for more information.
     *
     * @param root The root node of the scene graph
     * @param width The width of the scene
     * @param height The height of the scene
     * @param depthBuffer The depth buffer flag
     * &lt;p&gt;
     * The depthBuffer flag is a conditional feature and its default value is
     * false. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @throws NullPointerException if root is null
     *
     * @see javafx.scene.Node#setDepthTest(DepthTest)
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height, @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer) {
        this(root, width, height, Color.WHITE, depthBuffer, SceneAntialiasing.DISABLED);
    }

    /**
     * Constructs a scene consisting of a root, with a dimension of width and
     * height, specifies whether a depth buffer is created for this scene and
     * specifies whether scene anti-aliasing is requested.
     * &lt;p&gt;
     * A scene with only 2D shapes and without any 3D transforms does not need a
     * depth buffer nor scene anti-aliasing support. A scene containing 3D
     * shapes or 2D shapes with 3D transforms may use depth buffer support for
     * proper depth sorted rendering; to avoid depth fighting (also known as Z
     * fighting), disable depth testing on 2D shapes that have no 3D transforms.
     * See {@link Node#depthTestProperty() depthTest} for more information. A
     * scene with 3D shapes may enable scene anti-aliasing to improve its
     * rendering quality.
     *
     * @param root The root node of the scene graph
     * @param width The width of the scene
     * @param height The height of the scene
     * @param depthBuffer The depth buffer flag
     * @param antiAliasing The scene anti-aliasing attribute. A value of
     * {@code null} is treated as DISABLED.
     * &lt;p&gt;
     * The depthBuffer and antiAliasing are conditional features. With the
     * respective default values of: false and {@code SceneAntialiasing.DISABLED}. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @throws NullPointerException if root is null
     *
     * @see javafx.scene.Node#setDepthTest(DepthTest)
     * @since JavaFX 8.0
     */
    public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height,
            @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer,
            @NamedArg(value=&quot;antiAliasing&quot;, defaultValue=&quot;DISABLED&quot;) SceneAntialiasing antiAliasing) {
        this(root, width, height, Color.WHITE, depthBuffer, antiAliasing);

        if (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED &amp;&amp;
                !Toolkit.getToolkit().isMSAASupported())
        {
            String logname = Scene.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;System can't support &quot;
                + &quot;antiAliasing&quot;);
        }
    }

    private Scene(Parent root, double width, double height, Paint fill,
            boolean depthBuffer, SceneAntialiasing antiAliasing) {
        this.depthBuffer = depthBuffer;
        this.antiAliasing = antiAliasing;
        if (root == null) {
            throw new NullPointerException(&quot;Root cannot be null&quot;);
        }

        if ((depthBuffer || (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED))
                &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
            String logname = Scene.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;System can't support &quot;
                    + &quot;ConditionalFeature.SCENE3D&quot;);
        }

        init();
        setRoot(root);
        init(width, height);
        setFill(fill);
    }

    static {
            PerformanceTracker.setSceneAccessor(new PerformanceTracker.SceneAccessor() {
                public void setPerfTracker(Scene scene, PerformanceTracker tracker) {
                    synchronized (trackerMonitor) {
                        scene.tracker = tracker;
                    }
                }
                public PerformanceTracker getPerfTracker(Scene scene) {
                    synchronized (trackerMonitor) {
                        return scene.tracker;
                    }
                }
            });
            SceneHelper.setSceneAccessor(
                    new SceneHelper.SceneAccessor() {
                        @Override
                        public void enableInputMethodEvents(Scene scene, boolean enable) {
                            scene.enableInputMethodEvents(enable);
                        }

                        @Override
                        public void processKeyEvent(Scene scene, KeyEvent e) {
                            scene.processKeyEvent(e);
                        }

                        @Override
                        public void processMouseEvent(Scene scene, MouseEvent e) {
                            scene.processMouseEvent(e);
                        }

                        @Override
                        public void preferredSize(Scene scene) {
                            scene.preferredSize();
                        }

                        @Override
                        public void disposePeer(Scene scene) {
                            scene.disposePeer();
                        }

                        @Override
                        public void initPeer(Scene scene) {
                            scene.initPeer();
                        }

                        @Override
                        public void setWindow(Scene scene, Window window) {
                            scene.setWindow(window);
                        }

                        @Override
                        public TKScene getPeer(Scene scene) {
                            return scene.getPeer();
                        }

                        @Override
                        public void setAllowPGAccess(boolean flag) {
                            Scene.setAllowPGAccess(flag);
                        }

                        @Override
                        public void parentEffectiveOrientationInvalidated(
                                final Scene scene) {
                            scene.parentEffectiveOrientationInvalidated();
                        }

                        @Override
                        public Camera getEffectiveCamera(Scene scene) {
                            return scene.getEffectiveCamera();
                        }

                        @Override
                        public Scene createPopupScene(Parent root) {
                            return new Scene(root) {
                                       @Override
                                       void doLayoutPass() {
                                           resizeRootToPreferredSize(getRoot());
                                           super.doLayoutPass();
                                       }

                                       @Override
                                       void resizeRootOnSceneSizeChange(
                                               double newWidth,
                                               double newHeight) {
                                           // don't resize
                                       }
                                   };
                        }

                        @Override
                        public void setTransientFocusContainer(Scene scene, Node node) {
                            if (scene != null) {
                                scene.transientFocusContainer = node;
                            }
                        }

                        @Override
                        public Accessible getAccessible(Scene scene) {
                            return scene.getAccessible();
                        }
                    });
        }

        // Reserve space for 30 nodes in the dirtyNodes set.
        private static final int MIN_DIRTY_CAPACITY = 30;

        // For debugging
        private static boolean inSynchronizer = false;
        private static boolean inMousePick = false;
        private static boolean allowPGAccess = false;
        private static int pgAccessCount = 0;

        /**
         * Used for debugging purposes. Returns true if we are in either the
         * mouse event code (picking) or the synchronizer, or if the scene is
         * not yet initialized,
         *
         */
        static boolean isPGAccessAllowed() {
            return inSynchronizer || inMousePick || allowPGAccess;
        }

        static void setAllowPGAccess(boolean flag) {
            if (Utils.assertionEnabled()) {
                if (flag) {
                    pgAccessCount++;
                    allowPGAccess = true;
                }
                else {
                    if (pgAccessCount &lt;= 0) {
                        throw new java.lang.AssertionError(&quot;*** pgAccessCount underflow&quot;);
                    }
                    if (--pgAccessCount == 0) {
                        allowPGAccess = false;
                    }
                }
            }
        }

        /**
         * If true, use the platform's drag gesture detection
         * else use Scene-level detection as per DnDGesture.process(MouseEvent, List)
         */
        private static final boolean PLATFORM_DRAG_GESTURE_INITIATION = false;

    /**
     * Set of dirty nodes; processed once per frame by the synchronizer.
     * When a node's state changes such that it becomes &quot;dirty&quot; with respect
     * to the graphics stack and requires synchronization, then that node
     * is added to this list. Note that if state on the Node changes, but it
     * was already dirty, then the Node doesn't add itself again.
     * &lt;p&gt;
     * Because at initialization time every node in the scene graph is dirty,
     * we have a special state and special code path during initialization
     * that does not involve adding each node to the dirtyNodes list. When
     * dirtyNodes is null, that means this Scene has not yet been synchronized.
     * A good default size is then created for the dirtyNodes list.
     * &lt;p&gt;
     * We double-buffer the set so that we can add new nodes to the
     * set while processing the existing set. This avoids our having to
     * take a snapshot of the set (e.g., with toArray()) and reduces garbage.
     */
    private Node[] dirtyNodes;
    private int dirtyNodesSize;

    /**
     * Add the specified node to this scene's dirty list. Called by the
     * markDirty method in Node or when the Node's scene changes.
     */
    void addToDirtyList(Node n) {
        if (dirtyNodes == null || dirtyNodesSize == 0) {
            if (peer != null) {
                Toolkit.getToolkit().requestNextPulse();
            }
        }

        if (dirtyNodes != null) {
            if (dirtyNodesSize == dirtyNodes.length) {
                Node[] tmp = new Node[dirtyNodesSize + (dirtyNodesSize &gt;&gt; 1)];
                System.arraycopy(dirtyNodes, 0, tmp, 0, dirtyNodesSize);
                dirtyNodes = tmp;
            }
            dirtyNodes[dirtyNodesSize++] = n;
        }
    }

    private void doCSSPass() {
        final Parent sceneRoot = getRoot();
        //
        // RT-17547: when the tree is synchronized, the dirty bits are
        // are cleared but the cssFlag might still be something other than
        // clean.
        //
        // Before RT-17547, the code checked the dirty bit. But this is
        // superfluous since the dirty bit will be set if the flag is not clean,
        // but the flag will never be anything other than clean if the dirty
        // bit is not set. The dirty bit is still needed, however, since setting
        // it ensures a pulse if no other dirty bits have been set.
        //
        // For the purpose of showing the change, the dirty bit
        // check code was commented out and not removed.
        //
//        if (sceneRoot.isDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS)) {
        if (sceneRoot.cssFlag != CssFlags.CLEAN) {
            // The dirty bit isn't checked but we must ensure it is cleared.
            // The cssFlag is set to clean in either Node.processCSS or
            // NodeHelper.processCSS
            sceneRoot.clearDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
            sceneRoot.processCSS();
        }
    }

    void doLayoutPass() {
        final Parent r = getRoot();
        if (r != null) {
            r.layout();
        }
    }

    /**
     * The peer of this scene
     */
    private TKScene peer;

    /*
     * Get Scene's peer
     */
    TKScene getPeer() {
        return peer;
    }

    /**
     * The scene pulse listener that gets called on toolkit pulses
     */
    ScenePulseListener scenePulseListener = new ScenePulseListener();

    private List&lt;Runnable&gt; preLayoutPulseListeners;
    private List&lt;Runnable&gt; postLayoutPulseListeners;

    /**
     * Adds a new scene pre layout pulse listener to this scene. Every time a pulse occurs,
     * this listener will be called on the JavaFX Application Thread directly
     * &lt;strong&gt;before&lt;/strong&gt; the CSS and layout passes, and also before
     * any rendering is done for
     * this frame. This scene pulse listener is suitable for knowing when a
     * scenegraph pulse is happening and also for modifying the scenegraph
     * (as it is called before CSS and layout, so any changes made will be properly
     * styled and positioned).
     *
     * This method must be called on the JavaFX Application thread.
     *
     * @param r The Runnable to be called when the pulse occurs.
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     *
     * @throws NullPointerException if the provided Runnable is null.
     *
     * @since 9
     */
    public final void addPreLayoutPulseListener(Runnable r) {
        Toolkit.getToolkit().checkFxUserThread();

        if (r == null) {
            throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
        }
        if (preLayoutPulseListeners == null) {
            preLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
        }
        preLayoutPulseListeners.add(r);
    }

    /**
     * Removes a previously registered scene pre layout pulse listener from listening to
     * pulses in this scene. This method does nothing if the specified Runnable is
     * not already in the list.
     *
     * This method must be called on the JavaFX Application thread.
     *
     * @param r The Runnable that should no longer be called when the pulse
     * occurs for this scene.
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     *
     * @since 9
     */
    public final void removePreLayoutPulseListener(Runnable r) {
        Toolkit.getToolkit().checkFxUserThread();

        if (preLayoutPulseListeners == null) {
            return;
        }
        preLayoutPulseListeners.remove(r);
    }

    /**
     * Adds a new scene post layout pulse listener to this scene. Every time a pulse occurs,
     * this listener will be called on the JavaFX Application Thread directly
     * &lt;strong&gt;after&lt;/strong&gt; the CSS and layout passes, but before any rendering is done for
     * this frame. This scene pulse listener is suitable for knowing when a
     * scenegraph pulse is happening, but it is not suited to use cases related
     * to modifying the scenegraph (as it is called after CSS and layout, so
     * any changes will possibly be incorrect until the next pulse is run).
     * An alternative (and better) solution for situations where a scenegraph
     * modification is required to happen is to use either the
     * {@link #addPreLayoutPulseListener(Runnable)} API or the the
     * {@link javafx.animation.AnimationTimer} API.
     *
     * This method must be called on the JavaFX Application thread.
     *
     * @param r The Runnable to be called when the pulse occurs.
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     *
     * @throws NullPointerException if the provided Runnable is null.
     *
     * @since 9
     */
    public final void addPostLayoutPulseListener(Runnable r) {
        Toolkit.getToolkit().checkFxUserThread();

        if (r == null) {
            throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
        }
        if (postLayoutPulseListeners == null) {
            postLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
        }
        postLayoutPulseListeners.add(r);
    }

    /**
     * Removes a previously registered scene post layout pulse listener from listening to
     * pulses in this scene. This method does nothing if the specified Runnable is
     * not already in the list.
     *
     * This method must be called on the JavaFX Application thread.
     *
     * @param r The Runnable that should no longer be called when the pulse
     * occurs for this scene.
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     *
     * @since 9
     */
    public final void removePostLayoutPulseListener(Runnable r) {
        Toolkit.getToolkit().checkFxUserThread();

        if (postLayoutPulseListeners == null) {
            return;
        }
        postLayoutPulseListeners.remove(r);
    }

    /**
     * Return the defined {@code SceneAntialiasing} for this {@code Scene}.
     * &lt;p&gt;
     * Note: this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * and {@link javafx.scene.SceneAntialiasing SceneAntialiasing}
     * for more information.
     * @return the SceneAntialiasing for this scene
     * @since JavaFX 8.0
     */
    public final SceneAntialiasing getAntiAliasing() {
        return antiAliasing;
    }

    private boolean getAntiAliasingInternal() {
        return (antiAliasing != null &amp;&amp;
                Toolkit.getToolkit().isMSAASupported() &amp;&amp;
                Platform.isSupported(ConditionalFeature.SCENE3D)) ?
                antiAliasing != SceneAntialiasing.DISABLED : false;
    }

    /**
     * The {@code Window} for this {@code Scene}
     */
    private ReadOnlyObjectWrapper&lt;Window&gt; window;

    void setWindow(Window value) {
        windowPropertyImpl().set(value);
    }

    public final Window getWindow() {
        return window == null ? null : window.get();
    }

    public final ReadOnlyObjectProperty&lt;Window&gt; windowProperty() {
        return windowPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyObjectWrapper&lt;Window&gt; windowPropertyImpl() {
        if (window == null) {
            window = new ReadOnlyObjectWrapper&lt;Window&gt;() {
                private Window oldWindow;

                @Override protected void invalidated() {
                    final Window newWindow = get();
                    getKeyHandler().windowForSceneChanged(oldWindow, newWindow);
                    if (oldWindow != null) {
                        disposePeer();
                    }
                    if (newWindow != null) {
                        initPeer();
                    }
                    parentEffectiveOrientationInvalidated();

                    oldWindow = newWindow;
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;window&quot;;
                }
            };
        }
        return window;
    }

    void initPeer() {
        assert peer == null;

        Window window = getWindow();
        // initPeer() is only called from Window, either when the window
        // is being shown, or the window scene is being changed. In any case
        // this scene's window cannot be null.
        assert window != null;

        TKStage windowPeer = WindowHelper.getPeer(window);
        if (windowPeer == null) {
            // This is fine, the window is not visible. initPeer() will
            // be called again later, when the window is being shown.
            return;
        }

        final boolean isTransparentWindowsSupported = Platform.isSupported(ConditionalFeature.TRANSPARENT_WINDOW);
        if (!isTransparentWindowsSupported) {
            PlatformImpl.addNoTransparencyStylesheetToScene(this);
        }

        PerformanceTracker.logEvent(&quot;Scene.initPeer started&quot;);

        setAllowPGAccess(true);

        Toolkit tk = Toolkit.getToolkit();
        peer = windowPeer.createTKScene(isDepthBufferInternal(), getAntiAliasingInternal(), acc);
        PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene created&quot;);
        peer.setTKSceneListener(new ScenePeerListener());
        peer.setTKScenePaintListener(new ScenePeerPaintListener());
        PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene set&quot;);
        peer.setRoot(getRoot().getPeer());
        peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
        NodeHelper.updatePeer(getEffectiveCamera());
        peer.setCamera((NGCamera) getEffectiveCamera().getPeer());
        peer.markDirty();
        PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene initialized&quot;);

        setAllowPGAccess(false);

        tk.addSceneTkPulseListener(scenePulseListener);
        // listen to dnd gestures coming from the platform
        if (PLATFORM_DRAG_GESTURE_INITIATION) {
            if (dragGestureListener == null) {
                dragGestureListener = new DragGestureListener();
            }
            tk.registerDragGestureListener(peer, EnumSet.allOf(TransferMode.class), dragGestureListener);
        }
        tk.enableDrop(peer, new DropTargetListener());
        tk.installInputMethodRequests(peer, new InputMethodRequestsDelegate());

        PerformanceTracker.logEvent(&quot;Scene.initPeer finished&quot;);
    }

    public void disposePeer() {
        if (peer == null) {
            // This is fine, the window is either not shown yet and there is no
            // need in disposing scene peer, or is hidden and disposePeer()
            // has already been called.
            return;
        }

        PerformanceTracker.logEvent(&quot;Scene.disposePeer started&quot;);

        Toolkit tk = Toolkit.getToolkit();
        tk.removeSceneTkPulseListener(scenePulseListener);
        if (accessible != null) {
            disposeAccessibles();
            Node root = getRoot();
            if (root != null) root.releaseAccessible();
            accessible.dispose();
            accessible = null;
        }
        peer.dispose();
        peer = null;

        PerformanceTracker.logEvent(&quot;Scene.disposePeer finished&quot;);
    }

    DnDGesture dndGesture = null;
    DragGestureListener dragGestureListener;
    /**
     * The horizontal location of this {@code Scene} on the {@code Window}.
     */
    private ReadOnlyDoubleWrapper x;

    private final void setX(double value) {
        xPropertyImpl().set(value);
    }

    public final double getX() {
        return x == null ? 0.0 : x.get();
    }

    public final ReadOnlyDoubleProperty xProperty() {
        return xPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyDoubleWrapper xPropertyImpl() {
        if (x == null) {
            x = new ReadOnlyDoubleWrapper(this, &quot;x&quot;);
        }
        return x;
    }

    /**
     * The vertical location of this {@code Scene} on the {@code Window}.
     */
    private ReadOnlyDoubleWrapper y;

    private final void setY(double value) {
        yPropertyImpl().set(value);
    }

    public final double getY() {
        return y == null ? 0.0 : y.get();
    }

    public final ReadOnlyDoubleProperty yProperty() {
        return yPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyDoubleWrapper yPropertyImpl() {
        if (y == null) {
            y = new ReadOnlyDoubleWrapper(this, &quot;y&quot;);
        }
        return y;
    }

    /**
     * The width of this {@code Scene}
     */
    private ReadOnlyDoubleWrapper width;

    private final void setWidth(double value) {
        widthPropertyImpl().set(value);
    }

    public final double getWidth() {
        return width == null ? 0.0 : width.get();
    }

    public final ReadOnlyDoubleProperty widthProperty() {
        return widthPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyDoubleWrapper widthPropertyImpl() {
        if (width == null) {
            width = new ReadOnlyDoubleWrapper() {

                @Override
                protected void invalidated() {
                    final Parent _root = getRoot();
                    //TODO - use a better method to update mirroring
                    if (_root.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
                        NodeHelper.transformsChanged(_root);
                    }
                    if (_root.isResizable()) {
                        resizeRootOnSceneSizeChange(get() - _root.getLayoutX() - _root.getTranslateX(), _root.getLayoutBounds().getHeight());
                    }

                    getEffectiveCamera().setViewWidth(get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;width&quot;;
                }
            };
        }
        return width;
    }

    /**
     * The height of this {@code Scene}
     */
    private ReadOnlyDoubleWrapper height;

    private final void setHeight(double value) {
        heightPropertyImpl().set(value);
    }

    public final double getHeight() {
        return height == null ? 0.0 : height.get();
    }

    public final ReadOnlyDoubleProperty heightProperty() {
        return heightPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyDoubleWrapper heightPropertyImpl() {
        if (height == null) {
            height = new ReadOnlyDoubleWrapper() {

                @Override
                protected void invalidated() {
                    final Parent _root = getRoot();
                    if (_root.isResizable()) {
                        resizeRootOnSceneSizeChange(_root.getLayoutBounds().getWidth(), get() - _root.getLayoutY() - _root.getTranslateY());
                    }

                    getEffectiveCamera().setViewHeight(get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;height&quot;;
                }
            };
        }
        return height;
    }

    void resizeRootOnSceneSizeChange(double newWidth, double newHeight) {
        getRoot().resize(newWidth, newHeight);
    }

    // Reusable target wrapper (to avoid creating new one for each picking)
    private TargetWrapper tmpTargetWrapper = new TargetWrapper();

    /**
     * Specifies the type of camera use for rendering this {@code Scene}.
     * If {@code camera} is null, a parallel camera is used for rendering.
     * It is illegal to set a camera that belongs to other {@code Scene}
     * or {@code SubScene}.
     * &lt;p&gt;
     * Note: this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @defaultValue null
     */
    private ObjectProperty&lt;Camera&gt; camera;

    public final void setCamera(Camera value) {
        cameraProperty().set(value);
    }

    public final Camera getCamera() {
        return camera == null ? null : camera.get();
    }

    public final ObjectProperty&lt;Camera&gt; cameraProperty() {
        if (camera == null) {
            camera = new ObjectPropertyBase&lt;Camera&gt;() {
                Camera oldCamera = null;

                @Override
                protected void invalidated() {
                    Camera _value = get();
                    if (_value != null) {
                        if (_value instanceof PerspectiveCamera
                                &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
                            String logname = Scene.class.getName();
                            PlatformLogger.getLogger(logname).warning(&quot;System can't support &quot;
                                    + &quot;ConditionalFeature.SCENE3D&quot;);
                        }
                        // Illegal value if it belongs to other scene or any subscene
                        if ((_value.getScene() != null &amp;&amp; _value.getScene() != Scene.this)
                                || _value.getSubScene() != null) {
                            throw new IllegalArgumentException(_value
                                    + &quot;is already part of other scene or subscene&quot;);
                        }
                        // throws exception if the camera already has a different owner
                        _value.setOwnerScene(Scene.this);
                        _value.setViewWidth(getWidth());
                        _value.setViewHeight(getHeight());
                    }
                    if (oldCamera != null &amp;&amp; oldCamera != _value) {
                        oldCamera.setOwnerScene(null);
                    }
                    oldCamera = _value;
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;camera&quot;;
                }
            };
        }
        return camera;
    }

    Camera getEffectiveCamera() {
        final Camera cam = getCamera();
        if (cam == null
                || (cam instanceof PerspectiveCamera
                &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D))) {
            if (defaultCamera == null) {
                defaultCamera = new ParallelCamera();
                defaultCamera.setOwnerScene(this);
                defaultCamera.setViewWidth(getWidth());
                defaultCamera.setViewHeight(getHeight());
            }
            return defaultCamera;
        }

        return cam;
    }

    // Used by the camera
    void markCameraDirty() {
        markDirty(DirtyBits.CAMERA_DIRTY);
        setNeedsRepaint();
    }

    void markCursorDirty() {
        markDirty(DirtyBits.CURSOR_DIRTY);
    }

    /**
     * Defines the background fill of this {@code Scene}. Both a {@code null}
     * value meaning 'paint no background' and a {@link javafx.scene.paint.Paint}
     * with transparency are supported. The default fill of the Scene is
     * {@link Color#WHITE}, but it is more commonly the case that the initial
     * color shown to users is the background fill of the
     * {@link #rootProperty() root node} of the {@code Scene}, as it typically is
     * stretched to take up all available space in the {@code Scene}. The
     * root node of the {@code Scene} is given the CSS style class 'root', and
     * the default user agent stylesheets that ship with JavaFX (presently
     * Caspian and Modena) apply styling on to this root style class. In the
     * case of Caspian this does not impact the background fill color of the
     * root node, but in the case of Modena the default fill is set to be a
     * light gray color.
     *
     * @defaultValue WHITE
     */
    private ObjectProperty&lt;Paint&gt; fill;

    public final void setFill(Paint value) {
        fillProperty().set(value);
    }

    public final Paint getFill() {
        return fill == null ? Color.WHITE : fill.get();
    }

    public final ObjectProperty&lt;Paint&gt; fillProperty() {
        if (fill == null) {
            fill = new ObjectPropertyBase&lt;Paint&gt;(Color.WHITE) {

                @Override
                protected void invalidated() {
                    markDirty(DirtyBits.FILL_DIRTY);
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;fill&quot;;
                }
            };
        }
        return fill;
    }

    /**
     * Defines the root {@code Node} of the scene graph.
     * If a {@code Group} is used as the root, the
     * contents of the scene graph will be clipped by the scene's width and height and
     * changes to the scene's size (if user resizes the stage) will not alter the
     * layout of the scene graph.    If a resizable node (layout {@code Region} or
     * {@code Control}) is set as the root, then the root's size will track the
     * scene's size, causing the contents to be relayed out as necessary.
     *
     * Scene doesn't accept null root.
     *
     */
    private ObjectProperty&lt;Parent&gt; root;

    public final void setRoot(Parent value) {
        rootProperty().set(value);
    }

    public final Parent getRoot() {
        return root == null ? null : root.get();
    }

    Parent oldRoot;
    public final ObjectProperty&lt;Parent&gt; rootProperty() {
        if (root == null) {
            root = new ObjectPropertyBase&lt;Parent&gt;() {

                private void forceUnbind() {
                    System.err.println(&quot;Unbinding illegal root.&quot;);
                    unbind();
                }

                @Override
                protected void invalidated() {
                    Parent _value = get();

                    if (_value == null) {
                        if (isBound()) forceUnbind();
                        throw new NullPointerException(&quot;Scene's root cannot be null&quot;);
                    }

                    if (_value.getParent() != null) {
                        if (isBound()) forceUnbind();
                        throw new IllegalArgumentException(_value +
                                &quot;is already inside a scene-graph and cannot be set as root&quot;);
                    }
                    if (_value.getClipParent() != null) {
                        if (isBound()) forceUnbind();
                        throw new IllegalArgumentException(_value +
                                &quot;is set as a clip on another node, so cannot be set as root&quot;);
                    }
                    if (_value.getScene() != null &amp;&amp; _value.getScene().getRoot() == _value &amp;&amp; _value.getScene() != Scene.this) {
                        if (isBound()) forceUnbind();
                        throw new IllegalArgumentException(_value +
                                &quot;is already set as root of another scene&quot;);
                    }

                    if (oldRoot != null) {
                        oldRoot.setScenes(null, null);
                    }
                    oldRoot = _value;
                    _value.getStyleClass().add(0, &quot;root&quot;);
                    _value.setScenes(Scene.this, null);
                    markDirty(DirtyBits.ROOT_DIRTY);
                    _value.resize(getWidth(), getHeight()); // maybe no-op if root is not resizable
                    _value.requestLayout();
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;root&quot;;
                }
            };
        }
        return root;
    }

    void setNeedsRepaint() {
        if (this.peer != null) {
            peer.entireSceneNeedsRepaint();
        }
    }

    // Process CSS and layout and sync the scene prior to the snapshot
    // operation of the given node for this scene (currently the node
    // is unused but could possibly be used in the future to optimize this)
    void doCSSLayoutSyncForSnapshot(Node node) {
        if (!sizeInitialized) {
            preferredSize();
        } else {
            doCSSPass();
        }

        // we do not need pulse in the snapshot code
        // because this scene can be stage-less
        doLayoutPass();

        getRoot().updateBounds();
        if (peer != null) {
            peer.waitForRenderingToComplete();
            peer.waitForSynchronization();
            try {
                // Run the synchronizer while holding the render lock
                scenePulseListener.synchronizeSceneNodes();
            } finally {
                peer.releaseSynchronization(false);
            }
        } else {
            scenePulseListener.synchronizeSceneNodes();
        }

    }

    // Shared method for Scene.snapshot and Node.snapshot. It is static because
    // we might be doing a Node snapshot with a null scene
    static WritableImage doSnapshot(Scene scene,
            double x, double y, double w, double h,
            Node root, BaseTransform transform, boolean depthBuffer,
            Paint fill, Camera camera, WritableImage wimg) {

        Toolkit tk = Toolkit.getToolkit();
        Toolkit.ImageRenderingContext context = new Toolkit.ImageRenderingContext();

        int xMin = (int)Math.floor(x);
        int yMin = (int)Math.floor(y);
        int xMax = (int)Math.ceil(x + w);
        int yMax = (int)Math.ceil(y + h);
        int width = Math.max(xMax - xMin, 1);
        int height = Math.max(yMax - yMin, 1);
        if (wimg == null) {
            wimg = new WritableImage(width, height);
        } else {
            width = (int)wimg.getWidth();
            height = (int)wimg.getHeight();
        }

        setAllowPGAccess(true);
        context.x = xMin;
        context.y = yMin;
        context.width = width;
        context.height = height;
        context.transform = transform;
        context.depthBuffer = depthBuffer;
        context.root = root.getPeer();
        context.platformPaint = fill == null ? null : tk.getPaint(fill);
        double cameraViewWidth = 1.0;
        double cameraViewHeight = 1.0;
        if (camera != null) {
            // temporarily adjust camera viewport to the snapshot size
            cameraViewWidth = camera.getViewWidth();
            cameraViewHeight = camera.getViewHeight();
            camera.setViewWidth(width);
            camera.setViewHeight(height);
            NodeHelper.updatePeer(camera);
            context.camera = camera.getPeer();
        } else {
            context.camera = null;
        }

        // Grab the lights from the scene
        context.lights = null;
        if (scene != null &amp;&amp; !scene.lights.isEmpty()) {
            context.lights = new NGLightBase[scene.lights.size()];
            for (int i = 0; i &lt; scene.lights.size(); i++) {
                context.lights[i] = scene.lights.get(i).getPeer();
            }
        }

        Toolkit.WritableImageAccessor accessor = Toolkit.getWritableImageAccessor();
        context.platformImage = accessor.getTkImageLoader(wimg);
        setAllowPGAccess(false);
        Object tkImage = tk.renderToImage(context);
        accessor.loadTkImage(wimg, tkImage);

        if (camera != null) {
            setAllowPGAccess(true);
            camera.setViewWidth(cameraViewWidth);
            camera.setViewHeight(cameraViewHeight);
            NodeHelper.updatePeer(camera);
            setAllowPGAccess(false);
        }

        // if this scene belongs to some stage
        // we need to mark the entire scene as dirty
        // because dirty logic is buggy
        if (scene != null &amp;&amp; scene.peer != null) {
            scene.setNeedsRepaint();
        }

        return wimg;
    }

    /**
     * Implementation method for snapshot
     */
    private WritableImage doSnapshot(WritableImage img) {
        // TODO: no need to do CSS, layout or sync in the deferred case,
        // if this scene is attached to a visible stage
        doCSSLayoutSyncForSnapshot(getRoot());

        double w = getWidth();
        double h = getHeight();
        BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;

        return doSnapshot(this, 0, 0, w, h,
                getRoot(), transform, isDepthBufferInternal(),
                getFill(), getEffectiveCamera(), img);
    }

    // Pulse listener used to run all deferred (async) snapshot requests
    private static TKPulseListener snapshotPulseListener = null;

    private static List&lt;Runnable&gt; snapshotRunnableListA;
    private static List&lt;Runnable&gt; snapshotRunnableListB;
    private static List&lt;Runnable&gt; snapshotRunnableList;

    static void addSnapshotRunnable(final Runnable runnable) {
        Toolkit.getToolkit().checkFxUserThread();

        if (snapshotPulseListener == null) {
            snapshotRunnableListA = new ArrayList&lt;Runnable&gt;();
            snapshotRunnableListB = new ArrayList&lt;Runnable&gt;();
            snapshotRunnableList = snapshotRunnableListA;

            snapshotPulseListener = () -&gt; {
                if (snapshotRunnableList.size() &gt; 0) {
                    List&lt;Runnable&gt; runnables = snapshotRunnableList;
                    if (snapshotRunnableList == snapshotRunnableListA) {
                        snapshotRunnableList = snapshotRunnableListB;
                    } else {
                        snapshotRunnableList = snapshotRunnableListA;
                    }
                    for (Runnable r : runnables) {
                        try {
                            r.run();
                        } catch (Throwable th) {
                            System.err.println(&quot;Exception in snapshot runnable&quot;);
                            th.printStackTrace(System.err);
                        }
                    }
                    runnables.clear();
                }
            };

            // Add listener that will be called after all of the scenes have
            // had layout and CSS processing, and have been synced
            Toolkit.getToolkit().addPostSceneTkPulseListener(snapshotPulseListener);
        }

        final AccessControlContext acc = AccessController.getContext();
        snapshotRunnableList.add(() -&gt; {
            AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                runnable.run();
                return null;
            }, acc);
        });
        Toolkit.getToolkit().requestNextPulse();
    }

    /**
     * Takes a snapshot of this scene and returns the rendered image when
     * it is ready.
     * CSS and layout processing will be done for the scene prior to
     * rendering it.
     * The entire destination image is cleared using the fill {@code Paint}
     * of this scene. The nodes in the scene are then rendered to the image.
     * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
     * If the image is smaller than the size of the scene, then the rendering
     * will be clipped by the image.
     *
     * &lt;p&gt;
     * When taking a snapshot of a scene that is being animated, either
     * explicitly by the application or implicitly (such as chart animation),
     * the snapshot will be rendered based on the state of the scene graph at
     * the moment the snapshot is taken and will not reflect any subsequent
     * animation changes.
     * &lt;/p&gt;
     *
     * @param image the writable image that will be used to hold the rendered scene.
     * It may be null in which case a new WritableImage will be constructed.
     * If the image is non-null, the scene will be rendered into the
     * existing image.
     * In this case, the width and height of the image determine the area
     * that is rendered instead of the width and height of the scene.
     *
     * @throws IllegalStateException if this method is called on a thread
     *     other than the JavaFX Application Thread.
     *
     * @return the rendered image
     * @since JavaFX 2.2
     */
    public WritableImage snapshot(WritableImage image) {
        Toolkit.getToolkit().checkFxUserThread();

        return doSnapshot(image);
    }

    /**
     * Takes a snapshot of this scene at the next frame and calls the
     * specified callback method when the image is ready.
     * CSS and layout processing will be done for the scene prior to
     * rendering it.
     * The entire destination image is cleared using the fill {@code Paint}
     * of this scene. The nodes in the scene are then rendered to the image.
     * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
     * If the image is smaller than the size of the scene, then the rendering
     * will be clipped by the image.
     *
     * &lt;p&gt;
     * This is an asynchronous call, which means that other
     * events or animation might be processed before the scene is rendered.
     * If any such events modify a node in the scene that modification will
     * be reflected in the rendered image (as it will also be reflected in
     * the frame rendered to the Stage).
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * When taking a snapshot of a scene that is being animated, either
     * explicitly by the application or implicitly (such as chart animation),
     * the snapshot will be rendered based on the state of the scene graph at
     * the moment the snapshot is taken and will not reflect any subsequent
     * animation changes.
     * &lt;/p&gt;
     *
     * @param callback a class whose call method will be called when the image
     * is ready. The SnapshotResult that is passed into the call method of
     * the callback will contain the rendered image and the source scene
     * that was rendered. The callback parameter must not be null.
     *
     * @param image the writable image that will be used to hold the rendered scene.
     * It may be null in which case a new WritableImage will be constructed.
     * If the image is non-null, the scene will be rendered into the
     * existing image.
     * In this case, the width and height of the image determine the area
     * that is rendered instead of the width and height of the scene.
     *
     * @throws IllegalStateException if this method is called on a thread
     *     other than the JavaFX Application Thread.
     *
     * @throws NullPointerException if the callback parameter is null.
     * @since JavaFX 2.2
     */
    public void snapshot(Callback&lt;SnapshotResult, Void&gt; callback, WritableImage image) {
        Toolkit.getToolkit().checkFxUserThread();
        if (callback == null) {
            throw new NullPointerException(&quot;The callback must not be null&quot;);
        }

        final Callback&lt;SnapshotResult, Void&gt; theCallback = callback;
        final WritableImage theImage = image;

        // Create a deferred runnable that will be run from a pulse listener
        // that is called after all of the scenes have been synced but before
        // any of them have been rendered.
        final Runnable snapshotRunnable = () -&gt; {
            WritableImage img = doSnapshot(theImage);
//                System.err.println(&quot;Calling snapshot callback&quot;);
            SnapshotResult result = new SnapshotResult(img, Scene.this, null);
            try {
                Void v = theCallback.call(result);
            } catch (Throwable th) {
                System.err.println(&quot;Exception in snapshot callback&quot;);
                th.printStackTrace(System.err);
            }
        };
//        System.err.println(&quot;Schedule a snapshot in the future&quot;);
        addSnapshotRunnable(snapshotRunnable);
    }

    /**
     * Defines the mouse cursor for this {@code Scene}.
     */
    private ObjectProperty&lt;Cursor&gt; cursor;

    public final void setCursor(Cursor value) {
        cursorProperty().set(value);
    }

    public final Cursor getCursor() {
        return cursor == null ? null : cursor.get();
    }

    public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
        if (cursor == null) {
            cursor = new ObjectPropertyBase&lt;Cursor&gt;() {
                         @Override
                         protected void invalidated() {
                             markCursorDirty();
                         }

                         @Override
                         public Object getBean() {
                             return Scene.this;
                         }

                         @Override
                         public String getName() {
                             return &quot;cursor&quot;;
                         }
                     };
        }
        return cursor;
    }

    /**
     * Looks for any node within the scene graph based on the specified CSS selector.
     * If more than one node matches the specified selector, this function
     * returns the first of them.
     * If no nodes are found with this id, then null is returned.
     *
     * @param selector The css selector to look up
     * @return the {@code Node} in the scene which matches the CSS {@code selector},
     * or {@code null} if none is found.
     */
     public Node lookup(String selector) {
         return getRoot().lookup(selector);
     }
    /**
     * A ObservableList of string URLs linking to the stylesheets to use with this scene's
     * contents. For additional information about using CSS with the
     * scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
     * Guide&lt;/a&gt;.
     */
    private final ObservableList&lt;String&gt; stylesheets  = new TrackableObservableList&lt;String&gt;() {
        @Override
        protected void onChanged(Change&lt;String&gt; c) {
            StyleManager.getInstance().stylesheetsChanged(Scene.this, c);
            // RT-9784 - if stylesheet is removed, reset styled properties to
            // their initial value.
            c.reset();
            while(c.next()) {
                if (c.wasRemoved() == false) {
                    continue;
                }
                break; // no point in resetting more than once...
            }
            getRoot().reapplyCSS();
        }
    };

    /**
     * Gets an observable list of string URLs linking to the stylesheets to use
     * with this scene's contents.
     * &lt;p&gt;
     * The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
     * does not have a [scheme:] component, the URL is considered to be the [path] component only.
     * Any leading '/' character of the [path] is ignored and the [path] is treated as a path relative to
     * the root of the application's classpath.
     * &lt;/p&gt;
     * &lt;pre&gt;&lt;code&gt;
     *
     * package com.example.javafx.app;
     *
     * import javafx.application.Application;
     * import javafx.scene.Group;
     * import javafx.scene.Scene;
     * import javafx.stage.Stage;
     *
     * public class MyApp extends Application {
     *
     *     {@literal @}Override public void start(Stage stage) {
     *         Scene scene = new Scene(new Group());
     *         scene.getStylesheets().add(&quot;/com/example/javafx/app/mystyles.css&quot;);
     *         stage.setScene(scene);
     *         stage.show();
     *     }
     *
     *     public static void main(String[] args) {
     *         launch(args);
     *     }
     * }
     * &lt;/code&gt;&lt;/pre&gt;
     * For additional information about using CSS with the scene graph,
     * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     *
     * @return the list of stylesheets to use with this scene
     */
    public final ObservableList&lt;String&gt; getStylesheets() { return stylesheets; }

    private ObjectProperty&lt;String&gt; userAgentStylesheet = null;

    /**
     * @return the userAgentStylesheet property.
     * @see #getUserAgentStylesheet()
     * @see #setUserAgentStylesheet(String)
     * @since  JavaFX 8u20
     */
    public final ObjectProperty&lt;String&gt; userAgentStylesheetProperty() {
        if (userAgentStylesheet == null) {
            userAgentStylesheet = new SimpleObjectProperty&lt;String&gt;(Scene.this, &quot;userAgentStylesheet&quot;, null) {
                @Override protected void invalidated() {
                    StyleManager.getInstance().forget(Scene.this);
                    getRoot().reapplyCSS();
                }
            };
        }
        return userAgentStylesheet;
    }

    /**
     * Get the URL of the user-agent stylesheet that will be used by this Scene. If the URL has not been set,
     * the platform-default user-agent stylesheet will be used.
     * &lt;p&gt;
     * For additional information about using CSS with the scene graph,
     * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     * &lt;/p&gt;
     * @return The URL of the user-agent stylesheet that will be used by this Scene,
     * or null if has not been set.
     * @since  JavaFX 8u20
     */
    public final String getUserAgentStylesheet() {
        return userAgentStylesheet == null ? null : userAgentStylesheet.get();
    }

    /**
     * Set the URL of the user-agent stylesheet that will be used by this Scene in place of the
     * the platform-default user-agent stylesheet. If the URL does not resolve to a valid location,
     * the platform-default user-agent stylesheet will be used.
     * &lt;p&gt;
     * For additional information about using CSS with the scene graph,
     * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     * &lt;/p&gt;
     * @param url The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
     * does not have a [scheme:] component, the URL is considered to be the [path] component only.
     * Any leading '/' character of the [path] is ignored and the [path] is treated as a path relative to
     * the root of the application's classpath.
<A NAME="14"></A>     * @since  JavaFX 8u20
     */
    public final void setUserAgentStylesheet(String url) {
        <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#14',2,'match37-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>userAgentStylesheetProperty().set(url);
    }

    /**
     * Retrieves the depth buffer attribute for this scene.
     * @return the depth buffer attribute.
     */
    public final boolean isDepthBuffer() {
        return depthBuffer;
    }

    boolean isDepthBufferInternal() {
        if (!Platform.isSupported(ConditionalFeature.SCENE3D)) {
            return</B></FONT> false;
        }
        return depthBuffer;
    }

    private void init(double width, double height) {
        if (width &gt;= 0) {
            widthSetByUser = width;
            setWidth((float)width);
        }
        if (height &gt;= 0) {
            heightSetByUser = height;
            setHeight((float)height);
        }
        sizeInitialized = (widthSetByUser &gt;= 0 &amp;&amp; heightSetByUser &gt;= 0);
    }

    private void init() {
        if (PerformanceTracker.isLoggingEnabled()) {
            PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;]&quot;);
        }
        mouseHandler = new MouseHandler();
        clickGenerator = new ClickGenerator();

        if (PerformanceTracker.isLoggingEnabled()) {
            PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;] - finished&quot;);
        }
    }

    void preferredSize() {
        final Parent root = getRoot();

        // one or the other isn't initialized, need to perform layout in
        // order to ensure we can properly measure the preferred size of the
        // scene
        doCSSPass();

        resizeRootToPreferredSize(root);
        doLayoutPass();

        if (widthSetByUser &lt; 0) {
            setWidth(root.isResizable()? root.getLayoutX() + root.getTranslateX() + root.getLayoutBounds().getWidth() :
                            root.getBoundsInParent().getMaxX());
        } else {
            setWidth(widthSetByUser);
        }

        if (heightSetByUser &lt; 0) {
            setHeight(root.isResizable()? root.getLayoutY() + root.getTranslateY() + root.getLayoutBounds().getHeight() :
                            root.getBoundsInParent().getMaxY());
        } else {
            setHeight(heightSetByUser);
        }

        sizeInitialized = (getWidth() &gt; 0) &amp;&amp; (getHeight() &gt; 0);

        PerformanceTracker.logEvent(&quot;Scene preferred bounds computation complete&quot;);
    }

    final void resizeRootToPreferredSize(Parent root) {
        final double preferredWidth;
        final double preferredHeight;

        final Orientation contentBias = root.getContentBias();
        if (contentBias == null) {
            preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
            preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
        } else if (contentBias == Orientation.HORIZONTAL) {
            // height depends on width
            preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
            preferredHeight = getPreferredHeight(root, heightSetByUser,
                                                       preferredWidth);
        } else /* if (contentBias == Orientation.VERTICAL) */ {
            // width depends on height
            preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
            preferredWidth = getPreferredWidth(root, widthSetByUser,
                                                     preferredHeight);
        }

        root.resize(preferredWidth, preferredHeight);
    }

    private static double getPreferredWidth(Parent root,
                                            double forcedWidth,
                                            double height) {
        if (forcedWidth &gt;= 0) {
            return forcedWidth;
        }
        final double normalizedHeight = (height &gt;= 0) ? height : -1;
        return root.boundedSize(root.prefWidth(normalizedHeight),
                                root.minWidth(normalizedHeight),
                                root.maxWidth(normalizedHeight));
    }

    private static double getPreferredHeight(Parent root,
                                             double forcedHeight,
                                             double width) {
        if (forcedHeight &gt;= 0) {
            return forcedHeight;
        }
        final double normalizedWidth = (width &gt;= 0) ? width : -1;
        return root.boundedSize(root.prefHeight(normalizedWidth),
                                root.minHeight(normalizedWidth),
                                root.maxHeight(normalizedWidth));
    }

    private PerformanceTracker tracker;
    private static final Object trackerMonitor = new Object();

    // mouse events handling
    private MouseHandler mouseHandler;
    private ClickGenerator clickGenerator;

    // gesture events handling
    private Point2D cursorScreenPos;
    private Point2D cursorScenePos;

    private static class TouchGesture {
        WeakReference&lt;EventTarget&gt; target;
        Point2D sceneCoords;
        Point2D screenCoords;
        boolean finished;
    }

    private final TouchGesture scrollGesture = new TouchGesture();
    private final TouchGesture zoomGesture = new TouchGesture();
    private final TouchGesture rotateGesture = new TouchGesture();
    private final TouchGesture swipeGesture = new TouchGesture();

    // touch events handling
    private TouchMap touchMap = new TouchMap();
    private TouchEvent nextTouchEvent = null;
    private TouchPoint[] touchPoints = null;
    private int touchEventSetId = 0;
    private int touchPointIndex = 0;
    private Map&lt;Integer, EventTarget&gt; touchTargets =
            new HashMap&lt;Integer, EventTarget&gt;();

    void processMouseEvent(MouseEvent e) {
        mouseHandler.process(e, false);
    }

    private void processMenuEvent(double x2, double y2, double xAbs, double yAbs, boolean isKeyboardTrigger) {
        EventTarget eventTarget = null;
        Scene.inMousePick = true;
        if (isKeyboardTrigger) {
            Node sceneFocusOwner = getFocusOwner();

            // for keyboard triggers set coordinates inside focus owner
            final double xOffset = xAbs - x2;
            final double yOffset = yAbs - y2;
            if (sceneFocusOwner != null) {
                final Bounds bounds = sceneFocusOwner.localToScene(
                        sceneFocusOwner.getBoundsInLocal());
                x2 = bounds.getMinX() + bounds.getWidth() / 4;
                y2 = bounds.getMinY() + bounds.getHeight() / 2;
                eventTarget = sceneFocusOwner;
            } else {
                x2 = Scene.this.getWidth() / 4;
                y2 = Scene.this.getWidth() / 2;
                eventTarget = Scene.this;
            }

            xAbs = x2 + xOffset;
            yAbs = y2 + yOffset;
        }

        final PickResult res = pick(x2, y2);

        if (!isKeyboardTrigger) {
            eventTarget = res.getIntersectedNode();
            if (eventTarget == null) {
                eventTarget = this;
            }
        }

        if (eventTarget != null) {
            ContextMenuEvent context = new ContextMenuEvent(ContextMenuEvent.CONTEXT_MENU_REQUESTED,
                    x2, y2, xAbs, yAbs, isKeyboardTrigger, res);
            Event.fireEvent(eventTarget, context);
        }
        Scene.inMousePick = false;
    }

    private void processGestureEvent(GestureEvent e, TouchGesture gesture) {
        EventTarget pickedTarget = null;

        if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
                e.getEventType() == RotateEvent.ROTATION_STARTED ||
                e.getEventType() == ScrollEvent.SCROLL_STARTED) {
            gesture.target = null;
            gesture.finished = false;
        }

        if (gesture.target != null &amp;&amp; (!gesture.finished || e.isInertia())) {
            pickedTarget = gesture.target.get();
        } else {
            pickedTarget = e.getPickResult().getIntersectedNode();
            if (pickedTarget == null) {
                pickedTarget = this;
            }
        }

        if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
                e.getEventType() == RotateEvent.ROTATION_STARTED ||
                e.getEventType() == ScrollEvent.SCROLL_STARTED) {
            gesture.target = new WeakReference&lt;&gt;(pickedTarget);
        }
        if (e.getEventType() != ZoomEvent.ZOOM_FINISHED &amp;&amp;
                e.getEventType() != RotateEvent.ROTATION_FINISHED &amp;&amp;
                e.getEventType() != ScrollEvent.SCROLL_FINISHED &amp;&amp;
                !e.isInertia()) {
            gesture.sceneCoords = new Point2D(e.getSceneX(), e.getSceneY());
            gesture.screenCoords = new Point2D(e.getScreenX(), e.getScreenY());
        }

        if (pickedTarget != null) {
            Event.fireEvent(pickedTarget, e);
        }

        if (e.getEventType() == ZoomEvent.ZOOM_FINISHED ||
                e.getEventType() == RotateEvent.ROTATION_FINISHED ||
                e.getEventType() == ScrollEvent.SCROLL_FINISHED) {
            gesture.finished = true;
        }
    }

    private void processTouchEvent(TouchEvent e, TouchPoint[] touchPoints) {
        inMousePick = true;
        touchEventSetId++;

        List&lt;TouchPoint&gt; touchList = Arrays.asList(touchPoints);

        // fire all the events
        for (TouchPoint tp : touchPoints) {
            if (tp.getTarget() != null) {
                EventType&lt;TouchEvent&gt; type = null;
                switch (tp.getState()) {
                    case MOVED:
                        type = TouchEvent.TOUCH_MOVED;
                        break;
                    case PRESSED:
                        type = TouchEvent.TOUCH_PRESSED;
                        break;
                    case RELEASED:
                        type = TouchEvent.TOUCH_RELEASED;
                        break;
                    case STATIONARY:
                        type = TouchEvent.TOUCH_STATIONARY;
                        break;
                }

                for (TouchPoint t : touchPoints) {
                    TouchPointHelper.reset(t);
                }

                TouchEvent te = new TouchEvent(type, tp, touchList,
                        touchEventSetId, e.isShiftDown(), e.isControlDown(),
                        e.isAltDown(), e.isMetaDown());

                Event.fireEvent(tp.getTarget(), te);
            }
        }

        // process grabbing
        for (TouchPoint tp : touchPoints) {
            EventTarget grabbed = tp.getGrabbed();
            if (grabbed != null) {
                touchTargets.put(tp.getId(), grabbed);
            };

            if (grabbed == null || tp.getState() == TouchPoint.State.RELEASED) {
                touchTargets.remove(tp.getId());
            }
        }

        inMousePick = false;
    }

    /**
     * Note: The only user of this method is in unit test: PickAndContainTest.
     */
    Node test_pick(double x, double y) {
        inMousePick = true;
        PickResult result = mouseHandler.pickNode(new PickRay(x, y, 1,
                Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY));
        inMousePick = false;
        if (result != null) {
            return result.getIntersectedNode();
        }
        return null;
    }

    private PickResult pick(final double x, final double y) {
        pick(tmpTargetWrapper, x, y);
        return tmpTargetWrapper.getResult();
    }

    private boolean isInScene(double x, double y) {
        if (x &lt; 0 || y &lt; 0 || x &gt; getWidth() || y &gt; getHeight())  {
            return false;
        }

        Window w = getWindow();
        if (w instanceof Stage
                &amp;&amp; ((Stage) w).getStyle() == StageStyle.TRANSPARENT
                &amp;&amp; getFill() == null) {
            return false;
        }

        return true;
    }

    private void pick(TargetWrapper target, final double x, final double y) {
        final PickRay pickRay = getEffectiveCamera().computePickRay(
                x, y, null);

        final double mag = pickRay.getDirectionNoClone().length();
        pickRay.getDirectionNoClone().normalize();
        final PickResult res = mouseHandler.pickNode(pickRay);
        if (res != null) {
            target.setNodeResult(res);
        } else {
            //TODO: is this the intersection with projection plane?
            Vec3d o = pickRay.getOriginNoClone();
            Vec3d d = pickRay.getDirectionNoClone();
            target.setSceneResult(new PickResult(
                    null, new Point3D(
                    o.x + mag * d.x,
                    o.y + mag * d.y,
                    o.z + mag * d.z),
                    mag),
                    isInScene(x, y) ? this : null);
        }
    }

    /***************************************************************************
     *                                                                         *
     * Key Events and Focus Traversal                                          *
     *                                                                         *
     **************************************************************************/

    /*
     * We cannot initialize keyHandler in init because some of the triggers
     * access it before the init block.
     * No clue why def keyHandler = bind lazy {KeyHandler{scene:this};}
     * does not compile.
     */
    private KeyHandler keyHandler = null;
    private KeyHandler getKeyHandler() {
        if (keyHandler == null) {
            keyHandler = new KeyHandler();
        }
        return keyHandler;
    }
    /**
     * Set to true if something has happened to the focused node that makes
     * it no longer eligible to have the focus.
     *
     */
    private boolean focusDirty = true;

    final void setFocusDirty(boolean value) {
        if (!focusDirty) {
            Toolkit.getToolkit().requestNextPulse();
        }
        focusDirty = value;
    }

    final boolean isFocusDirty() {
        return focusDirty;
    }

    private TopMostTraversalEngine traversalEngine = new SceneTraversalEngine(this);

    /**
     * Traverses focus from the given node in the given direction.
     */
    boolean traverse(Node node, Direction dir) {
        if (node.getSubScene() != null) {
            return node.getSubScene().traverse(node, dir);
        }
        return traversalEngine.trav(node, dir) != null;
    }

    /**
     * Moves the focus to a reasonable initial location. Called when a scene's
     * focus is dirty and there's no current owner, or if the owner has been
     * removed from the scene.
     */
    private void focusInitial() {
        traversalEngine.traverseToFirst();
    }

    /**
     * Moves the focus to a reasonble location &quot;near&quot; the given node.
     * Called when the focused node is no longer eligible to have
     * the focus because it has become invisible or disabled. This
     * function assumes that it is still a member of the same scene.
     */
    private void focusIneligible(Node node) {
        traverse(node, Direction.NEXT);
    }

    public void processKeyEvent(KeyEvent e) {
        if (dndGesture != null) {
            if (!dndGesture.processKey(e)) {
                dndGesture = null;
            }
        }

        getKeyHandler().process(e);
    }

    void requestFocus(Node node) {
        getKeyHandler().requestFocus(node);
    }

    private Node oldFocusOwner;

    /**
      * The scene's current focus owner node. This node's &quot;focused&quot;
      * variable might be false if this scene has no window, or if the
      * window is inactive (window.focused == false).
      * @since JavaFX 2.2
      */
    private ReadOnlyObjectWrapper&lt;Node&gt; focusOwner = new ReadOnlyObjectWrapper&lt;Node&gt;(this, &quot;focusOwner&quot;) {

        @Override
        protected void invalidated() {
            if (oldFocusOwner != null) {
                ((Node.FocusedProperty) oldFocusOwner.focusedProperty()).store(false);
            }
            Node value = get();
            if (value != null) {
                ((Node.FocusedProperty) value.focusedProperty()).store(keyHandler.windowFocused);
                if (value != oldFocusOwner) {
                    value.getScene().enableInputMethodEvents(
                            value.getInputMethodRequests() != null
                            &amp;&amp; value.getOnInputMethodTextChanged() != null);
                }
            }
            // for the rest of the method we need to update the oldFocusOwner
            // and use a local copy of it because the user handlers can cause
            // recurrent calls of requestFocus
            Node localOldOwner = oldFocusOwner;
            oldFocusOwner = value;
            if (localOldOwner != null) {
                ((Node.FocusedProperty) localOldOwner.focusedProperty()).notifyListeners();
            }
            if (value != null) {
                ((Node.FocusedProperty) value.focusedProperty()).notifyListeners();
            }
            PlatformLogger logger = Logging.getFocusLogger();
            if (logger.isLoggable(Level.FINE)) {
                if (value == get()) {
                    logger.fine(&quot;Changed focus from &quot;
                            + localOldOwner + &quot; to &quot; + value);
                } else {
                    logger.fine(&quot;Changing focus from &quot;
                            + localOldOwner + &quot; to &quot; + value
                            + &quot; canceled by nested requestFocus&quot;);
                }
            }
            if (accessible != null) {
                accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
            }
        }
    };

    public final Node getFocusOwner() {
        return focusOwner.get();
    }

    public final ReadOnlyObjectProperty&lt;Node&gt; focusOwnerProperty() {
        return focusOwner.getReadOnlyProperty();
    }

    // For testing.
    void focusCleanup() {
        scenePulseListener.focusCleanup();
    }

    private void processInputMethodEvent(InputMethodEvent e) {
        Node node = getFocusOwner();
        if (node != null) {
            node.fireEvent(e);
        }
    }

    public void enableInputMethodEvents(boolean enable) {
       if (peer != null) {
           peer.enableInputMethodEvents(enable);
       }
    }

    /**
     * Returns true if this scene is quiescent, i.e. it has no activity
     * pending on it such as CSS processing or layout requests.
     *
     * Intended to be used for tests only
     *
     * @return boolean indicating whether the scene is quiescent
     */
    boolean isQuiescent() {
        final Parent r = getRoot();
        return !isFocusDirty()
               &amp;&amp; (r == null || (r.cssFlag == CssFlags.CLEAN &amp;&amp;
                r.layoutFlag == LayoutFlags.CLEAN));
    }

    /**
     * A listener for pulses, used for testing. If non-null, this is called at
     * the very end of ScenePulseListener.pulse().
     *
     * Intended to be used for tests only
     */
    Runnable testPulseListener = null;

    /**
     * Set the specified dirty bit and mark the peer as dirty
     */
    private void markDirty(DirtyBits dirtyBit) {
        setDirty(dirtyBit);
        if (peer != null) {
            Toolkit.getToolkit().requestNextPulse();
        }
    }

    /**
     * Set the specified dirty bit
     */
    private void setDirty(DirtyBits dirtyBit) {
        dirtyBits |= dirtyBit.getMask();
    }

    /**
     * Test the specified dirty bit
     */
    private boolean isDirty(DirtyBits dirtyBit) {
        return ((dirtyBits &amp; dirtyBit.getMask()) != 0);
    }

    /**
     * Test whether the dirty bits are empty
     */
    private boolean isDirtyEmpty() {
        return dirtyBits == 0;
    }

    /**
     * Clear all dirty bits
     */
    private void clearDirty() {
        dirtyBits = 0;
    }

    private enum DirtyBits {
        FILL_DIRTY,
        ROOT_DIRTY,
        CAMERA_DIRTY,
        LIGHTS_DIRTY,
        CURSOR_DIRTY;

        private int mask;

        private DirtyBits() {
            mask = 1 &lt;&lt; ordinal();
        }

        public final int getMask() { return mask; }
    }

    private List&lt;LightBase&gt; lights = new ArrayList&lt;&gt;();

    // @param light must not be null
    final void addLight(LightBase light) {
        if (!lights.contains(light)) {
            lights.add(light);
            markDirty(DirtyBits.LIGHTS_DIRTY);
        }
    }

    final void removeLight(LightBase light) {
        if (lights.remove(light)) {
            markDirty(DirtyBits.LIGHTS_DIRTY);
        }
    }

    /**
     * PG Light synchronizer.
     */
    private void syncLights() {
        if (!isDirty(DirtyBits.LIGHTS_DIRTY)) {
            return;
        }
        inSynchronizer = true;
        NGLightBase peerLights[] = peer.getLights();
        if (!lights.isEmpty() || (peerLights != null)) {
            if (lights.isEmpty()) {
                peer.setLights(null);
            } else {
                if (peerLights == null || peerLights.length &lt; lights.size()) {
                    peerLights = new NGLightBase[lights.size()];
                }
                int i = 0;
                for (; i &lt; lights.size(); i++) {
                    peerLights[i] = lights.get(i).getPeer();
                }
                // Clear the rest of the list
                while (i &lt; peerLights.length &amp;&amp; peerLights[i] != null) {
                    peerLights[i++] = null;
                }
                peer.setLights(peerLights);
            }
        }
        inSynchronizer = false;
    }

    //INNER CLASSES

    /*******************************************************************************
     *                                                                             *
     * Scene Pulse Listener                                                        *
     *                                                                             *
     ******************************************************************************/

    class ScenePulseListener implements TKPulseListener {

        private boolean firstPulse = true;

        /**
         * PG synchronizer. Called once per frame from the pulse listener.
         * This function calls the synchronizePGNode method on each node in
         * the dirty list.
         */
        private void synchronizeSceneNodes() {
            Toolkit.getToolkit().checkFxUserThread();

            Scene.inSynchronizer = true;

            // if dirtyNodes is null then that means this Scene has not yet been
            // synchronized, and so we will simply synchronize every node in the
            // scene and then create the dirty nodes array list
            if (Scene.this.dirtyNodes == null) {
                // must do this recursively
                syncAll(getRoot());
                dirtyNodes = new Node[MIN_DIRTY_CAPACITY];

            } else {
                // This is not the first time this scene has been synchronized,
                // so we will only synchronize those nodes that need it
                for (int i = 0 ; i &lt; dirtyNodesSize; ++i) {
                    Node node = dirtyNodes[i];
                    dirtyNodes[i] = null;
                    if (node.getScene() == Scene.this) {
                            node.syncPeer();
                        }
                    }
                dirtyNodesSize = 0;
            }

            Scene.inSynchronizer = false;
        }

        /**
         * Recursive function for synchronizing every node in the scenegraph.
         * The return value is the number of nodes in the graph.
         */
        private int syncAll(Node node) {
            node.syncPeer();
            int size = 1;
            if (node instanceof Parent) {
                Parent p = (Parent) node;
                final int childrenCount = p.getChildren().size();

                for (int i = 0; i &lt; childrenCount; i++) {
                    Node n = p.getChildren().get(i);
                    if (n != null) {
                        size += syncAll(n);
                    }
                }
            } else if (node instanceof SubScene) {
                SubScene subScene = (SubScene)node;
                size += syncAll(subScene.getRoot());
            }
            if (node.getClip() != null) {
                size += syncAll(node.getClip());
            }

            return size;
        }

        private void synchronizeSceneProperties() {
            inSynchronizer = true;
            if (isDirty(DirtyBits.ROOT_DIRTY)) {
                peer.setRoot(getRoot().getPeer());
            }

            if (isDirty(DirtyBits.FILL_DIRTY)) {
                Toolkit tk = Toolkit.getToolkit();
                peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
            }

            // new camera was set on the scene or old camera changed
            final Camera cam = getEffectiveCamera();
            if (isDirty(DirtyBits.CAMERA_DIRTY)) {
                NodeHelper.updatePeer(cam);
                peer.setCamera((NGCamera) cam.getPeer());
            }

            if (isDirty(DirtyBits.CURSOR_DIRTY)) {
                mouseHandler.updateCursor(getCursor());
                mouseHandler.updateCursorFrame();
            }

            clearDirty();
            inSynchronizer = false;
        }

        /**
         * The focus is considered dirty if something happened to
         * the scene graph that may require the focus to be moved.
         * This must handle cases where (a) the focus owner may have
         * become ineligible to have the focus, and (b) where the focus
         * owner is null and a node may have become traversable and eligible.
         */
        private void focusCleanup() {
            if (Scene.this.isFocusDirty()) {
                final Node oldOwner = Scene.this.getFocusOwner();
                if (oldOwner == null) {
                    Scene.this.focusInitial();
                } else if (oldOwner.getScene() != Scene.this) {
                    Scene.this.requestFocus(null);
                    Scene.this.focusInitial();
                } else if (!oldOwner.isCanReceiveFocus()) {
                    Scene.this.requestFocus(null);
                    Scene.this.focusIneligible(oldOwner);
                }
                Scene.this.setFocusDirty(false);
            }
        }

        @Override
        public void pulse() {
            if (Scene.this.tracker != null) {
                Scene.this.tracker.pulse();
            }
            if (firstPulse) {
                PerformanceTracker.logEvent(&quot;Scene - first repaint&quot;);
            }

            focusCleanup();

            disposeAccessibles();

            // run any scene pre pulse listeners immediately _before_ css / layout,
            // and before scene synchronization
            if (preLayoutPulseListeners != null) {
                for (Runnable r : preLayoutPulseListeners) {
                    r.run();
                }
            }

            if (PULSE_LOGGING_ENABLED) {
                PulseLogger.newPhase(&quot;CSS Pass&quot;);
            }
            Scene.this.doCSSPass();

            if (PULSE_LOGGING_ENABLED) {
                PulseLogger.newPhase(&quot;Layout Pass&quot;);
            }
            Scene.this.doLayoutPass();

            // run any scene post pulse listeners immediately _after_ css / layout,
            // and before scene synchronization
            if (postLayoutPulseListeners != null) {
                for (Runnable r : postLayoutPulseListeners) {
                    r.run();
                }
            }

            boolean dirty = dirtyNodes == null || dirtyNodesSize != 0 || !isDirtyEmpty();
            if (dirty) {
                if (PULSE_LOGGING_ENABLED) {
                    PulseLogger.newPhase(&quot;Update bounds&quot;);
                }
                getRoot().updateBounds();
                if (peer != null) {
                    try {
                        if (PULSE_LOGGING_ENABLED) {
                            PulseLogger.newPhase(&quot;Waiting for previous rendering&quot;);
                        }
                        peer.waitForRenderingToComplete();
                        peer.waitForSynchronization();
                        // synchronize scene properties
                        if (PULSE_LOGGING_ENABLED) {
                            PulseLogger.newPhase(&quot;Copy state to render graph&quot;);
                        }
                        syncLights();
                        synchronizeSceneProperties();
                        // Run the synchronizer
                        synchronizeSceneNodes();
                        Scene.this.mouseHandler.pulse();
                        // Tell the scene peer that it needs to repaint
                        peer.markDirty();
                    } finally {
                        peer.releaseSynchronization(true);
                    }
                } else {
                    if (PULSE_LOGGING_ENABLED) {
                        PulseLogger.newPhase(&quot;Synchronize with null peer&quot;);
                    }
                    synchronizeSceneNodes();
                    Scene.this.mouseHandler.pulse();
                }

                if (Scene.this.getRoot().cssFlag != CssFlags.CLEAN) {
                    NodeHelper.markDirty(Scene.this.getRoot(),
                            com.sun.javafx.scene.DirtyBits.NODE_CSS);
                }
            }

            // required for image cursor created from animated image
            Scene.this.mouseHandler.updateCursorFrame();

            if (firstPulse) {
                if (PerformanceTracker.isLoggingEnabled()) {
                    PerformanceTracker.logEvent(&quot;Scene - first repaint - layout complete&quot;);
                    if (PrismSettings.perfLogFirstPaintFlush) {
                        PerformanceTracker.outputLog();
                    }
                    if (PrismSettings.perfLogFirstPaintExit) {
                        System.exit(0);
                    }
                }
                firstPulse = false;
            }

            if (testPulseListener != null) {
                testPulseListener.run();
            }
        }
    }

    /*******************************************************************************
     *                                                                             *
     * Scene Peer Listener                                                         *
     *                                                                             *
     ******************************************************************************/

    class ScenePeerListener implements TKSceneListener {
        @Override
        public void changedLocation(float x, float y) {
            if (x != Scene.this.getX()) {
                Scene.this.setX(x);
            }
            if (y != Scene.this.getY()) {
                Scene.this.setY(y);
            }
        }

        @Override
        public void changedSize(float w, float h) {
            if (w != Scene.this.getWidth()) Scene.this.setWidth(w);
            if (h != Scene.this.getHeight()) Scene.this.setHeight(h);
        }

        @Override
        public void mouseEvent(EventType&lt;MouseEvent&gt; type, double x, double y, double screenX, double screenY,
                               MouseButton button, boolean popupTrigger, boolean synthesized,
                               boolean shiftDown, boolean controlDown, boolean altDown, boolean metaDown,
                               boolean primaryDown, boolean middleDown, boolean secondaryDown)
        {
            MouseEvent mouseEvent = new MouseEvent(type, x, y, screenX, screenY, button,
                    0, // click count will be adjusted by clickGenerator later anyway
                    shiftDown, controlDown, altDown, metaDown,
                    primaryDown, middleDown, secondaryDown, synthesized, popupTrigger, false, null);
            processMouseEvent(mouseEvent);
        }


        @Override
        public void keyEvent(KeyEvent keyEvent)
        {
            processKeyEvent(keyEvent);
        }

        @Override
        public void inputMethodEvent(EventType&lt;InputMethodEvent&gt; type,
                                     ObservableList&lt;InputMethodTextRun&gt; composed, String committed,
                                     int caretPosition)
        {
            InputMethodEvent inputMethodEvent = new InputMethodEvent(
               type, composed, committed, caretPosition);
            processInputMethodEvent(inputMethodEvent);
        }

        public void menuEvent(double x, double y, double xAbs, double yAbs,
                boolean isKeyboardTrigger) {
            Scene.this.processMenuEvent(x, y, xAbs,yAbs, isKeyboardTrigger);
        }

        @Override
        public void scrollEvent(
                EventType&lt;ScrollEvent&gt; eventType,
                double scrollX, double scrollY,
                double totalScrollX, double totalScrollY,
                double xMultiplier, double yMultiplier,
                int touchCount,
                int scrollTextX, int scrollTextY,
                int defaultTextX, int defaultTextY,
                double x, double y, double screenX, double screenY,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown,
                boolean _direct, boolean _inertia) {

            ScrollEvent.HorizontalTextScrollUnits xUnits = scrollTextX &gt; 0 ?
                    ScrollEvent.HorizontalTextScrollUnits.CHARACTERS :
                    ScrollEvent.HorizontalTextScrollUnits.NONE;

            double xText = scrollTextX &lt; 0 ? 0 : scrollTextX * scrollX;

            ScrollEvent.VerticalTextScrollUnits yUnits = scrollTextY &gt; 0 ?
                    ScrollEvent.VerticalTextScrollUnits.LINES :
                    (scrollTextY &lt; 0 ?
                        ScrollEvent.VerticalTextScrollUnits.PAGES :
                        ScrollEvent.VerticalTextScrollUnits.NONE);

            double yText = scrollTextY &lt; 0 ? scrollY : scrollTextY * scrollY;

            xMultiplier = defaultTextX &gt; 0 &amp;&amp; scrollTextX &gt;= 0
                    ? Math.round(xMultiplier * scrollTextX / defaultTextX)
                    : xMultiplier;

            yMultiplier = defaultTextY &gt; 0 &amp;&amp; scrollTextY &gt;= 0
                    ? Math.round(yMultiplier * scrollTextY / defaultTextY)
                    : yMultiplier;

            if (eventType == ScrollEvent.SCROLL_FINISHED) {
                x = scrollGesture.sceneCoords.getX();
                y = scrollGesture.sceneCoords.getY();
                screenX = scrollGesture.screenCoords.getX();
                screenY = scrollGesture.screenCoords.getY();
            } else if (Double.isNaN(x) || Double.isNaN(y) ||
                    Double.isNaN(screenX) || Double.isNaN(screenY)) {
                if (cursorScenePos == null || cursorScreenPos == null) {
                    return;
                }
                x = cursorScenePos.getX();
                y = cursorScenePos.getY();
                screenX = cursorScreenPos.getX();
                screenY = cursorScreenPos.getY();
            }

            inMousePick = true;
            Scene.this.processGestureEvent(new ScrollEvent(
                    eventType,
                    x, y, screenX, screenY,
                    _shiftDown, _controlDown, _altDown, _metaDown,
                    _direct, _inertia,
                    scrollX * xMultiplier, scrollY * yMultiplier,
                    totalScrollX * xMultiplier, totalScrollY * yMultiplier,
                    xMultiplier, yMultiplier,
                    xUnits, xText, yUnits, yText, touchCount, pick(x, y)),
                    scrollGesture);
            inMousePick = false;
        }

        @Override
        public void zoomEvent(
                EventType&lt;ZoomEvent&gt; eventType,
                double zoomFactor, double totalZoomFactor,
                double x, double y, double screenX, double screenY,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown,
                boolean _direct, boolean _inertia) {

            if (eventType == ZoomEvent.ZOOM_FINISHED) {
                x = zoomGesture.sceneCoords.getX();
                y = zoomGesture.sceneCoords.getY();
                screenX = zoomGesture.screenCoords.getX();
                screenY = zoomGesture.screenCoords.getY();
            } else if (Double.isNaN(x) || Double.isNaN(y) ||
                    Double.isNaN(screenX) || Double.isNaN(screenY)) {
                if (cursorScenePos == null || cursorScreenPos == null) {
                    return;
                }
                x = cursorScenePos.getX();
                y = cursorScenePos.getY();
                screenX = cursorScreenPos.getX();
                screenY = cursorScreenPos.getY();
            }

            inMousePick = true;
            Scene.this.processGestureEvent(new ZoomEvent(eventType,
                    x, y, screenX, screenY,
                    _shiftDown, _controlDown, _altDown, _metaDown,
                    _direct, _inertia,
                    zoomFactor, totalZoomFactor, pick(x, y)),
                    zoomGesture);
            inMousePick = false;
        }

        @Override
        public void rotateEvent(
                EventType&lt;RotateEvent&gt; eventType, double angle, double totalAngle,
                double x, double y, double screenX, double screenY,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown,
                boolean _direct, boolean _inertia) {

            if (eventType == RotateEvent.ROTATION_FINISHED) {
                x = rotateGesture.sceneCoords.getX();
                y = rotateGesture.sceneCoords.getY();
                screenX = rotateGesture.screenCoords.getX();
                screenY = rotateGesture.screenCoords.getY();
            } else if (Double.isNaN(x) || Double.isNaN(y) ||
                    Double.isNaN(screenX) || Double.isNaN(screenY)) {
                if (cursorScenePos == null || cursorScreenPos == null) {
                    return;
                }
                x = cursorScenePos.getX();
                y = cursorScenePos.getY();
                screenX = cursorScreenPos.getX();
                screenY = cursorScreenPos.getY();
            }

            inMousePick = true;
            Scene.this.processGestureEvent(new RotateEvent(
                    eventType, x, y, screenX, screenY,
                    _shiftDown, _controlDown, _altDown, _metaDown,
                    _direct, _inertia, angle, totalAngle, pick(x, y)),
                    rotateGesture);
            inMousePick = false;

        }

        @Override
        public void swipeEvent(
                EventType&lt;SwipeEvent&gt; eventType, int touchCount,
                double x, double y, double screenX, double screenY,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown, boolean _direct) {

            if (Double.isNaN(x) || Double.isNaN(y) ||
                    Double.isNaN(screenX) || Double.isNaN(screenY)) {
                if (cursorScenePos == null || cursorScreenPos == null) {
                    return;
                }
                x = cursorScenePos.getX();
                y = cursorScenePos.getY();
                screenX = cursorScreenPos.getX();
                screenY = cursorScreenPos.getY();
            }

            inMousePick = true;
            Scene.this.processGestureEvent(new SwipeEvent(
                    eventType, x, y, screenX, screenY,
                    _shiftDown, _controlDown, _altDown, _metaDown, _direct,
                    touchCount, pick(x, y)),
                    swipeGesture);
            inMousePick = false;
        }

        @Override
        public void touchEventBegin(
                long time, int touchCount, boolean isDirect,
                boolean _shiftDown, boolean _controlDown,
                boolean _altDown, boolean _metaDown) {

            if (!isDirect) {
                nextTouchEvent = null;
                return;
            }
            nextTouchEvent = new TouchEvent(
                    TouchEvent.ANY, null, null, 0,
                    _shiftDown, _controlDown, _altDown, _metaDown);
            if (touchPoints == null || touchPoints.length != touchCount) {
                touchPoints = new TouchPoint[touchCount];
            }
            touchPointIndex = 0;
        }

        @Override
        public void touchEventNext(
                TouchPoint.State state, long touchId,
                double x, double y, double screenX, double screenY) {

            inMousePick = true;
            if (nextTouchEvent == null) {
                // ignore indirect touch events
                return;
            }
            touchPointIndex++;
            int id = (state == TouchPoint.State.PRESSED
                    ? touchMap.add(touchId) :  touchMap.get(touchId));
            if (state == TouchPoint.State.RELEASED) {
                touchMap.remove(touchId);
            }
            int order = touchMap.getOrder(id);

            if (order &gt;= touchPoints.length) {
                throw new RuntimeException(&quot;Too many touch points reported&quot;);
            }

            // pick target
            boolean isGrabbed = false;
            PickResult pickRes = pick(x, y);
            EventTarget pickedTarget = touchTargets.get(id);
            if (pickedTarget == null) {
                pickedTarget = pickRes.getIntersectedNode();
                if (pickedTarget == null) {
                    pickedTarget = Scene.this;
                }
            } else {
                isGrabbed = true;
            }

            TouchPoint tp = new TouchPoint(id, state,
                    x, y, screenX, screenY, pickedTarget, pickRes);

            touchPoints[order] = tp;

            if (isGrabbed) {
                tp.grab(pickedTarget);
            }
            if (tp.getState() == TouchPoint.State.PRESSED) {
                tp.grab(pickedTarget);
                touchTargets.put(tp.getId(), pickedTarget);
            } else if (tp.getState() == TouchPoint.State.RELEASED) {
                touchTargets.remove(tp.getId());
            }
            inMousePick = false;
        }

        @Override
        public void touchEventEnd() {
            if (nextTouchEvent == null) {
                // ignore indirect touch events
                return;
            }

            if (touchPointIndex != touchPoints.length) {
                throw new RuntimeException(&quot;Wrong number of touch points reported&quot;);
            }

            Scene.this.processTouchEvent(nextTouchEvent, touchPoints);

            if (touchMap.cleanup()) {
                // gesture finished
                touchEventSetId = 0;
            }
        }

        @Override
        public Accessible getSceneAccessible() {
            return getAccessible();
        }
    }

    private class ScenePeerPaintListener implements TKScenePaintListener {
        @Override
        public void frameRendered() {
            // must use tracker with synchronization since this method is called on render thread
            synchronized (trackerMonitor) {
                if (Scene.this.tracker != null) {
                    Scene.this.tracker.frameRendered();
                }
            }
        }
    }

    /*******************************************************************************
     *                                                                             *
     * Drag and Drop                                                               *
     *                                                                             *
     ******************************************************************************/

    class DropTargetListener implements TKDropTargetListener {

        /*
         * This function is called when an drag operation enters a valid drop target.
         * This may be from either an internal or external dnd operation.
         */
        @Override
        public TransferMode dragEnter(double x, double y, double screenX, double screenY,
                                      TransferMode transferMode, TKClipboard dragboard)
        {
            if (dndGesture == null) {
                dndGesture = new DnDGesture();
            }
            Dragboard db = DragboardHelper.createDragboard(dragboard);
            dndGesture.dragboard = db;
            DragEvent dragEvent =
                    new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                            transferMode, null, null, pick(x, y));
            return dndGesture.processTargetEnterOver(dragEvent);
        }

        @Override
        public TransferMode dragOver(double x, double y, double screenX, double screenY,
                                     TransferMode transferMode)
        {
            if (Scene.this.dndGesture == null) {
                System.err.println(&quot;GOT A dragOver when dndGesture is null!&quot;);
                return null;
            } else {
                if (dndGesture.dragboard == null) {
                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragOver&quot;);
                }
                DragEvent dragEvent =
                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                                transferMode, null, null, pick(x, y));
                return dndGesture.processTargetEnterOver(dragEvent);
            }
        }

        @Override
        public void dragExit(double x, double y, double screenX, double screenY) {
            if (dndGesture == null) {
                System.err.println(&quot;GOT A dragExit when dndGesture is null!&quot;);
            } else {
                if (dndGesture.dragboard == null) {
                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragExit&quot;);
                }
                DragEvent dragEvent =
                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                                null, null, null, pick(x, y));
                dndGesture.processTargetExit(dragEvent);
                if (dndGesture.source == null) {
                    dndGesture.dragboard = null;
                    dndGesture = null;
                }
            }
        }


        @Override
        public TransferMode drop(double x, double y, double screenX, double screenY,
                                  TransferMode transferMode)
        {
            if (dndGesture == null) {
                System.err.println(&quot;GOT A drop when dndGesture is null!&quot;);
                return null;
            } else {
                if (dndGesture.dragboard == null) {
                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDrop&quot;);
                }
                DragEvent dragEvent =
                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                                transferMode, null, null, pick(x, y));
                // Data dropped to the app can be accessed without restriction
                DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);

                TransferMode tm;
                try {
                    tm = dndGesture.processTargetDrop(dragEvent);
                } finally {
                    DragboardHelper.setDataAccessRestriction(
                            dndGesture.dragboard, true);
                }

                if (dndGesture.source == null) {
                    dndGesture.dragboard = null;
                    dndGesture = null;
                }
                return tm;
            }
        }
    }

    class DragGestureListener implements TKDragGestureListener {

       @Override
       public void dragGestureRecognized(double x, double y, double screenX, double screenY,
                                         int button, TKClipboard dragboard)
       {
           Dragboard db = DragboardHelper.createDragboard(dragboard);
           dndGesture = new DnDGesture();
           dndGesture.dragboard = db;
           // TODO: support mouse buttons in DragEvent
           DragEvent dragEvent = new DragEvent(DragEvent.ANY, db, x, y, screenX, screenY,
                   null, null, null, pick(x, y));
           dndGesture.processRecognized(dragEvent);
           dndGesture = null;
        }
    }

    /**
     * A Drag and Drop gesture has a lifespan that lasts from mouse
     * PRESSED event to mouse RELEASED event.
     */
    class DnDGesture {
        private final double hysteresisSizeX =
                Toolkit.getToolkit().getMultiClickMaxX();
        private final double hysteresisSizeY =
                Toolkit.getToolkit().getMultiClickMaxY();

        private EventTarget source = null;
        private Set&lt;TransferMode&gt; sourceTransferModes = null;
        private TransferMode acceptedTransferMode = null;
        private Dragboard dragboard = null;
        private EventTarget potentialTarget = null;
        private EventTarget target = null;
        private DragDetectedState dragDetected = DragDetectedState.NOT_YET;
        private double pressedX;
        private double pressedY;
        private List&lt;EventTarget&gt; currentTargets = new ArrayList&lt;EventTarget&gt;();
        private List&lt;EventTarget&gt; newTargets = new ArrayList&lt;EventTarget&gt;();
        private EventTarget fullPDRSource = null;

        /**
         * Fires event on a given target or on scene if the node is null
         */
        private void fireEvent(EventTarget target, Event e) {
            if (target != null) {
                Event.fireEvent(target, e);
            }
        }

        /**
         * Called when DRAG_DETECTED event is going to be processed by
         * application
         */
        private void processingDragDetected() {
            dragDetected = DragDetectedState.PROCESSING;
        }

        /**
         * Called after DRAG_DETECTED event has been processed by application
         */
        private void dragDetectedProcessed() {
            dragDetected = DragDetectedState.DONE;
            final boolean hasContent = (dragboard != null) &amp;&amp; (ClipboardHelper.contentPut(dragboard));
            if (hasContent) {
                /* start DnD */
                Toolkit.getToolkit().startDrag(Scene.this.peer,
                                                sourceTransferModes,
                                                new DragSourceListener(),
                                                dragboard);
            } else if (fullPDRSource != null) {
                /* start PDR */
                Scene.this.mouseHandler.enterFullPDR(fullPDRSource);
            }

            fullPDRSource = null;
        }

        /**
         * Sets the default dragDetect value
         */
        private void processDragDetection(MouseEvent mouseEvent) {

            if (dragDetected != DragDetectedState.NOT_YET) {
                mouseEvent.setDragDetect(false);
                return;
            }

            if (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED) {
                pressedX = mouseEvent.getSceneX();
                pressedY = mouseEvent.getSceneY();

                mouseEvent.setDragDetect(false);

            } else if (mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) {

                double deltaX = Math.abs(mouseEvent.getSceneX() - pressedX);
                double deltaY = Math.abs(mouseEvent.getSceneY() - pressedY);
                mouseEvent.setDragDetect(deltaX &gt; hysteresisSizeX ||
                                         deltaY &gt; hysteresisSizeY);

            }
        }

        /**
         * This function is useful for drag gesture recognition from
         * within this Scene (as opposed to in the TK implementation... by the platform)
         */
        private boolean process(MouseEvent mouseEvent, EventTarget target) {
            boolean continueProcessing = true;
            if (!PLATFORM_DRAG_GESTURE_INITIATION) {

                if (dragDetected != DragDetectedState.DONE &amp;&amp;
                        (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED ||
                        mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) &amp;&amp;
                        mouseEvent.isDragDetect()) {

                    processingDragDetected();

                    if (target != null) {
                        final MouseEvent detectedEvent = mouseEvent.copyFor(
                                mouseEvent.getSource(), target,
                                MouseEvent.DRAG_DETECTED);

                        try {
                            fireEvent(target, detectedEvent);
                        } finally {
                            // Putting data to dragboard finished, restrict access to them
                            if (dragboard != null) {
                                DragboardHelper.setDataAccessRestriction(
                                        dragboard, true);
                            }
                        }
                    }

                    dragDetectedProcessed();
                }

                if (mouseEvent.getEventType() == MouseEvent.MOUSE_RELEASED) {
                    continueProcessing = false;
                }
            }
            return continueProcessing;
        }

        /*
         * Called when a drag source is recognized. This occurs at the very start of
         * the publicly visible drag and drop API, as it is responsible for calling
         * the Node.onDragSourceRecognized function.
         */
        private boolean processRecognized(DragEvent de) {
            MouseEvent me = new MouseEvent(
                    MouseEvent.DRAG_DETECTED, de.getX(), de.getY(),
                    de.getSceneX(), de.getScreenY(), MouseButton.PRIMARY, 1,
                    false, false, false, false, false, true, false, false, false,
                    false, de.getPickResult());

            processingDragDetected();

            final EventTarget target = de.getPickResult().getIntersectedNode();
            try {
                fireEvent(target != null ? target : Scene.this, me);
            } finally {
                // Putting data to dragboard finished, restrict access to them
                if (dragboard != null) {
                    DragboardHelper.setDataAccessRestriction(
                            dragboard, true);
                }
            }

            dragDetectedProcessed();

            final boolean hasContent = dragboard != null
                    &amp;&amp; !dragboard.getContentTypes().isEmpty();
            return hasContent;
        }

        private void processDropEnd(DragEvent de) {
            if (source == null) {
                System.out.println(&quot;Scene.DnDGesture.processDropEnd() - UNEXPECTD - source is NULL&quot;);
                return;
            }

            de = new DragEvent(de.getSource(), source, DragEvent.DRAG_DONE,
                    de.getDragboard(), de.getSceneX(), de.getSceneY(),
                    de.getScreenX(), de.getScreenY(),
                    de.getTransferMode(), source, target, de.getPickResult());

            Event.fireEvent(source, de);

            tmpTargetWrapper.clear();
            handleExitEnter(de, tmpTargetWrapper);

            // at this point the drag and drop operation is completely over, so we
            // can tell the toolkit that it can clean up if needs be.
            Toolkit.getToolkit().stopDrag(dragboard);
        }

        private TransferMode processTargetEnterOver(DragEvent de) {
            pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
            final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();

            if (dragboard == null) {
                dragboard = createDragboard(de, false);
            }

            de = new DragEvent(de.getSource(), pickedTarget, de.getEventType(),
                    dragboard, de.getSceneX(), de.getSceneY(),
                    de.getScreenX(), de.getScreenY(),
                    de.getTransferMode(), source, potentialTarget, de.getPickResult());

            handleExitEnter(de, tmpTargetWrapper);

            de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_OVER,
                    de.getDragboard(), de.getSceneX(), de.getSceneY(),
                    de.getScreenX(), de.getScreenY(),
                    de.getTransferMode(), source, potentialTarget, de.getPickResult());

            fireEvent(pickedTarget, de);

            Object acceptingObject = de.getAcceptingObject();
            potentialTarget = acceptingObject instanceof EventTarget
                    ? (EventTarget) acceptingObject : null;
            acceptedTransferMode = de.getAcceptedTransferMode();
            return acceptedTransferMode;
        }

        private void processTargetActionChanged(DragEvent de) {
            // Do we want DRAG_TRANSFER_MODE_CHANGED event?
//            final Node pickedNode = Scene.this.mouseHandler.pickNode(de.getX(), de.getY());
//            if (pickedNode != null &amp;&amp; pickedNode.isTreeVisible()) {
//                de = DragEvent.copy(de.getSource(), pickedNode, source,
//                        pickedNode, de, DragEvent.DRAG_TRANSFER_MODE_CHANGED);
//
//                if (dragboard == null) {
//                    dragboard = createDragboard(de);
//                }
//                dragboard = de.getPlatformDragboard();
//
//                fireEvent(pickedNode, de);
//            }
        }

        private void processTargetExit(DragEvent de) {
            if (dragboard == null) {
                // dragboard should have been created in processTargetEnterOver()
                throw new NullPointerException(&quot;dragboard is null in processTargetExit()&quot;);
            }

            if (currentTargets.size() &gt; 0) {
                potentialTarget = null;
                tmpTargetWrapper.clear();
                handleExitEnter(de, tmpTargetWrapper);
            }
        }

        private TransferMode processTargetDrop(DragEvent de) {
            pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
            final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();

            de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_DROPPED,
                    de.getDragboard(), de.getSceneX(), de.getSceneY(),
                    de.getScreenX(), de.getScreenY(),
                    acceptedTransferMode, source, potentialTarget, de.getPickResult());

            if (dragboard == null) {
                // dragboard should have been created in processTargetEnterOver()
                throw new NullPointerException(&quot;dragboard is null in processTargetDrop()&quot;);
            }

            handleExitEnter(de, tmpTargetWrapper);

            fireEvent(pickedTarget, de);

            Object acceptingObject = de.getAcceptingObject();
            potentialTarget = acceptingObject instanceof EventTarget
                    ? (EventTarget) acceptingObject : null;
            target = potentialTarget;

            TransferMode result = de.isDropCompleted() ?
                de.getAcceptedTransferMode() : null;

            tmpTargetWrapper.clear();
            handleExitEnter(de, tmpTargetWrapper);

            return result;
        }

        private void handleExitEnter(DragEvent e, TargetWrapper target) {
            EventTarget currentTarget =
                    currentTargets.size() &gt; 0 ? currentTargets.get(0) : null;

            if (target.getEventTarget() != currentTarget) {

                target.fillHierarchy(newTargets);

                int i = currentTargets.size() - 1;
                int j = newTargets.size() - 1;

                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentTargets.get(i) == newTargets.get(j)) {
                    i--;
                    j--;
                }

                for (; i &gt;= 0; i--) {
                    EventTarget t = currentTargets.get(i);
                    if (potentialTarget == t) {
                        potentialTarget = null;
                    }
                    e = e.copyFor(e.getSource(), t, source,
                            potentialTarget, DragEvent.DRAG_EXITED_TARGET);
                    Event.fireEvent(t, e);
                }

                potentialTarget = null;
                for (; j &gt;= 0; j--) {
                    EventTarget t = newTargets.get(j);
                    e = e.copyFor(e.getSource(), t, source,
                            potentialTarget, DragEvent.DRAG_ENTERED_TARGET);
                    Object acceptingObject = e.getAcceptingObject();
                    if (acceptingObject instanceof EventTarget) {
                        potentialTarget = (EventTarget) acceptingObject;
                    }
                    Event.fireEvent(t, e);
                }

                currentTargets.clear();
                currentTargets.addAll(newTargets);
                newTargets.clear();
            }
        }

//        function getIntendedTransferMode(e:MouseEvent):TransferMode {
//            return if (e.altDown) TransferMode.COPY else TransferMode.MOVE;
//        }

        /*
         * Function that hooks into the key processing code in Scene to handle the
         * situation where a drag and drop event is taking place and the user presses
         * the escape key to cancel the drag and drop operation.
         */
        private boolean processKey(KeyEvent e) {
            //note: this seems not to be called, the DnD cancelation is provided by platform
            if ((e.getEventType() == KeyEvent.KEY_PRESSED) &amp;&amp; (e.getCode() == KeyCode.ESCAPE)) {

                // cancel drag and drop
                DragEvent de = new DragEvent(
                        source, source, DragEvent.DRAG_DONE, dragboard, 0, 0, 0, 0,
                        null, source, null, null);
                if (source != null) {
                    Event.fireEvent(source, de);
                }

                tmpTargetWrapper.clear();
                handleExitEnter(de, tmpTargetWrapper);

                return false;
            }
            return true;
        }

        /*
         * This starts the drag gesture running, creating the dragboard used for
         * the remainder of this drag and drop operation.
         */
        private Dragboard startDrag(EventTarget source, Set&lt;TransferMode&gt; t) {
            if (dragDetected != DragDetectedState.PROCESSING) {
                throw new IllegalStateException(&quot;Cannot start drag and drop &quot;
                        + &quot;outside of DRAG_DETECTED event handler&quot;);
            }

            if (t.isEmpty()) {
                dragboard = null;
            } else if (dragboard == null) {
                dragboard = createDragboard(null, true);
            }

            // The app can see what it puts to dragboard without restriction
            DragboardHelper.setDataAccessRestriction(dragboard, false);

            this.source = source;
            potentialTarget = source;
            sourceTransferModes = t;
            return dragboard;
        }

        /*
         * This starts the full PDR gesture.
         */
        private void startFullPDR(EventTarget source) {
            fullPDRSource = source;
        }

        private Dragboard createDragboard(final DragEvent de, boolean isDragSource) {
            Dragboard dragboard = null;
            if (de != null) {
                dragboard = de.getDragboard();
                if (dragboard != null) {
                    return dragboard;
                }
            }
            TKClipboard dragboardPeer = peer.createDragboard(isDragSource);
            return DragboardHelper.createDragboard(dragboardPeer);
        }
    }

    /**
     * State of a drag gesture with regards to DRAG_DETECTED event.
     */
    private enum DragDetectedState {
        NOT_YET,
        PROCESSING,
        DONE
    }

    class DragSourceListener implements TKDragSourceListener {

        @Override
        public void dragDropEnd(double x, double y, double screenX, double screenY,
                                TransferMode transferMode)
        {
            if (dndGesture != null) {
                if (dndGesture.dragboard == null) {
                    throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDropEnd&quot;);
                }
                DragEvent dragEvent =
                        new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
                        transferMode, null, null, null);

                // DRAG_DONE event is delivered to gesture source, it can access
                // its own data without restriction
                DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);
                try {
                    dndGesture.processDropEnd(dragEvent);
                } finally {
                    DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, true);
                }
                dndGesture = null;
            }
        }
    }

    /*******************************************************************************
     *                                                                             *
     * Mouse Event Handling                                                        *
     *                                                                             *
     ******************************************************************************/

    static class ClickCounter {
        Toolkit toolkit = Toolkit.getToolkit();
        private int count;
        private boolean out;
        private boolean still;
        private Timeline timeout;
        private double pressedX, pressedY;

        private void inc() { count++; }
        private int get() { return count; }
        private boolean isStill() { return still; }

        private void clear() {
            count = 0;
            stopTimeout();
        }

        private void out() {
            out = true;
            stopTimeout();
        }

        private void applyOut() {
            if (out) clear();
            out = false;
        }

        private void moved(double x, double y) {
            if (Math.abs(x - pressedX) &gt; toolkit.getMultiClickMaxX() ||
                    Math.abs(y - pressedY) &gt; toolkit.getMultiClickMaxY()) {
                out();
                still = false;
            }
        }

        private void start(double x, double y) {
            pressedX = x;
            pressedY = y;
            out = false;

            if (timeout != null) {
                timeout.stop();
            }
            timeout = new Timeline();
            timeout.getKeyFrames().add(
                    new KeyFrame(new Duration(toolkit.getMultiClickTime()),
                            event -&gt; {
                                out = true;
                                timeout = null;
                            }
                    ));
            timeout.play();
            still = true;
        }

        private void stopTimeout() {
            if (timeout != null) {
                timeout.stop();
                timeout = null;
            }
        }
    }

    static class ClickGenerator {
        private ClickCounter lastPress = null;

        private Map&lt;MouseButton, ClickCounter&gt; counters =
                new EnumMap&lt;MouseButton, ClickCounter&gt;(MouseButton.class);
        private List&lt;EventTarget&gt; pressedTargets = new ArrayList&lt;EventTarget&gt;();
        private List&lt;EventTarget&gt; releasedTargets = new ArrayList&lt;EventTarget&gt;();

        public ClickGenerator() {
            for (MouseButton mb : MouseButton.values()) {
                if (mb != MouseButton.NONE) {
                    counters.put(mb, new ClickCounter());
                }
            }
        }

        private MouseEvent preProcess(MouseEvent e) {
            for (ClickCounter cc : counters.values()) {
                cc.moved(e.getSceneX(), e.getSceneY());
            }

            ClickCounter cc = counters.get(e.getButton());
            boolean still = lastPress != null ? lastPress.isStill() : false;

            if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {

                if (! e.isPrimaryButtonDown()) { counters.get(MouseButton.PRIMARY).clear(); }
                if (! e.isSecondaryButtonDown()) { counters.get(MouseButton.SECONDARY).clear(); }
                if (! e.isMiddleButtonDown()) { counters.get(MouseButton.MIDDLE).clear(); }

                cc.applyOut();
                cc.inc();
                cc.start(e.getSceneX(), e.getSceneY());
                lastPress = cc;
            }

            return new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
                    e.getScreenX(), e.getScreenY(), e.getButton(),
                    cc != null &amp;&amp; e.getEventType() != MouseEvent.MOUSE_MOVED ? cc.get() : 0,
                    e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
                    e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
                    e.isSynthesized(), e.isPopupTrigger(), still, e.getPickResult());
        }

        private void postProcess(MouseEvent e, TargetWrapper target, TargetWrapper pickedTarget) {

            if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
                ClickCounter cc = counters.get(e.getButton());

                target.fillHierarchy(pressedTargets);
                pickedTarget.fillHierarchy(releasedTargets);
                int i = pressedTargets.size() - 1;
                int j = releasedTargets.size() - 1;

                EventTarget clickedTarget = null;
                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; pressedTargets.get(i) == releasedTargets.get(j)) {
                    clickedTarget = pressedTargets.get(i);
                    i--;
                    j--;
                }

                pressedTargets.clear();
                releasedTargets.clear();

                if (clickedTarget != null &amp;&amp; lastPress != null) {
                    MouseEvent click = new MouseEvent(null, clickedTarget,
                            MouseEvent.MOUSE_CLICKED, e.getSceneX(), e.getSceneY(),
                            e.getScreenX(), e.getScreenY(), e.getButton(),
                            cc.get(),
                            e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
                            e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
                            e.isSynthesized(), e.isPopupTrigger(), lastPress.isStill(), e.getPickResult());
                    Event.fireEvent(clickedTarget, click);
                }
            }
        }
    }

    /**
     * Generates mouse exited event for a node which is going to be removed
     * and its children, where appropriate.
     * @param removing Node which is going to be removed
     */
    void generateMouseExited(Node removing) {
        mouseHandler.handleNodeRemoval(removing);
    }

    class MouseHandler {
        private TargetWrapper pdrEventTarget = new TargetWrapper(); // pdr - press-drag-release
        private boolean pdrInProgress = false;
        private boolean fullPDREntered = false;

        private EventTarget currentEventTarget = null;
        private MouseEvent lastEvent;
        private boolean hover = false;

        private boolean primaryButtonDown = false;
        private boolean secondaryButtonDown = false;
        private boolean middleButtonDown = false;

        private EventTarget fullPDRSource = null;
        private TargetWrapper fullPDRTmpTargetWrapper = new TargetWrapper();

        /* lists needed for enter/exit events generation */
        private final List&lt;EventTarget&gt; pdrEventTargets = new ArrayList&lt;EventTarget&gt;();
        private final List&lt;EventTarget&gt; currentEventTargets = new ArrayList&lt;EventTarget&gt;();
        private final List&lt;EventTarget&gt; newEventTargets = new ArrayList&lt;EventTarget&gt;();

        private final List&lt;EventTarget&gt; fullPDRCurrentEventTargets = new ArrayList&lt;EventTarget&gt;();
        private final List&lt;EventTarget&gt; fullPDRNewEventTargets = new ArrayList&lt;EventTarget&gt;();
        private EventTarget fullPDRCurrentTarget = null;

        private Cursor currCursor;
        private CursorFrame currCursorFrame;
        private EventQueue queue = new EventQueue();

        private Runnable pickProcess = new Runnable() {

            @Override
            public void run() {
                // Make sure this is run only if the peer is still alive
                // and there is an event to deliver
                if (Scene.this.peer != null &amp;&amp; lastEvent != null) {
                    process(lastEvent, true);
                }
            }
        };

        private void pulse() {
            if (hover &amp;&amp; lastEvent != null) {
                //Shouldn't run user code directly. User can call stage.showAndWait() and block the pulse.
                Platform.runLater(pickProcess);
            }
        }

        private void clearPDREventTargets() {
            pdrInProgress = false;
            currentEventTarget = currentEventTargets.size() &gt; 0
                    ? currentEventTargets.get(0) : null;
            pdrEventTarget.clear();
        }

        public void enterFullPDR(EventTarget gestureSource) {
            fullPDREntered = true;
            fullPDRSource = gestureSource;
            fullPDRCurrentTarget = null;
            fullPDRCurrentEventTargets.clear();
        }

        public void exitFullPDR(MouseEvent e) {
            if (!fullPDREntered) {
                return;
            }
            fullPDREntered = false;
            for (int i = fullPDRCurrentEventTargets.size() - 1; i &gt;= 0; i--) {
                EventTarget entered = fullPDRCurrentEventTargets.get(i);
                Event.fireEvent(entered, MouseEvent.copyForMouseDragEvent(e,
                        entered, entered,
                        MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
                        fullPDRSource, e.getPickResult()));
            }
            fullPDRSource = null;
            fullPDRCurrentEventTargets.clear();
            fullPDRCurrentTarget = null;
        }

        private void handleNodeRemoval(Node removing) {
            if (lastEvent == null) {
                // this can happen only if everything has been exited anyway
                return;
            }


            if (currentEventTargets.contains(removing)) {
                int i = 0;
                EventTarget trg = null;
                while(trg != removing) {
                    trg = currentEventTargets.get(i++);

                    queue.postEvent(lastEvent.copyFor(trg, trg,
                            MouseEvent.MOUSE_EXITED_TARGET));
                }
                currentEventTargets.subList(0, i).clear();
            }

            if (fullPDREntered &amp;&amp; fullPDRCurrentEventTargets.contains(removing)) {
                int i = 0;
                EventTarget trg = null;
                while (trg != removing) {
                    trg = fullPDRCurrentEventTargets.get(i++);

                    queue.postEvent(
                            MouseEvent.copyForMouseDragEvent(lastEvent, trg, trg,
                            MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
                            fullPDRSource, lastEvent.getPickResult()));
                }

                fullPDRCurrentEventTargets.subList(0, i).clear();
            }

            queue.fire();

            if (pdrInProgress &amp;&amp; pdrEventTargets.contains(removing)) {
                int i = 0;
                EventTarget trg = null;
                while (trg != removing) {
                    trg = pdrEventTargets.get(i++);

                    // trg.setHover(false) - already taken care of
                    // by the code above which sent a mouse exited event
                    ((Node) trg).setPressed(false);
                }
                pdrEventTargets.subList(0, i).clear();

                trg = pdrEventTargets.get(0);
                final PickResult res = pdrEventTarget.getResult();
                if (trg instanceof Node) {
                    pdrEventTarget.setNodeResult(new PickResult((Node) trg,
                            res.getIntersectedPoint(), res.getIntersectedDistance()));
                } else {
                    pdrEventTarget.setSceneResult(new PickResult(null,
                            res.getIntersectedPoint(), res.getIntersectedDistance()),
                            (Scene) trg);
                }
            }
        }

        private void handleEnterExit(MouseEvent e, TargetWrapper pickedTarget) {
            if (pickedTarget.getEventTarget() != currentEventTarget ||
                    e.getEventType() == MouseEvent.MOUSE_EXITED) {

                if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
                    newEventTargets.clear();
                } else {
                    pickedTarget.fillHierarchy(newEventTargets);
                }

                int newTargetsSize = newEventTargets.size();
                int i = currentEventTargets.size() - 1;
                int j = newTargetsSize - 1;
                int k = pdrEventTargets.size() - 1;

                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentEventTargets.get(i) == newEventTargets.get(j)) {
                    i--;
                    j--;
                    k--;
                }

                final int memk = k;
                for (; i &gt;= 0; i--, k--) {
                    final EventTarget exitedEventTarget = currentEventTargets.get(i);
                    if (pdrInProgress &amp;&amp;
                            (k &lt; 0 || exitedEventTarget != pdrEventTargets.get(k))) {
                         break;
                    }
                    queue.postEvent(e.copyFor(
                            exitedEventTarget, exitedEventTarget,
                            MouseEvent.MOUSE_EXITED_TARGET));
                }

                k = memk;
                for (; j &gt;= 0; j--, k--) {
                    final EventTarget enteredEventTarget = newEventTargets.get(j);
                    if (pdrInProgress &amp;&amp;
                            (k &lt; 0 || enteredEventTarget != pdrEventTargets.get(k))) {
                        break;
                    }
                    queue.postEvent(e.copyFor(
                            enteredEventTarget, enteredEventTarget,
                            MouseEvent.MOUSE_ENTERED_TARGET));
                }

                currentEventTarget = pickedTarget.getEventTarget();
                currentEventTargets.clear();
                for (j++; j &lt; newTargetsSize; j++) {
                    currentEventTargets.add(newEventTargets.get(j));
                }
            }
            queue.fire();
        }

        private void process(MouseEvent e, boolean onPulse) {
            Toolkit.getToolkit().checkFxUserThread();
            Scene.inMousePick = true;

            cursorScreenPos = new Point2D(e.getScreenX(), e.getScreenY());
            cursorScenePos = new Point2D(e.getSceneX(), e.getSceneY());

            boolean gestureStarted = false;
            if (!onPulse) {
                if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {
                    if (!(primaryButtonDown || secondaryButtonDown || middleButtonDown)) {
                        //old gesture ended and new one started
                        gestureStarted = true;
                        if (!PLATFORM_DRAG_GESTURE_INITIATION) {
                            Scene.this.dndGesture = new DnDGesture();
                        }
                        clearPDREventTargets();
                    }
                } else if (e.getEventType() == MouseEvent.MOUSE_MOVED) {
                    // gesture ended
                    clearPDREventTargets();
                } else if (e.getEventType() == MouseEvent.MOUSE_ENTERED) {
                    hover = true;
                } else if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
                    hover = false;
                }

                primaryButtonDown = e.isPrimaryButtonDown();
                secondaryButtonDown = e.isSecondaryButtonDown();
                middleButtonDown = e.isMiddleButtonDown();
            }

            pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
            PickResult res = tmpTargetWrapper.getResult();
            if (res != null) {
                e = new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
                    e.getScreenX(), e.getScreenY(), e.getButton(), e.getClickCount(),
                    e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
                    e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
                    e.isSynthesized(), e.isPopupTrigger(), e.isStillSincePress(), res);
            }

            if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
                tmpTargetWrapper.clear();
            }

            TargetWrapper target;
            if (pdrInProgress) {
                target = pdrEventTarget;
            } else {
                target = tmpTargetWrapper;
            }

            if (gestureStarted) {
                pdrEventTarget.copy(target);
                pdrEventTarget.fillHierarchy(pdrEventTargets);
            }

            if (!onPulse) {
                e = clickGenerator.preProcess(e);
            }

            // enter/exit handling
            handleEnterExit(e, tmpTargetWrapper);

            //deliver event to the target node
            if (Scene.this.dndGesture != null) {
                Scene.this.dndGesture.processDragDetection(e);
            }

            if (fullPDREntered &amp;&amp; e.getEventType() == MouseEvent.MOUSE_RELEASED) {
                processFullPDR(e, onPulse);
            }

            if (target.getEventTarget() != null) {
                if (e.getEventType() != MouseEvent.MOUSE_ENTERED
                        &amp;&amp; e.getEventType() != MouseEvent.MOUSE_EXITED
                        &amp;&amp; !onPulse) {
                    Event.fireEvent(target.getEventTarget(), e);
                }
            }

            if (fullPDREntered &amp;&amp; e.getEventType() != MouseEvent.MOUSE_RELEASED) {
                processFullPDR(e, onPulse);
            }

            if (!onPulse) {
                clickGenerator.postProcess(e, target, tmpTargetWrapper);
            }

            // handle drag and drop

            if (!PLATFORM_DRAG_GESTURE_INITIATION &amp;&amp; !onPulse) {
                if (Scene.this.dndGesture != null) {
                    if (!Scene.this.dndGesture.process(e, target.getEventTarget())) {
                        dndGesture = null;
                    }
                }
            }

            Cursor cursor = target.getCursor();
            if (e.getEventType() != MouseEvent.MOUSE_EXITED) {
                if (cursor == null &amp;&amp; hover) {
                    cursor = Scene.this.getCursor();
                }

                updateCursor(cursor);
                updateCursorFrame();
            }

            if (gestureStarted) {
                pdrInProgress = true;
            }

            if (pdrInProgress &amp;&amp;
                    !(primaryButtonDown || secondaryButtonDown || middleButtonDown)) {
                clearPDREventTargets();
                exitFullPDR(e);
                // we need to do new picking in case the originally picked node
                // was moved or removed by the event handlers
                pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
                handleEnterExit(e, tmpTargetWrapper);
            }

            lastEvent = e.getEventType() == MouseEvent.MOUSE_EXITED ? null : e;
            Scene.inMousePick = false;
        }

        private void processFullPDR(MouseEvent e, boolean onPulse) {

            pick(fullPDRTmpTargetWrapper, e.getSceneX(), e.getSceneY());
            final PickResult result = fullPDRTmpTargetWrapper.getResult();

            final EventTarget eventTarget = fullPDRTmpTargetWrapper.getEventTarget();

            // enter/exit handling
            if (eventTarget != fullPDRCurrentTarget) {

                fullPDRTmpTargetWrapper.fillHierarchy(fullPDRNewEventTargets);

                int newTargetsSize = fullPDRNewEventTargets.size();
                int i = fullPDRCurrentEventTargets.size() - 1;
                int j = newTargetsSize - 1;

                while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp;
                        fullPDRCurrentEventTargets.get(i) == fullPDRNewEventTargets.get(j)) {
                    i--;
                    j--;
                }

                for (; i &gt;= 0; i--) {
                    final EventTarget exitedEventTarget = fullPDRCurrentEventTargets.get(i);
                    Event.fireEvent(exitedEventTarget, MouseEvent.copyForMouseDragEvent(e,
                            exitedEventTarget, exitedEventTarget,
                            MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
                            fullPDRSource, result));
                }

                for (; j &gt;= 0; j--) {
                    final EventTarget enteredEventTarget = fullPDRNewEventTargets.get(j);
                    Event.fireEvent(enteredEventTarget, MouseEvent.copyForMouseDragEvent(e,
                            enteredEventTarget, enteredEventTarget,
                            MouseDragEvent.MOUSE_DRAG_ENTERED_TARGET,
                            fullPDRSource, result));
                }

                fullPDRCurrentTarget = eventTarget;
                fullPDRCurrentEventTargets.clear();
                fullPDRCurrentEventTargets.addAll(fullPDRNewEventTargets);
                fullPDRNewEventTargets.clear();
            }
            // done enter/exit handling

            // event delivery
            if (eventTarget != null &amp;&amp; !onPulse) {
                if (e.getEventType() == MouseEvent.MOUSE_DRAGGED) {
                    Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
                            eventTarget, eventTarget,
                            MouseDragEvent.MOUSE_DRAG_OVER,
                            fullPDRSource, result));
                }
                if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
                    Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
                            eventTarget, eventTarget,
                            MouseDragEvent.MOUSE_DRAG_RELEASED,
                            fullPDRSource, result));
                }
            }
        }

        private void updateCursor(Cursor newCursor) {
            if (currCursor != newCursor) {
                if (currCursor != null) {
                    currCursor.deactivate();
                }

                if (newCursor != null) {
                    newCursor.activate();
                }

                currCursor = newCursor;
            }
        }

        public void updateCursorFrame() {
            final CursorFrame newCursorFrame =
                    (currCursor != null)
                           ? currCursor.getCurrentFrame()
                           : Cursor.DEFAULT.getCurrentFrame();
            if (currCursorFrame != newCursorFrame) {
                if (Scene.this.peer != null) {
                    Scene.this.peer.setCursor(newCursorFrame);
                }

                currCursorFrame = newCursorFrame;
            }
        }

        private PickResult pickNode(PickRay pickRay) {
            PickResultChooser r = new PickResultChooser();
            Scene.this.getRoot().pickNode(pickRay, r);
            return r.toPickResult();
        }
    }

    /*******************************************************************************
     *                                                                             *
     * Key Event Handling                                                          *
     *                                                                             *
     ******************************************************************************/

    class KeyHandler {
        private void setFocusOwner(final Node value) {
            // Cancel IM composition if there is one in progress.
            // This needs to be done before the focus owner is switched as it
            // generates event that needs to be delivered to the old focus owner.
            if (oldFocusOwner != null) {
                final Scene s = oldFocusOwner.getScene();
                if (s != null) {
                    final TKScene peer = s.getPeer();
                    if (peer != null) {
                        peer.finishInputMethodComposition();
                    }
                }
            }
            focusOwner.set(value);
        }

        private boolean windowFocused;
        protected boolean isWindowFocused() { return windowFocused; }
        protected void setWindowFocused(boolean value) {
            windowFocused = value;
            if (getFocusOwner() != null) {
                getFocusOwner().setFocused(windowFocused);
            }
            if (windowFocused) {
                if (accessible != null) {
                    accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
                }
            }
        }

        private void windowForSceneChanged(Window oldWindow, Window window) {
            if (oldWindow != null) {
                oldWindow.focusedProperty().removeListener(sceneWindowFocusedListener);
            }

            if (window != null) {
                window.focusedProperty().addListener(sceneWindowFocusedListener);
                setWindowFocused(window.isFocused());
            } else {
                setWindowFocused(false);
            }
        }

        private final InvalidationListener sceneWindowFocusedListener = valueModel -&gt; setWindowFocused(((ReadOnlyBooleanProperty)valueModel).get());

        private void process(KeyEvent e) {
            final Node sceneFocusOwner = getFocusOwner();
            final EventTarget eventTarget =
                    (sceneFocusOwner != null &amp;&amp; sceneFocusOwner.getScene() == Scene.this) ? sceneFocusOwner
                                              : Scene.this;

            // send the key event to the current focus owner or to scene if
            // the focus owner is not set
            Event.fireEvent(eventTarget, e);
        }

        private void requestFocus(Node node) {
            if (getFocusOwner() == node || (node != null &amp;&amp; !node.isCanReceiveFocus())) {
                return;
            }
            setFocusOwner(node);
        }
    }
    /***************************************************************************
     *                                                                         *
     *                         Event Dispatch                                  *
     *                                                                         *
     **************************************************************************/
    // PENDING_DOC_REVIEW
    /**
     * Specifies the event dispatcher for this scene. When replacing the value
     * with a new {@code EventDispatcher}, the new dispatcher should forward
     * events to the replaced dispatcher to keep the scene's default event
     * handling behavior.
     */
    private ObjectProperty&lt;EventDispatcher&gt; eventDispatcher;

    public final void setEventDispatcher(EventDispatcher value) {
        eventDispatcherProperty().set(value);
    }

    public final EventDispatcher getEventDispatcher() {
        return eventDispatcherProperty().get();
    }

    public final ObjectProperty&lt;EventDispatcher&gt;
            eventDispatcherProperty() {
        initializeInternalEventDispatcher();
        return eventDispatcher;
    }

    private SceneEventDispatcher internalEventDispatcher;

    // Delegates requests from platform input method to the focused
    // node's one, if any.
    class InputMethodRequestsDelegate implements ExtendedInputMethodRequests {
        @Override
        public Point2D getTextLocation(int offset) {
            InputMethodRequests requests = getClientRequests();
            if (requests != null) {
                return requests.getTextLocation(offset);
            } else {
                return new Point2D(0, 0);
            }
        }

        @Override
        public int getLocationOffset(int x, int y) {
            InputMethodRequests requests = getClientRequests();
            if (requests != null) {
                return requests.getLocationOffset(x, y);
            } else {
                return 0;
            }
        }

        @Override
        public void cancelLatestCommittedText() {
            InputMethodRequests requests = getClientRequests();
            if (requests != null) {
                requests.cancelLatestCommittedText();
            }
        }

        @Override
        public String getSelectedText() {
            InputMethodRequests requests = getClientRequests();
            if (requests != null) {
                return requests.getSelectedText();
            }
            return null;
        }

        @Override
        public int getInsertPositionOffset() {
            InputMethodRequests requests = getClientRequests();
            if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
                return ((ExtendedInputMethodRequests)requests).getInsertPositionOffset();
            }
            return 0;
        }

        @Override
        public String getCommittedText(int begin, int end) {
            InputMethodRequests requests = getClientRequests();
            if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
                return ((ExtendedInputMethodRequests)requests).getCommittedText(begin, end);
            }
            return null;
        }

        @Override
        public int getCommittedTextLength() {
            InputMethodRequests requests = getClientRequests();
            if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
                return ((ExtendedInputMethodRequests)requests).getCommittedTextLength();
            }
            return 0;
        }

        private InputMethodRequests getClientRequests() {
            Node focusOwner = getFocusOwner();
            if (focusOwner != null) {
                return focusOwner.getInputMethodRequests();
            }
            return null;
        }
    }

    // PENDING_DOC_REVIEW
    /**
     * Registers an event handler to this scene. The handler is called when the
     * scene receives an {@code Event} of the specified type during the bubbling
     * phase of event delivery.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the type of the events to receive by the handler
     * @param eventHandler the handler to register
     * @throws NullPointerException if the event type or handler is null
     */
    public final &lt;T extends Event&gt; void addEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .addEventHandler(eventType, eventHandler);
    }

    // PENDING_DOC_REVIEW
    /**
     * Unregisters a previously registered event handler from this scene. One
     * handler might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the handler.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type from which to unregister
     * @param eventHandler the handler to unregister
     * @throws NullPointerException if the event type or handler is null
     */
    public final &lt;T extends Event&gt; void removeEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .removeEventHandler(eventType,
                                                        eventHandler);
    }

    // PENDING_DOC_REVIEW
    /**
     * Registers an event filter to this scene. The filter is called when the
     * scene receives an {@code Event} of the specified type during the
     * capturing phase of event delivery.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the type of the events to receive by the filter
     * @param eventFilter the filter to register
     * @throws NullPointerException if the event type or filter is null
     */
    public final &lt;T extends Event&gt; void addEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .addEventFilter(eventType, eventFilter);
    }

    // PENDING_DOC_REVIEW
    /**
     * Unregisters a previously registered event filter from this scene. One
     * filter might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the filter.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the event type from which to unregister
     * @param eventFilter the filter to unregister
     * @throws NullPointerException if the event type or filter is null
     */
    public final &lt;T extends Event&gt; void removeEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .removeEventFilter(eventType, eventFilter);
    }

    /**
     * Sets the handler to use for this event type. There can only be one such
     * handler specified at a time. This handler is guaranteed to be called
     * first. This is used for registering the user-defined onFoo event
     * handlers.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type to associate with the given eventHandler
     * @param eventHandler the handler to register, or null to unregister
     * @throws NullPointerException if the event type is null
     */
    protected final &lt;T extends Event&gt; void setEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher().getEventHandlerManager()
                                    .setEventHandler(eventType, eventHandler);
    }

    private SceneEventDispatcher getInternalEventDispatcher() {
        initializeInternalEventDispatcher();
        return internalEventDispatcher;
    }

    final void initializeInternalEventDispatcher() {
        if (internalEventDispatcher == null) {
            internalEventDispatcher = createInternalEventDispatcher();
            eventDispatcher = new SimpleObjectProperty&lt;EventDispatcher&gt;(
                                          this,
                                          &quot;eventDispatcher&quot;,
                                          internalEventDispatcher);
        }
    }

    private SceneEventDispatcher createInternalEventDispatcher() {
        return new SceneEventDispatcher(this);
    }

    /**
     * Registers the specified mnemonic.
     *
     * @param m The mnemonic
     */
    public void addMnemonic(Mnemonic m) {
        getInternalEventDispatcher().getKeyboardShortcutsHandler()
                                    .addMnemonic(m);
    }


    /**
     * Unregisters the specified mnemonic.
     *
     * @param m The mnemonic
     */
    public void removeMnemonic(Mnemonic m) {
        getInternalEventDispatcher().getKeyboardShortcutsHandler()
                                    .removeMnemonic(m);
    }

    final void clearNodeMnemonics(Node node) {
        getInternalEventDispatcher().getKeyboardShortcutsHandler()
                .clearNodeMnemonics(node);
    }


    /**
     * Gets the list of mnemonics for this {@code Scene}.
     *
     * @return the list of mnemonics
     */
    public ObservableMap&lt;KeyCombination, ObservableList&lt;Mnemonic&gt;&gt; getMnemonics() {
        return getInternalEventDispatcher().getKeyboardShortcutsHandler()
                                           .getMnemonics();
    }

    /**
     * Gets the list of accelerators for this {@code Scene}.
     *
     * @return the list of accelerators
     */
    public ObservableMap&lt;KeyCombination, Runnable&gt; getAccelerators() {
        return getInternalEventDispatcher().getKeyboardShortcutsHandler()
                                           .getAccelerators();
    }

    // PENDING_DOC_REVIEW
    /**
     * Construct an event dispatch chain for this scene. The event dispatch
     * chain contains all event dispatchers from the stage to this scene.
     *
     * @param tail the initial chain to build from
     * @return the resulting event dispatch chain for this scene
     */
    @Override
    public EventDispatchChain buildEventDispatchChain(
            EventDispatchChain tail) {
        if (eventDispatcher != null) {
            final EventDispatcher eventDispatcherValue = eventDispatcher.get();
            if (eventDispatcherValue != null) {
                tail = tail.prepend(eventDispatcherValue);
            }
        }

        if (getWindow() != null) {
            tail = getWindow().buildEventDispatchChain(tail);
        }

        return tail;
    }

    /***************************************************************************
     *                                                                         *
     *                             Context Menus                               *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when a mouse button has been clicked
     * (pressed and released) on this {@code Scene}.
     * @since JavaFX 2.1
     */

    private ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequested;

    public final void setOnContextMenuRequested(EventHandler&lt;? super ContextMenuEvent&gt; value) {
        onContextMenuRequestedProperty().set(value);
    }

    public final EventHandler&lt;? super ContextMenuEvent&gt; getOnContextMenuRequested() {
        return onContextMenuRequested == null ? null : onContextMenuRequested.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequestedProperty() {
        if (onContextMenuRequested == null) {
            onContextMenuRequested = new ObjectPropertyBase&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ContextMenuEvent.CONTEXT_MENU_REQUESTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onContextMenuRequested&quot;;
                }
            };
        }
        return onContextMenuRequested;
    }

    /***************************************************************************
     *                                                                         *
     *                             Mouse Handling                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when a mouse button has been clicked
     * (pressed and released) on this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClicked;

    public final void setOnMouseClicked(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseClickedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseClicked() {
        return onMouseClicked == null ? null : onMouseClicked.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClickedProperty() {
        if (onMouseClicked == null) {
            onMouseClicked = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_CLICKED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseClicked&quot;;
                }
            };
        }
        return onMouseClicked;
    }

    /**
     * Defines a function to be called when a mouse button is pressed
     * on this {@code Scene} and then dragged.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDragged;

    public final void setOnMouseDragged(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseDraggedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseDragged() {
        return onMouseDragged == null ? null : onMouseDragged.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDraggedProperty() {
        if (onMouseDragged == null) {
            onMouseDragged = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_DRAGGED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragged&quot;;
                }
            };
        }
        return onMouseDragged;
    }

    /**
     * Defines a function to be called when the mouse enters this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEntered;

    public final void setOnMouseEntered(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseEntered() {
        return onMouseEntered == null ? null : onMouseEntered.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEnteredProperty() {
        if (onMouseEntered == null) {
            onMouseEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_ENTERED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseEntered&quot;;
                }
            };
        }
        return onMouseEntered;
    }

    /**
     * Defines a function to be called when the mouse exits this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExited;

    public final void setOnMouseExited(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseExitedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseExited() {
        return onMouseExited == null ? null : onMouseExited.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExitedProperty() {
        if (onMouseExited == null) {
            onMouseExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_EXITED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseExited&quot;;
                }
            };
        }
        return onMouseExited;
    }

    /**
     * Defines a function to be called when mouse cursor moves within
     * this {@code Scene} but no buttons have been pushed.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMoved;

    public final void setOnMouseMoved(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseMovedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseMoved() {
        return onMouseMoved == null ? null : onMouseMoved.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMovedProperty() {
        if (onMouseMoved == null) {
            onMouseMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_MOVED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseMoved&quot;;
                }
            };
        }
        return onMouseMoved;
    }

    /**
     * Defines a function to be called when a mouse button
     * has been pressed on this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressed;

    public final void setOnMousePressed(EventHandler&lt;? super MouseEvent&gt; value) {
        onMousePressedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMousePressed() {
        return onMousePressed == null ? null : onMousePressed.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressedProperty() {
        if (onMousePressed == null) {
            onMousePressed = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_PRESSED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMousePressed&quot;;
                }
            };
        }
        return onMousePressed;
    }

    /**
     * Defines a function to be called when a mouse button
     * has been released on this {@code Scene}.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleased;

    public final void setOnMouseReleased(EventHandler&lt;? super MouseEvent&gt; value) {
        onMouseReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnMouseReleased() {
        return onMouseReleased == null ? null : onMouseReleased.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleasedProperty() {
        if (onMouseReleased == null) {
            onMouseReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.MOUSE_RELEASED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseReleased&quot;;
                }
            };
        }
        return onMouseReleased;
    }

    /**
     * Defines a function to be called when drag gesture has been
     * detected. This is the right place to start drag and drop operation.
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetected;

    public final void setOnDragDetected(EventHandler&lt;? super MouseEvent&gt; value) {
        onDragDetectedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseEvent&gt; getOnDragDetected() {
        return onDragDetected == null ? null : onDragDetected.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetectedProperty() {
        if (onDragDetected == null) {
            onDragDetected = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseEvent.DRAG_DETECTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragDetected&quot;;
                }
            };
        }
        return onDragDetected;
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * progresses within this {@code Scene}.
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOver;

    public final void setOnMouseDragOver(EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragOverProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragOver() {
        return onMouseDragOver == null ? null : onMouseDragOver.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOverProperty() {
        if (onMouseDragOver == null) {
            onMouseDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseDragEvent.MOUSE_DRAG_OVER, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragOver&quot;;
                }
            };
        }
        return onMouseDragOver;
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * ends within this {@code Scene}.
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleased;

    public final void setOnMouseDragReleased(EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragReleased() {
        return onMouseDragReleased == null ? null : onMouseDragReleased.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleasedProperty() {
        if (onMouseDragReleased == null) {
            onMouseDragReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseDragEvent.MOUSE_DRAG_RELEASED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragReleased&quot;;
                }
            };
        }
        return onMouseDragReleased;
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * enters this {@code Scene}.
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEntered;

    public final void setOnMouseDragEntered(EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragEntered() {
        return onMouseDragEntered == null ? null : onMouseDragEntered.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEnteredProperty() {
        if (onMouseDragEntered == null) {
            onMouseDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseDragEvent.MOUSE_DRAG_ENTERED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragEntered&quot;;
                }
            };
        }
        return onMouseDragEntered;
    }

    /**
     * Defines a function to be called when a full press-drag-release gesture
     * exits this {@code Scene}.
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExited;

    public final void setOnMouseDragExited(EventHandler&lt;? super MouseDragEvent&gt; value) {
        onMouseDragExitedProperty().set(value);
    }

    public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragExited() {
        return onMouseDragExited == null ? null : onMouseDragExited.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExitedProperty() {
        if (onMouseDragExited == null) {
            onMouseDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MouseDragEvent.MOUSE_DRAG_EXITED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onMouseDragExited&quot;;
                }
            };
        }
        return onMouseDragExited;
    }


    /***************************************************************************
     *                                                                         *
     *                           Gestures Handling                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when a scrolling gesture is detected.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStarted;

    public final void setOnScrollStarted(EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollStartedProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollStarted() {
        return onScrollStarted == null ? null : onScrollStarted.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStartedProperty() {
        if (onScrollStarted == null) {
            onScrollStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ScrollEvent.SCROLL_STARTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onScrollStarted&quot;;
                }
            };
        }
        return onScrollStarted;
    }

    /**
     * Defines a function to be called when user performs a scrolling action.
     */
    private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScroll;

    public final void setOnScroll(EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScroll() {
        return onScroll == null ? null : onScroll.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollProperty() {
        if (onScroll == null) {
            onScroll = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ScrollEvent.SCROLL, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onScroll&quot;;
                }
            };
        }
        return onScroll;
    }

    /**
     * Defines a function to be called when a scrolling gesture ends.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinished;

    public final void setOnScrollFinished(EventHandler&lt;? super ScrollEvent&gt; value) {
        onScrollFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollFinished() {
        return onScrollFinished == null ? null : onScrollFinished.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinishedProperty() {
        if (onScrollFinished == null) {
            onScrollFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ScrollEvent.SCROLL_FINISHED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onScrollFinished&quot;;
                }
            };
        }
        return onScrollFinished;
    }

    /**
     * Defines a function to be called when a rotating gesture is detected.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStarted;

    public final void setOnRotationStarted(EventHandler&lt;? super RotateEvent&gt; value) {
        onRotationStartedProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotationStarted() {
        return onRotationStarted == null ? null : onRotationStarted.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStartedProperty() {
        if (onRotationStarted == null) {
            onRotationStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(RotateEvent.ROTATION_STARTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onRotationStarted&quot;;
                }
            };
        }
        return onRotationStarted;
    }

    /**
     * Defines a function to be called when user performs a rotating action.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotate;

    public final void setOnRotate(EventHandler&lt;? super RotateEvent&gt; value) {
        onRotateProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotate() {
        return onRotate == null ? null : onRotate.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotateProperty() {
        if (onRotate == null) {
            onRotate = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(RotateEvent.ROTATE, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onRotate&quot;;
                }
            };
        }
        return onRotate;
    }

    /**
     * Defines a function to be called when a rotating gesture ends.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinished;

    public final void setOnRotationFinished(EventHandler&lt;? super RotateEvent&gt; value) {
        onRotationFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super RotateEvent&gt; getOnRotationFinished() {
        return onRotationFinished == null ? null : onRotationFinished.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinishedProperty() {
        if (onRotationFinished == null) {
            onRotationFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(RotateEvent.ROTATION_FINISHED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onRotationFinished&quot;;
                }
            };
        }
        return onRotationFinished;
    }

    /**
     * Defines a function to be called when a zooming gesture is detected.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStarted;

    public final void setOnZoomStarted(EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomStartedProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomStarted() {
        return onZoomStarted == null ? null : onZoomStarted.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStartedProperty() {
        if (onZoomStarted == null) {
            onZoomStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ZoomEvent.ZOOM_STARTED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onZoomStarted&quot;;
                }
            };
        }
        return onZoomStarted;
    }

    /**
     * Defines a function to be called when user performs a zooming action.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoom;

    public final void setOnZoom(EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoom() {
        return onZoom == null ? null : onZoom.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomProperty() {
        if (onZoom == null) {
            onZoom = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ZoomEvent.ZOOM, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onZoom&quot;;
                }
            };
        }
        return onZoom;
    }

    /**
     * Defines a function to be called when a zooming gesture ends.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinished;

    public final void setOnZoomFinished(EventHandler&lt;? super ZoomEvent&gt; value) {
        onZoomFinishedProperty().set(value);
    }

    public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomFinished() {
        return onZoomFinished == null ? null : onZoomFinished.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinishedProperty() {
        if (onZoomFinished == null) {
            onZoomFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(ZoomEvent.ZOOM_FINISHED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onZoomFinished&quot;;
                }
            };
        }
        return onZoomFinished;
    }

    /**
     * Defines a function to be called when an upward swipe gesture
     * happens in this scene.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUp;

    public final void setOnSwipeUp(EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeUpProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeUp() {
        return onSwipeUp == null ? null : onSwipeUp.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUpProperty() {
        if (onSwipeUp == null) {
            onSwipeUp = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(SwipeEvent.SWIPE_UP, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onSwipeUp&quot;;
                }
            };
        }
        return onSwipeUp;
    }

    /**
     * Defines a function to be called when an downward swipe gesture
     * happens in this scene.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDown;

    public final void setOnSwipeDown(EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeDownProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeDown() {
        return onSwipeDown == null ? null : onSwipeDown.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDownProperty() {
        if (onSwipeDown == null) {
            onSwipeDown = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(SwipeEvent.SWIPE_DOWN, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onSwipeDown&quot;;
                }
            };
        }
        return onSwipeDown;
    }

    /**
     * Defines a function to be called when an leftward swipe gesture
     * happens in this scene.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeft;

    public final void setOnSwipeLeft(EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeLeftProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeLeft() {
        return onSwipeLeft == null ? null : onSwipeLeft.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeftProperty() {
        if (onSwipeLeft == null) {
            onSwipeLeft = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(SwipeEvent.SWIPE_LEFT, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onSwipeLeft&quot;;
                }
            };
        }
        return onSwipeLeft;
    }

    /**
     * Defines a function to be called when an rightward swipe gesture
     * happens in this scene.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRight;

    public final void setOnSwipeRight(EventHandler&lt;? super SwipeEvent&gt; value) {
        onSwipeRightProperty().set(value);
    }

    public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeRight() {
        return onSwipeRight == null ? null : onSwipeRight.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRightProperty() {
        if (onSwipeRight == null) {
            onSwipeRight = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(SwipeEvent.SWIPE_RIGHT, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onSwipeRight&quot;;
                }
            };
        }
        return onSwipeRight;
    }

    /***************************************************************************
     *                                                                         *
     *                            Touch Handling                               *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when a new touch point is pressed.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressed;

    public final void setOnTouchPressed(EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchPressedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchPressed() {
        return onTouchPressed == null ? null : onTouchPressed.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressedProperty() {
        if (onTouchPressed == null) {
            onTouchPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(TouchEvent.TOUCH_PRESSED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onTouchPressed&quot;;
                }
            };
        }
        return onTouchPressed;
    }

    /**
     * Defines a function to be called when a touch point is moved.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMoved;

    public final void setOnTouchMoved(EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchMovedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchMoved() {
        return onTouchMoved == null ? null : onTouchMoved.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMovedProperty() {
        if (onTouchMoved == null) {
            onTouchMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(TouchEvent.TOUCH_MOVED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onTouchMoved&quot;;
                }
            };
        }
        return onTouchMoved;
    }

    /**
     * Defines a function to be called when a new touch point is pressed.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleased;

    public final void setOnTouchReleased(EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchReleased() {
        return onTouchReleased == null ? null : onTouchReleased.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleasedProperty() {
        if (onTouchReleased == null) {
            onTouchReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(TouchEvent.TOUCH_RELEASED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onTouchReleased&quot;;
                }
            };
        }
        return onTouchReleased;
    }

    /**
     * Defines a function to be called when a touch point stays pressed and
     * still.
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationary;

    public final void setOnTouchStationary(EventHandler&lt;? super TouchEvent&gt; value) {
        onTouchStationaryProperty().set(value);
    }

    public final EventHandler&lt;? super TouchEvent&gt; getOnTouchStationary() {
        return onTouchStationary == null ? null : onTouchStationary.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationaryProperty() {
        if (onTouchStationary == null) {
            onTouchStationary = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(TouchEvent.TOUCH_STATIONARY, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onTouchStationary&quot;;
                }
            };
        }
        return onTouchStationary;
    }

    /*
     * This class provides reordering and ID mapping of particular touch points.
     * Platform may report arbitrary touch point IDs and they may be reused
     * during one gesture. This class keeps track of it and provides
     * sequentially sorted IDs, unique in scope of a gesture.
     *
     * Some platforms report always small numbers, these take fast paths through
     * the algorithm, directly indexing an array. Bigger numbers take a slow
     * path using a hash map.
     *
     * The algorithm performance was measured and it doesn't impose
     * any significant slowdown on the event delivery.
     */
    private static class TouchMap {
        private static final int FAST_THRESHOLD = 10;
        int[] fastMap = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        Map&lt;Long, Integer&gt; slowMap = new HashMap&lt;Long, Integer&gt;();
        List&lt;Integer&gt; order = new LinkedList&lt;Integer&gt;();
        List&lt;Long&gt; removed = new ArrayList&lt;Long&gt;(10);
        int counter = 0;
        int active = 0;

        public int add(long id) {
            counter++;
            active++;
            if (id &lt; FAST_THRESHOLD) {
                fastMap[(int) id] = counter;
            } else {
                slowMap.put(id, counter);
            }
            order.add(counter);
            return counter;
        }

        public void remove(long id) {
            // book the removal - it needs to be done after all touch points
            // of an event are processed - see cleanup()
            removed.add(id);
        }

        public int get(long id) {
            if (id &lt; FAST_THRESHOLD) {
                int result = fastMap[(int) id];
                if (result == 0) {
                    throw new RuntimeException(&quot;Platform reported wrong &quot;
                            + &quot;touch point ID&quot;);
                }
                return result;
            } else {
                try {
                    return slowMap.get(id);
                } catch (NullPointerException e) {
                    throw new RuntimeException(&quot;Platform reported wrong &quot;
                            + &quot;touch point ID&quot;);
                }
            }
        }

        public int getOrder(int id) {
            return order.indexOf(id);
        }

        // returns true if gesture finished (no finger is touched)
        public boolean cleanup() {
            for (long id : removed) {
                active--;
                order.remove(Integer.valueOf(get(id)));
                if (id &lt; FAST_THRESHOLD) {
                    fastMap[(int) id] = 0;
                } else {
                    slowMap.remove(id);
                }
                if (active == 0) {
                    // gesture finished
                    counter = 0;
                }
            }
            removed.clear();
            return active == 0;
        }
    }


    /***************************************************************************
     *                                                                         *
     *                         Drag and Drop Handling                          *
     *                                                                         *
     **************************************************************************/

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEntered;

    public final void setOnDragEntered(EventHandler&lt;? super DragEvent&gt; value) {
        onDragEnteredProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragEntered() {
        return onDragEntered == null ? null : onDragEntered.get();
    }

    /**
     * Defines a function to be called when drag gesture
     * enters this {@code Scene}.
     * @return function to be called when drag gesture enters this scene
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEnteredProperty() {
        if (onDragEntered == null) {
            onDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_ENTERED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragEntered&quot;;
                }
            };
        }
        return onDragEntered;
    }

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExited;

    public final void setOnDragExited(EventHandler&lt;? super DragEvent&gt; value) {
        onDragExitedProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragExited() {
        return onDragExited == null ? null : onDragExited.get();
    }

    /**
     * Defines a function to be called when drag gesture
     * exits this {@code Scene}.
     * @return the function to be called when drag gesture exits this scene
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExitedProperty() {
        if (onDragExited == null) {
            onDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_EXITED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragExited&quot;;
                }
            };
        }
        return onDragExited;
    }

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOver;

    public final void setOnDragOver(EventHandler&lt;? super DragEvent&gt; value) {
        onDragOverProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragOver() {
        return onDragOver == null ? null : onDragOver.get();
    }

    /**
     * Defines a function to be called when drag gesture progresses
     * within this {@code Scene}.
     * @return the function to be called when drag gesture progresses within
     * this scene
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOverProperty() {
        if (onDragOver == null) {
            onDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_OVER, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragOver&quot;;
                }
            };
        }
        return onDragOver;
    }

    // Do we want DRAG_TRANSFER_MODE_CHANGED event?
//    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChanged;
//
//    public final void setOnDragTransferModeChanged(EventHandler&lt;? super DragEvent&gt; value) {
//        onDragTransferModeChangedProperty().set(value);
//    }
//
//    public final EventHandler&lt;? super DragEvent&gt; getOnDragTransferModeChanged() {
//        return onDragTransferModeChanged == null ? null : onDragTransferModeChanged.get();
//    }
//
//    /**
//     * Defines a function to be called this {@code Scene} if it is a potential
//     * drag-and-drop target when the user takes action to change the intended
//     * {@code TransferMode}.
//     * The user can change the intended {@link TransferMode} by holding down
//     * or releasing key modifiers.
//     */
//    public ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChangedProperty() {
//        if (onDragTransferModeChanged == null) {
//            onDragTransferModeChanged = new SimpleObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
//
//                @Override
//                protected void invalidated() {
//                    setEventHandler(DragEvent.DRAG_TRANSFER_MODE_CHANGED, get());
//                }
//            };
//        }
//        return onDragTransferModeChanged;
//    }

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDropped;

    public final void setOnDragDropped(EventHandler&lt;? super DragEvent&gt; value) {
        onDragDroppedProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragDropped() {
        return onDragDropped == null ? null : onDragDropped.get();
    }

    /**
     * Defines a function to be called when the mouse button is released
     * on this {@code Scene} during drag and drop gesture. Transfer of data from
     * the {@link DragEvent}'s {@link DragEvent#getDragboard() dragboard} should
     * happen in this function.
     * @return the function to be called when the mouse button is released on
     * this scene during drag and drop gesture
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDroppedProperty() {
        if (onDragDropped == null) {
            onDragDropped = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_DROPPED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragDropped&quot;;
                }
            };
        }
        return onDragDropped;
    }

    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDone;

    public final void setOnDragDone(EventHandler&lt;? super DragEvent&gt; value) {
        onDragDoneProperty().set(value);
    }

    public final EventHandler&lt;? super DragEvent&gt; getOnDragDone() {
        return onDragDone == null ? null : onDragDone.get();
    }

    /**
     * Defines a function to be called when this {@code Scene} is a
     * drag and drop gesture source after its data has
     * been dropped on a drop target. The {@code transferMode} of the
     * event shows what just happened at the drop target.
     * If {@code transferMode} has the value {@code MOVE}, then the source can
     * clear out its data. Clearing the source's data gives the appropriate
     * appearance to a user that the data has been moved by the drag and drop
     * gesture. A {@code transferMode} that has the value {@code NONE}
     * indicates that no data was transferred during the drag and drop gesture.
     * Positional data for the {@code DragEvent} is invalid.  Valid positional
     * data for the {@code DragEvent} is presented in the
     * {@link #onDragDroppedProperty() onDragDropped} event handler.
     * @return the function to be called when this scene is a drag and drop
     * gesture source after its data has been dropped on a drop target
     */
    public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDoneProperty() {
        if (onDragDone == null) {
            onDragDone = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(DragEvent.DRAG_DONE, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onDragDone&quot;;
                }
            };
        }
        return onDragDone;
    }

    /**
     * Confirms a potential drag and drop gesture that is recognized over this
     * {@code Scene}.
     * Can be called only from a DRAG_DETECTED event handler. The returned
     * {@link Dragboard} is used to transfer data during
     * the drag and drop gesture. Placing this {@code Scene}'s data on the
     * {@link Dragboard} also identifies this {@code Scene} as the source of
     * the drag and drop gesture.
     * More detail about drag and drop gestures is described in the overivew
     * of {@link DragEvent}.
     *
     * @see DragEvent
     * @param transferModes The supported {@code TransferMode}(s) of this {@code Node}
     * @return A {@code Dragboard} to place this {@code Scene}'s data on
     * @throws IllegalStateException if drag and drop cannot be started at this
     * moment (it's called outside of {@code DRAG_DETECTED} event handling).
     */
    public Dragboard startDragAndDrop(TransferMode... transferModes) {
        return startDragAndDrop(this, transferModes);
    }

    /**
     * Starts a full press-drag-release gesture with this scene as gesture
     * source. This method can be called only from a {@code DRAG_DETECTED} mouse
     * event handler. More detail about dragging gestures can be found
     * in the overview of {@link MouseEvent} and {@link MouseDragEvent}.
     *
     * @see MouseEvent
     * @see MouseDragEvent
     * @throws IllegalStateException if the full press-drag-release gesture
     * cannot be started at this moment (it's called outside of
     * {@code DRAG_DETECTED} event handling).
     * @since JavaFX 2.1
     */
    public void startFullDrag() {
        startFullDrag(this);
    }


    Dragboard startDragAndDrop(EventTarget source, TransferMode... transferModes) {
        Toolkit.getToolkit().checkFxUserThread();
        if (dndGesture == null ||
            (dndGesture.dragDetected != DragDetectedState.PROCESSING))
        {
            throw new IllegalStateException(&quot;Cannot start drag and drop &quot; +
                    &quot;outside of DRAG_DETECTED event handler&quot;);
        }

        Set&lt;TransferMode&gt; set = EnumSet.noneOf(TransferMode.class);
        for (TransferMode tm : InputEventUtils.safeTransferModes(transferModes)) {
            set.add(tm);
        }
        return dndGesture.startDrag(source, set);
    }

    void startFullDrag(EventTarget source) {
        Toolkit.getToolkit().checkFxUserThread();
        if (dndGesture.dragDetected != DragDetectedState.PROCESSING) {
            throw new IllegalStateException(&quot;Cannot start full drag &quot; +
                    &quot;outside of DRAG_DETECTED event handler&quot;);
        }

        if (dndGesture != null) {
            dndGesture.startFullPDR(source);
            return;
        }

        throw new IllegalStateException(&quot;Cannot start full drag when &quot;
                + &quot;mouse button is not pressed&quot;);
    }

    /***************************************************************************
     *                                                                         *
     *                           Keyboard Handling                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when some {@code Node} of this
     * {@code Scene} has input focus and a key has been pressed. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     */
    private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressed;

    public final void setOnKeyPressed(EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyPressedProperty().set(value);
    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyPressed() {
        return onKeyPressed == null ? null : onKeyPressed.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressedProperty() {
        if (onKeyPressed == null) {
            onKeyPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(KeyEvent.KEY_PRESSED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onKeyPressed&quot;;
                }
            };
        }
        return onKeyPressed;
    }

    /**
     * Defines a function to be called when some {@code Node} of this
     * {@code Scene} has input focus and a key has been released. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     */
    private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleased;

    public final void setOnKeyReleased(EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyReleasedProperty().set(value);
    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyReleased() {
        return onKeyReleased == null ? null : onKeyReleased.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleasedProperty() {
        if (onKeyReleased == null) {
            onKeyReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(KeyEvent.KEY_RELEASED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onKeyReleased&quot;;
                }
            };
        }
        return onKeyReleased;
    }

    /**
     * Defines a function to be called when some {@code Node} of this
     * {@code Scene} has input focus and a key has been typed. The function
     * is called only if the event hasn't been already consumed during its
     * capturing or bubbling phase.
     */
    private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTyped;

    public final void setOnKeyTyped(
            EventHandler&lt;? super KeyEvent&gt; value) {
        onKeyTypedProperty().set( value);

    }

    public final EventHandler&lt;? super KeyEvent&gt; getOnKeyTyped(
            ) {
        return onKeyTyped == null ? null : onKeyTyped.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTypedProperty(
    ) {
        if (onKeyTyped == null) {
            onKeyTyped = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(KeyEvent.KEY_TYPED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onKeyTyped&quot;;
                }
            };
        }
        return onKeyTyped;
    }

    /***************************************************************************
     *                                                                         *
     *                           Input Method Handling                         *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines a function to be called when this {@code Node}
     * has input focus and the input method text has changed.  If this
     * function is not defined in this {@code Node}, then it
     * receives the result string of the input method composition as a
     * series of {@code onKeyTyped} function calls.
     * &lt;p&gt;
     * When the {@code Node} loses the input focus, the JavaFX runtime
     * automatically commits the existing composed text if any.
     */
    private ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChanged;

    public final void setOnInputMethodTextChanged(
            EventHandler&lt;? super InputMethodEvent&gt; value) {
        onInputMethodTextChangedProperty().set( value);
    }

    public final EventHandler&lt;? super InputMethodEvent&gt; getOnInputMethodTextChanged() {
        return onInputMethodTextChanged == null ? null : onInputMethodTextChanged.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChangedProperty() {
        if (onInputMethodTextChanged == null) {
            onInputMethodTextChanged = new ObjectPropertyBase&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(InputMethodEvent.INPUT_METHOD_TEXT_CHANGED, get());
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;onInputMethodTextChanged&quot;;
                }
            };
        }
        return onInputMethodTextChanged;
    }

    /*
     * This class represents a picked target - either node, or scne, or null.
     * It provides functionality needed for the targets and covers the fact
     * that they are different kinds of animals.
     */
    private static class TargetWrapper {
        private Scene scene;
        private Node node;
        private PickResult result;

        /**
         * Fills the list with the target and all its parents (including scene)
         */
        public void fillHierarchy(final List&lt;EventTarget&gt; list) {
            list.clear();
            Node n = node;
            while(n != null) {
                list.add(n);
                final Parent p = n.getParent();
                n = p != null ? p : n.getSubScene();
            }

            if (scene != null) {
                list.add(scene);
            }
        }

        public EventTarget getEventTarget() {
            return node != null ? node : scene;
        }

        public Cursor getCursor() {
            Cursor cursor = null;
            if (node != null) {
                cursor = node.getCursor();
                Node n = node.getParent();
                while (cursor == null &amp;&amp; n != null) {
                    cursor = n.getCursor();

                    final Parent p = n.getParent();
                    n = p != null ? p : n.getSubScene();
                }
            }
            return cursor;
        }

        public void clear() {
            set(null, null);
            result = null;
        }

        public void setNodeResult(PickResult result) {
            if (result != null) {
                this.result = result;
                final Node n = result.getIntersectedNode();
                set(n, n.getScene());
            }
        }

        // Pass null scene if the mouse is outside of the window content
        public void setSceneResult(PickResult result, Scene scene) {
            if (result != null) {
                this.result = result;
                set(null, scene);
            }
        }

        public PickResult getResult() {
            return result;
        }

        public void copy(TargetWrapper tw) {
            node = tw.node;
            scene = tw.scene;
            result = tw.result;
        }

        private void set(Node n, Scene s) {
            node = n;
            scene = s;
        }
    }

    /*************************************************************************
    *                                                                        *
    *                                                                        *
    *                                                                        *
    *************************************************************************/

    private static final Object USER_DATA_KEY = new Object();
    // A map containing a set of properties for this scene
    private ObservableMap&lt;Object, Object&gt; properties;

    /**
      * Returns an observable map of properties on this node for use primarily
      * by application developers.
      *
      * @return an observable map of properties on this node for use primarily
      * by application developers
      *
      * @since JavaFX 8u40
      */
     public final ObservableMap&lt;Object, Object&gt; getProperties() {
        if (properties == null) {
            properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
        }
        return properties;
    }

    /**
     * Tests if Scene has properties.
     * @return true if node has properties.
     *
     * @since JavaFX 8u40
     */
     public boolean hasProperties() {
        return properties != null &amp;&amp; !properties.isEmpty();
    }

    /**
     * Convenience method for setting a single Object property that can be
     * retrieved at a later date. This is functionally equivalent to calling
     * the getProperties().put(Object key, Object value) method. This can later
     * be retrieved by calling {@link Scene#getUserData()}.
     *
     * @param value The value to be stored - this can later be retrieved by calling
     *          {@link Scene#getUserData()}.
     *
     * @since JavaFX 8u40
     */
    public void setUserData(Object value) {
        getProperties().put(USER_DATA_KEY, value);
    }

    /**
     * Returns a previously set Object property, or null if no such property
     * has been set using the {@link Scene#setUserData(java.lang.Object)} method.
     *
     * @return The Object that was previously set, or null if no property
     *          has been set or if null was set.
     *
     * @since JavaFX 8u40
     */
    public Object getUserData() {
        return getProperties().get(USER_DATA_KEY);
    }

    /***************************************************************************
     *                                                                         *
     *                       Component Orientation Properties                  *
     *                                                                         *
     **************************************************************************/

    private static final NodeOrientation defaultNodeOrientation =
        AccessController.doPrivileged(
                (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.scene.nodeOrientation.RTL&quot;)) ? NodeOrientation.RIGHT_TO_LEFT : NodeOrientation.INHERIT;



    private ObjectProperty&lt;NodeOrientation&gt; nodeOrientation;
    private EffectiveOrientationProperty effectiveNodeOrientationProperty;

    private NodeOrientation effectiveNodeOrientation;

    public final void setNodeOrientation(NodeOrientation orientation) {
        nodeOrientationProperty().set(orientation);
    }

    public final NodeOrientation getNodeOrientation() {
        return nodeOrientation == null ? defaultNodeOrientation : nodeOrientation.get();
    }

    /**
     * Property holding NodeOrientation.
     * &lt;p&gt;
     * Node orientation describes the flow of visual data within a node.
     * In the English speaking world, visual data normally flows from
     * left-to-right. In an Arabic or Hebrew world, visual data flows
     * from right-to-left.  This is consistent with the reading order
     * of text in both worlds.  The default value is left-to-right.
     * &lt;/p&gt;
     *
     * @return NodeOrientation
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;NodeOrientation&gt; nodeOrientationProperty() {
        if (nodeOrientation == null) {
            nodeOrientation = new StyleableObjectProperty&lt;NodeOrientation&gt;(defaultNodeOrientation) {
                @Override
                protected void invalidated() {
                    sceneEffectiveOrientationInvalidated();
                    getRoot().applyCss();
                }

                @Override
                public Object getBean() {
                    return Scene.this;
                }

                @Override
                public String getName() {
                    return &quot;nodeOrientation&quot;;
                }

                @Override
                public CssMetaData getCssMetaData() {
                    //TODO - not yet supported
                    throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
                }
            };
        }
        return nodeOrientation;
    }

    public final NodeOrientation getEffectiveNodeOrientation() {
        if (effectiveNodeOrientation == null) {
            effectiveNodeOrientation = calcEffectiveNodeOrientation();
        }

        return effectiveNodeOrientation;
    }

    /**
     * The effective node orientation of a scene resolves the inheritance of
     * node orientation, returning either left-to-right or right-to-left.
     * @return the effective node orientation of this scene
     * @since JavaFX 8.0
     */
    public final ReadOnlyObjectProperty&lt;NodeOrientation&gt;
            effectiveNodeOrientationProperty() {
        if (effectiveNodeOrientationProperty == null) {
            effectiveNodeOrientationProperty =
                    new EffectiveOrientationProperty();
        }

        return effectiveNodeOrientationProperty;
    }

    private void parentEffectiveOrientationInvalidated() {
        if (getNodeOrientation() == NodeOrientation.INHERIT) {
            sceneEffectiveOrientationInvalidated();
        }
    }

    private void sceneEffectiveOrientationInvalidated() {
        effectiveNodeOrientation = null;

        if (effectiveNodeOrientationProperty != null) {
            effectiveNodeOrientationProperty.invalidate();
        }

        getRoot().parentResolvedOrientationInvalidated();
    }

    private NodeOrientation calcEffectiveNodeOrientation() {
        NodeOrientation orientation = getNodeOrientation();
        if (orientation == NodeOrientation.INHERIT) {
            Window window = getWindow();
            if (window != null) {
                Window parent = null;
                if (window instanceof Stage) {
                    parent = ((Stage)window).getOwner();
                } else {
                    if (window instanceof PopupWindow) {
                        parent = ((PopupWindow)window).getOwnerWindow();
                    }
                }
                if (parent != null) {
                    Scene scene = parent.getScene();
                    if (scene != null) return scene.getEffectiveNodeOrientation();
                }
            }
            return NodeOrientation.LEFT_TO_RIGHT;
        }
        return orientation;
    }

    private final class EffectiveOrientationProperty
            extends ReadOnlyObjectPropertyBase&lt;NodeOrientation&gt; {
        @Override
        public NodeOrientation get() {
            return getEffectiveNodeOrientation();
        }

        @Override
        public Object getBean() {
            return Scene.this;
        }

        @Override
        public String getName() {
            return &quot;effectiveNodeOrientation&quot;;
        }

        public void invalidate() {
            fireValueChangedEvent();
        }
    }

    private Map&lt;Node, Accessible&gt; accMap;
    Accessible removeAccessible(Node node) {
        if (accMap == null) return null;
        return accMap.remove(node);
    }

    void addAccessible(Node node, Accessible acc) {
        if (accMap == null) {
            accMap = new HashMap&lt;Node, Accessible&gt;();
        }
        accMap.put(node, acc);
    }

    private void disposeAccessibles() {
        if (accMap != null) {
            for (Map.Entry&lt;Node, Accessible&gt; entry : accMap.entrySet()) {
                Node node = entry.getKey();
                Accessible acc = entry.getValue();
                if (node.accessible != null) {
                    /* This node has already been initialized to another scene.
                     * Note an accessible can be returned to the node before the
                     * pulse if getAccessible() is called. In which case it must
                     * already being removed from accMap.
                     */
                    if (node.accessible == acc) {
                        System.err.println(&quot;[A11y] 'node.accessible == acc' should never happen.&quot;);
                    }
                    if (node.getScene() == this) {
                        System.err.println(&quot;[A11y] 'node.getScene() == this' should never happen.&quot;);
                    }
                    acc.dispose();
                } else {
                    if (node.getScene() == this) {
                        node.accessible = acc;
                    } else {
                        acc.dispose();
                    }
                }
            }
            accMap.clear();
        }
    }

    private Accessible accessible;
    Accessible getAccessible() {
        /*
         * The accessible for the Scene should never be
         * requested when the peer is not set.
         * This can only happen in a error case where a
         * descender of this Scene was not disposed and
         * it still being used by the AT client and trying
         * to reach to the top level window.
         */
        if (peer == null) return null;
        if (accessible == null) {
            accessible = Application.GetApplication().createAccessible();
            accessible.setEventHandler(new Accessible.EventHandler() {
                @Override public AccessControlContext getAccessControlContext() {
                    return getPeer().getAccessControlContext();
                }

                @Override public Object getAttribute(AccessibleAttribute attribute,
                                                     Object... parameters) {
                    switch (attribute) {
                        case CHILDREN: {
                            Parent root = getRoot();
                            if (root != null) {
                                return FXCollections.observableArrayList(root);
                            }
                            break;
                        }
                        case TEXT: {
                            Window w = getWindow();
                            if (w instanceof Stage) {
                                return ((Stage)w).getTitle();
                            }
                            break;
                        }
                        case NODE_AT_POINT: {
                            Window window = getWindow();
                            /* is this screen to scene translation correct ? not considering camera ? */
                            Point2D pt = (Point2D)parameters[0];
                            PickResult res = pick(pt.getX() - getX() - window.getX(), pt.getY() - getY() - window.getY());
                            if (res != null) {
                                Node node = res.getIntersectedNode();
                                if (node != null) return node;
                            }
                            return getRoot();//not sure
                        }
                        case ROLE: return AccessibleRole.PARENT;
                        case SCENE: return Scene.this;
                        case FOCUS_NODE: {
                            if (transientFocusContainer != null) {
                                return transientFocusContainer.queryAccessibleAttribute(AccessibleAttribute.FOCUS_NODE);
                            }
                            return getFocusOwner();
                        }
                        default:
                    }
                    return super.getAttribute(attribute, parameters);
                }
            });
            PlatformImpl.accessibilityActiveProperty().set(true);
        }
        return accessible;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/SubScene.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene;

import com.sun.javafx.css.StyleManager;
import com.sun.javafx.scene.traversal.Direction;
import com.sun.javafx.scene.traversal.SubSceneTraversalEngine;
import com.sun.javafx.scene.traversal.TopMostTraversalEngine;
import javafx.application.ConditionalFeature;
import javafx.application.Platform;
import javafx.beans.NamedArg;
import javafx.beans.property.*;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Point3D;
import javafx.scene.input.PickResult;
import javafx.scene.paint.Paint;

import java.util.ArrayList;
import java.util.List;

import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.CssFlags;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.SubSceneHelper;
import com.sun.javafx.scene.input.PickResultChooser;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGLightBase;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.sg.prism.NGSubScene;
import com.sun.javafx.tk.Toolkit;

import com.sun.javafx.logging.PlatformLogger;

/**
 * The {@code SubScene} class is the container for content in a scene graph.
 * {@code SubScene} provides separation of different parts of a scene, each
 * of which can be rendered with a different camera, depth buffer, or scene
 * anti-aliasing. A {@code SubScene} is embedded into the main scene or another
 * sub-scene.
 * &lt;p&gt;
 * An application may request depth buffer support or scene anti-aliasing
 * support at the creation of a {@code SubScene}. A sub-scene with only 2D
 * shapes and without any 3D transforms does not need a depth buffer nor scene
 * anti-aliasing support. A sub-scene containing 3D shapes or 2D shapes with 3D
 * transforms may use depth buffer support for proper depth sorted rendering; to
 * avoid depth fighting (also known as Z fighting), disable depth testing on 2D
 * shapes that have no 3D transforms. See
 * {@link Node#depthTestProperty depthTest} for more information. A sub-scene
 * with 3D shapes may enable scene anti-aliasing to improve its rendering
 * quality.
 * &lt;p&gt;
 * The depthBuffer and antiAliasing flags are conditional features. With the
 * respective default values of: false and {@code SceneAntialiasing.DISABLED}.
 * See {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 * for more information.
 *
 * &lt;p&gt;
 * Possible use cases are:
 * &lt;ul&gt;
 * &lt;li&gt; Mixing 2D and 3D content &lt;/li&gt;
 * &lt;li&gt; Overlay for UI controls &lt;/li&gt;
 * &lt;li&gt; Underlay for background &lt;/li&gt;
 * &lt;li&gt; Heads-up display &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * A default headlight will be added to a {@code SubScene} that contains one or more
 * {@code Shape3D} nodes, but no light nodes. This light source is a
 * {@code Color.WHITE} {@code PointLight} placed at the camera position.
 * &lt;/p&gt;
 *
 * @since JavaFX 8.0
 */
public class SubScene extends Node {
    static {
        // This is used by classes in different packages to get access to
        // private and package private methods.
        SubSceneHelper.setSubSceneAccessor(new SubSceneHelper.SubSceneAccessor() {
            @Override
            public NGNode doCreatePeer(Node node) {
                return ((SubScene) node).doCreatePeer();
            }

            @Override
            public void doUpdatePeer(Node node) {
                ((SubScene) node).doUpdatePeer();
            }

            @Override
            public BaseBounds doComputeGeomBounds(Node node,
                    BaseBounds bounds, BaseTransform tx) {
                return ((SubScene) node).doComputeGeomBounds(bounds, tx);
            }

            @Override
            public boolean doComputeContains(Node node, double localX, double localY) {
                return ((SubScene) node).doComputeContains(localX, localY);
            }

            @Override
            public void doProcessCSS(Node node) {
                ((SubScene) node).doProcessCSS();
            }

            @Override
            public void doPickNodeLocal(Node node, PickRay localPickRay,
                    PickResultChooser result) {
                ((SubScene) node).doPickNodeLocal(localPickRay, result);
            }

            @Override
            public boolean isDepthBuffer(SubScene subScene) {
                return subScene.isDepthBufferInternal();
            };

            @Override
            public Camera getEffectiveCamera(SubScene subScene) {
                return subScene.getEffectiveCamera();
            }

        });
    }

    {
        // To initialize the class helper at the begining each constructor of this class
        SubSceneHelper.initHelper(this);
    }
    /**
     * Creates a {@code SubScene} for a specific root Node with a specific size.
     *
     * @param root The root node of the scene graph
     * @param width The width of the sub-scene
     * @param height The height of the sub-scene
     *
     * @throws NullPointerException if root is null
     */
    public SubScene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height) {
        this(root, width, height, false, SceneAntialiasing.DISABLED);
    }

    /**
     * Constructs a {@code SubScene} consisting of a root, with a dimension of width and
     * height, specifies whether a depth buffer is created for this scene and
     * specifies whether scene anti-aliasing is requested.
     * &lt;p&gt;
     * A sub-scene with only 2D shapes and without any 3D transforms does not
     * need a depth buffer nor scene anti-aliasing support. A sub-scene
     * containing 3D shapes or 2D shapes with 3D transforms may use depth buffer
     * support for proper depth sorted rendering; to avoid depth fighting (also
     * known as Z fighting), disable depth testing on 2D shapes that have no 3D
     * transforms. See {@link Node#depthTestProperty depthTest} for more
     * information. A sub-scene with 3D shapes may enable scene anti-aliasing to
     * improve its rendering quality.
     *
     * @param root The root node of the scene graph
     * @param width The width of the sub-scene
     * @param height The height of the sub-scene
     * @param depthBuffer The depth buffer flag
     * @param antiAliasing The sub-scene anti-aliasing attribute. A value of
     * {@code null} is treated as DISABLED.
     * &lt;p&gt;
     * The depthBuffer and antiAliasing flags are conditional features. With the
     * respective default values of: false and {@code SceneAntialiasing.DISABLED}.
     * See {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @throws NullPointerException if root is null
     *
     * @see javafx.scene.Node#setDepthTest(DepthTest)
     */
    public SubScene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height,
            @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer, @NamedArg(&quot;antiAliasing&quot;) SceneAntialiasing antiAliasing)
    {
        this.depthBuffer = depthBuffer;
        this.antiAliasing = antiAliasing;
        boolean isAntiAliasing = !(antiAliasing == null || antiAliasing == SceneAntialiasing.DISABLED);
        setRoot(root);
        setWidth(width);
        setHeight(height);

        if ((depthBuffer || isAntiAliasing) &amp;&amp; !is3DSupported) {
            String logname = SubScene.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;System can't support &quot;
                    + &quot;ConditionalFeature.SCENE3D&quot;);
        }
        if (isAntiAliasing &amp;&amp; !Toolkit.getToolkit().isMSAASupported()) {
            String logname = SubScene.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;System can't support &quot;
                    + &quot;antiAliasing&quot;);
        }
    }

    private static boolean is3DSupported =
            Platform.isSupported(ConditionalFeature.SCENE3D);

    private final SceneAntialiasing antiAliasing;

    /**
     * Return the defined {@code SceneAntialiasing} for this {@code SubScene}.
     * &lt;p&gt;
     * Note: this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * and {@link javafx.scene.SceneAntialiasing SceneAntialiasing}
     * for more information.
     * @return the SceneAntialiasing for this sub-scene
     * @since JavaFX 8.0
     */
    public final SceneAntialiasing getAntiAliasing() {
        return antiAliasing;
    }

    private final boolean depthBuffer;

    /**
     * Retrieves the depth buffer attribute for this {@code SubScene}.
     * @return the depth buffer attribute.
     */
    public final boolean isDepthBuffer() {
        return depthBuffer;
    }

    private boolean isDepthBufferInternal() {
        return is3DSupported ? depthBuffer : false;
    }

    /**
     * Defines the root {@code Node} of the {@code SubScene} scene graph.
     * If a {@code Group} is used as the root, the
     * contents of the scene graph will be clipped by the {@code SubScene}'s width and height.
     *
     * {@code SubScene} doesn't accept null root.
     *
     */
    private ObjectProperty&lt;Parent&gt; root;

    public final void setRoot(Parent value) {
        rootProperty().set(value);
    }

    public final Parent getRoot() {
        return root == null ? null : root.get();
    }

    public final ObjectProperty&lt;Parent&gt; rootProperty() {
        if (root == null) {
            root = new ObjectPropertyBase&lt;Parent&gt;() {
                private Parent oldRoot;

                private void forceUnbind() {
                    System.err.println(&quot;Unbinding illegal root.&quot;);
                    unbind();
                }

                @Override
                protected void invalidated() {
                    Parent _value = get();

                    if (_value == null) {
                        if (isBound()) { forceUnbind(); }
                        throw new NullPointerException(&quot;Scene's root cannot be null&quot;);
                    }
                    if (_value.getParent() != null) {
                        if (isBound()) { forceUnbind(); }
                        throw new IllegalArgumentException(_value +
                                &quot;is already inside a scene-graph and cannot be set as root&quot;);
                    }
                    if (_value.getClipParent() != null) {
                        if (isBound()) forceUnbind();
                        throw new IllegalArgumentException(_value +
                                &quot;is set as a clip on another node, so cannot be set as root&quot;);
                    }
                    if ((_value.getScene() != null &amp;&amp;
                            _value.getScene().getRoot() == _value) ||
                            (_value.getSubScene() != null &amp;&amp;
                            _value.getSubScene().getRoot() == _value &amp;&amp;
                            _value.getSubScene() != SubScene.this))
                    {
                        if (isBound()) { forceUnbind(); }
                        throw new IllegalArgumentException(_value +
                                &quot;is already set as root of another scene or subScene&quot;);
                    }

                    // disabled, isTreeVisible and isTreeShowing properties are inherited
                    _value.setTreeVisible(isTreeVisible());
                    _value.setDisabled(isDisabled());
                    _value.setTreeShowing(isTreeShowing());

                    if (oldRoot != null) {
                        StyleManager.getInstance().forget(SubScene.this);
                        oldRoot.setScenes(null, null);
                    }
                    oldRoot = _value;
                    _value.getStyleClass().add(0, &quot;root&quot;);
                    _value.setScenes(getScene(), SubScene.this);
                    markDirty(SubSceneDirtyBits.ROOT_SG_DIRTY);
                    _value.resize(getWidth(), getHeight()); // maybe no-op if root is not resizable
                    _value.requestLayout();
                }

                @Override
                public Object getBean() {
                    return SubScene.this;
                }

                @Override
                public String getName() {
                    return &quot;root&quot;;
                }
            };
        }
        return root;
    }

    /**
     * Specifies the type of camera use for rendering this {@code SubScene}.
     * If {@code camera} is null, a parallel camera is used for rendering.
     * It is illegal to set a camera that belongs to other {@code Scene}
     * or {@code SubScene}.
     * &lt;p&gt;
     * Note: this is a conditional feature. See
     * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
     * for more information.
     *
     * @defaultValue null
     */
    private ObjectProperty&lt;Camera&gt; camera;

    public final void setCamera(Camera value) {
        cameraProperty().set(value);
    }

    public final Camera getCamera() {
        return camera == null ? null : camera.get();
    }

    public final ObjectProperty&lt;Camera&gt; cameraProperty() {
        if (camera == null) {
            camera = new ObjectPropertyBase&lt;Camera&gt;() {
                Camera oldCamera = null;

                @Override
                protected void invalidated() {
                    Camera _value = get();
                    if (_value != null) {
                        if (_value instanceof PerspectiveCamera
                                &amp;&amp; !SubScene.is3DSupported) {
                            String logname = SubScene.class.getName();
                            PlatformLogger.getLogger(logname).warning(&quot;System can't support &quot;
                                    + &quot;ConditionalFeature.SCENE3D&quot;);
                        }
                        // Illegal value if it belongs to any scene or other subscene
                        if ((_value.getScene() != null || _value.getSubScene() != null)
                                &amp;&amp; (_value.getScene() != getScene() || _value.getSubScene() != SubScene.this)) {
                            throw new IllegalArgumentException(_value
                                    + &quot;is already part of other scene or subscene&quot;);
                        }
                        // throws exception if the camera already has a different owner
                        _value.setOwnerSubScene(SubScene.this);
                        _value.setViewWidth(getWidth());
                        _value.setViewHeight(getHeight());
                    }
                    markDirty(SubSceneDirtyBits.CAMERA_DIRTY);
                    if (oldCamera != null &amp;&amp; oldCamera != _value) {
                        oldCamera.setOwnerSubScene(null);
                    }
                    oldCamera = _value;
                }

                @Override
                public Object getBean() {
                    return SubScene.this;
                }

                @Override
                public String getName() {
                    return &quot;camera&quot;;
                }
            };
        }
        return camera;
    }

    private Camera defaultCamera;

    Camera getEffectiveCamera() {
        final Camera cam = getCamera();
        if (cam == null
                || (cam instanceof PerspectiveCamera &amp;&amp; !is3DSupported)) {
            if (defaultCamera == null) {
                defaultCamera = new ParallelCamera();
                defaultCamera.setOwnerSubScene(this);
                defaultCamera.setViewWidth(getWidth());
                defaultCamera.setViewHeight(getHeight());
            }
            return defaultCamera;
        }

        return cam;
    }

    // Used by the camera
    final void markContentDirty() {
        markDirty(SubSceneDirtyBits.CONTENT_DIRTY);
    }

    /**
     * Defines the width of this {@code SubScene}
     *
     * @defaultValue 0.0
     */
    private DoubleProperty width;

    public final void setWidth(double value) {
        widthProperty().set(value);
    }

    public final double getWidth() {
        return width == null ? 0.0 : width.get();
    }

    public final DoubleProperty widthProperty() {
        if (width == null) {
            width = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    final Parent _root = getRoot();
                    //TODO - use a better method to update mirroring
                    if (_root.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
                        NodeHelper.transformsChanged(_root);
                    }
                    if (_root.isResizable()) {
                        _root.resize(get() - _root.getLayoutX() - _root.getTranslateX(), _root.getLayoutBounds().getHeight());
                    }
                    markDirty(SubSceneDirtyBits.SIZE_DIRTY);
                    NodeHelper.geomChanged(SubScene.this);

                    getEffectiveCamera().setViewWidth(get());
                }

                @Override
                public Object getBean() {
                    return SubScene.this;
                }

                @Override
                public String getName() {
                    return &quot;width&quot;;
                }
            };
        }
        return width;
    }

    /**
     * Defines the height of this {@code SubScene}
     *
     * @defaultValue 0.0
     */
    private DoubleProperty height;

    public final void setHeight(double value) {
        heightProperty().set(value);
    }

    public final double getHeight() {
        return height == null ? 0.0 : height.get();
    }

    public final DoubleProperty heightProperty() {
        if (height == null) {
            height = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    final Parent _root = getRoot();
                    if (_root.isResizable()) {
                        _root.resize(_root.getLayoutBounds().getWidth(), get() - _root.getLayoutY() - _root.getTranslateY());
                    }
                    markDirty(SubSceneDirtyBits.SIZE_DIRTY);
                    NodeHelper.geomChanged(SubScene.this);

                    getEffectiveCamera().setViewHeight(get());
                }

                @Override
                public Object getBean() {
                    return SubScene.this;
                }

                @Override
                public String getName() {
                    return &quot;height&quot;;
                }
            };
        }
        return height;
    }

    /**
     * Defines the background fill of this {@code SubScene}. Both a {@code null}
     * value meaning paint no background and a {@link javafx.scene.paint.Paint}
     * with transparency are supported. The default value is null.
     *
     * @defaultValue null
     */
    private ObjectProperty&lt;Paint&gt; fill;

    public final void setFill(Paint value) {
        fillProperty().set(value);
    }

    public final Paint getFill() {
        return fill == null ? null : fill.get();
    }

    public final ObjectProperty&lt;Paint&gt; fillProperty() {
        if (fill == null) {
            fill = new ObjectPropertyBase&lt;Paint&gt;(null) {

                @Override
                protected void invalidated() {
                    markDirty(SubSceneDirtyBits.FILL_DIRTY);
                }

                @Override
                public Object getBean() {
                    return SubScene.this;
                }

                @Override
                public String getName() {
                    return &quot;fill&quot;;
                }
            };
        }
        return fill;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        // TODO deal with clip node

        dirtyNodes = false;
        if (isDirty()) {
            NGSubScene peer = getPeer();
            final Camera cam = getEffectiveCamera();
            boolean contentChanged = false;
            if (cam.getSubScene() == null &amp;&amp;
                    isDirty(SubSceneDirtyBits.CONTENT_DIRTY)) {
                // When camera is not a part of the graph, then its
                // owner(subscene) must take care of syncing it. And when a
                // property on the camera changes it will mark subscenes
                // CONTENT_DIRTY.
                cam.syncPeer();
            }
            if (isDirty(SubSceneDirtyBits.FILL_DIRTY)) {
                Object platformPaint = getFill() == null ? null :
                        Toolkit.getPaintAccessor().getPlatformPaint(getFill());
                peer.setFillPaint(platformPaint);
                contentChanged = true;
            }
            if (isDirty(SubSceneDirtyBits.SIZE_DIRTY)) {
                // Note change in size is a geom change and is handled by peer
                peer.setWidth((float)getWidth());
                peer.setHeight((float)getHeight());
            }
            if (isDirty(SubSceneDirtyBits.CAMERA_DIRTY)) {
                peer.setCamera((NGCamera) cam.getPeer());
                contentChanged = true;
            }
            if (isDirty(SubSceneDirtyBits.ROOT_SG_DIRTY)) {
                peer.setRoot(getRoot().getPeer());
                contentChanged = true;
            }
            contentChanged |= syncLights();
            if (contentChanged || isDirty(SubSceneDirtyBits.CONTENT_DIRTY)) {
                peer.markContentDirty();
            }

            clearDirtyBits();
        }

    }

    @Override
    void nodeResolvedOrientationChanged() {
        getRoot().parentResolvedOrientationInvalidated();
    }

    /***********************************************************************
     *                         CSS                                         *
     **********************************************************************/
    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doProcessCSS() {
        // Nothing to do...
        if (cssFlag == CssFlags.CLEAN) { return; }

        if (getRoot().cssFlag == CssFlags.CLEAN) {
            getRoot().cssFlag = cssFlag;
        }
        SubSceneHelper.superProcessCSS(this);
        getRoot().processCSS();
    }

    @Override
    void processCSS() {
        Parent root = getRoot();
        if (root.isDirty(DirtyBits.NODE_CSS)) {
            root.clearDirty(DirtyBits.NODE_CSS);
            if (cssFlag == CssFlags.CLEAN) { cssFlag = CssFlags.UPDATE; }
        }
        super.processCSS();
    }

    private ObjectProperty&lt;String&gt; userAgentStylesheet = null;
    /**
     * @return the userAgentStylesheet property.
     * @see #getUserAgentStylesheet()
     * @see #setUserAgentStylesheet(String)
     * @since  JavaFX 8u20
     */
    public final ObjectProperty&lt;String&gt; userAgentStylesheetProperty() {
        if (userAgentStylesheet == null) {
            userAgentStylesheet = new SimpleObjectProperty&lt;String&gt;(SubScene.this, &quot;userAgentStylesheet&quot;, null) {
                @Override protected void invalidated() {
                    StyleManager.getInstance().forget(SubScene.this);
                    reapplyCSS();
                }
            };
        }
        return userAgentStylesheet;
    }

    /**
     * Get the URL of the user-agent stylesheet that will be used by this SubScene. If the URL has not been set,
     * the platform-default user-agent stylesheet will be used.
     * &lt;p&gt;
     * For additional information about using CSS with the scene graph,
     * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     * &lt;/p&gt;
     * @return The URL of the user-agent stylesheet that will be used by this SubScene,
     * or null if has not been set.
     * @since  JavaFX 8u20
     */
    public final String getUserAgentStylesheet() {
        return userAgentStylesheet == null ? null : userAgentStylesheet.get();
    }

    /**
     * Set the URL of the user-agent stylesheet that will be used by this SubScene in place of the
     * the platform-default user-agent stylesheet. If the URL does not resolve to a valid location,
     * the platform-default user-agent stylesheet will be used.
     * &lt;p&gt;
     * For additional information about using CSS with the scene graph,
     * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     * &lt;/p&gt;
     * @param url The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
     * does not have a [scheme:] component, the URL is considered to be the [path] component only.
     * Any leading '/' character of the [path] is ignored and the [path] is treated as a path relative to
     * the root of the application's classpath.
     * @since  JavaFX 8u20
     */
    public final void setUserAgentStylesheet(String url) {
        userAgentStylesheetProperty().set(url);
    }

    @Override void updateBounds() {
        super.updateBounds();
        getRoot().updateBounds();
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private NGNode doCreatePeer() {
        if (!is3DSupported) {
            return new NGSubScene(false, false);
        }
        boolean aa = !(antiAliasing == null || antiAliasing == SceneAntialiasing.DISABLED);
        return new NGSubScene(depthBuffer, aa &amp;&amp; Toolkit.getToolkit().isMSAASupported());
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {
        int w = (int)Math.ceil(width.get());
        int h = (int)Math.ceil(height.get());
        bounds = bounds.deriveWithNewBounds(0.0f, 0.0f, 0.0f,
                                            w, h, 0.0f);
        bounds = tx.transform(bounds, bounds);
        return bounds;
    }

    /***********************************************************************
     *                         Dirty Bits                                  *
     **********************************************************************/
    boolean dirtyLayout = false;
    void setDirtyLayout(Parent p) {
        if (!dirtyLayout &amp;&amp; p != null &amp;&amp; p.getSubScene() == this &amp;&amp;
                this.getScene() != null) {
            dirtyLayout = true;
            markDirtyLayoutBranch();
            markDirty(SubSceneDirtyBits.CONTENT_DIRTY);
        }
    }

    private boolean dirtyNodes = false;
    void setDirty(Node n) {
        if (!dirtyNodes &amp;&amp; n != null &amp;&amp; n.getSubScene() == this &amp;&amp;
                this.getScene() != null) {
            dirtyNodes = true;
            markDirty(SubSceneDirtyBits.CONTENT_DIRTY);
        }
    }

    void layoutPass() {
        if (dirtyLayout) {
            Parent r = getRoot();
            if (r != null) {
                r.layout();
            }
            dirtyLayout = false;
        }
    }

    private TopMostTraversalEngine traversalEngine = new SubSceneTraversalEngine(this);

    boolean traverse(Node node, Direction dir) {
        return traversalEngine.trav(node, dir) != null;
    }

    private enum SubSceneDirtyBits {
        SIZE_DIRTY,
        FILL_DIRTY,
        ROOT_SG_DIRTY,
        CAMERA_DIRTY,
        LIGHTS_DIRTY,
        CONTENT_DIRTY;

        private int mask;

        private SubSceneDirtyBits() { mask = 1 &lt;&lt; ordinal(); }

        public final int getMask() { return mask; }
    }

    private int dirtyBits = ~0;

    private void clearDirtyBits() { dirtyBits = 0; }

    private boolean isDirty() { return dirtyBits != 0; }

    // Should not be called directly, instead use markDirty
    private void setDirty(SubSceneDirtyBits dirtyBit) {
        this.dirtyBits |= dirtyBit.getMask();
    }

    private boolean isDirty(SubSceneDirtyBits dirtyBit) {
        return ((this.dirtyBits &amp; dirtyBit.getMask()) != 0);
    }

    private void markDirty(SubSceneDirtyBits dirtyBit) {
        if (!isDirty()) {
            // Force SubScene to redraw
            NodeHelper.markDirty(this, DirtyBits.NODE_CONTENTS);
        }
        setDirty(dirtyBit);
    }

    /***********************************************************************
     *                           Picking                                   *
     **********************************************************************/

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeContains(double localX, double localY) {
        if (subSceneComputeContains(localX, localY)) {
            return true;
        } else {
            return NodeHelper.computeContains(getRoot(), localX, localY);
        }
    }

    /**
     * Determines whether {@code SubScene} contains the given point.
     * It does not consider the contained nodes, only {@code SubScene}'s
     * size and fills.
     * @param localX horizontal coordinate in the local space of the {@code SubScene} node
     * @param localY vertical coordinate in the local space of the {@code SubScene} node
     * @return true if the point is inside {@code SubScene}'s area covered by its fill
     */
    private boolean subSceneComputeContains(double localX, double localY) {
        if (localX &lt; 0 || localY &lt; 0 || localX &gt; getWidth() || localY &gt; getHeight()) {
            return false;
        }
        return getFill() != null;
    }

    /*
     * Generates a pick ray based on local coordinates and camera. Then finds a
     * top-most child node that intersects the pick ray.
     */
    private PickResult pickRootSG(double localX, double localY) {
        final double viewWidth = getWidth();
        final double viewHeight = getHeight();
        if (localX &lt; 0 || localY &lt; 0 || localX &gt; viewWidth || localY &gt; viewHeight) {
            return null;
        }
        final PickResultChooser result = new PickResultChooser();
        final PickRay pickRay = getEffectiveCamera().computePickRay(localX, localY, new PickRay());
        pickRay.getDirectionNoClone().normalize();
        getRoot().pickNode(pickRay, result);
        return result.toPickResult();
    }

    /**
     * Finds a top-most child node that contains the given local coordinates.
     *
     * Returns the picked node, null if no such node was found.
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doPickNodeLocal(PickRay localPickRay, PickResultChooser result) {
        final double boundsDistance = intersectsBounds(localPickRay);
        if (!Double.isNaN(boundsDistance) &amp;&amp; result.isCloser(boundsDistance)) {
            final Point3D intersectPt = PickResultChooser.computePoint(
                    localPickRay, boundsDistance);
            final PickResult subSceneResult =
                    pickRootSG(intersectPt.getX(), intersectPt.getY());
            if (subSceneResult != null) {
                result.offerSubScenePickResult(this, subSceneResult, boundsDistance);
            } else if (isPickOnBounds() ||
                    subSceneComputeContains(intersectPt.getX(), intersectPt.getY())) {
                result.offer(this, boundsDistance, intersectPt);
            }
        }
    }

    private List&lt;LightBase&gt; lights = new ArrayList&lt;&gt;();

    // @param light must not be null
    final void addLight(LightBase light) {
        if (!lights.contains(light)) {
            markDirty(SubSceneDirtyBits.LIGHTS_DIRTY);
            lights.add(light);
        }
    }

    final void removeLight(LightBase light) {
        if (lights.remove(light)) {
            markDirty(SubSceneDirtyBits.LIGHTS_DIRTY);
        }
    }

    /**
     * PG Light synchronizer.
     */
    private boolean syncLights() {
<A NAME="33"></A>        boolean lightOwnerChanged = false;
        if (!isDirty(SubSceneDirtyBits.LIGHTS_DIRTY)) {
            return lightOwnerChanged;
        <FONT color="#736aff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#33',2,'match37-top.html#33',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
        NGSubScene pgSubScene = getPeer();
        NGLightBase peerLights[] = pgSubScene.getLights();
        if (!lights.isEmpty() || (peerLights != null)) {
            if (lights.isEmpty()) {
                pgSubScene.setLights(null);
            }</B></FONT> else {
                if (peerLights == null || peerLights.length &lt; lights.size()) {
                    peerLights = new NGLightBase[lights.size()];
                }
                int i = 0;
                for (; i &lt; lights.size(); i++) {
                    peerLights[i] = lights.get(i).getPeer();
                }
                // Clear the rest of the list
                while (i &lt; peerLights.length &amp;&amp; peerLights[i] != null) {
                    peerLights[i++] = null;
                }
                pgSubScene.setLights(peerLights);
            }
            lightOwnerChanged = true;
        }
        return lightOwnerChanged;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/image/ImageView.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.image;

import com.sun.javafx.beans.event.AbstractNotifyListener;
import com.sun.javafx.css.StyleManager;
import javafx.css.converter.URLConverter;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.ImageViewHelper;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.sg.prism.NGImageView;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.tk.Toolkit;
import javafx.beans.DefaultProperty;
import javafx.beans.Observable;
import javafx.beans.property.*;
import javafx.css.CssMetaData;
import javafx.css.Styleable;
import javafx.css.StyleableProperty;
import javafx.css.StyleableStringProperty;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Rectangle2D;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * The {@code ImageView} is a {@code Node} used for painting images loaded with
 * {@link Image} class.
 *
 * &lt;p&gt;
 * This class allows resizing the displayed image (with or without preserving
 * the original aspect ratio) and specifying a viewport into the source image
 * for restricting the pixels displayed by this {@code ImageView}.
 * &lt;/p&gt;
 *
 *
 * &lt;p&gt;
 * Example code for displaying images
 * &lt;/p&gt;
 *
 * &lt;pre&gt;&lt;code&gt;
 * import javafx.application.Application;
 * import javafx.geometry.Rectangle2D;
 * import javafx.scene.Group;
 * import javafx.scene.Scene;
 * import javafx.scene.image.Image;
 * import javafx.scene.image.ImageView;
 * import javafx.scene.layout.HBox;
 * import javafx.scene.paint.Color;
 * import javafx.stage.Stage;
 *
 * public class HelloImageView extends Application {
 *
 *     {@literal @Override} public void start(Stage stage) {
 *         // load the image
 *         Image image = new Image(&quot;flower.png&quot;);
 *
 *         // simple displays ImageView the image as is
 *         ImageView iv1 = new ImageView();
 *         iv1.setImage(image);
 *
 *         // resizes the image to have width of 100 while preserving the ratio and using
 *         // higher quality filtering method; this ImageView is also cached to
 *         // improve performance
 *         ImageView iv2 = new ImageView();
 *         iv2.setImage(image);
 *         iv2.setFitWidth(100);
 *         iv2.setPreserveRatio(true);
 *         iv2.setSmooth(true);
 *         iv2.setCache(true);
 *
 *         // defines a viewport into the source image (achieving a &quot;zoom&quot; effect) and
 *         // displays it rotated
 *         ImageView iv3 = new ImageView();
 *         iv3.setImage(image);
 *         Rectangle2D viewportRect = new Rectangle2D(40, 35, 110, 110);
 *         iv3.setViewport(viewportRect);
 *         iv3.setRotate(90);
 *
 *         Group root = new Group();
 *         Scene scene = new Scene(root);
 *         scene.setFill(Color.BLACK);
 *         HBox box = new HBox();
 *         box.getChildren().add(iv1);
 *         box.getChildren().add(iv2);
 *         box.getChildren().add(iv3);
 *         root.getChildren().add(box);
 *
 *         stage.setTitle(&quot;ImageView&quot;);
 *         stage.setWidth(415);
 *         stage.setHeight(200);
 *         stage.setScene(scene);
 *         stage.sizeToScene();
 *         stage.show();
 *     }
 *
 *     public static void main(String[] args) {
 *         Application.launch(args);
 *     }
 * }
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 * The code above produces the following:
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;img src=&quot;doc-files/imageview.png&quot; alt=&quot;A visual rendering of the ImageView example&quot;&gt;
 * &lt;/p&gt;
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;image&quot;)
public class ImageView extends Node {
    static {
         // This is used by classes in different packages to get access to
         // private and package private methods.
        ImageViewHelper.setImageViewAccessor(new ImageViewHelper.ImageViewAccessor() {
            @Override
            public NGNode doCreatePeer(Node node) {
                return ((ImageView) node).doCreatePeer();
            }

            @Override
            public void doUpdatePeer(Node node) {
                ((ImageView) node).doUpdatePeer();
            }

            @Override
            public BaseBounds doComputeGeomBounds(Node node,
            BaseBounds bounds, BaseTransform tx) {
                return ((ImageView) node).doComputeGeomBounds(bounds, tx);
            }

            @Override
            public boolean doComputeContains(Node node, double localX, double localY) {
                return ((ImageView) node).doComputeContains(localX, localY);
            }
        });
    }

    {
        // To initialize the class helper at the begining each constructor of this class
        ImageViewHelper.initHelper(this);
    }
    /**
     * Allocates a new ImageView object.
     */
    public ImageView() {
        getStyleClass().add(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.IMAGE_VIEW);
        setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
    }

    /**
     * Allocates a new ImageView object with image loaded from the specified
     * URL.
     * &lt;p&gt;
     * The {@code new ImageView(url)} has the same effect as
     * {@code new ImageView(new Image(url))}.
     * &lt;/p&gt;
     *
     * @param url the string representing the URL from which to load the image
     * @throws NullPointerException if URL is null
     * @throws IllegalArgumentException if URL is invalid or unsupported
     * @since JavaFX 2.1
     */
    public ImageView(String url) {
        this(new Image(url));
    }

    /**
     * Allocates a new ImageView object using the given image.
     *
     * @param image Image that this ImageView uses
     */
    public ImageView(Image image) {
        getStyleClass().add(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.IMAGE_VIEW);
        setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
        setImage(image);
    }

    /**
     * The {@link Image} to be painted by this {@code ImageView}.
     *
     * @defaultValue null
     */
    private ObjectProperty&lt;Image&gt; image;

    public final void setImage(Image value) {
        imageProperty().set(value);
    }
    public final Image getImage() {
        return image == null ? null : image.get();
    }

    private Image oldImage;
    public final ObjectProperty&lt;Image&gt; imageProperty() {
        if (image == null) {
            image = new ObjectPropertyBase&lt;Image&gt;() {

                private boolean needsListeners = false;

                @Override
                public void invalidated() {
                    Image _image = get();
                    boolean dimensionChanged = _image == null || oldImage == null ||
                                                (oldImage.getWidth() != _image.getWidth() ||
                                                oldImage.getHeight() != _image.getHeight());

                    if (needsListeners) {
                        Toolkit.getImageAccessor().getImageProperty(oldImage).
                                removeListener(platformImageChangeListener.getWeakListener());
                    }

                    needsListeners = _image != null &amp;&amp; (_image.isAnimation() || _image.getProgress() &lt; 1);
                    oldImage = _image;

                    if (needsListeners) {
                        Toolkit.getImageAccessor().getImageProperty(_image).
                                addListener(platformImageChangeListener.getWeakListener());
                    }
                    if (dimensionChanged) {
                        invalidateWidthHeight();
                        NodeHelper.geomChanged(ImageView.this);
                    }
                    NodeHelper.markDirty(ImageView.this, DirtyBits.NODE_CONTENTS);
                }

                @Override
                public Object getBean() {
                    return ImageView.this;
                }

                @Override
                public String getName() {
                    return &quot;image&quot;;
                }
            };
        }
        return image;
    }

    private StringProperty imageUrl = null;
    /**
     * The imageUrl property is set from CSS and then the image property is
     * set from the invalidated method. This ensures that the same image isn't
     * reloaded.
     */
    private StringProperty imageUrlProperty() {
        if (imageUrl == null) {
            imageUrl = new StyleableStringProperty() {

                @Override
                protected void invalidated() {

                    final String imageUrl = get();
                    if (imageUrl != null) {
                        setImage(StyleManager.getInstance().getCachedImage(imageUrl));
                    } else {
                        setImage(null);
                    }
                }

                @Override
                public Object getBean() {
                    return ImageView.this;
                }

                @Override
                public String getName() {
                    return &quot;imageUrl&quot;;
                }

                @Override
                public CssMetaData&lt;ImageView,String&gt; getCssMetaData() {
                    return StyleableProperties.IMAGE;
                }

            };
        }
        return imageUrl;
    }

    private final AbstractNotifyListener platformImageChangeListener =
            new AbstractNotifyListener() {
        @Override
        public void invalidated(Observable valueModel) {
            invalidateWidthHeight();
            NodeHelper.markDirty(ImageView.this, DirtyBits.NODE_CONTENTS);
            NodeHelper.geomChanged(ImageView.this);
        }
    };
    /**
     * The current x coordinate of the {@code ImageView} origin.
     *
     * @defaultValue 0
     */
    private DoubleProperty x;


    public final void setX(double value) {
        xProperty().set(value);
    }

    public final double getX() {
        return x == null ? 0.0 : x.get();
    }

    public final DoubleProperty xProperty() {
        if (x == null) {
            x = new DoublePropertyBase() {

                @Override
                protected void invalidated() {
                    NodeHelper.markDirty(ImageView.this, DirtyBits.NODE_GEOMETRY);
                    NodeHelper.geomChanged(ImageView.this);
                }

                @Override
                public Object getBean() {
                    return ImageView.this;
                }

                @Override
                public String getName() {
                    return &quot;x&quot;;
                }
            };
        }
        return x;
    }

    /**
     * The current y coordinate of the {@code ImageView} origin.
     *
     * @defaultValue 0
     */
    private DoubleProperty y;


    public final void setY(double value) {
        yProperty().set(value);
    }

    public final double getY() {
        return y == null ? 0.0 : y.get();
    }

    public final DoubleProperty yProperty() {
        if (y == null) {
            y = new DoublePropertyBase() {

                @Override
                protected void invalidated() {
                    NodeHelper.markDirty(ImageView.this, DirtyBits.NODE_GEOMETRY);
                    NodeHelper.geomChanged(ImageView.this);
                }

                @Override
                public Object getBean() {
                    return ImageView.this;
                }

                @Override
                public String getName() {
                    return &quot;y&quot;;
                }
            };
        }
        return y;
    }

    /**
     * The width of the bounding box within which the source image is resized as
     * necessary to fit. If set to a value &amp;lt;= 0, then the intrinsic width of the
     * image will be used as the {@code fitWidth}.
     * &lt;p&gt;
     * See {@link #preserveRatioProperty() preserveRatio} for information on interaction between image
     * view's {@code fitWidth}, {@code fitHeight} and {@code preserveRatio}
     * attributes.
     *
     * @defaultValue 0
     */
    private DoubleProperty fitWidth;


    public final void setFitWidth(double value) {
        fitWidthProperty().set(value);
    }

    public final double getFitWidth() {
        return fitWidth == null ? 0.0 : fitWidth.get();
    }

    public final DoubleProperty fitWidthProperty() {
        if (fitWidth == null) {
            fitWidth = new DoublePropertyBase() {

                @Override
                protected void invalidated() {
                    invalidateWidthHeight();
                    NodeHelper.markDirty(ImageView.this, DirtyBits.NODE_VIEWPORT);
                    NodeHelper.geomChanged(ImageView.this);
                }

                @Override
                public Object getBean() {
                    return ImageView.this;
                }

                @Override
                public String getName() {
                    return &quot;fitWidth&quot;;
                }
            };
        }
        return fitWidth;
    }

    /**
     * The height of the bounding box within which the source image is resized
     * as necessary to fit. If set to a value &amp;lt;= 0, then the intrinsic height of
     * the image will be used as the {@code fitHeight}.
     * &lt;p&gt;
     * See {@link #preserveRatioProperty() preserveRatio} for information on interaction between image
     * view's {@code fitWidth}, {@code fitHeight} and {@code preserveRatio}
     * attributes.
     * &lt;/p&gt;
     *
     * @defaultValue 0
     */
    private DoubleProperty fitHeight;


    public final void setFitHeight(double value) {
        fitHeightProperty().set(value);
    }

    public final double getFitHeight() {
        return fitHeight == null ? 0.0 : fitHeight.get();
    }

    public final DoubleProperty fitHeightProperty() {
        if (fitHeight == null) {
            fitHeight = new DoublePropertyBase() {

                @Override
                protected void invalidated() {
                    invalidateWidthHeight();
                    NodeHelper.markDirty(ImageView.this, DirtyBits.NODE_VIEWPORT);
                    NodeHelper.geomChanged(ImageView.this);
                }

                @Override
                public Object getBean() {
                    return ImageView.this;
                }

                @Override
                public String getName() {
                    return &quot;fitHeight&quot;;
                }
            };
        }
        return fitHeight;
    }

    /**
     * Indicates whether to preserve the aspect ratio of the source image when
     * scaling to fit the image within the fitting bounding box.
     * &lt;p&gt;
     * If set to {@code true}, it affects the dimensions of this
     * {@code ImageView} in the following way
     * &lt;ul&gt;
     * &lt;li&gt;If only {@code fitWidth} is set, height is scaled to preserve ratio
     * &lt;li&gt;If only {@code fitHeight} is set, width is scaled to preserve ratio
     * &lt;li&gt;If both are set, they both may be scaled to get the best fit in a
     * width by height rectangle while preserving the original aspect ratio
     * &lt;/ul&gt;
     *
     * If unset or set to {@code false}, it affects the dimensions of this
     * {@code ImageView} in the following way
     * &lt;ul&gt;
     * &lt;li&gt;If only {@code fitWidth} is set, image's view width is scaled to
     * match and height is unchanged;
     * &lt;li&gt;If only {@code fitHeight} is set, image's view height is scaled to
     * match and height is unchanged;
     * &lt;li&gt;If both are set, the image view is scaled to match both.
     * &lt;/ul&gt;
     *
     * Note that the dimensions of this node as reported by the node's bounds
     * will be equal to the size of the scaled image and is guaranteed to be
     * contained within {@code fitWidth x fitHeight} bonding box.
     *
     * @defaultValue false
     */
    private BooleanProperty preserveRatio;


    public final void setPreserveRatio(boolean value) {
        preserveRatioProperty().set(value);
    }

    public final boolean isPreserveRatio() {
        return preserveRatio == null ? false : preserveRatio.get();
    }

    public final BooleanProperty preserveRatioProperty() {
        if (preserveRatio == null) {
            preserveRatio = new BooleanPropertyBase() {

                @Override
                protected void invalidated() {
                    invalidateWidthHeight();
                    NodeHelper.markDirty(ImageView.this, DirtyBits.NODE_VIEWPORT);
                    NodeHelper.geomChanged(ImageView.this);
                }

                @Override
                public Object getBean() {
                    return ImageView.this;
                }

                @Override
                public String getName() {
                    return &quot;preserveRatio&quot;;
                }
            };
        }
        return preserveRatio;
    }

    /**
     * Indicates whether to use a better quality filtering algorithm or a faster
     * one when transforming or scaling the source image to fit within the
     * bounding box provided by {@code fitWidth} and {@code fitHeight}.
     *
     * &lt;p&gt;
     * If set to {@code true} a better quality filtering will be used, if set to
     * {@code false} a faster but lesser quality filtering will be used.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * The default value depends on platform configuration.
     * &lt;/p&gt;
     *
     * @defaultValue platform-dependent
     */
    private BooleanProperty smooth;


    public final void setSmooth(boolean value) {
        smoothProperty().set(value);
    }

    public final boolean isSmooth() {
        return smooth == null ? SMOOTH_DEFAULT : smooth.get();
    }

    public final BooleanProperty smoothProperty() {
        if (smooth == null) {
            smooth = new BooleanPropertyBase(SMOOTH_DEFAULT) {

                @Override
                protected void invalidated() {
                    NodeHelper.markDirty(ImageView.this, DirtyBits.NODE_SMOOTH);
                }

                @Override
                public Object getBean() {
                    return ImageView.this;
                }

                @Override
                public String getName() {
                    return &quot;smooth&quot;;
                }
            };
        }
        return smooth;
    }

    /**
     * Platform-dependent default value of the {@link #smoothProperty() smooth} property.
     */
    public static final boolean SMOOTH_DEFAULT = Toolkit.getToolkit()
            .getDefaultImageSmooth();
    /**
     * The rectangular viewport into the image. The viewport is specified in the
     * coordinates of the image, prior to scaling or any other transformations.
     *
     * &lt;p&gt;
     * If {@code viewport} is {@code null}, the entire image is displayed. If
     * {@code viewport} is non-{@code null}, only the portion of the image which
     * falls within the viewport will be displayed. If the image does not fully
     * cover the viewport then any remaining area of the viewport will be empty.
     * &lt;/p&gt;
     *
     * @defaultValue null
     */
    private ObjectProperty&lt;Rectangle2D&gt; viewport;


    public final void setViewport(Rectangle2D value) {
        viewportProperty().set(value);
    }

    public final Rectangle2D getViewport() {
        return viewport == null ? null : viewport.get();
    }

    public final ObjectProperty&lt;Rectangle2D&gt; viewportProperty() {
        if (viewport == null) {
            viewport = new ObjectPropertyBase&lt;Rectangle2D&gt;() {

                @Override
                protected void invalidated() {
                    invalidateWidthHeight();
                    NodeHelper.markDirty(ImageView.this, DirtyBits.NODE_VIEWPORT);
                    NodeHelper.geomChanged(ImageView.this);
                }

                @Override
                public Object getBean() {
                    return ImageView.this;
                }

                @Override
                public String getName() {
                    return &quot;viewport&quot;;
                }
            };
        }
        return viewport;
    }

    // Need to track changes to image width and image height and recompute
    // bounds when changed.
    // imageWidth = bind image.width on replace {
    // NodeHelper.geomChanged(ImageView.this);
    // }
    //
    // imageHeight = bind image.height on replace {
    // NodeHelper.geomChanged(ImageView.this);
    // }

    private double destWidth, destHeight;

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private NGNode doCreatePeer() {
        return new NGImageView();
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {
        recomputeWidthHeight();

        bounds = bounds.deriveWithNewBounds((float)getX(), (float)getY(), 0.0f,
                (float)(getX() + destWidth), (float)(getY() + destHeight), 0.0f);
        bounds = tx.transform(bounds, bounds);
        return bounds;
    }

    private boolean validWH;

    private void invalidateWidthHeight() {
        validWH = false;
    }

    private void recomputeWidthHeight() {
        if (validWH) {
            return;
        }
        Image localImage = getImage();
        Rectangle2D localViewport = getViewport();

        double w = 0;
        double h = 0;
        if (localViewport != null &amp;&amp; localViewport.getWidth() &gt; 0 &amp;&amp; localViewport.getHeight() &gt; 0) {
            w = localViewport.getWidth();
            h = localViewport.getHeight();
        } else if (localImage != null) {
            w = localImage.getWidth();
            h = localImage.getHeight();
        }

        double localFitWidth = getFitWidth();
        double localFitHeight = getFitHeight();

        if (isPreserveRatio() &amp;&amp; w &gt; 0 &amp;&amp; h &gt; 0 &amp;&amp; (localFitWidth &gt; 0 || localFitHeight &gt; 0)) {
            if (localFitWidth &lt;= 0 || (localFitHeight &gt; 0 &amp;&amp; localFitWidth * h &gt; localFitHeight * w)) {
                w = w * localFitHeight / h;
                h = localFitHeight;
            } else {
                h = h * localFitWidth / w;
                w = localFitWidth;
            }
        } else {
            if (localFitWidth &gt; 0f) {
                w = localFitWidth;
            }
            if (localFitHeight &gt; 0f) {
                h = localFitHeight;
            }
        }

        // Store these values for use later in doComputeContains() to support
        // Node.contains().
        destWidth = w;
        destHeight = h;

        validWH = true;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeContains(double localX, double localY) {
        if (getImage() == null) {
            return false;
        }

        recomputeWidthHeight();
        // Local Note bounds contain test is already done by the caller.
        // (Node.contains()).

        double dx = localX - getX();
        double dy = localY - getY();

        Image localImage = getImage();
        double srcWidth = localImage.getWidth();
        double srcHeight = localImage.getHeight();
        double viewWidth = srcWidth;
        double viewHeight = srcHeight;
        double vw = 0;
        double vh = 0;
        double vminx = 0;
        double vminy = 0;
        Rectangle2D localViewport = getViewport();
        if (localViewport != null) {
            vw = localViewport.getWidth();
            vh = localViewport.getHeight();
            vminx = localViewport.getMinX();
            vminy = localViewport.getMinY();
        }

        if (vw &gt; 0 &amp;&amp; vh &gt; 0) {
            viewWidth = vw;
            viewHeight = vh;
        }

        // desWidth Note and destHeight are computed by NodeHelper.computeGeomBounds()
        // via a call from Node.contains() before calling
        // doComputeContains().
        // Transform into image's coordinate system.
        dx = vminx + dx * viewWidth / destWidth;
        dy = vminy + dy * viewHeight / destHeight;
        // test whether it's inside the original image AND inside of viewport
        // (viewport may stick out from the image bounds)
        if (dx &lt; 0.0 || dy &lt; 0.0 || dx &gt;= srcWidth || dy &gt;= srcHeight ||
                dx &lt; vminx || dy &lt; vminy ||
                dx &gt;= vminx + viewWidth || dy &gt;= vminy + viewHeight) {
            return false;
        }
        // Do alpha test on the picked pixel.
        return Toolkit.getToolkit().imageContains(
                Toolkit.getImageAccessor().getPlatformImage(localImage), (float)dx, (float)dy);
    }

    /***************************************************************************
     * * Stylesheet Handling * *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;image-view&quot;;

    /*
     * Super-lazy instantiation pattern from Bill Pugh.
     */
     private static class StyleableProperties {
        // TODO
        // &quot;preserve-ratio&quot;,&quot;smooth&quot;,&quot;viewport&quot;,&quot;fit-width&quot;,&quot;fit-height&quot;
         private static final CssMetaData&lt;ImageView, String&gt; IMAGE =
            new CssMetaData&lt;ImageView,String&gt;(&quot;-fx-image&quot;,
                URLConverter.getInstance()) {

            @Override
            public boolean isSettable(ImageView n) {
                // Note that we care about the image, not imageUrl
                return n.image == null || !n.image.isBound();
            }

            @Override
            public StyleableProperty&lt;String&gt; getStyleableProperty(ImageView n) {
                return (StyleableProperty&lt;String&gt;)n.imageUrlProperty();
            }
        };

         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
         static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Node.getClassCssMetaData());
            styleables.add(IMAGE);
            STYLEABLES = Collections.unmodifiableList(styleables);
         }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its super classes.
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    void updateViewport() {
        recomputeWidthHeight();
        if (getImage() == null || Toolkit.getImageAccessor().getPlatformImage(getImage()) == null) {
            return;
        }

        Rectangle2D localViewport = getViewport();
        final NGImageView peer = NodeHelper.getPeer(this);
        if (localViewport != null) {
            peer.setViewport((float)localViewport.getMinX(), (float)localViewport.getMinY(),
                    (float)localViewport.getWidth(), (float)localViewport.getHeight(),
                    (float)destWidth, (float)destHeight);
        } else {
            peer.setViewport(0, 0, 0, 0, (float)destWidth, (float)destHeight);
        }
    }

    /*
<A NAME="34"></A>     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        final NGImageView peer = <FONT color="#827d6b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#34',2,'match37-top.html#34',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>NodeHelper.getPeer(this);
        if (NodeHelper.isDirty(this, DirtyBits.NODE_GEOMETRY)) {
            peer.setX((float)getX());
            peer.setY((float)getY());
        }
        if (NodeHelper.isDirty(this, DirtyBits.NODE_SMOOTH)) {
            peer.setSmooth(isSmooth());
        }</B></FONT>
        if (NodeHelper.isDirty(this, DirtyBits.NODE_CONTENTS)) {
            peer.setImage(getImage() != null
                    ? Toolkit.getImageAccessor().getPlatformImage(getImage()) : null);
        }
        // The NG part expects this to be called when image changes
        if (NodeHelper.isDirty(this, DirtyBits.NODE_VIEWPORT) || NodeHelper.isDirty(this, DirtyBits.NODE_CONTENTS)) {
            updateViewport();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/robot/Robot.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.robot;

import static com.sun.javafx.FXPermissions.CREATE_ROBOT_PERMISSION;

import java.util.Objects;

import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.scene.image.Image;
import javafx.scene.image.WritableImage;
import javafx.scene.input.KeyCode;
import javafx.scene.input.MouseButton;
import javafx.scene.paint.Color;

import com.sun.glass.ui.Application;
import com.sun.glass.ui.GlassRobot;
import com.sun.javafx.tk.Toolkit;

/**
 * A {@code Robot} is used for simulating user interaction such as
 * typing keys on the keyboard and using the mouse as well as capturing
 * graphical information without requiring a {@link javafx.scene.Scene}
 * instance. Robot objects must be constructed and used on the JavaFX
 * Application Thread.
 *
 * @since 11
 */
public final class Robot {

    private final GlassRobot peer;

    /**
     * Constructs a new {@code Robot} that can be used for simulating user
     * interactions. If a security manager is present, the application must
     * have the {@link javafx.util.FXPermission} {@code &quot;createRobot&quot;} permission
     * in order to construct a {@code Robot} object.
     *
     * @throws IllegalStateException if this object is constructed on a thread
     * other than the JavaFX Application Thread.
     * @throws SecurityException if a security manager exists and the application
     * does not have the {@link javafx.util.FXPermission} {@code &quot;createRobot&quot;}
     * permission.
     */
    public Robot() {
        Application.checkEventThread();

        // Ensure we have proper permission for creating a robot.
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            sm.checkPermission(CREATE_ROBOT_PERMISSION);
        }

        peer = Toolkit.getToolkit().createRobot();
        peer.create();
    }

    /**
     * Presses the specified {@link KeyCode} key.
     *
     * @param keyCode the key to press
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     * @throws NullPointerException if keyCode is {@literal null}.
     */
    public void keyPress(KeyCode keyCode) {
        Objects.requireNonNull(keyCode, &quot;keyCode must not be null&quot;);
        peer.keyPress(keyCode);
    }

    /**
     * Releases the specified {@link KeyCode} key.
     *
     * @param keyCode the key to release
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     * @throws NullPointerException if keyCode is {@literal null}.
     */
    public void keyRelease(KeyCode keyCode) {
        Objects.requireNonNull(keyCode, &quot;keyCode must not be null&quot;);
        peer.keyRelease(keyCode);
    }

    /**
     * Types the specified {@link KeyCode} key.
     *
     * @implSpec This is a convenience method that is equivalent to calling
     * {@link #keyPress(KeyCode)} followed by {@link #keyRelease(KeyCode)}.
     * @param keyCode the key to type
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     * @throws NullPointerException if keyCode is {@literal null}.
     */
    public void keyType(KeyCode keyCode) {
        Objects.requireNonNull(keyCode, &quot;keyCode must not be null&quot;);
        keyPress(keyCode);
        keyRelease(keyCode);
    }

    /**
     * Returns the current mouse {@code x} position in screen coordinates.
     *
     * @return the current mouse {@code x} position
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     */
    public double getMouseX() {
        return peer.getMouseX();
    }

    /**
     * Returns the current mouse {@code y} position in screen coordinates.
     *
     * @return the current mouse {@code y} position
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     */
    public double getMouseY() {
        return peer.getMouseY();
    }

    /**
     * Returns the current mouse (x,y) screen coordinates as a {@link Point2D}.
     *
     * @return the current mouse (x,y) screen coordinates
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     */
    public Point2D getMousePosition() {
        return new Point2D(getMouseX(), getMouseY());
    }

    /**
     * Moves the mouse to the specified (x,y) screen coordinates relative to
     * the primary screen.
     *
     * @param x screen coordinate x to move the mouse to
     * @param y screen coordinate y to move the mouse to
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     */
    public void mouseMove(double x, double y) {
        peer.mouseMove(x, y);
    }

    /**
     * Moves the mouse to the (x,y) screen coordinates, relative to the primary
     * screen, specified by the given {@code location}.
     *
     * @param location the (x,y) coordinates to move the mouse to
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     * @throws NullPointerException if location is {@literal null}.
<A NAME="53"></A>     */
    public final void mouseMove(Point2D location) {
        Objects.requireNonNull(location);
        mouseMove(location.getX(), <FONT color="#f88158"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#53',2,'match37-top.html#53',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>location.getY());
    }

    /**
     * Presses the specified {@link MouseButton}s.
     *
     * @param buttons the mouse buttons to press
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     * @throws NullPointerException if buttons is {@literal null}.
     */
    public void mousePress(MouseButton... buttons) {
        Objects.requireNonNull(buttons, &quot;buttons must not be null&quot;);
        peer.mousePress(buttons);
    }

    /**
     * Releases the specified {@link MouseButton}s.
     *
     * @param buttons the mouse buttons to release
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     * @throws NullPointerException if buttons is {@literal null}.
     */
    public void mouseRelease(MouseButton... buttons) {
        Objects.requireNonNull(buttons, &quot;buttons must not be null&quot;);
        peer.mouseRelease(buttons);
    }

    /**
     * Clicks the specified {@link MouseButton}s.
     *
     * @implSpec This is a convenience method that is equivalent to calling
     * {@link #mousePress(MouseButton...)} followed by {@link #mouseRelease(MouseButton...)}.
     * @param buttons the mouse buttons to click
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     * @throws NullPointerException if buttons is {@literal null}.
     */
    public void mouseClick(MouseButton... buttons) {
        Objects.requireNonNull(buttons, &quot;buttons must not be null&quot;);
        mousePress(buttons);
        mouseRelease(buttons);
    }

    /**
     * Scrolls the mouse wheel by the specified amount of wheel clicks. A positive
     * {@code wheelAmt} scrolls the wheel towards the user (down) whereas negative
     * amounts scrolls the wheel away from the user (up).
     *
     * @param wheelAmt the (signed) amount of clicks to scroll the wheel
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     */
    public void mouseWheel(int wheelAmt) {</B></FONT>
        peer.mouseWheel(wheelAmt);
    }

    /**
     * Returns the {@link Color} of the pixel at the screen coordinates relative to the
     * primary screen specified by {@code location}. Regardless of the scale of the screen
     * ({@link javafx.stage.Screen#getOutputScaleX()}, {@link javafx.stage.Screen#getOutputScaleY()}),
     * this method only samples a single pixel. For example, on a HiDPI screen with output
     * scale 2, the screen unit at the point (x,y) may have 4 pixels. In this case the color
     * returned is the color of the top, left pixel. Color values are &lt;em&gt;not&lt;/em&gt;
     * averaged when a screen unit is made up of more than one pixel.
     *
     * @param x the x coordinate to get the pixel color from
     * @param y the y coordinate to get the pixel color from
     * @return the pixel color at the specified screen coordinates
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     */
    public Color getPixelColor(double x, double y) {
        return peer.getPixelColor(x, y);
    }

    /**
     * Returns the {@link Color} of the pixel at the screen coordinates relative to the
     * primary screen specified by {@code location}. Regardless of the scale of the screen
     * ({@link javafx.stage.Screen#getOutputScaleX()}, {@link javafx.stage.Screen#getOutputScaleY()}),
     * this method only samples a single pixel. For example, on a HiDPI screen with output
     * scale 2, the screen unit at the point (x,y) may have 4 pixels. In this case the color
     * returned is the color of the top, left pixel. Color values are &lt;em&gt;not&lt;/em&gt;
     * averaged when a screen unit is made up of more than one pixel.
     *
     * @param location the (x,y) coordinates to get the pixel color from
     * @return the pixel color at the specified screen coordinates
     * @throws NullPointerException if the given {@code location} is {@literal null}
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     */
    public Color getPixelColor(Point2D location) {
        return getPixelColor(location.getX(), location.getY());
    }

    /**
     * Returns a {@link WritableImage} containing the specified rectangular area relative
     * to the primary screen. If the given {@code image} is {@literal null}, or if the given
     * {@code image} is not the required size, a new {@code WritableImage} will be created
     * and returned. Otherwise, the given {@code image} is re-used.
     * &lt;p&gt;
     * If the {@code scaleToFit} argument is {@literal false}, the returned
     * {@code Image} object dimensions may differ from the requested {@code width}
     * and {@code height} depending on how many physical pixels the area occupies
     * on the screen. For example, in HiDPI mode on the Mac (aka Retina display) the
     * pixels are doubled, and thus a screen capture of an area of size (10x10) pixels
     * will result in an {@code Image} with dimensions (20x20). Calling code should
     * use the returned images's {@link Image#getWidth()} and {@link Image#getHeight()}
     * methods to determine the actual image size.
     * &lt;p&gt;
     * If {@code scaleToFit} is {@literal true}, the returned {@code Image} is of
     * the requested size. Note that in this case the image will be scaled in
     * order to fit to the requested dimensions if necessary, such as when running
     * on a HiDPI display.
     *
     * @param image either {@literal null} or a {@code WritableImage} that will
     * be used to place the screen capture in
     * @param x the starting x-position of the rectangular area to capture
     * @param y the starting y-position of the rectangular area to capture
     * @param width the width of the rectangular area to capture
     * @param height the height of the rectangular area to capture
     * @param scaleToFit If {@literal true}, the returned {@code Image} will be
     * scaled to fit the request dimensions (if necessary). Otherwise, the size
     * of the returned image will depend on the output scale (DPI) of the primary
     * screen.
     * @return the screen capture of the specified {@code region} as a {@link WritableImage}
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     */
    public WritableImage getScreenCapture(WritableImage image, double x, double y,
                                          double width, double height, boolean scaleToFit) {
        return peer.getScreenCapture(image, x, y, width, height, scaleToFit);
    }

    /**
     * Returns a {@link WritableImage} containing the specified rectangular area relative
     * to the primary screen. If the given {@code image} is {@literal null}, or if the given
     * {@code image} is not the required size, a new {@code WritableImage} will be created
     * and returned. Otherwise, the given {@code image} is re-used.
     *
     * @implSpec This method is equivalent to calling {@code getScreenCapture(x, y, width, height, true)},
     * that is, this method scales the image to fit the requested size.
     * @param image either {@literal null} or a {@code WritableImage} that will
     * be used to place the screen capture in
     * @param x the starting x-position of the rectangular area to capture
     * @param y the starting y-position of the rectangular area to capture
     * @param width the width of the rectangular area to capture
     * @param height the height of the rectangular area to capture
     * @return the screen capture of the specified {@code region} as a {@link WritableImage}
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     */
    public WritableImage getScreenCapture(WritableImage image, double x, double y,
                                          double width, double height) {
        return getScreenCapture(image, x, y, width, height, true);
    }

    /**
     * Returns a {@link WritableImage} containing the specified rectangular area relative
     * to the primary screen. If the given {@code image} is {@literal null}, or if the given
     * {@code image} is not the required size, a new {@code WritableImage} will be created
     * and returned. Otherwise, the given {@code image} is re-used.
     *
     * @implSpec This method is equivalent to calling {@code getScreenCapture(image, region, true)},
     * that is, this method scales the image to fit the requested size.
     * @param image either {@literal null} or a {@code WritableImage} that will
     * be used to place the screen capture in
     * @param region the rectangular area of the screen to capture
     * @return the screen capture of the specified {@code region} as a {@link WritableImage}
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     * @throws NullPointerException if region is {@literal null}.
     */
    public WritableImage getScreenCapture(WritableImage image, Rectangle2D region) {
        Objects.requireNonNull(region);
        return getScreenCapture(image, region.getMinX(), region.getMinY(),
                region.getWidth(), region.getHeight(), true);
    }

    /**
     * Returns a {@link WritableImage} containing the specified rectangular area relative to
     * the primary screen. If the given {@code image} is {@literal null}, or if the given
     * {@code image} is not the required size, a new {@code WritableImage} will be created
     * and returned. Otherwise, the given {@code image} is re-used.
     * &lt;p&gt;
     * If the {@code scaleToFit} argument is {@literal false}, the returned
     * {@code Image} object dimensions may differ from the requested {@code width}
     * and {@code height} depending on how many physical pixels the area occupies
     * on the screen. For example, in HiDPI mode on the Mac (aka Retina display) the
     * pixels are doubled, and thus a screen capture of an area of size (10x10) pixels
     * will result in an {@code Image} with dimensions (20x20). Calling code should
     * use the returned images's {@link Image#getWidth()} and {@link Image#getHeight()}
     * methods to determine the actual image size.
     * &lt;p&gt;
     * If {@code scaleToFit} is {@literal true}, the returned {@code Image} is of
     * the requested size. Note that in this case the image will be scaled in
     * order to fit to the requested dimensions if necessary, such as when running
     * on a HiDPI display.
     *
     * @param image either {@literal null} or a {@code WritableImage} that will
     * be used to place the screen capture in
     * @param region the rectangular area of the screen to capture
     * @param scaleToFit if {@literal true}, the returned {@code Image} will be
     * scaled to fit the request dimensions (if necessary). Otherwise, the size
     * of the returned image will depend on the output scale (DPI) of the primary
     * screen.
     * @return the screen capture of the specified {@code region} as a {@link WritableImage}
     * @throws IllegalStateException if this method is called on a thread
     * other than the JavaFX Application Thread.
     * @throws NullPointerException if region is {@literal null}.
     */
    public WritableImage getScreenCapture(WritableImage image, Rectangle2D region, boolean scaleToFit) {
        Objects.requireNonNull(region);
        return getScreenCapture(image, region.getMinX(), region.getMinY(),
                region.getWidth(), region.getHeight(), scaleToFit);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/shape/MeshView.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.shape;

import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.input.PickResultChooser;
import com.sun.javafx.scene.shape.MeshHelper;
import com.sun.javafx.scene.shape.MeshViewHelper;
import com.sun.javafx.sg.prism.NGMeshView;
import com.sun.javafx.sg.prism.NGNode;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.beans.value.WeakChangeListener;
import javafx.scene.Node;

/**
 * The {@code MeshView} class defines a surface with the specified 3D
 * mesh data.
 *
 * @since JavaFX 8.0
 */
public class MeshView extends Shape3D {
    static {
         // This is used by classes in different packages to get access to
         // private and package private methods.
        MeshViewHelper.setMeshViewAccessor(new MeshViewHelper.MeshViewAccessor() {
            @Override
            public NGNode doCreatePeer(Node node) {
                return ((MeshView) node).doCreatePeer();
            }

            @Override
            public void doUpdatePeer(Node node) {
                ((MeshView) node).doUpdatePeer();
            }

            @Override
            public BaseBounds doComputeGeomBounds(Node node,
                    BaseBounds bounds, BaseTransform tx) {
                return ((MeshView) node).doComputeGeomBounds(bounds, tx);
            }

            @Override
            public boolean doComputeContains(Node node, double localX, double localY) {
                return ((MeshView) node).doComputeContains(localX, localY);
            }

            @Override
            public boolean doComputeIntersects(Node node, PickRay pickRay,
                    PickResultChooser pickResult) {
                return ((MeshView) node).doComputeIntersects(pickRay, pickResult);
            }
        });
    }

    {
        // To initialize the class helper at the begining each constructor of this class
        MeshViewHelper.initHelper(this);
    }

    /**
     * Creates a new instance of {@code MeshView} class.
     */
    public MeshView() {
    }

    /**
     * Creates a new instance of {@code MeshView} class with the specified {@code Mesh}
     * surface.
     * @param mesh the mesh surface
     */
    public MeshView(Mesh mesh) {
        setMesh(mesh);
    }

    /**
     * Specifies the 3D mesh data of this {@code MeshView}.
     *
     * @defaultValue null
     */
    private ObjectProperty&lt;Mesh&gt; mesh;

    public final void setMesh(Mesh value) {
        meshProperty().set(value);
    }

    public final Mesh getMesh() {
        return mesh == null ? null : mesh.get();
    }

    public final ObjectProperty&lt;Mesh&gt; meshProperty() {
        if (mesh == null) {
            mesh = new SimpleObjectProperty&lt;Mesh&gt;(MeshView.this, &quot;mesh&quot;) {

                private Mesh old = null;
                private final ChangeListener&lt;Boolean&gt; meshChangeListener =
                        (observable, oldValue, newValue) -&gt; {
                            if (newValue) {
                                NodeHelper.markDirty(MeshView.this, DirtyBits.MESH_GEOM);
                                NodeHelper.geomChanged(MeshView.this);
                            }
                        };
                private final WeakChangeListener&lt;Boolean&gt; weakMeshChangeListener =
                        new WeakChangeListener(meshChangeListener);

                @Override
                protected void invalidated() {
                    if (old != null) {
                        old.dirtyProperty().removeListener(weakMeshChangeListener);
                    }
                    Mesh newMesh = get();
                    if (newMesh != null) {
                        newMesh.dirtyProperty().addListener(weakMeshChangeListener);
                    }
                    NodeHelper.markDirty(MeshView.this, DirtyBits.MESH);
                    NodeHelper.markDirty(MeshView.this, DirtyBits.MESH_GEOM);
                    NodeHelper.geomChanged(MeshView.this);
<A NAME="43"></A>                    old = newMesh;
                }
            };
        <FONT color="#c22817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#43',2,'match37-top.html#43',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
        return mesh;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        NGMeshView peer = NodeHelper.getPeer(this);
        if (NodeHelper.isDirty(this, DirtyBits.MESH_GEOM) &amp;&amp; getMesh() != null) {
            getMesh().updatePG();
        }
        if (NodeHelper.isDirty</B></FONT>(this, DirtyBits.MESH)) {
            peer.setMesh((getMesh() == null) ? null : getMesh().getPGMesh());
        }
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private NGNode doCreatePeer() {
        return new NGMeshView();
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {
        if (getMesh() != null) {
            bounds = getMesh().computeBounds(bounds);
            bounds = tx.transform(bounds, bounds);
        } else {
            bounds.makeEmpty();
        }
        return bounds;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeContains(double localX, double localY) {
        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeIntersects(PickRay pickRay, PickResultChooser pickResult) {
        return MeshHelper.computeIntersects(getMesh(), pickRay, pickResult, this, getCullFace(), true);
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.swing/com/sun/javafx/embed/swing/CachingTransferable.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.embed.swing;

import java.awt.datatransfer.DataFlavor;
<A NAME="55"></A>import java.awt.datatransfer.Transferable;
import java.io.UnsupportedEncodingException;
import java.util.Arrays;
<FONT color="#4863a0"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#55',2,'match37-top.html#55',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import javafx.scene.input.Clipboard;
import javafx.scene.input.DataFormat;

/**
 * A Transferable implementation backed by a Map.
 * The data can be populated either from AWT Transferable
 * or from FX Clipboard.
 */
public class CachingTransferable implements Transferable {

    @Override
    public Object getTransferData(final DataFlavor flavor) throws UnsupportedEncodingException
    {
        String mimeType = DataFlavorUtils.getFxMimeType</B></FONT>(flavor);
        return DataFlavorUtils.adjustFxData(
                flavor, getData(mimeType));
    }

    @Override
    public DataFlavor[] getTransferDataFlavors() {
        final String mimeTypes[] = getMimeTypes();
        return DataFlavorUtils.getDataFlavors(mimeTypes);
    }

    @Override
    public boolean isDataFlavorSupported(final DataFlavor flavor) {
        return isMimeTypeAvailable(
                DataFlavorUtils.getFxMimeType(flavor));
    }

    private Map&lt;String, Object&gt; mimeType2Data = Collections.EMPTY_MAP;

    public void updateData(Transferable t, boolean fetchData) {
        final Map&lt;String, DataFlavor&gt; mimeType2DataFlavor =
                DataFlavorUtils.adjustSwingDataFlavors(
                t.getTransferDataFlavors());

        // If we keep reference to source Transferable in SwingDragSource and
        // call Transferable#getTransferData() on it from
        // SwingDragSource#getData() we may run into
        // &quot;java.awt.dnd.InvalidDnDOperationException&quot; issue as
        // SwingDragSource#getData() is called from FX user code and from
        // QuantumClipboard#getContent() (sik!). These calls usually take
        // place in the context of
        // EmbeddedSceneDTInterface#handleDragDrop() method as the
        // normal handling of DnD.
        // Instead of keeping reference to source Transferable we just read
        // all its data while in the context safe for calling
        // Transferable#getTransferData().
        //
        // This observation is true for standard AWT Transferable-s.
        // Things may be totally broken for custom Transferable-s though.

        // For performance reasons, the DRAG_ENTERED and DRAG_OVER event
        // handlers pass fetchData == false so as to update the set of
        // available MIME types only. The DRAG_DROPPED handler passes
        // fetchData == true which also fetches all the data.
        // NOTE: Due to JDK-8028585 this code won't be able to fetch data
        // when invoked from handlers other than DROPPED in any case.

        try {
            mimeType2Data = DataFlavorUtils.readAllData(t, mimeType2DataFlavor,
                    fetchData);
        } catch (Exception e) {
            mimeType2Data = Collections.EMPTY_MAP;
        }
    }

    public void updateData(Clipboard cb, boolean fetchData) {
        mimeType2Data = new HashMap&lt;&gt;();
        for (DataFormat f : cb.getContentTypes()) {
            mimeType2Data.put(DataFlavorUtils.getMimeType(f),
                    fetchData ? cb.getContent(f) : null);
        }
    }

    public Object getData(final String mimeType) {
        return mimeType2Data.get(mimeType);
    }

    public String[] getMimeTypes() {
        return mimeType2Data.keySet().toArray(new String[0]);
    }

    public boolean isMimeTypeAvailable(final String mimeType) {
        return Arrays.asList(getMimeTypes()).contains(mimeType);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/javafx/webkit/prism/PrismInvoker.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.webkit.prism;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;
import java.util.concurrent.locks.ReentrantLock;
import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.tk.RenderJob;
import com.sun.javafx.tk.Toolkit;
import com.sun.webkit.Invoker;

public final class PrismInvoker extends Invoker {

    public PrismInvoker() {
    }

    /*
     * No synchronization b/w Event (User) &amp; Render threads is required
     * because FX synchronizes pulse and render operations itself.
     */
    @Override protected boolean lock(ReentrantLock lock) {
        return false;
    }

    @Override protected boolean unlock(ReentrantLock lock) {
        return false;
    }

    @Override protected boolean isEventThread() {
        return isEventThreadPrivate();
    }

    private static boolean isEventThreadPrivate() {
        return Toolkit.getToolkit().isFxUserThread();
    }

    @Override public void checkEventThread() {
        Toolkit.getToolkit().checkFxUserThread();
    }

    @Override public void invokeOnEventThread(final Runnable r) {
        if (isEventThread()) {
            r.run();
        } else {
            PlatformImpl.runLater(r);
        }
    }

    @Override public void postOnEventThread(final Runnable r) {
        PlatformImpl.runLater(r);
<A NAME="19"></A>    }

    static void invokeOnRenderThread(final Runnable r) {
        <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#19',2,'match37-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Toolkit.getToolkit().addRenderJob(new RenderJob(r));
    }

    static void runOnRenderThread(final Runnable r) {
        if (Thread.currentThread().getName().startsWith</B></FONT>(&quot;QuantumRenderer&quot;)) {
            r.run();
        } else {
            FutureTask&lt;Void&gt; f = new FutureTask&lt;Void&gt;(r, null);
            Toolkit.getToolkit().addRenderJob(new RenderJob(f));
            try {
                // block until job is complete
                f.get();
            } catch (ExecutionException ex) {
                throw new AssertionError(ex);
            } catch (InterruptedException ex) {
                // ignore; recovery is impossible
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/javafx/webkit/prism/WCGraphicsPrismContext.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.webkit.prism;

import com.sun.glass.ui.Screen;
import com.sun.javafx.font.FontStrike;
import com.sun.javafx.font.Metrics;
import com.sun.javafx.font.PGFont;
import com.sun.javafx.geom.*;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;
import com.sun.javafx.scene.text.GlyphList;
import com.sun.javafx.scene.text.TextLayout;
import com.sun.javafx.sg.prism.*;
import com.sun.javafx.text.TextRun;
import com.sun.prism.*;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.Gradient;
import com.sun.prism.paint.ImagePattern;
import com.sun.prism.paint.Paint;
import com.sun.scenario.effect.*;
import com.sun.scenario.effect.impl.prism.PrDrawable;
import com.sun.scenario.effect.impl.prism.PrEffectHelper;
import com.sun.scenario.effect.impl.prism.PrFilterContext;
import com.sun.webkit.graphics.*;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.List;

import static com.sun.scenario.effect.Blend.Mode.*;
import com.sun.scenario.effect.impl.Renderer;
import com.sun.scenario.effect.impl.prism.PrRenderer;

class WCGraphicsPrismContext extends WCGraphicsContext {

    public enum Type {
        /**
         * Base context associated with the topmost page buffer.
         * Created and disposed during a single render pass.
         */
        PRIMARY,

        /**
         * A context associated with a dedicated buffer representing
         * a separate render target like canvas, buffered image etc.
         * Its life cycle is not limited to a single render pass.
         */
        DEDICATED
    }

    private final static PlatformLogger log =
            PlatformLogger.getLogger(WCGraphicsPrismContext.class.getName());
    private final static boolean DEBUG_DRAW_CLIP_SHAPE = Boolean.valueOf(
            AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt;
            System.getProperty(&quot;com.sun.webkit.debugDrawClipShape&quot;, &quot;false&quot;)));

    Graphics baseGraphics;
    private BaseTransform baseTransform;

    private final List&lt;ContextState&gt; states = new ArrayList&lt;ContextState&gt;();

    private ContextState state = new ContextState();

    // Cache for getPlatformGraphics
    private Graphics cachedGraphics = null;

    private int fontSmoothingType;
    private boolean isRootLayerValid = false;

    WCGraphicsPrismContext(Graphics g) {
        state.setClip(g.getClipRect());
        state.setAlpha(g.getExtraAlpha());
        baseGraphics = g;
        initBaseTransform(g.getTransformNoClone());
    }

    WCGraphicsPrismContext() {
    }

    public Type type() {
        return Type.PRIMARY;
    }

    final void initBaseTransform(BaseTransform t) {
        baseTransform = new Affine3D(t);
        state.setTransform((Affine3D)baseTransform);
    }

    private void resetCachedGraphics() {
        cachedGraphics = null;
    }

    @Override
    public Object getPlatformGraphics() {
        return getGraphics(false);
    }

    Graphics getGraphics(boolean checkClip) {
        if (cachedGraphics == null) {
            Layer l = state.getLayerNoClone();
            cachedGraphics = (l != null)
                    ? l.getGraphics()
                    : baseGraphics;

            state.apply(cachedGraphics);

            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;getPlatformGraphics for &quot; + this + &quot; : &quot; +
                         cachedGraphics);
            }
        }

        Rectangle clip = cachedGraphics.getClipRectNoClone();
        return (checkClip &amp;&amp; clip!=null &amp;&amp; clip.isEmpty())
            ? null
            : cachedGraphics;
    }

    public void saveState()
    {
        state.markAsRestorePoint();
        saveStateInternal();
    }

    private void saveStateInternal()
    {
        states.add(state);
        state = state.clone();
    }

    private void startNewLayer(Layer layer) {
        saveStateInternal();

        // layer has the same bounds as clip, so we have to translate
        Rectangle clip = state.getClipNoClone();

        //left-side (post-) translate.
        //NB! an order of transforms is essential!
        Affine3D newTr = new Affine3D(BaseTransform.getTranslateInstance(
                -clip.x,
                -clip.y));
        newTr.concatenate(state.getTransformNoClone());

        //move clip to (0, 0) - start of texture
        clip.x = 0;
        clip.y = 0;
        //no-clone - no-set!

        Graphics g = getGraphics(true);
        if (g != null &amp;&amp; g != baseGraphics) {
            layer.init(g);
        }

        state.setTransform(newTr);
        state.setLayer(layer);

        resetCachedGraphics();
    }

    private void renderLayer(final Layer layer) {
        WCTransform cur = getTransform();

        //translate to (layer.getX(), layer.getY())
        setTransform(new WCTransform(
            1.0, 0.0,
            0.0, 1.0,
            layer.getX(), layer.getY()));

        // composite drawing delegated to the layer rendering
        Graphics g = getGraphics(true);
        if (g != null) {
            layer.render(g);
        }

        //restore transform
        setTransform(cur);
    }

    private void restoreStateInternal() {
        int size = states.size();
        if (size == 0) {
            assert false: &quot;Unbalanced restoreState&quot;;
            return;
        }

        Layer layer = state.getLayerNoClone();
        state = states.remove(size - 1);
        if (layer != state.getLayerNoClone()) {
            renderLayer(layer);
            layer.dispose();
            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;Popped layer &quot; + layer);
            }
        } else {
            resetCachedGraphics();
        }
    }

    public void restoreState()
    {
        log.fine(&quot;restoring state&quot;);
        do {
            restoreStateInternal();
        } while ( !state.isRestorePoint() );
    }

    /**
     *  Renders all layers to the underlaying Graphics, but preserves the
     *  current state and the states stack
     */
    private void flushAllLayers() {
        if (state == null) {
            // context disposed
            return;
        }

        if (isRootLayerValid) {
            log.fine(&quot;FlushAllLayers: root layer is valid, skipping&quot;);
            return;
        }

        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;FlushAllLayers&quot;);
        }

        ContextState currentState = state;

        for (int i = states.size() - 1; i &gt;=0; i--) {
            Layer layer = state.getLayerNoClone();
            state = states.get(i);
            if (layer != state.getLayerNoClone()) {
                renderLayer(layer);
            } else {
                resetCachedGraphics();
            }
        }

        Layer layer = state.getLayerNoClone();
        if (layer != null) {
            renderLayer(layer);
        }

        state = currentState;
        isRootLayerValid = true;
    }


    public void dispose() {
        if (!states.isEmpty()) {
            log.fine(&quot;Unbalanced saveState/restoreState&quot;);
        }
        for (ContextState state: states) {
            if (state.getLayerNoClone() != null) {
                state.getLayerNoClone().dispose();
            }
        }
        states.clear();

        if (state != null &amp;&amp; state.getLayerNoClone() != null) {
            state.getLayerNoClone().dispose();
        }
        state = null;
    }


    public void setClip(WCPath path, boolean isOut) {
        Affine3D tr = new Affine3D(state.getTransformNoClone());
        path.transform(
                tr.getMxx(), tr.getMyx(),
                tr.getMxy(), tr.getMyy(),
                tr.getMxt(), tr.getMyt());
        //path now is in node coordinates, as well as clip

        if (!isOut) {
            WCRectangle pathBounds = path.getBounds();

            // path bounds could be fractional so 'inclusive' rounding
            // is used for determining clip rectangle
            int pixelX = (int) Math.floor(pathBounds.getX());
            int pixelY = (int) Math.floor(pathBounds.getY());
            int pixelW = (int) Math.ceil(pathBounds.getMaxX()) - pixelX;
            int pixelH = (int) Math.ceil(pathBounds.getMaxY()) - pixelY;

            state.clip(new Rectangle(pixelX, pixelY, pixelW, pixelH));
        }

        Rectangle clip = state.getClipNoClone();

        if (isOut) {
            path.addRect(clip.x, clip.y, clip.width, clip.height);
            //Out clip path is always EVENODD.
        }

        path.translate(-clip.x, -clip.y);

        Layer layer = new ClipLayer(
            getGraphics(false), clip, path, type() == Type.DEDICATED);

        startNewLayer(layer);

        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setClip(WCPath &quot; + path.getID() + &quot;)&quot;);
            log.fine(&quot;Pushed layer &quot; + layer);
        }
    }

    private Rectangle transformClip(Rectangle localClip) {
        if (localClip==null) {
            return null;
        }

        float[] points = new float[] {
            localClip.x, localClip.y,
            localClip.x + localClip.width, localClip.y,
            localClip.x, localClip.y + localClip.height,
            localClip.x  + localClip.width, localClip.y + localClip.height};
        state.getTransformNoClone().transform(points, 0, points, 0, 4);
        float minX = Math.min(
               points[0], Math.min(
               points[2], Math.min(
               points[4], points[6])));
        float maxX = Math.max(
               points[0], Math.max(
               points[2], Math.max(
               points[4], points[6])));
        float minY = Math.min(
               points[1], Math.min(
               points[3], Math.min(
               points[5], points[7])));
        float maxY = Math.max(
               points[1], Math.max(
               points[3], Math.max(
               points[5], points[7])));
        return new Rectangle(new RectBounds(minX, minY, maxX, maxY));

/* #1 loose rotate
        state.getTransformNoClone().transform(localClip, localClip);
*/
/* #2 problem with negative coordinates
        RectBounds rb = TransformedShape.transformedShape(
            new RoundRectangle2D(localClip.x, localClip.y, localClip.width, localClip.height, 0, 0),
            state.getTransformNoClone()).getBounds();
        return rb.isEmpty()
            ? null
            : new Rectangle(rb);
 */
    }

    private void setClip(Rectangle shape) {
        Affine3D tr = state.getTransformNoClone();
        if (tr.getMxy() == 0 &amp;&amp; tr.getMxz() == 0
         &amp;&amp; tr.getMyx() == 0 &amp;&amp; tr.getMyz() == 0
         &amp;&amp; tr.getMzx() == 0 &amp;&amp; tr.getMzy() == 0) {
            //There is no rotation here: scale + translation.
            //Fast &amp; easy!
            state.clip(transformClip(shape));
            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;setClip({0})&quot;, shape);
            }
            if (DEBUG_DRAW_CLIP_SHAPE) {
                //Draw clip shape
                Rectangle rc = state.getClipNoClone();
                if (rc != null &amp;&amp; rc.width &gt;= 2 &amp;&amp; rc.height &gt;= 2) {
                    WCTransform cur = getTransform();
                    //translate to (layer.getX(), layer.getY())
                    setTransform(new WCTransform(
                        1.0, 0.0,
                        0.0, 1.0,
                        0.0, 0.0));

                    Graphics g2d = getGraphics(true);
                    if (g2d != null) {
                        float fbase = (float)Math.random();
                        g2d.setPaint(new Color(
                                fbase,
                                1f - fbase,
                                0.5f,
                                0.1f));
                        g2d.setStroke(new BasicStroke());
                        g2d.fillRect(rc.x, rc.y, rc.width, rc.height);

                        g2d.setPaint(new Color(
                                1f - fbase,
                                fbase,
                                0.5f,
                                1f));
                        g2d.drawRect(rc.x, rc.y, rc.width, rc.height);
                    }
                    //restore transform
                    setTransform(cur);
                    state.clip(new Rectangle(rc.x+1, rc.y+1, rc.width-2, rc.height-2));
                }
            }
            if (cachedGraphics != null) {
                cachedGraphics.setClipRect(state.getClipNoClone());
            }
        } else {
            //twisted axis set
            WCPath path = new WCPathImpl();
            path.addRect(shape.x, shape.y, shape.width, shape.height);
            setClip(path, false);
        }
    }

    public void setClip(int cx, int cy, int cw, int ch) {
        setClip(new Rectangle(cx, cy, cw, ch));
    }

    public void setClip(WCRectangle c) {
        setClip(new Rectangle((int)c.getX(), (int)c.getY(),
                              (int)c.getWidth(), (int)c.getHeight()));
    }

    public WCRectangle getClip() {
        Rectangle r = state.getClipNoClone();
        return r == null ? null : new WCRectangle(r.x, r.y, r.width, r.height);
    }

    protected Rectangle getClipRectNoClone() {
        return state.getClipNoClone();
    }

    protected Affine3D getTransformNoClone() {
        return state.getTransformNoClone();
    }

    public void translate(float x, float y) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;translate({0},{1})&quot;, new Object[] {x, y});
        }
        state.translate(x, y);
        if (cachedGraphics != null) {
            cachedGraphics.translate(x, y);
        }
    }

    public void scale(float sx, float sy) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;scale(&quot; + sx + &quot; &quot; + sy + &quot;)&quot;);
        }
        state.scale(sx, sy);
        if (cachedGraphics != null) {
            cachedGraphics.scale(sx, sy);
        }
    }

    public void rotate(float radians) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;rotate(&quot; + radians + &quot;)&quot;);
        }
        state.rotate(radians);
        if (cachedGraphics != null) {
            cachedGraphics.setTransform(state.getTransformNoClone());
        }
    }

    // overriden in WCBufferedContext
    protected boolean shouldRenderRect(float x, float y, float w, float h,
                                       DropShadow shadow, BasicStroke stroke)
    {
        return true;
    }

    // overriden in WCBufferedContext
    protected boolean shouldRenderShape(Shape shape, DropShadow shadow, BasicStroke stroke) {
        return true;
    }

    // overriden in WCBufferedContext
    protected boolean shouldCalculateIntersection() {
        return false;
    }

    @Override
    public void fillRect(final float x, final float y, final float w, final float h, final Integer rgba) {
        if (log.isLoggable(Level.FINE)) {
            String format = (rgba != null)
                    ? &quot;fillRect(%f, %f, %f, %f, 0x%x)&quot;
                    : &quot;fillRect(%f, %f, %f, %f, null)&quot;;
            log.fine(String.format(format, x, y, w, h, rgba));
        }
        if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                Paint paint = (rgba != null) ? createColor(rgba) : state.getPaintNoClone();
                DropShadow shadow = state.getShadowNoClone();
                // TextureMapperJava::drawSolidColor calls fillRect with perspective
                // projection.
                if (shadow != null || !state.getPerspectiveTransformNoClone().isIdentity()) {
                    final NGRectangle node = new NGRectangle();
                    node.updateRectangle(x, y, w, h, 0, 0);
                    render(g, shadow, paint, null, node);
                } else {
                    g.setPaint(paint);
                    g.fillRect(x, y, w, h);
                }
            }
        }.paint();
    }

    @Override
    public void fillRoundedRect(final float x, final float y, final float w, final float h,
        final float topLeftW, final float topLeftH, final float topRightW, final float topRightH,
        final float bottomLeftW, final float bottomLeftH, final float bottomRightW, final float bottomRightH,
        final int rgba)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;fillRoundedRect(%f, %f, %f, %f, &quot;
                    + &quot;%f, %f, %f, %f, %f, %f, %f, %f, 0x%x)&quot;,
                    x, y, w, h, topLeftW, topLeftH, topRightW, topRightH,
                    bottomLeftW, bottomLeftH, bottomRightW, bottomRightH, rgba));
        }
        if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                // Prism only supports single arcWidth/Height.
                // We work around by calculating average width and height here

                float arcW = (topLeftW + topRightW + bottomLeftW + bottomRightW) / 2;
                float arcH = (topLeftH + topRightH + bottomLeftH + bottomRightH) / 2;

                Paint paint = createColor(rgba);
                DropShadow shadow = state.getShadowNoClone();
                if (shadow != null) {
                    final NGRectangle node = new NGRectangle();
                    node.updateRectangle(x, y, w, h, arcW, arcH);
                    render(g, shadow, paint, null, node);
                } else {
                    g.setPaint(paint);
                    g.fillRoundRect(x, y, w, h, arcW, arcH);
                }
            }
        }.paint();
    }

    @Override
    public void clearRect(final float x, final float y, final float w, final float h) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;clearRect(%f, %f, %f, %f)&quot;, x, y, w, h));
        }
        if (shouldCalculateIntersection()) {
            // No intersection is applicable for clearRect.
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                g.clearQuad(x, y, x + w, y + h);
            }
        }.paint();
    }

    @Override
    public void setFillColor(int rgba) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;setFillColor(0x%x)&quot;, rgba));
        }
        state.setPaint(createColor(rgba));
    }

    @Override
    public void setFillGradient(WCGradient gradient) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setFillGradient(&quot; + gradient + &quot;)&quot;);
        }
        state.setPaint((Gradient) gradient.getPlatformGradient());
    }

    @Override
    public void setTextMode(boolean fill, boolean stroke, boolean clip) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setTextMode(fill:&quot; + fill + &quot;,stroke:&quot; + stroke + &quot;,clip:&quot; + clip + &quot;)&quot;);
        }
        state.setTextMode(fill, stroke, clip);
    }

    @Override
    public void setFontSmoothingType(int fontSmoothingType) {
        this.fontSmoothingType = fontSmoothingType;
    }

    @Override
    public int getFontSmoothingType() {
        return fontSmoothingType;
    }

    @Override
    public void setStrokeStyle(int style) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setStrokeStyle({0})&quot;, style);
        }
        state.getStrokeNoClone().setStyle(style);
    }

    @Override
    public void setStrokeColor(int rgba) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;setStrokeColor(0x%x)&quot;, rgba));
        }
        state.getStrokeNoClone().setPaint(createColor(rgba));
    }

    @Override
    public void setStrokeWidth(float width) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setStrokeWidth({0})&quot;, new Object[] { width });
        }
        state.getStrokeNoClone().setThickness(width);
    }

    @Override
    public void setStrokeGradient(WCGradient gradient) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setStrokeGradient(&quot; + gradient + &quot;)&quot;);
        }
        state.getStrokeNoClone().setPaint((Gradient) gradient.getPlatformGradient());
    }

    @Override
    public void setLineDash(float offset, float... sizes) {
        if (log.isLoggable(Level.FINE)) {
            StringBuilder s = new StringBuilder(&quot;[&quot;);
            for (int i=0; i &lt; sizes.length; i++) {
                s.append(sizes[i]).append(',');
            }
            s.append(']');
            log.fine(&quot;setLineDash({0},{1}&quot;, new Object[] {offset, s});
        }
        state.getStrokeNoClone().setDashOffset(offset);
        if (sizes != null) {
            boolean allZero = true;
            for (int i = 0; i &lt; sizes.length; i++) {
                if (sizes[i] != 0) {
                    allZero = false;
                    break;
                }
            }
            if (allZero) {
                sizes = null;
            }
        }
        state.getStrokeNoClone().setDashSizes(sizes);
    }

    @Override
    public void setLineCap(int lineCap) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setLineCap(&quot; + lineCap + &quot;)&quot;);
        }
        state.getStrokeNoClone().setLineCap(lineCap);
    }

    @Override
    public void setLineJoin(int lineJoin) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setLineJoin(&quot; + lineJoin + &quot;)&quot;);
        }
        state.getStrokeNoClone().setLineJoin(lineJoin);
    }

    @Override
    public void setMiterLimit(float miterLimit) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setMiterLimit(&quot; + miterLimit + &quot;)&quot;);
        }
        state.getStrokeNoClone().setMiterLimit(miterLimit);
    }

    @Override
    public void setShadow(float dx, float dy, float blur, int rgba) {
        if (log.isLoggable(Level.FINE)) {
            String format = &quot;setShadow(%f, %f, %f, 0x%x)&quot;;
            log.fine(String.format(format, dx, dy, blur, rgba));
        }
        state.setShadow(createShadow(dx, dy, blur, rgba));
    }

    @Override
    public void drawPolygon(final WCPath path, final boolean shouldAntialias) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawPolygon({0})&quot;,
                    new Object[] {shouldAntialias});
        }
        if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(), null,
                                state.getStrokeNoClone().getPlatformStroke()))
        {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                Path2D p2d = (Path2D) path.getPlatformPath();
                g.setPaint(state.getPaintNoClone());
                g.fill(p2d);
                if (state.getStrokeNoClone().apply(g)) {
                    g.draw(p2d);
                }
            }
        }.paint();
    }

    @Override
    public void drawLine(final int x0, final int y0, final int x1, final int y1) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawLine({0}, {1}, {2}, {3})&quot;,
                    new Object[] {x0, y0, x1, y1});
        }
        Line2D line = new Line2D(x0, y0, x1, y1);
        if (!shouldRenderShape(line, null, state.getStrokeNoClone().getPlatformStroke())) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                if (state.getStrokeNoClone().apply(g)) {
                    g.drawLine(x0, y0, x1, y1);
                }
            }
        }.paint();
    }

    @Override
    public void drawPattern(
        final WCImage texture,
        final WCRectangle srcRect,
        final WCTransform patternTransform,
        final WCPoint phase,
        final WCRectangle destRect)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawPattern({0}, {1}, {2}, {3})&quot;,
                    new Object[] {destRect.getIntX(), destRect.getIntY(),
                                  destRect.getIntWidth(),
                                  destRect.getIntHeight()});
        }
        if (!shouldRenderRect(destRect.getX(), destRect.getY(),
                              destRect.getWidth(), destRect.getHeight(), null, null))
        {
            return;
        }
        if (texture != null) {
            new Composite() {
                @Override void doPaint(Graphics g) {
                    // The handling of pattern transform is modeled after the WebKit
                    // ImageCG.cpp's Image::drawPattern()
                    float adjustedX = phase.getX()
                            + srcRect.getX() * (float) patternTransform.getMatrix()[0];
                    float adjustedY = phase.getY()
                            + srcRect.getY() * (float) patternTransform.getMatrix()[3];
                    float scaledTileWidth =
                            srcRect.getWidth() * (float) patternTransform.getMatrix()[0];
                    float scaledTileHeight =
                            srcRect.getHeight() * (float) patternTransform.getMatrix()[3];

                    Image img = ((PrismImage)texture).getImage();

                    // Create subImage only if srcRect doesn't fit the texture bounds. See RT-20193.
                    if (!srcRect.contains(new WCRectangle(0, 0, texture.getWidth(), texture.getHeight()))) {

                        img = img.createSubImage(srcRect.getIntX(),
                                                 srcRect.getIntY(),
                                                 (int)Math.ceil(srcRect.getWidth()),
                                                 (int)Math.ceil(srcRect.getHeight()));
                    }
                    g.setPaint(new ImagePattern(
                               img,
                               adjustedX, adjustedY,
                               scaledTileWidth, scaledTileHeight,
                               false, false));

                    g.fillRect(destRect.getX(), destRect.getY(),
                               destRect.getWidth(), destRect.getHeight());
                }
            }.paint();
        }
    }

    @Override
    public void drawImage(final WCImage img,
                          final float dstx, final float dsty, final float dstw, final float dsth,
                          final float srcx, final float srcy, final float srcw, final float srch)
    {
        if (log.isLoggable(Level.FINE)){
            log.fine(&quot;drawImage(img, dst({0},{1},{2},{3}), &quot; +
                    &quot;src({4},{5},{6},{7}))&quot;,
                    new Object[] {dstx, dsty, dstw, dsth,
                                  srcx, srcy, srcw, srch});
        }
        if (!shouldRenderRect(dstx, dsty, dstw, dsth, state.getShadowNoClone(), null)) {
            return;
        }
        if (img instanceof PrismImage) {
            new Composite() {
                @Override void doPaint(Graphics g) {
                    PrismImage pi = (PrismImage) img;
                    DropShadow shadow = state.getShadowNoClone();
                    if (shadow != null) {
                        NGImageView node = new NGImageView();
                        node.setImage(pi.getImage());
                        node.setX(dstx);
                        node.setY(dsty);
                        node.setViewport(srcx, srcy, srcw, srch, dstw, dsth);
                        node.setContentBounds(new RectBounds(dstx, dsty, dstx + dstw, dsty + dsth));
                        render(g, shadow, null, null, node);
                    } else {
                        pi.draw(g,
                                (int) dstx, (int) dsty,
                                (int) (dstx + dstw), (int) (dsty + dsth),
                                (int) srcx, (int) srcy,
                                (int) (srcx + srcw), (int) (srcy + srch));
                    }
                }
            }.paint();
        }
    }

    @Override
    public void drawBitmapImage(final ByteBuffer image, final int x, final int y, final int w, final int h) {
        if (!shouldRenderRect(x, y, w, h, null, null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                image.order(ByteOrder.nativeOrder());
                Image img = Image.fromByteBgraPreData(image, w, h);
                ResourceFactory rf = g.getResourceFactory();
                Texture txt = rf.createTexture(img, Texture.Usage.STATIC, Texture.WrapMode.REPEAT);
                g.drawTexture(txt, x, y, x + w, y + h, 0, 0, w, h);
                txt.dispose();
            }
        }.paint();
    }

    @Override
    public void drawIcon(WCIcon icon, int x, int y) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;UNIMPLEMENTED drawIcon ({0}, {1})&quot;,
                    new Object[] {x, y});
        }
    }

    @Override
    public void drawRect(final int x, final int y, final int w, final int h) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawRect({0}, {1}, {2}, {3})&quot;,
                    new Object[]{x, y, w, h});
        }
        if (!shouldRenderRect(x, y, w, h,
                              null, state.getStrokeNoClone().getPlatformStroke()))
        {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                Paint c = state.getPaintNoClone();
                if (c != null &amp;&amp; c.isOpaque()) {
                    g.setPaint(c);
                    g.fillRect(x, y, w, h);
                }

                if (state.getStrokeNoClone().apply(g)) {
                    g.drawRect(x, y, w, h);
                }
            }
        }.paint();
    }

    @Override
    public void drawString(final WCFont f, final int[] glyphs,
                           final float[] advances, final float x, final float y)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(
                    &quot;Drawing %d glyphs @(%.1f, %.1f)&quot;,
                    glyphs.length, x, y));
        }
        PGFont font = (PGFont)f.getPlatformFont();
        TextRun gl = TextUtilities.createGlyphList(glyphs, advances, x, y);

        DropShadow shadow = state.getShadowNoClone();
        BasicStroke stroke = state.isTextStroke()
                ? state.getStrokeNoClone().getPlatformStroke()
                : null;

        final FontStrike strike = font.getStrike(getTransformNoClone(), getFontSmoothingType());
        if (shouldCalculateIntersection()) {
            Metrics m = strike.getMetrics();
            gl.setMetrics(m.getAscent(), m.getDescent(), m.getLineGap());
            if (!shouldRenderRect(x, y, gl.getWidth(), gl.getHeight(), shadow, stroke)) {
                return;
            }
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                Paint paint = state.isTextFill()
                        ? state.getPaintNoClone()
                        : null;
                if (shadow != null) {
                    final NGText span = new NGText();
                    span.setGlyphs(new GlyphList[] {gl});
                    span.setFont(font);
                    span.setFontSmoothingType(fontSmoothingType);
                    render(g, shadow, paint, stroke, span);
                } else {
                    if (paint != null) {
                        g.setPaint(paint);
                        g.drawString(gl, strike, x, y, null, 0, 0);
                    }
                    if (stroke != null) {
                        paint = state.getStrokeNoClone().getPaint();
                        if (paint != null) {
                            g.setPaint(paint);
                            g.setStroke(stroke);
                            g.draw(strike.getOutline(gl, BaseTransform.getTranslateInstance(x, y)));
                        }
                    }
                }
            }
        }.paint();
    }

    @Override public void drawString(WCFont f, String str, boolean rtl,
            int from, int to, float x, float y)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(
                    &quot;str='%s' (length=%d), from=%d, to=%d, rtl=%b, @(%.1f, %.1f)&quot;,
                    str, str.length(), from, to, rtl, x, y));
        }
        TextLayout layout = TextUtilities.createLayout(
                str.substring(from, to), f.getPlatformFont());
        int count = 0;
        GlyphList[] runs = layout.getRuns();
        for (GlyphList run: runs) {
            count += run.getGlyphCount();
        }

        int[] glyphs = new int[count];
        float[] adv = new float[count];
        count = 0;
        for (GlyphList run: layout.getRuns()) {
            int gc = run.getGlyphCount();
            for (int i = 0; i &lt; gc; i++) {
                glyphs[count] = run.getGlyphCode(i);
                adv[count] = run.getPosX(i + 1) - run.getPosX(i);
                count++;
            }
        }

        // adjust x coordinate (see RT-29908)
        if (rtl) {
            x += (TextUtilities.getLayoutWidth(str.substring(from), f.getPlatformFont()) -
                  layout.getBounds().getWidth());
        } else {
            x += TextUtilities.getLayoutWidth(str.substring(0, from), f.getPlatformFont());
        }
        drawString(f, glyphs, adv, x, y);
    }

    @Override
    public void setComposite(int composite) {
        log.fine(&quot;setComposite({0})&quot;, composite);
        state.setCompositeOperation(composite);
    }

    @Override
    public void drawEllipse(final int x, final int y, final int w, final int h) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawEllipse({0}, {1}, {2}, {3})&quot;,
                    new Object[] { x, y, w, h});
        }
        if (!shouldRenderRect(x, y, w, h,
                              null, state.getStrokeNoClone().getPlatformStroke()))
        {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                g.setPaint(state.getPaintNoClone());
                g.fillEllipse(x, y, w, h);
                if (state.getStrokeNoClone().apply(g)) {
                    g.drawEllipse(x, y, w, h);
                }
            }
        }.paint();
    }

    private final static BasicStroke focusRingStroke =
        new BasicStroke(1.1f, BasicStroke.CAP_BUTT,
                         BasicStroke.JOIN_ROUND, 0.0f,
                         new float[] {1.0f}, 0.0f);

    @Override
    public void drawFocusRing(final int x, final int y, final int w, final int h, final int rgba) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;drawFocusRing: %d, %d, %d, %d, 0x%x&quot;, x, y, w, h, rgba));
        }
        if (!shouldRenderRect(x, y, w, h, null, focusRingStroke)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                g.setPaint(createColor(rgba));
                BasicStroke stroke = g.getStroke();
                g.setStroke(focusRingStroke);
                g.drawRoundRect(x, y, w, h, 4, 4);
                g.setStroke(stroke);
            }
        }.paint();
    }

    public void setAlpha(float alpha) {
        log.fine(&quot;setAlpha({0})&quot;, alpha);

        state.setAlpha(alpha);

        if (null != cachedGraphics) {
            cachedGraphics.setExtraAlpha(state.getAlpha());
        }
    }

    public float getAlpha() {
        return state.getAlpha();
    }

    @Override public void beginTransparencyLayer(float opacity) {
        TransparencyLayer layer = new TransparencyLayer(
                getGraphics(false), state.getClipNoClone(), opacity);

        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;beginTransparencyLayer(%s)&quot;, layer));
        }

        //[saveStateIntertal] will work as [saveState]
        state.markAsRestorePoint();

        startNewLayer(layer);
    }

    @Override public void endTransparencyLayer() {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;endTransparencyLayer(%s)&quot;, state.getLayerNoClone()));
        }

        //pair to [startNewLayer] that works as [saveState] call
        restoreState();
    }

    @Override
    public void drawWidget(final RenderTheme theme, final Ref widget, final int x, final int y) {
        WCSize s = theme.getWidgetSize(widget);
        if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                theme.drawWidget(WCGraphicsPrismContext.this, widget, x, y);
            }
        }.paint();
    }

    @Override
    public void drawScrollbar(final ScrollBarTheme theme, final Ref widget, int x, int y,
                              int pressedPart, int hoveredPart)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;drawScrollbar(%s, %s, x = %d, y = %d)&quot;, theme, widget, x, y));
        }

        WCSize s = theme.getWidgetSize(widget);
        if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                theme.paint(WCGraphicsPrismContext.this, widget, x, y, pressedPart, hoveredPart);
            }
        }.paint();
    }

    private static Rectangle intersect(Rectangle what, Rectangle with) {
        if (what == null) {
            return with;
        }
        RectBounds b = what.toRectBounds();
        b.intersectWith(with);
        what.setBounds(b);
        return what;
    }

    static Color createColor(int rgba) {
        float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
        float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
        float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
        float b = (0xFF &amp; (rgba)) / 255.0f;
        return new Color(r, g, b, a);
    }

    private static Color4f createColor4f(int rgba) {
        float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
        float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
        float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
        float b = (0xFF &amp; (rgba)) / 255.0f;
        return new Color4f(r, g, b, a);
    }

    private DropShadow createShadow(float dx, float dy, float blur, int rgba) {
        if (dx == 0f &amp;&amp; dy == 0f &amp;&amp; blur == 0f) {
            return null;
        }
        DropShadow shadow = new DropShadow();
        shadow.setOffsetX((int) dx);
        shadow.setOffsetY((int) dy);
        shadow.setRadius((blur &lt; 0f) ? 0f : (blur &gt; 127f) ? 127f : blur);
        shadow.setColor(createColor4f(rgba));
        return shadow;
    }

    private void render(Graphics g, Effect effect, Paint paint, BasicStroke stroke, NGNode node) {
        if (node instanceof NGShape) {
            NGShape shape = (NGShape) node;
            Shape realShape = shape.getShape();
            Paint strokePaint = state.getStrokeNoClone().getPaint();
            if ((stroke != null) &amp;&amp; (strokePaint != null)) {
                realShape = stroke.createStrokedShape(realShape);
                shape.setDrawStroke(stroke);
                shape.setDrawPaint(strokePaint);
                shape.setMode((paint == null) ? NGShape.Mode.STROKE : NGShape.Mode.STROKE_FILL);
            } else {
                shape.setMode((paint == null) ? NGShape.Mode.EMPTY : NGShape.Mode.FILL);
            }
            shape.setFillPaint(paint);
            shape.setContentBounds(realShape.getBounds());
        }
        boolean culling = g.hasPreCullingBits();
        g.setHasPreCullingBits(false);
        node.setEffect(effect);
        node.render(g);
        g.setHasPreCullingBits(culling);
    }

    private static final class ContextState {
        private final WCStrokeImpl stroke = new WCStrokeImpl();
        private Rectangle clip;
        private Paint paint;
        private float alpha;

        private boolean textFill = true;
        private boolean textStroke = false;
        private boolean textClip = false;
        private boolean restorePoint = false;

        private DropShadow shadow;
        private Affine3D xform;
        private GeneralTransform3D perspectiveTransform;
        private Layer layer;
        private int compositeOperation;

        private ContextState() {
            clip = null;
            paint = Color.BLACK;
            stroke.setPaint(Color.BLACK);
            alpha = 1.0f;
            xform = new Affine3D();
            perspectiveTransform = new GeneralTransform3D();
            compositeOperation = COMPOSITE_SOURCE_OVER;
        }

        private ContextState(ContextState state) {
            stroke.copyFrom(state.getStrokeNoClone());
            setPaint(state.getPaintNoClone());
            clip = state.getClipNoClone();
            if (clip != null) {
                clip = new Rectangle(clip);
            }
            xform = new Affine3D(state.getTransformNoClone());
            perspectiveTransform = new GeneralTransform3D().set(state.getPerspectiveTransformNoClone());
            setShadow(state.getShadowNoClone());
            setLayer(state.getLayerNoClone());
            setAlpha(state.getAlpha());
            setTextMode(state.isTextFill(), state.isTextStroke(), state.isTextClip());
            setCompositeOperation(state.getCompositeOperation());
        }

        @Override
        protected ContextState clone() {
            return new ContextState(this);
        }

        private void apply(Graphics g) {
            g.setTransform(getTransformNoClone());
            g.setPerspectiveTransform(getPerspectiveTransformNoClone());
            g.setClipRect(getClipNoClone());
            g.setExtraAlpha(getAlpha());
        }

        private int getCompositeOperation() {
            return compositeOperation;
        }

        private void setCompositeOperation(int compositeOperation) {
            this.compositeOperation = compositeOperation;
        }

        private WCStrokeImpl getStrokeNoClone() {
            return stroke;
        }

        private Paint getPaintNoClone() {
            return paint;
        }

        private void setPaint(Paint paint) {
            this.paint = paint;
        }

        private Rectangle getClipNoClone() {
            return clip;
        }

        private Layer getLayerNoClone() {
            return layer;
        }

        private void setLayer(Layer layer) {
            this.layer = layer;
        }

        private void setClip(Rectangle area) {
            clip = area;
        }

        private void clip(Rectangle area) {
            if (null == clip) {
                clip = area;
            } else {
                clip.intersectWith(area);
            }
        }

        private void setAlpha(float alpha) {
            this.alpha = alpha;
        }

        private float getAlpha() {
            return alpha;
        }

        private void setTextMode(boolean fill, boolean stroke, boolean clip) {
            textFill = fill;
            textStroke = stroke;
            textClip = clip;
        }

        private boolean isTextFill() {
            return textFill;
        }

        private boolean isTextStroke() {
            return textStroke;
        }

        private boolean isTextClip() {
            return textClip;
        }

        private void markAsRestorePoint() {
            restorePoint = true;
        }

        private boolean isRestorePoint() {
            return restorePoint;
        }

        private void setShadow(DropShadow shadow) {
            this.shadow = shadow;
        }

        private DropShadow getShadowNoClone() {
            return shadow;
        }

        private Affine3D getTransformNoClone() {
            return xform;
        }

        private GeneralTransform3D getPerspectiveTransformNoClone() {
            return perspectiveTransform;
        }

        private void setTransform(final Affine3D at) {
            this.xform.setTransform(at);
        }

        private void setPerspectiveTransform(final GeneralTransform3D gt) {
            this.perspectiveTransform.set(gt);
        }

        private void concatTransform(Affine3D at) {
            xform.concatenate(at);
        }

        private void translate(double dx, double dy) {
            xform.translate(dx, dy);
        }

        private void scale(double sx, double sy) {
            xform.scale(sx,sy);
        }

        private void rotate(double radians) {
            xform.rotate(radians);
        }
    }

    private abstract static class Layer {
        FilterContext fctx;
        PrDrawable buffer;
        Graphics graphics;
        final Rectangle bounds;
        boolean permanent;

        Layer(Graphics g, Rectangle bounds, boolean permanent) {
            this.bounds = new Rectangle(bounds);
            this.permanent = permanent;

            // avoid creating zero-size drawable, see also RT-21410
            int w = Math.max(bounds.width, 1);
            int h = Math.max(bounds.height, 1);
            fctx = getFilterContext(g);
            if (permanent) {
                ResourceFactory f = GraphicsPipeline.getDefaultResourceFactory();
                RTTexture rtt = f.createRTTexture(w, h, Texture.WrapMode.CLAMP_NOT_NEEDED);
                rtt.makePermanent();
                buffer = ((PrRenderer)Renderer.getRenderer(fctx)).createDrawable(rtt);
            } else {
                buffer = (PrDrawable) Effect.getCompatibleImage(fctx, w, h);
            }
        }

        Graphics getGraphics() {
            if (graphics == null) {
                graphics = buffer.createGraphics();
            }
            return graphics;
        }

        abstract void init(Graphics g);

        abstract void render(Graphics g);

        private void dispose() {
            if (buffer != null) {
                if (permanent) {
                    buffer.flush(); // releases the resource
                } else {
                    Effect.releaseCompatibleImage(fctx, buffer);
                }
                fctx = null;
                buffer = null;
            }
        }

        private double getX() { return (double) bounds.x; }
        private double getY() { return (double) bounds.y; }
    }

    private final class TransparencyLayer extends Layer {
        private final float opacity;

        private TransparencyLayer(Graphics g, Rectangle bounds, float opacity) {
            super(g, bounds, false);
            this.opacity = opacity;
        }

        @Override void init(Graphics g) {
            state.setCompositeOperation(COMPOSITE_SOURCE_OVER);
        }
<A NAME="52"></A>
        @Override void render(Graphics g) {
            new Composite() {
                @Override void doPaint(<FONT color="#2b60de"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#52',2,'match37-top.html#52',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Graphics g) {
                    float op = g.getExtraAlpha();
                    g.setExtraAlpha(opacity);
                    Affine3D tx = new Affine3D(g.getTransformNoClone());
                    g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
                    g.drawTexture(buffer.getTextureObject(),
                            bounds.x, bounds.y, bounds.width, bounds.height);
                    g.setTransform</B></FONT>(tx);
                    g.setExtraAlpha(op);
                }
            }.paint(g);
        }

        @Override public String toString() {
            return String.format(&quot;TransparencyLayer[%d,%d + %dx%d, opacity %.2f]&quot;,
                bounds.x, bounds.y, bounds.width, bounds.height, opacity);
        }
    }

    private static final class ClipLayer extends Layer {
        private final WCPath normalizedToClipPath;
        private boolean srcover;

        private ClipLayer(Graphics g, Rectangle bounds, WCPath normalizedToClipPath,
                          boolean permanent)
        {
            super(g, bounds, permanent);
            this.normalizedToClipPath = normalizedToClipPath;
            srcover = true;
        }

        @Override void init(Graphics g) {
            RTTexture texture = null;
            ReadbackGraphics readbackGraphics = null;
            try {
                readbackGraphics = (ReadbackGraphics) g;
                texture = readbackGraphics.readBack(bounds);
                getGraphics().drawTexture(texture, 0, 0, bounds.width, bounds.height);
            } finally {
                if (readbackGraphics != null &amp;&amp; texture != null) {
                    readbackGraphics.releaseReadBackBuffer(texture);
                }
            }
            srcover = false;
        }

        @Override void render(Graphics g) {
            Path2D p2d = ((WCPathImpl)normalizedToClipPath).getPlatformPath();

            // render normalizedToClipPath to a drawable
            PrDrawable bufferImg = (PrDrawable) Effect.getCompatibleImage(
                    fctx, bounds.width, bounds.height);
            Graphics bufferGraphics = bufferImg.createGraphics();

            bufferGraphics.setPaint(Color.BLACK);
            bufferGraphics.fill(p2d);

            // blend buffer and clipImg onto |g|
            if (g instanceof MaskTextureGraphics &amp;&amp; ! (g instanceof PrinterGraphics)) {
                MaskTextureGraphics mg = (MaskTextureGraphics) g;
                if (srcover) {
                    mg.drawPixelsMasked(buffer.getTextureObject(),
                                        bufferImg.getTextureObject(),
                                        bounds.x, bounds.y, bounds.width, bounds.height,
                                        0, 0, 0, 0);
                } else {
                    mg.maskInterpolatePixels(buffer.getTextureObject(),
                                             bufferImg.getTextureObject(),
                                             bounds.x, bounds.y, bounds.width, bounds.height,
                                             0, 0, 0, 0);
                }
            } else {
                Blend blend = new Blend(Blend.Mode.SRC_IN,
                        new PassThrough(bufferImg, bounds.width, bounds.height),
                        new PassThrough(buffer, bounds.width, bounds.height));
                Affine3D tx = new Affine3D(g.getTransformNoClone());
                g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
                PrEffectHelper.render(blend, g, bounds.x, bounds.y, null);
                g.setTransform(tx);
            }

            Effect.releaseCompatibleImage(fctx, bufferImg);
        }

        @Override public String toString() {
            return String.format(&quot;ClipLayer[%d,%d + %dx%d, path %s]&quot;,
                    bounds.x, bounds.y, bounds.width, bounds.height,
                    normalizedToClipPath);
        }
    }

    private abstract class Composite {
        abstract void doPaint(Graphics g);

        void paint() {
            paint(getGraphics(true));
        }

        void paint(Graphics g) {
            if (g != null) {
                CompositeMode oldCompositeMode = g.getCompositeMode();
                switch (state.getCompositeOperation()) {
                    // decode operations that don't require Blend first
                    case COMPOSITE_COPY:
                        g.setCompositeMode(CompositeMode.SRC);
                        doPaint(g);
                        g.setCompositeMode(oldCompositeMode);
                        break;
                    case COMPOSITE_SOURCE_OVER:
                        g.setCompositeMode(CompositeMode.SRC_OVER);
                        doPaint(g);
                        g.setCompositeMode(oldCompositeMode);
                        break;
                    default:
                        // other operations require usage of Blend
                        blend(g);
                        break;
                }
                isRootLayerValid = false;
            }
        }

        private void blend(Graphics g) {
            FilterContext fctx = getFilterContext(g);
            PrDrawable dstImg = null;
            PrDrawable srcImg = null;
            ReadbackGraphics readBackGraphics = null;
            RTTexture texture = null;
            Rectangle clip = state.getClipNoClone();
            WCImage image = getImage();
            try {
                if (image != null &amp;&amp; image instanceof PrismImage) {
                    // blending on canvas
                    dstImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
                    Graphics dstG = dstImg.createGraphics();
                    ((PrismImage) image).draw(dstG,
                            0, 0, clip.width, clip.height,
                            clip.x, clip.y, clip.width, clip.height);
                } else {
                    // blending on page
                    readBackGraphics = (ReadbackGraphics) g;
                    texture = readBackGraphics.readBack(clip);
                    dstImg = PrDrawable.create(fctx, texture);
                }

                srcImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
                Graphics srcG = srcImg.createGraphics();
                state.apply(srcG);
                doPaint(srcG);

                g.clear();
                PrEffectHelper.render(createEffect(dstImg, srcImg, clip.width, clip.height), g, 0, 0, null);

            } finally {
                if (srcImg != null) {
                    Effect.releaseCompatibleImage(fctx, srcImg);
                }
                if (dstImg != null) {
                    if (readBackGraphics != null &amp;&amp; texture != null) {
                        readBackGraphics.releaseReadBackBuffer(texture);
                    } else {
                        Effect.releaseCompatibleImage(fctx, dstImg);
                    }
                }
            }
        }

        // provides some syntax sugar for createEffect()
        private Effect createBlend(Blend.Mode mode,
                                   PrDrawable dstImg,
                                   PrDrawable srcImg,
                                   int width,
                                   int height)
        {
            return new Blend(
                    mode,
                    new PassThrough(dstImg, width, height),
                    new PassThrough(srcImg, width, height));
        }

        private Effect createEffect(PrDrawable dstImg,
                                    PrDrawable srcImg,
                                    int width,
                                    int height)
        {
            switch (state.getCompositeOperation()) {
                case COMPOSITE_CLEAR: // same as xor
                case COMPOSITE_XOR:
                    return new Blend(
                            SRC_OVER,
                            createBlend(SRC_OUT, dstImg, srcImg, width, height),
                            createBlend(SRC_OUT, srcImg, dstImg, width, height)
                    );
                case COMPOSITE_SOURCE_IN:
                    return createBlend(SRC_IN, dstImg, srcImg, width, height);
                case COMPOSITE_SOURCE_OUT:
                    return createBlend(SRC_OUT, dstImg, srcImg, width, height);
                case COMPOSITE_SOURCE_ATOP:
                    return createBlend(SRC_ATOP, dstImg, srcImg, width, height);
                case COMPOSITE_DESTINATION_OVER:
                    return createBlend(SRC_OVER, srcImg, dstImg, width, height);
                case COMPOSITE_DESTINATION_IN:
                    return createBlend(SRC_IN, srcImg, dstImg, width, height);
                case COMPOSITE_DESTINATION_OUT:
                    return createBlend(SRC_OUT, srcImg, dstImg, width, height);
                case COMPOSITE_DESTINATION_ATOP:
                    return createBlend(SRC_ATOP, srcImg, dstImg, width, height);
                case COMPOSITE_HIGHLIGHT:
                    return createBlend(ADD, dstImg, srcImg, width, height);
                default:
                    return createBlend(SRC_OVER, dstImg, srcImg, width, height);
            }
        }
    }

    private static final class PassThrough extends Effect {
        private final PrDrawable img;
        private final int width;
        private final int height;

        private PassThrough(PrDrawable img, int width, int height) {
            this.img = img;
            this.width = width;
            this.height = height;
        }

        @Override public ImageData filter(
                FilterContext fctx,
                BaseTransform transform,
                Rectangle outputClip,
                Object renderHelper,
                Effect defaultInput) {
            // We have an unpaired lock() here, because unlocking is done
            // internally by ImageData. See RT-33625 for details.
            img.lock();
            ImageData imgData = new ImageData(fctx, img, new Rectangle(
                                              (int) transform.getMxt(),
                                              (int) transform.getMyt(),
                                              width, height));
            imgData.setReusable(true);
            return imgData;
        }

        @Override public RectBounds getBounds(
                BaseTransform transform,
                Effect defaultInput) {
            return null;
        }

        @Override public AccelType getAccelType(FilterContext fctx) {
            return AccelType.INTRINSIC;
        }

        @Override
        public boolean reducesOpaquePixels() {
            return false;
        }

        @Override
        public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
            return null;
        }
    }

    private static FilterContext getFilterContext(Graphics g) {
        Screen screen = g.getAssociatedScreen();
        if (screen == null) {
            ResourceFactory factory = g.getResourceFactory();
            return PrFilterContext.getPrinterContext(factory);
        } else {
            return PrFilterContext.getInstance(screen);
        }
    }

    @Override
    public void strokeArc(final int x, final int y, final int w, final int h,
                          final int startAngle, final int angleSpan)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;strokeArc(%d, %d, %d, %d, %d, %d)&quot;,
                                   x, y, w, h, startAngle, angleSpan));
        }
        Arc2D arc = new Arc2D(x, y, w, h, startAngle, angleSpan, Arc2D.OPEN);
        if (state.getStrokeNoClone().isApplicable() &amp;&amp;
            !shouldRenderShape(arc, null, state.getStrokeNoClone().getPlatformStroke()))
        {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                if (state.getStrokeNoClone().apply(g)) {
                    g.draw(arc);
                }
            }
        }.paint();
    }

    @Override
    public WCImage getImage() {
        return null;
    }

    @Override
    public void strokeRect(final float x, final float y, final float w, final float h,
                           final float lineWidth) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;strokeRect_FFFFF(%f, %f, %f, %f, %f)&quot;,
                                   x, y, w, h, lineWidth));
        }
        BasicStroke stroke = new BasicStroke(
            lineWidth,
            BasicStroke.CAP_BUTT,
            BasicStroke.JOIN_MITER,
            Math.max(1.0f, lineWidth),
            state.getStrokeNoClone().getDashSizes(),
            state.getStrokeNoClone().getDashOffset());

        if (!shouldRenderRect(x, y, w, h, null, stroke)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                g.setStroke(stroke);
                Paint paint = state.getStrokeNoClone().getPaint();
                if (paint == null) {
                    paint = state.getPaintNoClone();
                }
                g.setPaint(paint);
                g.drawRect(x, y, w, h);
            }
        }.paint();
    }

    @Override
    public void strokePath(final WCPath path) {
        log.fine(&quot;strokePath&quot;);
        if (path != null) {
            final BasicStroke stroke = state.getStrokeNoClone().getPlatformStroke();
            final DropShadow shadow = state.getShadowNoClone();
            final Path2D p2d = (Path2D)path.getPlatformPath();

            if ((stroke == null &amp;&amp; shadow == null) ||
                !shouldRenderShape(p2d, shadow, stroke))
            {
                return;
            }
            new Composite() {
                @Override void doPaint(Graphics g) {
                    if (shadow != null) {
                        final NGPath node = new NGPath();
                        node.updateWithPath2d(p2d);
                        render(g, shadow, null, stroke, node);
                    } else if (stroke != null) {
                        Paint paint = state.getStrokeNoClone().getPaint();
                        if (paint == null) {
                            paint = state.getPaintNoClone();
                        }
                        g.setPaint(paint);
                        g.setStroke(stroke);
                        g.draw(p2d);
                    }
                }
            }.paint();
        }
    }

    @Override
    public void fillPath(final WCPath path) {
        log.fine(&quot;fillPath&quot;);
        if (path != null) {
            if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(),
                                   state.getShadowNoClone(), null))
            {
                return;
            }
            new Composite() {
                @Override void doPaint(Graphics g) {
                    Path2D p2d = (Path2D) path.getPlatformPath();
                    Paint paint = state.getPaintNoClone();
                    DropShadow shadow = state.getShadowNoClone();
                    if (shadow != null) {
                        final NGPath node = new NGPath();
                        node.updateWithPath2d(p2d);
                        render(g, shadow, paint, null, node);
                    } else {
                        g.setPaint(paint);
                        g.fill(p2d);
                    }
                }
            }.paint();
        }
    }

    public void setPerspectiveTransform(WCTransform tm) {
        final GeneralTransform3D at = new GeneralTransform3D().set(tm.getMatrix());
        state.setPerspectiveTransform(at);
        resetCachedGraphics();
    }

    public void setTransform(WCTransform tm) {
        final double m[] = tm.getMatrix();
        final Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
        if (state.getLayerNoClone() == null) {
            at.preConcatenate(baseTransform);
        }
        state.setTransform(at);
        resetCachedGraphics();
    }

    public WCTransform getTransform() {
        Affine3D xf = state.getTransformNoClone();
        return new WCTransform(xf.getMxx(), xf.getMyx(),
                               xf.getMxy(), xf.getMyy(),
                               xf.getMxt(), xf.getMyt());
    }

    public void concatTransform(WCTransform tm) {
        double m[] = tm.getMatrix();
        Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
        state.concatTransform(at);
        resetCachedGraphics();
    }

    @Override
    public void flush() {
        flushAllLayers();
    }

    @Override
    public WCGradient createLinearGradient(WCPoint p1, WCPoint p2) {
        return new WCLinearGradient(p1, p2);
    }

    @Override
    public WCGradient createRadialGradient(WCPoint p1, float r1, WCPoint p2, float r2) {
        return new WCRadialGradient(p1, r1, p2, r2);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/webkit/plugin/PluginManager.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.webkit.plugin;

import com.sun.javafx.logging.PlatformLogger;
import java.net.URL;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ServiceLoader;
import java.util.TreeMap;
import java.util.Vector;

public final class PluginManager {
    private final static PlatformLogger log =
            PlatformLogger.getLogger(&quot;com.sun.browser.plugin.PluginManager&quot;);

    private static final ServiceLoader&lt;PluginHandler&gt; pHandlers =
        ServiceLoader.load(PluginHandler.class);

    private static final TreeMap&lt;String,PluginHandler&gt; hndMap =
        new TreeMap&lt;String,PluginHandler&gt;();

    private static PluginHandler[] hndArray;

    private static final HashSet&lt;String&gt; disabledPluginHandlers =
        new HashSet&lt;String&gt;();


    private static void updatePluginHandlers() {
        log.fine(&quot;Update plugin handlers&quot;);

        hndMap.clear();

        Iterator&lt;PluginHandler&gt; iter = pHandlers.iterator();
        while(iter.hasNext()) {
            PluginHandler hnd = iter.next();
            if (hnd.isSupportedPlatform() &amp;&amp; !isDisabledPlugin(hnd))
            {
                String [] types = hnd.supportedMIMETypes();
                for (String type : types) {
                    hndMap.put(type, hnd);
                    log.fine(type);
                }
            }
        }
        Collection&lt;PluginHandler&gt; vals = hndMap.values();
        hndArray = vals.toArray(new PluginHandler[vals.size()]);
    }

    static {
        if (&quot;false&quot;.equalsIgnoreCase(
                System.getProperty(&quot;com.sun.browser.plugin&quot;)))
        {
            for(PluginHandler hnd : getAvailablePlugins()) {
                disabledPluginHandlers.add(hnd.getClass().getCanonicalName());
            }
        }

        updatePluginHandlers();
    }

    public static Plugin createPlugin(URL url, String type, String[] pNames,
                                        String[] pValues)
    {
        try {
            PluginHandler hnd =  hndMap.get(type);
            if (hnd == null) {
                return new DefaultPlugin(url, type, pNames, pValues);
            } else {
                Plugin p = hnd.createPlugin(url, type, pNames, pValues);
                if (p == null) {
                    return new DefaultPlugin(url, type, pNames, pValues);
                } else {
                    return p;
                }
            }
        } catch (Throwable ex) {
            log.fine(&quot;Cannot create plugin&quot; , ex);
            return new DefaultPlugin(url, type, pNames, pValues);
        }
    }


    private static List&lt;PluginHandler&gt; getAvailablePlugins() {
        Vector&lt;PluginHandler&gt; res = new Vector&lt;PluginHandler&gt;();
        Iterator&lt;PluginHandler&gt; iter = pHandlers.iterator();
        while(iter.hasNext()) {
            PluginHandler hnd = iter.next();
            if (hnd.isSupportedPlatform()) {
                res.add(hnd);
            }
        }
        return res;
    }

    private static PluginHandler getEnabledPlugin(int i) {
        if (i &lt; 0 || i &gt;= hndArray.length) return null;
        return hndArray[i];
    }

    private static int getEnabledPluginCount() {
        return hndArray.length;
<A NAME="45"></A>    }

    private static void disablePlugin(PluginHandler hnd) {
        <FONT color="#79d867"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#45',2,'match37-top.html#45',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>disabledPluginHandlers.add(hnd.getClass().getCanonicalName());
        updatePluginHandlers();
    }

    private static void enablePlugin(PluginHandler hnd) {
        disabledPluginHandlers.remove(hnd.getClass().getCanonicalName());
        updatePluginHandlers();
    }

    private static boolean isDisabledPlugin(PluginHandler hnd) {</B></FONT>
        return disabledPluginHandlers.contains(
            hnd.getClass().getCanonicalName());
    }

    private static boolean supportsMIMEType(String mimeType) {
        return hndMap.containsKey(mimeType);
    }

    private static String getPluginNameForMIMEType(String mimeType) {
        PluginHandler hnd = hndMap.get(mimeType);
        if (hnd != null) return hnd.getName();
        return &quot;&quot;;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/javafx/scene/web/WebEngine.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.web;

import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.scene.web.Debugger;
import com.sun.javafx.scene.web.Printable;
import com.sun.javafx.tk.TKPulseListener;
import com.sun.javafx.tk.Toolkit;
import com.sun.javafx.webkit.*;
import com.sun.javafx.webkit.prism.PrismGraphicsManager;
import com.sun.javafx.webkit.prism.PrismInvoker;
import com.sun.javafx.webkit.prism.theme.PrismRenderer;
import com.sun.javafx.webkit.theme.RenderThemeImpl;
import com.sun.javafx.webkit.theme.Renderer;
import com.sun.webkit.*;
import com.sun.webkit.graphics.WCGraphicsManager;
import com.sun.webkit.network.URLs;
import com.sun.webkit.network.Util;
import javafx.animation.AnimationTimer;
import javafx.application.Platform;
import javafx.beans.InvalidationListener;
import javafx.beans.property.*;
import javafx.concurrent.Worker;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.geometry.Rectangle2D;
import javafx.print.PageLayout;
import javafx.print.PrinterJob;
import javafx.scene.Node;
import javafx.util.Callback;
import org.w3c.dom.Document;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.IOException;
import static java.lang.String.format;
import java.lang.ref.WeakReference;
import java.net.MalformedURLException;
import java.net.URLConnection;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.PosixFilePermissions;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.Objects;

import static com.sun.webkit.LoadListenerClient.*;

/**
 * {@code WebEngine} is a non-visual object capable of managing one Web page
 * at a time. It loads Web pages, creates their document models, applies
 * styles as necessary, and runs JavaScript on pages. It provides access
 * to the document model of the current page, and enables two-way
 * communication between a Java application and JavaScript code of the page.
 *
 * &lt;p&gt;&lt;b&gt;Loading Web Pages&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;The {@code WebEngine} class provides two ways to load content into a
 * {@code WebEngine} object:
 * &lt;ul&gt;
 * &lt;li&gt;From an arbitrary URL using the {@link #load} method. This method uses
 *     the {@code java.net} package for network access and protocol handling.
 * &lt;li&gt;From an in-memory String using the
 *     {@link #loadContent(java.lang.String, java.lang.String)} and
 *     {@link #loadContent(java.lang.String)} methods.
 * &lt;/ul&gt;
 * &lt;p&gt;Loading always happens on a background thread. Methods that initiate
 * loading return immediately after scheduling a background job. To track
 * progress and/or cancel a job, use the {@link javafx.concurrent.Worker}
 * instance available from the {@link #getLoadWorker} method.
 *
 * &lt;p&gt;The following example changes the stage title when loading completes
 * successfully:
 * &lt;pre&gt;{@code
    import javafx.concurrent.Worker.State;
    final Stage stage;
    webEngine.getLoadWorker().stateProperty().addListener(
        new ChangeListener&lt;State&gt;() {
            public void changed(ObservableValue ov, State oldState, State newState) {
                if (newState == State.SUCCEEDED) {
                    stage.setTitle(webEngine.getLocation());
                }
            }
        });
    webEngine.load(&quot;http://javafx.com&quot;);
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;User Interface Callbacks&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;A number of user interface callbacks may be registered with a
 * {@code WebEngine} object. These callbacks are invoked when a script running
 * on the page requests a user interface operation to be performed, for
 * example, opens a popup window or changes status text. A {@code WebEngine}
 * object cannot handle such requests internally, so it passes the request to
 * the corresponding callbacks. If no callback is defined for a specific
 * operation, the request is silently ignored.
 *
 * &lt;p&gt;The table below shows JavaScript user interface methods and properties
 * with their corresponding {@code WebEngine} callbacks:
 * &lt;table border=&quot;1&quot;&gt;
 * &lt;caption&gt;JavaScript Callback Table&lt;/caption&gt;
 * &lt;tr&gt;
 *     &lt;th scope=&quot;col&quot;&gt;JavaScript method/property&lt;/th&gt;
 *     &lt;th scope=&quot;col&quot;&gt;WebEngine callback&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.alert()}&lt;/th&gt;&lt;td&gt;{@code onAlert}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.confirm()}&lt;/th&gt;&lt;td&gt;{@code confirmHandler}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.open()}&lt;/th&gt;&lt;td&gt;{@code createPopupHandler}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.open()} and&lt;br&gt;
 *         {@code window.close()}&lt;/th&gt;&lt;td&gt;{@code onVisibilityChanged}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.prompt()}&lt;/th&gt;&lt;td&gt;{@code promptHandler}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Setting {@code window.status}&lt;/th&gt;&lt;td&gt;{@code onStatusChanged}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Setting any of the following:&lt;br&gt;
 *         {@code window.innerWidth}, {@code window.innerHeight},&lt;br&gt;
 *         {@code window.outerWidth}, {@code window.outerHeight},&lt;br&gt;
 *         {@code window.screenX}, {@code window.screenY},&lt;br&gt;
 *         {@code window.screenLeft}, {@code window.screenTop}&lt;/th&gt;
 *         &lt;td&gt;{@code onResized}&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;p&gt;The following example shows a callback that resizes a browser window:
 * &lt;pre&gt;{@code
    Stage stage;
    webEngine.setOnResized(
        new EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;() {
            public void handle(WebEvent&lt;Rectangle2D&gt; ev) {
                Rectangle2D r = ev.getData();
                stage.setWidth(r.getWidth());
                stage.setHeight(r.getHeight());
            }
        });
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;Access to Document Model&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;The {@code WebEngine} objects create and manage a Document Object Model
 * (DOM) for their Web pages. The model can be accessed and modified using
 * Java DOM Core classes. The {@link #getDocument()} method provides access
 * to the root of the model. Additionally DOM Event specification is supported
 * to define event handlers in Java code.
 *
 * &lt;p&gt;The following example attaches a Java event listener to an element of
 * a Web page. Clicking on the element causes the application to exit:
 * &lt;pre&gt;{@code
    EventListener listener = new EventListener() {
        public void handleEvent(Event ev) {
            Platform.exit();
        }
    };

    Document doc = webEngine.getDocument();
    Element el = doc.getElementById(&quot;exit-app&quot;);
    ((EventTarget) el).addEventListener(&quot;click&quot;, listener, false);
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;Evaluating JavaScript expressions&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;It is possible to execute arbitrary JavaScript code in the context of
 * the current page using the {@link #executeScript} method. For example:
 * &lt;pre&gt;{@code
    webEngine.executeScript(&quot;history.back()&quot;);
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;The execution result is returned to the caller,
 * as described in the next section.
 *
 * &lt;p&gt;&lt;b&gt;Mapping JavaScript values to Java objects&lt;/b&gt;&lt;/p&gt;
 *
 * JavaScript values are represented using the obvious Java classes:
 * null becomes Java null; a boolean becomes a {@code java.lang.Boolean};
 * and a string becomes a {@code java.lang.String}.
 * A number can be {@code java.lang.Double} or a {@code java.lang.Integer},
 * depending.
 * The undefined value maps to a specific unique String
 * object whose value is {@code &quot;undefined&quot;}.
 * &lt;p&gt;
 * If the result is a
 * JavaScript object, it is wrapped as an instance of the
 * {@link netscape.javascript.JSObject} class.
 * (As a special case, if the JavaScript object is
 * a {@code JavaRuntimeObject} as discussed in the next section,
 * then the original Java object is extracted instead.)
 * The {@code JSObject} class is a proxy that provides access to
 * methods and properties of its underlying JavaScript object.
 * The most commonly used {@code JSObject} methods are
 * {@link netscape.javascript.JSObject#getMember getMember}
 * (to read a named property),
 * {@link netscape.javascript.JSObject#setMember setMember}
 * (to set or define a property),
 * and {@link netscape.javascript.JSObject#call call}
 * (to call a function-valued property).
 * &lt;p&gt;
 * A DOM {@code Node} is mapped to an object that both extends
 * {@code JSObject} and implements the appropriate DOM interfaces.
 * To get a {@code JSObject} object for a {@code Node} just do a cast:
 * &lt;pre&gt;
 * JSObject jdoc = (JSObject) webEngine.getDocument();
 * &lt;/pre&gt;
 * &lt;p&gt;
 * In some cases the context provides a specific Java type that guides
 * the conversion.
 * For example if setting a Java {@code String} field from a JavaScript
 * expression, then the JavaScript value is converted to a string.
 *
 * &lt;p&gt;&lt;b&gt;Mapping Java objects to JavaScript values&lt;/b&gt;&lt;/p&gt;
 *
 * The arguments of the {@code JSObject} methods {@code setMember} and
 * {@code call} pass Java objects to the JavaScript environment.
 * This is roughly the inverse of the JavaScript-to-Java mapping
 * described above:
 * Java {@code String},  {@code Number}, or {@code Boolean} objects
 * are converted to the obvious JavaScript values. A  {@code JSObject}
 * object is converted to the original wrapped JavaScript object.
 * Otherwise a {@code JavaRuntimeObject} is created.  This is
 * a JavaScript object that acts as a proxy for the Java object,
 * in that accessing properties of the {@code JavaRuntimeObject}
 * causes the Java field or method with the same name to be accessed.
 * &lt;p&gt; Note that the Java objects bound using
 * {@link netscape.javascript.JSObject#setMember JSObject.setMember},
 * {@link netscape.javascript.JSObject#setSlot JSObject.setSlot}, and
 * {@link netscape.javascript.JSObject#call JSObject.call}
 * are implemented using weak references. This means that the Java object
 * can be garbage collected, causing subsequent accesses to the JavaScript
 * objects to have no effect.
 *
 * &lt;p&gt;&lt;b&gt;Calling back to Java from JavaScript&lt;/b&gt;&lt;/p&gt;
 *
 * &lt;p&gt;The {@link netscape.javascript.JSObject#setMember JSObject.setMember}
 * method is useful to enable upcalls from JavaScript
 * into Java code, as illustrated by the following example. The Java code
 * establishes a new JavaScript object named {@code app}. This object has one
 * public member, the method {@code exit}.
 * &lt;pre&gt;&lt;code&gt;
public class JavaApplication {
    public void exit() {
        Platform.exit();
    }
}
...
JavaApplication javaApp = new JavaApplication();
JSObject window = (JSObject) webEngine.executeScript(&quot;window&quot;);
window.setMember(&quot;app&quot;, javaApp);
 * &lt;/code&gt;&lt;/pre&gt;
 * You can then refer to the object and the method from your HTML page:
 * &lt;pre&gt;{@code
    &lt;a href=&quot;&quot; onclick=&quot;app.exit()&quot;&gt;Click here to exit application&lt;/a&gt;
 * }&lt;/pre&gt;
 * &lt;p&gt;When a user clicks the link the application is closed.
 * &lt;p&gt;
 * Note that in the above example, the application holds a reference
 * to the {@code JavaApplication} instance. This is required for the callback
 * from JavaScript to execute the desired method.
 * &lt;p&gt; In the following example, the application does not hold a reference
 * to the Java object:
 * &lt;pre&gt;&lt;code&gt;
 * JSObject window = (JSObject) webEngine.executeScript(&quot;window&quot;);
 * window.setMember(&quot;app&quot;, new JavaApplication());
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt; In this case, since the property value is a local object, {@code &quot;new JavaApplication()&quot;},
 * the value may be garbage collected in next GC cycle.
 * &lt;p&gt;
 * When a user clicks the link, it does not guarantee to execute the callback method {@code exit}.
 * &lt;p&gt;
 * If there are multiple Java methods with the given name,
 * then the engine selects one matching the number of parameters
 * in the call.  (Varargs are not handled.) An unspecified one is
 * chosen if there are multiple ones with the correct number of parameters.
 * &lt;p&gt;
 * You can pick a specific overloaded method by listing the
 * parameter types in an &quot;extended method name&quot;, which has the
 * form &lt;code&gt;&quot;&lt;var&gt;method_name&lt;/var&gt;(&lt;var&gt;param_type1&lt;/var&gt;,...,&lt;var&gt;param_typen&lt;/var&gt;)&quot;&lt;/code&gt;.  Typically you'd write the JavaScript expression:
 * &lt;pre&gt;
 * &lt;code&gt;&lt;var&gt;receiver&lt;/var&gt;[&quot;&lt;var&gt;method_name&lt;/var&gt;(&lt;var&gt;param_type1&lt;/var&gt;,...,&lt;var&gt;param_typeN&lt;/var&gt;)&quot;](&lt;var&gt;arg1&lt;/var&gt;,...,&lt;var&gt;argN&lt;/var&gt;)&lt;/code&gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * The Java class and method must both be declared public.
 * &lt;/p&gt;
 *
 * &lt;p&gt;&lt;b&gt;Deploying an Application as a Module&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;
 * If any Java class passed to JavaScript is in a named module, then it must
 * be reflectively accessible to the {@code javafx.web} module.
 * A class is reflectively accessible if the module
 * {@link Module#isOpen(String,Module) opens} the containing package to at
 * least the {@code javafx.web} module.
 * Otherwise, the method will not be called, and no error or
 * warning will be produced.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For example, if {@code com.foo.MyClass} is in the {@code foo.app} module,
 * the {@code module-info.java} might
 * look like this:
 * &lt;/p&gt;
 *
&lt;pre&gt;{@code module foo.app {
    opens com.foo to javafx.web;
}}&lt;/pre&gt;
 *
 * &lt;p&gt;
 * Alternatively, a class is reflectively accessible if the module
 * {@link Module#isExported(String) exports} the containing package
 * unconditionally.
 * &lt;/p&gt;
 *
 * &lt;p&gt;&lt;b&gt;Threading&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;{@code WebEngine} objects must be created and accessed solely from the
 * JavaFX Application thread. This rule also applies to any DOM and JavaScript
 * objects obtained from the {@code WebEngine} object.
 * @since JavaFX 2.0
 */
final public class WebEngine {
    static {
        Accessor.setPageAccessor(w -&gt; w == null ? null : w.getPage());

        Invoker.setInvoker(new PrismInvoker());
        Renderer.setRenderer(new PrismRenderer());
        WCGraphicsManager.setGraphicsManager(new PrismGraphicsManager());
        CursorManager.setCursorManager(new CursorManagerImpl());
        com.sun.webkit.EventLoop.setEventLoop(new EventLoopImpl());
        ThemeClient.setDefaultRenderTheme(new RenderThemeImpl());
        Utilities.setUtilities(new UtilitiesImpl());
    }

    private static final PlatformLogger logger =
            PlatformLogger.getLogger(WebEngine.class.getName());

    /**
     * The number of instances of this class.
     * Used to start and stop the pulse timer.
     */
    private static int instanceCount = 0;

    /**
     * The node associated with this engine. There is a one-to-one correspondence
     * between the WebView and its WebEngine (although not all WebEngines have
     * a WebView, every WebView has one and only one WebEngine).
     */
    private final ObjectProperty&lt;WebView&gt; view = new SimpleObjectProperty&lt;WebView&gt;(this, &quot;view&quot;);

    /**
     * The Worker which shows progress of the web engine as it loads pages.
     */
    private final LoadWorker loadWorker = new LoadWorker();

    /**
     * The object that provides interaction with the native webkit core.
     */
    private final WebPage page;

    private final SelfDisposer disposer;

    private final DebuggerImpl debugger = new DebuggerImpl();

    private boolean userDataDirectoryApplied = false;


    /**
     * Returns a {@link javafx.concurrent.Worker} object that can be used to
     * track loading progress.
     *
     * @return the {@code Worker} object
     */
    public final Worker&lt;Void&gt; getLoadWorker() {
        return loadWorker;
    }


    /*
     * The final document. This may be null if no document has been loaded.
     */
    private final DocumentProperty document = new DocumentProperty();

    public final Document getDocument() { return document.getValue(); }

    /**
     * Document object for the current Web page. The value is {@code null}
     * if the Web page failed to load.
     *
     * @return the document property
     */
    public final ReadOnlyObjectProperty&lt;Document&gt; documentProperty() {
        return document;
    }


    /*
     * The location of the current page. This may return null.
     */
    private final ReadOnlyStringWrapper location = new ReadOnlyStringWrapper(this, &quot;location&quot;);

    public final String getLocation() { return location.getValue(); }

    /**
     * URL of the current Web page. If the current page has no URL,
     * the value is an empty String.
     *
     * @return the location property
     */
    public final ReadOnlyStringProperty locationProperty() { return location.getReadOnlyProperty(); }

    private void updateLocation(String value) {
        this.location.set(value);
        this.document.invalidate(false);
        this.title.set(null);
    }


    /*
     * The page title.
     */
    private final ReadOnlyStringWrapper title = new ReadOnlyStringWrapper(this, &quot;title&quot;);

    public final String getTitle() { return title.getValue(); }

    /**
     * Title of the current Web page. If the current page has no title,
     * the value is {@code null}.
     *
     * @return the title property
     */
    public final ReadOnlyStringProperty titleProperty() { return title.getReadOnlyProperty(); }

    private void updateTitle() {
        title.set(page.getTitle(page.getMainFrame()));
    }

    //
    // Settings

    /**
     * Specifies whether JavaScript execution is enabled.
     *
     * @defaultValue true
     * @since JavaFX 2.2
     */
    private BooleanProperty javaScriptEnabled;

    public final void setJavaScriptEnabled(boolean value) {
        javaScriptEnabledProperty().set(value);
    }

    public final boolean isJavaScriptEnabled() {
        return javaScriptEnabled == null ? true : javaScriptEnabled.get();
    }

    public final BooleanProperty javaScriptEnabledProperty() {
        if (javaScriptEnabled == null) {
            javaScriptEnabled = new BooleanPropertyBase(true) {
                @Override public void invalidated() {
                    checkThread();
                    page.setJavaScriptEnabled(get());
                }

                @Override public Object getBean() {
                    return WebEngine.this;
                }

                @Override public String getName() {
                    return &quot;javaScriptEnabled&quot;;
                }
            };
        }
        return javaScriptEnabled;
    }

    /**
     * Location of the user stylesheet as a string URL.
     *
     * &lt;p&gt;This should be a local URL, i.e. either {@code 'data:'},
     * {@code 'file:'}, or {@code 'jar:'}. Remote URLs are not allowed
     * for security reasons.
     *
     * @defaultValue null
     * @since JavaFX 2.2
     */
    private StringProperty userStyleSheetLocation;

    public final void setUserStyleSheetLocation(String value) {
        userStyleSheetLocationProperty().set(value);
    }

    public final String getUserStyleSheetLocation() {
        return userStyleSheetLocation == null ? null : userStyleSheetLocation.get();
    }

    private byte[] readFully(BufferedInputStream in) throws IOException {
        final int BUF_SIZE = 4096;
        int outSize = 0;
        final List&lt;byte[]&gt; outList = new ArrayList&lt;&gt;();
        byte[] buffer = new byte[BUF_SIZE];

        while (true) {
            int nBytes = in.read(buffer);
            if (nBytes &lt; 0) break;

            byte[] chunk;
            if (nBytes == buffer.length) {
                chunk = buffer;
                buffer = new byte[BUF_SIZE];
            } else {
                chunk = new byte[nBytes];
                System.arraycopy(buffer, 0, chunk, 0, nBytes);
            }
            outList.add(chunk);
            outSize += nBytes;
        }

        final byte[] out = new byte[outSize];
        int outPos = 0;
        for (byte[] chunk : outList) {
            System.arraycopy(chunk, 0, out, outPos, chunk.length);
            outPos += chunk.length;
        }

        return out;
    }

    public final StringProperty userStyleSheetLocationProperty() {
        if (userStyleSheetLocation == null) {
            userStyleSheetLocation = new StringPropertyBase(null) {
                private final static String DATA_PREFIX = &quot;data:text/css;charset=utf-8;base64,&quot;;

                @Override public void invalidated() {
                    checkThread();
                    String url = get();
                    String dataUrl;
                    if (url == null || url.length() &lt;= 0) {
                        dataUrl = null;
                    } else if (url.startsWith(DATA_PREFIX)) {
                        dataUrl = url;
                    } else if (url.startsWith(&quot;file:&quot;) ||
                               url.startsWith(&quot;jar:&quot;)  ||
                               url.startsWith(&quot;data:&quot;))
                    {
                        try {
                            URLConnection conn = URLs.newURL(url).openConnection();
                            conn.connect();

                            BufferedInputStream in =
                                    new BufferedInputStream(conn.getInputStream());
                            byte[] inBytes = readFully(in);
                            String out = Base64.getMimeEncoder().encodeToString(inBytes);
                            dataUrl = DATA_PREFIX + out;
                        } catch (IOException e) {
                            throw new RuntimeException(e);
                        }
                    } else {
                        throw new IllegalArgumentException(&quot;Invalid stylesheet URL&quot;);
                    }
                    page.setUserStyleSheetLocation(dataUrl);
                }

                @Override public Object getBean() {
                    return WebEngine.this;
                }

                @Override public String getName() {
                    return &quot;userStyleSheetLocation&quot;;
                }
            };
        }
        return userStyleSheetLocation;
    }

    /**
     * Specifies the directory to be used by this {@code WebEngine}
     * to store local user data.
     *
     * &lt;p&gt;If the value of this property is not {@code null},
     * the {@code WebEngine} will attempt to store local user data
     * in the respective directory.
     * If the value of this property is {@code null},
     * the {@code WebEngine} will attempt to store local user data
     * in an automatically selected system-dependent user- and
     * application-specific directory.
     *
     * &lt;p&gt;When a {@code WebEngine} is about to start loading a web
     * page or executing a script for the first time, it checks whether
     * it can actually use the directory specified by this property.
     * If the check fails for some reason, the {@code WebEngine} invokes
     * the {@link WebEngine#onErrorProperty WebEngine.onError} event handler,
     * if any, with a {@link WebErrorEvent} describing the reason.
     * If the invoked event handler modifies the {@code userDataDirectory}
     * property, the {@code WebEngine} retries with the new value as soon
     * as the handler returns. If the handler does not modify the
     * {@code userDataDirectory} property (which is the default),
     * the {@code WebEngine} continues without local user data.
     *
     * &lt;p&gt;Once the {@code WebEngine} has started loading a web page or
     * executing a script, changes made to this property have no effect
     * on where the {@code WebEngine} stores or will store local user
     * data.
     *
     * &lt;p&gt;Currently, the directory specified by this property is used
     * only to store the data that backs the {@code window.localStorage}
     * objects. In the future, more types of data can be added.
     *
     * @defaultValue {@code null}
     * @since JavaFX 8.0
     */
    private final ObjectProperty&lt;File&gt; userDataDirectory =
            new SimpleObjectProperty&lt;&gt;(this, &quot;userDataDirectory&quot;);

    public final File getUserDataDirectory() {
        return userDataDirectory.get();
    }

    public final void setUserDataDirectory(File value) {
        userDataDirectory.set(value);
    }

    public final ObjectProperty&lt;File&gt; userDataDirectoryProperty() {
        return userDataDirectory;
    }

    /**
     * Specifies user agent ID string. This string is the value of the
     * {@code User-Agent} HTTP header.
     *
     * @defaultValue system dependent
     * @since JavaFX 8.0
     */
    private StringProperty userAgent;

    public final void setUserAgent(String value) {
        userAgentProperty().set(value);
    }

    public final String getUserAgent() {
        return userAgent == null ? page.getUserAgent() : userAgent.get();
    }

    public final StringProperty userAgentProperty() {
        if (userAgent == null) {
            userAgent = new StringPropertyBase(page.getUserAgent()) {
                @Override public void invalidated() {
                    checkThread();
                    page.setUserAgent(get());
                }

                @Override public Object getBean() {
                    return WebEngine.this;
                }

                @Override public String getName() {
                    return &quot;userAgent&quot;;
                }
            };
        }
        return userAgent;
    }

    private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onAlert
            = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt;(this, &quot;onAlert&quot;);

    public final EventHandler&lt;WebEvent&lt;String&gt;&gt; getOnAlert() { return onAlert.get(); }

    public final void setOnAlert(EventHandler&lt;WebEvent&lt;String&gt;&gt; handler) { onAlert.set(handler); }

    /**
     * JavaScript {@code alert} handler property. This handler is invoked
     * when a script running on the Web page calls the {@code alert} function.
     * @return the onAlert property
     */
    public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onAlertProperty() { return onAlert; }


    private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onStatusChanged
            = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt;(this, &quot;onStatusChanged&quot;);

    public final EventHandler&lt;WebEvent&lt;String&gt;&gt; getOnStatusChanged() { return onStatusChanged.get(); }

    public final void setOnStatusChanged(EventHandler&lt;WebEvent&lt;String&gt;&gt; handler) { onStatusChanged.set(handler); }

    /**
     * JavaScript status handler property. This handler is invoked when
     * a script running on the Web page sets {@code window.status} property.
     * @return the onStatusChanged property
     */
    public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onStatusChangedProperty() { return onStatusChanged; }


    private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt; onResized
            = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt;(this, &quot;onResized&quot;);

    public final EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt; getOnResized() { return onResized.get(); }

    public final void setOnResized(EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt; handler) { onResized.set(handler); }

    /**
     * JavaScript window resize handler property. This handler is invoked
     * when a script running on the Web page moves or resizes the
     * {@code window} object.
     * @return the onResized property
     */
    public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt; onResizedProperty() { return onResized; }


    private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt; onVisibilityChanged
            = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt;(this, &quot;onVisibilityChanged&quot;);

    public final EventHandler&lt;WebEvent&lt;Boolean&gt;&gt; getOnVisibilityChanged() { return onVisibilityChanged.get(); }

    public final void setOnVisibilityChanged(EventHandler&lt;WebEvent&lt;Boolean&gt;&gt; handler) { onVisibilityChanged.set(handler); }

    /**
     * JavaScript window visibility handler property. This handler is invoked
     * when a script running on the Web page changes visibility of the
     * {@code window} object.
     * @return the onVisibilityChanged property
     */
    public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt; onVisibilityChangedProperty() { return onVisibilityChanged; }


    private final ObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt; createPopupHandler
            = new SimpleObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt;(this, &quot;createPopupHandler&quot;,
            p -&gt; WebEngine.this);

    public final Callback&lt;PopupFeatures, WebEngine&gt; getCreatePopupHandler() { return createPopupHandler.get(); }

    public final void setCreatePopupHandler(Callback&lt;PopupFeatures, WebEngine&gt; handler) { createPopupHandler.set(handler); }

    /**
     * JavaScript popup handler property. This handler is invoked when a script
     * running on the Web page requests a popup to be created.
     * &lt;p&gt;To satisfy this request a handler may create a new {@code WebEngine},
     * attach a visibility handler and optionally a resize handler, and return
     * the newly created engine. To block the popup, a handler should return
     * {@code null}.
     * &lt;p&gt;By default, a popup handler is installed that opens popups in this
     * {@code WebEngine}.
     *
     * @return the createPopupHandler property
     *
     * @see PopupFeatures
     */
    public final ObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt; createPopupHandlerProperty() { return createPopupHandler; }


    private final ObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt; confirmHandler
            = new SimpleObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt;(this, &quot;confirmHandler&quot;);

    public final Callback&lt;String, Boolean&gt; getConfirmHandler() { return confirmHandler.get(); }

    public final void setConfirmHandler(Callback&lt;String, Boolean&gt; handler) { confirmHandler.set(handler); }

    /**
     * JavaScript {@code confirm} handler property. This handler is invoked
     * when a script running on the Web page calls the {@code confirm} function.
     * &lt;p&gt;An implementation may display a dialog box with Yes and No options,
     * and return the user's choice.
     *
     * @return the confirmHandler property
     */
    public final ObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt; confirmHandlerProperty() { return confirmHandler; }


    private final ObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt; promptHandler
            = new SimpleObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt;(this, &quot;promptHandler&quot;);

    public final Callback&lt;PromptData, String&gt; getPromptHandler() { return promptHandler.get(); }

    public final void setPromptHandler(Callback&lt;PromptData, String&gt; handler) { promptHandler.set(handler); }

    /**
     * JavaScript {@code prompt} handler property. This handler is invoked
     * when a script running on the Web page calls the {@code prompt} function.
     * &lt;p&gt;An implementation may display a dialog box with an text field,
     * and return the user's input.
     *
     * @return the promptHandler property
     * @see PromptData
     */
    public final ObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt; promptHandlerProperty() { return promptHandler; }

    /**
     * The event handler called when an error occurs.
     *
     * @defaultValue {@code null}
     * @since JavaFX 8.0
     */
    private final ObjectProperty&lt;EventHandler&lt;WebErrorEvent&gt;&gt; onError =
            new SimpleObjectProperty&lt;&gt;(this, &quot;onError&quot;);

    public final EventHandler&lt;WebErrorEvent&gt; getOnError() {
        return onError.get();
    }

    public final void setOnError(EventHandler&lt;WebErrorEvent&gt; handler) {
        onError.set(handler);
    }

    public final ObjectProperty&lt;EventHandler&lt;WebErrorEvent&gt;&gt; onErrorProperty() {
        return onError;
    }


    /**
     * Creates a new engine.
     */
    public WebEngine() {
        this(null, false);
    }

    /**
     * Creates a new engine and loads a Web page into it.
     *
     * @param url the URL of the web page to load
     */
    public WebEngine(String url) {
        this(url, true);
    }

    private WebEngine(String url, boolean callLoad) {
        checkThread();
        Accessor accessor = new AccessorImpl(this);
        page = new WebPage(
            new WebPageClientImpl(accessor),
            new UIClientImpl(accessor),
            null,
            new InspectorClientImpl(this),
            new ThemeClientImpl(accessor),
            false);
        page.addLoadListenerClient(new PageLoadListener(this));

        history = new WebHistory(page);

        disposer = new SelfDisposer(page);
        Disposer.addRecord(this, disposer);

        if (callLoad) {
            load(url);
        }

        if (instanceCount == 0 &amp;&amp;
            Timer.getMode() == Timer.Mode.PLATFORM_TICKS)
        {
            PulseTimer.start();
        }
        instanceCount++;
    }

    /**
     * Loads a Web page into this engine. This method starts asynchronous
     * loading and returns immediately.
     * @param url URL of the web page to load
     */
    public void load(String url) {
        checkThread();
        loadWorker.cancelAndReset();

        if (url == null || url.equals(&quot;&quot;) || url.equals(&quot;about:blank&quot;)) {
            url = &quot;&quot;;
        } else {
            // verify and, if possible, adjust the url on the Java
            // side, otherwise it may crash native code
            try {
                url = Util.adjustUrlForWebKit(url);
            } catch (MalformedURLException e) {
                loadWorker.dispatchLoadEvent(getMainFrame(),
                        PAGE_STARTED, url, null, 0.0, 0);
                loadWorker.dispatchLoadEvent(getMainFrame(),
                        LOAD_FAILED, url, null, 0.0, MALFORMED_URL);
                return;
            }
        }
        applyUserDataDirectory();
        page.open(page.getMainFrame(), url);
    }

    /**
     * Loads the given HTML content directly. This method is useful when you have an HTML
     * String composed in memory, or loaded from some system which cannot be reached via
     * a URL (for example, the HTML text may have come from a database). As with
     * {@link #load(String)}, this method is asynchronous.
     *
     * @param content the HTML content to load
     */
    public void loadContent(String content) {
        loadContent(content, &quot;text/html&quot;);
    }

    /**
     * Loads the given content directly. This method is useful when you have content
     * composed in memory, or loaded from some system which cannot be reached via
     * a URL (for example, the SVG text may have come from a database). As with
     * {@link #load(String)}, this method is asynchronous. This method also allows you to
     * specify the content type of the string being loaded, and so may optionally support
     * other types besides just HTML.
     *
     * @param content the HTML content to load
     * @param contentType the type of content to load
     */
    public void loadContent(String content, String contentType) {
        checkThread();
        loadWorker.cancelAndReset();
        applyUserDataDirectory();
        page.load(page.getMainFrame(), content, contentType);
    }

    /**
     * Reloads the current page, whether loaded from URL or directly from a String in
     * one of the {@code loadContent} methods.
     */
    public void reload() {
        // TODO what happens if this is called while currently loading a page?
        checkThread();
        page.refresh(page.getMainFrame());
    }

    private final WebHistory history;

    /**
     * Returns the session history object.
     *
     * @return history object
     * @since JavaFX 2.2
     */
    public WebHistory getHistory() {
        return history;
    }

    /**
     * Executes a script in the context of the current page.
     *
     * @param script the script
     * @return execution result, converted to a Java object using the following
     * rules:
     * &lt;ul&gt;
     * &lt;li&gt;JavaScript Int32 is converted to {@code java.lang.Integer}
     * &lt;li&gt;Other JavaScript numbers to {@code java.lang.Double}
     * &lt;li&gt;JavaScript string to {@code java.lang.String}
     * &lt;li&gt;JavaScript boolean to {@code java.lang.Boolean}
     * &lt;li&gt;JavaScript {@code null} to {@code null}
     * &lt;li&gt;Most JavaScript objects get wrapped as
     *     {@code netscape.javascript.JSObject}
     * &lt;li&gt;JavaScript JSNode objects get mapped to instances of
     *     {@code netscape.javascript.JSObject}, that also implement
     *     {@code org.w3c.dom.Node}
     * &lt;li&gt;A special case is the JavaScript class {@code JavaRuntimeObject}
     *     which is used to wrap a Java object as a JavaScript value - in this
     *     case we just extract the original Java value.
     * &lt;/ul&gt;
     */
    public Object executeScript(String script) {
        checkThread();
        applyUserDataDirectory();
        return page.executeScript(page.getMainFrame(), script);
    }

    private long getMainFrame() {
        return page.getMainFrame();
    }

    WebPage getPage() {
        return page;
    }

    void setView(WebView view) {
        this.view.setValue(view);
    }

    private void stop() {
        checkThread();
        page.stop(page.getMainFrame());
    }

    private void applyUserDataDirectory() {
        if (userDataDirectoryApplied) {
            return;
        }
        userDataDirectoryApplied = true;
        File nominalUserDataDir = getUserDataDirectory();
        while (true) {
            File userDataDir;
            String displayString;
            if (nominalUserDataDir == null) {
                userDataDir = defaultUserDataDirectory();
                displayString = format(&quot;null (%s)&quot;, userDataDir);
            } else {
                userDataDir = nominalUserDataDir;
                displayString = userDataDir.toString();
            }
            logger.fine(&quot;Trying to apply user data directory [{0}]&quot;, displayString);
            String errorMessage;
            EventType&lt;WebErrorEvent&gt; errorType;
            Throwable error;
            try {
                userDataDir = DirectoryLock.canonicalize(userDataDir);
                File localStorageDir = new File(userDataDir, &quot;localstorage&quot;);
                File[] dirs = new File[] {
                    userDataDir,
                    localStorageDir,
                };
                for (File dir : dirs) {
                    createDirectories(dir);
                    // Additional security check to make sure the caller
                    // has permission to write to the target directory
                    File test = new File(dir, &quot;.test&quot;);
                    if (test.createNewFile()) {
                        test.delete();
                    }
                }
                disposer.userDataDirectoryLock = new DirectoryLock(userDataDir);

                page.setLocalStorageDatabasePath(localStorageDir.getPath());
                page.setLocalStorageEnabled(true);

                logger.fine(&quot;User data directory [{0}] has &quot;
                        + &quot;been applied successfully&quot;, displayString);
                return;

            } catch (DirectoryLock.DirectoryAlreadyInUseException ex) {
                errorMessage = &quot;User data directory [%s] is already in use&quot;;
                errorType = WebErrorEvent.USER_DATA_DIRECTORY_ALREADY_IN_USE;
                error = ex;
            } catch (IOException ex) {
                errorMessage = &quot;An I/O error occurred while setting up &quot;
                        + &quot;user data directory [%s]&quot;;
                errorType = WebErrorEvent.USER_DATA_DIRECTORY_IO_ERROR;
                error = ex;
            } catch (SecurityException ex) {
                errorMessage = &quot;A security error occurred while setting up &quot;
                        + &quot;user data directory [%s]&quot;;
                errorType = WebErrorEvent.USER_DATA_DIRECTORY_SECURITY_ERROR;
                error = ex;
            }

            errorMessage = format(errorMessage, displayString);
            logger.fine(&quot;{0}, calling error handler&quot;, errorMessage);
            File oldNominalUserDataDir = nominalUserDataDir;
            fireError(errorType, errorMessage, error);
            nominalUserDataDir = getUserDataDirectory();
            if (Objects.equals(nominalUserDataDir, oldNominalUserDataDir)) {
                logger.fine(&quot;Error handler did not modify user data directory, &quot;
                        + &quot;continuing without user data directory&quot;);
                return;
            } else {
                logger.fine(&quot;Error handler has set user data directory to [{0}], &quot;
                        + &quot;retrying&quot;, nominalUserDataDir);
                continue;
            }
        }
    }

    private static File defaultUserDataDirectory() {
        return new File(
                com.sun.glass.ui.Application.GetApplication()
                        .getDataDirectory(),
                &quot;webview&quot;);
    }

    private static void createDirectories(File directory) throws IOException {
        Path path = directory.toPath();
        try {
            Files.createDirectories(path, PosixFilePermissions.asFileAttribute(
                    PosixFilePermissions.fromString(&quot;rwx------&quot;)));
        } catch (UnsupportedOperationException ex) {
            Files.createDirectories(path);
        }
    }

    private void fireError(EventType&lt;WebErrorEvent&gt; eventType, String message,
                           Throwable exception)
    {
        EventHandler&lt;WebErrorEvent&gt; handler = getOnError();
        if (handler != null) {
            handler.handle(new WebErrorEvent(this, eventType,
                                             message, exception));
        }
    }

    // for testing purposes only
    void dispose() {
        disposer.dispose();
    }

    private static final class SelfDisposer implements DisposerRecord {
        private WebPage page;
        private DirectoryLock userDataDirectoryLock;

        private SelfDisposer(WebPage page) {
            this.page = page;
        }

        @Override public void dispose() {
            if (page == null) {
                return;
            }
            page.dispose();
            page = null;
            if (userDataDirectoryLock != null) {
                userDataDirectoryLock.close();
            }
            instanceCount--;
            if (instanceCount == 0 &amp;&amp;
                Timer.getMode() == Timer.Mode.PLATFORM_TICKS)
            {
                PulseTimer.stop();
            }
        }
    }

    private static final class AccessorImpl extends Accessor {
        private final WeakReference&lt;WebEngine&gt; engine;

        private AccessorImpl(WebEngine w) {
            this.engine = new WeakReference&lt;WebEngine&gt;(w);
        }

        @Override public WebEngine getEngine() {
            return engine.get();
        }

        @Override public WebPage getPage() {
            WebEngine w = getEngine();
            return w == null ? null : w.page;
        }

        @Override public WebView getView() {
            WebEngine w = getEngine();
            return w == null ? null : w.view.get();
        }

        @Override public void addChild(Node child) {
            WebView view = getView();
            if (view != null) {
                view.getChildren().add(child);
            }
        }

        @Override public void removeChild(Node child) {
            WebView view = getView();
            if (view != null) {
                view.getChildren().remove(child);
            }
        }

        @Override public void addViewListener(InvalidationListener l) {
            WebEngine w = getEngine();
            if (w != null) {
                w.view.addListener(l);
            }
        }
    }

    /**
     * Drives the {@code Timer} when {@code Timer.Mode.PLATFORM_TICKS} is set.
     */
    private static final class PulseTimer {

        // Used just to guarantee constant pulse activity. See RT-14433.
        private static final AnimationTimer animation =
            new AnimationTimer() {
                @Override public void handle(long l) {}
            };

        private static final TKPulseListener listener =
                () -&gt; {
                    // Note, the timer event is executed right in the notifyTick(),
                    // that is during the pulse event. This makes the timer more
                    // repsonsive, though prolongs the pulse. So far it causes no
                    // problems but nevertheless it should be kept in mind.

                    // Execute notifyTick in runLater to run outside of pulse so
                    // that events will run in order and be able to display dialogs
                    // or call other methods that require a nested event loop.
                    Platform.runLater(() -&gt; Timer.getTimer().notifyTick());
                };

        private static void start(){
            Toolkit.getToolkit().addSceneTkPulseListener(listener);
            animation.start();
        }

        private static void stop() {
            Toolkit.getToolkit().removeSceneTkPulseListener(listener);
            animation.stop();
        }
    }

    static void checkThread() {
        Toolkit.getToolkit().checkFxUserThread();
    }


    /**
     * The page load event listener. This object references the owner
     * WebEngine weakly so as to avoid referencing WebEngine from WebPage
     * strongly.
     */
    private static final class PageLoadListener implements LoadListenerClient {

        private final WeakReference&lt;WebEngine&gt; engine;


        private PageLoadListener(WebEngine engine) {
            this.engine = new WeakReference&lt;WebEngine&gt;(engine);
        }


        @Override public void dispatchLoadEvent(long frame, int state,
                String url, String contentType, double progress, int errorCode)
        {
            WebEngine w = engine.get();
            if (w != null) {
                w.loadWorker.dispatchLoadEvent(frame, state, url,
                        contentType, progress, errorCode);
            }
        }

        @Override public void dispatchResourceLoadEvent(long frame,
                int state, String url, String contentType, double progress,
                int errorCode)
        {
        }
    }


    private final class LoadWorker implements Worker&lt;Void&gt; {

        private final ReadOnlyObjectWrapper&lt;State&gt; state = new ReadOnlyObjectWrapper&lt;State&gt;(this, &quot;state&quot;, State.READY);
        @Override public final State getState() { checkThread(); return state.get(); }
        @Override public final ReadOnlyObjectProperty&lt;State&gt; stateProperty() { checkThread(); return state.getReadOnlyProperty(); }
        private void updateState(State value) {
            checkThread();
            this.state.set(value);
            running.set(value == State.SCHEDULED || value == State.RUNNING);
        }

        /**
         * @InheritDoc
         */
        private final ReadOnlyObjectWrapper&lt;Void&gt; value = new ReadOnlyObjectWrapper&lt;Void&gt;(this, &quot;value&quot;, null);
        @Override public final Void getValue() { checkThread(); return value.get(); }
        @Override public final ReadOnlyObjectProperty&lt;Void&gt; valueProperty() { checkThread(); return value.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyObjectWrapper&lt;Throwable&gt; exception = new ReadOnlyObjectWrapper&lt;Throwable&gt;(this, &quot;exception&quot;);
        @Override public final Throwable getException() { checkThread(); return exception.get(); }
        @Override public final ReadOnlyObjectProperty&lt;Throwable&gt; exceptionProperty() { checkThread(); return exception.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyDoubleWrapper workDone = new ReadOnlyDoubleWrapper(this, &quot;workDone&quot;, -1);
        @Override public final double getWorkDone() { checkThread(); return workDone.get(); }
        @Override public final ReadOnlyDoubleProperty workDoneProperty() { checkThread(); return workDone.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyDoubleWrapper totalWorkToBeDone = new ReadOnlyDoubleWrapper(this, &quot;totalWork&quot;, -1);
        @Override public final double getTotalWork() { checkThread(); return totalWorkToBeDone.get(); }
        @Override public final ReadOnlyDoubleProperty totalWorkProperty() { checkThread(); return totalWorkToBeDone.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyDoubleWrapper progress = new ReadOnlyDoubleWrapper(this, &quot;progress&quot;, -1);
        @Override public final double getProgress() { checkThread(); return progress.get(); }
        @Override public final ReadOnlyDoubleProperty progressProperty() { checkThread(); return progress.getReadOnlyProperty(); }
        private void updateProgress(double p) {
            totalWorkToBeDone.set(100.0);
            workDone.set(p * 100.0);
            progress.set(p);
        }

        /**
         * @InheritDoc
         */
        private final ReadOnlyBooleanWrapper running = new ReadOnlyBooleanWrapper(this, &quot;running&quot;, false);
        @Override public final boolean isRunning() { checkThread(); return running.get(); }
        @Override public final ReadOnlyBooleanProperty runningProperty() { checkThread(); return running.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyStringWrapper message = new ReadOnlyStringWrapper(this, &quot;message&quot;, &quot;&quot;);
        @Override public final String getMessage() { return message.get(); }
        @Override public final ReadOnlyStringProperty messageProperty() { return message.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyStringWrapper title = new ReadOnlyStringWrapper(this, &quot;title&quot;, &quot;WebEngine Loader&quot;);
        @Override public final String getTitle() { return title.get(); }
        @Override public final ReadOnlyStringProperty titleProperty() { return title.getReadOnlyProperty(); }

        /**
         * Cancels the loading of the page. If called after the page has already
         * been loaded, then this call takes no effect.
         */
        @Override public boolean cancel() {
            if (isRunning()) {
                stop(); // this call indirectly sets state
                return true;
<A NAME="39"></A>            } else {
                return false;
            }
        <FONT color="#152dc6"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#39',2,'match37-top.html#39',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

        private void cancelAndReset() {
            cancel();
            exception.set(null);
            message.set(&quot;&quot;);
            totalWorkToBeDone.set(-1);
            workDone.set(-1);
            progress.set(-1);
            updateState(State.READY);
            running.set(false);
        }

        private void disp</B></FONT>atchLoadEvent(long frame, int state,
                String url, String contentType, double workDone, int errorCode)
        {
            if (frame != getMainFrame()) {
                return;
            }
            switch (state) {
                case PAGE_STARTED:
                    message.set(&quot;Loading &quot; + url);
                    updateLocation(url);
                    updateProgress(0.0);
                    updateState(State.SCHEDULED);
                    updateState(State.RUNNING);
                    break;
                case PAGE_REDIRECTED:
                    message.set(&quot;Loading &quot; + url);
                    updateLocation(url);
                    break;
                case PAGE_REPLACED:
                    message.set(&quot;Replaced &quot; + url);
                    // Update only the location, don't change title or document.
                    WebEngine.this.location.set(url);
                    break;
                case PAGE_FINISHED:
                    message.set(&quot;Loading complete&quot;);
                    updateProgress(1.0);
                    updateState(State.SUCCEEDED);
                    break;
                case LOAD_FAILED:
                    message.set(&quot;Loading failed&quot;);
                    exception.set(describeError(errorCode));
                    updateState(State.FAILED);
                    break;
                case LOAD_STOPPED:
                    message.set(&quot;Loading stopped&quot;);
                    updateState(State.CANCELLED);
                    break;
                case PROGRESS_CHANGED:
                    updateProgress(workDone);
                    break;
                case TITLE_RECEIVED:
                    updateTitle();
                    break;
                case DOCUMENT_AVAILABLE:
                    if (this.state.get() != State.RUNNING) {
                        // We have empty load; send a synthetic event (RT-32097)
                        dispatchLoadEvent(frame, PAGE_STARTED, url, contentType, workDone, errorCode);
                    }
                    document.invalidate(true);
                    break;
            }
        }

        private Throwable describeError(int errorCode) {
            String reason = &quot;Unknown error&quot;;

            switch (errorCode) {
                case UNKNOWN_HOST:
                    reason = &quot;Unknown host&quot;;
                    break;
                case MALFORMED_URL:
                    reason = &quot;Malformed URL&quot;;
                    break;
                case SSL_HANDSHAKE:
                    reason = &quot;SSL handshake failed&quot;;
                    break;
                case CONNECTION_REFUSED:
                    reason = &quot;Connection refused by server&quot;;
                    break;
                case CONNECTION_RESET:
                    reason = &quot;Connection reset by server&quot;;
                    break;
                case NO_ROUTE_TO_HOST:
                    reason = &quot;No route to host&quot;;
                    break;
                case CONNECTION_TIMED_OUT:
                    reason = &quot;Connection timed out&quot;;
                    break;
                case PERMISSION_DENIED:
                    reason = &quot;Permission denied&quot;;
                    break;
                case INVALID_RESPONSE:
                    reason = &quot;Invalid response from server&quot;;
                    break;
                case TOO_MANY_REDIRECTS:
                    reason = &quot;Too many redirects&quot;;
                    break;
                case FILE_NOT_FOUND:
                    reason = &quot;File not found&quot;;
                    break;
            }
            return new Throwable(reason);
        }
    }


    private final class DocumentProperty
            extends ReadOnlyObjectPropertyBase&lt;Document&gt; {

        private boolean available;
        private Document document;

        private void invalidate(boolean available) {
            if (this.available || available) {
                this.available = available;
                this.document = null;
                fireValueChangedEvent();
            }
        }

        public Document get() {
            if (!this.available) {
                return null;
            }
            if (this.document == null) {
                this.document = page.getDocument(page.getMainFrame());
                if (this.document == null) {
                    this.available = false;
                }
            }
            return this.document;
        }

        public Object getBean() {
            return WebEngine.this;
        }

        public String getName() {
            return &quot;document&quot;;
        }
    }


    /*
     * Returns the debugger associated with this web engine.
     * The debugger is an object that can be used to debug
     * the web page currently loaded into the web engine.
     * &lt;p&gt;
     * All methods of the debugger must be called on
     * the JavaFX Application Thread.
     * The message callback object registered with the debugger
     * is always called on the JavaFX Application Thread.
     * @return the debugger associated with this web engine.
     *         The return value cannot be {@code null}.
     */
    Debugger getDebugger() {
        return debugger;
    }

    /**
     * The debugger implementation.
     */
    private final class DebuggerImpl implements Debugger {

        private boolean enabled;
        private Callback&lt;String,Void&gt; messageCallback;


        @Override
        public boolean isEnabled() {
            checkThread();
            return enabled;
        }

        @Override
        public void setEnabled(boolean enabled) {
            checkThread();
            if (enabled != this.enabled) {
                if (enabled) {
                    page.setDeveloperExtrasEnabled(true);
                    page.connectInspectorFrontend();
                } else {
                    page.disconnectInspectorFrontend();
                    page.setDeveloperExtrasEnabled(false);
                }
                this.enabled = enabled;
            }
        }

        @Override
        public void sendMessage(String message) {
            checkThread();
            if (!enabled) {
                throw new IllegalStateException(&quot;Debugger is not enabled&quot;);
            }
            if (message == null) {
                throw new NullPointerException(&quot;message is null&quot;);
            }
            page.dispatchInspectorMessageFromFrontend(message);
        }

        @Override
        public Callback&lt;String,Void&gt; getMessageCallback() {
            checkThread();
            return messageCallback;
        }

        @Override
        public void setMessageCallback(Callback&lt;String,Void&gt; callback) {
            checkThread();
            messageCallback = callback;
        }
    }

    /**
     * The inspector client implementation. This object references the owner
     * WebEngine weakly so as to avoid referencing WebEngine from WebPage
     * strongly.
     */
    private static final class InspectorClientImpl implements InspectorClient {

        private final WeakReference&lt;WebEngine&gt; engine;


        private InspectorClientImpl(WebEngine engine) {
            this.engine = new WeakReference&lt;WebEngine&gt;(engine);
        }


        @Override
        public boolean sendMessageToFrontend(final String message) {
            boolean result = false;
            WebEngine webEngine = engine.get();
            if (webEngine != null) {
                final Callback&lt;String,Void&gt; messageCallback =
                        webEngine.debugger.messageCallback;
                if (messageCallback != null) {
                    AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                        messageCallback.call(message);
                        return null;
                    }, webEngine.page.getAccessControlContext());
                    result = true;
                }
            }
            return result;
        }
    }

    private static final boolean printStatusOK(PrinterJob job) {
        switch (job.getJobStatus()) {
            case NOT_STARTED:
            case PRINTING:
                return true;
            default:
                return false;
        }
    }

    /**
     * Prints the current Web page using the given printer job.
     * &lt;p&gt;This method does not modify the state of the job, nor does it call
     * {@link PrinterJob#endJob}, so the job may be safely reused afterwards.
     *
     * @param job printer job used for printing
     * @since JavaFX 8.0
     */
    public void print(PrinterJob job) {
        if (!printStatusOK(job)) {
            return;
        }

        PageLayout pl = job.getJobSettings().getPageLayout();
        float width = (float) pl.getPrintableWidth();
        float height = (float) pl.getPrintableHeight();
        int pageCount = page.beginPrinting(width, height);

        for (int i = 0; i &lt; pageCount; i++) {
            if (printStatusOK(job)) {
                Node printable = new Printable(page, i, width);
                job.printPage(printable);
            }
        }
        page.endPrinting();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/View/GameView.java</CENTER></H3><HR>
<PRE>
/*
  RMIT University Vietnam
  Course: INTE2512 Object-Oriented Programming
  Semester: 2019C
  Assessment: Assignment 2
  Author: Hoang Quoc Dai
  ID: s3426353
  Created  date: 15/12/2019
  Last modified: 16/12/2019
  Acknowledgement: If you use any resources, acknowledge here. Failure to do so will be considered as plagiarism.
*/
package sample.View;

import javafx.geometry.Pos;
import javafx.scene.image.Image;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontPosture;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import java.util.ArrayList;
import java.util.Random;
import java.util.Timer;
import java.util.TimerTask;

public class GameView extends VBox{
    int[] cardIndices = { 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10};
    ArrayList &lt;Card&gt; cards = new ArrayList&lt;&gt;();
    private GridPane matrixCards;
    private TimeBar timeBar;
    private Image image;
    private Text timeDisplay;
    private Timer timer;
    private int min = 1;
    private int sec = 59;
    private int milliSec = 99;
    private int totalFront;

    public GameView() {
        setSpacing(20);
        setAlignment(Pos.CENTER_RIGHT);

        matrixCards = new GridPane();
        String prefix = &quot;Images/&quot;;
        String postfix = &quot;.jpg&quot;;
        shuffleCards();
        for (int col = 1; col &lt;= 5; col++) {
            for (int row = 1; row &lt;= 4; row++) {
                String cardID = Integer.toString(cardIndices[row - 1 + 4*(col-1)]);
                Card temp = new Card(prefix + cardID + postfix);
                matrixCards.add(temp, col, row);
                cards.add(temp);
            }
        }
        setTimeBar(new TimeBar());
        getChildren().addAll(matrixCards, getTimeBar());

        //Set timeDisplay
        setTimeDisplay(new Text(&quot;Time: 00:00:00&quot;));
        getTimeDisplay().setFill(Color.YELLOW);
        getTimeDisplay().setFont(Font.font(&quot;Courier&quot;, FontWeight.BOLD, FontPosture.REGULAR, 15));
        getChildren().add(getTimeDisplay());
        timerProcess(); //Set timer
    }

    //For Card
    public void shuffleCards() {
        Random rand = new Random();
        for (int i = 0; i &lt; cardIndices.length; i++) {
            int randomIndexToSwap = rand.nextInt(cardIndices.length);
            int temp = cardIndices[randomIndexToSwap];
            cardIndices[randomIndexToSwap] = cardIndices[i];
            cardIndices[i] = temp;
        }
    }
    //For timer
    private void timerProcess() {

        setTotalFront(0);
        int delay = 40;
        int period = 40;
        setTimer(new Timer());
        getTimer().scheduleAtFixedRate(new TimerTask() {
            public void run() {
                getTimeDisplay().setText(&quot;Time: &quot;+ showCountDown());
            }
        }, delay, period);
    }

    //For timer
    private String showCountDown() {
        setMilliSec(getMilliSec() -4);
        if (getMilliSec() &lt; 0){
            setMilliSec(99);
            setSec(getSec() - 1);
        }
        if (getSec() == 0){
            setSec(59);
            setMin(getMin() - 1);
        }
        if (getMin() &lt; 0) {
            getTimer().cancel();
            return &quot;00:00:00&quot;;
        };
        if (getTotalFront() == 20){
            getTimer().cancel();
        }
        return &quot;0&quot;+Integer.toString(getMin())+&quot;:&quot;+Integer.toString(getSec()/10)+Integer.toString(getSec()%10)+&quot;:&quot;+Integer.toString(getMilliSec());
    }

    private TimeBar getTimeBar() {
        return timeBar;
    }

    private void setTimeBar(TimeBar timeBar) {
        this.timeBar = timeBar;
    }

    private Image getImage() {
        return image;
    }

    private void setImage(Image image) {
<A NAME="26"></A>        this.image = image;
    }

    public ArrayList&lt;Card&gt; getCards() <FONT color="#95b9c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#26',2,'match37-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        return cards;
    }

    private Text getTimeDisplay() {
        return timeDisplay;
    }

    private void setTimeDisplay(Text timeDisplay) {
        this.timeDisplay = timeDisplay;
    }

    private Timer getTimer() {</B></FONT>
        return timer;
    }

    private void setTimer(Timer timer) {
        this.timer = timer;
    }

    private int getMin() {
        return min;
    }

    private void setMin(int min) {
        this.min = min;
    }

    private int getSec() {
        return sec;
    }

    private void setSec(int sec) {
        this.sec = sec;
    }

    private int getMilliSec() {
        return milliSec;
    }

    private void setMilliSec(int milliSec) {
        this.milliSec = milliSec;
    }

    private int getTotalFront() {
        return totalFront;
    }

    private void setTotalFront(int totalFront) {
        this.totalFront = totalFront;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/View/StartView.java</CENTER></H3><HR>
<PRE>
/*
  RMIT University Vietnam
  Course: INTE2512 Object-Oriented Programming
  Semester: 2019C
  Assessment: Assignment 2
  Author: Hoang Quoc Dai
  ID: s3426353
  Created  date: 15/12/2019
  Last modified: 16/12/2019
  Acknowledgement: If you use any resources, acknowledge here. Failure to do so will be considered as plagiarism.
*/
package sample.View;

import javafx.geometry.Pos;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;


public class StartView extends VBox {
    private Button btLevel1;
    private Button btLevel2;
    private Button btLevel3;
    private Button btSoundPlay;
    private Button btSoundPause;
    private Label message;
    private Label message1;

    public StartView() {
        // Create a vBox
        HBox hBox = new HBox();
        hBox.setSpacing(10);
        hBox.setAlignment(Pos.CENTER);
        // Set name for buttons and message label
        setBtLevel1(new Button(&quot;Level 1&quot;));
        setBtLevel2(new Button(&quot;Level 2&quot;));
        setBtLevel3(new Button(&quot;Level 3&quot;));
        setBtSoundPlay(new Button(&quot;Music On&quot;));
        setBtSoundPause(new Button(&quot;Music Pause&quot;));
        setMessage(new Label(&quot;Hello, QUOC DAI ! &quot;));
        setMessage1(new Label(&quot;PLEASE CHOOSE THE LEVEL TO START !&quot;));
        //Set Front, Size, Color for Message
        getMessage().setFont(new Font(&quot;Arial&quot;, 40));
        getMessage().setTextFill(Color.WHITE);
        //Set Front, Size, Color for Message1
        getMessage1().setFont(new Font(&quot;Arial&quot;, 40));
        getMessage1().setTextFill(Color.WHITE);
        // add 4 buttons to hBox
        hBox.getChildren().addAll(getBtLevel1(), getBtLevel2(), getBtLevel3(), getBtSoundPlay(), getBtSoundPause());

        setAlignment(Pos.CENTER);
        setSpacing(10);
<A NAME="12"></A>
        // add hBox and label to vBox
        getChildren().addAll(getMessage(), getMessage1(),hBox);
    <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match37-0.html#12',2,'match37-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    public Button getBtLevel1() {
        return btLevel1;
    }

    public Button getBtLevel2() {</B></FONT>
        return btLevel2;
    }

    public Button getBtLevel3() {
        return btLevel3;
    }

    private void setBtLevel1(Button btLevel1) {
        this.btLevel1 = btLevel1;
    }

    private void setBtLevel2(Button btLevel2) {
        this.btLevel2 = btLevel2;
    }

    private void setBtLevel3(Button btLevel3) {
        this.btLevel3 = btLevel3;
    }

    private Label getMessage() {
        return message;
    }

    private void setMessage(Label message) {
        this.message = message;
    }

    private Label getMessage1() {
        return message1;
    }

    private void setMessage1(Label message1) {
        this.message1 = message1;
    }

    public Button getBtSoundPlay() {
        return btSoundPlay;
    }

    private void setBtSoundPlay(Button btSoundPlay) {
        this.btSoundPlay = btSoundPlay;
    }

    public Button getBtSoundPause() {
        return btSoundPause;
    }

    private void setBtSoundPause(Button btSoundPause) {
        this.btSoundPause = btSoundPause;
    }
}
</PRE>

</BODY>
</HTML>
