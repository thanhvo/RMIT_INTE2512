<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>daihoangquoc_</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.base/javafx/util/converter/LocalDateTimeStringConverter.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.util.converter;

import java.time.DateTimeException;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.LocalDateTime;
import java.time.chrono.Chronology;
import java.time.chrono.ChronoLocalDate;
import java.time.chrono.ChronoLocalDateTime;
import java.time.chrono.IsoChronology;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.format.DecimalStyle;
import java.time.format.FormatStyle;
import java.time.temporal.Temporal;
import java.time.temporal.TemporalAccessor;
import java.util.Locale;

import javafx.util.StringConverter;

import com.sun.javafx.binding.Logging;

/**
 * &lt;p&gt;{@link StringConverter} implementation for {@link LocalDateTime} values.&lt;/p&gt;
 *
 * @see LocalDateStringConverter
 * @see LocalTimeStringConverter
 * @since JavaFX 8u40
 */
public class LocalDateTimeStringConverter extends StringConverter&lt;LocalDateTime&gt; {

    LdtConverter&lt;LocalDateTime&gt; ldtConverter;



   // ------------------------------------------------------------ Constructors

    /**
     * Create a {@link StringConverter} for {@link LocalDateTime} values, using a
     * default formatter and parser based on {@link IsoChronology},
     * {@link FormatStyle#SHORT} for both date and time, and the user's
     * {@link Locale}.
     *
     * &lt;p&gt;This converter ensures symmetry between the toString() and
     * fromString() methods. Many of the default locale based patterns used by
     * {@link DateTimeFormatter} will display only two digits for the year when
     * formatting to a string. This would cause a value like 1955 to be
     * displayed as 55, which in turn would be parsed back as 2055. This
     * converter modifies two-digit year patterns to always use four digits. The
     * input parsing is not affected, so two digit year values can still be
     * parsed as expected in these locales.&lt;/p&gt;
     */
    public LocalDateTimeStringConverter() {
        ldtConverter = new LdtConverter&lt;LocalDateTime&gt;(LocalDateTime.class, null, null,
                                                       null, null, null, null);
    }

    /**
     * Create a {@link StringConverter} for {@link LocalDateTime} values, using
     * a default formatter and parser based on {@link IsoChronology}, the
     * specified {@link FormatStyle} values for date and time, and the user's
     * {@link Locale}.
     *
     * @param dateStyle The {@link FormatStyle} that will be used by the default
     * formatter and parser for the date. If null then {@link FormatStyle#SHORT}
     * will be used.
     * @param timeStyle The {@link FormatStyle} that will be used by the default
     * formatter and parser for the time. If null then {@link FormatStyle#SHORT}
     * will be used.
     */
    public LocalDateTimeStringConverter(FormatStyle dateStyle, FormatStyle timeStyle) {
        ldtConverter = new LdtConverter&lt;LocalDateTime&gt;(LocalDateTime.class, null, null,
                                                       dateStyle, timeStyle, null, null);
    }

    /**
     * Create a {@link StringConverter} for {@link LocalDateTime} values using
     * the supplied formatter and parser.
     *
     * &lt;p&gt;For example, to use a fixed pattern for converting both ways:&lt;/p&gt;
     * &lt;blockquote&gt;&lt;pre&gt;
     * String pattern = &quot;yyyy-MM-dd HH:mm&quot;;
     * DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
     * StringConverter&amp;lt;LocalDateTime&amp;gt; converter =
     *     DateTimeStringConverter.getLocalDateTimeConverter(formatter, null);
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * Note that the formatter and parser can be created to handle non-default
     * {@link Locale} and {@link Chronology} as needed.
     *
     * @param formatter An instance of {@link DateTimeFormatter} which will be
     * used for formatting by the toString() method. If null then a default
     * formatter will be used.
     * @param parser An instance of {@link DateTimeFormatter} which will be used
     * for parsing by the fromString() method. This can be identical to
     * formatter. If null then formatter will be used, and if that is also null,
     * then a default parser will be used.
     */
    public LocalDateTimeStringConverter(DateTimeFormatter formatter, DateTimeFormatter parser) {
        ldtConverter = new LdtConverter&lt;LocalDateTime&gt;(LocalDateTime.class, formatter, parser,
                                                       null, null, null, null);
    }

    /**
     * Create a {@link StringConverter} for {@link LocalDateTime} values using a
     * default formatter and parser, which will be based on the supplied
     * {@link FormatStyle}s, {@link Locale}, and {@link Chronology}.
     *
     * @param dateStyle The {@link FormatStyle} that will be used by the default
     * formatter and parser for the date. If null then {@link FormatStyle#SHORT}
     * will be used.
     * @param timeStyle The {@link FormatStyle} that will be used by the default
     * formatter and parser for the time. If null then {@link FormatStyle#SHORT}
     * will be used.
     * @param locale The {@link Locale} that will be used by the
     * default formatter and parser. If null then
     * {@code Locale.getDefault(Locale.Category.FORMAT)} will be used.
     * @param chronology The {@link Chronology} that will be used by the default
     * formatter and parser. If null then {@link IsoChronology#INSTANCE} will be
     * used.
     */
    public LocalDateTimeStringConverter(FormatStyle dateStyle, FormatStyle timeStyle,
                                        Locale locale, Chronology chronology) {
        ldtConverter = new LdtConverter&lt;LocalDateTime&gt;(LocalDateTime.class, null, null,
                                                       dateStyle, timeStyle, locale, chronology);
    }



    // ------------------------------------------------------- Converter Methods

    /** {@inheritDoc} */
    @Override public LocalDateTime fromString(String value) {
        return ldtConverter.fromString(value);
    }

    /** {@inheritDoc} */
    @Override public String toString(LocalDateTime value) {
        return ldtConverter.toString(value);
    }



    static class LdtConverter&lt;T extends Temporal&gt; extends StringConverter&lt;T&gt; {
        private Class&lt;T&gt; type;
        Locale locale;
        Chronology chronology;
        DateTimeFormatter formatter;
        DateTimeFormatter parser;
        FormatStyle dateStyle;
        FormatStyle timeStyle;

        LdtConverter(Class&lt;T&gt; type, DateTimeFormatter formatter, DateTimeFormatter parser,
                     FormatStyle dateStyle, FormatStyle timeStyle, Locale locale, Chronology chronology) {
            this.type = type;
            this.formatter = formatter;
            this.parser = (parser != null) ? parser : formatter;
            this.locale = (locale != null) ? locale : Locale.getDefault(Locale.Category.FORMAT);
            this.chronology = (chronology != null) ? chronology : IsoChronology.INSTANCE;

            if (type == LocalDate.class || type == LocalDateTime.class) {
                this.dateStyle = (dateStyle != null) ? dateStyle : FormatStyle.SHORT;
            }

            if (type == LocalTime.class || type == LocalDateTime.class) {
                this.timeStyle = (timeStyle != null) ? timeStyle : FormatStyle.SHORT;
            }
        }

        /** {@inheritDoc} */
        @SuppressWarnings({&quot;unchecked&quot;})
        @Override public T fromString(String text) {
            if (text == null || text.isEmpty()) {
                return null;
            }

            text = text.trim();

            if (parser == null) {
                parser = getDefaultParser();
            }

            TemporalAccessor temporal = parser.parse(text);

            if (type == LocalDate.class) {
                return (T)LocalDate.from(chronology.date(temporal));
            } else if (type == LocalTime.class) {
                return (T)LocalTime.from(temporal);
            } else {
                return (T)LocalDateTime.from(chronology.localDateTime(temporal));
            }
        }


        /** {@inheritDoc} */
        @Override public String toString(T value) {
            // If the specified value is null, return a zero-length String
            if (value == null) {
                return &quot;&quot;;
            }

            if (formatter == null) {
                formatter = getDefaultFormatter();
            }

            if (value instanceof LocalDate) {
                ChronoLocalDate cDate;
                try {
                    cDate = chronology.date(value);
                } catch (DateTimeException ex) {
                    Logging.getLogger().warning(&quot;Converting LocalDate &quot; + value + &quot; to &quot; + chronology + &quot; failed, falling back to IsoChronology.&quot;, ex);
                    chronology = IsoChronology.INSTANCE;
                    cDate = (LocalDate)value;
                }
                return formatter.format(cDate);
            } else if (value instanceof LocalDateTime) {
                ChronoLocalDateTime&lt;? extends ChronoLocalDate&gt; cDateTime;
                try {
                    cDateTime = chronology.localDateTime(value);
                } catch (DateTimeException ex) {
                    Logging.getLogger().warning(&quot;Converting LocalDateTime &quot; + value + &quot; to &quot; + chronology + &quot; failed, falling back to IsoChronology.&quot;, ex);
                    chronology = IsoChronology.INSTANCE;
                    cDateTime = (LocalDateTime)value;
                }
                return formatter.format(cDateTime);
            } else {
                return formatter.format(value);
            }
        }


        private DateTimeFormatter getDefaultParser() {
<A NAME="17"></A>            String pattern =
                DateTimeFormatterBuilder.getLocalizedDateTimePattern(dateStyle, timeStyle,
                                                                     chronology, locale);
            return <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#17',2,'match46-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new DateTimeFormatterBuilder().parseLenient()
                                                 .appendPattern(pattern)
                                                 .toFormatter()
                                                 .withChronology(chronology)
                                                 .withDecimalStyle(DecimalStyle.of(locale));
        }

        /**
         * &lt;p&gt;Return a default &lt;code&gt;DateTimeFormatter&lt;/code&gt; instance to use for formatting
         * and parsing in this {@link StringConverter}.&lt;/p&gt;
         */
        private DateTimeFormatter getDefaultFormatter() {
            DateTimeFormatter formatter</B></FONT>;

            if (dateStyle != null &amp;&amp; timeStyle != null) {
                formatter = DateTimeFormatter.ofLocalizedDateTime(dateStyle, timeStyle);
            } else if (dateStyle != null) {
                formatter = DateTimeFormatter.ofLocalizedDate(dateStyle);
            } else {
                formatter = DateTimeFormatter.ofLocalizedTime(timeStyle);
            }

            formatter = formatter.withLocale(locale)
                                 .withChronology(chronology)
                                 .withDecimalStyle(DecimalStyle.of(locale));

            if (dateStyle != null) {
                formatter = fixFourDigitYear(formatter, dateStyle, timeStyle,
                                             chronology, locale);
            }

            return formatter;
        }

        private DateTimeFormatter fixFourDigitYear(DateTimeFormatter formatter,
                                                   FormatStyle dateStyle, FormatStyle timeStyle,
                                                   Chronology chronology, Locale locale) {
            String pattern =
                DateTimeFormatterBuilder.getLocalizedDateTimePattern(dateStyle, timeStyle,
                                                                     chronology, locale);
            if (pattern.contains(&quot;yy&quot;) &amp;&amp; !pattern.contains(&quot;yyy&quot;)) {
                // Modify pattern to show four-digit year, including leading zeros.
                String newPattern = pattern.replace(&quot;yy&quot;, &quot;yyyy&quot;);
                formatter = DateTimeFormatter.ofPattern(newPattern)
                                             .withDecimalStyle(DecimalStyle.of(locale));
            }

            return formatter;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/ContextMenuContent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.control.behavior.TwoLevelFocusPopupBehavior;
import com.sun.javafx.scene.control.skin.Utils;
import com.sun.javafx.scene.traversal.Direction;
import javafx.animation.Animation.Status;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.beans.InvalidationListener;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.*;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.*;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.shape.Rectangle;
import javafx.stage.Window;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

/**
 * This is a the SkinBase for ContextMenu based controls so that the CSS parts
 * work right, because otherwise we would have to copy the Keys from there to here.
 */
public class ContextMenuContent extends Region {

    private static final String ITEM_STYLE_CLASS_LISTENER = &quot;itemStyleClassListener&quot;;

    private ContextMenu contextMenu;

    /***************************************************************************
     * UI subcomponents
     **************************************************************************/

    private double maxGraphicWidth = 0; // we keep this margin to left for graphic
    private double maxRightWidth = 0;
    private double maxLabelWidth = 0;
    private double maxRowHeight = 0;
    private double maxLeftWidth = 0;
    private double oldWidth = 0;

    private Rectangle clipRect;
    MenuBox itemsContainer;
    private ArrowMenuItem upArrow;
    private ArrowMenuItem downArrow;

    /*
     * We maintain a current focused index which is used
     * in keyboard navigation of menu items.
     */
    private int currentFocusedIndex = -1;

    private boolean itemsDirty = true;
    private InvalidationListener popupShowingListener = arg0 -&gt; {
        updateItems();
    };
    private WeakInvalidationListener weakPopupShowingListener =
            new WeakInvalidationListener(popupShowingListener);


    /***************************************************************************
     * Constructors
     **************************************************************************/
    public ContextMenuContent(final ContextMenu popupMenu) {
        this.contextMenu = popupMenu;
        clipRect = new Rectangle();
         clipRect.setSmooth(false);
        itemsContainer = new MenuBox();
//        itemsContainer = new VBox();
        itemsContainer.setClip(clipRect);

        upArrow = new ArrowMenuItem(this);
        upArrow.setUp(true);
        upArrow.setFocusTraversable(false);

        downArrow = new ArrowMenuItem(this);
        downArrow.setUp(false);
        downArrow.setFocusTraversable(false);
        getChildren().add(itemsContainer);
        getChildren().add(upArrow);
        getChildren().add(downArrow);
        initialize();
        setUpBinds();
        updateItems();
        // RT-20197 add menuitems only on first show.
        popupMenu.showingProperty().addListener(weakPopupShowingListener);

        /*
        ** only add this if we're on an embedded
        ** platform that supports 5-button navigation
        */
        if (Utils.isTwoLevelFocus()) {
            new TwoLevelFocusPopupBehavior(this);
        }
    }

    //For access from controls
    public VBox getItemsContainer() {
        return itemsContainer;
    }
    //For testing purpose only
    int getCurrentFocusIndex() {
        return currentFocusedIndex;
    }
    //For testing purpose only
    void setCurrentFocusedIndex(int index) {
        if (index &lt; itemsContainer.getChildren().size()) {
            currentFocusedIndex = index;
        }
    }

    private void updateItems() {
        if (itemsDirty) {
            updateVisualItems();
            itemsDirty = false;
        }
    }

    private void computeVisualMetrics() {
        maxRightWidth = 0;
        maxLabelWidth = 0;
        maxRowHeight = 0;
        maxGraphicWidth = 0;
        maxLeftWidth = 0;

        for (int i = 0; i &lt; itemsContainer.getChildren().size(); i++) {
            Node child = itemsContainer.getChildren().get(i);
            if (child instanceof MenuItemContainer) {
                final MenuItemContainer menuItemContainer = (MenuItemContainer)itemsContainer.getChildren().get(i);

                if (! menuItemContainer.isVisible()) continue;

                double alt = -1;
                Node n = menuItemContainer.left;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxLeftWidth = Math.max(maxLeftWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }

                n = menuItemContainer.graphic;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxGraphicWidth = Math.max(maxGraphicWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }

                n = menuItemContainer.label;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) {
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxLabelWidth = Math.max(maxLabelWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }

                n = menuItemContainer.right;
                if (n != null) {
                    if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
                        alt = snapSizeY(n.prefHeight(-1));
                    } else alt = -1;
                    maxRightWidth = Math.max(maxRightWidth, snapSizeX(n.prefWidth(alt)));
                    maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
                }
            }
        }

        // Fix for RT-38838.
        // This fixes the issue where CSS is applied to a menu after it has been
        // showing, resulting in its bounds changing. In this case, we need to
        // shift the submenu such that it is properly aligned with its parent menu.
        //
        // To do this, we must firstly determine if the open submenu is shifted
        // horizontally to appear on the other side of this menu, as this is the
        // only situation where shifting has to happen. If so, we need to check
        // if we should shift the submenu due to changes in width.
        //
        // We need to get the parent menu of this contextMenu, so that we only
        // modify the X value in the following conditions:
        // 1) There exists a parent menu
        // 2) The parent menu is in the correct position (i.e. to the left of this
        //    menu in normal LTR systems).
        final double newWidth = maxRightWidth + maxLabelWidth + maxGraphicWidth + maxLeftWidth;
        Window ownerWindow = contextMenu.getOwnerWindow();
        if (ownerWindow instanceof ContextMenu) {
            if (contextMenu.getX() &lt; ownerWindow.getX()) {
                if (oldWidth != newWidth) {
                    contextMenu.setX(contextMenu.getX() + oldWidth - newWidth);
                }
            }
        }

        oldWidth = newWidth;
    }

    private void updateVisualItems() {
        ObservableList&lt;Node&gt; itemsContainerChilder = itemsContainer.getChildren();

        disposeVisualItems();

        for (int row = 0; row &lt; getItems().size(); row++) {
            final MenuItem item = getItems().get(row);
            if (item instanceof CustomMenuItem &amp;&amp; ((CustomMenuItem) item).getContent() == null) {
                continue;
            }

            if (item instanceof SeparatorMenuItem) {
                // we don't want the hover highlight for separators, so for
                // now this is the simplest approach - just remove the
                // background entirely. This may cause issues if people
                // intend to style the background differently.
                Node node = ((CustomMenuItem) item).getContent();
                node.visibleProperty().bind(item.visibleProperty());
                itemsContainerChilder.add(node);
                // Add the (separator) menu item to properties map of this node.
                // Special casing this for separator :
                // This allows associating this container with SeparatorMenuItem.
                node.getProperties().put(MenuItem.class, item);
            } else {
                MenuItemContainer menuItemContainer = new MenuItemContainer(item);
                menuItemContainer.visibleProperty().bind(item.visibleProperty());
                itemsContainerChilder.add(menuItemContainer);
            }
        }

        // Add the Menu to properties map of this skin. Used by QA for testing
        // This enables associating a parent menu for this skin showing menu items.
        if (getItems().size() &gt; 0) {
            final MenuItem item = getItems().get(0);
            getProperties().put(Menu.class, item.getParentMenu());
        }

        // RT-36513 made this applyCss(). Modified by RT-36995 to NodeHelper.reapplyCSS()
        NodeHelper.reapplyCSS(this);
    }

    private void disposeVisualItems() {
        // clean up itemsContainer
        ObservableList&lt;Node&gt; itemsContainerChilder = itemsContainer.getChildren();
        for (int i = 0, max = itemsContainerChilder.size(); i &lt; max; i++) {
            Node n = itemsContainerChilder.get(i);

            if (n instanceof MenuItemContainer) {
                MenuItemContainer container = (MenuItemContainer) n;
                container.visibleProperty().unbind();
                container.dispose();
            }
        }
        itemsContainerChilder.clear();
    }

    /**
     * Can be called by Skins when they need to clean up the content of any
     * ContextMenu instances they might have created. This ensures that contents
     * of submenus if any, also get cleaned up.
     */
    public void dispose() {
        disposeBinds();
        disposeVisualItems();

        disposeContextMenu(submenu);
        submenu = null;
        openSubmenu = null;
        selectedBackground = null;
        if (contextMenu != null) {
            contextMenu.getItems().clear();
            contextMenu = null;
        }
    }

    public void disposeContextMenu(ContextMenu menu) {
        if (menu == null) return;

        Skin&lt;?&gt; skin = menu.getSkin();
        if (skin == null) return;

        ContextMenuContent cmContent = (ContextMenuContent)skin.getNode();
        if (cmContent == null) return;

        cmContent.dispose(); // recursive call to dispose submenus.
    }

    @Override protected void layoutChildren() {
        if (itemsContainer.getChildren().size() == 0) return;
        final double x = snappedLeftInset();
        final double y = snappedTopInset();
        final double w = getWidth() - x - snappedRightInset();
        final double h = getHeight() - y - snappedBottomInset();
        final double contentHeight =  snapSizeY(getContentHeight()); // itemsContainer.prefHeight(-1);

        itemsContainer.resize(w,contentHeight);
        itemsContainer.relocate(x, y);

        if (isFirstShow &amp;&amp; ty == 0) {
            upArrow.setVisible(false);
            isFirstShow = false;
        } else {
            upArrow.setVisible(ty &lt; y &amp;&amp; ty &lt; 0);
        }
        downArrow.setVisible(ty + contentHeight &gt; (y + h));

        clipRect.setX(0);
        clipRect.setY(0);
        clipRect.setWidth(w);
        clipRect.setHeight(h);

        if (upArrow.isVisible()) {
            final double prefHeight = snapSizeY(upArrow.prefHeight(-1));
            clipRect.setHeight(snapSizeY(clipRect.getHeight() - prefHeight));
            clipRect.setY(snapSizeY(clipRect.getY()) + prefHeight);
            upArrow.resize(snapSizeX(upArrow.prefWidth(-1)), prefHeight);
            positionInArea(upArrow, x, y, w, prefHeight, /*baseline ignored*/0,
                    HPos.CENTER, VPos.CENTER);
        }

        if (downArrow.isVisible()) {
            final double prefHeight = snapSizeY(downArrow.prefHeight(-1));
            clipRect.setHeight(snapSizeY(clipRect.getHeight()) - prefHeight);
            downArrow.resize(snapSizeX(downArrow.prefWidth(-1)), prefHeight);
            positionInArea(downArrow, x, (y + h - prefHeight), w, prefHeight, /*baseline ignored*/0,
                    HPos.CENTER, VPos.CENTER);
        }
    }

     @Override protected double computePrefWidth(double height) {
         computeVisualMetrics();
         double prefWidth = 0;
         if (itemsContainer.getChildren().size() == 0) return 0;
         for (Node n : itemsContainer.getChildren()) {
             if (! n.isVisible()) continue;
             prefWidth = Math.max(prefWidth, snapSizeX(n.prefWidth(-1)));
         }
         return snappedLeftInset() + snapSizeX(prefWidth) + snappedRightInset();
    }

    @Override protected double computePrefHeight(double width) {
        if (itemsContainer.getChildren().size() == 0) return 0;
        final double screenHeight = getScreenHeight();
        final double contentHeight = getContentHeight(); // itemsContainer.prefHeight(width);
        double totalHeight = snappedTopInset() + snapSizeY(contentHeight) + snappedBottomInset();
        // the pref height of this menu is the smaller value of the
        // actual pref height and the height of the screens _visual_ bounds.
        double prefHeight = (screenHeight &lt;= 0) ? (totalHeight) : (Math.min(totalHeight, screenHeight));
        return prefHeight;
    }

    @Override protected double computeMinHeight(double width) {
        return 0.0;
    }

    @Override protected double computeMaxHeight(double height) {
        return getScreenHeight();
    }

    private double getScreenHeight() {
        if (contextMenu == null || contextMenu.getOwnerWindow() == null ||
                contextMenu.getOwnerWindow().getScene() == null) {
            return -1;
        }
        return snapSizeY(com.sun.javafx.util.Utils.getScreen(
            contextMenu.getOwnerWindow().getScene().getRoot()).getVisualBounds().getHeight());

    }

    private double getContentHeight() {
        double h = 0.0d;
        for (Node i : itemsContainer.getChildren()) {
            if (i.isVisible()) {
               h += snapSizeY(i.prefHeight(-1));
            }
        }
        return h;
    }

    // This handles shifting ty when doing keyboard navigation.
    private void ensureFocusedMenuItemIsVisible(Node node) {
        if (node == null) return;

        final Bounds nodeBounds = node.getBoundsInParent();
        final Bounds clipBounds = clipRect.getBoundsInParent();

        if (nodeBounds.getMaxY() &gt;= clipBounds.getMaxY()) {
            // this is for moving down the menu
            scroll(-nodeBounds.getMaxY() + clipBounds.getMaxY());
        } else if (nodeBounds.getMinY() &lt;= clipBounds.getMinY()) {
            // this is for moving up the menu
            scroll(-nodeBounds.getMinY() + clipBounds.getMinY());
        }
    }

    protected ObservableList&lt;MenuItem&gt; getItems() {
        return contextMenu.getItems();
    }

    /**
     * Finds the index of currently focused item.
     */
    private int findFocusedIndex() {
         for (int i = 0; i &lt; itemsContainer.getChildren().size(); i++) {
            Node n = itemsContainer.getChildren().get(i);
            if (n.isFocused()) {
                return i;
            }
        }
        return -1;
    }

    private boolean isFirstShow = true;
    private double ty;

    private void initialize() {
        // RT-19624 calling requestFocus inside layout was casuing repeated layouts.
        contextMenu.addEventHandler(Menu.ON_SHOWN, event -&gt; {
            currentFocusedIndex = -1;
            for (Node child : itemsContainer.getChildren()) {
                if (child instanceof MenuItemContainer) {
                    final MenuItem item = ((MenuItemContainer)child).item;
                    // When the choiceBox popup is shown, if this menu item is selected
                    // do a requestFocus so CSS kicks in and the item is highlighted.
                    if (&quot;choice-box-menu-item&quot;.equals(item.getId())) {
                        if (((RadioMenuItem)item).isSelected()) {
                            child.requestFocus();
                            break;
                        }
                    }
                }

            }
        });

//        // FIXME For some reason getSkinnable()Behavior traversal functions don't
//        // get called as expected, so I've just put the important code below.
        // We use setOnKeyPressed here as we are not adding a listener to a public
        // event type (ContextMenuContent is not public API), and without this
        // we get the issue shown in RT-34429
        setOnKeyPressed(new EventHandler&lt;KeyEvent&gt;() {
            @Override public void handle(KeyEvent ke) {
                switch (ke.getCode()) {
                    case LEFT:
                        if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
                            processRightKey(ke);
                        } else {
                            processLeftKey(ke);
                        }
                        break;
                    case RIGHT:
                        if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
                            processLeftKey(ke);
                        } else {
                            processRightKey(ke);
                        }
                        break;
                    case CANCEL:
                        ke.consume();
                        break;
                    case ESCAPE:
                        // if the owner is not a menubar button, just close the
                        // menu - this will move focus up to the parent menu
                        // as required. In the case of the parent being a
                        // menubar button we special case in the conditional code
                        // beneath this switch statement. See RT-34429 for more context.
                        final Node ownerNode = contextMenu.getOwnerNode();
                        if (! (ownerNode instanceof MenuBarButton)) {
                            contextMenu.hide();
                            ke.consume();
                        }
                        break;
                    case DOWN:
                        // move to the next sibling
                        move(Direction.NEXT);
                        ke.consume();
                        break;
                    case UP:
                        // move to previous sibling
                        move(Direction.PREVIOUS);
                        ke.consume();
                        break;
                    case SPACE:
                    case ENTER:
                        // select the menuitem
                        selectMenuItem();
                        ke.consume();
                        break;
                    default:
                        break;
                }

                if (!ke.isConsumed()) {
                    final Node ownerNode = contextMenu.getOwnerNode();
                    if (ownerNode instanceof MenuItemContainer) {
                        // Forward to parent menu
                        Parent parent = ownerNode.getParent();
                        while (parent != null &amp;&amp; !(parent instanceof ContextMenuContent)) {
                            parent = parent.getParent();
                        }
                        if (parent instanceof ContextMenuContent) {
                            parent.getOnKeyPressed().handle(ke);
                        }
                    } else if (ownerNode instanceof MenuBarButton) {
                        // the following code no longer appears necessary, but
                        // leaving in intact for now...
//                        // This is a top-level MenuBar Menu, so forward event to MenuBar
//                        MenuBarSkin mbs = ((MenuBarButton)ownerNode).getMenuBarSkin();
//                        if (mbs != null &amp;&amp; mbs.getKeyEventHandler() != null) {
//                            mbs.getKeyEventHandler().handle(ke);
//                        }
                    }
                }
            }
        });

        addEventHandler(ScrollEvent.SCROLL, event -&gt; {
            /*
             * we'll only scroll if the arrows are visible in the direction
             * that we're going, otherwise we go into empty space.
             */
            final double textDeltaY = event.getTextDeltaY();
            final double deltaY = event.getDeltaY();
            if ((downArrow.isVisible() &amp;&amp; (textDeltaY &lt; 0.0 || deltaY &lt; 0.0)) ||
                (upArrow.isVisible() &amp;&amp; (textDeltaY &gt; 0.0 || deltaY &gt; 0.0))) {

                switch(event.getTextDeltaYUnits()) {
                  case LINES:
                      /*
                      ** scroll lines, use the row height of selected row,
                      ** or row 0 if none selected
                      */
                      int focusedIndex = findFocusedIndex();
                      if (focusedIndex == -1) {
                          focusedIndex = 0;
                      }
                      double rowHeight = itemsContainer.getChildren().get(focusedIndex).prefHeight(-1);
                      scroll(textDeltaY * rowHeight);
                      break;
                  case PAGES:
                      /*
                      ** page scroll, scroll the menu height
                      */
                      scroll(textDeltaY * itemsContainer.getHeight());
                      break;
                  case NONE:
                      /*
                      ** pixel scroll
                      */
                      scroll(deltaY);
                      break;
                }
                event.consume();
            }
        });
    }

    private Optional&lt;Node&gt; getFocusedNode() {
        final List&lt;Node&gt; children = itemsContainer.getChildren();
        final boolean validIndex = currentFocusedIndex &gt;= 0 &amp;&amp; currentFocusedIndex &lt; children.size();
        return validIndex ? Optional.of(children.get(currentFocusedIndex)) : Optional.empty();
    }

    private void processLeftKey(KeyEvent ke) {
        getFocusedNode().ifPresent(n -&gt; {
            if (n instanceof MenuItemContainer) {
                MenuItem item = ((MenuItemContainer)n).item;
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;

                    // if the submenu for this menu is showing, hide it
                    if (menu == openSubmenu &amp;&amp; submenu != null &amp;&amp; submenu.isShowing()) {
                        hideSubmenu();
                        ke.consume();
                    }
                }
            }
        });
    }

    private void processRightKey(KeyEvent ke) {
        getFocusedNode().ifPresent(n -&gt; {
            if (n instanceof MenuItemContainer) {
                MenuItem item = ((MenuItemContainer)n).item;
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;
                    if (menu.isDisable()) return;
                    selectedBackground = ((MenuItemContainer)n);

                    // RT-15103
                    // if submenu for this menu is already showing then do nothing
                    // Menubar will process the right key and move to the next menu
                    if (openSubmenu == menu &amp;&amp; submenu != null &amp;&amp; submenu.isShowing()) {
                        return;
                    }

                    showMenu(menu);
                    ke.consume();
                }
            }
        });
    }

    private void showMenu(Menu menu) {
        menu.show();
        // request focus on the first item of the submenu after it is shown
        ContextMenuContent cmContent = (ContextMenuContent)submenu.getSkin().getNode();
        if (cmContent != null) {
           if (cmContent.itemsContainer.getChildren().size() &gt; 0) {
               cmContent.itemsContainer.getChildren().get(0).requestFocus();
               cmContent.currentFocusedIndex = 0;
           } else {
               cmContent.requestFocus();
           }
        }
    }

    private void selectMenuItem() {
        getFocusedNode().ifPresent(n -&gt; {
            if (n instanceof MenuItemContainer) {
                MenuItem item = ((MenuItemContainer)n).item;
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;
                    if (openSubmenu != null) {
                        hideSubmenu();
                    }
                    if (menu.isDisable()) return;
                    selectedBackground = ((MenuItemContainer)n);
                    menu.show();
                } else {
                    ((MenuItemContainer)n).doSelect();
                }
            }
        });
    }

    private void move(Direction dir) {
        int startIndex = currentFocusedIndex != -1 ? currentFocusedIndex : itemsContainer.getChildren().size();
        requestFocusOnIndex(findSibling(dir, startIndex));
    }

    private int findSibling(final Direction dir, final int startIndex) {
        final int childCount = itemsContainer.getChildren().size();
        int i = startIndex;
        do {
            if (dir.isForward() &amp;&amp; i &gt;= childCount - 1) {
                // loop to zero
                i = 0;
            } else if (!dir.isForward() &amp;&amp; i == 0) {
                // loop to end
                i = childCount - 1;
            } else {
                i += (dir.isForward() ? 1 : -1);
            }

            Node n = itemsContainer.getChildren().get(i);
            if (n instanceof MenuItemContainer &amp;&amp; n.isVisible()) {
                return i;
            }
        } while (i != startIndex);
        return -1;
    }

    public void requestFocusOnIndex(int index) {
        currentFocusedIndex = index;
        Node n = itemsContainer.getChildren().get(index);
        selectedBackground = ((MenuItemContainer)n);
        n.requestFocus();
        ensureFocusedMenuItemIsVisible(n);
    }

    /*
     * Get the Y offset from the top of the popup to the menu item whose index
     * is given.
     */
    public double getMenuYOffset(int menuIndex) {
        double offset = 0;
        if (itemsContainer.getChildren().size() &gt; menuIndex) {
            offset = snappedTopInset();
            Node menuitem = itemsContainer.getChildren().get(menuIndex);
            offset += menuitem.getLayoutY() + menuitem.prefHeight(-1);
        }
        return offset;
    }
<A NAME="34"></A>
    private void setUpBinds() {
        updateMenuShowingListeners(contextMenu.getItems(), true);
        <FONT color="#827d6b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#34',2,'match46-top.html#34',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>contextMenu.getItems().addListener(contextMenuItemsListener);
    }

    private void disposeBinds() {
        updateMenuShowingListeners(contextMenu.getItems(), false);
        contextMenu.getItems().removeListener(contextMenuItemsListener);
    }</B></FONT>

    private ChangeListener&lt;Boolean&gt; menuShowingListener = (observable, wasShowing, isShowing) -&gt; {
        ReadOnlyBooleanProperty isShowingProperty = (ReadOnlyBooleanProperty) observable;
        Menu menu = (Menu) isShowingProperty.getBean();

        if (wasShowing &amp;&amp; ! isShowing) {
            // hide the submenu popup
            hideSubmenu();
        } else if (! wasShowing &amp;&amp; isShowing) {
            // show the submenu popup
            showSubmenu(menu);
        }
    };

    private ListChangeListener&lt;MenuItem&gt; contextMenuItemsListener = (ListChangeListener&lt;MenuItem&gt;) c -&gt; {
        // Add listeners to the showing property of all menus that have
        // been added, and remove listeners from menus that have been removed
        // FIXME this is temporary - we should be adding and removing
        // listeners such that they use the one listener defined above
        // - but that can't be done until we have the bean in the
        // ObservableValue
        while (c.next()) {
            updateMenuShowingListeners(c.getRemoved(), false);
            updateMenuShowingListeners(c.getAddedSubList(), true);
        }

        // Listener to items in PopupMenu to update items in PopupMenuContent
        itemsDirty = true;
        updateItems(); // RT-29761
    };

    private ChangeListener&lt;Boolean&gt; menuItemVisibleListener = (observable, oldValue, newValue) -&gt; {
        // re layout as item's visibility changed
        requestLayout();
    };

    private void updateMenuShowingListeners(List&lt;? extends MenuItem&gt; items, boolean addListeners) {
        for (MenuItem item : items) {
            if (item instanceof Menu) {
                final Menu menu = (Menu) item;

                if (addListeners) {
                    menu.showingProperty().addListener(menuShowingListener);
                } else {
                    menu.showingProperty().removeListener(menuShowingListener);
                }
            }

             // listen to menu items's visible property.
            if (addListeners) {
                item.visibleProperty().addListener(menuItemVisibleListener);
            } else {
                item.visibleProperty().removeListener(menuItemVisibleListener);
            }
        }
    }

    // For test purpose only
    ContextMenu getSubMenu() {
        return submenu;
    }

    Menu getOpenSubMenu() {
        return openSubmenu;
    }

    private void createSubmenu() {
        if (submenu == null) {
            submenu = new ContextMenu();
            submenu.showingProperty().addListener(new ChangeListener&lt;Boolean&gt;() {
                @Override public void changed(ObservableValue&lt;? extends Boolean&gt; observable,
                                              Boolean oldValue, Boolean newValue) {
                    if (!submenu.isShowing()) {
                        // Maybe user clicked outside or typed ESCAPE.
                        // Make sure menus are in sync.
                        for (Node node : itemsContainer.getChildren()) {
                            if (node instanceof MenuItemContainer
                                  &amp;&amp; ((MenuItemContainer)node).item instanceof Menu) {
                                Menu menu = (Menu)((MenuItemContainer)node).item;
                                if (menu.isShowing()) {
                                    menu.hide();
                                }
                            }
                        }
                    }
                }
            });
        }
    }

    private void showSubmenu(Menu menu) {
        openSubmenu = menu;
        createSubmenu();
        submenu.getItems().setAll(menu.getItems());
        submenu.show(selectedBackground, Side.RIGHT, 0, 0);
    }

    private void hideSubmenu() {
        if (submenu == null) return;

        submenu.hide();
        openSubmenu = null;

        // Fix for RT-37022 - we dispose content so that we do not process CSS
        // on hidden submenus
        disposeContextMenu(submenu);
        submenu = null;

        // Fix for JDK-8158679 - we put the focus on the menu, and then back
        // on the menu item, so that screen readers can properly speak out
        // the menu item.
        getFocusedNode().ifPresent(n -&gt; {
            requestFocus();
            n.requestFocus();
        });
    }

    private void hideAllMenus(MenuItem item) {
        if (contextMenu != null) contextMenu.hide();

        Menu parentMenu;
        while ((parentMenu = item.getParentMenu()) != null) {
            parentMenu.hide();
            item = parentMenu;
        }
        if (item.getParentPopup() != null) {
            item.getParentPopup().hide();
        }
    }

    private Menu openSubmenu;
    private ContextMenu submenu;

    // FIXME: HACKY. We use this so that a submenu knows where to open from
    // but this will only work for mouse hovers currently - and won't work
    // programmatically.
    // package protected for testing only!
    Region selectedBackground;

    void scroll(double delta) {
        double newTy = ty + delta;
        if (ty == newTy) return;

        // translation should never be positive (this would mean the top of the
        // menu content is detaching from the top of the menu!)
        if (newTy &gt; 0.0) {
            newTy = 0.0;
        }

        // translation should never be greater than the preferred height of the
        // menu content (otherwise the menu content will be detaching from the
        // bottom of the menu).
        // RT-37185: We check the direction of the scroll, to prevent it locking
        // up when scrolling upwards from the very bottom (using the on-screen
        // up arrow).
        if (delta &lt; 0 &amp;&amp; (getHeight() - newTy) &gt; itemsContainer.getHeight() - downArrow.getHeight()) {
            newTy = getHeight() - itemsContainer.getHeight() - downArrow.getHeight();
        }

        ty = newTy;
        itemsContainer.requestLayout();
    }

    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/
    @Override public Styleable getStyleableParent() {
        return contextMenu;
    }

    private static class StyleableProperties {

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());

            //
            // SkinBase only has Region's unique StlyleableProperty's, none of Nodes
            // So, we need to add effect back in. The effect property is in a
            // private inner class, so get the property from Node the hard way.
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; nodeStyleables = Node.getClassCssMetaData();
            for(int n=0, max=nodeStyleables.size(); n&lt;max; n++) {
                CssMetaData&lt;? extends Styleable, ?&gt; styleable = nodeStyleables.get(n);
                if (&quot;effect&quot;.equals(styleable.getProperty())) {
                    styleables.add(styleable);
                    break;
                }
            }
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    public Label getLabelAt(int index) {
        return ((MenuItemContainer)itemsContainer.getChildren().get(index)).getLabel();
    }

    /**
     * Custom VBox to enable scrolling of items. Scrolling effect is achieved by
     * controlling the translate Y coordinate of the menu item &quot;ty&quot; which is set by a
     * timeline when mouse is over up/down arrow.
     */
    class MenuBox extends VBox {
        MenuBox() {
            setAccessibleRole(AccessibleRole.CONTEXT_MENU);
        }

        @Override protected void layoutChildren() {
            double yOffset = ty;
            for (Node n : getChildren()) {
                if (n.isVisible()) {
                    final double prefHeight = snapSizeY(n.prefHeight(-1));
                    n.resize(snapSizeX(getWidth()), prefHeight);
                    n.relocate(snappedLeftInset(), yOffset);
                    yOffset += prefHeight;
                }
            }
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case VISIBLE: return contextMenu.isShowing();
                case PARENT_MENU: return contextMenu.getOwnerNode();
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }
    }

    class ArrowMenuItem extends StackPane {
         private StackPane upDownArrow;
         private ContextMenuContent popupMenuContent;
         private boolean up = false;
         public final boolean isUp() { return up; }
         public void setUp(boolean value) {
            up = value;
            upDownArrow.getStyleClass().setAll(isUp() ? &quot;menu-up-arrow&quot; : &quot;menu-down-arrow&quot;);
        }

        // used to automatically scroll through menu items when the user performs
        // certain interactions, e.g. pressing and holding the arrow buttons
        private Timeline scrollTimeline;

        public ArrowMenuItem(ContextMenuContent pmc) {
            getStyleClass().setAll(&quot;scroll-arrow&quot;);
            upDownArrow = new StackPane();
            this.popupMenuContent = pmc;
            upDownArrow.setMouseTransparent(true);
            upDownArrow.getStyleClass().setAll(isUp() ? &quot;menu-up-arrow&quot; : &quot;menu-down-arrow&quot;);
    //        setMaxWidth(Math.max(upDownArrow.prefWidth(-1), getWidth()));
            addEventHandler(MouseEvent.MOUSE_ENTERED, me -&gt; {
                if (scrollTimeline != null &amp;&amp; (scrollTimeline.getStatus() != Status.STOPPED)) {
                    return;
                }
                startTimeline();
            });
            addEventHandler(MouseEvent.MOUSE_EXITED, me -&gt; {
                stopTimeline();
            });
            setVisible(false);
            setManaged(false);
            getChildren().add(upDownArrow);
        }

        @Override protected double computePrefWidth(double height) {
//            return snapSize(getInsets().getLeft()) + snapSize(getInsets().getRight());
            return itemsContainer.getWidth();
        }

        @Override protected double computePrefHeight(double width) {
            return snappedTopInset() + upDownArrow.prefHeight(-1) + snappedBottomInset();
        }

        @Override protected void layoutChildren() {
            double w = snapSizeX(upDownArrow.prefWidth(-1));
            double h = snapSizeY(upDownArrow.prefHeight(-1));

            upDownArrow.resize(w, h);
            positionInArea(upDownArrow, 0, 0, getWidth(), getHeight(),
                    /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
        }

        private void adjust() {
            if(up) popupMenuContent.scroll(12); else popupMenuContent.scroll(-12);
        }

        private void startTimeline() {
            scrollTimeline = new Timeline();
            scrollTimeline.setCycleCount(Timeline.INDEFINITE);
            KeyFrame kf = new KeyFrame(
                Duration.millis(60),
                    event -&gt; {
                        adjust();
                    }
            );
            scrollTimeline.getKeyFrames().clear();
            scrollTimeline.getKeyFrames().add(kf);
            scrollTimeline.play();
        }

        private void stopTimeline() {
            scrollTimeline.stop();
            scrollTimeline = null;
        }
    }

    /*
     * Container responsible for laying out a single row in the menu - in other
     * words, this contains and lays out a single MenuItem, regardless of it's
     * specific subtype.
     */
    public class MenuItemContainer extends Region {

        private final MenuItem item;

        private Node left;
        private Node graphic;
        private Node label;
        private Node right;

        private final LambdaMultiplePropertyChangeListenerHandler listener =
            new LambdaMultiplePropertyChangeListenerHandler();

        private EventHandler&lt;MouseEvent&gt; mouseEnteredEventHandler;
        private EventHandler&lt;MouseEvent&gt; mouseReleasedEventHandler;

        private EventHandler&lt;ActionEvent&gt; actionEventHandler;

        protected Label getLabel(){
            return (Label) label;
        }

        public MenuItem getItem() {
            return item;
        }

        public MenuItemContainer(MenuItem item){
            if (item == null) {
                throw new NullPointerException(&quot;MenuItem can not be null&quot;);
            }

            getStyleClass().addAll(item.getStyleClass());
            setId(item.getId());
            setFocusTraversable(!(item instanceof CustomMenuItem));
            this.item = item;

            createChildren();

            // listen to changes in the state of certain MenuItem types
            ReadOnlyBooleanProperty pseudoProperty;
            if (item instanceof Menu) {
                pseudoProperty = ((Menu)item).showingProperty();
                listener.registerChangeListener(pseudoProperty,
                        e -&gt; pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, ((Menu) item).isShowing()));
                pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, pseudoProperty.get());
                setAccessibleRole(AccessibleRole.MENU);
            } else if (item instanceof RadioMenuItem) {
                pseudoProperty = ((RadioMenuItem)item).selectedProperty();
                listener.registerChangeListener(pseudoProperty,
                        e -&gt; pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, ((RadioMenuItem) item).isSelected()));
                pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, pseudoProperty.get());
                setAccessibleRole(AccessibleRole.RADIO_MENU_ITEM);
            } else if (item instanceof CheckMenuItem) {
                pseudoProperty = ((CheckMenuItem)item).selectedProperty();
                listener.registerChangeListener(pseudoProperty,
                        e -&gt; pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, ((CheckMenuItem) item).isSelected()));
                pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, pseudoProperty.get());
                setAccessibleRole(AccessibleRole.CHECK_MENU_ITEM);
            } else {
                setAccessibleRole(AccessibleRole.MENU_ITEM);
            }

            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, item.disableProperty().get());
            listener.registerChangeListener(item.disableProperty(),
                    e -&gt; pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, item.isDisable()));

            // Add the menu item to properties map of this node. Used by QA for testing
            // This allows associating this container with corresponding MenuItem.
            getProperties().put(MenuItem.class, item);

            listener.registerChangeListener(item.graphicProperty(), e -&gt; {
                createChildren();
                computeVisualMetrics();
            });

            actionEventHandler = e -&gt; {
                if (item instanceof Menu) {
                    final Menu menu = (Menu) item;
                    if (openSubmenu == menu &amp;&amp; submenu.isShowing()) return;
                    if (openSubmenu != null) {
                        hideSubmenu();
                    }

                    selectedBackground = MenuItemContainer.this;
                    showMenu(menu);
                } else {
                    doSelect();
                }
            };
            addEventHandler(ActionEvent.ACTION, actionEventHandler);
        }

        public void dispose() {
            if (item instanceof CustomMenuItem) {
                Node node = ((CustomMenuItem)item).getContent();
                if (node != null) {
                    node.removeEventHandler(MouseEvent.MOUSE_CLICKED, customMenuItemMouseClickedHandler);
                }
            }

            listener.dispose();
            removeEventHandler(ActionEvent.ACTION, actionEventHandler);

            if (label != null) {
                ((Label)label).textProperty().unbind();
                label.styleProperty().unbind();
                label.idProperty().unbind();

                ListChangeListener&lt;String&gt; itemStyleClassListener = (ListChangeListener&lt;String&gt;)item.getProperties().remove(ITEM_STYLE_CLASS_LISTENER);
                if (itemStyleClassListener != null) {
                    item.getStyleClass().removeListener(itemStyleClassListener);
                }
            }

            left = null;
            graphic = null;
            label = null;
            right = null;
        }

        private void createChildren() {
            getChildren().clear();

            // draw background region for hover effects. All content (other
            // than Nodes from NodeMenuItems) are set to be mouseTransparent, so
            // this background also acts as the receiver of user input
            if (item instanceof CustomMenuItem) {
                createNodeMenuItemChildren((CustomMenuItem)item);

                if (mouseEnteredEventHandler == null) {
                    mouseEnteredEventHandler = event -&gt; {
                        requestFocus(); // request Focus on hover
                    };
                } else {
                    removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                }
                addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
            } else {
                // --- add check / radio to left column
                Node leftNode = getLeftGraphic(item);
                if (leftNode != null) {
                    StackPane leftPane = new StackPane();
                    leftPane.getStyleClass().add(&quot;left-container&quot;);
                    leftPane.getChildren().add(leftNode);
                    left = leftPane;
                    getChildren().add(left);
                    left.setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
                }
                // -- add graphic to graphic pane
                if (item.getGraphic() != null) {
                    Node graphicNode = item.getGraphic();
                    StackPane graphicPane = new StackPane();
                    graphicPane.getStyleClass().add(&quot;graphic-container&quot;);
                    graphicPane.getChildren().add(graphicNode);
                    graphic = graphicPane;
                    getChildren().add(graphic);
                }

                // --- add text to center column
                label = new MenuLabel(item, this);  // make this a menulabel to handle mnemonics fire()

                // set up bindings from the MenuItem into the Label
                ((Label)label).textProperty().bind(item.textProperty());
                label.styleProperty().bind(item.styleProperty());
                label.idProperty().bind(item.styleProperty());

                // we want to ensure that any styleclasses set on the menuitem are applied to the
                // label (so we can style appropriately), but we can't just do a binding such as this:
                // Bindings.bindContent(label.getStyleClass(), item.getStyleClass());
                // Because that means we overwrite the 'label' style class on the Label.
                // What we really want is to ensure all style classes in the MenuItem are _copied_
                // into the label, which is what we do below
                ListChangeListener&lt;String&gt; itemStyleClassListener = c -&gt; {
                    while (c.next()) {
                        label.getStyleClass().removeAll(c.getRemoved());
                        label.getStyleClass().addAll(c.getAddedSubList());
                    }
                };
                item.getStyleClass().addListener(itemStyleClassListener);
                item.getProperties().put(ITEM_STYLE_CLASS_LISTENER, itemStyleClassListener);


                label.setMouseTransparent(true);
                getChildren().add(label);

                listener.unregisterChangeListeners(focusedProperty());
                // RT-19546 update currentFocusedIndex when MenuItemContainer gets focused.
                // e.g this happens when you press the Right key to open a submenu; the first
                // menuitem is focused.
                listener.registerChangeListener(focusedProperty(), e -&gt; {
                    if (isFocused()) {
                        currentFocusedIndex = itemsContainer.getChildren().indexOf(MenuItemContainer.this);
                    }
                });

                // --- draw in right column - this depends on whether we are
                // a Menu or not. A Menu gets an arrow, whereas other MenuItems
                // get the ability to draw an accelerator
                if (item instanceof Menu) {
                    // --- add arrow / accelerator / mnemonic to right column
                    Region rightNode = new Region();
                    rightNode.setMouseTransparent(true);
                    rightNode.getStyleClass().add(&quot;arrow&quot;);

                    StackPane rightPane = new StackPane();
                    rightPane.setMaxWidth(Math.max(rightNode.prefWidth(-1), 10));
                    rightPane.setMouseTransparent(true);
                    rightPane.getStyleClass().add(&quot;right-container&quot;);
                    rightPane.getChildren().add(rightNode);
                    right = rightPane;
                    getChildren().add(rightPane);

                    if (mouseEnteredEventHandler == null) {
                        mouseEnteredEventHandler = event -&gt; {
                            if (openSubmenu != null &amp;&amp; item != openSubmenu) {
                                // if a submenu of a different menu is already
                                // open then close it (RT-15049)
                                hideSubmenu();
                            }

                            selectedBackground = MenuItemContainer.this;
                            requestFocus();  // request Focus on hover
                            final Menu menu = (Menu) item;
                            if (menu.isDisable()) return;
                            menu.show();
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    }

                    if (mouseReleasedEventHandler == null) {
                        mouseReleasedEventHandler = event -&gt; {
                            item.fire();
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
                    }

                    // show submenu when the menu is hovered over
                    addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    addEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
                } else { // normal MenuItem
                    // remove old listeners
                    listener.unregisterChangeListeners(item.acceleratorProperty());

                    // accelerator support
                    updateAccelerator();

                    if (mouseEnteredEventHandler == null) {
                        mouseEnteredEventHandler = event -&gt; {
                            if (openSubmenu != null) {
                                openSubmenu.hide();
                            }
                            requestFocus();  // request Focus on hover
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    }

                    if (mouseReleasedEventHandler == null) {
                        mouseReleasedEventHandler = event -&gt; {
                            doSelect();
                        };
                    } else {
                        removeEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
                    }

                    addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
                    addEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);

                    listener.registerChangeListener(item.acceleratorProperty(), e -&gt; updateAccelerator());
                }
            }
        }

        private void updateAccelerator() {
            if (item.getAccelerator() != null) {
                if (right != null) {
                    getChildren().remove(right);
                }

                String text = item.getAccelerator().getDisplayText();
                right = new Label(text);
                right.setStyle(item.getStyle());
                right.getStyleClass().add(&quot;accelerator-text&quot;);
                getChildren().add(right);
            } else {
                getChildren().remove(right);
            }
        }

        void doSelect() {
            // don't do anything on disabled menu items
            if (item.isDisable()) return;
            // toggle state of check or radio items
            if (item instanceof CheckMenuItem) {
                CheckMenuItem checkItem = (CheckMenuItem)item;
                checkItem.setSelected(!checkItem.isSelected());
            } else if (item instanceof RadioMenuItem) {
                // this is a radio button. If there is a toggleGroup specified, we
                // simply set selected to true. If no toggleGroup is specified, we
                // toggle the selected state, as there is no assumption of mutual
                // exclusivity when no toggleGroup is set.
                final RadioMenuItem radioItem = (RadioMenuItem) item;
                radioItem.setSelected(radioItem.getToggleGroup() != null ? true : !radioItem.isSelected());
            }

            // fire the action before hiding the menu
            item.fire();

            if (item instanceof CustomMenuItem) {
                CustomMenuItem customMenuItem = (CustomMenuItem) item;
                if (customMenuItem.isHideOnClick()) {
                    hideAllMenus(item);
                }
            } else {
                hideAllMenus(item);
            }
        }

        private EventHandler&lt;MouseEvent&gt; customMenuItemMouseClickedHandler;

        private void createNodeMenuItemChildren(final CustomMenuItem item) {
            Node node = item.getContent();
            getChildren().add(node);

            // handle hideOnClick
            customMenuItemMouseClickedHandler = event -&gt; {
                if (item == null || item.isDisable()) return;

                item.fire();
                if (item.isHideOnClick()) {
                    hideAllMenus(item);
                }
            };
            node.addEventHandler(MouseEvent.MOUSE_CLICKED, customMenuItemMouseClickedHandler);
        }

        @Override protected void layoutChildren() {
            double xOffset;

            final double prefHeight = prefHeight(-1);
            if (left != null) {
                xOffset = snappedLeftInset();
                left.resize(left.prefWidth(-1), left.prefHeight(-1));
                positionInArea(left, xOffset, 0,
                        maxLeftWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
            }
            if (graphic != null) {
                xOffset = snappedLeftInset() + maxLeftWidth;
                graphic.resize(graphic.prefWidth(-1), graphic.prefHeight(-1));
                positionInArea(graphic, xOffset, 0,
                        maxGraphicWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
            }

            if (label != null) {
                xOffset = snappedLeftInset() + maxLeftWidth + maxGraphicWidth;
                label.resize(label.prefWidth(-1), label.prefHeight(-1));
                positionInArea(label, xOffset, 0,
                        maxLabelWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
            }

            if (right != null) {
                xOffset = snappedLeftInset() + maxLeftWidth + maxGraphicWidth + maxLabelWidth;
                right.resize(right.prefWidth(-1), right.prefHeight(-1));
                positionInArea(right, xOffset, 0,
                    maxRightWidth, prefHeight, 0, HPos.RIGHT, VPos.CENTER);
            }

            if ( item instanceof CustomMenuItem) {
                Node n = ((CustomMenuItem) item).getContent();
                if (item instanceof SeparatorMenuItem) {
                    double width = prefWidth(-1) - (snappedLeftInset() + maxGraphicWidth + snappedRightInset());
                    n.resize(width, n.prefHeight(-1));
                    positionInArea(n, snappedLeftInset() + maxGraphicWidth, 0, prefWidth(-1), prefHeight, 0, HPos.LEFT, VPos.CENTER);
                } else {
                    n.resize(n.prefWidth(-1), n.prefHeight(-1));
                    //the node should be left aligned
                    positionInArea(n, snappedLeftInset(), 0, getWidth(), prefHeight, 0, HPos.LEFT, VPos.CENTER);
                }
            }
        }

        @Override protected double computePrefHeight(double width) {
            double prefHeight = 0;
            if (item instanceof CustomMenuItem || item instanceof SeparatorMenuItem) {
                prefHeight = (getChildren().isEmpty()) ? 0 : getChildren().get(0).prefHeight(-1);
            } else {
                prefHeight = Math.max(prefHeight, (left != null) ? left.prefHeight(-1) : 0);
                prefHeight = Math.max(prefHeight, (graphic != null) ? graphic.prefHeight(-1) : 0);
                prefHeight = Math.max(prefHeight, (label != null) ? label.prefHeight(-1) : 0);
                prefHeight = Math.max(prefHeight, (right != null) ? right.prefHeight(-1) : 0);
            }
             return snappedTopInset() + prefHeight + snappedBottomInset();
        }

        @Override protected double computePrefWidth(double height) {
            double nodeMenuItemWidth = 0;
            if (item instanceof CustomMenuItem &amp;&amp; !(item instanceof SeparatorMenuItem)) {
                nodeMenuItemWidth = snappedLeftInset() + ((CustomMenuItem) item).getContent().prefWidth(-1) +
                        snappedRightInset();
            }
            return Math.max(nodeMenuItemWidth,
                    snappedLeftInset() + maxLeftWidth + maxGraphicWidth +
                    maxLabelWidth + maxRightWidth + snappedRightInset());
        }

        // Responsible for returning a graphic (if necessary) to position in the
        // left column of the menu. This may be a Node from the MenuItem.graphic
        // property, or it may be a check/radio item if necessary.
        private Node getLeftGraphic(MenuItem item) {
            if (item instanceof RadioMenuItem) {
                 final Region _graphic = new Region();
                _graphic.getStyleClass().add(&quot;radio&quot;);
                return _graphic;
            } else if (item instanceof CheckMenuItem) {
                final StackPane _graphic = new StackPane();
                _graphic.getStyleClass().add(&quot;check&quot;);
                return _graphic;
            }

            return null;
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case SELECTED:
                    if (item instanceof CheckMenuItem) {
                        return ((CheckMenuItem)item).isSelected();
                    }
                    if (item instanceof RadioMenuItem) {
                        return ((RadioMenuItem) item).isSelected();
                    }
                    return false;
                case ACCELERATOR: return item.getAccelerator();
                case TEXT: {
                    String title = &quot;&quot;;
                    if (graphic != null) {
                        String t = (String)graphic.queryAccessibleAttribute(AccessibleAttribute.TEXT);
                        if (t != null) title += t;
                    }
                    final Label label = getLabel();
                    if (label != null) {
                        String t = (String)label.queryAccessibleAttribute(AccessibleAttribute.TEXT);
                        if (t != null) title += t;
                    }
                    if (item instanceof CustomMenuItem) {
                        Node content = ((CustomMenuItem) item).getContent();
                        if (content != null) {
                            String t = (String)content.queryAccessibleAttribute(AccessibleAttribute.TEXT);
                            if (t != null) title += t;
                        }
                    }
                    return title;
                }
                case MNEMONIC: {
                    final Label label = getLabel();
                    if (label != null) {
                        String mnemonic = (String)label.queryAccessibleAttribute(AccessibleAttribute.MNEMONIC);
                        if (mnemonic != null) return mnemonic;
                    }
                    return null;
                }
                case DISABLED: return item.isDisable();
                case SUBMENU:
                    createSubmenu();
                    // Accessibility might need to see the menu node before the window
                    // is visible (i.e. before the skin is applied).
                    if (submenu.getSkin() == null) {
                        submenu.getStyleableNode().applyCss();
                    }
                    ContextMenuContent cmContent = (ContextMenuContent)submenu.getSkin().getNode();
                    return cmContent.itemsContainer;
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }

        /** {@inheritDoc} */
        @Override
        public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
            switch (action) {
                case SHOW_MENU:{
                    if (item instanceof Menu) {
                        final Menu menuItem = (Menu) item;
                        if (menuItem.isShowing()) {
                            menuItem.hide();
                        } else {
                            menuItem.show();
                        }
                    }
                    break;
                }
                case FIRE:
                    doSelect();
                    break;
                default: super.executeAccessibleAction(action);
            }
        }
    }


    private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;selected&quot;);
    private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;disabled&quot;);
    private static final PseudoClass CHECKED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;checked&quot;);

    private class MenuLabel extends Label {

        public MenuLabel(MenuItem item, MenuItemContainer mic) {
            super(item.getText());
            setMnemonicParsing(item.isMnemonicParsing());
            setLabelFor(mic);
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/LabeledImpl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package com.sun.javafx.scene.control;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.scene.control.Label;
import javafx.scene.control.Labeled;

import javafx.css.CssMetaData;
import javafx.css.StyleOrigin;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javafx.css.Styleable;
import javafx.css.StyleableProperty;
import javafx.scene.layout.Region;


public class LabeledImpl extends Label {

    public LabeledImpl(final Labeled labeled) {
        shuttler = new Shuttler(this, labeled);
<A NAME="8"></A>    }
    private final Shuttler shuttler;

    private static void initialize(Shuttler shuttler, LabeledImpl labeledImpl, <FONT color="#bce954"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#8',2,'match46-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Labeled labeled) {

        labeledImpl.setText(labeled.getText());
        labeled.textProperty().addListener(shuttler);

        labeledImpl.setGraphic(labeled.getGraphic());
        labeled.graphicProperty().addListener(shuttler);

        final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables = StyleableProperties.STYLEABLES_TO_MIRROR</B></FONT>;

        for(int n=0, nMax=styleables.size(); n&lt;nMax; n++) {
            @SuppressWarnings(&quot;unchecked&quot;)
            final CssMetaData&lt;Styleable,Object&gt; styleable = (CssMetaData&lt;Styleable,Object&gt;)styleables.get(n);

            // the Labeled isn't necessarily a Label, so skip the skin or
            // we'll get an argument type mismatch on the invocation of the
            // skin constructor.
            if (&quot;-fx-skin&quot;.equals(styleable.getProperty())) continue;

            final StyleableProperty&lt;?&gt; fromVal = styleable.getStyleableProperty(labeled);
            if (fromVal instanceof Observable) {
                // listen for changes to this property
                ((Observable)fromVal).addListener(shuttler);
                // set this LabeledImpl's property to the same value as the Labeled.
                final StyleOrigin origin = fromVal.getStyleOrigin();
                if (origin == null) continue;
                final StyleableProperty&lt;Object&gt; styleableProperty = styleable.getStyleableProperty(labeledImpl);
                styleableProperty.applyStyle(origin, fromVal.getValue());
            }
        }
    }

    private static class Shuttler implements InvalidationListener {

        private final LabeledImpl labeledImpl;
        private final Labeled labeled;

        Shuttler(LabeledImpl labeledImpl, Labeled labeled) {
            this.labeledImpl = labeledImpl;
            this.labeled = labeled;
            initialize(this, labeledImpl, labeled);

        }

        @Override public void invalidated(Observable valueModel) {

            if (valueModel == labeled.textProperty()) {
                labeledImpl.setText(labeled.getText());
            } else if (valueModel == labeled.graphicProperty()) {
                // If the user set the graphic, then mirror that.
                // Otherwise, the graphic was set via the imageUrlProperty which
                // will be mirrored onto the labeledImpl by the next block.
                StyleOrigin origin = ((StyleableProperty&lt;?&gt;)labeled.graphicProperty()).getStyleOrigin();
                if (origin == null || origin == StyleOrigin.USER) {
                    labeledImpl.setGraphic(labeled.getGraphic());
                }

            } else if (valueModel instanceof StyleableProperty) {
                StyleableProperty&lt;?&gt; styleableProperty = (StyleableProperty&lt;?&gt;)valueModel;
                @SuppressWarnings(&quot;unchecked&quot;)
                CssMetaData&lt;Styleable,Object&gt; cssMetaData = (CssMetaData&lt;Styleable,Object&gt;)styleableProperty.getCssMetaData();
                if (cssMetaData != null) {
                    StyleOrigin origin = styleableProperty.getStyleOrigin();
                    StyleableProperty&lt;Object&gt; targetProperty = cssMetaData.getStyleableProperty(labeledImpl);
                    targetProperty.applyStyle(origin, styleableProperty.getValue());
                }
            }
        }
    }

    /** Protected for unit test purposes */
    static final class StyleableProperties {

        static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES_TO_MIRROR;
        static {
            //
            // We do this as we only want to mirror the Labeled's keys,
            // none of Parent's, otherwise all of the properties on Parent,
            // like opacity, would be applied twice (once to the Labeled and
            // again to the LabeledImpl).
            //
            // Note, however, that this subset is not the list of properties
            // for this LabeledImpl that can be styled. For that, we want all
            // the properites that are inherited by virtue of LabeledImpl
            // being a Label. This allows for the LabledImpl to be styled
            // with styles like .menu-button .label { -fx-opacity: 80%; }
            // If just this subset were returned then
            // -fx-opacity (for example) would be meaningless to the Labeled.
            //
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; labeledStyleables = Labeled.getClassCssMetaData();
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; parentStyleables = Region.getClassCssMetaData();
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(labeledStyleables);
            styleables.removeAll(parentStyleables);
            STYLEABLES_TO_MIRROR = Collections.unmodifiableList(styleables);
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/SelectedItemsReadOnlyObservableList.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.javafx.scene.control;

import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.ObservableListBase;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Supplier;

public abstract class SelectedItemsReadOnlyObservableList&lt;E&gt; extends ObservableListBase&lt;E&gt; {

    // This is the actual observable list of selected indices used in the selection model
    private final ObservableList&lt;Integer&gt; selectedIndices;

    private ObservableList&lt;E&gt; itemsList;

    private boolean itemsListChanged = false;
    private ListChangeListener.Change&lt;? extends E&gt; itemsListChange;
    private final ListChangeListener itemsListListener = c -&gt; {
        itemsListChanged = true;
        itemsListChange = c;
    };

    private final Supplier&lt;Integer&gt; modelSizeSupplier;

    private final List&lt;WeakReference&lt;E&gt;&gt; itemsRefList;

    public SelectedItemsReadOnlyObservableList(ObservableList&lt;Integer&gt; selectedIndices, Supplier&lt;Integer&gt; modelSizeSupplier) {
        this.modelSizeSupplier = modelSizeSupplier;
        this.selectedIndices = selectedIndices;
        this.itemsRefList = new ArrayList&lt;&gt;();

        selectedIndices.addListener((ListChangeListener&lt;Integer&gt;)c -&gt; {
            beginChange();

            while (c.next()) {
                if (c.wasReplaced()) {
                    List&lt;E&gt; removed = getRemovedElements(c);
                    List&lt;E&gt; added = getAddedElements(c);
                    if (!removed.equals(added)) {
                        nextReplace(c.getFrom(), c.getTo(), removed);
                    }
                } else if (c.wasAdded()) {
                    nextAdd(c.getFrom(), c.getTo());
                } else if (c.wasRemoved()) {
                    int removedSize = c.getRemovedSize();
                    if (removedSize == 1) {
                        nextRemove(c.getFrom(), getRemovedModelItem(c.getFrom()));
                    } else {
                        nextRemove(c.getFrom(), getRemovedElements(c));
                    }
                } else if (c.wasPermutated()) {
                    int[] permutation = new int[size()];
                    for (int i = 0; i &lt; size(); i++) {
                        permutation[i] = c.getPermutation(i);
                    }
                    nextPermutation(c.getFrom(), c.getTo(), permutation);
                } else if (c.wasUpdated()) {
                    for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                        nextUpdate(i);
                    }
                }
            }

            // regardless of the change, we recreate the itemsRefList to reflect the current items list.
            // This is important for cases where items are removed (and so must their selection, but we lose
            // access to the item before we can fire the event).
            // FIXME we could make this more efficient by only making the reported changes to the list
            itemsRefList.clear();
            for (int selectedIndex : selectedIndices) {
                itemsRefList.add(new WeakReference&lt;&gt;(getModelItem(selectedIndex)));
            }

            itemsListChanged = false;
            itemsListChange = null;

            endChange();
        });
    }

    protected abstract E getModelItem(int index);

    @Override
    public E get(int index) {
        int pos = selectedIndices.get(index);
        return getModelItem(pos);
    }

    @Override
    public int size() {
        return selectedIndices.size();
    }

    // Used by ListView and TableView to allow for improved handling.
    public void setItemsList(ObservableList&lt;E&gt; itemsList) {
        if (this.itemsList != null) {
            this.itemsList.removeListener(itemsListListener);
        }
        this.itemsList = itemsList;
        if (itemsList != null) {
            itemsList.addListener(itemsListListener);
        }
    }

    private E _getModelItem(int index) {
        if (index &gt;= modelSizeSupplier.get()) {
            // attempt to return from the itemsRefList instead
            return getRemovedModelItem(index);
        } else {
            return getModelItem(index);
        }
    }
<A NAME="49"></A>
    private E getRemovedModelItem(int index) {
        // attempt to return from the itemsRefList instead
        return index &lt; 0 || index &gt;= itemsRefList.size() ? null : <FONT color="#8e35ef"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#49',2,'match46-top.html#49',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>itemsRefList.get(index).get();
    }

    private List&lt;E&gt; getRemovedElements(ListChangeListener.Change&lt;? extends Integer&gt; c) {
        List&lt;E&gt; removed = new ArrayList&lt;&gt;(c.getRemovedSize</B></FONT>());
        final int startPos = c.getFrom();
        for (int i = startPos, max = startPos + c.getRemovedSize(); i &lt; max; i++) {
            removed.add(getRemovedModelItem(i));
        }
        return removed;
    }

    private List&lt;E&gt; getAddedElements(ListChangeListener.Change&lt;? extends Integer&gt; c) {
        List&lt;E&gt; added = new ArrayList&lt;&gt;(c.getAddedSize());
        for (int index : c.getAddedSubList()) {
            added.add(_getModelItem(index));
        }
        return added;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/SplitMenuButtonBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="20"></A> * questions.
 */

<FONT color="#d4a017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#20',2,'match46-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.javafx.scene.control.behavior;

import javafx.scene.control.SplitMenuButton;
import com.sun.javafx.scene.control.inputmap.InputMap;

import static javafx.scene.input.KeyCode.ENTER;
import static javafx.scene.input.KeyCode.SPACE;
import static javafx.scene.input.KeyEvent.KEY_PRESSED;
import static javafx.scene.input.KeyEvent.KEY_RELEASED;

/**
 * Behavior for SplitMenuButton.
 */
public class SplitMenuButtonBehavior extends MenuButtonBehaviorBase&lt;SplitMenuButton&gt; {

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new SplitMenuButtonBehavior for the given SplitMenuButton.
     *
     * @param splitMenuButton the SplitMenuButton
     */
    public SplitMenuButtonBehavior(final SplitMenuButton splitMenuButton) {
        super(splitMenuButton);

        /**
         * The key bindings for the SplitMenuButton. Sets the Enter key as the means
         * to open the menu and the space key as the means to activate the action.
         */
        addDefaultMapping(new</B></FONT> InputMap.KeyMapping(SPACE, KEY_PRESSED, this::keyPressed));
        addDefaultMapping(new InputMap.KeyMapping(SPACE, KEY_RELEASED, this::keyReleased));
        addDefaultMapping(new InputMap.KeyMapping(ENTER, KEY_PRESSED, this::keyPressed));
        addDefaultMapping(new InputMap.KeyMapping(ENTER, KEY_RELEASED, this::keyReleased));
    }

    /***************************************************************************
     *                                                                         *
     * Key event handling                                                      *
     *                                                                         *
     **************************************************************************/

//    /**
//     * The key bindings for the SplitMenuButton. Sets the Enter key as the means
//     * to open the menu and the space key as the means to activate the action.
//     */
//    protected static final List&lt;KeyBinding&gt; SPLIT_MENU_BUTTON_BINDINGS = new ArrayList&lt;KeyBinding&gt;();
//    static {
//        SPLIT_MENU_BUTTON_BINDINGS.addAll(BASE_MENU_BUTTON_BINDINGS);
//
//        SPLIT_MENU_BUTTON_BINDINGS.add(new KeyBinding(SPACE, KEY_PRESSED, &quot;Press&quot;));
//        SPLIT_MENU_BUTTON_BINDINGS.add(new KeyBinding(SPACE, KEY_RELEASED, &quot;Release&quot;));
//
//        SPLIT_MENU_BUTTON_BINDINGS.add(new KeyBinding(ENTER, KEY_PRESSED,  &quot;Press&quot;));
//        SPLIT_MENU_BUTTON_BINDINGS.add(new KeyBinding(ENTER, KEY_RELEASED, &quot;Release&quot;));
//    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/TableViewBehaviorBase.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.scene.control.SizeLimitedList;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.event.EventHandler;
import javafx.geometry.NodeOrientation;
import javafx.scene.control.*;
import com.sun.javafx.scene.control.inputmap.InputMap;
import com.sun.javafx.scene.control.inputmap.KeyBinding;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.util.Callback;
import java.util.ArrayList;
import java.util.List;
import com.sun.javafx.PlatformUtil;
import static javafx.scene.input.KeyCode.*;
import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;

public abstract class TableViewBehaviorBase&lt;C extends Control, T, TC extends TableColumnBase&lt;T,?&gt;&gt; extends BehaviorBase&lt;C&gt; {

    /**************************************************************************
     *                                                                        *
     * Internal fields                                                        *
     *                                                                        *
     *************************************************************************/

    private final InputMap&lt;C&gt; tableViewInputMap;

    protected boolean isShortcutDown = false;
    protected boolean isShiftDown = false;
    private boolean selectionPathDeviated = false;
    protected boolean selectionChanging = false;

    private final EventHandler&lt;KeyEvent&gt; keyEventListener = e -&gt; {
        if (!e.isConsumed()) {
            // RT-12751: we want to keep an eye on the user holding down the shift key,
            // so that we know when they enter/leave multiple selection mode. This
            // changes what happens when certain key combinations are pressed.
            isShiftDown = e.getEventType() == KeyEvent.KEY_PRESSED &amp;&amp; e.isShiftDown();
            isShortcutDown = e.getEventType() == KeyEvent.KEY_PRESSED &amp;&amp; e.isShortcutDown();
        }
    };

    private final SizeLimitedList&lt;TablePositionBase&gt; selectionHistory = new SizeLimitedList&lt;&gt;(10);

    protected final ListChangeListener&lt;TablePositionBase&gt; selectedCellsListener = c -&gt; {
        while (c.next()) {
            if (c.wasReplaced()) {
                if (TreeTableCellBehavior.hasDefaultAnchor(getNode())) {
                    TreeTableCellBehavior.removeAnchor(getNode());
                }
            }

            if (! c.wasAdded()) {
                continue;
            }

            TableSelectionModel sm = getSelectionModel();
            if (sm == null) return;

            TablePositionBase anchor = getAnchor();
            boolean cellSelectionEnabled = sm.isCellSelectionEnabled();

            int addedSize = c.getAddedSize();
            List&lt;TablePositionBase&gt; addedSubList = (List&lt;TablePositionBase&gt;) c.getAddedSubList();

            for (TablePositionBase tpb : addedSubList) {
                if (! selectionHistory.contains(tpb)) {
                    selectionHistory.add(tpb);
                }
            }

            // newest selection
            if (addedSize &gt; 0 &amp;&amp; ! hasAnchor()) {
                TablePositionBase tp = addedSubList.get(addedSize - 1);
                setAnchor(tp);
            }

            if (anchor != null &amp;&amp; cellSelectionEnabled &amp;&amp; ! selectionPathDeviated) {
                // check if the selection is on the same row or column,
                // otherwise set selectionPathDeviated to true
                for (int i = 0; i &lt; addedSize; i++) {
                    TablePositionBase tp = addedSubList.get(i);
                    if (anchor.getRow() != -1 &amp;&amp; tp.getRow() != anchor.getRow() &amp;&amp; tp.getColumn() != anchor.getColumn()) {
                        setSelectionPathDeviated(true);
                        break;
                    }
                }
            }
        }
    };

    protected final WeakListChangeListener&lt;TablePositionBase&gt; weakSelectedCellsListener =
            new WeakListChangeListener&lt;TablePositionBase&gt;(selectedCellsListener);



    /**************************************************************************
     *                                                                        *
     * Constructors                                                           *
     *                                                                        *
     *************************************************************************/

    public TableViewBehaviorBase(C control) {
        super(control);


        // create a map for TableView(Base)-specific mappings
        tableViewInputMap = createInputMap();

        KeyMapping enterKeyActivateMapping, escapeKeyCancelEditMapping;
        addDefaultMapping(tableViewInputMap,
                new KeyMapping(TAB, FocusTraversalInputMap::traverseNext),
                new KeyMapping(new KeyBinding(TAB).shift(), FocusTraversalInputMap::traversePrevious),

                new KeyMapping(HOME, e -&gt; selectFirstRow()),
                new KeyMapping(END, e -&gt; selectLastRow()),

                new KeyMapping(PAGE_UP, e -&gt; scrollUp()),
                new KeyMapping(PAGE_DOWN, e -&gt; scrollDown()),

                new KeyMapping(LEFT, e -&gt; selectLeftCell()),
                new KeyMapping(KP_LEFT, e -&gt; selectLeftCell()),
                new KeyMapping(RIGHT, e -&gt; selectRightCell()),
                new KeyMapping(KP_RIGHT, e -&gt; selectRightCell()),

                new KeyMapping(UP, e -&gt; selectPreviousRow()),
                new KeyMapping(KP_UP, e -&gt; selectPreviousRow()),
                new KeyMapping(DOWN, e -&gt; selectNextRow()),
                new KeyMapping(KP_DOWN, e -&gt; selectNextRow()),

                new KeyMapping(LEFT, FocusTraversalInputMap::traverseLeft),
                new KeyMapping(KP_LEFT, FocusTraversalInputMap::traverseLeft),
                new KeyMapping(RIGHT, FocusTraversalInputMap::traverseRight),
                new KeyMapping(KP_RIGHT, FocusTraversalInputMap::traverseRight),
                new KeyMapping(UP, FocusTraversalInputMap::traverseUp),
                new KeyMapping(KP_UP, FocusTraversalInputMap::traverseUp),
                new KeyMapping(DOWN, FocusTraversalInputMap::traverseDown),
                new KeyMapping(KP_DOWN, FocusTraversalInputMap::traverseDown),

                new KeyMapping(new KeyBinding(HOME).shift(), e -&gt; selectAllToFirstRow()),
                new KeyMapping(new KeyBinding(END).shift(), e -&gt; selectAllToLastRow()),
                new KeyMapping(new KeyBinding(PAGE_UP).shift(), e -&gt; selectAllPageUp()),
                new KeyMapping(new KeyBinding(PAGE_DOWN).shift(), e -&gt; selectAllPageDown()),

                new KeyMapping(new KeyBinding(UP).shift(), e -&gt; alsoSelectPrevious()),
                new KeyMapping(new KeyBinding(KP_UP).shift(), e -&gt; alsoSelectPrevious()),
                new KeyMapping(new KeyBinding(DOWN).shift(), e -&gt; alsoSelectNext()),
                new KeyMapping(new KeyBinding(KP_DOWN).shift(), e -&gt; alsoSelectNext()),

                new KeyMapping(new KeyBinding(SPACE).shift(), e -&gt; selectAllToFocus(false)),
                new KeyMapping(new KeyBinding(SPACE).shortcut().shift(), e -&gt; selectAllToFocus(true)),

                new KeyMapping(new KeyBinding(LEFT).shift(), e -&gt; alsoSelectLeftCell()),
                new KeyMapping(new KeyBinding(KP_LEFT).shift(), e -&gt; alsoSelectLeftCell()),
                new KeyMapping(new KeyBinding(RIGHT).shift(), e -&gt; alsoSelectRightCell()),
                new KeyMapping(new KeyBinding(KP_RIGHT).shift(), e -&gt; alsoSelectRightCell()),

                new KeyMapping(new KeyBinding(UP).shortcut(), e -&gt; focusPreviousRow()),
                new KeyMapping(new KeyBinding(DOWN).shortcut(), e -&gt; focusNextRow()),
                new KeyMapping(new KeyBinding(RIGHT).shortcut(), e -&gt; focusRightCell()),
                new KeyMapping(new KeyBinding(KP_RIGHT).shortcut(), e -&gt; focusRightCell()),
                new KeyMapping(new KeyBinding(LEFT).shortcut(), e -&gt; focusLeftCell()),
                new KeyMapping(new KeyBinding(KP_LEFT).shortcut(), e -&gt; focusLeftCell()),

                new KeyMapping(new KeyBinding(A).shortcut(), e -&gt; selectAll()),
                new KeyMapping(new KeyBinding(HOME).shortcut(), e -&gt; focusFirstRow()),
                new KeyMapping(new KeyBinding(END).shortcut(), e -&gt; focusLastRow()),
                new KeyMapping(new KeyBinding(PAGE_UP).shortcut(), e -&gt; focusPageUp()),
                new KeyMapping(new KeyBinding(PAGE_DOWN).shortcut(), e -&gt; focusPageDown()),

                new KeyMapping(new KeyBinding(UP).shortcut().shift(), e -&gt; discontinuousSelectPreviousRow()),
                new KeyMapping(new KeyBinding(DOWN).shortcut().shift(), e -&gt; discontinuousSelectNextRow()),
                new KeyMapping(new KeyBinding(LEFT).shortcut().shift(), e -&gt; discontinuousSelectPreviousColumn()),
                new KeyMapping(new KeyBinding(RIGHT).shortcut().shift(), e -&gt; discontinuousSelectNextColumn()),
                new KeyMapping(new KeyBinding(PAGE_UP).shortcut().shift(), e -&gt; discontinuousSelectPageUp()),
                new KeyMapping(new KeyBinding(PAGE_DOWN).shortcut().shift(), e -&gt; discontinuousSelectPageDown()),
                new KeyMapping(new KeyBinding(HOME).shortcut().shift(), e -&gt; discontinuousSelectAllToFirstRow()),
                new KeyMapping(new KeyBinding(END).shortcut().shift(), e -&gt; discontinuousSelectAllToLastRow()),

                enterKeyActivateMapping = new KeyMapping(ENTER, this::activate),
                new KeyMapping(SPACE, this::activate),
                new KeyMapping(F2, this::activate),
                escapeKeyCancelEditMapping = new KeyMapping(ESCAPE, this::cancelEdit),

                new InputMap.MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed)
        );

        enterKeyActivateMapping.setAutoConsume(false);
        escapeKeyCancelEditMapping.setAutoConsume(false);

        // create OS-specific child mappings
        // --- mac OS
        InputMap&lt;C&gt; macInputMap = new InputMap&lt;&gt;(control);
        macInputMap.setInterceptor(event -&gt; !PlatformUtil.isMac());
        addDefaultMapping(macInputMap, new KeyMapping(new KeyBinding(SPACE).shortcut().ctrl(), e -&gt; toggleFocusOwnerSelection()));
        addDefaultChildMap(tableViewInputMap, macInputMap);

        // --- all other platforms
        InputMap&lt;C&gt; otherOsInputMap = new InputMap&lt;&gt;(control);
        otherOsInputMap.setInterceptor(event -&gt; PlatformUtil.isMac());
        addDefaultMapping(otherOsInputMap, new KeyMapping(new KeyBinding(SPACE).ctrl(), e -&gt; toggleFocusOwnerSelection()));
        addDefaultChildMap(tableViewInputMap, otherOsInputMap);

        // set up other listeners
        // We make this an event _filter_ so that we can determine the state
        // of the shift key before the event handlers get a shot at the event.
        control.addEventFilter(KeyEvent.ANY, keyEventListener);
    }



    /**************************************************************************
     *                                                                        *
     * Abstract API                                                           *
     *                                                                        *
     *************************************************************************/

    /** {@inheritDoc} */
    @Override public InputMap&lt;C&gt; getInputMap() {
        return tableViewInputMap;
    }

    /**
     * Call to record the current anchor position
     */
    protected void setAnchor(TablePositionBase tp) {
        TableCellBehaviorBase.setAnchor(getNode(), tp, false);
        setSelectionPathDeviated(false);
    }

    /**
     * Will return the current anchor position.
     */
    protected TablePositionBase getAnchor() {
        return TableCellBehaviorBase.getAnchor(getNode(), getFocusedCell());
    }

    /**
     * Returns true if there is an anchor set, and false if not anchor is set.
     */
    protected boolean hasAnchor() {
        return TableCellBehaviorBase.hasNonDefaultAnchor(getNode());
    }

    /**
     * Returns the number of items in the underlying data model.
     */
    protected abstract int getItemCount();

    /**
     * Returns the focus model for the underlying UI control (which must extend
     * from TableFocusModel).
     */
    protected abstract TableFocusModel getFocusModel();

    /**
     * Returns the selection model for the underlying UI control (which must extend
     * from TableSelectionModel).
     */
    protected abstract TableSelectionModel&lt;T&gt; getSelectionModel();

    /**
     * Returns an observable list of all cells that are currently selected in
     * the selection model of the underlying control.
     */
    protected abstract ObservableList&lt;? extends TablePositionBase/*&lt;C,TC&gt;*/&gt; getSelectedCells();

    /**
     * Returns the focused cell from the focus model of the underlying control.
     */
    protected abstract TablePositionBase getFocusedCell();

    /**
     * Returns the position of the given table column in the visible leaf columns
     * list of the underlying control.
     */
    protected abstract int getVisibleLeafIndex(TableColumnBase tc);

    /**
     * Returns the column at the given index in the visible leaf columns list of
     * the underlying control.
     */
    protected abstract TableColumnBase getVisibleLeafColumn(int index);

    /**
     * Returns true if the control (i.e. TableView / TreeTableView) is editable
     */
    protected abstract boolean isControlEditable();

    /**
     * Begins the edit process in the underlying control for the given row/column
     * position.
     */
    protected abstract void editCell(int row, TableColumnBase tc);

    /**
     * Returns an observable list of all visible leaf columns in the underlying
     * control.
     */
    protected abstract ObservableList&lt;? extends TableColumnBase&gt; getVisibleLeafColumns();

    /**
     * Creates a TablePositionBase instance using the underlying controls
     * concrete implementation for the given row/column intersection.
     */
    protected abstract TablePositionBase&lt;TC&gt; getTablePosition(int row, TableColumnBase&lt;T,?&gt; tc);



    /**************************************************************************
     *                                                                        *
     * Public API                                                             *
     *                                                                        *
     *************************************************************************/

    /*
     * Anchor is created upon
     * - initial selection of an item (by mouse or keyboard)
     *
     * Anchor is changed when you
     * - move the selection to an item by UP/DOWN/LEFT/RIGHT arrow keys
     * - select an item by mouse click
     * - add/remove an item to/from an existing selection by CTRL+SPACE shortcut
     * - add/remove an items to/from an existing selection by CTRL+mouse click
     *
     * Note that if an item is removed from an existing selection by
     * CTRL+SPACE/CTRL+mouse click, anchor still remains on this item even
     * though it is not selected.
     *
     * Anchor is NOT changed when you
     * - create linear multi-selection by SHIFT+UP/DOWN/LEFT/RIGHT arrow keys
     * - create linear multi-selection by SHIFT+SPACE arrow keys
     * - create linear multi-selection by SHIFT+mouse click
     *
     * In case there is a discontinuous selection in the list, creating linear
     * multi-selection between anchor and focused item will cancel the
     * discontinuous selection. It means that only items that are located between
     * anchor and focused item will be selected.
     */
    protected void setAnchor(int row, TableColumnBase col) {
        setAnchor(row == -1 &amp;&amp; col == null ? null : getTablePosition(row, col));
    }

    private Callback&lt;Boolean, Integer&gt; onScrollPageUp;
    public void setOnScrollPageUp(Callback&lt;Boolean, Integer&gt; c) { onScrollPageUp = c; }

    private Callback&lt;Boolean, Integer&gt; onScrollPageDown;
    public void setOnScrollPageDown(Callback&lt;Boolean, Integer&gt; c) { onScrollPageDown = c; }

    private Runnable onFocusPreviousRow;
    public void setOnFocusPreviousRow(Runnable r) { onFocusPreviousRow = r; }

    private Runnable onFocusNextRow;
    public void setOnFocusNextRow(Runnable r) { onFocusNextRow = r; }

    private Runnable onSelectPreviousRow;
    public void setOnSelectPreviousRow(Runnable r) { onSelectPreviousRow = r; }

    private Runnable onSelectNextRow;
    public void setOnSelectNextRow(Runnable r) { onSelectNextRow = r; }

    private Runnable onMoveToFirstCell;
    public void setOnMoveToFirstCell(Runnable r) { onMoveToFirstCell = r; }

    private Runnable onMoveToLastCell;
    public void setOnMoveToLastCell(Runnable r) { onMoveToLastCell = r; }

    private Runnable onSelectRightCell;
    public void setOnSelectRightCell(Runnable r) { onSelectRightCell = r; }

    private Runnable onSelectLeftCell;
    public void setOnSelectLeftCell(Runnable r) { onSelectLeftCell = r; }

    public void mousePressed(MouseEvent e) {
//        // FIXME can't assume (yet) cells.get(0) is necessarily the lead cell
//        ObservableList&lt;? extends TablePositionBase&gt; cells = getSelectedCells();
//        setAnchor(cells.isEmpty() ? null : cells.get(0));

        if (!getNode().isFocused() &amp;&amp; getNode().isFocusTraversable()) {
            getNode().requestFocus();
        }
<A NAME="27"></A>    }

    protected boolean isRTL() {
        return (<FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#27',2,'match46-top.html#27',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getNode().getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT);
    }


    /**************************************************************************
     *                                                                        *
     * Private implementation                                                 *
     *                                                                        *
     *************************************************************************/

    private void setSelectionPathDeviated(boolean selectionPathDeviated) {
        this.selectionPathDeviated = selectionPathDeviated;
    }

    protected void scrollUp() {</B></FONT>
        TableSelectionModel&lt;T&gt; sm = getSelectionModel();
        if (sm == null || getSelectedCells().isEmpty()) return;

        TablePositionBase&lt;TC&gt; selectedCell = getSelectedCells().get(0);

        int newSelectedIndex = -1;
        if (onScrollPageUp != null) {
            newSelectedIndex = onScrollPageUp.call(false);
        }
        if (newSelectedIndex == -1) return;

        sm.clearAndSelect(newSelectedIndex, selectedCell.getTableColumn());
    }

    protected void scrollDown() {
        TableSelectionModel&lt;T&gt; sm = getSelectionModel();
        if (sm == null || getSelectedCells().isEmpty()) return;

        TablePositionBase&lt;TC&gt; selectedCell = getSelectedCells().get(0);

        int newSelectedIndex = -1;
        if (onScrollPageDown != null) {
            newSelectedIndex = onScrollPageDown.call(false);
        }
        if (newSelectedIndex == -1) return;

        sm.clearAndSelect(newSelectedIndex, selectedCell.getTableColumn());
    }

    protected void focusFirstRow() {
        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TableColumnBase tc = getFocusedCell() == null ? null : getFocusedCell().getTableColumn();
        fm.focus(0, tc);

        if (onMoveToFirstCell != null) onMoveToFirstCell.run();
    }

    protected void focusLastRow() {
        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TableColumnBase tc = getFocusedCell() == null ? null : getFocusedCell().getTableColumn();
        fm.focus(getItemCount() - 1, tc);

        if (onMoveToLastCell != null) onMoveToLastCell.run();
    }

    protected void focusPreviousRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        if (sm.isCellSelectionEnabled()) {
            fm.focusAboveCell();
        } else {
            fm.focusPrevious();
        }

        if (! isShortcutDown || getAnchor() == null) {
            setAnchor(fm.getFocusedIndex(), null);
        }

        if (onFocusPreviousRow != null) onFocusPreviousRow.run();
    }

    protected void focusNextRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        if (sm.isCellSelectionEnabled()) {
            fm.focusBelowCell();
        } else {
            fm.focusNext();
        }

        if (! isShortcutDown || getAnchor() == null) {
            setAnchor(fm.getFocusedIndex(), null);
        }

        if (onFocusNextRow != null) onFocusNextRow.run();
    }

    protected void focusLeftCell() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        fm.focusLeftCell();
        if (onFocusPreviousRow != null) onFocusPreviousRow.run();
    }

    protected void focusRightCell() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        fm.focusRightCell();
        if (onFocusNextRow != null) onFocusNextRow.run();
    }

    protected void focusPageUp() {
        int newFocusIndex = onScrollPageUp.call(true);

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;
        TableColumnBase tc = getFocusedCell() == null ? null : getFocusedCell().getTableColumn();
        fm.focus(newFocusIndex, tc);
    }

    protected void focusPageDown() {
        int newFocusIndex = onScrollPageDown.call(true);

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;
        TableColumnBase tc = getFocusedCell() == null ? null : getFocusedCell().getTableColumn();
        fm.focus(newFocusIndex, tc);
    }

    protected void clearSelection() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        sm.clearSelection();
    }

    protected void clearSelectionOutsideRange(int start, int end, TableColumnBase&lt;T,?&gt; column) {
        TableSelectionModel&lt;T&gt; sm = getSelectionModel();
        if (sm == null) return;

        int min = Math.min(start, end);
        int max = Math.max(start, end);

        List&lt;Integer&gt; indices = new ArrayList&lt;Integer&gt;(sm.getSelectedIndices());

        selectionChanging = true;
        for (int i = 0; i &lt; indices.size(); i++) {
            int index = indices.get(i);
            if (index &lt; min || index &gt; max) {
                sm.clearSelection(index, column);
            }
        }
        selectionChanging = false;
    }

    protected void alsoSelectPrevious() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        if (sm.getSelectionMode() == SelectionMode.SINGLE) {
            selectPreviousRow();
            return;
        }

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        if (sm.isCellSelectionEnabled()) {
            updateCellVerticalSelection(-1, () -&gt; {
                getSelectionModel().selectAboveCell();
            });
        } else {
            if (isShiftDown &amp;&amp; hasAnchor()) {
                updateRowSelection(-1);
            } else {
                sm.selectPrevious();
            }
        }
        onSelectPreviousRow.run();
    }

    protected void alsoSelectNext() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        if (sm.getSelectionMode() == SelectionMode.SINGLE) {
            selectNextRow();
            return;
        }

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        if (sm.isCellSelectionEnabled()) {
            updateCellVerticalSelection(1, () -&gt; {
                getSelectionModel().selectBelowCell();
            });
        } else {
            if (isShiftDown &amp;&amp; hasAnchor()) {
                updateRowSelection(1);
            } else {
                sm.selectNext();
            }
        }
        onSelectNextRow.run();
    }

    protected void alsoSelectLeftCell() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null || !sm.isCellSelectionEnabled()) return;

        updateCellHorizontalSelection(-1, () -&gt; getSelectionModel().selectLeftCell());
        onSelectLeftCell.run();
    }

    protected void alsoSelectRightCell() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null || !sm.isCellSelectionEnabled()) return;

        updateCellHorizontalSelection(1, () -&gt; getSelectionModel().selectRightCell());
        onSelectRightCell.run();
    }

    protected void updateRowSelection(int delta) {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null || sm.getSelectionMode() == SelectionMode.SINGLE) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int newRow = fm.getFocusedIndex() + delta;
        TablePositionBase anchor = getAnchor();

        if (! hasAnchor()) {
            setAnchor(getFocusedCell());
        }

        if (sm.getSelectedIndices().size() &gt; 1) {
            clearSelectionOutsideRange(anchor.getRow(), newRow, null);
        }

        if (anchor.getRow() &gt; newRow) {
            sm.selectRange(anchor.getRow(), newRow - 1);
        } else {
            sm.selectRange(anchor.getRow(), newRow + 1);
        }
    }

    protected void updateCellVerticalSelection(int delta, Runnable defaultAction) {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null || sm.getSelectionMode() == SelectionMode.SINGLE) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        final TablePositionBase focusedCell = getFocusedCell();
        final int focusedCellRow = focusedCell.getRow();

        if (isShiftDown &amp;&amp; sm.isSelected(focusedCellRow + delta, focusedCell.getTableColumn())) {
            int newFocusOwner = focusedCellRow + delta;

            // work out if we're backtracking
            boolean backtracking = false;
            if (selectionHistory.size() &gt;= 2) {
                TablePositionBase&lt;TC&gt; secondToLastSelectedCell = selectionHistory.get(1);
                backtracking = secondToLastSelectedCell.getRow() == newFocusOwner &amp;&amp;
                        secondToLastSelectedCell.getColumn() == focusedCell.getColumn();
            }

            // if the selection path has deviated from the anchor row / column, then we need to see if we're moving
            // backwards to the previous selection or not (as it determines what cell row we clear out)
            int cellRowToClear = selectionPathDeviated ?
                    (backtracking ? focusedCellRow : newFocusOwner) :
                    focusedCellRow;

            sm.clearSelection(cellRowToClear, focusedCell.getTableColumn());
            fm.focus(newFocusOwner, focusedCell.getTableColumn());
        } else if (isShiftDown &amp;&amp; getAnchor() != null &amp;&amp; ! selectionPathDeviated) {
            int newRow = fm.getFocusedIndex() + delta;

            // we don't let the newRow go outside the bounds of the data
            newRow = Math.max(Math.min(getItemCount() - 1, newRow), 0);

            int start = Math.min(getAnchor().getRow(), newRow);
            int end = Math.max(getAnchor().getRow(), newRow);

            if (sm.getSelectedIndices().size() &gt; 1) {
                clearSelectionOutsideRange(start, end, focusedCell.getTableColumn());
            }

            for (int _row = start; _row &lt;= end; _row++) {
                if (sm.isSelected(_row, focusedCell.getTableColumn())) {
                    continue;
                }
                sm.select(_row, focusedCell.getTableColumn());
            }
            fm.focus(newRow, focusedCell.getTableColumn());
        } else {
            final int focusIndex = fm.getFocusedIndex();
            if (! sm.isSelected(focusIndex, focusedCell.getTableColumn())) {
                sm.select(focusIndex, focusedCell.getTableColumn());
            }
            defaultAction.run();
        }
    }

    protected void updateCellHorizontalSelection(int delta, Runnable defaultAction) {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null || sm.getSelectionMode() == SelectionMode.SINGLE) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        final TablePositionBase focusedCell = getFocusedCell();
        if (focusedCell == null || focusedCell.getTableColumn() == null) return;

        boolean atEnd = false;
        TableColumnBase adjacentColumn = getColumn(focusedCell.getTableColumn(), delta);
        if (adjacentColumn == null) {
            // if adjacentColumn is null, we use the focusedCell column, as we are
            // most probably at the very beginning or end of the row
            adjacentColumn = focusedCell.getTableColumn();
            atEnd = true;
        }

        final int focusedCellRow = focusedCell.getRow();

        if (isShiftDown &amp;&amp; sm.isSelected(focusedCellRow, adjacentColumn)) {
            if (atEnd) {
                return;
            }

            // work out if we're backtracking
            boolean backtracking = false;
            ObservableList&lt;? extends TablePositionBase&gt; selectedCells = getSelectedCells();
            if (selectedCells.size() &gt;= 2) {
                TablePositionBase&lt;TC&gt; secondToLastSelectedCell = selectedCells.get(selectedCells.size() - 2);
                backtracking = secondToLastSelectedCell.getRow() == focusedCellRow &amp;&amp;
                        secondToLastSelectedCell.getTableColumn().equals(adjacentColumn);
            }

            // if the selection path has deviated from the anchor row / column, then we need to see if we're moving
            // backwards to the previous selection or not (as it determines what cell column we clear out)
            TableColumnBase&lt;?,?&gt; cellColumnToClear = selectionPathDeviated ?
                    (backtracking ? focusedCell.getTableColumn() : adjacentColumn) :
                    focusedCell.getTableColumn();

            sm.clearSelection(focusedCellRow, cellColumnToClear);
            fm.focus(focusedCellRow, adjacentColumn);
        } else if (isShiftDown &amp;&amp; getAnchor() != null &amp;&amp; ! selectionPathDeviated) {
            final int anchorColumn = getAnchor().getColumn();

            // we don't let the newColumn go outside the bounds of the data
            int newColumn = getVisibleLeafIndex(focusedCell.getTableColumn()) + delta;
            newColumn = Math.max(Math.min(getVisibleLeafColumns().size() - 1, newColumn), 0);

            int start = Math.min(anchorColumn, newColumn);
            int end = Math.max(anchorColumn, newColumn);

            for (int _col = start; _col &lt;= end; _col++) {
                sm.select(focusedCell.getRow(), getColumn(_col));
            }
            fm.focus(focusedCell.getRow(), getColumn(newColumn));
        } else {
            defaultAction.run();
        }
    }

    protected TableColumnBase getColumn(int index) {
        return getVisibleLeafColumn(index);
    }

    protected TableColumnBase getColumn(TableColumnBase tc, int delta) {
        return getVisibleLeafColumn(getVisibleLeafIndex(tc) + delta);
    }

    protected void selectFirstRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        ObservableList&lt;? extends TablePositionBase&gt; selection = getSelectedCells();
        TableColumnBase&lt;?,?&gt; selectedColumn = selection.size() == 0 ? null : selection.get(0).getTableColumn();
        sm.clearAndSelect(0, selectedColumn);

        if (onMoveToFirstCell != null) onMoveToFirstCell.run();
    }

    protected void selectLastRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        ObservableList&lt;? extends TablePositionBase&gt; selection = getSelectedCells();
        TableColumnBase&lt;?,?&gt; selectedColumn = selection.size() == 0 ? null : selection.get(0).getTableColumn();
        sm.clearAndSelect(getItemCount() - 1, selectedColumn);

        if (onMoveToLastCell != null) onMoveToLastCell.run();
    }

    protected void selectPreviousRow() {
        selectCell(-1, 0);
        if (onSelectPreviousRow != null) onSelectPreviousRow.run();
    }

    protected void selectNextRow() {
        selectCell(1, 0);
        if (onSelectNextRow != null) onSelectNextRow.run();
    }

    protected void selectLeftCell() {
        selectCell(0, -1);
        if (onSelectLeftCell != null) onSelectLeftCell.run();
    }

    protected void selectRightCell() {
        selectCell(0, 1);
        if (onSelectRightCell != null) onSelectRightCell.run();
    }

    protected void selectCell(int rowDiff, int columnDiff) {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TablePositionBase&lt;TC&gt; focusedCell = getFocusedCell();
        int currentRow = focusedCell.getRow();
        int currentColumn = getVisibleLeafIndex(focusedCell.getTableColumn());

        if (rowDiff &lt; 0 &amp;&amp; currentRow &lt;= 0) return;
        else if (rowDiff &gt; 0 &amp;&amp; currentRow &gt;= getItemCount() - 1) return;
        else if (columnDiff &lt; 0 &amp;&amp; currentColumn &lt;= 0) return;
        else if (columnDiff &gt; 0 &amp;&amp; currentColumn &gt;= getVisibleLeafColumns().size() - 1) return;
        else if (columnDiff &gt; 0 &amp;&amp; currentColumn == -1) return;

        TableColumnBase tc = focusedCell.getTableColumn();
        tc = getColumn(tc, columnDiff);

        int row = focusedCell.getRow() + rowDiff;
        sm.clearAndSelect(row, tc);
        setAnchor(row, tc);
    }

    protected void cancelEdit(KeyEvent e) {
        if (isControlEditable()) {
            editCell(-1, null);
            e.consume();
        }
    }

    protected void activate(KeyEvent e) {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TablePositionBase&lt;TC&gt; cell = getFocusedCell();
        sm.select(cell.getRow(), cell.getTableColumn());
        setAnchor(cell);

        // check if we are editable
        boolean isEditable = isControlEditable() &amp;&amp; cell.getTableColumn().isEditable();

        // edit this row also
        if (isEditable &amp;&amp; cell.getRow() &gt;= 0) {
            editCell(cell.getRow(), cell.getTableColumn());
            e.consume();
        }
    }

    protected void selectAllToFocus(boolean setAnchorToFocusIndex) {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TablePositionBase&lt;TC&gt; focusedCell = getFocusedCell();
        int focusRow = focusedCell.getRow();

        TablePositionBase&lt;TC&gt; anchor = getAnchor();
        int anchorRow = anchor.getRow();

        sm.clearSelection();
        if (! sm.isCellSelectionEnabled()) {
            int startPos = anchorRow;
            int endPos = anchorRow &gt; focusRow ? focusRow - 1 : focusRow + 1;
            sm.selectRange(startPos, endPos);
        } else {
            // we add all cells/rows between the current selection focus and
            // the anchor (inclusive) to the current selection.
            // We want focus to end up on the current focus position.
            sm.selectRange(anchor.getRow(), anchor.getTableColumn(),
                           focusedCell.getRow(), focusedCell.getTableColumn());
        }

        setAnchor(setAnchorToFocusIndex ? focusedCell : anchor);
    }

    protected void selectAll() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;
        sm.selectAll();
    }

    protected void selectAllToFirstRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        final boolean isSingleSelection = sm.getSelectionMode() == SelectionMode.SINGLE;
        final TablePositionBase focusedCell = getFocusedCell();
        final TableColumnBase&lt;?,?&gt; column = getFocusedCell().getTableColumn();
        int leadIndex = focusedCell.getRow();

        if (isShiftDown) {
            leadIndex = getAnchor() == null ? leadIndex : getAnchor().getRow();
        }

        sm.clearSelection();
        if (! sm.isCellSelectionEnabled()) {
            // we are going from 0 to one before the focused cell as that is
            // the requirement of selectRange, so we call focus on the 0th row
            if (isSingleSelection) {
                sm.select(0);
            } else {
                sm.selectRange(leadIndex, -1);
            }
            fm.focus(0);
        } else {
            if (isSingleSelection) {
                sm.select(0, column);
            } else {
                sm.selectRange(leadIndex, column, -1, column);
            }
            fm.focus(0, column);
        }

        if (isShiftDown) {
            setAnchor(leadIndex, column);
        }

        if (onMoveToFirstCell != null) onMoveToFirstCell.run();
    }

    protected void selectAllToLastRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        final int itemCount = getItemCount();
        final TablePositionBase focusedCell = getFocusedCell();
        final TableColumnBase&lt;?,?&gt; column = getFocusedCell().getTableColumn();
        int leadIndex = focusedCell.getRow();

        if (isShiftDown) {
            leadIndex = getAnchor() == null ? leadIndex : getAnchor().getRow();
        }

        sm.clearSelection();
        if (! sm.isCellSelectionEnabled()) {
            sm.selectRange(leadIndex, itemCount);
        } else {
            sm.selectRange(leadIndex, column, itemCount - 1, column);
        }

        if (isShiftDown) {
            setAnchor(leadIndex, column);
        }

        if (onMoveToLastCell != null) onMoveToLastCell.run();
    }

    protected void selectAllPageUp() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int leadIndex = fm.getFocusedIndex();
        final TableColumnBase col = sm.isCellSelectionEnabled() ? getFocusedCell().getTableColumn() : null;
        if (isShiftDown) {
            leadIndex = getAnchor() == null ? leadIndex : getAnchor().getRow();
            setAnchor(leadIndex, col);
        }

        int leadSelectedIndex = onScrollPageUp.call(false);

        selectionChanging = true;
        if (sm.getSelectionMode() == null || sm.getSelectionMode() == SelectionMode.SINGLE) {
            if (sm.isCellSelectionEnabled()) {
                sm.select(leadSelectedIndex, col);
            } else {
                sm.select(leadSelectedIndex);
            }
        } else {
            sm.clearSelection();
            if (sm.isCellSelectionEnabled()) {
                sm.selectRange(leadIndex, col, leadSelectedIndex, col);
            } else {
                // fix for RT-34407
                int adjust = leadIndex &lt; leadSelectedIndex ? 1 : -1;
                sm.selectRange(leadIndex, leadSelectedIndex + adjust);
            }
        }
        selectionChanging = false;
    }

    protected void selectAllPageDown() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int leadIndex = fm.getFocusedIndex();
        final TableColumnBase col = sm.isCellSelectionEnabled() ? getFocusedCell().getTableColumn() : null;
        if (isShiftDown) {
            leadIndex = getAnchor() == null ? leadIndex : getAnchor().getRow();
            setAnchor(leadIndex, col);
        }

        int leadSelectedIndex = onScrollPageDown.call(false);

        selectionChanging = true;
        if (sm.getSelectionMode() == null || sm.getSelectionMode() == SelectionMode.SINGLE) {
            if (sm.isCellSelectionEnabled()) {
                sm.select(leadSelectedIndex, col);
            } else {
                sm.select(leadSelectedIndex);
            }
        } else {
            sm.clearSelection();

            if (sm.isCellSelectionEnabled()) {
                sm.selectRange(leadIndex, col, leadSelectedIndex, col);
            } else {
                // fix for RT-34407
                int adjust = leadIndex &lt; leadSelectedIndex ? 1 : -1;
                sm.selectRange(leadIndex, leadSelectedIndex + adjust);
            }
        }
        selectionChanging = false;
    }

    protected void toggleFocusOwnerSelection() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TablePositionBase focusedCell = getFocusedCell();

        if (sm.isSelected(focusedCell.getRow(), focusedCell.getTableColumn())) {
            sm.clearSelection(focusedCell.getRow(), focusedCell.getTableColumn());
            fm.focus(focusedCell.getRow(), focusedCell.getTableColumn());
        } else {
            sm.select(focusedCell.getRow(), focusedCell.getTableColumn());
        }

        setAnchor(focusedCell.getRow(), focusedCell.getTableColumn());
    }

    // This functionality was added, but then removed when it was realised by
    // UX that TableView should not include 'spreadsheet-like' functionality.
    // When / if we ever introduce this kind of control, this functionality can
    // be re-enabled then.
    /*
    protected void moveToLeftMostColumn() {
        // Functionality as described in RT-12752
        if (onMoveToLeftMostColumn != null) onMoveToLeftMostColumn.run();

        TableSelectionModel sm = getSelectionModel();
        if (sm == null || ! sm.isCellSelectionEnabled()) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TablePosition focusedCell = fm.getFocusedCell();

        TableColumn endColumn = getNode().getVisibleLeafColumn(0);
        sm.clearAndSelect(focusedCell.getRow(), endColumn);
    }

    protected void moveToRightMostColumn() {
        // Functionality as described in RT-12752
        if (onMoveToRightMostColumn != null) onMoveToRightMostColumn.run();

        TableSelectionModel sm = getSelectionModel();
        if (sm == null || ! sm.isCellSelectionEnabled()) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TablePosition focusedCell = fm.getFocusedCell();

        TableColumn endColumn = getNode().getVisibleLeafColumn(getNode().getVisibleLeafColumns().size() - 1);
        sm.clearAndSelect(focusedCell.getRow(), endColumn);
    }
     */


    /**************************************************************************
     * Discontinuous Selection                                                *
     *************************************************************************/

    protected void discontinuousSelectPreviousRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        if (sm.getSelectionMode() != SelectionMode.MULTIPLE) {
            selectPreviousRow();
            return;
        }

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int focusIndex = fm.getFocusedIndex();
        final int newFocusIndex = focusIndex - 1;
        if (newFocusIndex &lt; 0) return;

        int startIndex = focusIndex;
        final TableColumnBase col = sm.isCellSelectionEnabled() ? getFocusedCell().getTableColumn() : null;
        if (isShiftDown) {
            startIndex = getAnchor() == null ? focusIndex : getAnchor().getRow();
        }

        if (! sm.isCellSelectionEnabled()) {
            sm.selectRange(newFocusIndex, startIndex + 1);
            fm.focus(newFocusIndex);
        } else {
            for (int i = newFocusIndex; i &lt; startIndex + 1; i++) {
                sm.select(i, col);
            }
            fm.focus(newFocusIndex, col);
        }

        if (onFocusPreviousRow != null) onFocusPreviousRow.run();
    }

    protected void discontinuousSelectNextRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        if (sm.getSelectionMode() != SelectionMode.MULTIPLE) {
            selectNextRow();
            return;
        }

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int focusIndex = fm.getFocusedIndex();
        final int newFocusIndex = focusIndex + 1;
        if (newFocusIndex &gt;= getItemCount()) return;

        int startIndex = focusIndex;
        final TableColumnBase col = sm.isCellSelectionEnabled() ? getFocusedCell().getTableColumn() : null;
        if (isShiftDown) {
            startIndex = getAnchor() == null ? focusIndex : getAnchor().getRow();
        }

        if (! sm.isCellSelectionEnabled()) {
            sm.selectRange(startIndex, newFocusIndex + 1);
            fm.focus(newFocusIndex);
        } else {
            for (int i = startIndex; i &lt; newFocusIndex + 1; i++) {
                sm.select(i, col);
            }
            fm.focus(newFocusIndex, col);
        }

        if (onFocusNextRow != null) onFocusNextRow.run();
    }

    protected void discontinuousSelectPreviousColumn() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null || ! sm.isCellSelectionEnabled()) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TableColumnBase tc = getColumn(getFocusedCell().getTableColumn(), -1);
        sm.select(fm.getFocusedIndex(), tc);
    }

    protected void discontinuousSelectNextColumn() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null || ! sm.isCellSelectionEnabled()) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        TableColumnBase tc = getColumn(getFocusedCell().getTableColumn(), 1);
        sm.select(fm.getFocusedIndex(), tc);
    }

    protected void discontinuousSelectPageUp() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int anchor = hasAnchor() ? getAnchor().getRow() : fm.getFocusedIndex();
        int leadSelectedIndex = onScrollPageUp.call(false);

        if (! sm.isCellSelectionEnabled()) {
            sm.selectRange(anchor, leadSelectedIndex - 1);
        }
    }

    protected void discontinuousSelectPageDown() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int anchor = hasAnchor() ? getAnchor().getRow() : fm.getFocusedIndex();
        int leadSelectedIndex = onScrollPageDown.call(false);

        if (! sm.isCellSelectionEnabled()) {
            sm.selectRange(anchor, leadSelectedIndex + 1);
        }
    }

    protected void discontinuousSelectAllToFirstRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int index = fm.getFocusedIndex();

        if (! sm.isCellSelectionEnabled()) {
            sm.selectRange(0, index);
            fm.focus(0);
        } else {
            for (int i = 0; i &lt; index; i++) {
                sm.select(i, getFocusedCell().getTableColumn());
            }
            fm.focus(0, getFocusedCell().getTableColumn());
        }

        if (onMoveToFirstCell != null) onMoveToFirstCell.run();
    }

    protected void discontinuousSelectAllToLastRow() {
        TableSelectionModel sm = getSelectionModel();
        if (sm == null) return;

        TableFocusModel fm = getFocusModel();
        if (fm == null) return;

        int index = fm.getFocusedIndex() + 1;

        if (! sm.isCellSelectionEnabled()) {
            sm.selectRange(index, getItemCount());
        } else {
            for (int i = index; i &lt; getItemCount(); i++) {
                sm.select(i, getFocusedCell().getTableColumn());
            }
        }

        if (onMoveToLastCell != null) onMoveToLastCell.run();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/TextAreaBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.PlatformUtil;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.scene.control.Properties;
import javafx.scene.control.skin.TextAreaSkin;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.scene.Scene;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.TextArea;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.scene.input.ContextMenuEvent;
import com.sun.javafx.scene.control.inputmap.InputMap;
import com.sun.javafx.scene.control.inputmap.KeyBinding;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.text.HitInfo;
import javafx.stage.Screen;
import javafx.stage.Window;

import java.util.function.Predicate;

import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;
import com.sun.javafx.stage.WindowHelper;
import static javafx.scene.control.skin.TextInputControlSkin.TextUnit;
import static javafx.scene.control.skin.TextInputControlSkin.Direction;
import static javafx.scene.input.KeyCode.*;


/**
 * Text area behavior.
 */
public class TextAreaBehavior extends TextInputControlBehavior&lt;TextArea&gt; {
    private TextAreaSkin skin;
    private TwoLevelFocusBehavior tlFocus;

    /**************************************************************************
     * Constructors                                                           *
     *************************************************************************/

    public TextAreaBehavior(final TextArea c) {
        super(c);

        if (Properties.IS_TOUCH_SUPPORTED) {
            contextMenu.getStyleClass().add(&quot;text-input-context-menu&quot;);
        }

        // some of the mappings are only valid when the control is editable, or
        // only on certain platforms, so we create the following predicates that filters out the mapping when the
        // control is not in the correct state / on the correct platform
        final Predicate&lt;KeyEvent&gt; validWhenEditable = e -&gt; !c.isEditable();

        // Add these bindings as a child input map, so they take precedence
        InputMap&lt;TextArea&gt; textAreaInputMap = new InputMap&lt;&gt;(c);
        textAreaInputMap.getMappings().addAll(
            keyMapping(HOME,      e -&gt; lineStart(false)),
            keyMapping(END,       e -&gt; lineEnd(false)),
            keyMapping(UP,        e -&gt; skin.moveCaret(TextUnit.LINE, Direction.UP,   false)),
            keyMapping(DOWN,      e -&gt; skin.moveCaret(TextUnit.LINE, Direction.DOWN, false)),
            keyMapping(PAGE_UP,   e -&gt; skin.moveCaret(TextUnit.PAGE, Direction.UP,   false)),
            keyMapping(PAGE_DOWN, e -&gt; skin.moveCaret(TextUnit.PAGE, Direction.DOWN, false)),

            keyMapping(new KeyBinding(HOME).shift(),      e -&gt; lineStart(true)),
            keyMapping(new KeyBinding(END).shift(),       e -&gt; lineEnd(true)),
            keyMapping(new KeyBinding(UP).shift(),        e -&gt; skin.moveCaret(TextUnit.LINE, Direction.UP,   true)),
            keyMapping(new KeyBinding(DOWN).shift(),      e -&gt; skin.moveCaret(TextUnit.LINE, Direction.DOWN, true)),
            keyMapping(new KeyBinding(PAGE_UP).shift(),   e -&gt; skin.moveCaret(TextUnit.PAGE, Direction.UP,   true)),
            keyMapping(new KeyBinding(PAGE_DOWN).shift(), e -&gt; skin.moveCaret(TextUnit.PAGE, Direction.DOWN, true)),

            // editing-only mappings
            keyMapping(new KeyBinding(ENTER), e -&gt; insertNewLine(), validWhenEditable),
            keyMapping(new KeyBinding(TAB), e -&gt; insertTab(), validWhenEditable)
        );
        addDefaultChildMap(getInputMap(), textAreaInputMap);

        // mac os specific mappings
        InputMap&lt;TextArea&gt; macOsInputMap = new InputMap&lt;&gt;(c);
        macOsInputMap.setInterceptor(e -&gt; !PlatformUtil.isMac());
        macOsInputMap.getMappings().addAll(
            // Mac OS specific mappings
            keyMapping(new KeyBinding(LEFT).shortcut(),  e -&gt; lineStart(false)),
            keyMapping(new KeyBinding(RIGHT).shortcut(), e -&gt; lineEnd(false)),
            keyMapping(new KeyBinding(UP).shortcut(),    e -&gt; c.home()),
            keyMapping(new KeyBinding(DOWN).shortcut(),  e -&gt; c.end()),

            keyMapping(new KeyBinding(LEFT).shortcut().shift(),  e -&gt; lineStart(true)),
            keyMapping(new KeyBinding(RIGHT).shortcut().shift(), e -&gt; lineEnd(true)),
            keyMapping(new KeyBinding(UP).shortcut().shift(),    e -&gt; selectHomeExtend()),
            keyMapping(new KeyBinding(DOWN).shortcut().shift(),  e -&gt; selectEndExtend()),

            keyMapping(new KeyBinding(UP).alt(),           e -&gt; skin.moveCaret(TextUnit.PARAGRAPH, Direction.UP,   false)),
            keyMapping(new KeyBinding(DOWN).alt(),         e -&gt; skin.moveCaret(TextUnit.PARAGRAPH, Direction.DOWN, false)),
            keyMapping(new KeyBinding(UP).alt().shift(),   e -&gt; skin.moveCaret(TextUnit.PARAGRAPH, Direction.UP,   true)),
            keyMapping(new KeyBinding(DOWN).alt().shift(), e -&gt; skin.moveCaret(TextUnit.PARAGRAPH, Direction.DOWN, true))
        );
        addDefaultChildMap(textAreaInputMap, macOsInputMap);

        // windows / linux specific mappings
        InputMap&lt;TextArea&gt; nonMacOsInputMap = new InputMap&lt;&gt;(c);
        nonMacOsInputMap.setInterceptor(e -&gt; PlatformUtil.isMac());
        nonMacOsInputMap.getMappings().addAll(
            keyMapping(new KeyBinding(UP).ctrl(),           e -&gt; skin.moveCaret(TextUnit.PARAGRAPH, Direction.UP,   false)),
            keyMapping(new KeyBinding(DOWN).ctrl(),         e -&gt; skin.moveCaret(TextUnit.PARAGRAPH, Direction.DOWN, false)),
            keyMapping(new KeyBinding(UP).ctrl().shift(),   e -&gt; skin.moveCaret(TextUnit.PARAGRAPH, Direction.UP,   true)),
            keyMapping(new KeyBinding(DOWN).ctrl().shift(), e -&gt; skin.moveCaret(TextUnit.PARAGRAPH, Direction.DOWN, true))
        );
        addDefaultChildMap(textAreaInputMap, nonMacOsInputMap);

        addKeyPadMappings(textAreaInputMap);

        // Register for change events
        c.focusedProperty().addListener(new ChangeListener&lt;Boolean&gt;() {
            @Override
            public void changed(ObservableValue&lt;? extends Boolean&gt; observable, Boolean oldValue, Boolean newValue) {
                // NOTE: The code in this method is *almost* and exact copy of what is in TextFieldBehavior.
                // The only real difference is that TextFieldBehavior selects all the text when the control
                // receives focus (when not gained by mouse click), whereas TextArea doesn't, and also the
                // TextArea doesn't lose selection on focus lost, whereas the TextField does.
                final TextArea textArea = getNode();
                if (textArea.isFocused()) {
                    if (PlatformUtil.isIOS()) {
                        // Special handling of focus on iOS is required to allow to
                        // control native keyboard, because native keyboard is popped-up only when native
                        // text component gets focus. When we have JFX keyboard we can remove this code
                        final Bounds bounds = textArea.getBoundsInParent();
                        double w = bounds.getWidth();
                        double h = bounds.getHeight();
                        Affine3D trans = TextFieldBehavior.calculateNodeToSceneTransform(textArea);
                        String text = textArea.textProperty().getValueSafe();

                        // we need to display native text input component on the place where JFX component is drawn
                        // all parameters needed to do that are passed to native impl. here
                        WindowHelper.getPeer(textArea.getScene().getWindow()).requestInput(
                                text, TextFieldBehavior.TextInputTypes.TEXT_AREA.ordinal(), w, h,
                                trans.getMxx(), trans.getMxy(), trans.getMxz(), trans.getMxt(),
                                trans.getMyx(), trans.getMyy(), trans.getMyz(), trans.getMyt(),
                                trans.getMzx(), trans.getMzy(), trans.getMzz(), trans.getMzt());
                    }
                    if (!focusGainedByMouseClick) {
                        setCaretAnimating(true);
                    }
                } else {
//                    skin.hideCaret();
                    if (PlatformUtil.isIOS() &amp;&amp; textArea.getScene() != null) {
                        // releasing the focus =&gt; we need to hide the native component and also native keyboard
                        WindowHelper.getPeer(textArea.getScene().getWindow()).releaseInput();
                    }
                    focusGainedByMouseClick = false;
                    setCaretAnimating(false);
                }
            }
        });

        // Only add this if we're on an embedded platform that supports 5-button navigation
        if (Utils.isTwoLevelFocus()) {
            tlFocus = new TwoLevelFocusBehavior(c); // needs to be last.
        }
    }
<A NAME="37"></A>
    @Override public void dispose() {
        if (tlFocus != null) tlFocus.dispose();
        <FONT color="#810541"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#37',2,'match46-top.html#37',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>super.dispose();
    }

    // An unholy back-reference!
    public void setTextAreaSkin(TextAreaSkin skin) {
        this.skin = skin;
    }

    private void insertNewLine() {
        setEditing(true);
        getNode().replaceSelection</B></FONT>(&quot;\n&quot;);
        setEditing(false);
    }

    private void insertTab() {
        setEditing(true);
        getNode().replaceSelection(&quot;\t&quot;);
        setEditing(false);
    }

    @Override protected void deleteChar(boolean previous) {
        if (previous) {
            getNode().deletePreviousChar();
        } else {
            getNode().deleteNextChar();
        }
    }

    @Override protected void deleteFromLineStart() {
        TextArea textArea = getNode();
        int end = textArea.getCaretPosition();

        if (end &gt; 0) {
            lineStart(false);
            int start = textArea.getCaretPosition();
            if (end &gt; start) {
                replaceText(start, end, &quot;&quot;);
            }
        }
    }

    private void lineStart(boolean select) {
        skin.moveCaret(TextUnit.LINE, Direction.BEGINNING, select);
    }

    private void lineEnd(boolean select) {
        skin.moveCaret(TextUnit.LINE, Direction.END, select);
    }

    @Override protected void replaceText(int start, int end, String txt) {
        getNode().replaceText(start, end, txt);
    }

    /**
     * If the focus is gained via response to a mouse click, then we don't
     * want to select all the text even if selectOnFocus is true.
     */
    private boolean focusGainedByMouseClick = false; // TODO!!
    private boolean shiftDown = false;
    private boolean deferClick = false;

    @Override public void mousePressed(MouseEvent e) {
        TextArea textArea = getNode();
        // We never respond to events if disabled
        if (!textArea.isDisabled()) {
            // If the text field doesn't have focus, then we'll attempt to set
            // the focus and we'll indicate that we gained focus by a mouse
            // click, TODO which will then NOT honor the selectOnFocus variable
            // of the textInputControl
            if (!textArea.isFocused()) {
                focusGainedByMouseClick = true;
                textArea.requestFocus();
            }

            // stop the caret animation
            setCaretAnimating(false);
            // only if there is no selection should we see the caret
//            setCaretOpacity(if (textInputControl.dot == textInputControl.mark) then 1.0 else 0.0);

            // if the primary button was pressed
            if (e.getButton() == MouseButton.PRIMARY &amp;&amp; !(e.isMiddleButtonDown() || e.isSecondaryButtonDown())) {
                HitInfo hit = skin.getIndex(e.getX(), e.getY());
                int i = hit.getInsertionIndex();
                final int anchor = textArea.getAnchor();
                final int caretPosition = textArea.getCaretPosition();
                if (e.getClickCount() &lt; 2 &amp;&amp;
                    (e.isSynthesized() ||
                     (anchor != caretPosition &amp;&amp;
                      ((i &gt; anchor &amp;&amp; i &lt; caretPosition) || (i &lt; anchor &amp;&amp; i &gt; caretPosition))))) {
                    // if there is a selection, then we will NOT handle the
                    // press now, but will defer until the release. If you
                    // select some text and then press down, we change the
                    // caret and wait to allow you to drag the text (TODO).
                    // When the drag concludes, then we handle the click

                    deferClick = true;
                    // TODO start a timer such that after some millis we
                    // switch into text dragging mode, change the cursor
                    // to indicate the text can be dragged, etc.
                } else if (!(e.isControlDown() || e.isAltDown() || e.isShiftDown() || e.isMetaDown() || e.isShortcutDown())) {
                    switch (e.getClickCount()) {
                        case 1: skin.positionCaret(hit, false); break;
                        case 2: mouseDoubleClick(hit); break;
                        case 3: mouseTripleClick(hit); break;
                        default: // no-op
                    }
                } else if (e.isShiftDown() &amp;&amp; !(e.isControlDown() || e.isAltDown() || e.isMetaDown() || e.isShortcutDown()) &amp;&amp; e.getClickCount() == 1) {
                    // didn't click inside the selection, so select
                    shiftDown = true;
                    // if we are on mac os, then we will accumulate the
                    // selection instead of just moving the dot. This happens
                    // by figuring out past which (dot/mark) are extending the
                    // selection, and set the mark to be the other side and
                    // the dot to be the new position.
                    // everywhere else we just move the dot.
                    if (isMac()) {
                        textArea.extendSelection(i);
                    } else {
                        skin.positionCaret(hit, true);
                    }
                }
//                 skin.setForwardBias(hit.isLeading());
//                if (textInputControl.editable)
//                    displaySoftwareKeyboard(true);
            }
            if (contextMenu.isShowing()) {
                contextMenu.hide();
            }
        }
    }

    @Override public void mouseDragged(MouseEvent e) {
        final TextArea textArea = getNode();
        // we never respond to events if disabled, but we do notify any onXXX
        // event listeners on the control
        if (!textArea.isDisabled() &amp;&amp; !e.isSynthesized()) {
            if (e.getButton() == MouseButton.PRIMARY &amp;&amp;
                    !(e.isMiddleButtonDown() || e.isSecondaryButtonDown() ||
                            e.isControlDown() || e.isAltDown() || e.isShiftDown() || e.isMetaDown())) {
                skin.positionCaret(skin.getIndex(e.getX(), e.getY()), true);
            }
        }
        deferClick = false;
    }

    @Override public void mouseReleased(final MouseEvent e) {
        final TextArea textArea = getNode();
        // we never respond to events if disabled, but we do notify any onXXX
        // event listeners on the control
        if (!textArea.isDisabled()) {
            setCaretAnimating(false);
            if (deferClick) {
                deferClick = false;
                skin.positionCaret(skin.getIndex(e.getX(), e.getY()), shiftDown);
                shiftDown = false;
            }
            setCaretAnimating(true);
        }
    }

    @Override public void contextMenuRequested(ContextMenuEvent e) {
        final TextArea textArea = getNode();

        if (contextMenu.isShowing()) {
            contextMenu.hide();
        } else if (textArea.getContextMenu() == null &amp;&amp;
                   textArea.getOnContextMenuRequested() == null) {
            double screenX = e.getScreenX();
            double screenY = e.getScreenY();
            double sceneX = e.getSceneX();

            if (Properties.IS_TOUCH_SUPPORTED) {
                Point2D menuPos;
                if (textArea.getSelection().getLength() == 0) {
                    skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false);
                    menuPos = skin.getMenuPosition();
                } else {
                    menuPos = skin.getMenuPosition();
                    if (menuPos != null &amp;&amp; (menuPos.getX() &lt;= 0 || menuPos.getY() &lt;= 0)) {
                        skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false);
                        menuPos = skin.getMenuPosition();
                    }
                }

                if (menuPos != null) {
                    Point2D p = getNode().localToScene(menuPos);
                    Scene scene = getNode().getScene();
                    Window window = scene.getWindow();
                    Point2D location = new Point2D(window.getX() + scene.getX() + p.getX(),
                                                   window.getY() + scene.getY() + p.getY());
                    screenX = location.getX();
                    sceneX = p.getX();
                    screenY = location.getY();
                }
            }

            populateContextMenu();
            double menuWidth = contextMenu.prefWidth(-1);
            double menuX = screenX - (Properties.IS_TOUCH_SUPPORTED ? (menuWidth / 2) : 0);
            Screen currentScreen = com.sun.javafx.util.Utils.getScreenForPoint(screenX, 0);
            Rectangle2D bounds = currentScreen.getBounds();

            if (menuX &lt; bounds.getMinX()) {
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, screenX);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, sceneX);
                contextMenu.show(getNode(), bounds.getMinX(), screenY);
            } else if (screenX + menuWidth &gt; bounds.getMaxX()) {
                double leftOver = menuWidth - ( bounds.getMaxX() - screenX);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, screenX);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, sceneX);
                contextMenu.show(getNode(), screenX - leftOver, screenY);
            } else {
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, 0);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, 0);
                contextMenu.show(getNode(), menuX, screenY);
            }
        }

        e.consume();
    }

    @Override protected void setCaretAnimating(boolean play) {
        skin.setCaretAnimating(play);
    }

    protected void mouseDoubleClick(HitInfo hit) {
        final TextArea textArea = getNode();
        textArea.previousWord();
        if (isWindows()) {
            textArea.selectNextWord();
        } else {
            textArea.selectEndOfNextWord();
        }
    }

    protected void mouseTripleClick(HitInfo hit) {
        // select the line
        skin.moveCaret(TextUnit.PARAGRAPH, Direction.BEGINNING, false);
        skin.moveCaret(TextUnit.PARAGRAPH, Direction.END, true);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/Accordion.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import javafx.beans.property.ObjectProperty;
<A NAME="30"></A>import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;

<FONT color="#f9966b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#30',2,'match46-top.html#30',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import com.sun.javafx.collections.TrackableObservableList;
import javafx.geometry.Orientation;
import javafx.scene.Node;
import javafx.scene.control.skin.AccordionSkin;

import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.value.WritableValue;
import javafx.css.StyleableProperty;

import java.util.List;

/**
 * &lt;p&gt;An accordion is a group of {@link TitledPane TitlePanes}.  Only one TitledPane can be opened at
 * a time.&lt;/p&gt;
 *
 * &lt;p&gt;The {@link TitledPane} content in an accordion can be any {@link javafx.scene.Node} such as UI controls or groups
 * of nodes added to a layout container.&lt;/p&gt;
 *
 * &lt;p&gt;It is not recommended to set the MinHeight, PrefHeight, or MaxHeight
 * for this control.  Unexpected behavior will occur because the
 * Accordion's height changes when a TitledPane is opened or closed.&lt;/p&gt;
 *
 * &lt;p&gt;
 * Accordion sets focusTraversable to false.
 * &lt;/p&gt;
 *
 * &lt;p&gt;Example:
 * &lt;pre&gt;&lt;code&gt;
 * TitledPane t1 = new TitledPane(&quot;T1&quot;, new Button(&quot;B1&quot;));
 * TitledPane t2 = new TitledPane(&quot;T2&quot;, new Button(&quot;B2&quot;));
 * TitledPane t3 = new TitledPane(&quot;T3&quot;, new Button(&quot;B3&quot;));
 * Accordion accordion = new Accordion();
 * accordion.getPanes().addAll(t1, t2, t3);&lt;/code&gt;&lt;/pre&gt;
 * @since JavaFX 2.0
 */
public class Accordion extends Control {
    private boolean biasDirty = true;
    private Orientation bias;

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new Accordion with no TitledPanes.
     */
    public Accordion() {
        this((TitledPane[])null);
    }

    /**
     * Creates a new Accordion with the given TitledPanes showing within it.
     *
     * @param titledPanes The TitledPanes to show inside the Accordion.
     * @since JavaFX 8u40
     */
    public</B></FONT> Accordion(TitledPane... titledPanes) {
        getStyleClass().setAll(DEFAULT_STYLE_CLASS);

        if (titledPanes != null) {
            getPanes().addAll(titledPanes);
        }

        // focusTraversable is styleable through css. Calling setFocusTraversable
        // makes it look to css like the user set the value and css will not
        // override. Initializing focusTraversable by calling applyStyle with null
        // StyleOrigin ensures that css will be able to override the value.
        ((StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)focusTraversableProperty()).applyStyle(null, Boolean.FALSE);
    }

    /***************************************************************************
     *                                                                         *
     * Instance Variables                                                      *
     *                                                                         *
     **************************************************************************/

    // The ObservableList of TitlePanes to use in this Accordion.
    private final ObservableList&lt;TitledPane&gt; panes = new TrackableObservableList&lt;TitledPane&gt;() {
        @Override protected void onChanged(ListChangeListener.Change&lt;TitledPane&gt; c) {
            // If one of the removed panes was the expandedPane, then clear
            // the expandedPane property. This can only be done if expandedPane
            // is not bound (if it is bound, we just have to accept the
            // potential error condition and allow the skin to handle it).
            while (c.next()) {
                if (c.wasRemoved() &amp;&amp; !expandedPane.isBound()) {
                    for (TitledPane pane : c.getRemoved()) {
                        if (!c.getAddedSubList().contains(pane) &amp;&amp; getExpandedPane() == pane) {
                            setExpandedPane(null);
                            break; // There can be only one, so no point continuing iteration
                        }
                    }
                }
            }
        }
    };

    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- Expanded Pane
    private ObjectProperty&lt;TitledPane&gt; expandedPane = new ObjectPropertyBase&lt;TitledPane&gt;() {

        private TitledPane oldValue;

        @Override
        protected void invalidated() {
            final TitledPane value = get();
            if (value != null) {
                value.setExpanded(true);
            } else {
                if (oldValue != null) {
                    oldValue.setExpanded(false);
                }
            }
            oldValue = value;
        }

        @Override
        public String getName() {
            return &quot;expandedPane&quot;;
        }

        @Override
        public Object getBean() {
            return Accordion.this;
        }

    };

    /**
     * &lt;p&gt;The expanded {@link TitledPane} that is currently visible. While it is technically
     * possible to set the expanded pane to a value that is not in {@link #getPanes},
     * doing so will be treated by the skin as if expandedPane is null. If a pane
     * is set as the expanded pane, and is subsequently removed from {@link #getPanes},
     * then expanded pane will be set to null, if possible. (This will not be possible
     * if you have manually bound the expanded pane to some value, for example).
     * &lt;/p&gt;
     * @param value the expanded {@link TitledPane}
     */
    public final void setExpandedPane(TitledPane value) { expandedPaneProperty().set(value); }

    /**
     * Gets the expanded TitledPane in the Accordion.  If the expanded pane has been
     * removed or there is no expanded TitledPane {@code null} is returned.
     *
     * @return The expanded TitledPane in the Accordion.
     */
    public final TitledPane getExpandedPane() { return expandedPane.get(); }

    /**
     * The expanded TitledPane in the Accordion.
     *
     * @return The expanded TitledPane in the Accordion.
     */
    public final ObjectProperty&lt;TitledPane&gt; expandedPaneProperty() { return expandedPane; }

    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Gets the list of {@link TitledPane} in this Accordion.  Changing this ObservableList
     * will immediately result in the Accordion updating to display
     * the new contents of this ObservableList.
     *
     * @return The list of TitledPane in this Accordion.
     */
    public final ObservableList&lt;TitledPane&gt; getPanes() { return panes; }

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new AccordionSkin(this);
    }

    /** {@inheritDoc} */
    @Override public void requestLayout() {
        biasDirty = true;
        bias = null;
        super.requestLayout();
    }

    /** {@inheritDoc} */
    @Override public Orientation getContentBias() {
        if (biasDirty) {
            bias = null;
            final List&lt;Node&gt; children = getManagedChildren();
            for (Node child : children) {
                Orientation contentBias = child.getContentBias();
                if (contentBias != null) {
                    bias = contentBias;
                    if (contentBias == Orientation.HORIZONTAL) {
                        break;
                    }
                }
            }
            biasDirty = false;
        }
        return bias;
    }

    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;accordion&quot;;

    /**
     * Returns the initial focus traversable state of this control, for use
     * by the JavaFX CSS engine to correctly set its initial value. This method
     * is overridden as by default UI controls have focus traversable set to true,
     * but that is not appropriate for this control.
     *
     * @since 9
     */
    @Override protected Boolean getInitialFocusTraversable() {
        return Boolean.FALSE;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/ButtonBase.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import javafx.css.PseudoClass;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.AccessibleAction;
import javafx.scene.Node;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyBooleanWrapper;

/**
 * Base class for button-like UI Controls, including Hyperlinks, Buttons,
 * ToggleButtons, CheckBoxes, and RadioButtons. The primary contribution of
 * ButtonBase is providing a consistent API for handling the concept of button
 * &quot;arming&quot;. In UIs, a button will typically only &quot;fire&quot; if some user gesture
 * occurs while the button is &quot;armed&quot;. For example, a Button may be armed if
 * the mouse is pressed and the Button is enabled and the mouse is over the
 * button. In such a situation, if the mouse is then released, then the Button
 * is &quot;fired&quot;, meaning its action takes place.
 * @since JavaFX 2.0
 */

public abstract class ButtonBase extends Labeled {

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Create a default ButtonBase with empty text.
     */
    public ButtonBase() { }

    /**
     * Create a ButtonBase with the given text.
     * @param text null text is treated as the empty string
     */
    public ButtonBase(String text) {
        super(text);
    }

    /**
     * Create a ButtonBase with the given text and graphic.
     * @param text null text is treated as the empty string
     * @param graphic a null graphic is acceptable
<A NAME="25"></A>     */
    public ButtonBase(String text, Node graphic) {
        super(text, graphic);
    <FONT color="#87f717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#25',2,'match46-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}


    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Indicates that the button has been &quot;armed&quot; such that a mouse release
     * will cause the button's action to be invoked. This is subtly different
     * from pressed. Pressed indicates that the mouse has been
     * pressed on a Node and has not yet been released. {@code arm} however
     * also takes into account whether the mouse is actually over the
     * button and pressed.
     * @return the property to indicate that the button has been &quot;armed&quot;
     */
    public final ReadOnlyBooleanProperty armedProperty() { return armed.getReadOnlyProperty(); }
    private void setArmed(boolean value) { armed.set(value); }
    public final boolean isArmed() { return armedProperty().get(); }</B></FONT>
    private ReadOnlyBooleanWrapper armed = new ReadOnlyBooleanWrapper() {
        @Override protected void invalidated() {
            pseudoClassStateChanged(ARMED_PSEUDOCLASS_STATE, get());
        }

        @Override
        public Object getBean() {
            return ButtonBase.this;
        }

        @Override
        public String getName() {
            return &quot;armed&quot;;
        }
    };

    /**
     * The button's action, which is invoked whenever the button is fired. This
     * may be due to the user clicking on the button with the mouse, or by
     * a touch event, or by a key press, or if the developer programmatically
     * invokes the {@link #fire()} method.
     * @return the property to represent the button's action, which is invoked
     * whenever the button is fired
     */
    public final ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onActionProperty() { return onAction; }
    public final void setOnAction(EventHandler&lt;ActionEvent&gt; value) { onActionProperty().set(value); }
    public final EventHandler&lt;ActionEvent&gt; getOnAction() { return onActionProperty().get(); }
    private ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onAction = new ObjectPropertyBase&lt;EventHandler&lt;ActionEvent&gt;&gt;() {
        @Override protected void invalidated() {
            setEventHandler(ActionEvent.ACTION, get());
        }

        @Override
        public Object getBean() {
            return ButtonBase.this;
        }

        @Override
        public String getName() {
            return &quot;onAction&quot;;
        }
    };


    /***************************************************************************
     *                                                                         *
     * Methods                                                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Arms the button. An armed button will fire an action (whether that be
     * the action of a {@link Button} or toggling selection on a
     * {@link CheckBox} or some other behavior) on the next expected UI
     * gesture.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins or Behaviors. It is not common
     *       for developers or designers to access this function directly.
     */
    public void arm() {
        setArmed(true);
    }

    /**
     * Disarms the button. See {@link #arm()}.
     *
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins or Behaviors. It is not common
     *       for developers or designers to access this function directly.
     */
    public void disarm() {
        setArmed(false);
    }

    /**
     * Invoked when a user gesture indicates that an event for this
     * {@code ButtonBase} should occur.
     * &lt;p&gt;
     * If invoked, this method will be executed regardless of the status of
     * {@link #arm}.
     * &lt;/p&gt;
     */
    public abstract void fire();


    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final PseudoClass ARMED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;armed&quot;);


    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case FIRE:
                fire();
                break;
            default: super.executeAccessibleAction(action);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/DatePicker.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

// editor and converter code in sync with ComboBox 4858:e60e9a5396e6

import java.time.LocalDate;
import java.time.DateTimeException;
import java.time.chrono.Chronology;
import java.time.chrono.IsoChronology;
import java.time.format.FormatStyle;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;

import com.sun.javafx.scene.control.FakeFocusTextField;

import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.WritableValue;
import javafx.css.CssMetaData;
import javafx.css.Styleable;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableProperty;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.util.Callback;
import javafx.util.StringConverter;
import javafx.util.converter.LocalDateStringConverter;

import javafx.css.converter.BooleanConverter;
import javafx.scene.control.skin.DatePickerSkin;
import com.sun.javafx.scene.control.skin.resources.ControlResources;


/**
 * The DatePicker control allows the user to enter a date as text or
 * to select a date from a calendar popup. The calendar is based on
 * either the standard ISO-8601 chronology or any of the other
 * chronology classes defined in the java.time.chrono package.
 *
 * &lt;p&gt;The {@link #valueProperty() value} property represents the
 * currently selected {@link java.time.LocalDate}.  An initial date can
 * be set via the {@link #DatePicker(java.time.LocalDate) constructor}
 * or by calling {@link #setValue setValue(LocalDate)}.  The
 * default value is null.
 *
 * &lt;pre&gt;&lt;code&gt;
 * final DatePicker datePicker = new DatePicker();
 * datePicker.setOnAction(new EventHandler() {
 *     public void handle(Event t) {
 *         LocalDate date = datePicker.getValue();
 *         System.err.println(&quot;Selected date: &quot; + date);
 *     }
 * });
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * The {@link #chronologyProperty() chronology} property specifies a
 * calendar system to be used for parsing, displaying, and choosing
 * dates.
 * The {@link #valueProperty() value} property is always defined in
 * the ISO calendar system, however, so applications based on a
 * different chronology may use the conversion methods provided in the
 * {@link java.time.chrono.Chronology} API to get or set the
 * corresponding {@link java.time.chrono.ChronoLocalDate} value. For
 * example:
 *
 * &lt;pre&gt;&lt;code&gt;
 * LocalDate isoDate = datePicker.getValue();
 * ChronoLocalDate chronoDate =
 *     ((isoDate != null) ? datePicker.getChronology().date(isoDate) : null);
 * System.err.println(&quot;Selected date: &quot; + chronoDate);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 * @since JavaFX 8.0
 */
public class DatePicker extends ComboBoxBase&lt;LocalDate&gt; {

    private LocalDate lastValidDate = null;
    private Chronology lastValidChronology = IsoChronology.INSTANCE;

    /**
     * Creates a default DatePicker instance with a &lt;code&gt;null&lt;/code&gt; date value set.
     */
    public DatePicker() {
        this(null);

        valueProperty().addListener(observable -&gt; {
            LocalDate date = getValue();
            Chronology chrono = getChronology();

            if (validateDate(chrono, date)) {
                lastValidDate = date;
            } else {
                System.err.println(&quot;Restoring value to &quot; +
                            ((lastValidDate == null) ? &quot;null&quot; : getConverter().toString(lastValidDate)));
                setValue(lastValidDate);
            }
        });

        chronologyProperty().addListener(observable -&gt; {
            LocalDate date = getValue();
            Chronology chrono = getChronology();

            if (validateDate(chrono, date)) {
                lastValidChronology = chrono;
                defaultConverter = new LocalDateStringConverter(FormatStyle.SHORT, null, chrono);
            } else {
                System.err.println(&quot;Restoring value to &quot; + lastValidChronology);
                setChronology(lastValidChronology);
            }
        });
    }

    private boolean validateDate(Chronology chrono, LocalDate date) {
        try {
            if (date != null) {
                chrono.date(date);
            }
            return true;
        } catch (DateTimeException ex) {
<A NAME="21"></A>            System.err.println(ex);
            return false;
        }
    <FONT color="#00ff00"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#21',2,'match46-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    /**
     * Creates a DatePicker instance and sets the
     * {@link #valueProperty() value} to the given date.
     *
     * @param localDate to be set as the currently selected date in the DatePicker. Can be null.
     */
    public DatePicker(LocalDate localDate) {
        setValue(localDate);
        getStyleClass().add(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.DATE_PICKER);
        setEditable(true);
    }</B></FONT>


    /***************************************************************************
     *                                                                         *
     * Properties                                                                 *
     *                                                                         *
     **************************************************************************/


    /**
     * A custom cell factory can be provided to customize individual
     * day cells in the DatePicker popup. Refer to {@link DateCell}
     * and {@link Cell} for more information on cell factories.
     * Example:
     *
     * &lt;pre&gt;&lt;code&gt;
     * final Callback&amp;lt;DatePicker, DateCell&amp;gt; dayCellFactory = new Callback&amp;lt;DatePicker, DateCell&amp;gt;() {
     *     public DateCell call(final DatePicker datePicker) {
     *         return new DateCell() {
     *             &amp;#064;Override public void updateItem(LocalDate item, boolean empty) {
     *                 super.updateItem(item, empty);
     *
     *                 if (MonthDay.from(item).equals(MonthDay.of(9, 25))) {
     *                     setTooltip(new Tooltip(&quot;Happy Birthday!&quot;));
     *                     setStyle(&quot;-fx-background-color: #ff4444;&quot;);
     *                 }
     *                 if (item.equals(LocalDate.now().plusDays(1))) {
     *                     // Tomorrow is too soon.
     *                     setDisable(true);
     *                 }
     *             }
     *         };
     *     }
     * };
     * datePicker.setDayCellFactory(dayCellFactory);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @defaultValue null
     */
    private ObjectProperty&lt;Callback&lt;DatePicker, DateCell&gt;&gt; dayCellFactory;
    public final void setDayCellFactory(Callback&lt;DatePicker, DateCell&gt; value) {
        dayCellFactoryProperty().set(value);
    }
    public final Callback&lt;DatePicker, DateCell&gt; getDayCellFactory() {
        return (dayCellFactory != null) ? dayCellFactory.get() : null;
    }
    public final ObjectProperty&lt;Callback&lt;DatePicker, DateCell&gt;&gt; dayCellFactoryProperty() {
        if (dayCellFactory == null) {
            dayCellFactory = new SimpleObjectProperty&lt;Callback&lt;DatePicker, DateCell&gt;&gt;(this, &quot;dayCellFactory&quot;);
        }
        return dayCellFactory;
    }



    /**
     * The calendar system used for parsing, displaying, and choosing
     * dates in the DatePicker control.
     *
     * &lt;p&gt;The default value is returned from a call to
     * {@code Chronology.ofLocale(Locale.getDefault(Locale.Category.FORMAT))}.
     * The default is usually {@link java.time.chrono.IsoChronology} unless
     * provided explicitly in the {@link java.util.Locale} by use of a
     * Locale calendar extension.
     *
     * Setting the value to &lt;code&gt;null&lt;/code&gt; will restore the default
     * chronology.
     * @return a property representing the Chronology being used
     */
    public final ObjectProperty&lt;Chronology&gt; chronologyProperty() {
        return chronology;
    }
    private ObjectProperty&lt;Chronology&gt; chronology =
        new SimpleObjectProperty&lt;Chronology&gt;(this, &quot;chronology&quot;, null);
    public final Chronology getChronology() {
        Chronology chrono = chronology.get();
        if (chrono == null) {
            try {
                chrono = Chronology.ofLocale(Locale.getDefault(Locale.Category.FORMAT));
            } catch (Exception ex) {
                System.err.println(ex);
            }
            if (chrono == null) {
                chrono = IsoChronology.INSTANCE;
            }
            //System.err.println(chrono);
        }
        return chrono;
    }
    public final void setChronology(Chronology value) {
        chronology.setValue(value);
    }


    /**
     * Whether the DatePicker popup should display a column showing
     * week numbers.
     *
     * &lt;p&gt;The default value is specified in a resource bundle, and
     * depends on the country of the current locale.
     * @return true if popup should display a column showing
     * week numbers
     */
    public final BooleanProperty showWeekNumbersProperty() {
        if (showWeekNumbers == null) {
            String country = Locale.getDefault(Locale.Category.FORMAT).getCountry();
            boolean localizedDefault =
                (!country.isEmpty() &amp;&amp;
                 ControlResources.getNonTranslatableString(&quot;DatePicker.showWeekNumbers&quot;).contains(country));
            showWeekNumbers = new StyleableBooleanProperty(localizedDefault) {
                @Override public CssMetaData&lt;DatePicker,Boolean&gt; getCssMetaData() {
                    return StyleableProperties.SHOW_WEEK_NUMBERS;
                }

                @Override public Object getBean() {
                    return DatePicker.this;
                }

                @Override public String getName() {
                    return &quot;showWeekNumbers&quot;;
                }
            };
        }
        return showWeekNumbers;
    }
    private BooleanProperty showWeekNumbers;
    public final void setShowWeekNumbers(boolean value) {
        showWeekNumbersProperty().setValue(value);
    }
    public final boolean isShowWeekNumbers() {
        return showWeekNumbersProperty().getValue();
    }


    // --- string converter
    /**
     * Converts the input text to an object of type LocalDate and vice
     * versa.
     *
     * &lt;p&gt;If not set by the application, the DatePicker skin class will
     * set a converter based on a {@link java.time.format.DateTimeFormatter}
     * for the current {@link java.util.Locale} and
     * {@link #chronologyProperty() chronology}. This formatter is
     * then used to parse and display the current date value.
     *
     * Setting the value to &lt;code&gt;null&lt;/code&gt; will restore the default
     * converter.
     *
     * &lt;p&gt;Example using an explicit formatter:
     * &lt;pre&gt;&lt;code&gt;
     * datePicker.setConverter(new StringConverter&amp;lt;LocalDate&amp;gt;() {
     *     String pattern = &quot;yyyy-MM-dd&quot;;
     *     DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(pattern);
     *
     *     {
     *         datePicker.setPromptText(pattern.toLowerCase());
     *     }
     *
     *     {@literal @Override public String toString(LocalDate date) {
     *         if (date != null) {
     *             return dateFormatter.format(date);
     *         } else {
     *             return &quot;&quot;;
     *         }
     *     }}
     *
     *     {@literal @Override public LocalDate fromString(String string) {
     *         if (string != null &amp;&amp; !string.isEmpty()) {
     *             return LocalDate.parse(string, dateFormatter);
     *         } else {
     *             return null;
     *         }
     *     }}
     * });
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;Example that wraps the default formatter and catches parse exceptions:
     * &lt;pre&gt;&lt;code&gt;
     *   final StringConverter&amp;lt;LocalDate&amp;gt; defaultConverter = datePicker.getConverter();
     *   datePicker.setConverter(new StringConverter&amp;lt;LocalDate&amp;gt;() {
     *       &amp;#064;Override public String toString(LocalDate value) {
     *           return defaultConverter.toString(value);
     *       }
     *
     *       &amp;#064;Override public LocalDate fromString(String text) {
     *           try {
     *               return defaultConverter.fromString(text);
     *           } catch (DateTimeParseException ex) {
     *               System.err.println(&quot;HelloDatePicker: &quot;+ex.getMessage());
     *               throw ex;
     *           }
     *       }
     *   });
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;p&gt;The default base year for parsing input containing only two digits for
     * the year is 2000 (see {@link java.time.format.DateTimeFormatter}).  This
     * default is not useful for allowing a person's date of birth to be typed.
     * The following example modifies the converter's fromString() method to
     * allow a two digit year for birth dates up to 99 years in the past.
     * &lt;pre&gt;&lt;code&gt;
     *   {@literal @Override public LocalDate fromString(String text) {
     *       if (text != null &amp;&amp; !text.isEmpty()) {
     *           Locale locale = Locale.getDefault(Locale.Category.FORMAT);
     *           Chronology chrono = datePicker.getChronology();
     *           String pattern =
     *               DateTimeFormatterBuilder.getLocalizedDateTimePattern(FormatStyle.SHORT,
     *                                                                    null, chrono, locale);
     *           String prePattern = pattern.substring(0, pattern.indexOf(&quot;y&quot;));
     *           String postPattern = pattern.substring(pattern.lastIndexOf(&quot;y&quot;)+1);
     *           int baseYear = LocalDate.now().getYear() - 99;
     *           DateTimeFormatter df = new DateTimeFormatterBuilder()
     *                       .parseLenient()
     *                       .appendPattern(prePattern)
     *                       .appendValueReduced(ChronoField.YEAR, 2, 2, baseYear)
     *                       .appendPattern(postPattern)
     *                       .toFormatter();
     *           return LocalDate.from(chrono.date(df.parse(text)));
     *       } else {
     *           return null;
     *       }
     *   }}
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @return the property representing the current LocalDate string converter
     * @see javafx.scene.control.ComboBox#converterProperty
     */
    public final ObjectProperty&lt;StringConverter&lt;LocalDate&gt;&gt; converterProperty() { return converter; }
    private ObjectProperty&lt;StringConverter&lt;LocalDate&gt;&gt; converter =
            new SimpleObjectProperty&lt;StringConverter&lt;LocalDate&gt;&gt;(this, &quot;converter&quot;, null);
    public final void setConverter(StringConverter&lt;LocalDate&gt; value) { converterProperty().set(value); }
    public final StringConverter&lt;LocalDate&gt; getConverter() {
        StringConverter&lt;LocalDate&gt; converter = converterProperty().get();
        if (converter != null) {
            return converter;
        } else {
            return defaultConverter;
        }
    }

    // Create a symmetric (format/parse) converter with the default locale.
    private StringConverter&lt;LocalDate&gt; defaultConverter =
                new LocalDateStringConverter(FormatStyle.SHORT, null, getChronology());


    // --- Editor
    /**
     * The editor for the DatePicker.
     *
     * @see javafx.scene.control.ComboBox#editorProperty
     */
    private ReadOnlyObjectWrapper&lt;TextField&gt; editor;
    public final TextField getEditor() {
        return editorProperty().get();
    }
    public final ReadOnlyObjectProperty&lt;TextField&gt; editorProperty() {
        if (editor == null) {
            editor = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;editor&quot;);
            editor.set(new FakeFocusTextField());
        }
        return editor.getReadOnlyProperty();
    }

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new DatePickerSkin(this);
    }


    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;date-picker&quot;;

    private static class StyleableProperties {
        private static final String country =
            Locale.getDefault(Locale.Category.FORMAT).getCountry();
        private static final CssMetaData&lt;DatePicker, Boolean&gt; SHOW_WEEK_NUMBERS =
              new CssMetaData&lt;DatePicker, Boolean&gt;(&quot;-fx-show-week-numbers&quot;,
                   BooleanConverter.getInstance(),
                   (!country.isEmpty() &amp;&amp;
                    ControlResources.getNonTranslatableString(&quot;DatePicker.showWeekNumbers&quot;).contains(country))) {
            @Override public boolean isSettable(DatePicker n) {
                return n.showWeekNumbers == null || !n.showWeekNumbers.isBound();
            }

            @Override public StyleableProperty&lt;Boolean&gt; getStyleableProperty(DatePicker n) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)n.showWeekNumbersProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;

        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
            Collections.addAll(styleables,
                SHOW_WEEK_NUMBERS
            );
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
        return getClassCssMetaData();
    }

    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case DATE: return getValue();
            case TEXT: {
                String accText = getAccessibleText();
                if (accText != null &amp;&amp; !accText.isEmpty()) return accText;

                LocalDate date = getValue();
                StringConverter&lt;LocalDate&gt; c = getConverter();
                if (date != null &amp;&amp; c != null) {
                    return c.toString(date);
                }
                return &quot;&quot;;
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/DialogPane.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javafx.scene.control;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;

import com.sun.javafx.scene.control.skin.Utils;
import com.sun.javafx.scene.control.skin.resources.ControlResources;
import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.css.CssMetaData;
import javafx.css.StyleOrigin;
import javafx.css.Styleable;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.css.StyleableStringProperty;
import javafx.event.ActionEvent;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.ButtonBar.ButtonData;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;

import com.sun.javafx.css.StyleManager;
import javafx.css.converter.StringConverter;

/**
 * DialogPane should be considered to be the root node displayed within a
 * {@link Dialog} instance. In this role, the DialogPane is responsible for the
 * placement of {@link #headerProperty() headers}, {@link #graphicProperty() graphics},
 * {@link #contentProperty() content}, and {@link #getButtonTypes() buttons}.
 * The default implementation of DialogPane (that is, the DialogPane class itself)
 * handles the layout via the normal {@link #layoutChildren()} method. This
 * method may be overridden by subclasses wishing to handle the layout in an
 * alternative fashion).
 *
 * &lt;p&gt;In addition to the {@link #headerProperty() header} and
 * {@link #contentProperty() content} properties, there exists
 * {@link #headerTextProperty() header text} and
 * {@link #contentTextProperty() content text} properties. The way the *Text
 * properties work is that they are a lower precedence compared to the Node
 * properties, but they are far more convenient for developers in the common case,
 * as it is likely the case that a developer more often than not simply wants to
 * set a string value into the header or content areas of the DialogPane.
 *
 * &lt;p&gt;It is important to understand the implications of setting non-null values
 * in the {@link #headerProperty() header} and {@link #headerTextProperty() headerText}
 * properties. The key points are as follows:
 *
 * &lt;ol&gt;
 *   &lt;li&gt;The {@code header} property takes precedence over the {@code headerText}
 *       property, so if both are set to non-null values, {@code header} will be
 *       used and {@code headerText} will be ignored.&lt;/li&gt;
 *   &lt;li&gt;If {@code headerText} is set to a non-null value, and a
 *       {@link #graphicProperty() graphic} has also been set, the default position
 *       for the graphic shifts from being located to the left of the content area
 *       to being to the right of the header text.&lt;/li&gt;
 *   &lt;li&gt;If {@code header} is set to a non-null value, and a
 *       {@link #graphicProperty() graphic} has also been set, the graphic is
 *       removed from its default position (to the left of the content area),
 *       and &lt;strong&gt;is not&lt;/strong&gt; placed to the right of the custom header
 *       node. If the graphic is desired, it should be manually added in to the
 *       layout of the custom header node manually.&lt;/li&gt;
 * &lt;/ol&gt;
 *
 * &lt;p&gt;DialogPane operates on the concept of {@link ButtonType}. A ButtonType is
 * a descriptor of a single button that should be represented visually in the
 * DialogPane. Developers who create a DialogPane therefore must specify the
 * button types that they want to display, and this is done via the
 * {@link #getButtonTypes()} method, which returns a modifiable
 * {@link ObservableList}, which users can add to and remove from as desired.
 *
 * &lt;p&gt;The {@link ButtonType} class defines a number of pre-defined button types,
 * such as {@link ButtonType#OK} and {@link ButtonType#CANCEL}. Many users of the
 * JavaFX dialogs API will find that these pre-defined button types meet their
 * needs, particularly due to their built-in support for
 * {@link ButtonData#isDefaultButton() default} and
 * {@link ButtonData#isCancelButton() cancel} buttons, as well as the benefit of
 * the strings being translated into all languages which JavaFX is translated to.
 * For users that want to define their own {@link ButtonType} (most commonly to
 * define a button with custom text), they may do so via the constructors available
 * on the {@link ButtonType} class.
 *
 * &lt;p&gt;Developers will quickly find that the amount of configurability offered
 * via the {@link ButtonType} class is minimal. This is intentional, but does not
 * mean that developers can not modify the buttons created by the {@link ButtonType}
 * that have been specified. To do this, developers simply call the
 * {@link #lookupButton(ButtonType)} method with the ButtonType (assuming it has
 * already been set in the {@link #getButtonTypes()} list. The returned Node is
 * typically of type {@link Button}, but this depends on if the
 * {@link #createButton(ButtonType)} method has been overridden.
 *
 * &lt;p&gt;The DialogPane class offers a few methods that can be overridden by
 * subclasses, to more easily enable custom functionality. These methods include
 * the following:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #createButton(ButtonType)}
 *   &lt;li&gt;{@link #createDetailsButton()}
 *   &lt;li&gt;{@link #createButtonBar()}
 * &lt;/ul&gt;
 *
 * &lt;p&gt;These methods are documented, so please take note of the expectations
 * placed on any developer who wishes to override these methods with their own
 * functionality.
 *
 * @see Dialog
 * @since JavaFX 8u40
 */
@DefaultProperty(&quot;buttonTypes&quot;)
public class DialogPane extends Pane {

    /**************************************************************************
     *
     * Static fields
     *
     **************************************************************************/

    /**
     * Creates a Label node that works well within a Dialog.
     * @param text The text to display
     */
    static Label createContentLabel(String text) {
        Label label = new Label(text);
        label.setMaxWidth(Double.MAX_VALUE);
        label.setMaxHeight(Double.MAX_VALUE);
        label.getStyleClass().add(&quot;content&quot;);
        label.setWrapText(true);
        label.setPrefWidth(360);
        return label;
    }



    /**************************************************************************
     *
     * Private fields
     *
     **************************************************************************/

    private final GridPane headerTextPanel;
    private final Label contentLabel;
    private final StackPane graphicContainer;
    private final Node buttonBar;

    private final ObservableList&lt;ButtonType&gt; buttons = FXCollections.observableArrayList();

    private final Map&lt;ButtonType, Node&gt; buttonNodes = new WeakHashMap&lt;&gt;();

    private Node detailsButton;

    // this is not a property - we have a package-scope setDialog method that
    // sets this field. It is set by Dialog if the DialogPane is set inside a Dialog.
    private Dialog&lt;?&gt; dialog;



    /**************************************************************************
     *
     * Constructors
     *
     **************************************************************************/

    /**
     * Creates a new DialogPane instance with a style class of 'dialog-pane'.
     */
    public DialogPane() {
        getStyleClass().add(&quot;dialog-pane&quot;);

        headerTextPanel = new GridPane();
        getChildren().add(headerTextPanel);

        graphicContainer = new StackPane();

        contentLabel = createContentLabel(&quot;&quot;);
        getChildren().add(contentLabel);

        buttonBar = createButtonBar();
        if (buttonBar != null) {
            getChildren().add(buttonBar);
        }

        buttons.addListener((ListChangeListener&lt;ButtonType&gt;) c -&gt; {
            while (c.next()) {
                if (c.wasRemoved()) {
                    for (ButtonType cmd : c.getRemoved()) {
                        buttonNodes.remove(cmd);
                    }
                }
                if (c.wasAdded()) {
                    for (ButtonType cmd : c.getAddedSubList()) {
                        if (! buttonNodes.containsKey(cmd)) {
                            buttonNodes.put(cmd, createButton(cmd));
                        }
                    }
                }
            }
        });
    }



    /**************************************************************************
     *
     * Properties
     *
     **************************************************************************/

    // --- graphic
    private final ObjectProperty&lt;Node&gt; graphicProperty = new StyleableObjectProperty&lt;Node&gt;() {
        // The graphic is styleable by css, but it is the
        // imageUrlProperty that handles the style value.
        @Override public CssMetaData getCssMetaData() {
            return StyleableProperties.GRAPHIC;
        }

        @Override public Object getBean() {
            return DialogPane.this;
        }

        @Override public String getName() {
            return &quot;graphic&quot;;
        }

        WeakReference&lt;Node&gt; graphicRef = new WeakReference&lt;&gt;(null);

        protected void invalidated() {
            Node oldGraphic = graphicRef.get();
            if (oldGraphic != null) {
                getChildren().remove(oldGraphic);
            }

            Node newGraphic = getGraphic();
            graphicRef = new WeakReference&lt;&gt;(newGraphic);
            updateHeaderArea();
        }
    };

    /**
     * The dialog graphic, presented either in the header, if one is showing, or
     * to the left of the {@link #contentProperty() content}.
     *
     * @return An ObjectProperty wrapping the current graphic.
     */
    public final ObjectProperty&lt;Node&gt; graphicProperty() {
        return graphicProperty;
    }

    public final Node getGraphic() {
        return graphicProperty.get();
    }

    /**
     * Sets the dialog graphic, which will be displayed either in the header, if
     * one is showing, or to the left of the {@link #contentProperty() content}.
     *
     * @param graphic
     *            The new dialog graphic, or null if no graphic should be shown.
     */
    public final void setGraphic(Node graphic) {
        this.graphicProperty.set(graphic);
    }


    // --- imageUrl (this is NOT public API, except via CSS)
    // Note that this code is a copy/paste from Labeled
    private StyleableStringProperty imageUrl = null;
    /**
     * The imageUrl property is set from CSS and then the graphic property is
     * set from the invalidated method. This ensures that the same image isn't
     * reloaded.
     */
    private StyleableStringProperty imageUrlProperty() {
        if (imageUrl == null) {
            imageUrl = new StyleableStringProperty() {
                //
                // If imageUrlProperty is invalidated, this is the origin of the style that
                // triggered the invalidation. This is used in the invalidated() method where the
                // value of super.getStyleOrigin() is not valid until after the call to set(v) returns,
                // by which time invalidated will have been called.
                // This value is initialized to USER in case someone calls set on the imageUrlProperty, which
                // is possible:
                //     CssMetaData metaData = ((StyleableProperty)dialogPane.graphicProperty()).getCssMetaData();
                //     StyleableProperty prop = metaData.getStyleableProperty(dialogPane);
                //     prop.set(someUrl);
                //
                // TODO: Note that prop != dialogPane, which violates the contract between StyleableProperty and CssMetaData.
                //
                StyleOrigin origin = StyleOrigin.USER;

                @Override
                public void applyStyle(StyleOrigin origin, String v) {
                    this.origin = origin;

                    // Don't want applyStyle to throw an exception which would leave this.origin set to the wrong value
                    if (graphicProperty == null || graphicProperty.isBound() == false) super.applyStyle(origin, v);

                    // Origin is only valid for this invocation of applyStyle, so reset it to USER in case someone calls set.
                    this.origin = StyleOrigin.USER;
                }

                @Override
                protected void invalidated() {
                    // need to call super.get() here since get() is overridden to return the graphicProperty's value
                    final String url = super.get();

                    if (url == null) {
                        ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty()).applyStyle(origin, null);
                    } else {
                        // RT-34466 - if graphic's url is the same as this property's value, then don't overwrite.
                        final Node graphicNode = DialogPane.this.getGraphic();
                        if (graphicNode instanceof ImageView) {
                            final ImageView imageView = (ImageView)graphicNode;
                            final Image image = imageView.getImage();
                            if (image != null) {
                                final String imageViewUrl = image.getUrl();
                                if (url.equals(imageViewUrl)) return;
                            }

                        }

                        final Image img = StyleManager.getInstance().getCachedImage(url);

                        if (img != null) {
                            //
                            // Note that it is tempting to try to re-use existing ImageView simply by setting
                            // the image on the current ImageView, if there is one. This would effectively change
                            // the image, but not the ImageView which means that no graphicProperty listeners would
                            // be notified. This is probably not what we want.
                            //

                            //
                            // Have to call applyStyle on graphicProperty so that the graphicProperty's
                            // origin matches the imageUrlProperty's origin.
                            //
                            ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty()).applyStyle(origin, new ImageView(img));
                        }
                    }
                }

                @Override
                public String get() {
                    //
                    // The value of the imageUrlProperty is that of the graphicProperty.
                    // Return the value in a way that doesn't expand the graphicProperty.
                    //
                    final Node graphic = getGraphic();
                    if (graphic instanceof ImageView) {
                        final Image image = ((ImageView)graphic).getImage();
                        if (image != null) {
                            return image.getUrl();
                        }
                    }
                    return null;
                }

                @Override
                public StyleOrigin getStyleOrigin() {
                    //
                    // The origin of the imageUrlProperty is that of the graphicProperty.
                    // Return the origin in a way that doesn't expand the graphicProperty.
                    //
                    return graphicProperty != null ? ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty).getStyleOrigin() : null;
                }

                @Override
                public Object getBean() {
                    return DialogPane.this;
                }

                @Override
                public String getName() {
                    return &quot;imageUrl&quot;;
                }

                @Override
                public CssMetaData&lt;DialogPane,String&gt; getCssMetaData() {
                    return StyleableProperties.GRAPHIC;
                }

            };
        }
        return imageUrl;
    }


    // --- header
    private final ObjectProperty&lt;Node&gt; header = new SimpleObjectProperty&lt;Node&gt;(null) {
        WeakReference&lt;Node&gt; headerRef = new WeakReference&lt;&gt;(null);
        @Override protected void invalidated() {
            Node oldHeader = headerRef.get();
            if (oldHeader != null) {
                getChildren().remove(oldHeader);
            }

            Node newHeader = getHeader();
            headerRef = new WeakReference&lt;&gt;(newHeader);
            updateHeaderArea();
        }
    };

    /**
     * Node which acts as the dialog pane header.
     *
     * @return the header of the dialog pane.
     */
    public final Node getHeader() {
        return header.get();
    }

    /**
     * Assigns the dialog pane header. Any Node can be used.
     *
     * @param header The new header of the DialogPane.
     */
    public final void setHeader(Node header) {
        this.header.setValue(header);
    }

    /**
     * Property representing the header area of the dialog pane. Note that if this
     * header is set to a non-null value, that it will take up the entire top
     * area of the DialogPane. It will also result in the DialogPane switching its
     * layout to the 'header' layout - as outlined in the {@link DialogPane} class
     * javadoc.
     * @return the property representing the header area of the dialog pane
     */
    public final ObjectProperty&lt;Node&gt; headerProperty() {
        return header;
    }



    // --- header text
    private final StringProperty headerText = new SimpleStringProperty(this, &quot;headerText&quot;) {
        @Override protected void invalidated() {
            updateHeaderArea();
            requestLayout();
        }
    };

    /**
     * Sets the string to show in the dialog header area. Note that the header text
     * is lower precedence than the {@link #headerProperty() header node}, meaning
     * that if both the header node and the headerText properties are set, the
     * header text will not be displayed in a default DialogPane instance.
     *
     * &lt;p&gt;When headerText is set to a non-null value, this will result in the
     * DialogPane switching its layout to the 'header' layout - as outlined in
     * the {@link DialogPane} class javadoc.&lt;/p&gt;
     * @param headerText the string to show in the dialog header area
     */
    public final void setHeaderText(String headerText) {
        this.headerText.set(headerText);
    }

    /**
     * Returns the currently-set header text for this DialogPane.
     * @return the currently-set header text for this DialogPane
     */
    public final String getHeaderText() {
        return headerText.get();
    }

    /**
     * A property representing the header text for the dialog pane. The header text
     * is lower precedence than the {@link #headerProperty() header node}, meaning
     * that if both the header node and the headerText properties are set, the
     * header text will not be displayed in a default DialogPane instance.
     *
     * &lt;p&gt;When headerText is set to a non-null value, this will result in the
     * DialogPane switching its layout to the 'header' layout - as outlined in
     * the {@link DialogPane} class javadoc.&lt;/p&gt;
     * @return the property representing the header text for the dialog pane
     */
    public final StringProperty headerTextProperty() {
        return headerText;
    }


    // --- content
    private final ObjectProperty&lt;Node&gt; content = new SimpleObjectProperty&lt;Node&gt;(null) {
        WeakReference&lt;Node&gt; contentRef = new WeakReference&lt;&gt;(null);
        @Override protected void invalidated() {
            Node oldContent = contentRef.get();
            if (oldContent != null) {
                getChildren().remove(oldContent);
            }

            Node newContent = getContent();
            contentRef = new WeakReference&lt;&gt;(newContent);
            updateContentArea();
        }
    };

    /**
     * Returns the dialog content as a Node (even if it was set as a String
     * using {@link #setContentText(String)} - this was simply transformed into a
     * {@link Node} (most probably a {@link Label}).
     *
     * @return dialog's content
     */
    public final Node getContent() {
        return content.get();
    }

    /**
     * Assign dialog content. Any Node can be used
     *
     * @param content
     *            dialog's content
     */
    public final void setContent(Node content) {
        this.content.setValue(content);
    }

    /**
     * Property representing the content area of the dialog.
     * @return the property representing the content area of the dialog
     */
    public final ObjectProperty&lt;Node&gt; contentProperty() {
        return content;
    }


    // --- content text
    private final StringProperty contentText = new SimpleStringProperty(this, &quot;contentText&quot;) {
        @Override protected void invalidated() {
            updateContentArea();
            requestLayout();
        }
    };

    /**
     * Sets the string to show in the dialog content area. Note that the content text
     * is lower precedence than the {@link #contentProperty() content node}, meaning
     * that if both the content node and the contentText properties are set, the
     * content text will not be displayed in a default DialogPane instance.
     * @param contentText the string to show in the dialog content area
     */
    public final void setContentText(String contentText) {
        this.contentText.set(contentText);
    }

    /**
     * Returns the currently-set content text for this DialogPane.
     * @return the currently-set content text for this DialogPane
     */
    public final String getContentText() {
        return contentText.get();
    }

    /**
     * A property representing the content text for the dialog pane. The content text
     * is lower precedence than the {@link #contentProperty() content node}, meaning
     * that if both the content node and the contentText properties are set, the
     * content text will not be displayed in a default DialogPane instance.
     * @return the property representing the content text for the dialog pane
     */
    public final StringProperty contentTextProperty() {
        return contentText;
    }


    // --- expandable content
    private final ObjectProperty&lt;Node&gt; expandableContentProperty = new SimpleObjectProperty&lt;Node&gt;(null) {
        WeakReference&lt;Node&gt; expandableContentRef = new WeakReference&lt;&gt;(null);
        @Override protected void invalidated() {
            Node oldExpandableContent = expandableContentRef.get();
            if (oldExpandableContent != null) {
                getChildren().remove(oldExpandableContent);
            }

            Node newExpandableContent = getExpandableContent();
            expandableContentRef = new WeakReference&lt;Node&gt;(newExpandableContent);
            if (newExpandableContent != null) {
                newExpandableContent.setVisible(isExpanded());
                newExpandableContent.setManaged(isExpanded());

                if (!newExpandableContent.getStyleClass().contains(&quot;expandable-content&quot;)) { //$NON-NLS-1$
                    newExpandableContent.getStyleClass().add(&quot;expandable-content&quot;); //$NON-NLS-1$
                }

                getChildren().add(newExpandableContent);
            }
        }
    };

    /**
     * A property that represents the dialog expandable content area. Any Node
     * can be placed in this area, but it will only be shown when the user
     * clicks the 'Show Details' expandable button. This button will be added
     * automatically when the expandable content property is non-null.
     * @return the property that represents the dialog expandable content area
     */
    public final ObjectProperty&lt;Node&gt; expandableContentProperty() {
        return expandableContentProperty;
    }

    /**
     * Returns the dialog expandable content node, if one is set, or null
     * otherwise.
     * @return the dialog expandable content node
     */
    public final Node getExpandableContent() {
        return expandableContentProperty.get();
    }

    /**
     * Sets the dialog expandable content node, or null if no expandable content
     * needs to be shown.
     * @param content the dialog expandable content node
     */
    public final void setExpandableContent(Node content) {
        this.expandableContentProperty.set(content);
    }


    // --- expanded
    private final BooleanProperty expandedProperty = new SimpleBooleanProperty(this, &quot;expanded&quot;, false) {
        protected void invalidated() {
            final Node expandableContent = getExpandableContent();

            if (expandableContent != null) {
                expandableContent.setVisible(isExpanded());
            }

            requestLayout();
        }
    };

    /**
     * Represents whether the dialogPane is expanded.
     * @return the property representing whether the dialogPane is expanded
     */
    public final BooleanProperty expandedProperty() {
        return expandedProperty;
    }

    /**
     * Returns whether or not the dialogPane is expanded.
     *
     * @return true if dialogPane is expanded.
     */
    public final boolean isExpanded() {
        return expandedProperty().get();
    }

    /**
     * Sets whether the dialogPane is expanded. This only makes sense when there
     * is {@link #expandableContentProperty() expandable content} to show.
     *
     * @param value true if dialogPane should be expanded.
     */
    public final void setExpanded(boolean value) {
        expandedProperty().set(value);
    }



    /**************************************************************************
     *
     * Public API
     *
     **************************************************************************/

    // --- button types
    /**
     * Observable list of button types used for the dialog button bar area
     * (created via the {@link #createButtonBar()} method). Modifying the contents
     * of this list will immediately change the buttons displayed to the user
     * within the dialog pane.
     *
     * @return The {@link ObservableList} of {@link ButtonType button types}
     *         available to the user.
     */
    public final ObservableList&lt;ButtonType&gt; getButtonTypes() {
        return buttons;
    }

    /**
     * This method provides a way in which developers may retrieve the actual
     * Node for a given {@link ButtonType} (assuming it is part of the
     * {@link #getButtonTypes() button types} list).
     *
     * @param buttonType The {@link ButtonType} for which a Node representation is requested.
     * @return The Node used to represent the button type, as created by
     *         {@link #createButton(ButtonType)}, and only if the button type
     *         is part of the {@link #getButtonTypes() button types} list, otherwise null.
     */
    public final Node lookupButton(ButtonType buttonType) {
        return buttonNodes.get(buttonType);
    }

    /**
     * This method can be overridden by subclasses to provide the button bar.
     * Note that by overriding this method, the developer must take on multiple
     * responsibilities:
     *
     * &lt;ol&gt;
     *   &lt;li&gt;The developer must immediately iterate through all
     *   {@link #getButtonTypes() button types} and call
     *   {@link #createButton(ButtonType)} for each of them in turn.
     *   &lt;li&gt;The developer must add a listener to the
     *   {@link #getButtonTypes() button types} list, and when this list changes
     *   update the button bar as appropriate.
     *   &lt;li&gt;Similarly, the developer must watch for changes to the
     *   {@link #expandableContentProperty() expandable content} property,
     *   adding and removing the details button (created via
     *   {@link #createDetailsButton()} method).
     * &lt;/ol&gt;
     *
     * &lt;p&gt;The default implementation of this method creates and returns a new
     * {@link ButtonBar} instance.
     * @return the created button bar
     */
    protected Node createButtonBar() {
        ButtonBar buttonBar = new ButtonBar();
        buttonBar.setMaxWidth(Double.MAX_VALUE);

        updateButtons(buttonBar);
        getButtonTypes().addListener((ListChangeListener&lt;? super ButtonType&gt;) c -&gt; updateButtons(buttonBar));
        expandableContentProperty().addListener(o -&gt; updateButtons(buttonBar));

        return buttonBar;
    }

    /**
     * This method can be overridden by subclasses to create a custom button that
     * will subsequently inserted into the DialogPane button area (created via
     * the {@link #createButtonBar()} method, but mostly commonly it is an instance
     * of {@link ButtonBar}.
     *
     * @param buttonType The {@link ButtonType} to create a button from.
     * @return A JavaFX {@link Node} that represents the given {@link ButtonType},
     *         most commonly an instance of {@link Button}.
     */
    protected Node createButton(ButtonType buttonType) {
        final Button button = new Button(buttonType.getText());
        final ButtonData buttonData = buttonType.getButtonData();
        ButtonBar.setButtonData(button, buttonData);
        button.setDefaultButton(buttonData.isDefaultButton());
        button.setCancelButton(buttonData.isCancelButton());
        button.addEventHandler(ActionEvent.ACTION, ae -&gt; {
            if (ae.isConsumed()) return;
            if (dialog != null) {
                dialog.setResultAndClose(buttonType, true);
            }
        });

        return button;
    }

    /**
     * This method can be overridden by subclasses to create a custom details button.
     *
     * &lt;p&gt;To override this method you must do two things:
     * &lt;ol&gt;
     *   &lt;li&gt;The button will need to have its own code set to handle mouse / keyboard
     *       interaction and to toggle the state of the
     *       {@link #expandedProperty() expanded} property.
     *   &lt;li&gt;If your button changes its visuals based on whether the dialog pane
     *       is expanded or collapsed, you should add a listener to the
     *       {@link #expandedProperty() expanded} property, so that you may update
     *       the button visuals.
     * &lt;/ol&gt;
     * @return the created details button
     */
    protected Node createDetailsButton() {
        final Hyperlink detailsButton = new Hyperlink();
        final String moreText = ControlResources.getString(&quot;Dialog.detail.button.more&quot;); //$NON-NLS-1$
        final String lessText = ControlResources.getString(&quot;Dialog.detail.button.less&quot;); //$NON-NLS-1$

        InvalidationListener expandedListener = o -&gt; {
            final boolean isExpanded = isExpanded();
            detailsButton.setText(isExpanded ? lessText : moreText);
            detailsButton.getStyleClass().setAll(&quot;details-button&quot;, (isExpanded ? &quot;less&quot; : &quot;more&quot;)); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
        };

        // we call the listener immediately to ensure the state is correct at start up
        expandedListener.invalidated(null);
        expandedProperty().addListener(expandedListener);

        detailsButton.setOnAction(ae -&gt; setExpanded(!isExpanded()));
        return detailsButton;
    }

    private double oldHeight = -1;

    /** {@inheritDoc} */
    @Override protected void layoutChildren() {
        final boolean hasHeader = hasHeader();

        // snapped insets code commented out to resolve RT-39738
        final double w = Math.max(minWidth(-1), getWidth());// - (snappedLeftInset() + snappedRightInset());

        final double minHeight = minHeight(w);
        final double prefHeight = prefHeight(w);
        final double maxHeight = maxHeight(w);
        final double currentHeight = getHeight();
        final double dialogHeight = dialog == null ? 0 : dialog.dialog.getSceneHeight();
        double h;

        if (prefHeight &gt; currentHeight &amp;&amp; prefHeight &gt; minHeight &amp;&amp; (prefHeight &lt;= dialogHeight || dialogHeight == 0)) {
            h = prefHeight;
            resize(w, h);
        } else {
            boolean isDialogGrowing = currentHeight &gt; oldHeight;

            if (isDialogGrowing) {
                double _h = currentHeight &lt; prefHeight ?
                        Math.min(prefHeight, currentHeight) : Math.max(prefHeight, dialogHeight);
                h = Utils.boundedSize(_h, minHeight, maxHeight);
            } else {
                h = Utils.boundedSize(Math.min(currentHeight, dialogHeight), minHeight, maxHeight);
            }
            resize(w, h);
        }

        h -= (snappedTopInset() + snappedBottomInset());

        oldHeight = h;

        final double leftPadding = snappedLeftInset();
        final double topPadding = snappedTopInset();
        final double rightPadding = snappedRightInset();

        // create the nodes up front so we can work out sizing
        final Node header = getActualHeader();
        final Node content = getActualContent();
        final Node graphic = getActualGraphic();
        final Node expandableContent = getExpandableContent();

        final double graphicPrefWidth = hasHeader || graphic == null ? 0 : graphic.prefWidth(-1);
        final double headerPrefHeight = hasHeader ? header.prefHeight(w) : 0;
        final double buttonBarPrefHeight = buttonBar == null ? 0 : buttonBar.prefHeight(w);
        final double graphicPrefHeight = hasHeader || graphic == null ? 0 : graphic.prefHeight(-1);

        final double expandableContentPrefHeight;
        final double contentAreaHeight;
        final double contentAndGraphicHeight;

        final double availableContentWidth = w - graphicPrefWidth - leftPadding - rightPadding;

        if (isExpanded()) {
            // precedence goes to content and then expandable content
            contentAreaHeight = isExpanded() ? content.prefHeight(availableContentWidth) : 0;
            contentAndGraphicHeight = hasHeader ? contentAreaHeight : Math.max(graphicPrefHeight, contentAreaHeight);
            expandableContentPrefHeight = h - (headerPrefHeight + contentAndGraphicHeight + buttonBarPrefHeight);
        } else {
            // content gets the lowest precedence
            expandableContentPrefHeight = isExpanded() ? expandableContent.prefHeight(w) : 0;
            contentAreaHeight = h - (headerPrefHeight + expandableContentPrefHeight + buttonBarPrefHeight);
            contentAndGraphicHeight = hasHeader ? contentAreaHeight : Math.max(graphicPrefHeight, contentAreaHeight);
        }

        double x = leftPadding;
        double y = topPadding;

        if (! hasHeader) {
            if (graphic != null) {
                graphic.resizeRelocate(x, y, graphicPrefWidth, graphicPrefHeight);
                x += graphicPrefWidth;
            }
        } else {
            header.resizeRelocate(x, y, w - (leftPadding + rightPadding), headerPrefHeight);
            y += headerPrefHeight;
        }

        content.resizeRelocate(x, y, availableContentWidth, contentAreaHeight);
        y += hasHeader ? contentAreaHeight : contentAndGraphicHeight;

        if (expandableContent != null) {
            expandableContent.resizeRelocate(leftPadding, y, w - rightPadding, expandableContentPrefHeight);
            y += expandableContentPrefHeight;
        }

        if (buttonBar != null) {
            buttonBar.resizeRelocate(leftPadding,
                                     y,
                                     w - (leftPadding + rightPadding),
                                     buttonBarPrefHeight);
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMinWidth(double height) {
        double headerMinWidth = hasHeader() ? getActualHeader().minWidth(height) + 10 : 0;
        double contentMinWidth = getActualContent().minWidth(height);
        double buttonBarMinWidth = buttonBar == null ? 0 : buttonBar.minWidth(height);
        double graphicMinWidth = getActualGraphic().minWidth(height);

        double expandableContentMinWidth = 0;
        final Node expandableContent = getExpandableContent();
        if (isExpanded() &amp;&amp; expandableContent != null) {
            expandableContentMinWidth = expandableContent.minWidth(height);
        }

        double minWidth = snappedLeftInset() +
                (hasHeader() ? 0 : graphicMinWidth) +
                Math.max(Math.max(headerMinWidth, expandableContentMinWidth), Math.max(contentMinWidth, buttonBarMinWidth)) +
                snappedRightInset();

        return snapSizeX(minWidth);
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width) {
        final boolean hasHeader = hasHeader();

        double headerMinHeight = hasHeader ? getActualHeader().minHeight(width) : 0;
        double buttonBarMinHeight = buttonBar == null ? 0 : buttonBar.minHeight(width);

        Node graphic = getActualGraphic();
        double graphicMinWidth = hasHeader ? 0 : graphic.minWidth(-1);
        double graphicMinHeight = hasHeader ? 0 : graphic.minHeight(width);

        // min height of a label is based on one line (wrapping is ignored)
        Node content = getActualContent();
        double contentAvailableWidth = width == Region.USE_COMPUTED_SIZE ? Region.USE_COMPUTED_SIZE :
                hasHeader ? width : (width - graphicMinWidth);
        double contentMinHeight = content.minHeight(contentAvailableWidth);

        double expandableContentMinHeight = 0;
        final Node expandableContent = getExpandableContent();
        if (isExpanded() &amp;&amp; expandableContent != null) {
            expandableContentMinHeight = expandableContent.minHeight(width);
        }

        double minHeight = snappedTopInset() +
                headerMinHeight +
                Math.max(graphicMinHeight, contentMinHeight) +
                expandableContentMinHeight +
                buttonBarMinHeight +
                snappedBottomInset();

        return snapSizeY(minHeight);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height) {
        double headerPrefWidth = hasHeader() ? getActualHeader().prefWidth(height) + 10 : 0;
        double contentPrefWidth = getActualContent().prefWidth(height);
        double buttonBarPrefWidth = buttonBar == null ? 0 : buttonBar.prefWidth(height);
        double graphicPrefWidth = getActualGraphic().prefWidth(height);

        double expandableContentPrefWidth = 0;
        final Node expandableContent = getExpandableContent();
        if (isExpanded() &amp;&amp; expandableContent != null) {
            expandableContentPrefWidth = expandableContent.prefWidth(height);
        }

        double prefWidth = snappedLeftInset() +
               (hasHeader() ? 0 : graphicPrefWidth) +
               Math.max(Math.max(headerPrefWidth, expandableContentPrefWidth), Math.max(contentPrefWidth, buttonBarPrefWidth)) +
               snappedRightInset();

        return snapSizeX(prefWidth);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width) {
        final boolean hasHeader = hasHeader();

        double headerPrefHeight = hasHeader ? getActualHeader().prefHeight(width) : 0;
        double buttonBarPrefHeight = buttonBar == null ? 0 : buttonBar.prefHeight(width);

        Node graphic = getActualGraphic();
        double graphicPrefWidth = hasHeader ? 0 : graphic.prefWidth(-1);
        double graphicPrefHeight = hasHeader ? 0 : graphic.prefHeight(width);

        Node content = getActualContent();
        double contentAvailableWidth = width == Region.USE_COMPUTED_SIZE ? Region.USE_COMPUTED_SIZE :
                hasHeader ? width : (width - graphicPrefWidth);
        double contentPrefHeight = content.prefHeight(contentAvailableWidth);

        double expandableContentPrefHeight = 0;
        final Node expandableContent = getExpandableContent();
        if (isExpanded() &amp;&amp; expandableContent != null) {
            expandableContentPrefHeight = expandableContent.prefHeight(width);
        }

        double prefHeight = snappedTopInset() +
               headerPrefHeight +
               Math.max(graphicPrefHeight, contentPrefHeight) +
               expandableContentPrefHeight +
               buttonBarPrefHeight +
               snappedBottomInset();

        return snapSizeY(prefHeight);
    }



    /**************************************************************************
     *
     * Private implementation
     * @param buttonBar
     *
     **************************************************************************/

    private void updateButtons(ButtonBar buttonBar) {
        buttonBar.getButtons().clear();

        // show details button if expandable content is present
        if (hasExpandableContent()) {
            if (detailsButton == null) {
                detailsButton = createDetailsButton();
            }
            ButtonBar.setButtonData(detailsButton, ButtonData.HELP_2);
            buttonBar.getButtons().add(detailsButton);
            ButtonBar.setButtonUniformSize(detailsButton, false);
        }

        boolean hasDefault = false;
        for (ButtonType cmd : getButtonTypes()) {
            Node button = buttonNodes.computeIfAbsent(cmd, dialogButton -&gt; createButton(cmd));

            // keep only first default button
            if (button instanceof Button) {
                ButtonData buttonType = cmd.getButtonData();

                ((Button)button).setDefaultButton(!hasDefault &amp;&amp; buttonType != null &amp;&amp; buttonType.isDefaultButton());
                ((Button)button).setCancelButton(buttonType != null &amp;&amp; buttonType.isCancelButton());

                hasDefault |= buttonType != null &amp;&amp; buttonType.isDefaultButton();
            }
            buttonBar.getButtons().add(button);
        }
    }

    private Node getActualContent() {
        Node content = getContent();
        return content == null ? contentLabel : content;
    }

    private Node getActualHeader() {
        Node header = getHeader();
        return header == null ? headerTextPanel : header;
    }

    private Node getActualGraphic() {
        return headerTextPanel;
    }

    private void updateHeaderArea() {
        Node header = getHeader();
        if (header != null) {
            if (! getChildren().contains(header)) {
                getChildren().add(header);
            }

            headerTextPanel.setVisible(false);
            headerTextPanel.setManaged(false);
        } else {
            final String headerText = getHeaderText();

            headerTextPanel.getChildren().clear();
            headerTextPanel.getStyleClass().clear();

            // recreate the headerTextNode and add it to the children list.
            headerTextPanel.setMaxWidth(Double.MAX_VALUE);

            if (headerText != null &amp;&amp; ! headerText.isEmpty()) {
                headerTextPanel.getStyleClass().add(&quot;header-panel&quot;); //$NON-NLS-1$
            }

            // on left of header is the text
            Label headerLabel = new Label(headerText);
            headerLabel.setWrapText(true);
            headerLabel.setAlignment(Pos.CENTER_LEFT);
            headerLabel.setMaxWidth(Double.MAX_VALUE);
            headerLabel.setMaxHeight(Double.MAX_VALUE);
            headerTextPanel.add(headerLabel, 0, 0);

            // on the right of the header is a graphic, if one is specified
            graphicContainer.getChildren().clear();

            if (! graphicContainer.getStyleClass().contains(&quot;graphic-container&quot;)) { //$NON-NLS-1$)
                graphicContainer.getStyleClass().add(&quot;graphic-container&quot;); //$NON-NLS-1$
            }

            final Node graphic = getGraphic();
<A NAME="1"></A>            if (graphic != null) {
                graphicContainer.getChildren().add(graphic);
            }
            <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#1',2,'match46-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>headerTextPanel.add(graphicContainer, 1, 0);

            // column constraints
            ColumnConstraints textColumn = new ColumnConstraints();
            textColumn.setFillWidth(true);
            textColumn.setHgrow(Priority.ALWAYS);
            ColumnConstraints graphicColumn = new ColumnConstraints();
            graphicColumn.setFillWidth(false);
            graphicColumn.setHgrow(Priority.NEVER);
            headerTextPanel.getColumnConstraints().setAll(textColumn , graphicColumn);

            headerTextPanel.setVisible</B></FONT>(true);
            headerTextPanel.setManaged(true);
        }
    }

    private void updateContentArea() {
        Node content = getContent();
        if (content != null) {
            if (! getChildren().contains(content)) {
                getChildren().add(content);
            }

            if (! content.getStyleClass().contains(&quot;content&quot;)) {
                content.getStyleClass().add(&quot;content&quot;);
            }

            contentLabel.setVisible(false);
            contentLabel.setManaged(false);
        } else {
            final String contentText = getContentText();
            final boolean visible = contentText != null &amp;&amp; !contentText.isEmpty();
            contentLabel.setText(visible ? contentText : &quot;&quot;);
            contentLabel.setVisible(visible);
            contentLabel.setManaged(visible);
        }
    }

    boolean hasHeader() {
        return getHeader() != null || isTextHeader();
    }

    private boolean isTextHeader() {
        String headerText = getHeaderText();
        return headerText != null &amp;&amp; !headerText.isEmpty();
    }

    boolean hasExpandableContent() {
        return getExpandableContent() != null;
    }

    void setDialog(Dialog&lt;?&gt; dialog) {
        this.dialog = dialog;
    }



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static class StyleableProperties {

        private static final CssMetaData&lt;DialogPane,String&gt; GRAPHIC =
            new CssMetaData&lt;DialogPane,String&gt;(&quot;-fx-graphic&quot;,
                StringConverter.getInstance()) {

            @Override
            public boolean isSettable(DialogPane n) {
                // Note that we care about the graphic, not imageUrl
                return n.graphicProperty == null || !n.graphicProperty.isBound();
            }

            @Override
            public StyleableProperty&lt;String&gt; getStyleableProperty(DialogPane n) {
                return n.imageUrlProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables = new ArrayList&lt;&gt;(Region.getClassCssMetaData());
            Collections.addAll(styleables,
                GRAPHIC
            );
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /** {@inheritDoc} */
    @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/Label.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="0"></A> * questions.
 */

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#0',2,'match46-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package javafx.scene.control;

import javafx.scene.control.skin.LabelSkin;
import com.sun.javafx.scene.NodeHelper;

import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.WritableValue;
import javafx.css.StyleableProperty;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;

/**
 * Label is a non-editable text control. A Label is useful for displaying
 * text that is required to fit within a specific space, and thus may need
 * to use an ellipsis or truncation to size the string to fit. Labels also are
 * useful in that they can have mnemonics which, if used, will send focus to
 * the Control listed as the target of the &lt;code&gt;labelFor&lt;/code&gt; property.
 * &lt;p&gt;
 * Label sets focusTraversable to false.
 * &lt;/p&gt;
 *
 * &lt;p&gt;Example:
 * &lt;pre&gt;&lt;code&gt;Label label = new Label(&quot;a label&quot;);&lt;/code&gt;&lt;/pre&gt;
 * @since JavaFX 2.0
 */
public class Label extends Labeled {

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates an empty label
     */
    public Label() {
        initialize();
    }

    /**
     * Creates Label with supplied text.
     * @param text null text is treated as the empty string
     */
    public</B></FONT> Label(String text) {
        super(text);
        initialize();
    }

    /**
     * Creates a Label with the supplied text and graphic.
     * @param text null text is treated as the empty string
     * @param graphic a null graphic is acceptable
     */
    public Label(String text, Node graphic) {
        super(text, graphic);
        initialize();
    }

    private void initialize() {
        getStyleClass().setAll(&quot;label&quot;);
        setAccessibleRole(AccessibleRole.TEXT);
        // Labels are not focus traversable, unlike most other UI Controls.
        // focusTraversable is styleable through css. Calling setFocusTraversable
        // makes it look to css like the user set the value and css will not
        // override. Initializing focusTraversable by calling set on the
        // CssMetaData ensures that css will be able to override the value.
        ((StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)focusTraversableProperty()).applyStyle(null, Boolean.FALSE);
    }

    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    private ChangeListener&lt;Boolean&gt; mnemonicStateListener = (observable, oldValue, newValue) -&gt; {
        NodeHelper.showMnemonicsProperty(Label.this).setValue(newValue);
    };

    /**
     * A Label can act as a label for a different Control or
     * Node. This is used for Mnemonics and Accelerator parsing.
     * This allows setting of the target Node.
     * @return the Node that this label is to be associated with
     */
    public ObjectProperty&lt;Node&gt; labelForProperty() {
        if (labelFor == null) {
            labelFor = new ObjectPropertyBase&lt;Node&gt;() {
                Node oldValue = null;
                @Override protected void invalidated() {
                    if (oldValue != null) {
                        NodeHelper.getNodeAccessor().setLabeledBy(oldValue, null);
                        NodeHelper.showMnemonicsProperty(oldValue).removeListener(mnemonicStateListener);
                    }
                    final Node node = get();
                    if (node != null) {
                        NodeHelper.getNodeAccessor().setLabeledBy(node, Label.this);
                        NodeHelper.showMnemonicsProperty(node).addListener(mnemonicStateListener);
                        NodeHelper.setShowMnemonics(Label.this, NodeHelper.isShowMnemonics(node));
                    } else {
                        NodeHelper.setShowMnemonics(Label.this, false);
                    }
                    oldValue = node;
                }

                @Override public Object getBean() {
                    return Label.this;
                }

                @Override public String getName() {
                    return &quot;labelFor&quot;;
                }
            };

        }
        return labelFor;
    }
    private ObjectProperty&lt;Node&gt; labelFor;

    public final void setLabelFor(Node value) { labelForProperty().setValue(value); }
    public final Node getLabelFor() { return labelFor == null ? null : labelFor.getValue(); }

    /***************************************************************************
     *                                                                         *
     * Methods                                                                 *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new LabelSkin(this);
    }

    /***************************************************************************
     *                                                                         *
     * CSS Support                                                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns the initial focus traversable state of this control, for use
     * by the JavaFX CSS engine to correctly set its initial value. This method
     * is overridden as by default UI controls have focus traversable set to true,
     * but that is not appropriate for this control.
     *
     * @since 9
     */
    @Override protected Boolean getInitialFocusTraversable() {
        return Boolean.FALSE;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/ComboBoxBaseSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import javafx.event.EventHandler;
import javafx.scene.control.SkinBase;
import com.sun.javafx.scene.control.behavior.ComboBoxBaseBehavior;
import javafx.geometry.HPos;
import javafx.geometry.VPos;
import javafx.scene.Node;
import javafx.scene.control.ComboBoxBase;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;

import java.util.List;

/**
 * An abstract class intended to be used as the base skin for ComboBox-like
 * controls that are based on {@link ComboBoxBase}. Most users of this skin class
 * would be well-advised to also look at {@link ComboBoxPopupControl} for
 * additional useful API.
 *
 * @since 9
 * @param &lt;T&gt; The type of the ComboBox-like control.
 * @see ComboBoxBase
 * @see ComboBoxPopupControl
 */
public abstract class ComboBoxBaseSkin&lt;T&gt; extends SkinBase&lt;ComboBoxBase&lt;T&gt;&gt; {

    /***************************************************************************
     *                                                                         *
     * Private Fields                                                          *
     *                                                                         *
     **************************************************************************/

    private Node displayNode; // this is normally either label or textField

    StackPane arrowButton;
<A NAME="22"></A>    Region arrow;

    /** The mode in which this control will be represented. */
    <FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#22',2,'match46-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private ComboBoxMode mode = ComboBoxMode.COMBOBOX;
    final ComboBoxMode getMode() { return mode; }
    final void setMode(ComboBoxMode value) { mode = value; }</B></FONT>

    private final EventHandler&lt;MouseEvent&gt; mouseEnteredEventHandler  = e -&gt;   getBehavior().mouseEntered(e);
    private final EventHandler&lt;MouseEvent&gt; mousePressedEventHandler  = e -&gt; { getBehavior().mousePressed(e);  e.consume(); };
    private final EventHandler&lt;MouseEvent&gt; mouseReleasedEventHandler = e -&gt; { getBehavior().mouseReleased(e); e.consume(); };
    private final EventHandler&lt;MouseEvent&gt; mouseExitedEventHandler   = e -&gt;   getBehavior().mouseExited(e);



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new instance of ComboBoxBaseSkin, although note that this
     * instance does not handle any behavior / input mappings - this needs to be
     * handled appropriately by subclasses.
     *
     * @param control The control that this skin should be installed onto.
     */
    public ComboBoxBaseSkin(final ComboBoxBase&lt;T&gt; control) {
        // Call the super method with the ComboBox we were just given in the constructor
        super(control);

        getChildren().clear();

        // open button / arrow
        arrow = new Region();
        arrow.setFocusTraversable(false);
        arrow.getStyleClass().setAll(&quot;arrow&quot;);
        arrow.setId(&quot;arrow&quot;);
        arrow.setMaxWidth(Region.USE_PREF_SIZE);
        arrow.setMaxHeight(Region.USE_PREF_SIZE);
        arrow.setMouseTransparent(true);

        arrowButton = new StackPane();
        arrowButton.setFocusTraversable(false);
        arrowButton.setId(&quot;arrow-button&quot;);
        arrowButton.getStyleClass().setAll(&quot;arrow-button&quot;);
        arrowButton.getChildren().add(arrow);

        getChildren().add(arrowButton);

        // When ComboBoxBase focus shifts to another node, it should hide.
        getSkinnable().focusedProperty().addListener((observable, oldValue, newValue) -&gt; {
            if (!newValue) {
                focusLost();
            }
        });

        // Register listeners
        updateArrowButtonListeners();
        registerChangeListener(control.editableProperty(), e -&gt; {
            updateArrowButtonListeners();
            updateDisplayArea();
        });
        registerChangeListener(control.showingProperty(), e -&gt; {
            if (getSkinnable().isShowing()) {
                show();
            } else {
                hide();
            }
        });
        registerChangeListener(control.valueProperty(), e -&gt; updateDisplayArea());
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * This method should return a Node that will be positioned within the
     * ComboBox 'button' area.
     * @return the node that will be positioned within the ComboBox 'button' area
     */
    public abstract Node getDisplayNode();

    /**
     * This method will be called when the ComboBox popup should be displayed.
     * It is up to specific skin implementations to determine how this is handled.
     */
    public abstract void show();

    /**
     * This method will be called when the ComboBox popup should be hidden.
     * It is up to specific skin implementations to determine how this is handled.
     */
    public abstract void hide();

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
            final double w, final double h) {
        if (displayNode == null) {
            updateDisplayArea();
        }

        final double arrowWidth = snapSizeX(arrow.prefWidth(-1));
        final double arrowButtonWidth = (isButton()) ? 0 :
                arrowButton.snappedLeftInset() + arrowWidth +
                arrowButton.snappedRightInset();

        if (displayNode != null) {
            displayNode.resizeRelocate(x, y, w - arrowButtonWidth, h);
        }

        arrowButton.setVisible(! isButton());
        if (! isButton()) {
            arrowButton.resize(arrowButtonWidth, h);
            positionInArea(arrowButton, (x + w) - arrowButtonWidth, y,
                    arrowButtonWidth, h, 0, HPos.CENTER, VPos.CENTER);
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        if (displayNode == null) {
            updateDisplayArea();
        }

        final double arrowWidth = snapSizeX(arrow.prefWidth(-1));
        final double arrowButtonWidth = isButton() ? 0 :
                                        arrowButton.snappedLeftInset() +
                                        arrowWidth +
                                        arrowButton.snappedRightInset();
        final double displayNodeWidth = displayNode == null ? 0 : displayNode.prefWidth(height);

        final double totalWidth = displayNodeWidth + arrowButtonWidth;
        return leftInset + totalWidth + rightInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        if (displayNode == null) {
            updateDisplayArea();
        }

        double ph;
        if (displayNode == null) {
            final int DEFAULT_HEIGHT = 21;
            double arrowHeight = (isButton()) ? 0 :
                    (arrowButton.snappedTopInset() + arrow.prefHeight(-1) + arrowButton.snappedBottomInset());
            ph = Math.max(DEFAULT_HEIGHT, arrowHeight);
        } else {
            ph = displayNode.prefHeight(width);
        }

        return topInset+ ph + bottomInset;
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return getSkinnable().prefWidth(height);
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return getSkinnable().prefHeight(width);
    }

    // Overridden so that we use the displayNode as the baseline, rather than the arrow.
    // See RT-30754 for more information.
    /** {@inheritDoc} */
    @Override protected double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        if (displayNode == null) {
            updateDisplayArea();
        }

        if (displayNode != null) {
            return displayNode.getLayoutBounds().getMinY() + displayNode.getLayoutY() + displayNode.getBaselineOffset();
        }

        return super.computeBaselineOffset(topInset, rightInset, bottomInset, leftInset);
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    ComboBoxBaseBehavior getBehavior() {
        return null;
    }

    void focusLost() {
        getSkinnable().hide();
    }

    private boolean isButton() {
        return getMode() == ComboBoxMode.BUTTON;
    }

    private void updateArrowButtonListeners() {
        if (getSkinnable().isEditable()) {
            //
            // arrowButton behaves like a button.
            // This is strongly tied to the implementation in ComboBoxBaseBehavior.
            //
            arrowButton.addEventHandler(MouseEvent.MOUSE_ENTERED,  mouseEnteredEventHandler);
            arrowButton.addEventHandler(MouseEvent.MOUSE_PRESSED,  mousePressedEventHandler);
            arrowButton.addEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
            arrowButton.addEventHandler(MouseEvent.MOUSE_EXITED,   mouseExitedEventHandler);
        } else {
            arrowButton.removeEventHandler(MouseEvent.MOUSE_ENTERED,  mouseEnteredEventHandler);
            arrowButton.removeEventHandler(MouseEvent.MOUSE_PRESSED,  mousePressedEventHandler);
            arrowButton.removeEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
            arrowButton.removeEventHandler(MouseEvent.MOUSE_EXITED,   mouseExitedEventHandler);
        }
    }

    void updateDisplayArea() {
        final List&lt;Node&gt; children = getChildren();
        final Node oldDisplayNode = displayNode;
        displayNode = getDisplayNode();

        // don't remove displayNode if it hasn't changed.
        if (oldDisplayNode != null &amp;&amp; oldDisplayNode != displayNode) {
            children.remove(oldDisplayNode);
        }

        if (displayNode != null &amp;&amp; !children.contains(displayNode)) {
            children.add(displayNode);
            displayNode.applyCss();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/NestedTableColumnHeader.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="3"></A> * questions.
 */

<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#3',2,'match46-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package javafx.scene.control.skin;

import com.sun.javafx.scene.control.skin.Utils;
import javafx.beans.property.ObjectProperty;
import javafx.collections.WeakListChangeListener;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.atomic.AtomicBoolean;

import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.event.EventHandler;
import javafx.geometry.NodeOrientation;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.util.Callback;

/**
 * &lt;p&gt;This class is used to construct the header of a TableView. We take the approach
 * that every TableView header is nested - even if it isn't. This allows for us
 * to use the same code for building a single row of TableColumns as we would
 * with a heavily nested sequences of TableColumns. Because of this, the
 * TableHeaderRow class consists of just one instance of a NestedTableColumnHeader.
 *
 * @since 9
 * @see TableColumnHeader
 * @see TableHeaderRow
 * @see TableColumnBase
 */
public class NestedTableColumnHeader extends TableColumnHeader {

    /***************************************************************************
     *                                                                         *
     * Static Fields                                                           *
     *                                                                         *
     **************************************************************************/

    static final String DEFAULT_STYLE_CLASS = &quot;nested-column-header&quot;;

    private static final int DRAG_RECT_WIDTH = 4;

    private static final String TABLE_COLUMN_KEY = &quot;TableColumn&quot;;
    private static final String TABLE_COLUMN_HEADER_KEY = &quot;TableColumnHeader&quot;;



    /***************************************************************************
     *                                                                         *
     * Private Fields                                                          *
     *                                                                         *
     **************************************************************************/

    /**
     * Represents the actual columns directly contained in this nested column.
     * It does NOT include ANY of the children of these columns, if any exist.
     */
    private ObservableList&lt;? extends TableColumnBase&gt; columns</B></FONT>;

    private TableColumnHeader label;

    private ObservableList&lt;TableColumnHeader&gt; columnHeaders;
    private ObservableList&lt;TableColumnHeader&gt; unmodifiableColumnHeaders;

    // used for column resizing
    private double lastX = 0.0F;
    private double dragAnchorX = 0.0;

    // drag rectangle overlays
    private Map&lt;TableColumnBase&lt;?,?&gt;, Rectangle&gt; dragRects = new WeakHashMap&lt;&gt;();

    boolean updateColumns = true;



    /***************************************************************************
     *                                                                         *
     * Constructor                                                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new NestedTableColumnHeader instance to visually represent the given
     * {@link TableColumnBase} instance.
     *
     * @param tc The table column to be visually represented by this instance.
     */
    public NestedTableColumnHeader(final TableColumnBase tc) {
        super(tc);

        setFocusTraversable(false);

        // init UI
        label = createTableColumnHeader(getTableColumn());
        label.setTableHeaderRow(getTableHeaderRow());
        label.setParentHeader(getParentHeader());
        label.setNestedColumnHeader(this);

        if (getTableColumn() != null) {
            changeListenerHandler.registerChangeListener(getTableColumn().textProperty(), e -&gt;
                    label.setVisible(getTableColumn().getText() != null &amp;&amp; ! getTableColumn().getText().isEmpty()));
        }
    }



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private final ListChangeListener&lt;TableColumnBase&gt; columnsListener = c -&gt; {
        setHeadersNeedUpdate();
    };

    private final WeakListChangeListener weakColumnsListener =
            new WeakListChangeListener(columnsListener);

    private static final EventHandler&lt;MouseEvent&gt; rectMousePressed = me -&gt; {
        Rectangle rect = (Rectangle) me.getSource();
        TableColumnBase column = (TableColumnBase) rect.getProperties().get(TABLE_COLUMN_KEY);
        NestedTableColumnHeader header = (NestedTableColumnHeader) rect.getProperties().get(TABLE_COLUMN_HEADER_KEY);

        if (! header.isColumnResizingEnabled()) return;

        // column reordering takes precedence over column resizing, but sometimes the mouse dragged events
        // can be received by both nodes, leading to less than ideal UX, hence the check here.
        if (header.getTableHeaderRow().columnDragLock) return;

        if (me.isConsumed()) return;
        me.consume();

        if (me.getClickCount() == 2 &amp;&amp; me.isPrimaryButtonDown()) {
            // the user wants to resize the column such that its
            // width is equal to the widest element in the column
            TableSkinUtils.resizeColumnToFitContent(header.getTableSkin(), column, -1);
        } else {
            // rather than refer to the rect variable, we just grab
            // it from the source to prevent a small memory leak.
            Rectangle innerRect = (Rectangle) me.getSource();
            double startX = header.getTableHeaderRow().sceneToLocal(innerRect.localToScene(innerRect.getBoundsInLocal())).getMinX() + 2;
            header.dragAnchorX = me.getSceneX();
            header.columnResizingStarted(startX);
        }
    };

    private static final EventHandler&lt;MouseEvent&gt; rectMouseDragged = me -&gt; {
        Rectangle rect = (Rectangle) me.getSource();
        TableColumnBase column = (TableColumnBase) rect.getProperties().get(TABLE_COLUMN_KEY);
        NestedTableColumnHeader header = (NestedTableColumnHeader) rect.getProperties().get(TABLE_COLUMN_HEADER_KEY);

        if (! header.isColumnResizingEnabled()) return;

        // column reordering takes precedence over column resizing, but sometimes the mouse dragged events
        // can be received by both nodes, leading to less than ideal UX, hence the check here.
        if (header.getTableHeaderRow().columnDragLock) return;

        if (me.isConsumed()) return;
        me.consume();

        header.columnResizing(column, me);
    };

    private static final EventHandler&lt;MouseEvent&gt; rectMouseReleased = me -&gt; {
        Rectangle rect = (Rectangle) me.getSource();
        TableColumnBase column = (TableColumnBase) rect.getProperties().get(TABLE_COLUMN_KEY);
        NestedTableColumnHeader header = (NestedTableColumnHeader) rect.getProperties().get(TABLE_COLUMN_HEADER_KEY);

        if (! header.isColumnResizingEnabled()) return;

        // column reordering takes precedence over column resizing, but sometimes the mouse dragged events
        // can be received by both nodes, leading to less than ideal UX, hence the check here.
        if (header.getTableHeaderRow().columnDragLock) return;

        if (me.isConsumed()) return;
        me.consume();

        header.columnResizingComplete(column, me);
    };

    private static final EventHandler&lt;MouseEvent&gt; rectCursorChangeListener = me -&gt; {
        Rectangle rect = (Rectangle) me.getSource();
        TableColumnBase column = (TableColumnBase) rect.getProperties().get(TABLE_COLUMN_KEY);
        NestedTableColumnHeader header = (NestedTableColumnHeader) rect.getProperties().get(TABLE_COLUMN_HEADER_KEY);

        // column reordering takes precedence over column resizing, but sometimes the mouse dragged events
        // can be received by both nodes, leading to less than ideal UX, hence the check here.
        if (header.getTableHeaderRow().columnDragLock) return;

        if (header.getCursor() == null) { // If there's a cursor for the whole header, don't override it
            rect.setCursor(header.isColumnResizingEnabled() &amp;&amp; rect.isHover() &amp;&amp;
                    column.isResizable() ? Cursor.H_RESIZE : null);
        }
    };



    /***************************************************************************
     *                                                                         *
     * Public Methods                                                          *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override void dispose() {
        super.dispose();

        if (label != null) {
            label.dispose();
        }

        if (getColumns() != null) {
            getColumns().removeListener(weakColumnsListener);
        }

        for (int i = 0; i &lt; getColumnHeaders().size(); i++) {
            TableColumnHeader header = getColumnHeaders().get(i);
            header.dispose();
        }

        for (Rectangle rect : dragRects.values()) {
            if (rect != null) {
                rect.visibleProperty().unbind();
            }
        }
        dragRects.clear();
        getChildren().clear();

        changeListenerHandler.dispose();
    }

    /**
     * Returns an unmodifiable list of the {@link TableColumnHeader} instances
     * that are children of this NestedTableColumnHeader.
     * @return the unmodifiable list of TableColumnHeader of this NestedTableColumnHeader
     */
    public final ObservableList&lt;TableColumnHeader&gt; getColumnHeaders() {
        if (columnHeaders == null) {
            columnHeaders = FXCollections.&lt;TableColumnHeader&gt;observableArrayList();
            unmodifiableColumnHeaders = FXCollections.unmodifiableObservableList(columnHeaders);
        }
        return unmodifiableColumnHeaders;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren() {
        double w = getWidth() - snappedLeftInset() - snappedRightInset();
        double h = getHeight() - snappedTopInset() - snappedBottomInset();

        int labelHeight = 0;

        if (label.isVisible() &amp;&amp; getTableColumn() != null) {
            labelHeight = (int) label.prefHeight(-1);
            // label gets to span whole width and sits at top
            label.resize(w, labelHeight);
            label.relocate(snappedLeftInset(), snappedTopInset());
        }

        // children columns need to share the total available width
        double x = snappedLeftInset();
        final double height = snapSizeY(h - labelHeight);
        for (int i = 0, max = getColumnHeaders().size(); i &lt; max; i++) {
            TableColumnHeader n = getColumnHeaders().get(i);
            if (! n.isVisible()) continue;

            double prefWidth = n.prefWidth(height);

            // position the column header in the default location...
            n.resize(prefWidth, height);
            n.relocate(x, labelHeight + snappedTopInset());

//            // ...but, if there are no children of this column, we should ensure
//            // that it is resized vertically such that it goes to the very
//            // bottom of the table header row.
//            if (getTableHeaderRow() != null &amp;&amp; n.getCol().getColumns().isEmpty()) {
//                Bounds bounds = getTableHeaderRow().sceneToLocal(n.localToScene(n.getBoundsInLocal()));
//                prefHeight = getTableHeaderRow().getHeight() - bounds.getMinY();
//                n.resize(prefWidth, prefHeight);
//            }

            // shuffle along the x-axis appropriately
            x += prefWidth;

            // position drag overlay to intercept column resize requests
            Rectangle dragRect = dragRects.get(n.getTableColumn());
            if (dragRect != null) {
                dragRect.setHeight(n.getDragRectHeight());
                dragRect.relocate(x - DRAG_RECT_WIDTH / 2, snappedTopInset() + labelHeight);
            }
        }
    }

    // sum up all children columns
    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height) {
        checkState();

        double width = 0.0F;

        if (getColumns() != null) {
            for (TableColumnHeader c : getColumnHeaders()) {
                if (c.isVisible()) {
                    width += c.computePrefWidth(height);
                }
            }
        }

        return width;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width) {
        checkState();

        double height = 0.0F;

        if (getColumnHeaders() != null) {
            for (TableColumnHeader n : getColumnHeaders()) {
                height = Math.max(height, n.prefHeight(-1));
            }
        }

        double labelHeight = 0.0;
        if (label.isVisible() &amp;&amp; getTableColumn() != null) {
            labelHeight = label.prefHeight(-1);
        }

        return height + labelHeight + snappedTopInset() + snappedBottomInset();
    }

    /**
     * Creates a new TableColumnHeader instance for the given TableColumnBase instance. The general pattern for
     * implementing this method is as follows:
     *
     * &lt;ul&gt;
     *     &lt;li&gt;If the given TableColumnBase instance is null, has no child columns, or if the given TableColumnBase
     *         instance equals the TableColumnBase instance returned by calling {@link #getTableColumn()}, then it is
     *         suggested to return a {@link TableColumnHeader} instance comprised of the given column.&lt;/li&gt;
     *     &lt;li&gt;Otherwise, we can presume that the given TableColumnBase instance has child columns, and in this case
     *         it is suggested to return a {@link NestedTableColumnHeader} instance instead.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;strong&gt;Note: &lt;/strong&gt;In most circumstances this method should not be overridden, but in some circumstances it
     * makes sense (e.g. testing, or when extreme customization is desired).
     *
     * @param col the table column
     * @return A new TableColumnHeader instance.
     */
    protected TableColumnHeader createTableColumnHeader(TableColumnBase col) {
        return col == null || col.getColumns().isEmpty() || col == getTableColumn() ?
                new TableColumnHeader(col) :
                new NestedTableColumnHeader(col);
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    @Override void initStyleClasses() {
        getStyleClass().setAll(DEFAULT_STYLE_CLASS);
        installTableColumnStyleClassListener();
    }

    @Override void setTableHeaderRow(TableHeaderRow header) {
        super.setTableHeaderRow(header);

        // it's only now that a skin might be available
        if (getTableSkin() != null) {
            changeListenerHandler.registerChangeListener(TableSkinUtils.columnResizePolicyProperty(getTableSkin()), e -&gt; updateContent());
        }

        label.setTableHeaderRow(header);

        // tell all children columns what TableHeader they belong to
        for (TableColumnHeader c : getColumnHeaders()) {
            c.setTableHeaderRow(header);
        }
    }

    @Override void setParentHeader(NestedTableColumnHeader parentHeader) {
        super.setParentHeader(parentHeader);
        label.setParentHeader(parentHeader);
    }

    ObservableList&lt;? extends TableColumnBase&gt; getColumns() {
        return columns;
    }

    void setColumns(ObservableList&lt;? extends TableColumnBase&gt; newColumns) {
        if (this.columns != null) {
            this.columns.removeListener(weakColumnsListener);
        }

        this.columns = newColumns;

        if (this.columns != null) {
            this.columns.addListener(weakColumnsListener);
        }
    }

    void updateTableColumnHeaders() {
        // watching for changes to the view columns in either table or tableColumn.
        if (getTableColumn() == null &amp;&amp; getTableSkin() != null) {
            setColumns(TableSkinUtils.getColumns(getTableSkin()));
        } else if (getTableColumn() != null) {
            setColumns(getTableColumn().getColumns());
        }

        // update the column headers...

        // iterate through all columns, unless we've got no child columns
        // any longer, in which case we should switch to a TableColumnHeader
        // instead
        if (getColumns().isEmpty()) {
            // iterate through all current headers, telling them to clean up
            for (int i = 0; i &lt; getColumnHeaders().size(); i++) {
                TableColumnHeader header = getColumnHeaders().get(i);
                header.dispose();
            }

            // switch out to be a TableColumn instead, if we have a parent header
            NestedTableColumnHeader parentHeader = getParentHeader();
            if (parentHeader != null) {
                List&lt;TableColumnHeader&gt; parentColumnHeaders = parentHeader.getColumnHeaders();
                int index = parentColumnHeaders.indexOf(this);
                if (index &gt;= 0 &amp;&amp; index &lt; parentColumnHeaders.size()) {
                    parentColumnHeaders.set(index, createColumnHeader(getTableColumn()));
                }
            } else {
                // otherwise just remove all the columns
                columnHeaders.clear();
            }
        } else {
            List&lt;TableColumnHeader&gt; oldHeaders = new ArrayList&lt;&gt;(getColumnHeaders());
            List&lt;TableColumnHeader&gt; newHeaders = new ArrayList&lt;&gt;();

            for (int i = 0; i &lt; getColumns().size(); i++) {
                TableColumnBase&lt;?,?&gt; column = getColumns().get(i);
                if (column == null || ! column.isVisible()) continue;

                // check if the header already exists and reuse it
                boolean found = false;
                for (int j = 0; j &lt; oldHeaders.size(); j++) {
                    TableColumnHeader oldColumn = oldHeaders.get(j);
                    if (oldColumn.represents(column)) {
                        newHeaders.add(oldColumn);
                        found = true;
                        break;
                    }
                }

                // otherwise create a new table column header
                if (!found) {
                    newHeaders.add(createColumnHeader(column));
                }
            }

            columnHeaders.setAll(newHeaders);

            // dispose all old headers
            oldHeaders.removeAll(newHeaders);
            for (int i = 0; i &lt; oldHeaders.size(); i++) {
                oldHeaders.get(i).dispose();
            }
        }

        // update the content
        updateContent();

        // RT-33596: Do CSS now, as we are in the middle of layout pass and the headers are new Nodes w/o CSS done
        for (TableColumnHeader header : getColumnHeaders()) {
            header.applyCss();
        }
    }

    // Used to test whether this column header properly represents the given column.
    // In particular, whether it has child column headers for all child columns
    boolean represents(TableColumnBase&lt;?, ?&gt; column) {
        if (column.getColumns().isEmpty()) {
            // this column has no children, but we are in a NestedTableColumnHeader instance,
            // so the match is bad.
            return false;
        }

        if (column != getTableColumn()) {
            return false;
        }

        final int columnCount = column.getColumns().size();
        final int headerCount = getColumnHeaders().size();
        if (columnCount != headerCount) {
            return false;
        }

        for (int i = 0; i &lt; columnCount; i++) {
            // we expect the order of all children to match the order of the headers
            TableColumnBase&lt;?,?&gt; childColumn = column.getColumns().get(i);
            TableColumnHeader childHeader = getColumnHeaders().get(i);
            if (!childHeader.represents(childColumn)) {
                return false;
            }
        }
        return true;
    }

    /** {@inheritDoc} */
    @Override double getDragRectHeight() {
        return label.prefHeight(-1);
    }

    void setHeadersNeedUpdate() {
        updateColumns = true;

        // go through children columns - they should update too
        for (int i = 0; i &lt; getColumnHeaders().size(); i++) {
            TableColumnHeader header = getColumnHeaders().get(i);
            if (header instanceof NestedTableColumnHeader) {
                ((NestedTableColumnHeader)header).setHeadersNeedUpdate();
            }
        }
        requestLayout();
    }

    private void updateContent() {
        // create a temporary list so we only do addAll into the main content
        // observableArrayList once.
        final List&lt;Node&gt; content = new ArrayList&lt;Node&gt;();

        // the label is the region that sits above the children columns
        content.add(label);

        // all children columns
        content.addAll(getColumnHeaders());

        // Small transparent overlays that sit at the start and end of each
        // column to intercept user drag gestures to enable column resizing.
        if (isColumnResizingEnabled()) {
            rebuildDragRects();
            content.addAll(dragRects.values());
        }

        getChildren().setAll(content);
    }

    private void rebuildDragRects() {
        if (! isColumnResizingEnabled()) return;

        getChildren().removeAll(dragRects.values());

        for (Rectangle rect : dragRects.values()) {
            rect.visibleProperty().unbind();
        }
        dragRects.clear();

        List&lt;? extends TableColumnBase&gt; columns = getColumns();

        if (columns == null) {
            return;
        }

        boolean isConstrainedResize = false;
        TableViewSkinBase tableSkin = getTableSkin();
        Callback&lt;ResizeFeaturesBase,Boolean&gt; columnResizePolicy = TableSkinUtils.columnResizePolicyProperty(tableSkin).get();
        if (columnResizePolicy != null) {
            isConstrainedResize =
                    tableSkin instanceof TableViewSkin ? TableView.CONSTRAINED_RESIZE_POLICY.equals(columnResizePolicy) :
                    tableSkin instanceof TreeTableViewSkin ? TreeTableView.CONSTRAINED_RESIZE_POLICY.equals(columnResizePolicy) :
                    false;
        }

        // RT-32547 - don't show resize cursor when in constrained resize mode
        // and there is only one column
        if (isConstrainedResize &amp;&amp; TableSkinUtils.getVisibleLeafColumns(tableSkin).size() == 1) {
            return;
        }

        for (int col = 0; col &lt; columns.size(); col++) {
            if (isConstrainedResize &amp;&amp; col == getColumns().size() - 1) {
                break;
            }

            final TableColumnBase c = columns.get(col);
            final Rectangle rect = new Rectangle();
            rect.getProperties().put(TABLE_COLUMN_KEY, c);
            rect.getProperties().put(TABLE_COLUMN_HEADER_KEY, this);
            rect.setWidth(DRAG_RECT_WIDTH);
            rect.setHeight(getHeight() - label.getHeight());
            rect.setFill(Color.TRANSPARENT);
            rect.visibleProperty().bind(c.visibleProperty().and(c.resizableProperty()));
            rect.setOnMousePressed(rectMousePressed);
            rect.setOnMouseDragged(rectMouseDragged);
            rect.setOnMouseReleased(rectMouseReleased);
            rect.setOnMouseEntered(rectCursorChangeListener);
            rect.setOnMouseExited(rectCursorChangeListener);

            dragRects.put(c, rect);
        }
    }

    private void checkState() {
        if (updateColumns) {
            updateTableColumnHeaders();
            updateColumns = false;
        }
    }

    private TableColumnHeader createColumnHeader(TableColumnBase col) {
        TableColumnHeader newCol = createTableColumnHeader(col);
        newCol.setTableHeaderRow(getTableHeaderRow());
        newCol.setParentHeader(this);
        return newCol;
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation: Column Resizing                                 *
     *                                                                         *
     **************************************************************************/

    private boolean isColumnResizingEnabled() {
        // this used to check if ! PlatformUtil.isEmbedded(), but has been changed
        // to always return true (for now), as we want to support column resizing
        // everywhere
        return true;
    }

    private void columnResizingStarted(double startX) {
        setCursor(Cursor.H_RESIZE);
        columnReorderLine.setLayoutX(startX);
    }

    private void columnResizing(TableColumnBase col, MouseEvent me) {
        double draggedX = me.getSceneX() - dragAnchorX;
        if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
            draggedX = -draggedX;
        }
        double delta = draggedX - lastX;
        boolean allowed = TableSkinUtils.resizeColumn(getTableSkin(), col, delta);
        if (allowed) {
            lastX = draggedX;
        }
    }

    private void columnResizingComplete(TableColumnBase col, MouseEvent me) {
        setCursor(null);
        columnReorderLine.setTranslateX(0.0F);
        columnReorderLine.setLayoutX(0.0F);
        lastX = 0.0F;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/PaginationSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.skin.Utils;
import javafx.beans.property.DoubleProperty;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableObjectProperty;
import javafx.css.CssMetaData;

import javafx.css.converter.BooleanConverter;
import javafx.css.converter.EnumConverter;
import javafx.css.converter.SizeConverter;
import com.sun.javafx.scene.control.behavior.PaginationBehavior;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javafx.animation.*;
import javafx.application.Platform;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.WritableValue;
import javafx.collections.ListChangeListener;
import javafx.css.Styleable;
import javafx.css.StyleableProperty;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.geometry.VPos;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.TouchEvent;
import javafx.scene.layout.HBox;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;

import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;

/**
 * Default skin implementation for the {@link Pagination} control.
 *
 * @see Pagination
 * @since 9
 */
public class PaginationSkin extends SkinBase&lt;Pagination&gt; {

    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    private static final Duration DURATION = new Duration(125.0);
    private static final double SWIPE_THRESHOLD = 0.30;
    private static final double TOUCH_THRESHOLD = 15;
    private static final Interpolator interpolator = Interpolator.SPLINE(0.4829, 0.5709, 0.6803, 0.9928);



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private Pagination pagination;
    private StackPane currentStackPane;
    private StackPane nextStackPane;
    private Timeline timeline;
    private Rectangle clipRect;

    private NavigationControl navigation;
    private int fromIndex;
    private int previousIndex;
    private int currentIndex;
    private int toIndex;
    private int pageCount;
    private int maxPageIndicatorCount;

    private double startTouchPos;
    private double lastTouchPos;
    private long startTouchTime;
    private long lastTouchTime;
    private double touchVelocity;
    private boolean touchThresholdBroken;
    private int touchEventId = -1;
    private boolean nextPageReached = false;
    private boolean setInitialDirection = false;
    private int direction;

    private int currentAnimatedIndex;
    private boolean hasPendingAnimation = false;

    private boolean animate = true;

    private final PaginationBehavior behavior;



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private EventHandler&lt;ActionEvent&gt; swipeAnimationEndEventHandler = new EventHandler&lt;ActionEvent&gt;() {
        @Override public void handle(ActionEvent t) {
            swapPanes();
            timeline = null;

            if (hasPendingAnimation) {
                animateSwitchPage();
                hasPendingAnimation = false;
            }
        }
    };

    private EventHandler&lt;ActionEvent&gt; clampAnimationEndEventHandler = new EventHandler&lt;ActionEvent&gt;() {
        @Override public void handle(ActionEvent t) {
            currentStackPane.setTranslateX(0);
            nextStackPane.setTranslateX(0);
            nextStackPane.setVisible(false);
            timeline = null;
        }
    };



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new PaginationSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public PaginationSkin(final Pagination control) {
        super(control);

        // install default input map for the Pagination control
        behavior = new PaginationBehavior(control);
//        control.setInputMap(behavior.getInputMap());

//        setManaged(false);
        clipRect = new Rectangle();
        getSkinnable().setClip(clipRect);

        this.pagination = control;

        this.currentStackPane = new StackPane();
        currentStackPane.getStyleClass().add(&quot;page&quot;);

        this.nextStackPane = new StackPane();
        nextStackPane.getStyleClass().add(&quot;page&quot;);
        nextStackPane.setVisible(false);

        resetIndexes(true);

        this.navigation = new NavigationControl();

        getChildren().addAll(currentStackPane, nextStackPane, navigation);

        control.maxPageIndicatorCountProperty().addListener(o -&gt; {
            resetIndiciesAndNav();
<A NAME="39"></A>        });

        registerChangeListener(control.widthProperty(), e -&gt; clipRect.setWidth(getSkinnable().getWidth()));
        registerChangeListener(control.heightProperty(), e -&gt; clipRect.setHeight(<FONT color="#152dc6"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#39',2,'match46-top.html#39',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getSkinnable().getHeight()));
        registerChangeListener(control.pageCountProperty(), e -&gt; resetIndiciesAndNav());
        registerChangeListener(control.pageFactoryProperty(), e -&gt; {
            if (animate &amp;&amp; timeline != null) {
                // If we are in the middle of a page animation.
                // Speedup and finish the animation then update the page factory.
                timeline.setRate</B></FONT>(8);
                timeline.setOnFinished(arg0 -&gt; {
                    resetIndiciesAndNav();
                });
                return;
            }
            resetIndiciesAndNav();
        });

        initializeSwipeAndTouchHandlers();
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /** The size of the gap between number buttons and arrow buttons */
    private final DoubleProperty arrowButtonGap = new StyleableDoubleProperty(60.0) {
        @Override public Object getBean() {
            return PaginationSkin.this;
        }
        @Override public String getName() {
            return &quot;arrowButtonGap&quot;;
        }
        @Override public CssMetaData&lt;Pagination,Number&gt; getCssMetaData() {
            return StyleableProperties.ARROW_BUTTON_GAP;
        }
    };
    private final DoubleProperty arrowButtonGapProperty() {
        return arrowButtonGap;
    }
    private final double getArrowButtonGap() {
        return arrowButtonGap.get();
    }
    private final void setArrowButtonGap(double value) {
        arrowButtonGap.set(value);
    }

    private BooleanProperty arrowsVisible;
    private final void setArrowsVisible(boolean value) { arrowsVisibleProperty().set(value); }
    private final boolean isArrowsVisible() { return arrowsVisible == null ? DEFAULT_ARROW_VISIBLE : arrowsVisible.get(); }
    private final BooleanProperty arrowsVisibleProperty() {
        if (arrowsVisible == null) {
            arrowsVisible = new StyleableBooleanProperty(DEFAULT_ARROW_VISIBLE) {
                @Override
                protected void invalidated() {
                    getSkinnable().requestLayout();
                }

                @Override
                public CssMetaData&lt;Pagination,Boolean&gt; getCssMetaData() {
                    return StyleableProperties.ARROWS_VISIBLE;
                }

                @Override
                public Object getBean() {
                    return PaginationSkin.this;
                }

                @Override
                public String getName() {
                    return &quot;arrowVisible&quot;;
                }
            };
        }
        return arrowsVisible;
    }

    private BooleanProperty pageInformationVisible;
    private final void setPageInformationVisible(boolean value) { pageInformationVisibleProperty().set(value); }
    private final boolean isPageInformationVisible() { return pageInformationVisible == null ? DEFAULT_PAGE_INFORMATION_VISIBLE : pageInformationVisible.get(); }
    private final BooleanProperty pageInformationVisibleProperty() {
        if (pageInformationVisible == null) {
            pageInformationVisible = new StyleableBooleanProperty(DEFAULT_PAGE_INFORMATION_VISIBLE) {
                @Override
                protected void invalidated() {
                    getSkinnable().requestLayout();
                }

                @Override
                public CssMetaData&lt;Pagination,Boolean&gt; getCssMetaData() {
                    return StyleableProperties.PAGE_INFORMATION_VISIBLE;
                }

                @Override
                public Object getBean() {
                    return PaginationSkin.this;
                }

                @Override
                public String getName() {
                    return &quot;pageInformationVisible&quot;;
                }
            };
        }
        return pageInformationVisible;
    }

    private ObjectProperty&lt;Side&gt; pageInformationAlignment;
    private final void setPageInformationAlignment(Side value) { pageInformationAlignmentProperty().set(value); }
    private final Side getPageInformationAlignment() { return pageInformationAlignment == null ? DEFAULT_PAGE_INFORMATION_ALIGNMENT : pageInformationAlignment.get(); }
    private final ObjectProperty&lt;Side&gt; pageInformationAlignmentProperty() {
        if (pageInformationAlignment == null) {
            pageInformationAlignment = new StyleableObjectProperty&lt;Side&gt;(Side.BOTTOM) {
                @Override
                protected void invalidated() {
                    getSkinnable().requestLayout();
                }

                @Override
                public CssMetaData&lt;Pagination,Side&gt; getCssMetaData() {
                    return StyleableProperties.PAGE_INFORMATION_ALIGNMENT;
                }

                @Override
                public Object getBean() {
                    return PaginationSkin.this;
                }

                @Override
                public String getName() {
                    return &quot;pageInformationAlignment&quot;;
                }
            };
        }
        return pageInformationAlignment;
    }

    private BooleanProperty tooltipVisible;
    private final void setTooltipVisible(boolean value) { tooltipVisibleProperty().set(value); }
    private final boolean isTooltipVisible() { return tooltipVisible == null ? DEFAULT_TOOLTIP_VISIBLE : tooltipVisible.get(); }
    private final BooleanProperty tooltipVisibleProperty() {
        if (tooltipVisible == null) {
            tooltipVisible = new StyleableBooleanProperty(DEFAULT_TOOLTIP_VISIBLE) {
                @Override
                protected void invalidated() {
                    getSkinnable().requestLayout();
                }

                @Override
                public CssMetaData&lt;Pagination,Boolean&gt; getCssMetaData() {
                    return StyleableProperties.TOOLTIP_VISIBLE;
                }

                @Override
                public Object getBean() {
                    return PaginationSkin.this;
                }

                @Override
                public String getName() {
                    return &quot;tooltipVisible&quot;;
                }
            };
        }
        return tooltipVisible;
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        double navigationWidth = navigation.isVisible() ? snapSizeX(navigation.minWidth(height)) : 0;
        return leftInset + Math.max(currentStackPane.minWidth(height), navigationWidth) + rightInset;
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        double navigationHeight = navigation.isVisible() ? snapSizeY(navigation.minHeight(width)) : 0;
        return topInset + currentStackPane.minHeight(width) + navigationHeight + bottomInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        double navigationWidth = navigation.isVisible() ? snapSizeX(navigation.prefWidth(height)) : 0;
        return leftInset + Math.max(currentStackPane.prefWidth(height), navigationWidth) + rightInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        double navigationHeight = navigation.isVisible() ? snapSizeY(navigation.prefHeight(width)) : 0;
        return topInset + currentStackPane.prefHeight(width) + navigationHeight + bottomInset;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        double navigationHeight = navigation.isVisible() ? snapSizeY(navigation.prefHeight(-1)) : 0;
        double stackPaneHeight = snapSizeY(h - navigationHeight);

        layoutInArea(currentStackPane, x, y, w, stackPaneHeight, 0, HPos.CENTER, VPos.CENTER);
        layoutInArea(nextStackPane, x, y, w, stackPaneHeight, 0, HPos.CENTER, VPos.CENTER);
        layoutInArea(navigation, x, stackPaneHeight, w, navigationHeight, 0, HPos.CENTER, VPos.CENTER);
    }

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case FOCUS_ITEM: return navigation.indicatorButtons.getSelectedToggle();
            case ITEM_COUNT: return navigation.indicatorButtons.getToggles().size();
            case ITEM_AT_INDEX: {
                Integer index = (Integer)parameters[0];
                if (index == null) return null;
                return navigation.indicatorButtons.getToggles().get(index);
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private void selectNext() {
        if (getCurrentPageIndex() &lt; getPageCount() - 1) {
            pagination.setCurrentPageIndex(getCurrentPageIndex() + 1);
        }
    }

    private void selectPrevious() {
        if (getCurrentPageIndex() &gt; 0) {
            pagination.setCurrentPageIndex(getCurrentPageIndex() - 1);
        }
    }

    private void resetIndiciesAndNav() {
        resetIndexes(false);
        navigation.initializePageIndicators();
        navigation.updatePageIndicators();
    }

    private void initializeSwipeAndTouchHandlers() {
        final Pagination control = getSkinnable();

        getSkinnable().addEventHandler(TouchEvent.TOUCH_PRESSED, e -&gt; {
            if (touchEventId == -1) {
                touchEventId = e.getTouchPoint().getId();
            }
            if (touchEventId != e.getTouchPoint().getId()) {
                return;
            }
            lastTouchPos = startTouchPos = e.getTouchPoint().getX();
            lastTouchTime = startTouchTime = System.currentTimeMillis();
            touchThresholdBroken = false;
            e.consume();
        });

        getSkinnable().addEventHandler(TouchEvent.TOUCH_MOVED, e -&gt; {
            if (touchEventId != e.getTouchPoint().getId()) {
                return;
            }

            double drag = e.getTouchPoint().getX() - lastTouchPos;
            long time = System.currentTimeMillis() - lastTouchTime;
            touchVelocity = drag/time;
            lastTouchPos = e.getTouchPoint().getX();
            lastTouchTime = System.currentTimeMillis();
            double delta = e.getTouchPoint().getX() - startTouchPos;

            if (!touchThresholdBroken &amp;&amp; Math.abs(delta) &gt; TOUCH_THRESHOLD) {
                touchThresholdBroken = true;
            }

            if (touchThresholdBroken) {
                double width = control.getWidth() - (snappedLeftInset() + snappedRightInset());
                double currentPaneX;
                double nextPaneX;

                if (!setInitialDirection) {
                    // Remember the direction travelled so we can
                    // load the next or previous page if the touch is not released.
                    setInitialDirection = true;
                    direction = delta &lt; 0 ? 1 : -1;
                }
                if (delta &lt; 0) {
                    if (direction == -1) {
                        nextStackPane.getChildren().clear();
                        direction = 1;
                    }
                    // right to left
                    if (Math.abs(delta) &lt;= width) {
                        currentPaneX = delta;
                        nextPaneX = width + delta;
                        nextPageReached = false;
                    } else {
                        currentPaneX = -width;
                        nextPaneX = 0;
                        nextPageReached = true;
                    }
                    currentStackPane.setTranslateX(currentPaneX);
                    if (getCurrentPageIndex() &lt; getPageCount() - 1) {
                        createPage(nextStackPane, currentIndex + 1);
                        nextStackPane.setVisible(true);
                        nextStackPane.setTranslateX(nextPaneX);
                    } else {
                        currentStackPane.setTranslateX(0);
                    }
                } else {
                    // left to right
                    if (direction == 1) {
                        nextStackPane.getChildren().clear();
                        direction = -1;
                    }
                    if (Math.abs(delta) &lt;= width) {
                        currentPaneX = delta;
                        nextPaneX = -width + delta;
                        nextPageReached = false;
                    } else {
                        currentPaneX = width;
                        nextPaneX = 0;
                        nextPageReached = true;
                    }
                    currentStackPane.setTranslateX(currentPaneX);
                    if (getCurrentPageIndex() != 0) {
                        createPage(nextStackPane, currentIndex - 1);
                        nextStackPane.setVisible(true);
                        nextStackPane.setTranslateX(nextPaneX);
                    } else {
                        currentStackPane.setTranslateX(0);
                    }
                }
            }
            e.consume();
        });

        getSkinnable().addEventHandler(TouchEvent.TOUCH_RELEASED, e -&gt; {
            if (touchEventId != e.getTouchPoint().getId()) {
                return;
            } else {
                touchEventId = -1;
                setInitialDirection = false;
            }

            if (touchThresholdBroken) {
                // determin if click or swipe
                final double drag = e.getTouchPoint().getX() - startTouchPos;
                // calculate complete time from start to end of drag
                final long time = System.currentTimeMillis() - startTouchTime;
                // if time is less than 300ms then considered a quick swipe and whole time is used
                final boolean quick = time &lt; 300;
                // calculate velocity
                final double velocity = quick ? (double)drag / time : touchVelocity; // pixels/ms
                // calculate distance we would travel at this speed for 500ms of travel
                final double distance = (velocity * 500);
                final double width = control.getWidth() - (snappedLeftInset() + snappedRightInset());

                // The swipe distance travelled.
                final double threshold = Math.abs(distance/width);
                // The touch and dragged distance travelled.
                final double delta = Math.abs(drag/width);
                if (threshold &gt; SWIPE_THRESHOLD || delta &gt; SWIPE_THRESHOLD) {
                    if (startTouchPos &gt; e.getTouchPoint().getX()) {
                        selectNext();
                    } else {
                        selectPrevious();
                    }
                } else {
                    animateClamping(startTouchPos &gt; e.getTouchPoint().getSceneX());
                }
            }
            e.consume();
        });
    }

    private void resetIndexes(boolean usePageIndex) {
        maxPageIndicatorCount = getMaxPageIndicatorCount();
        // Used to indicate that we can change a set of pages.
        pageCount = getPageCount();
        if (pageCount &gt; maxPageIndicatorCount) {
            pageCount = maxPageIndicatorCount;
        }

        fromIndex = 0;
        previousIndex = 0;
        currentIndex = usePageIndex ? getCurrentPageIndex() : 0;
        toIndex = pageCount - 1;

        if (pageCount == Pagination.INDETERMINATE &amp;&amp; maxPageIndicatorCount == Pagination.INDETERMINATE) {
            // We do not know how many indicators  can fit.  Let the layout pass compute it.
            toIndex = 0;
        }

        boolean isAnimate = animate;
        if (isAnimate) {
            animate = false;
        }
<A NAME="47"></A>
        // Remove the children in the pane before we create a new page.
        currentStackPane.getChildren().clear();
        <FONT color="#d16587"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#47',2,'match46-top.html#47',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>nextStackPane.getChildren().clear();

        pagination.setCurrentPageIndex(currentIndex);
        createPage(currentStackPane, currentIndex);

        if (isAnimate) {
            animate = true;
        }
    }</B></FONT>

    private boolean createPage(StackPane pane, int index) {
        if (pagination.getPageFactory() != null &amp;&amp; pane.getChildren().isEmpty()) {
            Node content = pagination.getPageFactory().call(index);
            // If the content is null we don't want to switch pages.
            if (content != null) {
                pane.getChildren().setAll(content);
                return true;
            } else {
                // Disable animation if the new page does not exist.  It is strange to
                // see the same page animated out then in.
                boolean isAnimate = animate;
                if (isAnimate) {
                    animate = false;
                }

                if (pagination.getPageFactory().call(previousIndex) != null) {
                    pagination.setCurrentPageIndex(previousIndex);
                } else {
                    // Set the page index to 0 because both the current,
                    // and the previous pages have no content.
                    pagination.setCurrentPageIndex(0);
                }

                if (isAnimate) {
                    animate = true;
                }
                return false;
            }
        }
        return false;
    }

    private int getPageCount() {
        if (getSkinnable().getPageCount() &lt; 1) {
            return 1;
        }
        return getSkinnable().getPageCount();
    }

    private int getMaxPageIndicatorCount() {
        return getSkinnable().getMaxPageIndicatorCount();
    }

    private int getCurrentPageIndex() {
        return getSkinnable().getCurrentPageIndex();
    }

    private void animateSwitchPage() {
        if (timeline != null) {
            timeline.setRate(8);
            hasPendingAnimation = true;
            return;
        }

        // We are handling a touch event if nextPane's page has already been
        // created and visible == true.
        if (!nextStackPane.isVisible()) {
            if (!createPage(nextStackPane, currentAnimatedIndex)) {
                // The next page does not exist just return without starting
                // any animation.
                return;
            }
        }
        if (nextPageReached) {
            // No animation is needed when the next page is already showing
            // and in the correct position.  Just swap the panes and return
            swapPanes();
            nextPageReached = false;
            return;
        }

        nextStackPane.setCache(true);
        currentStackPane.setCache(true);

        // wait one pulse then animate
        Platform.runLater(() -&gt; {
            // We are handling a touch event if nextPane's translateX is not 0
            boolean useTranslateX = nextStackPane.getTranslateX() != 0;
            if (currentAnimatedIndex &gt; previousIndex) {  // animate right to left
                if (!useTranslateX) {
                    nextStackPane.setTranslateX(currentStackPane.getWidth());
                }
                nextStackPane.setVisible(true);
                timeline = new Timeline();
                KeyFrame k1 =  new KeyFrame(Duration.millis(0),
                    new KeyValue(currentStackPane.translateXProperty(),
                        useTranslateX ? currentStackPane.getTranslateX() : 0,
                        interpolator),
                    new KeyValue(nextStackPane.translateXProperty(),
                        useTranslateX ?
                            nextStackPane.getTranslateX() : currentStackPane.getWidth(), interpolator));
                KeyFrame k2 = new KeyFrame(DURATION,
                    swipeAnimationEndEventHandler,
                    new KeyValue(currentStackPane.translateXProperty(), -currentStackPane.getWidth(), interpolator),
                    new KeyValue(nextStackPane.translateXProperty(), 0, interpolator));
                timeline.getKeyFrames().setAll(k1, k2);
                timeline.play();
            } else { // animate left to right
                if (!useTranslateX) {
                    nextStackPane.setTranslateX(-currentStackPane.getWidth());
                }
                nextStackPane.setVisible(true);
                timeline = new Timeline();
                KeyFrame k1 = new KeyFrame(Duration.millis(0),
                    new KeyValue(currentStackPane.translateXProperty(),
                        useTranslateX ? currentStackPane.getTranslateX() : 0,
                        interpolator),
                    new KeyValue(nextStackPane.translateXProperty(),
                        useTranslateX ? nextStackPane.getTranslateX() : -currentStackPane.getWidth(),
                        interpolator));
                KeyFrame k2 = new KeyFrame(DURATION,
                    swipeAnimationEndEventHandler,
                    new KeyValue(currentStackPane.translateXProperty(), currentStackPane.getWidth(), interpolator),
                    new KeyValue(nextStackPane.translateXProperty(), 0, interpolator));
                timeline.getKeyFrames().setAll(k1, k2);
                timeline.play();
            }
        });
    }

    private void swapPanes() {
        StackPane temp = currentStackPane;
        currentStackPane = nextStackPane;
        nextStackPane = temp;

        currentStackPane.setTranslateX(0);
        currentStackPane.setCache(false);

        nextStackPane.setTranslateX(0);
        nextStackPane.setCache(false);
        nextStackPane.setVisible(false);
        nextStackPane.getChildren().clear();
    }

    // If the swipe hasn't reached the THRESHOLD we want to animate the clamping.
    private void animateClamping(boolean rightToLeft) {
<A NAME="10"></A>        if (rightToLeft) {  // animate right to left
            timeline = new Timeline();
            KeyFrame k1 = new KeyFrame(Duration.millis(0),
                new KeyValue(<FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#10',2,'match46-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>currentStackPane.translateXProperty(), currentStackPane.getTranslateX(), interpolator),
                new KeyValue(nextStackPane.translateXProperty(), nextStackPane.getTranslateX(), interpolator));
            KeyFrame k2 = new KeyFrame(DURATION,
                clampAnimationEndEventHandler,
                new KeyValue(currentStackPane.translateXProperty(), 0, interpolator),
                new KeyValue(nextStackPane.translateXProperty(), currentStackPane.getWidth(), interpolator));
            timeline.getKeyFrames().setAll(k1, k2);
            timeline.play</B></FONT>();
        } else { // animate left to right
            timeline = new Timeline();
            KeyFrame k1 = new KeyFrame(Duration.millis(0),
                new KeyValue(currentStackPane.translateXProperty(), currentStackPane.getTranslateX(), interpolator),
                new KeyValue(nextStackPane.translateXProperty(), nextStackPane.getTranslateX(), interpolator));
            KeyFrame k2 = new KeyFrame(DURATION,
                clampAnimationEndEventHandler,
                new KeyValue(currentStackPane.translateXProperty(), 0, interpolator),
                new KeyValue(nextStackPane.translateXProperty(), -currentStackPane.getWidth(), interpolator));
            timeline.getKeyFrames().setAll(k1, k2);
            timeline.play();
        }
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    class NavigationControl extends StackPane {

        private HBox controlBox;
        private Button leftArrowButton;
        private StackPane leftArrow;
        private Button rightArrowButton;
        private StackPane rightArrow;
        private ToggleGroup indicatorButtons;
        private Label pageInformation;
        private double minButtonSize = -1;

        public NavigationControl() {
            getStyleClass().setAll(&quot;pagination-control&quot;);

            // redirect mouse events to behavior
            addEventHandler(MouseEvent.MOUSE_PRESSED, behavior::mousePressed);

            controlBox = new HBox();
            controlBox.getStyleClass().add(&quot;control-box&quot;);

            leftArrowButton = new Button();
            leftArrowButton.setAccessibleText(getString(&quot;Accessibility.title.Pagination.PreviousButton&quot;));
            minButtonSize = leftArrowButton.getFont().getSize() * 2;
            leftArrowButton.fontProperty().addListener((arg0, arg1, newFont) -&gt; {
                minButtonSize = newFont.getSize() * 2;
                for(Node child: controlBox.getChildren()) {
                    ((Control)child).setMinSize(minButtonSize, minButtonSize);
                }
                // We want to relayout the indicator buttons because the size has changed.
                requestLayout();
            });
            leftArrowButton.setMinSize(minButtonSize, minButtonSize);
            leftArrowButton.prefWidthProperty().bind(leftArrowButton.minWidthProperty());
            leftArrowButton.prefHeightProperty().bind(leftArrowButton.minHeightProperty());
            leftArrowButton.getStyleClass().add(&quot;left-arrow-button&quot;);
            leftArrowButton.setFocusTraversable(false);
            HBox.setMargin(leftArrowButton, new Insets(0, snapSize(arrowButtonGap.get()), 0, 0));
            leftArrow = new StackPane();
            leftArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
            leftArrowButton.setGraphic(leftArrow);
            leftArrow.getStyleClass().add(&quot;left-arrow&quot;);

            rightArrowButton = new Button();
            rightArrowButton.setAccessibleText(getString(&quot;Accessibility.title.Pagination.NextButton&quot;));
            rightArrowButton.setMinSize(minButtonSize, minButtonSize);
            rightArrowButton.prefWidthProperty().bind(rightArrowButton.minWidthProperty());
            rightArrowButton.prefHeightProperty().bind(rightArrowButton.minHeightProperty());
            rightArrowButton.getStyleClass().add(&quot;right-arrow-button&quot;);
            rightArrowButton.setFocusTraversable(false);
            HBox.setMargin(rightArrowButton, new Insets(0, 0, 0, snapSize(arrowButtonGap.get())));
            rightArrow = new StackPane();
            rightArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
            rightArrowButton.setGraphic(rightArrow);
            rightArrow.getStyleClass().add(&quot;right-arrow&quot;);

            indicatorButtons = new ToggleGroup();

            pageInformation = new Label();
            pageInformation.getStyleClass().add(&quot;page-information&quot;);

            getChildren().addAll(controlBox, pageInformation);
            initializeNavigationHandlers();
            initializePageIndicators();
            updatePageIndex();

            // listen to changes to arrowButtonGap and update margins
            arrowButtonGap.addListener((observable, oldValue, newValue) -&gt; {
                if (newValue.doubleValue() == 0) {
                    HBox.setMargin(leftArrowButton, null);
                    HBox.setMargin(rightArrowButton, null);

                } else {
                    HBox.setMargin(leftArrowButton, new Insets(0, snapSize(newValue.doubleValue()), 0, 0));
                    HBox.setMargin(rightArrowButton, new Insets(0, 0, 0, snapSize(newValue.doubleValue())));
                }
            });
        }

        private void initializeNavigationHandlers() {
            leftArrowButton.setOnAction(arg0 -&gt; {
                getNode().requestFocus();
                selectPrevious();
                requestLayout();
            });

            rightArrowButton.setOnAction(arg0 -&gt; {
                getNode().requestFocus();
                selectNext();
                requestLayout();
            });

            pagination.currentPageIndexProperty().addListener((arg0, arg1, arg2) -&gt; {
                previousIndex = arg1.intValue();
                currentIndex = arg2.intValue();
                updatePageIndex();
                if (animate) {
                    currentAnimatedIndex = currentIndex;
                    animateSwitchPage();
                } else {
                    createPage(currentStackPane, currentIndex);
                }
            });
        }

        // Create the indicators using fromIndex and toIndex.
        private void initializePageIndicators() {
            previousIndicatorCount = 0;
            controlBox.getChildren().clear();
            clearIndicatorButtons();

            controlBox.getChildren().add(leftArrowButton);
            for (int i = fromIndex; i &lt;= toIndex; i++) {
                IndicatorButton ib = new IndicatorButton(i);
                ib.setMinSize(minButtonSize, minButtonSize);
                ib.setToggleGroup(indicatorButtons);
                controlBox.getChildren().add(ib);
            }
            controlBox.getChildren().add(rightArrowButton);
        }

        private void clearIndicatorButtons() {
            for (Toggle toggle : indicatorButtons.getToggles()) {
                if (toggle instanceof IndicatorButton) {
                    IndicatorButton indicatorButton = (IndicatorButton) toggle;
                    indicatorButton.release();
                }
            }
            indicatorButtons.getToggles().clear();
        }

        // Finds and selects the IndicatorButton using the currentIndex.
         private void updatePageIndicators() {
            for (int i = 0; i &lt; indicatorButtons.getToggles().size(); i++) {
                IndicatorButton ib = (IndicatorButton)indicatorButtons.getToggles().get(i);
                if (ib.getPageNumber() == currentIndex) {
                    ib.setSelected(true);
                    updatePageInformation();
                    break;
                }
            }
            getSkinnable().notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
        }

        // Update the page index using the currentIndex and updates the page set
        // if necessary.
        private void updatePageIndex() {
            //System.out.println(&quot;SELECT PROPERTY FROM &quot; + fromIndex + &quot; TO &quot; + toIndex + &quot; PREVIOUS &quot; + previousIndex + &quot; CURRENT &quot;+ currentIndex + &quot; PAGE COUNT &quot; + pageCount + &quot; MAX PAGE INDICATOR COUNT &quot; + maxPageIndicatorCount);
            if (pageCount == maxPageIndicatorCount) {
                if (changePageSet()) {
                    initializePageIndicators();
                }
            }
            updatePageIndicators();
            requestLayout();
        }

        private void updatePageInformation() {
            String currentPageNumber = Integer.toString(currentIndex + 1);
            String lastPageNumber = getPageCount() == Pagination.INDETERMINATE ? &quot;...&quot; : Integer.toString(getPageCount());
            pageInformation.setText(currentPageNumber + &quot;/&quot; + lastPageNumber);
        }

        private int previousIndicatorCount = 0;
        // Layout the maximum number of page indicators we can fit within the width.
        // And always show the selected indicator.
        private void layoutPageIndicators() {
            final double left = snappedLeftInset();
            final double right = snappedRightInset();
            final double width = snapSize(getWidth()) - (left + right);
            final double controlBoxleft = controlBox.snappedLeftInset();
            final double controlBoxRight = controlBox.snappedRightInset();
            final double leftArrowWidth = snapSize(Utils.boundedSize(leftArrowButton.prefWidth(-1), leftArrowButton.minWidth(-1), leftArrowButton.maxWidth(-1)));
            final double rightArrowWidth = snapSize(Utils.boundedSize(rightArrowButton.prefWidth(-1), rightArrowButton.minWidth(-1), rightArrowButton.maxWidth(-1)));
            final double spacing = snapSize(controlBox.getSpacing());
            double w = width - (controlBoxleft + leftArrowWidth + 2* arrowButtonGap.get() + spacing + rightArrowWidth + controlBoxRight);

            if (isPageInformationVisible() &amp;&amp;
                    (Side.LEFT.equals(getPageInformationAlignment()) ||
                    Side.RIGHT.equals(getPageInformationAlignment()))) {
                w -= snapSize(pageInformation.prefWidth(-1));
            }

            double x = 0;
            int indicatorCount = 0;
            for (int i = 0; i &lt; getMaxPageIndicatorCount(); i++) {
                int index = i &lt; indicatorButtons.getToggles().size() ? i : indicatorButtons.getToggles().size() - 1;
                double iw = minButtonSize;
                if (index != -1) {
                    IndicatorButton ib = (IndicatorButton)indicatorButtons.getToggles().get(index);
                    iw = snapSize(Utils.boundedSize(ib.prefWidth(-1), ib.minWidth(-1), ib.maxWidth(-1)));
                }

                x += (iw + spacing);
                if (x &gt; w) {
                    break;
                }
                indicatorCount++;
            }
            if (indicatorCount == 0) {
               indicatorCount = 1; // The parent didn't respect the minSize of this Pagination.
                                   // We will show at least one indicator nonetheless.
            }

            if (indicatorCount != previousIndicatorCount) {
                if (indicatorCount &lt; getMaxPageIndicatorCount()) {
                    maxPageIndicatorCount = indicatorCount;
                } else {
                    maxPageIndicatorCount = getMaxPageIndicatorCount();
                }

                int lastIndicatorButtonIndex;
                if (pageCount &gt; maxPageIndicatorCount) {
                    pageCount = maxPageIndicatorCount;
                    lastIndicatorButtonIndex = maxPageIndicatorCount - 1;
                 } else {
                    if (indicatorCount &gt; getPageCount()) {
                        pageCount = getPageCount();
                        lastIndicatorButtonIndex = getPageCount() - 1;
                    } else {
                        pageCount = indicatorCount;
                        lastIndicatorButtonIndex = indicatorCount - 1;
                    }
                }

                if (currentIndex &gt;= toIndex) {
                    // The current index has fallen off the right
                    toIndex = currentIndex;
                    fromIndex = toIndex - lastIndicatorButtonIndex;
                } else if (currentIndex &lt;= fromIndex) {
                    // The current index has fallen off the left
                    fromIndex = currentIndex;
                    toIndex = fromIndex + lastIndicatorButtonIndex;
                } else {
                    toIndex = fromIndex + lastIndicatorButtonIndex;
                }

                if (toIndex &gt; getPageCount() - 1) {
                    toIndex = getPageCount() - 1;
                    //fromIndex = toIndex - lastIndicatorButtonIndex;
                }

                if (fromIndex &lt; 0) {
                    fromIndex = 0;
                    toIndex = fromIndex + lastIndicatorButtonIndex;
                }

                initializePageIndicators();
                updatePageIndicators();
                previousIndicatorCount = indicatorCount;
            }
        }

        // Only change to the next set when the current index is at the start or the end of the set.
        // Return true only if we have scrolled to the next/previous set.
        private boolean changePageSet() {
            int index = indexToIndicatorButtonsIndex(currentIndex);
            int lastIndicatorButtonIndex = maxPageIndicatorCount - 1;
            if (previousIndex &lt; currentIndex &amp;&amp;
                    index == 0 &amp;&amp;
                    lastIndicatorButtonIndex != 0 &amp;&amp;
                    index % lastIndicatorButtonIndex == 0) {
                // Get the right page set
                fromIndex = currentIndex;
                toIndex = fromIndex + lastIndicatorButtonIndex;
            } else if (currentIndex &lt; previousIndex &amp;&amp;
                    index == lastIndicatorButtonIndex &amp;&amp;
                    lastIndicatorButtonIndex != 0 &amp;&amp;
                    index % lastIndicatorButtonIndex == 0) {
                // Get the left page set
                toIndex = currentIndex;
                fromIndex = toIndex - lastIndicatorButtonIndex;
            } else {
                // We need to get the new page set if the currentIndex is out of range.
                // This can happen if setPageIndex() is called programatically.
                if (currentIndex &lt; fromIndex || currentIndex &gt; toIndex) {
                    fromIndex = currentIndex - index;
                    toIndex = fromIndex + lastIndicatorButtonIndex;
                } else {
                    return false;
                }
            }

            // We have gone past the total number of pages
            if (toIndex &gt; getPageCount() - 1) {
                if (fromIndex &gt; getPageCount() - 1) {
                    return false;
                } else {
                  toIndex = getPageCount() - 1;
                  //fromIndex = toIndex - lastIndicatorButtonIndex;
                }
            }

            // We have gone past the starting page
            if (fromIndex &lt; 0) {
                fromIndex = 0;
                toIndex = fromIndex + lastIndicatorButtonIndex;
            }
            return true;
        }

        private int indexToIndicatorButtonsIndex(int index) {
            // This should be in the indicator buttons toggle list.
            if (index &gt;= fromIndex &amp;&amp; index &lt;= toIndex) {
                return index - fromIndex;
            }
            // The requested index is not in indicator buttons list we have to predict
            // where the index will be.
            int i = 0;
            int from = fromIndex;
            int to = toIndex;
            if (currentIndex &gt; previousIndex) {
                while(from &lt; getPageCount() &amp;&amp; to &lt; getPageCount()) {
                    from += i;
                    to += i;
                    if (index &gt;= from &amp;&amp; index &lt;= to) {
                        if (index == from) {
                            return 0;
                        } else if (index == to) {
                            return maxPageIndicatorCount - 1;
                        }
                        return index - from;
                    }
                    i += maxPageIndicatorCount;
                }
            } else {
                while (from &gt; 0 &amp;&amp; to &gt; 0) {
                    from -= i;
                    to -= i;
                    if (index &gt;= from &amp;&amp; index &lt;= to) {
                        if (index == from) {
                            return 0;
                        } else if (index == to) {
                            return maxPageIndicatorCount - 1;
                        }
                        return index - from;
                    }
                    i += maxPageIndicatorCount;
                }
            }
            // We are on the last page set going back to the previous page set
            return maxPageIndicatorCount - 1;
        }

        private Pos sideToPos(Side s) {
            if (Side.TOP.equals(s)) {
                return Pos.TOP_CENTER;
            } else if (Side.RIGHT.equals(s)) {
                return Pos.CENTER_RIGHT;
            } else if (Side.BOTTOM.equals(s)) {
                return Pos.BOTTOM_CENTER;
            }
            return Pos.CENTER_LEFT;
        }

        @Override protected double computeMinWidth(double height) {
            double left = snappedLeftInset();
            double right = snappedRightInset();
            double leftArrowWidth = snapSize(Utils.boundedSize(leftArrowButton.prefWidth(-1), leftArrowButton.minWidth(-1), leftArrowButton.maxWidth(-1)));
            double rightArrowWidth = snapSize(Utils.boundedSize(rightArrowButton.prefWidth(-1), rightArrowButton.minWidth(-1), rightArrowButton.maxWidth(-1)));
            double spacing = snapSize(controlBox.getSpacing());
            double pageInformationWidth = 0;
            Side side = getPageInformationAlignment();
            if (Side.LEFT.equals(side) || Side.RIGHT.equals(side)) {
                pageInformationWidth = snapSize(pageInformation.prefWidth(-1));
            }
            double arrowGap = arrowButtonGap.get();

            return left + leftArrowWidth + 2 *arrowGap + minButtonSize /*at least one button*/
                    + 2 * spacing + rightArrowWidth + right + pageInformationWidth;
        }

        @Override protected double computeMinHeight(double width) {
            return computePrefHeight(width);
        }

        @Override protected double computePrefWidth(double height) {
            final double left = snappedLeftInset();
            final double right = snappedRightInset();
            final double controlBoxWidth = snapSize(controlBox.prefWidth(height));
            double pageInformationWidth = 0;
            Side side = getPageInformationAlignment();
            if (Side.LEFT.equals(side) || Side.RIGHT.equals(side)) {
                pageInformationWidth = snapSize(pageInformation.prefWidth(-1));
            }

            return left + controlBoxWidth + right + pageInformationWidth;
        }

        @Override protected double computePrefHeight(double width) {
            final double top = snappedTopInset();
            final double bottom = snappedBottomInset();
            final double boxHeight = snapSize(controlBox.prefHeight(width));
            double pageInformationHeight = 0;
            Side side = getPageInformationAlignment();
            if (Side.TOP.equals(side) || Side.BOTTOM.equals(side)) {
                pageInformationHeight = snapSize(pageInformation.prefHeight(-1));
            }

            return top + boxHeight + pageInformationHeight + bottom;
        }

        @Override protected void layoutChildren() {
            final double top = snappedTopInset();
            final double bottom = snappedBottomInset();
            final double left = snappedLeftInset();
            final double right = snappedRightInset();
            final double width = snapSize(getWidth()) - (left + right);
            final double height = snapSize(getHeight()) - (top + bottom);
            final double controlBoxWidth = snapSize(controlBox.prefWidth(-1));
            final double controlBoxHeight = snapSize(controlBox.prefHeight(-1));
            final double pageInformationWidth = snapSize(pageInformation.prefWidth(-1));
            final double pageInformationHeight = snapSize(pageInformation.prefHeight(-1));

            leftArrowButton.setDisable(false);
            rightArrowButton.setDisable(false);

            if (currentIndex == 0) {
                // Grey out the left arrow if we are at the beginning.
                leftArrowButton.setDisable(true);
            }
            if (currentIndex == (getPageCount() - 1)) {
                // Grey out the right arrow if we have reached the end.
                rightArrowButton.setDisable(true);
            }
            // Reapply CSS so the left and right arrow button's disable state is updated
            // immediately.
            applyCss();

            leftArrowButton.setVisible(isArrowsVisible());
            rightArrowButton.setVisible(isArrowsVisible());
            pageInformation.setVisible(isPageInformationVisible());

            // Determine the number of indicators we can fit within the pagination width.
            layoutPageIndicators();

            HPos controlBoxHPos = controlBox.getAlignment().getHpos();
            VPos controlBoxVPos = controlBox.getAlignment().getVpos();
            double controlBoxX = left + Utils.computeXOffset(width, controlBoxWidth, controlBoxHPos);
            double controlBoxY = top + Utils.computeYOffset(height, controlBoxHeight, controlBoxVPos);

            if (isPageInformationVisible()) {
                Pos p = sideToPos(getPageInformationAlignment());
                HPos pageInformationHPos = p.getHpos();
                VPos pageInformationVPos = p.getVpos();
                double pageInformationX = left + Utils.computeXOffset(width, pageInformationWidth, pageInformationHPos);
                double pageInformationY = top + Utils.computeYOffset(height, pageInformationHeight, pageInformationVPos);

                if (Side.TOP.equals(getPageInformationAlignment())) {
                    pageInformationY = top;
                    controlBoxY = top + pageInformationHeight;
                } else if (Side.RIGHT.equals(getPageInformationAlignment())) {
                    pageInformationX = width - right - pageInformationWidth;
                } else if (Side.BOTTOM.equals(getPageInformationAlignment())) {
                    controlBoxY = top;
                    pageInformationY = top + controlBoxHeight;
                } else if (Side.LEFT.equals(getPageInformationAlignment())) {
                    pageInformationX = left;
                }
                layoutInArea(pageInformation, pageInformationX, pageInformationY, pageInformationWidth, pageInformationHeight, 0, pageInformationHPos, pageInformationVPos);
            }

            layoutInArea(controlBox, controlBoxX, controlBoxY, controlBoxWidth, controlBoxHeight, 0, controlBoxHPos, controlBoxVPos);
        }
    }

    class IndicatorButton extends ToggleButton {
        private final ListChangeListener&lt;String&gt; updateSkinIndicatorType =
                                                    c -&gt; setIndicatorType();

        private final ChangeListener&lt;Boolean&gt; updateTooltipVisibility =
                       (ob, oldValue, newValue) -&gt; setTooltipVisible(newValue);

        private int pageNumber;

        public IndicatorButton(int pageNumber) {
            this.pageNumber = pageNumber;
            setFocusTraversable(false);
            setIndicatorType();
            setTooltipVisible(isTooltipVisible());

            getSkinnable().getStyleClass().addListener(updateSkinIndicatorType);

            setOnAction(arg0 -&gt; {
                    getNode().requestFocus();
                    int selected = getCurrentPageIndex();
                    // We do not need to update the selection if it has not changed.
                    if (selected != IndicatorButton.this.pageNumber) {
                        pagination.setCurrentPageIndex(IndicatorButton.this.pageNumber);
                        requestLayout();
                    }
            });

            tooltipVisibleProperty().addListener(updateTooltipVisibility);

            prefHeightProperty().bind(minHeightProperty());
            setAccessibleRole(AccessibleRole.PAGE_ITEM);
        }

        private void setIndicatorType() {
            if (getSkinnable().getStyleClass().contains(Pagination.STYLE_CLASS_BULLET)) {
                getStyleClass().remove(&quot;number-button&quot;);
                getStyleClass().add(&quot;bullet-button&quot;);
                setText(null);

                // Bind the width in addition to the height to ensure the region is square
                prefWidthProperty().bind(minWidthProperty());
            } else {
                getStyleClass().remove(&quot;bullet-button&quot;);
                getStyleClass().add(&quot;number-button&quot;);
                setText(Integer.toString(this.pageNumber + 1));

                // Free the width to conform to the text content
                prefWidthProperty().unbind();
            }
        }

        private void setTooltipVisible(boolean b) {
            if (b) {
                setTooltip(new Tooltip(Integer.toString(IndicatorButton.this.pageNumber + 1)));
            } else {
                setTooltip(null);
            }
        }

        public int getPageNumber() {
            return this.pageNumber;
        }

        @Override public void fire() {
            // we don't toggle from selected to not selected if part of a group
            if (getToggleGroup() == null || !isSelected()) {
                super.fire();
            }
        }

        public void release() {
            getSkinnable().getStyleClass().removeListener(updateSkinIndicatorType);
            tooltipVisibleProperty().removeListener(updateTooltipVisibility);
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case TEXT: return getText();
                case SELECTED: return isSelected();
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }

        /** {@inheritDoc} */
        @Override
        public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
            switch (action) {
                case REQUEST_FOCUS:
                    getSkinnable().setCurrentPageIndex(pageNumber);
                    break;
                default: super.executeAccessibleAction(action);
            }
        }
    }

    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/

    private static final Boolean DEFAULT_ARROW_VISIBLE = Boolean.FALSE;
    private static final Boolean DEFAULT_PAGE_INFORMATION_VISIBLE = Boolean.FALSE;
    private static final Side DEFAULT_PAGE_INFORMATION_ALIGNMENT = Side.BOTTOM;
    private static final Boolean DEFAULT_TOOLTIP_VISIBLE = Boolean.FALSE;

    private static class StyleableProperties {
        private static final CssMetaData&lt;Pagination,Boolean&gt; ARROWS_VISIBLE =
            new CssMetaData&lt;Pagination,Boolean&gt;(&quot;-fx-arrows-visible&quot;,
                BooleanConverter.getInstance(), DEFAULT_ARROW_VISIBLE) {

            @Override
            public boolean isSettable(Pagination n) {
                final PaginationSkin skin = (PaginationSkin) n.getSkin();
                return skin.arrowsVisible == null || !skin.arrowsVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Pagination n) {
                final PaginationSkin skin = (PaginationSkin) n.getSkin();
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)skin.arrowsVisibleProperty();
            }
        };

        private static final CssMetaData&lt;Pagination,Boolean&gt; PAGE_INFORMATION_VISIBLE =
            new CssMetaData&lt;Pagination,Boolean&gt;(&quot;-fx-page-information-visible&quot;,
                BooleanConverter.getInstance(), DEFAULT_PAGE_INFORMATION_VISIBLE) {

            @Override
            public boolean isSettable(Pagination n) {
                final PaginationSkin skin = (PaginationSkin) n.getSkin();
                return skin.pageInformationVisible == null || !skin.pageInformationVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Pagination n) {
                final PaginationSkin skin = (PaginationSkin) n.getSkin();
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)skin.pageInformationVisibleProperty();
            }
        };

        private static final CssMetaData&lt;Pagination,Side&gt; PAGE_INFORMATION_ALIGNMENT =
            new CssMetaData&lt;Pagination,Side&gt;(&quot;-fx-page-information-alignment&quot;,
                new EnumConverter&lt;Side&gt;(Side.class), DEFAULT_PAGE_INFORMATION_ALIGNMENT) {

            @Override
            public boolean isSettable(Pagination n) {
                final PaginationSkin skin = (PaginationSkin) n.getSkin();
                return skin.pageInformationAlignment == null || !skin.pageInformationAlignment.isBound();
            }

            @Override
            public StyleableProperty&lt;Side&gt; getStyleableProperty(Pagination n) {
                final PaginationSkin skin = (PaginationSkin) n.getSkin();
                return (StyleableProperty&lt;Side&gt;)(WritableValue&lt;Side&gt;)skin.pageInformationAlignmentProperty();
            }
        };

        private static final CssMetaData&lt;Pagination,Boolean&gt; TOOLTIP_VISIBLE =
            new CssMetaData&lt;Pagination,Boolean&gt;(&quot;-fx-tooltip-visible&quot;,
                BooleanConverter.getInstance(), DEFAULT_TOOLTIP_VISIBLE) {

            @Override
            public boolean isSettable(Pagination n) {
                final PaginationSkin skin = (PaginationSkin) n.getSkin();
                return skin.tooltipVisible == null || !skin.tooltipVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Pagination n) {
                final PaginationSkin skin = (PaginationSkin) n.getSkin();
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)skin.tooltipVisibleProperty();
            }
        };
        private static final CssMetaData&lt;Pagination,Number&gt; ARROW_BUTTON_GAP =
            new CssMetaData&lt;Pagination,Number&gt;(&quot;-fx-arrow-button-gap&quot;, SizeConverter.getInstance(), 4) {
                @Override public boolean isSettable(Pagination n) {
                    final PaginationSkin skin = (PaginationSkin) n.getSkin();
                    return skin.arrowButtonGap == null ||
                            !skin.arrowButtonGap.isBound();
                }
                @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(Pagination n) {
                    final PaginationSkin skin = (PaginationSkin) n.getSkin();
                    return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)skin.arrowButtonGapProperty();
                }
            };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
            styleables.add(ARROWS_VISIBLE);
            styleables.add(PAGE_INFORMATION_VISIBLE);
            styleables.add(PAGE_INFORMATION_ALIGNMENT);
            styleables.add(TOOLTIP_VISIBLE);
            styleables.add(ARROW_BUTTON_GAP);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * Returns the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/RadioButtonSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.behavior.BehaviorBase;
import com.sun.javafx.scene.control.behavior.ToggleButtonBehavior;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.scene.Node;
import javafx.scene.control.Accordion;
import javafx.scene.control.Button;
import javafx.scene.control.Control;
import javafx.scene.control.RadioButton;
import javafx.scene.layout.StackPane;

/**
 * Default skin implementation for the {@link RadioButton} control.
 *
 * @see RadioButton
 * @since 9
 */
public class RadioButtonSkin extends LabeledSkinBase&lt;RadioButton&gt; {

    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    /** The radio contains the &quot;dot&quot;, which is usually a circle */
    private StackPane radio;
    private final BehaviorBase&lt;RadioButton&gt; behavior;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new RadioButtonSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public RadioButtonSkin(RadioButton control) {
        super(control);

        // install default input map for the RadioButton control
        behavior = new ToggleButtonBehavior&lt;&gt;(control);
//        control.setInputMap(behavior.getInputMap());

        radio = createRadio();
        updateChildren();
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected void updateChildren() {
        super.updateChildren();
        if (radio != null) {
            getChildren().add(radio);
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return super.computeMinWidth(height, topInset, rightInset, bottomInset, leftInset) + snapSizeX(radio.minWidth(-1));
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return Math.max(snapSizeY(super.computeMinHeight(width - radio.minWidth(-1), topInset, rightInset, bottomInset, leftInset)),
                topInset + radio.minHeight(-1) + bottomInset);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return super.computePrefWidth(height, topInset, rightInset, bottomInset, leftInset) + snapSizeX(radio.prefWidth(-1));
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return Math.max(snapSizeY(super.computePrefHeight(width - radio.prefWidth(-1), topInset, rightInset, bottomInset, leftInset)),
                topInset + radio.prefHeight(-1) + bottomInset);
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        final RadioButton radioButton = getSkinnable();
        final double radioWidth = radio.prefWidth(-1);
        final double radioHeight = radio.prefHeight(-1);
        final double computeWidth = Math.max(radioButton.prefWidth(-1),radioButton.minWidth(-1));
        final double labelWidth = Math.min(computeWidth - radioWidth, w - snapSizeX(radioWidth));
        final double labelHeight = Math.min(radioButton.prefHeight(labelWidth), h);
        final double maxHeight = Math.max(radioHeight, labelHeight);
        final double xOffset = Utils.computeXOffset(w, labelWidth + radioWidth, radioButton.getAlignment().getHpos()) + x;
        final double yOffset = Utils.computeYOffset(h, maxHeight, radioButton.getAlignment().getVpos()) + y;
<A NAME="5"></A>
        layoutLabelInArea(xOffset + radioWidth, yOffset, labelWidth, maxHeight,  radioButton.getAlignment());
        radio.resize(snapSizeX(radioWidth), snapSizeY(radioHeight));
        positionInArea(radio, xOffset, yOffset, radioWidth, maxHeight, 0, <FONT color="#c8c2a7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#5',2,'match46-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>radioButton.getAlignment().getHpos(), radioButton.getAlignment().getVpos());
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private static StackPane createRadio() {
        StackPane radio = new StackPane();
        radio.getStyleClass</B></FONT>().setAll(&quot;radio&quot;);
        radio.setSnapToPixel(false);
        StackPane region = new StackPane();
        region.getStyleClass().setAll(&quot;dot&quot;);
        radio.getChildren().clear();
        radio.getChildren().addAll(region);
        return radio;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/SliderSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.behavior.BehaviorBase;
import javafx.animation.Transition;
import javafx.geometry.Orientation;
import javafx.geometry.Point2D;
import javafx.geometry.Side;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.chart.NumberAxis;
import javafx.scene.control.Accordion;
import javafx.scene.control.Button;
import javafx.scene.control.Control;
import javafx.scene.control.SkinBase;
import javafx.scene.control.Slider;
import javafx.scene.layout.StackPane;
import javafx.util.Duration;
import javafx.util.StringConverter;

import com.sun.javafx.scene.control.behavior.SliderBehavior;

/**
 * Default skin implementation for the {@link Slider} control.
 *
 * @see Slider
 * @since 9
 */
public class SliderSkin extends SkinBase&lt;Slider&gt; {

    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    /** Track if slider is vertical/horizontal and cause re layout */
//    private boolean horizontal;
    private NumberAxis tickLine = null;
    private double trackToTickGap = 2;

    private boolean showTickMarks;
    private double thumbWidth;
    private double thumbHeight;

    private double trackStart;
    private double trackLength;
    private double thumbTop;
    private double thumbLeft;
    private double preDragThumbPos;
    private Point2D dragStart; // in skin coordinates

    private StackPane thumb;
    private StackPane track;
    private boolean trackClicked = false;
//    private double visibleAmount = 16;

    private final SliderBehavior behavior;

    StringConverter&lt;Number&gt; stringConverterWrapper = new StringConverter&lt;Number&gt;() {
        Slider slider = getSkinnable();
        @Override public String toString(Number object) {
            return(object != null) ? slider.getLabelFormatter().toString(object.doubleValue()) : &quot;&quot;;
        }
        @Override public Number fromString(String string) {
            return slider.getLabelFormatter().fromString(string);
        }
    };



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new SliderSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public SliderSkin(Slider control) {
        super(control);

        behavior = new SliderBehavior(control);
//        control.setInputMap(behavior.getInputMap());

        initialize();
        control.requestLayout();
        registerChangeListener(control.minProperty(), e -&gt; {
            if (showTickMarks &amp;&amp; tickLine != null) {
                tickLine.setLowerBound(control.getMin());
            }
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.maxProperty(), e -&gt; {
            if (showTickMarks &amp;&amp; tickLine != null) {
                tickLine.setUpperBound(control.getMax());
            }
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.valueProperty(), e -&gt; {
            // only animate thumb if the track was clicked - not if the thumb is dragged
            positionThumb(trackClicked);
        });
        registerChangeListener(control.orientationProperty(), e -&gt; {
            if (showTickMarks &amp;&amp; tickLine != null) {
                tickLine.setSide(control.getOrientation() == Orientation.VERTICAL ? Side.RIGHT : (control.getOrientation() == null) ? Side.RIGHT: Side.BOTTOM);
            }
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.showTickMarksProperty(), e -&gt; setShowTickMarks(control.isShowTickMarks(), control.isShowTickLabels()));
        registerChangeListener(control.showTickLabelsProperty(), e -&gt; setShowTickMarks(control.isShowTickMarks(), control.isShowTickLabels()));
        registerChangeListener(control.majorTickUnitProperty(), e -&gt; {
            if (tickLine != null) {
                tickLine.setTickUnit(control.getMajorTickUnit());
                getSkinnable().requestLayout();
            }
        });
        registerChangeListener(control.minorTickCountProperty(), e -&gt; {
            if (tickLine != null) {
                tickLine.setMinorTickCount(Math.max(control.getMinorTickCount(), 0) + 1);
                getSkinnable().requestLayout();
            }
        });
        registerChangeListener(control.labelFormatterProperty(), e -&gt; {
            if (tickLine != null) {
                if (control.getLabelFormatter() == null) {
                    tickLine.setTickLabelFormatter(null);
                } else {
                    tickLine.setTickLabelFormatter(stringConverterWrapper);
                    tickLine.requestAxisLayout();
                }
            }
        });
        registerChangeListener(control.snapToTicksProperty(), e -&gt; {
            control.adjustValue(control.getValue());
        });
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        // calculate the available space
        // resize thumb to preferred size
        thumbWidth = snapSizeX(thumb.prefWidth(-1));
        thumbHeight = snapSizeY(thumb.prefHeight(-1));
        thumb.resize(thumbWidth, thumbHeight);
        // we are assuming the is common radius's for all corners on the track
        double trackRadius = track.getBackground() == null ? 0 : track.getBackground().getFills().size() &gt; 0 ?
                track.getBackground().getFills().get(0).getRadii().getTopLeftHorizontalRadius() : 0;

        if (getSkinnable().getOrientation() == Orientation.HORIZONTAL) {
            double tickLineHeight =  (showTickMarks) ? tickLine.prefHeight(-1) : 0;
            double trackHeight = snapSizeY(track.prefHeight(-1));
            double trackAreaHeight = Math.max(trackHeight,thumbHeight);
            double totalHeightNeeded = trackAreaHeight  + ((showTickMarks) ? trackToTickGap+tickLineHeight : 0);
            double startY = y + ((h - totalHeightNeeded)/2); // center slider in available height vertically
            trackLength = snapSizeX(w - thumbWidth);
            trackStart = snapPositionX(x + (thumbWidth/2));
            double trackTop = (int)(startY + ((trackAreaHeight-trackHeight)/2));
            thumbTop = (int)(startY + ((trackAreaHeight-thumbHeight)/2));

            positionThumb(false);
            // layout track
            track.resizeRelocate((int)(trackStart - trackRadius),
                    trackTop ,
                    (int)(trackLength + trackRadius + trackRadius),
                    trackHeight);
            // layout tick line
            if (showTickMarks) {
                tickLine.setLayoutX(trackStart);
                tickLine.setLayoutY(trackTop+trackHeight+trackToTickGap);
                tickLine.resize(trackLength, tickLineHeight);
                tickLine.requestAxisLayout();
            } else {
                if (tickLine != null) {
                    tickLine.resize(0,0);
                    tickLine.requestAxisLayout();
                }
                tickLine = null;
            }
        } else {
            double tickLineWidth = (showTickMarks) ? tickLine.prefWidth(-1) : 0;
            double trackWidth = snapSizeX(track.prefWidth(-1));
            double trackAreaWidth = Math.max(trackWidth,thumbWidth);
            double totalWidthNeeded = trackAreaWidth  + ((showTickMarks) ? trackToTickGap+tickLineWidth : 0) ;
            double startX = x + ((w - totalWidthNeeded)/2); // center slider in available width horizontally
            trackLength = snapSizeY(h - thumbHeight);
            trackStart = snapPositionY(y + (thumbHeight/2));
            double trackLeft = (int)(startX + ((trackAreaWidth-trackWidth)/2));
            thumbLeft = (int)(startX + ((trackAreaWidth-thumbWidth)/2));

            positionThumb(false);
            // layout track
            track.resizeRelocate(trackLeft,
                    (int)(trackStart - trackRadius),
                    trackWidth,
                    (int)(trackLength + trackRadius + trackRadius));
            // layout tick line
            if (showTickMarks) {
                tickLine.setLayoutX(trackLeft+trackWidth+trackToTickGap);
                tickLine.setLayoutY(trackStart);
                tickLine.resize(tickLineWidth, trackLength);
                tickLine.requestAxisLayout();
            } else {
                if (tickLine != null) {
                    tickLine.resize(0,0);
                    tickLine.requestAxisLayout();
                }
                tickLine = null;
            }
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        final Slider s = getSkinnable();
        if (s.getOrientation() == Orientation.HORIZONTAL) {
            return (leftInset + minTrackLength() + thumb.minWidth(-1) + rightInset);
        } else {
            return(leftInset + thumb.prefWidth(-1) + rightInset);
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        final Slider s = getSkinnable();
        if (s.getOrientation() == Orientation.HORIZONTAL) {
            double axisHeight = showTickMarks ? (tickLine.prefHeight(-1) + trackToTickGap) : 0;
            return topInset + thumb.prefHeight(-1) + axisHeight + bottomInset;
        } else {
            return topInset + minTrackLength() + thumb.prefHeight(-1) + bottomInset;
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        final Slider s = getSkinnable();
        if (s.getOrientation() == Orientation.HORIZONTAL) {
            if(showTickMarks) {
                return Math.max(140, tickLine.prefWidth(-1));
            } else {
                return 140;
            }
        } else {
            double axisWidth = showTickMarks ? (tickLine.prefWidth(-1) + trackToTickGap) : 0;
            return leftInset + Math.max(thumb.prefWidth(-1), track.prefWidth(-1)) + axisWidth + rightInset;
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        final Slider s = getSkinnable();
        if (s.getOrientation() == Orientation.HORIZONTAL) {
            return topInset + Math.max(thumb.prefHeight(-1), track.prefHeight(-1)) +
                    ((showTickMarks) ? (trackToTickGap+tickLine.prefHeight(-1)) : 0)  + bottomInset;
        } else {
            if(showTickMarks) {
                return Math.max(140, tickLine.prefHeight(-1));
            } else {
                return 140;
            }
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        if (getSkinnable().getOrientation() == Orientation.HORIZONTAL) {
            return Double.MAX_VALUE;
        } else {
            return getSkinnable().prefWidth(-1);
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        if (getSkinnable().getOrientation() == Orientation.HORIZONTAL) {
            return getSkinnable().prefHeight(width);
<A NAME="13"></A>        } else {
            return Double.MAX_VALUE;
        }
    <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#13',2,'match46-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private void initialize() {
        thumb = new StackPane() {
            @Override
            public Object queryAccessibleAttribute(AccessibleAttribute attribute</B></FONT>, Object... parameters) {
                switch (attribute) {
                    case VALUE: return getSkinnable().getValue();
                    default: return super.queryAccessibleAttribute(attribute, parameters);
                }
            }
        };
        thumb.getStyleClass().setAll(&quot;thumb&quot;);
        thumb.setAccessibleRole(AccessibleRole.THUMB);
        track = new StackPane();
        track.getStyleClass().setAll(&quot;track&quot;);
//        horizontal = getSkinnable().isVertical();

        getChildren().clear();
        getChildren().addAll(track, thumb);
        setShowTickMarks(getSkinnable().isShowTickMarks(), getSkinnable().isShowTickLabels());
        track.setOnMousePressed(me -&gt; {
            if (!thumb.isPressed()) {
                trackClicked = true;
                if (getSkinnable().getOrientation() == Orientation.HORIZONTAL) {
                    behavior.trackPress(me, (me.getX() / trackLength));
                } else {
                    behavior.trackPress(me, (me.getY() / trackLength));
                }
                trackClicked = false;
            }
        });

        track.setOnMouseDragged(me -&gt; {
            if (!thumb.isPressed()) {
                if (getSkinnable().getOrientation() == Orientation.HORIZONTAL) {
                    behavior.trackPress(me, (me.getX() / trackLength));
                } else {
                    behavior.trackPress(me, (me.getY() / trackLength));
                }
            }
        });

        thumb.setOnMousePressed(me -&gt; {
            behavior.thumbPressed(me, 0.0f);
            dragStart = thumb.localToParent(me.getX(), me.getY());
            preDragThumbPos = (getSkinnable().getValue() - getSkinnable().getMin()) /
                    (getSkinnable().getMax() - getSkinnable().getMin());
        });

        thumb.setOnMouseReleased(me -&gt; {
            behavior.thumbReleased(me);
        });

        thumb.setOnMouseDragged(me -&gt; {
            Point2D cur = thumb.localToParent(me.getX(), me.getY());
            double dragPos = (getSkinnable().getOrientation() == Orientation.HORIZONTAL) ?
                    cur.getX() - dragStart.getX() : -(cur.getY() - dragStart.getY());
            behavior.thumbDragged(me, preDragThumbPos + dragPos / trackLength);
        });
    }

    private void setShowTickMarks(boolean ticksVisible, boolean labelsVisible) {
        showTickMarks = (ticksVisible || labelsVisible);
        Slider slider = getSkinnable();
        if (showTickMarks) {
            if (tickLine == null) {
                tickLine = new NumberAxis();
                tickLine.setAutoRanging(false);
                tickLine.setSide(slider.getOrientation() == Orientation.VERTICAL ? Side.RIGHT : (slider.getOrientation() == null) ? Side.RIGHT: Side.BOTTOM);
                tickLine.setUpperBound(slider.getMax());
                tickLine.setLowerBound(slider.getMin());
                tickLine.setTickUnit(slider.getMajorTickUnit());
                tickLine.setTickMarkVisible(ticksVisible);
                tickLine.setTickLabelsVisible(labelsVisible);
                tickLine.setMinorTickVisible(ticksVisible);
                // add 1 to the slider minor tick count since the axis draws one
                // less minor ticks than the number given.
                tickLine.setMinorTickCount(Math.max(slider.getMinorTickCount(),0) + 1);
                if (slider.getLabelFormatter() != null) {
                    tickLine.setTickLabelFormatter(stringConverterWrapper);
                }
                getChildren().clear();
                getChildren().addAll(tickLine, track, thumb);
            } else {
                tickLine.setTickLabelsVisible(labelsVisible);
                tickLine.setTickMarkVisible(ticksVisible);
                tickLine.setMinorTickVisible(ticksVisible);
            }
        }
        else  {
            getChildren().clear();
            getChildren().addAll(track, thumb);
//            tickLine = null;
        }

        getSkinnable().requestLayout();
    }

    /**
     * Called when ever either min, max or value changes, so thumb's layoutX, Y is recomputed.
     */
    void positionThumb(final boolean animate) {
        Slider s = getSkinnable();
        if (s.getValue() &gt; s.getMax()) return;// this can happen if we are bound to something
        boolean horizontal = s.getOrientation() == Orientation.HORIZONTAL;
        final double endX = (horizontal) ? trackStart + (((trackLength * ((s.getValue() - s.getMin()) /
                (s.getMax() - s.getMin()))) - thumbWidth/2)) : thumbLeft;
        final double endY = (horizontal) ? thumbTop :
            snappedTopInset() + trackLength - (trackLength * ((s.getValue() - s.getMin()) /
                (s.getMax() - s.getMin()))); //  - thumbHeight/2

        if (animate) {
            // lets animate the thumb transition
            final double startX = thumb.getLayoutX();
            final double startY = thumb.getLayoutY();
            Transition transition = new Transition() {
                {
                    setCycleDuration(Duration.millis(200));
                }

                @Override protected void interpolate(double frac) {
                    if (!Double.isNaN(startX)) {
                        thumb.setLayoutX(startX + frac * (endX - startX));
                    }
                    if (!Double.isNaN(startY)) {
                        thumb.setLayoutY(startY + frac * (endY - startY));
                    }
                }
            };
            transition.play();
        } else {
            thumb.setLayoutX(endX);
            thumb.setLayoutY(endY);
        }
    }

    double minTrackLength() {
        return 2*thumb.prefWidth(-1);
    }
}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/SplitPaneSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.geometry.HPos;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Orientation;
import javafx.geometry.VPos;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.Accordion;
import javafx.scene.control.Control;
import javafx.scene.control.SkinBase;
import javafx.scene.control.SplitPane;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

/**
 * Default skin implementation for the {@link SplitPane} control.
 *
 * @see SplitPane
 * @since 9
 */
public class SplitPaneSkin extends SkinBase&lt;SplitPane&gt; {

    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private ObservableList&lt;Content&gt; contentRegions;
    private ObservableList&lt;ContentDivider&gt; contentDividers;
    private boolean horizontal;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new SplitPaneSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public SplitPaneSkin(final SplitPane control) {
        super(control);
//        control.setManaged(false);
        horizontal = getSkinnable().getOrientation() == Orientation.HORIZONTAL;

        contentRegions = FXCollections.&lt;Content&gt;observableArrayList();
        contentDividers = FXCollections.&lt;ContentDivider&gt;observableArrayList();

        int index = 0;
        for (Node n: getSkinnable().getItems()) {
            addContent(index++, n);
        }
        initializeContentListener();

        for (SplitPane.Divider d: getSkinnable().getDividers()) {
            addDivider(d);
        }

        registerChangeListener(control.orientationProperty(), e -&gt; {
            this.horizontal = getSkinnable().getOrientation() == Orientation.HORIZONTAL;
            this.previousSize = -1;
            for (ContentDivider c: contentDividers) {
                c.setGrabberStyle(horizontal);
            }
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.widthProperty(), e -&gt; getSkinnable().requestLayout());
        registerChangeListener(control.heightProperty(), e -&gt; getSkinnable().requestLayout());
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        final SplitPane s = getSkinnable();
        final double sw = s.getWidth();
        final double sh = s.getHeight();

        if ((horizontal ? sw == 0 : sh == 0) || contentRegions.isEmpty()) {
            return;
        }

        double dividerWidth = contentDividers.isEmpty() ? 0 : contentDividers.get(0).prefWidth(-1);

        if (contentDividers.size() &gt; 0 &amp;&amp; previousSize != -1 &amp;&amp; previousSize != (horizontal ? sw  : sh)) {
            //This algorithm adds/subtracts a little to each panel on every resize
            List&lt;Content&gt; resizeList = new ArrayList&lt;Content&gt;();
            for (Content c: contentRegions) {
                if (c.isResizableWithParent()) {
                    resizeList.add(c);
                }
            }

            double delta = (horizontal ? s.getWidth() : s.getHeight()) - previousSize;
            boolean growing = delta &gt; 0;

            delta = Math.abs(delta);

            if (delta != 0 &amp;&amp; !resizeList.isEmpty()) {
                int portion = (int)(delta)/resizeList.size();
                int remainder = (int)delta%resizeList.size();
                int size = 0;
                if (portion == 0) {
                    portion = remainder;
                    size = remainder;
                    remainder = 0;
                } else {
                    size = portion * resizeList.size();
                }

                while (size &gt; 0 &amp;&amp; !resizeList.isEmpty()) {
                    if (growing) {
                        lastDividerUpdate++;
                    } else {
                        lastDividerUpdate--;
                        if (lastDividerUpdate &lt; 0) {
                            lastDividerUpdate = contentRegions.size() - 1;
                        }
                    }
                    int id = lastDividerUpdate%contentRegions.size();
                    Content content = contentRegions.get(id);
                    if (content.isResizableWithParent() &amp;&amp; resizeList.contains(content)) {
                        double area = content.getArea();
                        if (growing) {
                            double max = horizontal ? content.maxWidth(-1) : content.maxHeight(-1);
                            if ((area + portion) &lt;= max) {
                                area += portion;
                            } else {
                                resizeList.remove(content);
                                continue;
                            }
                        } else {
                            double min = horizontal ? content.minWidth(-1) : content.minHeight(-1);
                            if ((area - portion) &gt;= min) {
                                area -= portion;
                            } else {
                                resizeList.remove(content);
                                continue;
                            }
                        }
                        content.setArea(area);
                        size -= portion;
                        if (size == 0 &amp;&amp; remainder != 0) {
                            portion = remainder;
                            size = remainder;
                            remainder = 0;
                        } else if (size == 0) {
                            break;
                        }
                    }
                }

                // If we are resizing the window save the current area into
                // resizableWithParentArea.  We use this value during layout.
                {
                    for (Content c: contentRegions) {
                        c.setResizableWithParentArea(c.getArea());
                        c.setAvailable(0);
                    }
                }
                resize = true;
            }

            previousSize = horizontal ? sw : sh;
        } else {
            previousSize = horizontal ? sw : sh;
        }

        // If the window is less than the min size we want to resize
        // proportionally
        double minSize = totalMinSize();
        if (minSize &gt; (horizontal ? w : h)) {
            double percentage = 0;
            for (int i = 0; i &lt; contentRegions.size(); i++) {
                Content c = contentRegions.get(i);
                double min = horizontal ? c.minWidth(-1) : c.minHeight(-1);
                percentage = min/minSize;
                if (horizontal) {
                    c.setArea(snapSpaceX(percentage * w));
                } else {
                    c.setArea(snapSpaceY(percentage * h));
                }
                c.setAvailable(0);
            }
            setupContentAndDividerForLayout();
            layoutDividersAndContent(w, h);
            resize = false;
            return;
        }

        for(int trys = 0; trys &lt; 10; trys++) {
            // Compute the area in between each divider.
            ContentDivider previousDivider = null;
            ContentDivider divider = null;
            for (int i = 0; i &lt; contentRegions.size(); i++) {
                double space = 0;
                if (i &lt; contentDividers.size()) {
                    divider = contentDividers.get(i);
                    if (divider.posExplicit) {
                        checkDividerPosition(divider, posToDividerPos(divider, divider.d.getPosition()),
                                divider.getDividerPos());
                    }
                    if (i == 0) {
                        // First panel
                        space = getAbsoluteDividerPos(divider);
                    } else {
                        double newPos = getAbsoluteDividerPos(previousDivider) + dividerWidth;
                        // Middle panels
                        if (getAbsoluteDividerPos(divider) &lt;= getAbsoluteDividerPos(previousDivider)) {
                            // The current divider and the previous divider share the same position
                            // or the current divider position is less than the previous position.
                            // We will set the divider next to the previous divider.
                            setAndCheckAbsoluteDividerPos(divider, newPos);
                        }
                        space = getAbsoluteDividerPos(divider) - newPos;
                    }
                } else if (i == contentDividers.size()) {
                    // Last panel
                    space = (horizontal ? w : h) - (previousDivider != null ? getAbsoluteDividerPos(previousDivider) + dividerWidth : 0);
                }
                if (!resize || divider.posExplicit) {
                    contentRegions.get(i).setArea(space);
                }
                previousDivider = divider;
            }

            // Compute the amount of space we have available.
            // Available is amount of space we can take from a panel before we reach its min.
            // If available is negative we don't have enough space and we will
            // proportionally take the space from the other availables.  If we have extra space
            // we will porportionally give it to the others
            double spaceRequested = 0;
            double extraSpace = 0;
            for (Content c: contentRegions) {
                if (c == null) continue;

                double max = horizontal ? c.maxWidth(-1) : c.maxHeight(-1);
                double min = horizontal ? c.minWidth(-1) : c.minHeight(-1);

                if (c.getArea() &gt;= max) {
                    // Add the space that needs to be distributed to the others
                    extraSpace += (c.getArea() - max);
                    c.setArea(max);
                }
                c.setAvailable(c.getArea() - min);
                if (c.getAvailable() &lt; 0) {
                    spaceRequested += c.getAvailable();
                }
            }

            spaceRequested = Math.abs(spaceRequested);

            // Add the panels where we can take space from
            List&lt;Content&gt; availableList = new ArrayList&lt;Content&gt;();
            List&lt;Content&gt; storageList = new ArrayList&lt;Content&gt;();
            List&lt;Content&gt; spaceRequestor = new ArrayList&lt;Content&gt;();
            double available = 0;
            for (Content c: contentRegions) {
                if (c.getAvailable() &gt;= 0) {
                    available += c.getAvailable();
                    availableList.add(c);
                }

                if (resize &amp;&amp; !c.isResizableWithParent()) {
                    // We are making the SplitPane bigger and will need to
                    // distribute the extra space.
                    if (c.getArea() &gt;= c.getResizableWithParentArea()) {
                        extraSpace += (c.getArea() - c.getResizableWithParentArea());
                    } else {
                        // We are making the SplitPane smaller and will need to
                        // distribute the space requested.
                        spaceRequested += (c.getResizableWithParentArea() - c.getArea());
                    }
                    c.setAvailable(0);
                }
                // Add the panels where we can add space to;
                if (resize) {
                    if (c.isResizableWithParent()) {
                        storageList.add(c);
                    }
                } else {
                    storageList.add(c);
                }
                // List of panels that need space.
                if (c.getAvailable() &lt; 0) {
                    spaceRequestor.add(c);
                }
            }

            if (extraSpace &gt; 0) {
                extraSpace = distributeTo(storageList, extraSpace);
                // After distributing add any panels that may still need space to the
                // spaceRequestor list.
                spaceRequested = 0;
<A NAME="2"></A>                spaceRequestor.clear();
                available = 0;
                availableList.clear();
                for (<FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#2',2,'match46-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Content c: contentRegions) {
                    if (c.getAvailable() &lt; 0) {
                        spaceRequested += c.getAvailable();
                        spaceRequestor.add(c);
                    } else {
                        available += c.getAvailable();
                        availableList.add(c);
                    }
                }</B></FONT>
                spaceRequested = Math.abs(spaceRequested);
            }

            if (available &gt;= spaceRequested) {
                for (Content requestor: spaceRequestor) {
                    double min = horizontal ? requestor.minWidth(-1) : requestor.minHeight(-1);
                    requestor.setArea(min);
                    requestor.setAvailable(0);
                }
                // After setting all the space requestors to their min we have to
                // redistribute the space requested to any panel that still
                // has available space.
                if (spaceRequested &gt; 0 &amp;&amp; !spaceRequestor.isEmpty()) {
                    distributeFrom(spaceRequested, availableList);
                }

                // Only for resizing.  We should have all the panel areas
                // available computed.  We can total them up and see
                // how much space we have left or went over and redistribute.
                if (resize) {
                    double total = 0;
                    for (Content c: contentRegions) {
                        if (c.isResizableWithParent()) {
                            total += c.getArea();
                        } else {
                            total += c.getResizableWithParentArea();
                        }
                    }
                    total += (dividerWidth * contentDividers.size());
                    if (total &lt; (horizontal ? w : h)) {
                        extraSpace += ((horizontal ? w : h) - total);
                        distributeTo(storageList, extraSpace);
                    } else {
                        spaceRequested += (total - (horizontal ? w : h));
                        distributeFrom(spaceRequested, storageList);
                    }
                }
            }

            setupContentAndDividerForLayout();

            // Check the bounds of every panel
            boolean passed = true;
            for (Content c: contentRegions) {
                double max = horizontal ? c.maxWidth(-1) : c.maxHeight(-1);
                double min = horizontal ? c.minWidth(-1) : c.minHeight(-1);
                if (c.getArea() &lt; min || c.getArea() &gt; max) {
                    passed = false;
                    break;
                }
            }
            if (passed) {
                break;
            }
        }

        layoutDividersAndContent(w, h);
        resize = false;
    }

    /** {@inheritDoc} */
    @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        double minWidth = 0;
        double maxMinWidth = 0;
        for (Content c: contentRegions) {
            minWidth += c.minWidth(-1);
            maxMinWidth = Math.max(maxMinWidth, c.minWidth(-1));
        }
        for (ContentDivider d: contentDividers) {
            minWidth += d.prefWidth(-1);
        }
        if (horizontal) {
            return minWidth + leftInset + rightInset;
        } else {
            return maxMinWidth + leftInset + rightInset;
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        double minHeight = 0;
        double maxMinHeight = 0;
        for (Content c: contentRegions) {
            minHeight += c.minHeight(-1);
            maxMinHeight = Math.max(maxMinHeight, c.minHeight(-1));
        }
        for (ContentDivider d: contentDividers) {
            minHeight += d.prefWidth(-1);
        }
        if (horizontal) {
            return maxMinHeight + topInset + bottomInset;
        } else {
            return minHeight + topInset + bottomInset;
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        double prefWidth = 0;
        double prefMaxWidth = 0;
        for (Content c: contentRegions) {
            prefWidth += c.prefWidth(-1);
            prefMaxWidth = Math.max(prefMaxWidth, c.prefWidth(-1));
        }
        for (ContentDivider d: contentDividers) {
            prefWidth += d.prefWidth(-1);
        }
        if (horizontal) {
            return prefWidth + leftInset + rightInset;
        } else {
            return prefMaxWidth + leftInset + rightInset;
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        double prefHeight = 0;
        double maxPrefHeight = 0;
        for (Content c: contentRegions) {
            prefHeight += c.prefHeight(-1);
            maxPrefHeight = Math.max(maxPrefHeight, c.prefHeight(-1));
        }
        for (ContentDivider d: contentDividers) {
            prefHeight += d.prefWidth(-1);
        }
        if (horizontal) {
            return maxPrefHeight + topInset + bottomInset;
        } else {
            return prefHeight + topInset + bottomInset;
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private void addContent(int index, Node n) {
        Content c = new Content(n);
        contentRegions.add(index, c);
        getChildren().add(index, c);
    }

    private void removeContent(Node n) {
        for (Content c: contentRegions) {
            if (c.getContent().equals(n)) {
                c.dispose();
                getChildren().remove(c);
                contentRegions.remove(c);
                break;
            }
        }
    }

    private void initializeContentListener() {
        getSkinnable().getItems().addListener((ListChangeListener&lt;Node&gt;) c -&gt; {
            while (c.next()) {
                if (c.wasPermutated() || c.wasUpdated()) {
                    /**
                     * the contents were either moved, or updated.
                     * rebuild the contents to re-sync
                     */
                    getChildren().clear();
                    contentRegions.clear();
                    int index = 0;
                    for (Node n : c.getList()) {
                        addContent(index++, n);
                    }

                } else {
                    for (Node n : c.getRemoved()) {
                        removeContent(n);
                    }

                    int index = c.getFrom();
                    for (Node n : c.getAddedSubList()) {
                        addContent(index++, n);
                    }
                }
            }
            // TODO there may be a more efficient way than rebuilding all the dividers
            // everytime the list changes.
            removeAllDividers();
            for (SplitPane.Divider d: getSkinnable().getDividers()) {
                addDivider(d);
            }
        });
    }

    private void checkDividerPosition(ContentDivider divider, double newPos, double oldPos) {
        double dividerWidth = divider.prefWidth(-1);
        Content left = getLeft(divider);
        Content right = getRight(divider);
        double minLeft = left == null ? 0 : (horizontal) ? left.minWidth(-1) : left.minHeight(-1);
        double minRight = right == null ? 0 : (horizontal) ? right.minWidth(-1) : right.minHeight(-1);
        double maxLeft = left == null ? 0 :
            left.getContent() != null ? (horizontal) ? left.getContent().maxWidth(-1) : left.getContent().maxHeight(-1) : 0;
        double maxRight = right == null ? 0 :
            right.getContent() != null ? (horizontal) ? right.getContent().maxWidth(-1) : right.getContent().maxHeight(-1) : 0;

        double previousDividerPos = 0;
        double nextDividerPos = getSize();
        int index = contentDividers.indexOf(divider);

        if (index - 1 &gt;= 0) {
            previousDividerPos = contentDividers.get(index - 1).getDividerPos();
            if (previousDividerPos == -1) {
                // Get the divider position if it hasn't been initialized.
                previousDividerPos = getAbsoluteDividerPos(contentDividers.get(index - 1));
            }
        }
        if (index + 1 &lt; contentDividers.size()) {
            nextDividerPos = contentDividers.get(index + 1).getDividerPos();
            if (nextDividerPos == -1) {
                // Get the divider position if it hasn't been initialized.
                nextDividerPos = getAbsoluteDividerPos(contentDividers.get(index + 1));
            }
        }

        // Set the divider into the correct position by looking at the max and min content sizes.
        checkDividerPos = false;
        if (newPos &gt; oldPos) {
            double max = previousDividerPos == 0 ? maxLeft : previousDividerPos + dividerWidth + maxLeft;
            double min = nextDividerPos - minRight - dividerWidth;
            double stopPos = Math.min(max, min);
            if (newPos &gt;= stopPos) {
                setAbsoluteDividerPos(divider, stopPos);
            } else {
                double rightMax = nextDividerPos - maxRight - dividerWidth;
                if (newPos &lt;= rightMax) {
                    setAbsoluteDividerPos(divider, rightMax);
                } else {
                    setAbsoluteDividerPos(divider, newPos);
                }
            }
        } else {
            double max = nextDividerPos - maxRight - dividerWidth;
            double min = previousDividerPos == 0 ? minLeft : previousDividerPos + minLeft + dividerWidth;
            double stopPos = Math.max(max, min);
            if (newPos &lt;= stopPos) {
                setAbsoluteDividerPos(divider, stopPos);
            } else {
                double leftMax = previousDividerPos + maxLeft + dividerWidth;
                if (newPos &gt;= leftMax) {
                    setAbsoluteDividerPos(divider, leftMax);
                } else {
                    setAbsoluteDividerPos(divider, newPos);
                }
<A NAME="44"></A>            }
        }
        checkDividerPos = true;
    <FONT color="#e57ded"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#44',2,'match46-top.html#44',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    private void addDivider(SplitPane.Divider d) {
        ContentDivider c = new ContentDivider(d);
        c.setInitialPos(d.getPosition());
        c.setDividerPos(-1);
        ChangeListener&lt;Number&gt; posPropertyListener = new PosPropertyListener(c);
        c.setPosPropertyListener</B></FONT>(posPropertyListener);
        d.positionProperty().addListener(posPropertyListener);
        initializeDivderEventHandlers(c);
        contentDividers.add(c);
        getChildren().add(c);
    }

    private void removeAllDividers() {
        ListIterator&lt;ContentDivider&gt; dividers = contentDividers.listIterator();
        while (dividers.hasNext()) {
            ContentDivider c = dividers.next();
            getChildren().remove(c);
            c.getDivider().positionProperty().removeListener(c.getPosPropertyListener());
            dividers.remove();
        }
        lastDividerUpdate = 0;
    }

    private void initializeDivderEventHandlers(final ContentDivider divider) {
        // TODO: do we need to consume all mouse events?
        // they only bubble to the skin which consumes them by default
        divider.addEventHandler(MouseEvent.ANY, event -&gt; {
            event.consume();
        });

        divider.setOnMousePressed(e -&gt; {
            if (horizontal) {
                divider.setInitialPos(divider.getDividerPos());
                divider.setPressPos(e.getSceneX());
                divider.setPressPos(getSkinnable().getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT
                        ? getSkinnable().getWidth() - e.getSceneX() : e.getSceneX());
            } else {
                divider.setInitialPos(divider.getDividerPos());
                divider.setPressPos(e.getSceneY());
            }
            e.consume();
        });

        divider.setOnMouseDragged(e -&gt; {
            double delta = 0;
            if (horizontal) {
                delta = getSkinnable().getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT
                        ? getSkinnable().getWidth() - e.getSceneX() : e.getSceneX();
            } else {
                delta = e.getSceneY();
            }
            delta -= divider.getPressPos();
            setAndCheckAbsoluteDividerPos(divider, Math.ceil(divider.getInitialPos() + delta));
            e.consume();
        });
    }

    private Content getLeft(ContentDivider d) {
        int index = contentDividers.indexOf(d);
        if (index != -1) {
            return contentRegions.get(index);
        }
        return null;
    }

    private Content getRight(ContentDivider d) {
        int index = contentDividers.indexOf(d);
        if (index != -1) {
            return contentRegions.get(index + 1);
        }
        return null;
    }

    // Value is the left edge of the divider
    private void setAbsoluteDividerPos(ContentDivider divider, double value) {
        if (getSkinnable().getWidth() &gt; 0 &amp;&amp; getSkinnable().getHeight() &gt; 0 &amp;&amp; divider != null) {
            SplitPane.Divider paneDivider = divider.getDivider();
            divider.setDividerPos(value);
            double size = getSize();
            if (size != 0) {
                // Adjust the position to the center of the
                // divider and convert its position to a percentage.
                double pos = value + divider.prefWidth(-1)/2;
                paneDivider.setPosition(pos / size);
            } else {
                paneDivider.setPosition(0);
            }
        }
    }

    // Updates the divider with the SplitPane.Divider's position
    // The value updated to SplitPane.Divider will be the center of the divider.
    // The returned position will be the left edge of the divider
    private double getAbsoluteDividerPos(ContentDivider divider) {
        if (getSkinnable().getWidth() &gt; 0 &amp;&amp; getSkinnable().getHeight() &gt; 0 &amp;&amp; divider != null) {
            SplitPane.Divider paneDivider = divider.getDivider();
            double newPos = posToDividerPos(divider, paneDivider.getPosition());
            divider.setDividerPos(newPos);
            return newPos;
        }
        return 0;
    }

    // Returns the left edge of the divider at pos
    // Pos is the percentage location from SplitPane.Divider.
    private double posToDividerPos(ContentDivider divider, double pos) {
        double newPos = getSize() * pos;
        if (pos == 1) {
            newPos -= divider.prefWidth(-1);
        } else {
            newPos -= divider.prefWidth(-1)/2;
        }
        return Math.round(newPos);
    }

    private double totalMinSize() {
        double dividerWidth = !contentDividers.isEmpty() ? contentDividers.size() * contentDividers.get(0).prefWidth(-1) : 0;
        double minSize = 0;
        for (Content c: contentRegions) {
            if (horizontal) {
                minSize += c.minWidth(-1);
            } else {
                minSize += c.minHeight(-1);
            }
        }
        return minSize + dividerWidth;
    }

    private double getSize() {
        final SplitPane s = getSkinnable();
        double size = totalMinSize();
        if (horizontal) {
            if (s.getWidth() &gt; size) {
                size = s.getWidth() - snappedLeftInset() - snappedRightInset();
            }
        } else {
            if (s.getHeight() &gt; size) {
                size = s.getHeight() - snappedTopInset() - snappedBottomInset();
            }
        }
        return size;
    }

    // Evenly distribute the size to the available list.
    // size is the amount to distribute.
    private double distributeTo(List&lt;Content&gt; available, double size) {
        if (available.isEmpty()) {
            return size;
        }

        size = horizontal ? snapSizeX(size) : snapSizeY(size);
        int portion = (int)(size)/available.size();
        int remainder;

        while (size &gt; 0 &amp;&amp; !available.isEmpty()) {
            Iterator&lt;Content&gt; i = available.iterator();
            while (i.hasNext()) {
                Content c = i.next();
                double max = Math.min((horizontal ? c.maxWidth(-1) : c.maxHeight(-1)), Double.MAX_VALUE);
                double min = horizontal ? c.minWidth(-1) : c.minHeight(-1);

                // We have too much space
                if (c.getArea() &gt;= max) {
                    c.setAvailable(c.getArea() - min);
                    i.remove();
                    continue;
                }
                // Not enough space
                if (portion &gt;= (max - c.getArea())) {
                    size -= (max - c.getArea());
                    c.setArea(max);
                    c.setAvailable(max - min);
                    i.remove();
                } else {
                    // Enough space
                    c.setArea(c.getArea() + portion);
                    c.setAvailable(c.getArea() - min);
                    size -= portion;
                }
                if ((int)size == 0) {
                    return size;
                }
            }
            if (available.isEmpty()) {
                // We reached the max size for everything just return
                return size;
            }
            portion = (int)(size)/available.size();
            remainder = (int)(size)%available.size();
            if (portion == 0 &amp;&amp; remainder != 0) {
                portion = remainder;
                remainder = 0;
            }
        }
        return size;
    }

    // Evenly distribute the size from the available list.
    // size is the amount to distribute.
    private double distributeFrom(double size, List&lt;Content&gt; available) {
        if (available.isEmpty()) {
            return size;
        }

        size = horizontal ? snapSizeX(size) : snapSizeY(size);
        int portion = (int)(size)/available.size();
        int remainder;

        while (size &gt; 0 &amp;&amp; !available.isEmpty()) {
            Iterator&lt;Content&gt; i = available.iterator();
            while (i.hasNext()) {
                Content c = i.next();
                //not enough space taking available and setting min
                if (portion &gt;= c.getAvailable()) {
                    c.setArea(c.getArea() - c.getAvailable()); // Min size
                    size -= c.getAvailable();
                    c.setAvailable(0);
                    i.remove();
                } else {
                    //enough space
                    c.setArea(c.getArea() - portion);
                    c.setAvailable(c.getAvailable() - portion);
                    size -= portion;
                }
                if ((int)size == 0) {
                    return size;
                }
            }
            if (available.isEmpty()) {
                // We reached the min size for everything just return
                return size;
            }
            portion = (int)(size)/available.size();
            remainder = (int)(size)%available.size();
            if (portion == 0 &amp;&amp; remainder != 0) {
                portion = remainder;
                remainder = 0;
            }
        }
        return size;
    }

    private void setupContentAndDividerForLayout() {
        // Set all the value to prepare for layout
        double dividerWidth = contentDividers.isEmpty() ? 0 : contentDividers.get(0).prefWidth(-1);
        double startX = 0;
        double startY = 0;
        for (Content c: contentRegions) {
            if (resize &amp;&amp; !c.isResizableWithParent()) {
                c.setArea(c.getResizableWithParentArea());
            }

            c.setX(startX);
            c.setY(startY);
            if (horizontal) {
                startX += (c.getArea() + dividerWidth);
            } else {
                startY += (c.getArea() + dividerWidth);
            }
        }

        startX = 0;
        startY = 0;
        // The dividers are already in the correct positions.  Disable
        // checking the divider positions.
        checkDividerPos = false;
        for (int i = 0; i &lt; contentDividers.size(); i++) {
            ContentDivider d = contentDividers.get(i);
            if (horizontal) {
                startX += getLeft(d).getArea() + (i == 0 ? 0 : dividerWidth);
            } else {
                startY += getLeft(d).getArea() + (i == 0 ? 0 : dividerWidth);
            }
            d.setX(startX);
            d.setY(startY);
            setAbsoluteDividerPos(d, (horizontal ? d.getX() : d.getY()));
            d.posExplicit = false;
        }
        checkDividerPos = true;
    }

    private void layoutDividersAndContent(double width, double height) {
        final double paddingX = snappedLeftInset();
        final double paddingY = snappedTopInset();
        final double dividerWidth = contentDividers.isEmpty() ? 0 : contentDividers.get(0).prefWidth(-1);

        for (Content c: contentRegions) {
//            System.out.println(&quot;LAYOUT &quot; + c.getId() + &quot; PANELS X &quot; + c.getX() + &quot; Y &quot; + c.getY() + &quot; W &quot; + (horizontal ? c.getArea() : width) + &quot; H &quot; + (horizontal ? height : c.getArea()));
            if (horizontal) {
                c.setClipSize(c.getArea(), height);
                layoutInArea(c, c.getX() + paddingX, c.getY() + paddingY, c.getArea(), height,
                    0/*baseline*/,HPos.CENTER, VPos.CENTER);
            } else {
                c.setClipSize(width, c.getArea());
                layoutInArea(c, c.getX() + paddingX, c.getY() + paddingY, width, c.getArea(),
                    0/*baseline*/,HPos.CENTER, VPos.CENTER);
            }
        }
        for (ContentDivider c: contentDividers) {
//            System.out.println(&quot;LAYOUT DIVIDERS X &quot; + c.getX() + &quot; Y &quot; + c.getY() + &quot; W &quot; + (horizontal ? dividerWidth : width) + &quot; H &quot; + (horizontal ? height : dividerWidth));
            if (horizontal) {
                c.resize(dividerWidth, height);
                positionInArea(c, c.getX() + paddingX, c.getY() + paddingY, dividerWidth, height,
                    /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
            } else {
                c.resize(width, dividerWidth);
                positionInArea(c, c.getX() + paddingX, c.getY() + paddingY, width, dividerWidth,
                    /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
            }
        }
    }

    private double previousSize = -1;
    private int lastDividerUpdate = 0;
    private boolean resize = false;
    private boolean checkDividerPos = true;

    private void setAndCheckAbsoluteDividerPos(ContentDivider divider, double value) {
        double oldPos = divider.getDividerPos();
        setAbsoluteDividerPos(divider, value);
        checkDividerPosition(divider, value, oldPos);
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    // This listener is to be removed from 'removed' dividers and added to 'added' dividers
    class PosPropertyListener implements ChangeListener&lt;Number&gt; {
        ContentDivider divider;

        public PosPropertyListener(ContentDivider divider) {
            this.divider = divider;
        }

        @Override public void changed(ObservableValue&lt;? extends Number&gt; observable, Number oldValue, Number newValue) {
            if (checkDividerPos) {
                // When checking is enforced, we know that the position was set explicitly
                divider.posExplicit = true;
            }
            getSkinnable().requestLayout();
        }
    }


    class ContentDivider extends StackPane {
        private double initialPos;
        private double dividerPos;
        private double pressPos;
        private SplitPane.Divider d;
        private StackPane grabber;
        private double x;
        private double y;
        private boolean posExplicit;
        private ChangeListener&lt;Number&gt; listener;

        public ContentDivider(SplitPane.Divider d) {
            getStyleClass().setAll(&quot;split-pane-divider&quot;);

            this.d = d;
            this.initialPos = 0;
            this.dividerPos = 0;
            this.pressPos = 0;

            grabber = new StackPane() {
                @Override protected double computeMinWidth(double height) {
                    return 0;
                }

                @Override protected double computeMinHeight(double width) {
                    return 0;
                }

                @Override protected double computePrefWidth(double height) {
                    return snappedLeftInset() + snappedRightInset();
                }

                @Override protected double computePrefHeight(double width) {
                    return snappedTopInset() + snappedBottomInset();
                }

                @Override protected double computeMaxWidth(double height) {
                    return computePrefWidth(-1);
                }

                @Override protected double computeMaxHeight(double width) {
                    return computePrefHeight(-1);
                }
            };
            setGrabberStyle(horizontal);
            getChildren().add(grabber);

            // TODO register a listener for SplitPane.Divider position
        }

        public SplitPane.Divider getDivider() {
            return this.d;
        }

        public final void setGrabberStyle(boolean horizontal) {
            grabber.getStyleClass().clear();
            grabber.getStyleClass().setAll(&quot;vertical-grabber&quot;);
            setCursor(Cursor.V_RESIZE);
            if (horizontal) {
                grabber.getStyleClass().setAll(&quot;horizontal-grabber&quot;);
                setCursor(Cursor.H_RESIZE);
            }
        }

        public double getInitialPos() {
            return initialPos;
        }

        public void setInitialPos(double initialPos) {
            this.initialPos = initialPos;
        }

        public double getDividerPos() {
            return dividerPos;
        }

        public void setDividerPos(double dividerPos) {
            this.dividerPos = dividerPos;
        }

        public double getPressPos() {
            return pressPos;
        }

        public void setPressPos(double pressPos) {
            this.pressPos = pressPos;
        }

        // TODO remove x and y and replace with dividerpos.
        public double getX() {
            return x;
        }

        public void setX(double x) {
            this.x = x;
        }

        public double getY() {
            return y;
        }

        public void setY(double y) {
            this.y = y;
        }

        public ChangeListener&lt;Number&gt; getPosPropertyListener() {
            return listener;
        }

        public void setPosPropertyListener(ChangeListener&lt;Number&gt; listener) {
            this.listener = listener;
        }

        @Override protected double computeMinWidth(double height) {
            return computePrefWidth(height);
        }

        @Override protected double computeMinHeight(double width) {
            return computePrefHeight(width);
        }

        @Override protected double computePrefWidth(double height) {
            return snappedLeftInset() + snappedRightInset();
        }

        @Override protected double computePrefHeight(double width) {
            return snappedTopInset() + snappedBottomInset();
        }

        @Override protected double computeMaxWidth(double height) {
            return computePrefWidth(height);
        }

        @Override protected double computeMaxHeight(double width) {
            return computePrefHeight(width);
        }

        @Override protected void layoutChildren() {
            double grabberWidth = grabber.prefWidth(-1);
            double grabberHeight = grabber.prefHeight(-1);
            double grabberX = (getWidth() - grabberWidth)/2;
            double grabberY = (getHeight() - grabberHeight)/2;
            grabber.resize(grabberWidth, grabberHeight);
            positionInArea(grabber, grabberX, grabberY, grabberWidth, grabberHeight,
                    /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
        }
    }

    static class Content extends StackPane {
        private Node content;
        private Rectangle clipRect;
        private double x;
        private double y;
        private double area;
        private double resizableWithParentArea;
        private double available;

        public Content(Node n) {
            this.clipRect = new Rectangle();
            setClip(clipRect);
            this.content = n;
            if (n != null) {
                getChildren().add(n);
            }
            this.x = 0;
            this.y = 0;
        }

        public Node getContent() {
            return content;
        }

        public double getX() {
            return x;
        }

        public void setX(double x) {
            this.x = x;
        }

        public double getY() {
            return y;
        }

        public void setY(double y) {
            this.y = y;
        }

        // This is the area of the panel.  This will be used as the
        // width/height during layout.
        public double getArea() {
            return area;
        }

        public void setArea(double area) {
            this.area = area;
        }

        // This is the minimum available area for other panels to use
        // if they need more space.
        public double getAvailable() {
            return available;
        }

        public void setAvailable(double available) {
            this.available = available;
        }

        public boolean isResizableWithParent() {
            return SplitPane.isResizableWithParent(content);
        }

        public double getResizableWithParentArea() {
            return resizableWithParentArea;
        }

        // This is used to save the current area during resizing when
        // isResizeableWithParent equals false.
        public void setResizableWithParentArea(double resizableWithParentArea) {
            if (!isResizableWithParent()) {
                this.resizableWithParentArea = resizableWithParentArea;
            } else {
                this.resizableWithParentArea = 0;
            }
        }

        protected void setClipSize(double w, double h) {
            clipRect.setWidth(w);
            clipRect.setHeight(h);
        }

        private void dispose() {
            getChildren().remove(content);
        }

        @Override protected double computeMaxWidth(double height) {
            return snapSizeX(content.maxWidth(height));
        }

        @Override protected double computeMaxHeight(double width) {
            return snapSizeY(content.maxHeight(width));
        }
    }
}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TabPaneSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.TabObservableList;
import com.sun.javafx.util.Utils;
import javafx.animation.Animation;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.animation.Transition;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Point2D;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.geometry.VPos;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Control;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.control.RadioMenuItem;
import javafx.scene.control.SkinBase;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.control.TabPane.TabClosingPolicy;
import javafx.scene.control.TabPane.TabDragPolicy;
import javafx.scene.control.ToggleGroup;
import javafx.scene.control.Tooltip;
import javafx.scene.effect.DropShadow;
import javafx.scene.image.ImageView;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.input.SwipeEvent;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import javafx.css.converter.EnumConverter;
import com.sun.javafx.scene.control.behavior.TabPaneBehavior;

import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;

/**
 * Default skin implementation for the {@link TabPane} control.
 *
 * @see TabPane
 * @since 9
 */
public class TabPaneSkin extends SkinBase&lt;TabPane&gt; {

    /***************************************************************************
     *                                                                         *
     * Enums                                                                   *
     *                                                                         *
     **************************************************************************/

    private enum TabAnimation {
        NONE,
        GROW
        // In future we could add FADE, ...
    }

    private enum TabAnimationState {
        SHOWING, HIDING, NONE;
    }



    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    static int CLOSE_BTN_SIZE = 16;



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private static final double ANIMATION_SPEED = 150;
    private static final int SPACER = 10;

    private TabHeaderArea tabHeaderArea;
    private ObservableList&lt;TabContentRegion&gt; tabContentRegions;
    private Rectangle clipRect;
    private Rectangle tabHeaderAreaClipRect;
    private Tab selectedTab;
    private boolean isSelectingTab;

    private final TabPaneBehavior behavior;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TabPaneSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TabPaneSkin(TabPane control) {
        super(control);

        // install default input map for the TabPane control
        this.behavior = new TabPaneBehavior(control);
//        control.setInputMap(behavior.getInputMap());

        clipRect = new Rectangle(control.getWidth(), control.getHeight());
        getSkinnable().setClip(clipRect);

        tabContentRegions = FXCollections.&lt;TabContentRegion&gt;observableArrayList();

        for (Tab tab : getSkinnable().getTabs()) {
            addTabContent(tab);
        }

        tabHeaderAreaClipRect = new Rectangle();
        tabHeaderArea = new TabHeaderArea();
        tabHeaderArea.setClip(tabHeaderAreaClipRect);
        getChildren().add(tabHeaderArea);
        if (getSkinnable().getTabs().size() == 0) {
            tabHeaderArea.setVisible(false);
        }

        initializeTabListener();

        registerChangeListener(control.getSelectionModel().selectedItemProperty(), e -&gt; {
            isSelectingTab = true;
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.sideProperty(), e -&gt; updateTabPosition());
        registerChangeListener(control.widthProperty(), e -&gt; clipRect.setWidth(getSkinnable().getWidth()));
        registerChangeListener(control.heightProperty(), e -&gt; clipRect.setHeight(getSkinnable().getHeight()));

        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        // Could not find the selected tab try and get the selected tab using the selected index
        if (selectedTab == null &amp;&amp; getSkinnable().getSelectionModel().getSelectedIndex() != -1) {
            getSkinnable().getSelectionModel().select(getSkinnable().getSelectionModel().getSelectedIndex());
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        }
        if (selectedTab == null) {
            // getSelectedItem and getSelectedIndex failed select the first.
            getSkinnable().getSelectionModel().selectFirst();
        }
        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        isSelectingTab = false;

        initializeSwipeHandlers();
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    private ObjectProperty&lt;TabAnimation&gt; openTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.OPEN_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;openTabAnimation&quot;;
        }
    };

    private ObjectProperty&lt;TabAnimation&gt; closeTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.CLOSE_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;closeTabAnimation&quot;;
        }
    };



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as wide as it widest content width.
        double maxw = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxw = Math.max(maxw, snapSizeX(contentRegion.prefWidth(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeX(tabHeaderArea.prefWidth(-1))
                : snapSizeY(tabHeaderArea.prefHeight(-1));

        double prefWidth = isHorizontal ?
                Math.max(maxw, tabHeaderAreaSize) : maxw + tabHeaderAreaSize;
        return snapSizeX(prefWidth) + rightInset + leftInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as high as it highest content height.
        double maxh = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxh = Math.max(maxh, snapSizeY(contentRegion.prefHeight(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefWidth(-1));

        double prefHeight = isHorizontal ?
                maxh + snapSizeY(tabHeaderAreaSize) : Math.max(maxh, tabHeaderAreaSize);
        return snapSizeY(prefHeight) + topInset + bottomInset;
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        Side tabPosition = getSkinnable().getSide();
        if (tabPosition == Side.TOP) {
            return tabHeaderArea.getBaselineOffset() + topInset;
        }
        return 0;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        TabPane tabPane = getSkinnable();
        Side tabPosition = tabPane.getSide();

        double headerHeight = tabPosition.isHorizontal()
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefHeight(-1));
        double tabsStartX = tabPosition.equals(Side.RIGHT)? x + w - headerHeight : x;
        double tabsStartY = tabPosition.equals(Side.BOTTOM)? y + h - headerHeight : y;

        final double leftInset = snappedLeftInset();
        final double topInset = snappedTopInset();

        if (tabPosition == Side.TOP) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(tabsStartX, tabsStartY);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.TOP)));
        } else if (tabPosition == Side.BOTTOM) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(w + leftInset, tabsStartY - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.BOTTOM), 0, headerHeight));
        } else if (tabPosition == Side.LEFT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX + headerHeight, h - headerHeight + topInset);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.LEFT), 0, headerHeight));
        } else if (tabPosition == Side.RIGHT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX, y - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.RIGHT), 0, headerHeight));
        }

        tabHeaderAreaClipRect.setX(0);
        tabHeaderAreaClipRect.setY(0);
        if (isHorizontal()) {
            tabHeaderAreaClipRect.setWidth(w);
        } else {
            tabHeaderAreaClipRect.setWidth(h);
        }
        tabHeaderAreaClipRect.setHeight(headerHeight);

        // ==================================
        // position the tab content for the selected tab only
        // ==================================
        // if the tabs are on the left, the content needs to be indented
        double contentStartX = 0;
        double contentStartY = 0;

        if (tabPosition == Side.TOP) {
            contentStartX = x;
            contentStartY = y + headerHeight;
            if (isFloatingStyleClass()) {
                // This is to hide the top border content
                contentStartY -= 1;
            }
        } else if (tabPosition == Side.BOTTOM) {
            contentStartX = x;
            contentStartY = y + topInset;
            if (isFloatingStyleClass()) {
                // This is to hide the bottom border content
                contentStartY = 1 + topInset;
            }
        } else if (tabPosition == Side.LEFT) {
            contentStartX = x + headerHeight;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the left border content
                contentStartX -= 1;
            }
        } else if (tabPosition == Side.RIGHT) {
            contentStartX = x + leftInset;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the right border content
                contentStartX = 1 + leftInset;
            }
        }

        double contentWidth = w - (isHorizontal() ? 0 : headerHeight);
        double contentHeight = h - (isHorizontal() ? headerHeight: 0);

        for (int i = 0, max = tabContentRegions.size(); i &lt; max; i++) {
            TabContentRegion tabContent = tabContentRegions.get(i);

            tabContent.setAlignment(Pos.TOP_LEFT);
            if (tabContent.getClip() != null) {
                ((Rectangle)tabContent.getClip()).setWidth(contentWidth);
                ((Rectangle)tabContent.getClip()).setHeight(contentHeight);
            }

            // we need to size all tabs, even if they aren't visible. For example,
            // see RT-29167
            tabContent.resize(contentWidth, contentHeight);
            tabContent.relocate(contentStartX, contentStartY);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private static int getRotation(Side pos) {
        switch (pos) {
            case TOP:
                return 0;
            case BOTTOM:
                return 180;
            case LEFT:
                return -90;
            case RIGHT:
                return 90;
            default:
                return 0;
        }
    }

    /**
     * VERY HACKY - this lets us 'duplicate' Label and ImageView nodes to be used in a
     * Tab and the tabs menu at the same time.
     */
    private static Node clone(Node n) {
        if (n == null) {
            return null;
        }
        if (n instanceof ImageView) {
            ImageView iv = (ImageView) n;
            ImageView imageview = new ImageView();
            imageview.imageProperty().bind(iv.imageProperty());
            return imageview;
        }
        if (n instanceof Label) {
            Label l = (Label)n;
            Label label = new Label(l.getText(), clone(l.getGraphic()));
            label.textProperty().bind(l.textProperty());
            return label;
        }
        return null;
    }

    private void removeTabs(List&lt;? extends Tab&gt; removedList) {
        for (final Tab tab : removedList) {
            stopCurrentAnimation(tab);
            // Animate the tab removal
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                tabRegion.isClosing = true;

                tabRegion.removeListeners(tab);
                removeTabContent(tab);

                EventHandler&lt;ActionEvent&gt; cleanup = ae -&gt; {
                    tabRegion.animationState = TabAnimationState.NONE;

                    tabHeaderArea.removeTab(tab);
                    tabHeaderArea.requestLayout();
                    if (getSkinnable().getTabs().isEmpty()) {
                        tabHeaderArea.setVisible(false);
                    }
                };

                if (closeTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.HIDING;
                    Timeline closedTabTimeline = tabRegion.currentAnimation =
                            createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 0.0F, cleanup);
                    closedTabTimeline.play();
                } else {
                    cleanup.handle(null);
                }
            }
        }
    }

    private void stopCurrentAnimation(Tab tab) {
        final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
        if (tabRegion != null) {
            // Execute the code immediately, don't wait for the animation to finish.
            Timeline timeline = tabRegion.currentAnimation;
            if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING) {
                timeline.getOnFinished().handle(null);
                timeline.stop();
                tabRegion.currentAnimation = null;
            }
        }
    }

    private void addTabs(List&lt;? extends Tab&gt; addedList, int from) {
        int i = 0;

        // RT-39984: check if any other tabs are animating - they must be completed first.
        List&lt;Node&gt; headers = new ArrayList&lt;&gt;(tabHeaderArea.headersRegion.getChildren());
        for (Node n : headers) {
            TabHeaderSkin header = (TabHeaderSkin) n;
            if (header.animationState == TabAnimationState.HIDING) {
                stopCurrentAnimation(header.tab);
            }
        }
        // end of fix for RT-39984

        for (final Tab tab : addedList) {
            stopCurrentAnimation(tab); // Note that this must happen before addTab() call below
            // A new tab was added - animate it out
            if (!tabHeaderArea.isVisible()) {
                tabHeaderArea.setVisible(true);
            }
            int index = from + i++;
            tabHeaderArea.addTab(tab, index);
            addTabContent(tab);
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                if (openTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.SHOWING;
                    tabRegion.animationTransition.setValue(0.0);
                    tabRegion.setVisible(true);
                    tabRegion.currentAnimation = createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 1.0, event -&gt; {
                        tabRegion.animationState = TabAnimationState.NONE;
                        tabRegion.setVisible(true);
                        tabRegion.inner.requestLayout();
                    });
                    tabRegion.currentAnimation.play();
                } else {
                    tabRegion.setVisible(true);
                    tabRegion.inner.requestLayout();
                }
            }
        }
    }

    private void initializeTabListener() {
        getSkinnable().getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; {
            List&lt;Tab&gt; tabsToRemove = new ArrayList&lt;&gt;();
            List&lt;Tab&gt; tabsToAdd = new ArrayList&lt;&gt;();
            int insertPos = -1;

            while (c.next()) {
                if (c.wasPermutated()) {
                    if (dragState != DragState.REORDER) {
                        TabPane tabPane = getSkinnable();
                        List&lt;Tab&gt; tabs = tabPane.getTabs();

                        // tabs sorted : create list of permutated tabs.
                        // clear selection, set tab animation to NONE
                        // remove permutated tabs, add them back in correct order.
                        // restore old selection, and old tab animation states.
                        int size = c.getTo() - c.getFrom();
                        Tab selTab = tabPane.getSelectionModel().getSelectedItem();
                        List&lt;Tab&gt; permutatedTabs = new ArrayList&lt;Tab&gt;(size);
                        getSkinnable().getSelectionModel().clearSelection();

                        // save and set tab animation to none - as it is not a good idea
                        // to animate on the same data for open and close.
                        TabAnimation prevOpenAnimation = openTabAnimation.get();
                        TabAnimation prevCloseAnimation = closeTabAnimation.get();
                        openTabAnimation.set(TabAnimation.NONE);
                        closeTabAnimation.set(TabAnimation.NONE);
                        for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                            permutatedTabs.add(tabs.get(i));
                        }

                        removeTabs(permutatedTabs);
                        addTabs(permutatedTabs, c.getFrom());
                        openTabAnimation.set(prevOpenAnimation);
                        closeTabAnimation.set(prevCloseAnimation);
                        getSkinnable().getSelectionModel().select(selTab);
                    }
                }

                if (c.wasRemoved()) {
                    tabsToRemove.addAll(c.getRemoved());
                }
                if (c.wasAdded()) {
                    tabsToAdd.addAll(c.getAddedSubList());
                    insertPos = c.getFrom();
                }
            }

            // now only remove the tabs that are not in the tabsToAdd list
            tabsToRemove.removeAll(tabsToAdd);
            removeTabs(tabsToRemove);

            // and add in any new tabs (that we don't already have showing)
            if (!tabsToAdd.isEmpty()) {
                for (TabContentRegion tabContentRegion : tabContentRegions) {
                    Tab tab = tabContentRegion.getTab();
                    TabHeaderSkin tabHeader = tabHeaderArea.getTabHeaderSkin(tab);
                    if (!tabHeader.isClosing &amp;&amp; tabsToAdd.contains(tabContentRegion.getTab())) {
                        tabsToAdd.remove(tabContentRegion.getTab());
                    }
                }

                addTabs(tabsToAdd, insertPos == -1 ? tabContentRegions.size() : insertPos);
            }

            // Fix for RT-34692
            getSkinnable().requestLayout();
        });
    }

    private void addTabContent(Tab tab) {
        TabContentRegion tabContentRegion = new TabContentRegion(tab);
        tabContentRegion.setClip(new Rectangle());
        tabContentRegions.add(tabContentRegion);
        // We want the tab content to always sit below the tab headers
        getChildren().add(0, tabContentRegion);
    }

    private void removeTabContent(Tab tab) {
        for (TabContentRegion contentRegion : tabContentRegions) {
            if (contentRegion.getTab().equals(tab)) {
                contentRegion.removeListeners(tab);
                getChildren().remove(contentRegion);
                tabContentRegions.remove(contentRegion);
                break;
            }
        }
    }

    private void updateTabPosition() {
        tabHeaderArea.setScrollOffset(0.0F);
        getSkinnable().applyCss();
        getSkinnable().requestLayout();
    }

    private Timeline createTimeline(final TabHeaderSkin tabRegion, final Duration duration, final double endValue, final EventHandler&lt;ActionEvent&gt; func) {
        Timeline timeline = new Timeline();
        timeline.setCycleCount(1);

        KeyValue keyValue = new KeyValue(tabRegion.animationTransition, endValue, Interpolator.LINEAR);
        timeline.getKeyFrames().clear();
        timeline.getKeyFrames().add(new KeyFrame(duration, keyValue));

        timeline.setOnFinished(func);
        return timeline;
    }

    private boolean isHorizontal() {
        Side tabPosition = getSkinnable().getSide();
        return Side.TOP.equals(tabPosition) || Side.BOTTOM.equals(tabPosition);
    }

    private void initializeSwipeHandlers() {
        if (Properties.IS_TOUCH_SUPPORTED) {
            getSkinnable().addEventHandler(SwipeEvent.SWIPE_LEFT, t -&gt; {
                behavior.selectNextTab();
            });

            getSkinnable().addEventHandler(SwipeEvent.SWIPE_RIGHT, t -&gt; {
                behavior.selectPreviousTab();
            });
        }
    }

    //TODO need to cache this.
    private boolean isFloatingStyleClass() {
        return getSkinnable().getStyleClass().contains(TabPane.STYLE_CLASS_FLOATING);
    }



    /***************************************************************************
     *                                                                         *
     * CSS                                                                     *
     *                                                                         *
     **************************************************************************/

   /*
    * Super-lazy instantiation pattern from Bill Pugh.
    */
   private static class StyleableProperties {
        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; OPEN_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-open-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.openTabAnimation;
            }
        };

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; CLOSE_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-close-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.closeTabAnimation;
            }
        };

        static {

           final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
               new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
           styleables.add(OPEN_TAB_ANIMATION);
           styleables.add(CLOSE_TAB_ANIMATION);
           STYLEABLES = Collections.unmodifiableList(styleables);

        }
    }

    /**
     * Returns the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    /**************************************************************************
     *
     * TabHeaderArea: Area responsible for painting all tabs
     *
     **************************************************************************/
    class TabHeaderArea extends StackPane {
        private Rectangle headerClip;
        private StackPane headersRegion;
        private StackPane headerBackground;
        private TabControlButtons controlButtons;

        private boolean measureClosingTabs = false;

        private double scrollOffset;

        public TabHeaderArea() {
            getStyleClass().setAll(&quot;tab-header-area&quot;);
            setManaged(false);
            final TabPane tabPane = getSkinnable();

            headerClip = new Rectangle();

            headersRegion = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double width = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        if (tabHeaderSkin.isVisible() &amp;&amp; (measureClosingTabs || ! tabHeaderSkin.isClosing)) {
                            width += tabHeaderSkin.prefWidth(height);
                        }
                    }
                    return snapSize(width) + snappedLeftInset() + snappedRightInset();
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        height = Math.max(height, tabHeaderSkin.prefHeight(width));
                    }
                    return snapSize(height) + snappedTopInset() + snappedBottomInset();
                }

                @Override protected void layoutChildren() {
                    if (tabsFit()) {
                        setScrollOffset(0.0);
                    } else {
                        if (isSelectingTab) {
                            ensureSelectedTabIsVisible();
                        } else {
                            validateScrollOffset();
                        }
                    }
                    isSelectingTab = false;

                    Side tabPosition = getSkinnable().getSide();
                    double tabBackgroundHeight = snapSize(prefHeight(-1));
                    double tabX = (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) ?
                        snapSize(getWidth()) - getScrollOffset() : getScrollOffset();

                    updateHeaderClip();
                    for (Node node : getChildren()) {
                        TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                        // size and position the header relative to the other headers
                        double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1) * tabHeader.animationTransition.get());
                        double tabHeaderPrefHeight = snapSize(tabHeader.prefHeight(-1));
                        tabHeader.resize(tabHeaderPrefWidth, tabHeaderPrefHeight);

                        // This ensures that the tabs are located in the correct position
                        // when there are tabs of differing heights.
                        double startY = tabPosition.equals(Side.BOTTOM) ?
                            0 : tabBackgroundHeight - tabHeaderPrefHeight - snappedBottomInset();
                        if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                            // build from the right
                            tabX -= tabHeaderPrefWidth;
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                        } else {
                            // build from the left
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                            tabX += tabHeaderPrefWidth;
                        }
                    }
                }

            };
            headersRegion.getStyleClass().setAll(&quot;headers-region&quot;);
            headersRegion.setClip(headerClip);
            setupReordering(headersRegion);

            headerBackground = new StackPane();
            headerBackground.getStyleClass().setAll(&quot;tab-header-background&quot;);

            int i = 0;
            for (Tab tab: tabPane.getTabs()) {
                addTab(tab, i++);
            }

            controlButtons = new TabControlButtons();
            controlButtons.setVisible(false);
            if (controlButtons.isVisible()) {
                controlButtons.setVisible(true);
            }
            getChildren().addAll(headerBackground, headersRegion, controlButtons);

            // support for mouse scroll of header area (for when the tabs exceed
            // the available space).
            // Scrolling the mouse wheel downwards results in the tabs scrolling left (i.e. exposing the right-most tabs)
            // Scrolling the mouse wheel upwards results in the tabs scrolling right (i.e. exposing th left-most tabs)
            addEventHandler(ScrollEvent.SCROLL, (ScrollEvent e) -&gt; {
                Side side = getSkinnable().getSide();
                side = side == null ? Side.TOP : side;
                switch (side) {
                    default:
                    case TOP:
                    case BOTTOM:
                        setScrollOffset(scrollOffset + e.getDeltaY());
                        break;
                    case LEFT:
                    case RIGHT:
                        setScrollOffset(scrollOffset - e.getDeltaY());
                        break;
                }

            });
        }

        private void updateHeaderClip() {
            Side tabPosition = getSkinnable().getSide();

            double x = 0;
            double y = 0;
            double clipWidth = 0;
            double clipHeight = 0;
            double maxWidth = 0;
            double shadowRadius = 0;
            double clipOffset = firstTabIndent();
            double controlButtonPrefWidth = snapSize(controlButtons.prefWidth(-1));

            measureClosingTabs = true;
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            measureClosingTabs = false;

            double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));

            // Add the spacer if isShowTabsMenu is true.
            if (controlButtonPrefWidth &gt; 0) {
                controlButtonPrefWidth = controlButtonPrefWidth + SPACER;
            }

            if (headersRegion.getEffect() instanceof DropShadow) {
                DropShadow shadow = (DropShadow)headersRegion.getEffect();
                shadowRadius = shadow.getRadius();
            }

            maxWidth = snapSize(getWidth()) - controlButtonPrefWidth - clipOffset;
            if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                if (headersPrefWidth &lt; maxWidth) {
                    clipWidth = headersPrefWidth + shadowRadius;
                } else {
                    x = headersPrefWidth - maxWidth;
                    clipWidth = maxWidth + shadowRadius;
                }
                clipHeight = headersPrefHeight;
            } else {
                // If x = 0 the header region's drop shadow is clipped.
                x = -shadowRadius;
                clipWidth = (headersPrefWidth &lt; maxWidth ? headersPrefWidth : maxWidth) + shadowRadius;
                clipHeight = headersPrefHeight;
            }

<A NAME="15"></A>            headerClip.setX(x);
            headerClip.setY(y);
            headerClip.setWidth(clipWidth);
            <FONT color="#3bb9ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#15',2,'match46-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>headerClip.setHeight(clipHeight);
        }

        private void addTab(Tab tab, int addToIndex) {
            TabHeaderSkin tabHeaderSkin = new TabHeaderSkin(tab);
            headersRegion.getChildren</B></FONT>().add(addToIndex, tabHeaderSkin);
        }

        private void removeTab(Tab tab) {
            TabHeaderSkin tabHeaderSkin = getTabHeaderSkin(tab);
            if (tabHeaderSkin != null) {
                headersRegion.getChildren().remove(tabHeaderSkin);
            }
        }

        private TabHeaderSkin getTabHeaderSkin(Tab tab) {
            for (Node child: headersRegion.getChildren()) {
                TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                if (tabHeaderSkin.getTab().equals(tab)) {
                    return tabHeaderSkin;
                }
            }
            return null;
        }

        private boolean tabsFit() {
            double headerPrefWidth = snapSize(headersRegion.prefWidth(-1));
            double controlTabWidth = snapSize(controlButtons.prefWidth(-1));
            double visibleWidth = headerPrefWidth + controlTabWidth + firstTabIndent() + SPACER;
            return visibleWidth &lt; getWidth();
        }

        private void ensureSelectedTabIsVisible() {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // and get where the selected tab is in the header area
            double offset = 0.0;
            double selectedTabOffset = 0.0;
            double selectedTabWidth = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));

                if (selectedTab != null &amp;&amp; selectedTab.equals(tabHeader.getTab())) {
                    selectedTabOffset = offset;
                    selectedTabWidth = tabHeaderPrefWidth;
                }
                offset += tabHeaderPrefWidth;
            }

            final double scrollOffset = getScrollOffset();
            final double selectedTabStartX = selectedTabOffset;
            final double selectedTabEndX = selectedTabOffset + selectedTabWidth;

            final double visibleAreaEndX = visibleWidth;

            if (selectedTabStartX &lt; -scrollOffset) {
                setScrollOffset(-selectedTabStartX);
            } else if (selectedTabEndX &gt; (visibleAreaEndX - scrollOffset)) {
                setScrollOffset(visibleAreaEndX - selectedTabEndX);
            }
        }

        public double getScrollOffset() {
            return scrollOffset;
        }

        private void validateScrollOffset() {
            setScrollOffset(getScrollOffset());
        }

        private void setScrollOffset(double newScrollOffset) {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // measure the width of all tabs
            double offset = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;
                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));
                offset += tabHeaderPrefWidth;
            }

            double actualNewScrollOffset;

            if ((visibleWidth - newScrollOffset) &gt; offset &amp;&amp; newScrollOffset &lt; 0) {
                // need to make sure the right-most tab is attached to the
                // right-hand side of the tab header (e.g. if the tab header area width
                // is expanded), and if it isn't modify the scroll offset to bring
                // it into line. See RT-35194 for a test case.
                actualNewScrollOffset = visibleWidth - offset;
            } else if (newScrollOffset &gt; 0) {
                // need to prevent the left-most tab from becoming detached
                // from the left-hand side of the tab header.
                actualNewScrollOffset = 0;
            } else {
                actualNewScrollOffset = newScrollOffset;
            }

            if (Math.abs(actualNewScrollOffset - scrollOffset) &gt; 0.001) {
                scrollOffset = actualNewScrollOffset;
                headersRegion.requestLayout();
            }
        }

        private double firstTabIndent() {
            switch (getSkinnable().getSide()) {
                case TOP:
                case BOTTOM:
                    return snappedLeftInset();
                case RIGHT:
                case LEFT:
                    return snappedTopInset();
                default:
                    return 0;
            }
        }

        @Override protected double computePrefWidth(double height) {
            double padding = isHorizontal() ?
                snappedLeftInset() + snappedRightInset() :
                snappedTopInset() + snappedBottomInset();
            return snapSize(headersRegion.prefWidth(height)) + controlButtons.prefWidth(height) +
                    firstTabIndent() + SPACER + padding;
        }

        @Override protected double computePrefHeight(double width) {
            double padding = isHorizontal() ?
                snappedTopInset() + snappedBottomInset() :
                snappedLeftInset() + snappedRightInset();
            return snapSize(headersRegion.prefHeight(-1)) + padding;
        }

        @Override public double getBaselineOffset() {
            if (getSkinnable().getSide() == Side.TOP) {
                return headersRegion.getBaselineOffset() + snappedTopInset();
            }
            return 0;
        }

        @Override protected void layoutChildren() {
            final double leftInset = snappedLeftInset();
            final double rightInset = snappedRightInset();
            final double topInset = snappedTopInset();
            final double bottomInset = snappedBottomInset();
            double w = snapSize(getWidth()) - (isHorizontal() ?
                    leftInset + rightInset : topInset + bottomInset);
            double h = snapSize(getHeight()) - (isHorizontal() ?
                    topInset + bottomInset : leftInset + rightInset);
            double tabBackgroundHeight = snapSize(prefHeight(-1));
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));

            controlButtons.showTabsMenu(! tabsFit());

            updateHeaderClip();
            headersRegion.requestLayout();

            // RESIZE CONTROL BUTTONS
            double btnWidth = snapSize(controlButtons.prefWidth(-1));
            final double btnHeight = controlButtons.prefHeight(btnWidth);
            controlButtons.resize(btnWidth, btnHeight);

            // POSITION TABS
            headersRegion.resize(headersPrefWidth, headersPrefHeight);

            if (isFloatingStyleClass()) {
                headerBackground.setVisible(false);
            } else {
                headerBackground.resize(snapSize(getWidth()), snapSize(getHeight()));
                headerBackground.setVisible(true);
            }

            double startX = 0;
            double startY = 0;
            double controlStartX = 0;
            double controlStartY = 0;
            Side tabPosition = getSkinnable().getSide();

            if (tabPosition.equals(Side.TOP)) {
                startX = leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - bottomInset;
                controlStartX = w - btnWidth + leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - bottomInset;
            } else if (tabPosition.equals(Side.RIGHT)) {
                startX = topInset;
                startY = tabBackgroundHeight - headersPrefHeight - leftInset;
                controlStartX = w - btnWidth + topInset;
                controlStartY = snapSize(getHeight()) - btnHeight - leftInset;
            } else if (tabPosition.equals(Side.BOTTOM)) {
                startX = snapSize(getWidth()) - headersPrefWidth - leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - topInset;
                controlStartX = rightInset;
                controlStartY = snapSize(getHeight()) - btnHeight - topInset;
            } else if (tabPosition.equals(Side.LEFT)) {
                startX = snapSize(getWidth()) - headersPrefWidth - topInset;
                startY = tabBackgroundHeight - headersPrefHeight - rightInset;
                controlStartX = leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - rightInset;
            }
            if (headerBackground.isVisible()) {
                positionInArea(headerBackground, 0, 0,
                        snapSize(getWidth()), snapSize(getHeight()), /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
            }
            positionInArea(headersRegion, startX, startY, w, h, /*baseline ignored*/0, HPos.LEFT, VPos.CENTER);
            positionInArea(controlButtons, controlStartX, controlStartY, btnWidth, btnHeight,
                        /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
        }
    } /* End TabHeaderArea */




    /**************************************************************************
     *
     * TabHeaderSkin: skin for each tab
     *
     **************************************************************************/

    class TabHeaderSkin extends StackPane {
        private final Tab tab;
        public Tab getTab() {
            return tab;
        }
        private Label label;
        private StackPane closeBtn;
        private StackPane inner;
        private Tooltip oldTooltip;
        private Tooltip tooltip;
        private Rectangle clip;

        private boolean isClosing = false;

        private LambdaMultiplePropertyChangeListenerHandler listener = new LambdaMultiplePropertyChangeListenerHandler();

        private final ListChangeListener&lt;String&gt; styleClassListener = new ListChangeListener&lt;String&gt;() {
            @Override
            public void onChanged(Change&lt;? extends String&gt; c) {
                getStyleClass().setAll(tab.getStyleClass());
            }
        };

        private final WeakListChangeListener&lt;String&gt; weakStyleClassListener =
                new WeakListChangeListener&lt;&gt;(styleClassListener);

        public TabHeaderSkin(final Tab tab) {
            getStyleClass().setAll(tab.getStyleClass());
            setId(tab.getId());
            setStyle(tab.getStyle());
            setAccessibleRole(AccessibleRole.TAB_ITEM);
            setViewOrder(1);

            this.tab = tab;
            clip = new Rectangle();
            setClip(clip);

            label = new Label(tab.getText(), tab.getGraphic());
            label.getStyleClass().setAll(&quot;tab-label&quot;);

            closeBtn = new StackPane() {
                @Override protected double computePrefWidth(double h) {
                    return CLOSE_BTN_SIZE;
                }
                @Override protected double computePrefHeight(double w) {
                    return CLOSE_BTN_SIZE;
                }
                @Override
                public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
                    switch (action) {
                        case FIRE: {
                            Tab tab = getTab();
                            if (behavior.canCloseTab(tab)) {
                                behavior.closeTab(tab);
                                setOnMousePressed(null);
                            }
                            break;
                        }
                        default: super.executeAccessibleAction(action, parameters);
                    }
                }
            };
            closeBtn.setAccessibleRole(AccessibleRole.BUTTON);
            closeBtn.setAccessibleText(getString(&quot;Accessibility.title.TabPane.CloseButton&quot;));
            closeBtn.getStyleClass().setAll(&quot;tab-close-button&quot;);
            closeBtn.setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override
                public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (me.getButton().equals(MouseButton.PRIMARY) &amp;&amp; behavior.canCloseTab(tab)) {
                        behavior.closeTab(tab);
                        setOnMousePressed(null);
                        me.consume();
                    }
                }
            });

            updateGraphicRotation();

            final Region focusIndicator = new Region();
            focusIndicator.setMouseTransparent(true);
            focusIndicator.getStyleClass().add(&quot;focus-indicator&quot;);

            inner = new StackPane() {
                @Override protected void layoutChildren() {
                    final TabPane skinnable = getSkinnable();

                    final double paddingTop = snappedTopInset();
                    final double paddingRight = snappedRightInset();
                    final double paddingBottom = snappedBottomInset();
                    final double paddingLeft = snappedLeftInset();
                    final double w = getWidth() - (paddingLeft + paddingRight);
                    final double h = getHeight() - (paddingTop + paddingBottom);

                    final double prefLabelWidth = snapSize(label.prefWidth(-1));
                    final double prefLabelHeight = snapSize(label.prefHeight(-1));

                    final double closeBtnWidth = showCloseButton() ? snapSize(closeBtn.prefWidth(-1)) : 0;
                    final double closeBtnHeight = showCloseButton() ? snapSize(closeBtn.prefHeight(-1)) : 0;
                    final double minWidth = snapSize(skinnable.getTabMinWidth());
                    final double maxWidth = snapSize(skinnable.getTabMaxWidth());
                    final double maxHeight = snapSize(skinnable.getTabMaxHeight());

                    double labelAreaWidth = prefLabelWidth;
                    double labelWidth = prefLabelWidth;
                    double labelHeight = prefLabelHeight;

                    final double childrenWidth = labelAreaWidth + closeBtnWidth;
                    final double childrenHeight = Math.max(labelHeight, closeBtnHeight);

                    if (childrenWidth &gt; maxWidth &amp;&amp; maxWidth != Double.MAX_VALUE) {
                        labelAreaWidth = maxWidth - closeBtnWidth;
                        labelWidth = maxWidth - closeBtnWidth;
                    } else if (childrenWidth &lt; minWidth) {
                        labelAreaWidth = minWidth - closeBtnWidth;
                    }

                    if (childrenHeight &gt; maxHeight &amp;&amp; maxHeight != Double.MAX_VALUE) {
                        labelHeight = maxHeight;
                    }

                    if (animationState != TabAnimationState.NONE) {
//                        if (prefWidth.getValue() &lt; labelAreaWidth) {
//                            labelAreaWidth = prefWidth.getValue();
//                        }
                        labelAreaWidth *= animationTransition.get();
                        closeBtn.setVisible(false);
                    } else {
                        closeBtn.setVisible(showCloseButton());
                    }


                    label.resize(labelWidth, labelHeight);


                    double labelStartX = paddingLeft;

                    // If maxWidth is less than Double.MAX_VALUE, the user has
                    // clamped the max width, but we should
                    // position the close button at the end of the tab,
                    // which may not necessarily be the entire width of the
                    // provided max width.
                    double closeBtnStartX = (maxWidth &lt; Double.MAX_VALUE ? Math.min(w, maxWidth) : w) - paddingRight - closeBtnWidth;

                    positionInArea(label, labelStartX, paddingTop, labelAreaWidth, h,
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);

                    if (closeBtn.isVisible()) {
                        closeBtn.resize(closeBtnWidth, closeBtnHeight);
                        positionInArea(closeBtn, closeBtnStartX, paddingTop, closeBtnWidth, h,
                                /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                    }

                    // Magic numbers regretfully introduced for RT-28944 (so that
                    // the focus rect appears as expected on Windows and Mac).
                    // In short we use the vPadding to shift the focus rect down
                    // into the content area (whereas previously it was being clipped
                    // on Windows, whilst it still looked fine on Mac). In the
                    // future we may want to improve this code to remove the
                    // magic number. Similarly, the hPadding differs on Mac.
                    final int vPadding = Utils.isMac() ? 2 : 3;
                    final int hPadding = Utils.isMac() ? 2 : 1;
                    focusIndicator.resizeRelocate(
                            paddingLeft - hPadding,
                            paddingTop + vPadding,
                            w + 2 * hPadding,
                            h - 2 * vPadding);
                }
            };
            inner.getStyleClass().add(&quot;tab-container&quot;);
            inner.setRotate(getSkinnable().getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            inner.getChildren().addAll(label, closeBtn, focusIndicator);

            getChildren().addAll(inner);

            tooltip = tab.getTooltip();
            if (tooltip != null) {
                Tooltip.install(this, tooltip);
                oldTooltip = tooltip;
            }

            listener.registerChangeListener(tab.closableProperty(), e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.selectedProperty(), e -&gt; {
                pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
                // Need to request a layout pass for inner because if the width
                // and height didn't not change the label or close button may have
                // changed.
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.textProperty(),e -&gt; label.setText(getTab().getText()));
            listener.registerChangeListener(tab.graphicProperty(), e -&gt; label.setGraphic(getTab().getGraphic()));
            listener.registerChangeListener(tab.tooltipProperty(), e -&gt; {
                // uninstall the old tooltip
                if (oldTooltip != null) {
                    Tooltip.uninstall(this, oldTooltip);
                }
                tooltip = tab.getTooltip();
                if (tooltip != null) {
                    // install new tooltip and save as old tooltip.
                    Tooltip.install(this, tooltip);
                    oldTooltip = tooltip;
                }
            });
            listener.registerChangeListener(tab.disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.getTabPane().disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.styleProperty(), e -&gt; setStyle(tab.getStyle()));

            tab.getStyleClass().addListener(weakStyleClassListener);

            listener.registerChangeListener(getSkinnable().tabClosingPolicyProperty(),e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(getSkinnable().sideProperty(),e -&gt; {
                final Side side = getSkinnable().getSide();
                pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
                pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
                pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
                pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
                inner.setRotate(side == Side.BOTTOM ? 180.0F : 0.0F);
                if (getSkinnable().isRotateGraphic()) {
                    updateGraphicRotation();
                }
            });
            listener.registerChangeListener(getSkinnable().rotateGraphicProperty(), e -&gt; updateGraphicRotation());
            listener.registerChangeListener(getSkinnable().tabMinWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMaxWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMinHeightProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMaxHeightProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });

            getProperties().put(Tab.class, tab);
            getProperties().put(ContextMenu.class, tab.getContextMenu());

            setOnContextMenuRequested((ContextMenuEvent me) -&gt; {
               if (getTab().getContextMenu() != null) {
                    getTab().getContextMenu().show(inner, me.getScreenX(), me.getScreenY());
                    me.consume();
                }
            });
            setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (tab.isDisable()) {
                        return;
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)
                        || me.getButton().equals(MouseButton.PRIMARY)) {

                        if (tab.getContextMenu() != null
                            &amp;&amp; tab.getContextMenu().isShowing()) {
                            tab.getContextMenu().hide();
                        }
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)) {
                        if (showCloseButton()) {
                            if (behavior.canCloseTab(tab)) {
                                removeListeners(tab);
                                behavior.closeTab(tab);
                            }
                        }
                    } else if (me.getButton().equals(MouseButton.PRIMARY)) {
                        behavior.selectTab(tab);
                    }
                }
            });

            // initialize pseudo-class state
            pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            final Side side = getSkinnable().getSide();
            pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
            pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
            pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
            pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
        }

        private void updateTabDisabledState() {
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            inner.requestLayout();
            requestLayout();
        }

        private void updateGraphicRotation() {
            if (label.getGraphic() != null) {
                label.getGraphic().setRotate(getSkinnable().isRotateGraphic() ? 0.0F :
                    (getSkinnable().getSide().equals(Side.RIGHT) ? -90.0F :
                        (getSkinnable().getSide().equals(Side.LEFT) ? 90.0F : 0.0F)));
            }
        }

        private boolean showCloseButton() {
            return tab.isClosable() &amp;&amp;
                    (getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.ALL_TABS) ||
                    getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.SELECTED_TAB) &amp;&amp; tab.isSelected());
        }

        private final DoubleProperty animationTransition = new SimpleDoubleProperty(this, &quot;animationTransition&quot;, 1.0) {
            @Override protected void invalidated() {
                requestLayout();
            }
        };

        private void removeListeners(Tab tab) {
            listener.dispose();
            inner.getChildren().clear();
            getChildren().clear();
            setOnContextMenuRequested(null);
            setOnMousePressed(null);
        }

        private TabAnimationState animationState = TabAnimationState.NONE;
        private Timeline currentAnimation;

        @Override protected double computePrefWidth(double height) {
//            if (animating) {
//                return prefWidth.getValue();
//            }
            double minWidth = snapSize(getSkinnable().getTabMinWidth());
            double maxWidth = snapSize(getSkinnable().getTabMaxWidth());
            double paddingRight = snappedRightInset();
            double paddingLeft = snappedLeftInset();
            double tmpPrefWidth = snapSize(label.prefWidth(-1));

            // only include the close button width if it is relevant
            if (showCloseButton()) {
                tmpPrefWidth += snapSize(closeBtn.prefWidth(-1));
            }

            if (tmpPrefWidth &gt; maxWidth) {
                tmpPrefWidth = maxWidth;
            } else if (tmpPrefWidth &lt; minWidth) {
                tmpPrefWidth = minWidth;
            }
            tmpPrefWidth += paddingRight + paddingLeft;
//            prefWidth.setValue(tmpPrefWidth);
            return tmpPrefWidth;
        }

        @Override protected double computePrefHeight(double width) {
            double minHeight = snapSize(getSkinnable().getTabMinHeight());
            double maxHeight = snapSize(getSkinnable().getTabMaxHeight());
            double paddingTop = snappedTopInset();
            double paddingBottom = snappedBottomInset();
            double tmpPrefHeight = snapSize(label.prefHeight(width));

            if (tmpPrefHeight &gt; maxHeight) {
                tmpPrefHeight = maxHeight;
            } else if (tmpPrefHeight &lt; minHeight) {
                tmpPrefHeight = minHeight;
            }
            tmpPrefHeight += paddingTop + paddingBottom;
            return tmpPrefHeight;
        }

        @Override protected void layoutChildren() {
            double w = (snapSize(getWidth()) - snappedRightInset() - snappedLeftInset()) * animationTransition.getValue();
            inner.resize(w, snapSize(getHeight()) - snappedTopInset() - snappedBottomInset());
            inner.relocate(snappedLeftInset(), snappedTopInset());
        }

        @Override protected void setWidth(double value) {
            super.setWidth(value);
            clip.setWidth(value);
        }

        @Override protected void setHeight(double value) {
            super.setHeight(value);
            clip.setHeight(value);
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case TEXT: return getTab().getText();
                case SELECTED: return selectedTab == getTab();
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }

        /** {@inheritDoc} */
        @Override
        public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
            switch (action) {
                case REQUEST_FOCUS:
                    getSkinnable().getSelectionModel().select(getTab());
                    break;
                default: super.executeAccessibleAction(action, parameters);
            }
        }

    } /* End TabHeaderSkin */

    private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;selected&quot;);
    private static final PseudoClass TOP_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;top&quot;);
    private static final PseudoClass BOTTOM_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;bottom&quot;);
    private static final PseudoClass LEFT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;left&quot;);
    private static final PseudoClass RIGHT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;right&quot;);
    private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;disabled&quot;);


    /**************************************************************************
     *
     * TabContentRegion: each tab has one to contain the tab's content node
     *
     **************************************************************************/
    static class TabContentRegion extends StackPane {

        private Tab tab;

        private InvalidationListener tabContentListener = valueModel -&gt; {
            updateContent();
        };
        private InvalidationListener tabSelectedListener = new InvalidationListener() {
            @Override public void invalidated(Observable valueModel) {
                setVisible(tab.isSelected());
            }
        };

        private WeakInvalidationListener weakTabContentListener =
                new WeakInvalidationListener(tabContentListener);
        private WeakInvalidationListener weakTabSelectedListener =
                new WeakInvalidationListener(tabSelectedListener);

        public Tab getTab() {
            return tab;
        }

        public TabContentRegion(Tab tab) {
            getStyleClass().setAll(&quot;tab-content-area&quot;);
            setManaged(false);
            this.tab = tab;
            updateContent();
            setVisible(tab.isSelected());

            tab.selectedProperty().addListener(weakTabSelectedListener);
            tab.contentProperty().addListener(weakTabContentListener);
        }

        private void updateContent() {
            Node newContent = getTab().getContent();
            if (newContent == null) {
                getChildren().clear();
            } else {
                getChildren().setAll(newContent);
            }
        }

        private void removeListeners(Tab tab) {
            tab.selectedProperty().removeListener(weakTabSelectedListener);
            tab.contentProperty().removeListener(weakTabContentListener);
        }

    } /* End TabContentRegion */

    /**************************************************************************
     *
     * TabControlButtons: controls to manipulate tab interaction
     *
     **************************************************************************/
    class TabControlButtons extends StackPane {
        private StackPane inner;
        private StackPane downArrow;
        private Pane downArrowBtn;
        private boolean showControlButtons;
        private ContextMenu popup;

        public TabControlButtons() {
            getStyleClass().setAll(&quot;control-buttons-tab&quot;);

            TabPane tabPane = getSkinnable();

            downArrowBtn = new Pane();
            downArrowBtn.getStyleClass().setAll(&quot;tab-down-button&quot;);
            downArrowBtn.setVisible(isShowTabsMenu());
            downArrow = new StackPane();
            downArrow.setManaged(false);
            downArrow.getStyleClass().setAll(&quot;arrow&quot;);
            downArrow.setRotate(tabPane.getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            downArrowBtn.getChildren().add(downArrow);
            downArrowBtn.setOnMouseClicked(me -&gt; {
                showPopupMenu();
            });

            setupPopupMenu();

            inner = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double pw;
                    double maxArrowWidth = ! isShowTabsMenu() ? 0 : snapSize(downArrow.prefWidth(getHeight())) + snapSize(downArrowBtn.prefWidth(getHeight()));
                    pw = 0.0F;
                    if (isShowTabsMenu()) {
                        pw += maxArrowWidth;
                    }
                    if (pw &gt; 0) {
                        pw += snappedLeftInset() + snappedRightInset();
                    }
                    return pw;
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    if (isShowTabsMenu()) {
                        height = Math.max(height, snapSize(downArrowBtn.prefHeight(width)));
                    }
                    if (height &gt; 0) {
                        height += snappedTopInset() + snappedBottomInset();
                    }
                    return height;
                }

                @Override protected void layoutChildren() {
                    if (isShowTabsMenu()) {
                        double x = 0;
                        double y = snappedTopInset();
                        double w = snapSize(getWidth()) - x + snappedLeftInset();
                        double h = snapSize(getHeight()) - y + snappedBottomInset();
                        positionArrow(downArrowBtn, downArrow, x, y, w, h);
                    }
                }

                private void positionArrow(Pane btn, StackPane arrow, double x, double y, double width, double height) {
                    btn.resize(width, height);
                    positionInArea(btn, x, y, width, height, /*baseline ignored*/0,
                            HPos.CENTER, VPos.CENTER);
                    // center arrow region within arrow button
                    double arrowWidth = snapSize(arrow.prefWidth(-1));
                    double arrowHeight = snapSize(arrow.prefHeight(-1));
                    arrow.resize(arrowWidth, arrowHeight);
                    positionInArea(arrow, btn.snappedLeftInset(), btn.snappedTopInset(),
                            width - btn.snappedLeftInset() - btn.snappedRightInset(),
                            height - btn.snappedTopInset() - btn.snappedBottomInset(),
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                }
            };
            inner.getStyleClass().add(&quot;container&quot;);
            inner.getChildren().add(downArrowBtn);

            getChildren().add(inner);

            tabPane.sideProperty().addListener(valueModel -&gt; {
                Side tabPosition = getSkinnable().getSide();
                downArrow.setRotate(tabPosition.equals(Side.BOTTOM)? 180.0F : 0.0F);
            });
            tabPane.getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; setupPopupMenu());
            showControlButtons = false;
            if (isShowTabsMenu()) {
                showControlButtons = true;
                requestLayout();
            }
            getProperties().put(ContextMenu.class, popup);
        }

        private boolean showTabsMenu = false;

        private void showTabsMenu(boolean value) {
            final boolean wasTabsMenuShowing = isShowTabsMenu();
            this.showTabsMenu = value;

            if (showTabsMenu &amp;&amp; !wasTabsMenuShowing) {
                downArrowBtn.setVisible(true);
                showControlButtons = true;
                inner.requestLayout();
                tabHeaderArea.requestLayout();
            } else if (!showTabsMenu &amp;&amp; wasTabsMenuShowing) {
                hideControlButtons();
            }
        }

        private boolean isShowTabsMenu() {
            return showTabsMenu;
        }

        @Override protected double computePrefWidth(double height) {
            double pw = snapSize(inner.prefWidth(height));
            if (pw &gt; 0) {
                pw += snappedLeftInset() + snappedRightInset();
            }
            return pw;
        }

        @Override protected double computePrefHeight(double width) {
            return Math.max(getSkinnable().getTabMinHeight(), snapSize(inner.prefHeight(width))) +
                    snappedTopInset() + snappedBottomInset();
        }

        @Override protected void layoutChildren() {
            double x = snappedLeftInset();
            double y = snappedTopInset();
            double w = snapSize(getWidth()) - x + snappedRightInset();
            double h = snapSize(getHeight()) - y + snappedBottomInset();

            if (showControlButtons) {
                showControlButtons();
                showControlButtons = false;
            }

            inner.resize(w, h);
            positionInArea(inner, x, y, w, h, /*baseline ignored*/0, HPos.CENTER, VPos.BOTTOM);
        }

        private void showControlButtons() {
            setVisible(true);
            if (popup == null) {
                setupPopupMenu();
            }
        }

        private void hideControlButtons() {
            // If the scroll arrows or tab menu is still visible we don't want
            // to hide it animate it back it.
            if (isShowTabsMenu()) {
                showControlButtons = true;
            } else {
                setVisible(false);
                clearPopupMenu();
                popup = null;
            }

            // This needs to be called when we are in the left tabPosition
            // to allow for the clip offset to move properly (otherwise
            // it jumps too early - before the animation is done).
            requestLayout();
        }

        private void setupPopupMenu() {
            if (popup == null) {
                popup = new ContextMenu();
            }
            clearPopupMenu();
            ToggleGroup group = new ToggleGroup();
            ObservableList&lt;RadioMenuItem&gt; menuitems = FXCollections.&lt;RadioMenuItem&gt;observableArrayList();
            for (final Tab tab : getSkinnable().getTabs()) {
                TabMenuItem item = new TabMenuItem(tab);
                item.setToggleGroup(group);
                item.setOnAction(t -&gt; getSkinnable().getSelectionModel().select(tab));
                menuitems.add(item);
            }
            popup.getItems().addAll(menuitems);
        }

        private void clearPopupMenu() {
            for (MenuItem item : popup.getItems()) {
                ((TabMenuItem) item).dispose();
            }
            popup.getItems().clear();
        }

        private void showPopupMenu() {
            for (MenuItem mi: popup.getItems()) {
                TabMenuItem tmi = (TabMenuItem)mi;
                if (selectedTab.equals(tmi.getTab())) {
                    tmi.setSelected(true);
                    break;
                }
            }
            popup.show(downArrowBtn, Side.BOTTOM, 0, 0);
        }
    } /* End TabControlButtons*/

    static class TabMenuItem extends RadioMenuItem {
        Tab tab;

        private InvalidationListener disableListener = new InvalidationListener() {
            @Override public void invalidated(Observable o) {
                setDisable(tab.isDisable());
            }
        };

        private WeakInvalidationListener weakDisableListener =
                new WeakInvalidationListener(disableListener);

        public TabMenuItem(final Tab tab) {
            super(tab.getText(), TabPaneSkin.clone(tab.getGraphic()));
            this.tab = tab;
            setDisable(tab.isDisable());
            tab.disableProperty().addListener(weakDisableListener);
            textProperty().bind(tab.textProperty());
        }

        public Tab getTab() {
            return tab;
        }

        public void dispose() {
            textProperty().unbind();
            tab.disableProperty().removeListener(weakDisableListener);
            tab = null;
        }
    }

    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case FOCUS_ITEM: return tabHeaderArea.getTabHeaderSkin(selectedTab);
            case ITEM_COUNT: return tabHeaderArea.headersRegion.getChildren().size();
            case ITEM_AT_INDEX: {
                Integer index = (Integer)parameters[0];
                if (index == null) return null;
                return tabHeaderArea.headersRegion.getChildren().get(index);
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    // --------------------------
    // Tab Reordering
    // --------------------------
    private enum DragState {
        NONE,
        START,
        REORDER
    }
    private EventHandler&lt;MouseEvent&gt; headerDraggedHandler = this::handleHeaderDragged;
    private EventHandler&lt;MouseEvent&gt; headerMousePressedHandler = this::handleHeaderMousePressed;
    private EventHandler&lt;MouseEvent&gt; headerMouseReleasedHandler = this::handleHeaderMouseReleased;

    private int dragTabHeaderIndex;
    private TabHeaderSkin dragTabHeader;
    private TabHeaderSkin dropTabHeader;
    private StackPane headersRegion;
    private DragState dragState;
    private final int MIN_TO_MAX = 1;
    private final int MAX_TO_MIN = -1;
    private int xLayoutDirection;
    private double dragEventPrevLoc;
    private int prevDragDirection = MIN_TO_MAX;
    private final double DRAG_DIST_THRESHOLD = 0.75;

    // Reordering Animation
    private final double ANIM_DURATION = 120;
    private TabHeaderSkin dropAnimHeader;
    private Tab swapTab;
    private double dropHeaderSourceX;
    private double dropHeaderTransitionX;
    private final Animation dropHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_BOTH);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                completeHeaderReordering();
            });
        }
        protected void interpolate(double frac) {
            dropAnimHeader.setLayoutX(dropHeaderSourceX + dropHeaderTransitionX * frac);
        }
    };
    private double dragHeaderStartX;
    private double dragHeaderDestX;
    private double dragHeaderSourceX;
    private double dragHeaderTransitionX;
    private final Animation dragHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_OUT);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                resetDrag();
            });
        }
        protected void interpolate(double frac) {
            dragTabHeader.setLayoutX(dragHeaderSourceX + dragHeaderTransitionX * frac);
        }
    };

    // Helper methods for managing the listeners based on TabDragPolicy.
    private void addReorderListeners(Node n) {
        n.addEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.addEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.addEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private void removeReorderListeners(Node n) {
        n.removeEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private ListChangeListener childListener = new ListChangeListener&lt;Node&gt;() {
        public void onChanged(Change&lt;? extends Node&gt; change) {
            while (change.next()) {
                if (change.wasAdded()) {
                    for(Node n : change.getAddedSubList()) {
                        addReorderListeners(n);
                    }
                }
                if (change.wasRemoved()) {
                    for(Node n : change.getRemoved()) {
                        removeReorderListeners(n);
                    }
                }
            }
        }
    };

    private void updateListeners() {
        if (getSkinnable().getTabDragPolicy() == TabDragPolicy.FIXED ||
                getSkinnable().getTabDragPolicy() == null) {
            for (Node n : headersRegion.getChildren()) {
                removeReorderListeners(n);
            }
            headersRegion.getChildren().removeListener(childListener);
        } else if (getSkinnable().getTabDragPolicy() == TabDragPolicy.REORDER) {
            for (Node n : headersRegion.getChildren()) {
                addReorderListeners(n);
            }
            headersRegion.getChildren().addListener(childListener);
        }
    }

    private void setupReordering(StackPane headersRegion) {
        dragState = DragState.NONE;
        this.headersRegion = headersRegion;
        updateListeners();
        getSkinnable().tabDragPolicyProperty().addListener((observable, oldValue, newValue) -&gt; {
            if (oldValue != newValue) {
                updateListeners();
            }
        });
    }

    private void handleHeaderMousePressed(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(true);
            startDrag(event);
        }
    }

    private void handleHeaderMouseReleased(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(false);
            stopDrag();
            event.consume();
        }
    }

    private void handleHeaderDragged(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            perfromDrag(event);
        }
    }

    private double getDragDelta(double curr, double prev) {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            return curr - prev;
        } else {
            return prev - curr;
        }
    }

    private int deriveTabHeaderLayoutXDirection() {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            // TabHeaderSkin are laid out in left to right direction inside headersRegion
            return MIN_TO_MAX;
        }
        // TabHeaderSkin are laid out in right to left direction inside headersRegion
        return MAX_TO_MIN;
    }

    private void perfromDrag(MouseEvent event) {
        int dragDirection;
        double dragHeaderNewLayoutX;
        Bounds dragHeaderBounds;
        Bounds dropHeaderBounds;
        double draggedDist;
        double mouseCurrentLoc = getHeaderRegionLocalX(event);
        double dragDelta = getDragDelta(mouseCurrentLoc, dragEventPrevLoc);

        if (dragDelta &gt; 0) {
            // Dragging the tab header towards higher indexed tab headers inside headersRegion.
            dragDirection = MIN_TO_MAX;
        } else {
            // Dragging the tab header towards lower indexed tab headers inside headersRegion.
            dragDirection = MAX_TO_MIN;
        }
        // Stop dropHeaderAnim if direction of drag is changed
        if (prevDragDirection != dragDirection) {
            stopAnim(dropHeaderAnim);
            prevDragDirection = dragDirection;
        }

        dragHeaderNewLayoutX = dragTabHeader.getLayoutX() + xLayoutDirection * dragDelta;

        if (dragHeaderNewLayoutX &gt;= 0 &amp;&amp;
                dragHeaderNewLayoutX + dragTabHeader.getWidth() &lt;= headersRegion.getWidth()) {

            dragState = DragState.REORDER;
            dragTabHeader.setLayoutX(dragHeaderNewLayoutX);
            dragHeaderBounds = dragTabHeader.getBoundsInParent();

            if (dragDirection == MIN_TO_MAX) {
                // Dragging the tab header towards higher indexed tab headers
                // Last tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // headers to be reordered.
                for (int i = dragTabHeaderIndex + 1; i &lt; headersRegion.getChildren().size(); i++) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        } else {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab header crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * -dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            } else {
                // dragDirection is MAX_TO_MIN
                // Dragging the tab header towards lower indexed tab headers.
                // First tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // tab headers to be reordered.
                for (int i = dragTabHeaderIndex - 1; i &gt;= 0; i--) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        } else {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            }
        }
        dragEventPrevLoc = mouseCurrentLoc;
        event.consume();
    }

    private void startDrag(MouseEvent event) {
        // Stop the animations if any are running from previous reorder.
        stopAnim(dropHeaderAnim);
        stopAnim(dragHeaderAnim);

        dragTabHeader = (TabHeaderSkin) event.getSource();
        if (dragTabHeader != null) {
            dragState = DragState.START;
            swapTab = null;
            xLayoutDirection = deriveTabHeaderLayoutXDirection();
            dragEventPrevLoc = getHeaderRegionLocalX(event);
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
            dragTabHeader.setViewOrder(0);
            dragHeaderStartX = dragHeaderDestX = dragTabHeader.getLayoutX();
        }
    }

    private double getHeaderRegionLocalX(MouseEvent ev) {
        // The event is converted to tab header's parent i.e. headersRegion's local space.
        // This will provide a value of X co-ordinate with all transformations of TabPane
        // and transformations of all nodes in the TabPane's parent hierarchy.
        Point2D sceneToLocalHR = headersRegion.sceneToLocal(ev.getSceneX(), ev.getSceneY());
        return sceneToLocalHR.getX();
    }

    private void stopDrag() {
        if (dragState == DragState.START) {
            // No drag action was performed.
            resetDrag();
            return;
        }
        // Animate tab header being dragged to its final position.
        dragHeaderSourceX = dragTabHeader.getLayoutX();
        dragHeaderTransitionX = dragHeaderDestX - dragHeaderSourceX;
        dragHeaderAnim.playFromStart();

        // Reorder the tab list.
        if (dragHeaderStartX != dragHeaderDestX) {
            ((TabObservableList&lt;Tab&gt;) getSkinnable().getTabs()).reorder(dragTabHeader.tab, swapTab);
            swapTab = null;
        }
    }

    private void resetDrag() {
        dragState = DragState.NONE;
        dragTabHeader.setViewOrder(1);
        dragTabHeader = null;
        dropTabHeader = null;
        headersRegion.requestLayout();
    }

    // Animate tab header being dropped-on to its new position.
    private void startHeaderReorderingAnim() {
        dropAnimHeader = dropTabHeader;
        swapTab = dropAnimHeader.tab;
        dropHeaderSourceX = dropAnimHeader.getLayoutX();
        dropHeaderAnim.playFromStart();
    }

    // Remove dropAnimHeader and add at the index position of dragTabHeader.
    private void completeHeaderReordering() {
        if (dropAnimHeader != null) {
            headersRegion.getChildren().remove(dropAnimHeader);
            headersRegion.getChildren().add(dragTabHeaderIndex, dropAnimHeader);
            dropAnimHeader = null;
            headersRegion.requestLayout();
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
        }
    }

    // Helper method to stop an animation.
    private void stopAnim(Animation anim) {
        if (anim.getStatus() == Animation.Status.RUNNING) {
            anim.getOnFinished().handle(null);
            anim.stop();
        }
    }

    // For testing purpose.
    ContextMenu test_getTabsMenu() {
        return tabHeaderArea.controlButtons.popup;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TextAreaSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.behavior.BehaviorBase;
import com.sun.javafx.scene.control.behavior.TextAreaBehavior;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.binding.BooleanBinding;
import javafx.beans.binding.DoubleBinding;
import javafx.beans.binding.IntegerBinding;
import javafx.beans.value.ObservableBooleanValue;
import javafx.beans.value.ObservableIntegerValue;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.Orientation;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.geometry.VPos;
import javafx.geometry.VerticalDirection;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.control.Accordion;
import javafx.scene.control.Button;
import javafx.scene.control.Control;
import javafx.scene.control.IndexRange;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.Region;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.Path;
import javafx.scene.shape.PathElement;
import javafx.scene.text.Text;
import javafx.scene.text.HitInfo;
import javafx.util.Duration;

import java.util.List;

import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;

/**
 * Default skin implementation for the {@link TextArea} control.
 *
 * @see TextArea
 * @since 9
 */
public class TextAreaSkin extends TextInputControlSkin&lt;TextArea&gt; {

    /**************************************************************************
     *
     * Static fields
     *
     **************************************************************************/

    /** A shared helper object, used only by downLines(). */
    private static final Path tmpCaretPath = new Path();



    /**************************************************************************
     *
     * Private fields
     *
     **************************************************************************/

    final private TextArea textArea;

    // *** NOTE: Multiple node mode is not yet fully implemented *** //
    private static final boolean USE_MULTIPLE_NODES = false;

    private final TextAreaBehavior behavior;

    private double computedMinWidth = Double.NEGATIVE_INFINITY;
    private double computedMinHeight = Double.NEGATIVE_INFINITY;
    private double computedPrefWidth = Double.NEGATIVE_INFINITY;
    private double computedPrefHeight = Double.NEGATIVE_INFINITY;
    private double widthForComputedPrefHeight = Double.NEGATIVE_INFINITY;
    private double characterWidth;
    private double lineHeight;

    private ContentView contentView = new ContentView();
    private Group paragraphNodes = new Group();

    private Text promptNode;
    private ObservableBooleanValue usePromptText;

    private ObservableIntegerValue caretPosition;
    private Group selectionHighlightGroup = new Group();

    private ScrollPane scrollPane;
    private Bounds oldViewportBounds;

    private VerticalDirection scrollDirection = null;

    private Path characterBoundingPath = new Path();

    private Timeline scrollSelectionTimeline = new Timeline();
    private EventHandler&lt;ActionEvent&gt; scrollSelectionHandler = event -&gt; {
        switch (scrollDirection) {
            case UP: {
                // TODO Get previous offset
                break;
            }

            case DOWN: {
                // TODO Get next offset
                break;
            }
        }
    };

    private double pressX, pressY; // For dragging handles on embedded
    private boolean handlePressed;

    /**
     * Remembers horizontal position when traversing up / down.
     */
    double targetCaretX = -1;



    /**************************************************************************
     *
     * Constructors
     *
     **************************************************************************/

    /**
     * Creates a new TextAreaSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TextAreaSkin(final TextArea control) {
        super(control);

        // install default input map for the text area control
        this.behavior = new TextAreaBehavior(control);
        this.behavior.setTextAreaSkin(this);
//        control.setInputMap(behavior.getInputMap());

        this.textArea = control;

        caretPosition = new IntegerBinding() {
            { bind(control.caretPositionProperty()); }
            @Override protected int computeValue() {
                return control.getCaretPosition();
            }
        };
        caretPosition.addListener((observable, oldValue, newValue) -&gt; {
            targetCaretX = -1;
            if (control.getWidth() &gt; 0) {
                setForwardBias(true);
            }
        });

        forwardBiasProperty().addListener(observable -&gt; {
            if (control.getWidth() &gt; 0) {
                updateTextNodeCaretPos(control.getCaretPosition());
            }
        });

//        setManaged(false);

        // Initialize content
        scrollPane = new ScrollPane();
        scrollPane.setFitToWidth(control.isWrapText());
        scrollPane.setContent(contentView);
        getChildren().add(scrollPane);

        getSkinnable().addEventFilter(ScrollEvent.ANY, event -&gt; {
            if (event.isDirect() &amp;&amp; handlePressed) {
                event.consume();
            }
        });

        // Add selection
        selectionHighlightGroup.setManaged(false);
        selectionHighlightGroup.setVisible(false);
        contentView.getChildren().add(selectionHighlightGroup);

        // Add content view
        paragraphNodes.setManaged(false);
        contentView.getChildren().add(paragraphNodes);

        // Add caret
        caretPath.setManaged(false);
        caretPath.setStrokeWidth(1);
        caretPath.fillProperty().bind(textFillProperty());
        caretPath.strokeProperty().bind(textFillProperty());
        // modifying visibility of the caret forces a layout-pass (RT-32373), so
        // instead we modify the opacity.
        caretPath.opacityProperty().bind(new DoubleBinding() {
            { bind(caretVisibleProperty()); }
            @Override protected double computeValue() {
                return caretVisibleProperty().get() ? 1.0 : 0.0;
            }
        });
        contentView.getChildren().add(caretPath);

        if (SHOW_HANDLES) {
            contentView.getChildren().addAll(caretHandle, selectionHandle1, selectionHandle2);
        }

        scrollPane.hvalueProperty().addListener((observable, oldValue, newValue) -&gt; {
            getSkinnable().setScrollLeft(newValue.doubleValue() * getScrollLeftMax());
        });

        scrollPane.vvalueProperty().addListener((observable, oldValue, newValue) -&gt; {
            getSkinnable().setScrollTop(newValue.doubleValue() * getScrollTopMax());
        });

        // Initialize the scroll selection timeline
        scrollSelectionTimeline.setCycleCount(Timeline.INDEFINITE);
        List&lt;KeyFrame&gt; scrollSelectionFrames = scrollSelectionTimeline.getKeyFrames();
        scrollSelectionFrames.clear();
        scrollSelectionFrames.add(new KeyFrame(Duration.millis(350), scrollSelectionHandler));

        // Add initial text content
        for (int i = 0, n = USE_MULTIPLE_NODES ? control.getParagraphs().size() : 1; i &lt; n; i++) {
            CharSequence paragraph = (n == 1) ? control.textProperty().getValueSafe() : control.getParagraphs().get(i);
            addParagraphNode(i, paragraph.toString());
        }

        control.selectionProperty().addListener((observable, oldValue, newValue) -&gt; {
            // TODO Why do we need two calls here?
            control.requestLayout();
            contentView.requestLayout();
        });

        control.wrapTextProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            scrollPane.setFitToWidth(newValue);
        });

        control.prefColumnCountProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updatePrefViewportWidth();
        });

        control.prefRowCountProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updatePrefViewportHeight();
        });

        updateFontMetrics();
        fontMetrics.addListener(valueModel -&gt; {
<A NAME="16"></A>            updateFontMetrics();
        });

        <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#16',2,'match46-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>contentView.paddingProperty().addListener(valueModel -&gt; {
            updatePrefViewportWidth();
            updatePrefViewportHeight();
        });

        scrollPane.viewportBoundsProperty().addListener(valueModel -&gt; {</B></FONT>
            if (scrollPane.getViewportBounds() != null) {
                // ScrollPane creates a new Bounds instance for each
                // layout pass, so we need to check if the width/height
                // have really changed to avoid infinite layout requests.
                Bounds newViewportBounds = scrollPane.getViewportBounds();
                if (oldViewportBounds == null ||
                    oldViewportBounds.getWidth() != newViewportBounds.getWidth() ||
                    oldViewportBounds.getHeight() != newViewportBounds.getHeight()) {

                    invalidateMetrics();
                    oldViewportBounds = newViewportBounds;
                    contentView.requestLayout();
                }
            }
        });

        control.scrollTopProperty().addListener((observable, oldValue, newValue) -&gt; {
            double vValue = (newValue.doubleValue() &lt; getScrollTopMax())
                               ? (newValue.doubleValue() / getScrollTopMax()) : 1.0;
            scrollPane.setVvalue(vValue);
        });

        control.scrollLeftProperty().addListener((observable, oldValue, newValue) -&gt; {
            double hValue = (newValue.doubleValue() &lt; getScrollLeftMax())
                               ? (newValue.doubleValue() / getScrollLeftMax()) : 1.0;
            scrollPane.setHvalue(hValue);
        });

        if (USE_MULTIPLE_NODES) {
            control.getParagraphs().addListener((ListChangeListener.Change&lt;? extends CharSequence&gt; change) -&gt; {
                while (change.next()) {
                    int from = change.getFrom();
                    int to = change.getTo();
                    List&lt;? extends CharSequence&gt; removed = change.getRemoved();
                    if (from &lt; to) {

                        if (removed.isEmpty()) {
                            // This is an add
                            for (int i = from, n = to; i &lt; n; i++) {
                                addParagraphNode(i, change.getList().get(i).toString());
                            }
                        } else {
                            // This is an update
                            for (int i = from, n = to; i &lt; n; i++) {
                                Node node = paragraphNodes.getChildren().get(i);
                                Text paragraphNode = (Text) node;
                                paragraphNode.setText(change.getList().get(i).toString());
                            }
                        }
                    } else {
                        // This is a remove
                        paragraphNodes.getChildren().subList(from, from + removed.size()).clear();
                    }
                }
            });
        } else {
            control.textProperty().addListener(observable -&gt; {
                invalidateMetrics();
                ((Text)paragraphNodes.getChildren().get(0)).setText(control.textProperty().getValueSafe());
                contentView.requestLayout();
            });
        }

        usePromptText = new BooleanBinding() {
            { bind(control.textProperty(), control.promptTextProperty()); }
            @Override protected boolean computeValue() {
                String txt = control.getText();
                String promptTxt = control.getPromptText();
                return ((txt == null || txt.isEmpty()) &amp;&amp;
                        promptTxt != null &amp;&amp; !promptTxt.isEmpty());
            }
        };

        if (usePromptText.get()) {
            createPromptNode();
        }

        usePromptText.addListener(observable -&gt; {
            createPromptNode();
            control.requestLayout();
        });

        updateHighlightFill();
        updatePrefViewportWidth();
        updatePrefViewportHeight();
        if (control.isFocused()) setCaretAnimating(true);

        if (SHOW_HANDLES) {
            selectionHandle1.setRotate(180);

            EventHandler&lt;MouseEvent&gt; handlePressHandler = e -&gt; {
                pressX = e.getX();
                pressY = e.getY();
                handlePressed = true;
                e.consume();
            };

            EventHandler&lt;MouseEvent&gt; handleReleaseHandler = event -&gt; {
                handlePressed = false;
            };

            caretHandle.setOnMousePressed(handlePressHandler);
            selectionHandle1.setOnMousePressed(handlePressHandler);
            selectionHandle2.setOnMousePressed(handlePressHandler);

            caretHandle.setOnMouseReleased(handleReleaseHandler);
            selectionHandle1.setOnMouseReleased(handleReleaseHandler);
            selectionHandle2.setOnMouseReleased(handleReleaseHandler);

<A NAME="6"></A>            caretHandle.setOnMouseDragged(e -&gt; {
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                <FONT color="#50ebec"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#6',2,'match46-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + caretHandle.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY - 6);
                HitInfo hit = textNode.hitTest(translateCaretPosition</B></FONT>(p));
                positionCaret(hit, false);
                e.consume();
            });

            selectionHandle1.setOnMouseDragged(e -&gt; {
                TextArea control1 = getSkinnable();
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + selectionHandle1.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY + selectionHandle1.getHeight() + 5);
                HitInfo hit = textNode.hitTest(translateCaretPosition(p));
                if (control1.getAnchor() &lt; control1.getCaretPosition()) {
                    // Swap caret and anchor
                    control1.selectRange(control1.getCaretPosition(), control1.getAnchor());
                }
                int pos = hit.getCharIndex();
                if (pos &gt; 0) {
                    if (pos &gt;= control1.getAnchor()) {
                        pos = control1.getAnchor();
                    }
                }
                positionCaret(hit, true);
                e.consume();
            });

            selectionHandle2.setOnMouseDragged(e -&gt; {
                TextArea control1 = getSkinnable();
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + selectionHandle2.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY - 6);
                HitInfo hit = textNode.hitTest(translateCaretPosition(p));
                if (control1.getAnchor() &gt; control1.getCaretPosition()) {
                    // Swap caret and anchor
                    control1.selectRange(control1.getCaretPosition(), control1.getAnchor());
                }
                int pos = hit.getCharIndex();
                if (pos &gt; 0) {
                    if (pos &lt;= control1.getAnchor() + 1) {
                        pos = Math.min(control1.getAnchor() + 2, control1.getLength());
                    }
                    positionCaret(hit, true);
                }
                e.consume();
            });
        }
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected void invalidateMetrics() {
        computedMinWidth = Double.NEGATIVE_INFINITY;
        computedMinHeight = Double.NEGATIVE_INFINITY;
        computedPrefWidth = Double.NEGATIVE_INFINITY;
        computedPrefHeight = Double.NEGATIVE_INFINITY;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(double contentX, double contentY, double contentWidth, double contentHeight) {
        scrollPane.resizeRelocate(contentX, contentY, contentWidth, contentHeight);
    }

    /** {@inheritDoc} */
    @Override protected void updateHighlightFill() {
        for (Node node : selectionHighlightGroup.getChildren()) {
            Path selectionHighlightPath = (Path)node;
            selectionHighlightPath.setFill(highlightFillProperty().get());
        }
    }

    // Public for behavior
    /**
     * Performs a hit test, mapping point to index in the content.
     *
     * @param x the x coordinate of the point.
     * @param y the y coordinate of the point.
     * @return a {@code HitInfo} object describing the index and forward bias.
     */
    public HitInfo getIndex(double x, double y) {
        // adjust the event to be in the same coordinate space as the
        // text content of the textInputControl
        Text textNode = getTextNode();
        Point2D p = new Point2D(x - textNode.getLayoutX(), y - getTextTranslateY());
        HitInfo hit = textNode.hitTest(translateCaretPosition(p));
        return hit;
    };

    /** {@inheritDoc} */
    @Override public void moveCaret(TextUnit unit, Direction dir, boolean select) {
        switch (unit) {
            case CHARACTER:
                switch (dir) {
                    case LEFT:
                    case RIGHT:
                        nextCharacterVisually(dir == Direction.RIGHT);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case LINE:
                switch (dir) {
                    case UP:
                        previousLine(select);
                        break;
                    case DOWN:
                        nextLine(select);
                        break;
                    case BEGINNING:
                        lineStart(select, select &amp;&amp; isMac());
                        break;
                    case END:
                        lineEnd(select, select &amp;&amp; isMac());
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case PAGE:
                switch (dir) {
                    case UP:
                        previousPage(select);
                        break;
                    case DOWN:
                        nextPage(select);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case PARAGRAPH:
                switch (dir) {
                    case UP:
                        paragraphStart(true, select);
                        break;
                    case DOWN:
                        paragraphEnd(true, select);
                        break;
                    case BEGINNING:
                        paragraphStart(false, select);
                        break;
                    case END:
                        paragraphEnd(false, select);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            default:
                throw new IllegalArgumentException(&quot;&quot;+unit);
        }
    }

    private void nextCharacterVisually(boolean moveRight) {
        if (isRTL()) {
            // Text node is mirrored.
            moveRight = !moveRight;
        }

        Text textNode = getTextNode();
        Bounds caretBounds = caretPath.getLayoutBounds();
        if (caretPath.getElements().size() == 4) {
            // The caret is split
            // TODO: Find a better way to get the primary caret position
            // instead of depending on the internal implementation.
            // See RT-25465.
            caretBounds = new Path(caretPath.getElements().get(0), caretPath.getElements().get(1)).getLayoutBounds();
        }
        double hitX = moveRight ? caretBounds.getMaxX() : caretBounds.getMinX();
        double hitY = (caretBounds.getMinY() + caretBounds.getMaxY()) / 2;
        HitInfo hit = textNode.hitTest(new Point2D(hitX, hitY));
        boolean leading = hit.isLeading();
        Path charShape = new Path(textNode.rangeShape(hit.getCharIndex(), hit.getCharIndex() + 1));
        if ((moveRight &amp;&amp; charShape.getLayoutBounds().getMaxX() &gt; caretBounds.getMaxX()) ||
                (!moveRight &amp;&amp; charShape.getLayoutBounds().getMinX() &lt; caretBounds.getMinX())) {
            leading = !leading;
            positionCaret(hit.getInsertionIndex(), leading, false, false);
        } else {
            // We're at beginning or end of line. Try moving up / down.
            int dot = textArea.getCaretPosition();
            targetCaretX = moveRight ? 0 : Double.MAX_VALUE;
            // TODO: Use Bidi sniffing instead of assuming right means forward here?
            downLines(moveRight ? 1 : -1, false, false);
            targetCaretX = -1;
            if (dot == textArea.getCaretPosition()) {
                if (moveRight) {
                    textArea.forward();
                } else {
                    textArea.backward();
                }
            }
        }
    }

    private void downLines(int nLines, boolean select, boolean extendSelection) {
        Text textNode = getTextNode();
        Bounds caretBounds = caretPath.getLayoutBounds();

        // The middle y coordinate of the the line we want to go to.
        double targetLineMidY = (caretBounds.getMinY() + caretBounds.getMaxY()) / 2 + nLines * lineHeight;
        if (targetLineMidY &lt; 0) {
            targetLineMidY = 0;
        }

        // The target x for the caret. This may have been set during a
        // previous call.
        double x = (targetCaretX &gt;= 0) ? targetCaretX : (caretBounds.getMaxX());

        // Find a text position for the target x,y.
        HitInfo hit = textNode.hitTest(translateCaretPosition(new Point2D(x, targetLineMidY)));
        int pos = hit.getCharIndex();

        // Save the old pos temporarily while testing the new one.
        int oldPos = textNode.getCaretPosition();
        boolean oldBias = textNode.isCaretBias();
        textNode.setCaretBias(hit.isLeading());
        textNode.setCaretPosition(pos);
        tmpCaretPath.getElements().clear();
        tmpCaretPath.getElements().addAll(textNode.getCaretShape());
        tmpCaretPath.setLayoutX(textNode.getLayoutX());
        tmpCaretPath.setLayoutY(textNode.getLayoutY());
        Bounds tmpCaretBounds = tmpCaretPath.getLayoutBounds();
        // The y for the middle of the row we found.
        double foundLineMidY = (tmpCaretBounds.getMinY() + tmpCaretBounds.getMaxY()) / 2;
        textNode.setCaretBias(oldBias);
        textNode.setCaretPosition(oldPos);

        // Test if the found line is in the correct direction and move
        // the caret.
        if (nLines == 0 ||
                (nLines &gt; 0 &amp;&amp; foundLineMidY &gt; caretBounds.getMaxY()) ||
                (nLines &lt; 0 &amp;&amp; foundLineMidY &lt; caretBounds.getMinY())) {

            positionCaret(hit.getInsertionIndex(), hit.isLeading(), select, extendSelection);
            targetCaretX = x;
        }
    }

    private void previousLine(boolean select) {
        downLines(-1, select, false);
    }

    private void nextLine(boolean select) {
        downLines(1, select, false);
    }

    private void previousPage(boolean select) {
        downLines(-(int)(scrollPane.getViewportBounds().getHeight() / lineHeight),
                select, false);
    }

    private void nextPage(boolean select) {
        downLines((int)(scrollPane.getViewportBounds().getHeight() / lineHeight),
                select, false);
    }

    private void lineStart(boolean select, boolean extendSelection) {
        targetCaretX = 0;
        downLines(0, select, extendSelection);
        targetCaretX = -1;
    }

    private void lineEnd(boolean select, boolean extendSelection) {
        targetCaretX = Double.MAX_VALUE;
        downLines(0, select, extendSelection);
        targetCaretX = -1;
    }


    private void paragraphStart(boolean previousIfAtStart, boolean select) {
        TextArea textArea = getSkinnable();
        String text = textArea.textProperty().getValueSafe();
        int pos = textArea.getCaretPosition();

        if (pos &gt; 0) {
            if (previousIfAtStart &amp;&amp; text.codePointAt(pos-1) == 0x0a) {
                // We are at the beginning of a paragraph.
                // Back up to the previous paragraph.
                pos--;
            }
            // Back up to the beginning of this paragraph
            while (pos &gt; 0 &amp;&amp; text.codePointAt(pos-1) != 0x0a) {
                pos--;
            }
            if (select) {
                textArea.selectPositionCaret(pos);
            } else {
                textArea.positionCaret(pos);
                setForwardBias(true);
            }
        }
    }

    private void paragraphEnd(boolean goPastInitialNewline, boolean select) {
        TextArea textArea = getSkinnable();
        String text = textArea.textProperty().getValueSafe();
        int pos = textArea.getCaretPosition();
        int len = text.length();
        boolean wentPastInitialNewline = false;
        boolean goPastTrailingNewline = isWindows();

        if (pos &lt; len) {
            if (goPastInitialNewline &amp;&amp; text.codePointAt(pos) == 0x0a) {
                // We are at the end of a paragraph, start by moving to the
                // next paragraph.
                pos++;
                wentPastInitialNewline = true;
            }
            if (!(goPastTrailingNewline &amp;&amp; wentPastInitialNewline)) {
                // Go to the end of this paragraph
                while (pos &lt; len &amp;&amp; text.codePointAt(pos) != 0x0a) {
                    pos++;
                }
                if (goPastTrailingNewline &amp;&amp; pos &lt; len) {
                    // We are at the end of a paragraph, finish by moving to
                    // the beginning of the next paragraph (Windows behavior).
                    pos++;
                }
            }
            if (select) {
                textArea.selectPositionCaret(pos);
            } else {
                textArea.positionCaret(pos);
            }
        }
    }

    /** {@inheritDoc} */
    @Override protected PathElement[] getUnderlineShape(int start, int end) {
        int pStart = 0;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                return p.underlineShape(start - pStart, end - pStart);
            }
            pStart = pEnd + 1;
        }
        return null;
    }

    /** {@inheritDoc} */
    @Override protected PathElement[] getRangeShape(int start, int end) {
        int pStart = 0;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                return p.rangeShape(start - pStart, end - pStart);
            }
            pStart = pEnd + 1;
        }
        return null;
    }

    /** {@inheritDoc} */
    @Override protected void addHighlight(List&lt;? extends Node&gt; nodes, int start) {
        int pStart = 0;
        Text paragraphNode = null;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                paragraphNode = p;
                break;
            }
            pStart = pEnd + 1;
        }

        if (paragraphNode != null) {
            for (Node node : nodes) {
                node.setLayoutX(paragraphNode.getLayoutX());
                node.setLayoutY(paragraphNode.getLayoutY());
            }
        }
        contentView.getChildren().addAll(nodes);
    }

    /** {@inheritDoc} */
    @Override protected void removeHighlight(List&lt;? extends Node&gt; nodes) {
        contentView.getChildren().removeAll(nodes);
    }

    /** {@inheritDoc} */
    @Override public Point2D getMenuPosition() {
        contentView.layoutChildren();
        Point2D p = super.getMenuPosition();
        if (p != null) {
            p = new Point2D(Math.max(0, p.getX() - contentView.snappedLeftInset() - getSkinnable().getScrollLeft()),
                    Math.max(0, p.getY() - contentView.snappedTopInset() - getSkinnable().getScrollTop()));
        }
        return p;
    }

    // Public for FXVKSkin
    /**
     * Gets the {@code Bounds} of the caret of the skinned {@code TextArea}.
     * @return the {@code Bounds} of the caret shape, relative to the {@code TextArea}.
     */
    public Bounds getCaretBounds() {
        return getSkinnable().sceneToLocal(caretPath.localToScene(caretPath.getBoundsInLocal()));
    }

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case LINE_FOR_OFFSET:
            case LINE_START:
            case LINE_END:
            case BOUNDS_FOR_RANGE:
            case OFFSET_AT_POINT:
                Text text = getTextNode();
                return text.queryAccessibleAttribute(attribute, parameters);
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }

        // TODO Unregister listeners on text editor, paragraph list
        throw new UnsupportedOperationException();
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        Text firstParagraph = (Text) paragraphNodes.getChildren().get(0);
        return Utils.getAscent(getSkinnable().getFont(), firstParagraph.getBoundsType())
                + contentView.snappedTopInset() + textArea.snappedTopInset();
    }

    private char getCharacter(int index) {
        int n = paragraphNodes.getChildren().size();

        int paragraphIndex = 0;
        int offset = index;

        String paragraph = null;
        while (paragraphIndex &lt; n) {
            Text paragraphNode = (Text)paragraphNodes.getChildren().get(paragraphIndex);
            paragraph = paragraphNode.getText();
            int count = paragraph.length() + 1;

            if (offset &lt; count) {
                break;
            }

            offset -= count;
            paragraphIndex++;
        }

        return offset == paragraph.length() ? '\n' : paragraph.charAt(offset);
    }

    /** {@inheritDoc} */
    @Override protected int getInsertionPoint(double x, double y) {
        TextArea textArea = getSkinnable();

        int n = paragraphNodes.getChildren().size();
        int index = -1;

        if (n &gt; 0) {
            if (y &lt; contentView.snappedTopInset()) {
                // Select the character at x in the first row
                Text paragraphNode = (Text)paragraphNodes.getChildren().get(0);
                index = getNextInsertionPoint(paragraphNode, x, -1, VerticalDirection.DOWN);
            } else if (y &gt; contentView.snappedTopInset() + contentView.getHeight()) {
                // Select the character at x in the last row
                int lastParagraphIndex = n - 1;
                Text lastParagraphView = (Text)paragraphNodes.getChildren().get(lastParagraphIndex);

                index = getNextInsertionPoint(lastParagraphView, x, -1, VerticalDirection.UP)
                        + (textArea.getLength() - lastParagraphView.getText().length());
            } else {
                // Select the character at x in the row at y
                int paragraphOffset = 0;
                for (int i = 0; i &lt; n; i++) {
                    Text paragraphNode = (Text)paragraphNodes.getChildren().get(i);

                    Bounds bounds = paragraphNode.getBoundsInLocal();
                    double paragraphViewY = paragraphNode.getLayoutY() + bounds.getMinY();
                    if (y &gt;= paragraphViewY
                            &amp;&amp; y &lt; paragraphViewY + paragraphNode.getBoundsInLocal().getHeight()) {
                        index = getInsertionPoint(paragraphNode,
                                x - paragraphNode.getLayoutX(),
                                y - paragraphNode.getLayoutY()) + paragraphOffset;
                        break;
                    }

                    paragraphOffset += paragraphNode.getText().length() + 1;
                }
            }
        }

        return index;
    }

    // Public for behavior
    /**
     * Moves the caret to the specified position.
     *
     * @param hit the new position and forward bias of the caret.
     * @param select whether to extend selection to the new position.
     */
    public void positionCaret(HitInfo hit, boolean select) {
        positionCaret(hit.getInsertionIndex(), hit.isLeading(), select, false);
    }

    private void positionCaret(int pos, boolean leading, boolean select, boolean extendSelection) {
        boolean isNewLine =
                (pos &gt; 0 &amp;&amp;
                        pos &lt;= getSkinnable().getLength() &amp;&amp;
                        getSkinnable().getText().codePointAt(pos-1) == 0x0a);

        // special handling for a new line
        if (!leading &amp;&amp; isNewLine) {
            leading = true;
            pos -= 1;
        }

        if (select) {
            if (extendSelection) {
                getSkinnable().extendSelection(pos);
            } else {
                getSkinnable().selectPositionCaret(pos);
            }
        } else {
            getSkinnable().positionCaret(pos);
        }

        setForwardBias(leading);
    }

    /** {@inheritDoc} */
    @Override public Rectangle2D getCharacterBounds(int index) {
        TextArea textArea = getSkinnable();

        int paragraphIndex = paragraphNodes.getChildren().size();
        int paragraphOffset = textArea.getLength() + 1;

        Text paragraphNode = null;
        do {
            paragraphNode = (Text)paragraphNodes.getChildren().get(--paragraphIndex);
            paragraphOffset -= paragraphNode.getText().length() + 1;
        } while (index &lt; paragraphOffset);

        int characterIndex = index - paragraphOffset;
        boolean terminator = false;

        if (characterIndex == paragraphNode.getText().length()) {
            characterIndex--;
            terminator = true;
        }

        characterBoundingPath.getElements().clear();
        characterBoundingPath.getElements().addAll(paragraphNode.rangeShape(characterIndex, characterIndex + 1));
        characterBoundingPath.setLayoutX(paragraphNode.getLayoutX());
        characterBoundingPath.setLayoutY(paragraphNode.getLayoutY());

        Bounds bounds = characterBoundingPath.getBoundsInLocal();

        double x = bounds.getMinX() + paragraphNode.getLayoutX() - textArea.getScrollLeft();
        double y = bounds.getMinY() + paragraphNode.getLayoutY() - textArea.getScrollTop();

        // Sometimes the bounds is empty, in which case we must ignore the width/height
        double width = bounds.isEmpty() ? 0 : bounds.getWidth();
        double height = bounds.isEmpty() ? 0 : bounds.getHeight();

        if (terminator) {
            x += width;
            width = 0;
        }

        return new Rectangle2D(x, y, width, height);
    }

    /** {@inheritDoc} */
    @Override protected void scrollCharacterToVisible(final int index) {
        // TODO We queue a callback because when characters are added or
        // removed the bounds are not immediately updated; is this really
        // necessary?

        Platform.runLater(() -&gt; {
            if (getSkinnable().getLength() == 0) {
                return;
            }
            Rectangle2D characterBounds = getCharacterBounds(index);
            scrollBoundsToVisible(characterBounds);
        });
    }



    /**************************************************************************
     *
     * Private implementation
     *
     **************************************************************************/

    TextAreaBehavior getBehavior() {
        return behavior;
    }

    private void createPromptNode() {
        if (promptNode == null &amp;&amp; usePromptText.get()) {
            promptNode = new Text();
            contentView.getChildren().add(0, promptNode);
            promptNode.setManaged(false);
            promptNode.getStyleClass().add(&quot;text&quot;);
            promptNode.visibleProperty().bind(usePromptText);
            promptNode.fontProperty().bind(getSkinnable().fontProperty());
            promptNode.textProperty().bind(getSkinnable().promptTextProperty());
            promptNode.fillProperty().bind(promptTextFillProperty());
        }
    }

    private void addParagraphNode(int i, String string) {
        final TextArea textArea = getSkinnable();
        Text paragraphNode = new Text(string);
        paragraphNode.setTextOrigin(VPos.TOP);
        paragraphNode.setManaged(false);
        paragraphNode.getStyleClass().add(&quot;text&quot;);
        paragraphNode.boundsTypeProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updateFontMetrics();
        });
        paragraphNodes.getChildren().add(i, paragraphNode);

        paragraphNode.fontProperty().bind(textArea.fontProperty());
        paragraphNode.fillProperty().bind(textFillProperty());
        paragraphNode.selectionFillProperty().bind(highlightTextFillProperty());
    }

    private double getScrollTopMax() {
        return Math.max(0, contentView.getHeight() - scrollPane.getViewportBounds().getHeight());
    }

    private double getScrollLeftMax() {
        return Math.max(0, contentView.getWidth() - scrollPane.getViewportBounds().getWidth());
    }

    private int getInsertionPoint(Text paragraphNode, double x, double y) {
        HitInfo hitInfo = paragraphNode.hitTest(new Point2D(x, y));
        return hitInfo.getInsertionIndex();
    }

    private int getNextInsertionPoint(Text paragraphNode, double x, int from,
        VerticalDirection scrollDirection) {
        // TODO
        return 0;
    }

    private void scrollCaretToVisible() {
        TextArea textArea = getSkinnable();
        Bounds bounds = caretPath.getLayoutBounds();
        double x = bounds.getMinX() - textArea.getScrollLeft();
        double y = bounds.getMinY() - textArea.getScrollTop();
        double w = bounds.getWidth();
        double h = bounds.getHeight();

        if (SHOW_HANDLES) {
            if (caretHandle.isVisible()) {
                h += caretHandle.getHeight();
            } else if (selectionHandle1.isVisible() &amp;&amp; selectionHandle2.isVisible()) {
                x -= selectionHandle1.getWidth() / 2;
                y -= selectionHandle1.getHeight();
                w += selectionHandle1.getWidth() / 2 + selectionHandle2.getWidth() / 2;
                h += selectionHandle1.getHeight() + selectionHandle2.getHeight();
            }
        }

        if (w &gt; 0 &amp;&amp; h &gt; 0) {
            scrollBoundsToVisible(new Rectangle2D(x, y, w, h));
        }
    }

    private void scrollBoundsToVisible(Rectangle2D bounds) {
        TextArea textArea = getSkinnable();
        Bounds viewportBounds = scrollPane.getViewportBounds();

        double viewportWidth = viewportBounds.getWidth();
        double viewportHeight = viewportBounds.getHeight();
        double scrollTop = textArea.getScrollTop();
        double scrollLeft = textArea.getScrollLeft();
        double slop = 6.0;

        if (bounds.getMinY() &lt; 0) {
            double y = scrollTop + bounds.getMinY();
            if (y &lt;= contentView.snappedTopInset()) {
                y = 0;
            }
            textArea.setScrollTop(y);
        } else if (contentView.snappedTopInset() + bounds.getMaxY() &gt; viewportHeight) {
            double y = scrollTop + contentView.snappedTopInset() + bounds.getMaxY() - viewportHeight;
            if (y &gt;= getScrollTopMax() - contentView.snappedBottomInset()) {
                y = getScrollTopMax();
            }
            textArea.setScrollTop(y);
        }


        if (bounds.getMinX() &lt; 0) {
            double x = scrollLeft + bounds.getMinX() - slop;
            if (x &lt;= contentView.snappedLeftInset() + slop) {
                x = 0;
            }
            textArea.setScrollLeft(x);
        } else if (contentView.snappedLeftInset() + bounds.getMaxX() &gt; viewportWidth) {
            double x = scrollLeft + contentView.snappedLeftInset() + bounds.getMaxX() - viewportWidth + slop;
            if (x &gt;= getScrollLeftMax() - contentView.snappedRightInset() - slop) {
                x = getScrollLeftMax();
            }
            textArea.setScrollLeft(x);
        }
    }

    private void updatePrefViewportWidth() {
        int columnCount = getSkinnable().getPrefColumnCount();
        scrollPane.setPrefViewportWidth(columnCount * characterWidth + contentView.snappedLeftInset() + contentView.snappedRightInset());
        scrollPane.setMinViewportWidth(characterWidth + contentView.snappedLeftInset() + contentView.snappedRightInset());
    }

    private void updatePrefViewportHeight() {
        int rowCount = getSkinnable().getPrefRowCount();
        scrollPane.setPrefViewportHeight(rowCount * lineHeight + contentView.snappedTopInset() + contentView.snappedBottomInset());
        scrollPane.setMinViewportHeight(lineHeight + contentView.snappedTopInset() + contentView.snappedBottomInset());
    }

    private void updateFontMetrics() {
        Text firstParagraph = (Text)paragraphNodes.getChildren().get(0);
        lineHeight = Utils.getLineHeight(getSkinnable().getFont(), firstParagraph.getBoundsType());
        characterWidth = fontMetrics.get().getCharWidth('W');
    }

    private double getTextTranslateX() {
        return contentView.snappedLeftInset();
    }

    private double getTextTranslateY() {
        return contentView.snappedTopInset();
    }

    private double getTextLeft() {
        return 0;
    }

    private Point2D translateCaretPosition(Point2D p) {
        return p;
    }

    private Text getTextNode() {
        if (USE_MULTIPLE_NODES) {
            throw new IllegalArgumentException(&quot;Multiple node traversal is not yet implemented.&quot;);
        }
        return (Text)paragraphNodes.getChildren().get(0);
    }

    private void updateTextNodeCaretPos(int pos) {
        Text textNode = getTextNode();
        if (isForwardBias()) {
            textNode.setCaretPosition(pos);
        } else {
            textNode.setCaretPosition(pos - 1);
        }
        textNode.caretBiasProperty().set(isForwardBias());
    }



    /**************************************************************************
     *
     * Support classes
     *
     **************************************************************************/

    private class ContentView extends Region {
        {
            getStyleClass().add(&quot;content&quot;);

            addEventHandler(MouseEvent.MOUSE_PRESSED, event -&gt; {
                behavior.mousePressed(event);
                event.consume();
            });

            addEventHandler(MouseEvent.MOUSE_RELEASED, event -&gt; {
                behavior.mouseReleased(event);
                event.consume();
            });

            addEventHandler(MouseEvent.MOUSE_DRAGGED, event -&gt; {
                behavior.mouseDragged(event);
                event.consume();
            });
        }

        @Override protected ObservableList&lt;Node&gt; getChildren() {
            return super.getChildren();
        }

        @Override public Orientation getContentBias() {
            return Orientation.HORIZONTAL;
        }

        @Override protected double computePrefWidth(double height) {
            if (computedPrefWidth &lt; 0) {
                double prefWidth = 0;

                for (Node node : paragraphNodes.getChildren()) {
                    Text paragraphNode = (Text)node;
                    prefWidth = Math.max(prefWidth,
                            Utils.computeTextWidth(paragraphNode.getFont(),
                                    paragraphNode.getText(), 0));
                }

                prefWidth += snappedLeftInset() + snappedRightInset();

                Bounds viewPortBounds = scrollPane.getViewportBounds();
                computedPrefWidth = Math.max(prefWidth, (viewPortBounds != null) ? viewPortBounds.getWidth() : 0);
            }
            return computedPrefWidth;
        }

        @Override protected double computePrefHeight(double width) {
            if (width != widthForComputedPrefHeight) {
                invalidateMetrics();
                widthForComputedPrefHeight = width;
            }

            if (computedPrefHeight &lt; 0) {
                double wrappingWidth;
                if (width == -1) {
                    wrappingWidth = 0;
                } else {
                    wrappingWidth = Math.max(width - (snappedLeftInset() + snappedRightInset()), 0);
                }

                double prefHeight = 0;

                for (Node node : paragraphNodes.getChildren()) {
                    Text paragraphNode = (Text)node;
                    prefHeight += Utils.computeTextHeight(
                            paragraphNode.getFont(),
                            paragraphNode.getText(),
                            wrappingWidth,
                            paragraphNode.getBoundsType());
                }

                prefHeight += snappedTopInset() + snappedBottomInset();

                Bounds viewPortBounds = scrollPane.getViewportBounds();
                computedPrefHeight = Math.max(prefHeight, (viewPortBounds != null) ? viewPortBounds.getHeight() : 0);
            }
            return computedPrefHeight;
        }

        @Override protected double computeMinWidth(double height) {
            if (computedMinWidth &lt; 0) {
                double hInsets = snappedLeftInset() + snappedRightInset();
                computedMinWidth = Math.min(characterWidth + hInsets, computePrefWidth(height));
            }
            return computedMinWidth;
        }

        @Override protected double computeMinHeight(double width) {
            if (computedMinHeight &lt; 0) {
                double vInsets = snappedTopInset() + snappedBottomInset();
                computedMinHeight = Math.min(lineHeight + vInsets, computePrefHeight(width));
            }
            return computedMinHeight;
        }

        @Override public void layoutChildren() {
            TextArea textArea = getSkinnable();
            double width = getWidth();

            // Lay out paragraphs
            final double topPadding = snappedTopInset();
            final double leftPadding = snappedLeftInset();

            double wrappingWidth = Math.max(width - (leftPadding + snappedRightInset()), 0);

            double y = topPadding;

            final List&lt;Node&gt; paragraphNodesChildren = paragraphNodes.getChildren();

            for (int i = 0; i &lt; paragraphNodesChildren.size(); i++) {
                Node node = paragraphNodesChildren.get(i);
                Text paragraphNode = (Text)node;
                paragraphNode.setWrappingWidth(wrappingWidth);

                Bounds bounds = paragraphNode.getBoundsInLocal();
                paragraphNode.setLayoutX(leftPadding);
                paragraphNode.setLayoutY(y);

                y += bounds.getHeight();
            }

            if (promptNode != null) {
                promptNode.setLayoutX(leftPadding);
                promptNode.setLayoutY(topPadding + promptNode.getBaselineOffset());
                promptNode.setWrappingWidth(wrappingWidth);
            }

            // Update the selection
            IndexRange selection = textArea.getSelection();
            Bounds oldCaretBounds = caretPath.getBoundsInParent();

            selectionHighlightGroup.getChildren().clear();

            int caretPos = textArea.getCaretPosition();
            int anchorPos = textArea.getAnchor();

            if (SHOW_HANDLES) {
                // Install and resize the handles for caret and anchor.
                if (selection.getLength() &gt; 0) {
                    selectionHandle1.resize(selectionHandle1.prefWidth(-1),
                            selectionHandle1.prefHeight(-1));
                    selectionHandle2.resize(selectionHandle2.prefWidth(-1),
                            selectionHandle2.prefHeight(-1));
                } else {
                    caretHandle.resize(caretHandle.prefWidth(-1),
                            caretHandle.prefHeight(-1));
                }

                // Position the handle for the anchor. This could be handle1 or handle2.
                // Do this before positioning the actual caret.
                if (selection.getLength() &gt; 0) {
                    int paragraphIndex = paragraphNodesChildren.size();
                    int paragraphOffset = textArea.getLength() + 1;
                    Text paragraphNode = null;
                    do {
                        paragraphNode = (Text)paragraphNodesChildren.get(--paragraphIndex);
                        paragraphOffset -= paragraphNode.getText().length() + 1;
                    } while (anchorPos &lt; paragraphOffset);

                    updateTextNodeCaretPos(anchorPos - paragraphOffset);
                    caretPath.getElements().clear();
                    caretPath.getElements().addAll(paragraphNode.getCaretShape());
                    caretPath.setLayoutX(paragraphNode.getLayoutX());
                    caretPath.setLayoutY(paragraphNode.getLayoutY());

                    Bounds b = caretPath.getBoundsInParent();
                    if (caretPos &lt; anchorPos) {
                        selectionHandle2.setLayoutX(b.getMinX() - selectionHandle2.getWidth() / 2);
                        selectionHandle2.setLayoutY(b.getMaxY() - 1);
                    } else {
                        selectionHandle1.setLayoutX(b.getMinX() - selectionHandle1.getWidth() / 2);
                        selectionHandle1.setLayoutY(b.getMinY() - selectionHandle1.getHeight() + 1);
                    }
                }
            }

            {
                // Position caret
                int paragraphIndex = paragraphNodesChildren.size();
                int paragraphOffset = textArea.getLength() + 1;

                Text paragraphNode = null;
                do {
                    paragraphNode = (Text)paragraphNodesChildren.get(--paragraphIndex);
                    paragraphOffset -= paragraphNode.getText().length() + 1;
                } while (caretPos &lt; paragraphOffset);

                updateTextNodeCaretPos(caretPos - paragraphOffset);

                caretPath.getElements().clear();
                caretPath.getElements().addAll(paragraphNode.getCaretShape());

                caretPath.setLayoutX(paragraphNode.getLayoutX());

                // TODO: Remove this temporary workaround for RT-27533
                paragraphNode.setLayoutX(2 * paragraphNode.getLayoutX() - paragraphNode.getBoundsInParent().getMinX());

                caretPath.setLayoutY(paragraphNode.getLayoutY());
                if (oldCaretBounds == null || !oldCaretBounds.equals(caretPath.getBoundsInParent())) {
                    scrollCaretToVisible();
                }
            }

            // Update selection fg and bg
            int start = selection.getStart();
            int end = selection.getEnd();
            for (int i = 0, max = paragraphNodesChildren.size(); i &lt; max; i++) {
                Node paragraphNode = paragraphNodesChildren.get(i);
                Text textNode = (Text)paragraphNode;
                int paragraphLength = textNode.getText().length() + 1;
                if (end &gt; start &amp;&amp; start &lt; paragraphLength) {
                    textNode.setSelectionStart(start);
                    textNode.setSelectionEnd(Math.min(end, paragraphLength));

                    Path selectionHighlightPath = new Path();
                    selectionHighlightPath.setManaged(false);
                    selectionHighlightPath.setStroke(null);
                    PathElement[] selectionShape = textNode.getSelectionShape();
                    if (selectionShape != null) {
                        selectionHighlightPath.getElements().addAll(selectionShape);
                    }
                    selectionHighlightGroup.getChildren().add(selectionHighlightPath);
                    selectionHighlightGroup.setVisible(true);
                    selectionHighlightPath.setLayoutX(textNode.getLayoutX());
                    selectionHighlightPath.setLayoutY(textNode.getLayoutY());
                    updateHighlightFill();
                } else {
                    textNode.setSelectionStart(-1);
                    textNode.setSelectionEnd(-1);
                    selectionHighlightGroup.setVisible(false);
                }
                start = Math.max(0, start - paragraphLength);
                end   = Math.max(0, end   - paragraphLength);
            }

            if (SHOW_HANDLES) {
                // Position handle for the caret. This could be handle1 or handle2 when
                // a selection is active.
                Bounds b = caretPath.getBoundsInParent();
                if (selection.getLength() &gt; 0) {
                    if (caretPos &lt; anchorPos) {
                        selectionHandle1.setLayoutX(b.getMinX() - selectionHandle1.getWidth() / 2);
                        selectionHandle1.setLayoutY(b.getMinY() - selectionHandle1.getHeight() + 1);
                    } else {
                        selectionHandle2.setLayoutX(b.getMinX() - selectionHandle2.getWidth() / 2);
                        selectionHandle2.setLayoutY(b.getMaxY() - 1);
                    }
                } else {
                    caretHandle.setLayoutX(b.getMinX() - caretHandle.getWidth() / 2 + 1);
                    caretHandle.setLayoutY(b.getMaxY());
                }
            }

            if (scrollPane.getPrefViewportWidth() == 0
                    || scrollPane.getPrefViewportHeight() == 0) {
                updatePrefViewportWidth();
                updatePrefViewportHeight();
                if (getParent() != null &amp;&amp; scrollPane.getPrefViewportWidth() &gt; 0
                        || scrollPane.getPrefViewportHeight() &gt; 0) {
                    // Force layout of viewRect in ScrollPaneSkin
                    getParent().requestLayout();
                }
            }

            // RT-36454: Fit to width/height only if smaller than viewport.
            // That is, grow to fit but don't shrink to fit.
            Bounds viewportBounds = scrollPane.getViewportBounds();
            boolean wasFitToWidth = scrollPane.isFitToWidth();
            boolean wasFitToHeight = scrollPane.isFitToHeight();
            boolean setFitToWidth = textArea.isWrapText() || computePrefWidth(-1) &lt;= viewportBounds.getWidth();
            boolean setFitToHeight = computePrefHeight(width) &lt;= viewportBounds.getHeight();
            if (wasFitToWidth != setFitToWidth || wasFitToHeight != setFitToHeight) {
                Platform.runLater(() -&gt; {
                    scrollPane.setFitToWidth(setFitToWidth);
                    scrollPane.setFitToHeight(setFitToHeight);
                });
                getParent().requestLayout();
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.fxml/com/sun/javafx/fxml/ParseTraceElement.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="24"></A> * questions.
 */

<FONT color="#ada96e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#24',2,'match46-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.javafx.fxml;

import java.net.URL;

/*
 * An element in a parse trace, as returned by
 * {@link javafx.fxml.FXMLLoader#getParseTrace()}.
 *
 * @since JavaFX 2.1
 */
public class ParseTraceElement {
    private URL location;
    private int lineNumber;

    public ParseTraceElement(URL location, int lineNumber) {
        this.location = location;
        t</B></FONT>his.lineNumber = lineNumber;
    }

    public URL getLocation() {
        return location;
    }

    public int getLineNumber() {
        return lineNumber;
    }

    @Override
    public String toString() {
        return ((location == null) ? &quot;?&quot; : location.getPath()) + &quot;: &quot; + lineNumber;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/gtk/GtkPixels.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
<A NAME="48"></A> * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
<FONT color="#c57726"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#48',2,'match46-top.html#48',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.glass.ui.gtk;

import com.sun.glass.ui.Pixels;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;

final class GtkPixels extends Pixels {

    public GtkPixels(int width, int height, ByteBuffer data) {
        super</B></FONT>(width, height, data);
    }

    public GtkPixels(int width, int height, IntBuffer data) {
        super(width, height, data);
    }

    public GtkPixels(int width, int height, IntBuffer data, float scalex, float scaley) {
        super(width, height, data, scalex, scaley);
    }

    @Override
    protected void _fillDirectByteBuffer(ByteBuffer bb) {
        // Taken from MacPixels
        if (this.bytes != null) {
            this.bytes.rewind();
            if (this.bytes.isDirect()) {
                _copyPixels(bb, this.bytes, getWidth()*getHeight());
            } else {
                bb.put(this.bytes);
            }
            this.bytes.rewind();
        } else {
            this.ints.rewind();
            if (this.ints.isDirect()) {
                _copyPixels(bb, this.ints, getWidth()*getHeight());
            } else {
                for (int i=0; i&lt;this.ints.capacity(); i++) {
                    int data = this.ints.get();
                    bb.put((byte)((data)&amp;0xff));
                    bb.put((byte)((data&gt;&gt;8)&amp;0xff));
                    bb.put((byte)((data&gt;&gt;16)&amp;0xff));
                    bb.put((byte)((data&gt;&gt;24)&amp;0xff));
                }
            }
            this.ints.rewind();
        }
    }

    protected native void _copyPixels(Buffer dst, Buffer src, int size);

    @Override
    protected native void _attachInt(long ptr, int w, int h, IntBuffer ints, int[] array, int offset);

    @Override
    protected native void _attachByte(long ptr, int w, int h, ByteBuffer bytes, byte[] array, int offset);

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/MonocleWindowManager.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.glass.ui.monocle;

import com.sun.glass.events.WindowEvent;
import com.sun.glass.ui.Screen;
import com.sun.javafx.tk.Toolkit;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javafx.application.Platform;

final class MonocleWindowManager {

    private static MonocleWindowManager instance = new MonocleWindowManager();

    /** The window stack. Windows are in Z-order, from back to front. */
    private MonocleWindow[] windows = new MonocleWindow[0];
    private int nextID = 1;

    private MonocleWindow focusedWindow = null;

    private MonocleWindowManager() {
        //singleton
    }

    static MonocleWindowManager getInstance() {
        return instance;
    }

    private int getWindowIndex(MonocleWindow window) {
        for (int i = 0; i &lt; windows.length; i++) {
            // Any two MonocleWindow objects represent different windows, so
            // equality can be determined by reference comparison.
            if (windows[i] == window) {
                return i;
            }
        }
        return -1;
    }
    void toBack(MonocleWindow window) {
        int index = getWindowIndex(window);
        if (index != 0 &amp;&amp; index != -1) {
            System.arraycopy(windows, 0, windows, 1, index);
            windows[0] = window;
        }
    }

    void toFront(MonocleWindow window) {
        int index = getWindowIndex(window);
        if (index != windows.length - 1 &amp;&amp; index != -1) {
            System.arraycopy(windows, index + 1, windows, index,
                             windows.length - index - 1);
            windows[windows.length - 1] = window;
        }
    }

    int addWindow(MonocleWindow window) {
        int index = getWindowIndex(window);
        if (index == -1) {
            windows = Arrays.copyOf(windows, windows.length + 1);
            windows[windows.length - 1] = window;
        }
        return nextID++;

    }

    boolean closeWindow(MonocleWindow window) {
        int index = getWindowIndex(window);
        if (index != -1) {
            System.arraycopy(windows, index + 1, windows, index,
                             windows.length - index - 1);
            windows = Arrays.copyOf(windows, windows.length - 1);
        }
        List&lt;MonocleWindow&gt; windowsToNotify = new ArrayList&lt;MonocleWindow&gt;();
        for (MonocleWindow otherWindow : windows) {
            if (otherWindow.getOwner() == window) {
                windowsToNotify.add(otherWindow);
            }
        }
        for (int i = 0; i &lt; windowsToNotify.size(); i++) {
            windowsToNotify.get(i).notifyClose();
        }
        window.notifyDestroy();
        return true;

    }

    boolean minimizeWindow(MonocleWindow window) {
        return true;
    }

    boolean maximizeWindow(MonocleWindow window) {
        return true;
    }

    boolean requestFocus(MonocleWindow window) {
        int index = getWindowIndex(window);
        if (index != -1) {
            focusedWindow = window;
            window.notifyFocus(WindowEvent.FOCUS_GAINED);
            return true;
        } else {
            return false;
        }
    }

    boolean grabFocus(MonocleWindow window) {
        return true;
    }

    void ungrabFocus(MonocleWindow window) {

    }

    MonocleWindow getWindowForLocation(int x, int y) {
        for (int i = windows.length - 1; i &gt;=0 ; i--) {
            MonocleWindow w = windows[i];
            if (x &gt;= w.getX() &amp;&amp; y &gt;= w.getY()
                   &amp;&amp; x &lt; w.getX() + w.getWidth()
                   &amp;&amp; y &lt; w.getY() + w.getHeight()
                   &amp;&amp; w.isEnabled()) {
                return w;
            }
        }
        return null;
    }

    void notifyFocusDisabled(MonocleWindow window) {
<A NAME="43"></A>        if (window != null) {
            window._notifyFocusDisabled();
        }
    <FONT color="#c22817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#43',2,'match46-top.html#43',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    MonocleWindow getFocusedWindow() {
        return focusedWindow;
    }

    void repaintAll() {
        for (int i = 0; i &lt; windows.length; i++) {
            MonocleView view = (MonocleView) windows[i].getView</B></FONT>();
            if (view != null) {
                view.notifyRepaint();
            }
        }
    }

    static void repaintFromNative () {
        Platform.runLater(new Runnable () {

            @Override
            public void run() {
                Screen.notifySettingsChanged();
                instance.getFocusedWindow().setFullScreen(true);
                instance.repaintAll();
                Toolkit.getToolkit().requestNextPulse();
            }
        });
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/SysFS.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.glass.ui.monocle;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.util.BitSet;
import java.util.HashMap;
import java.util.Map;

class SysFS {

    static final String CURSOR_BLINK =
            &quot;/sys/devices/virtual/graphics/fbcon/cursor_blink&quot;;

    /** Read input device capability data from sysfs */
    static Map&lt;String, BitSet&gt; readCapabilities(File sysPath) {
        Map&lt;String, BitSet&gt; capsMap = new HashMap&lt;String, BitSet&gt;();
        File[] capsFiles = new File(sysPath, &quot;device/capabilities&quot;).listFiles();
        if (capsFiles == null) {
            return capsMap;
        }
        for (int i = 0; i &lt; capsFiles.length; i++) {
            try {
                BufferedReader r = new BufferedReader(new FileReader(capsFiles[i]));
                String s = r.readLine();
                r.close();
                if (s == null) {
                    continue;
                }
                String[] elements = s.split(&quot; &quot;);
                if (elements == null) {
                    continue;
                }
                byte[] b = new byte[elements.length * (LinuxArch.is64Bit() ? 8 : 4)];
                ByteBuffer bb = ByteBuffer.wrap(b);
                bb.order(ByteOrder.LITTLE_ENDIAN);
                for (int j = elements.length - 1; j &gt;= 0; j--) {
                    if (LinuxArch.is64Bit()) {
                        bb.putLong(Long.parseUnsignedLong(elements[j], 16));
                    } else {
                        bb.putInt(Integer.parseUnsignedInt(elements[j], 16));
                    }
                }
                capsMap.put(capsFiles[i].getName(), BitSet.valueOf(b));
<A NAME="9"></A>            } catch (IOException | RuntimeException e) {
                e.printStackTrace();
            }
        <FONT color="#f88017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#9',2,'match46-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
        return capsMap;
    }

    static Map&lt;String, String&gt; readUEvent(File sysPath) {
        Map&lt;String, String&gt; uevent = new HashMap();
        File f = new</B></FONT> File(sysPath, &quot;device/uevent&quot;);
        try {
            BufferedReader r = new BufferedReader(new FileReader(f));
            for (String line; (line = r.readLine()) != null;) {
                int i = line.indexOf(&quot;=&quot;);
                if (i &gt;= 0) {
                    uevent.put(line.substring(0, i), line.substring(i + 1));
                }
            }
        } catch (IOException e) {
            // return an empty map
        }
        return uevent;
    }

    /** Fires udev notification events for devices of the given type */
    static void triggerUdevNotification(String sysClass) {
        File[] devices = new File(&quot;/sys/class/&quot; + sysClass).listFiles();
        byte[] action = &quot;change&quot;.getBytes();
        for (File device: devices) {
            File uevent = new File(device, &quot;uevent&quot;);
            if (uevent.exists()) {
                try {
                    write(uevent.getAbsolutePath(), action);
                } catch (IOException e) {
                    System.err.println(&quot;Udev: Failed to write to &quot; + uevent);
                    System.err.println(&quot;      Check that you have permission to access input devices&quot;);
                    if (!e.getMessage().contains(&quot;Permission denied&quot;)) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    static void write(String location, byte[] value) throws IOException {
        FileOutputStream out = new FileOutputStream(location);
        try {
            out.write(value);
        } finally {
            out.close();
        }
    }

    static void write(String location, String value) throws IOException {
        write(location, value.getBytes());
    }

    /** Read a comma-separated list of integer values from a file */
    static int[] readInts(String location, int expectedLength) throws IOException {
        BufferedReader r = new BufferedReader(new FileReader(location));
        String s = r.readLine();
        r.close();
        if (s != null &amp;&amp; s.length() &gt; 0) {
            String[] elements = s.split(&quot;,&quot;);
            try {
                if (expectedLength == 0 || elements.length == expectedLength) {
                    int[] xs = new int[elements.length];
                    for (int i = 0; i &lt; xs.length; i++) {
                        xs[i] = Integer.parseInt(elements[i]);
                    }
                    return xs;
                }
            } catch (NumberFormatException e) {
                // fall through to throw an IOException
            }
        }
        if (expectedLength != 0) {
            throw new IOException(&quot;Expected to find &quot; + expectedLength
                    + &quot; integers in &quot; + location + &quot; but found '&quot;
                    + s + &quot;'&quot;);
        } else {
            return new int[0];
        }
    }

    /**
     * Read a single integer value from a file
     */
    static int readInt(String location) throws IOException {
        BufferedReader r = new BufferedReader(new FileReader(location));
        String s = r.readLine();
        r.close();
        try {
            if (s != null &amp;&amp; s.length() &gt; 0) {
                return Integer.parseInt(s);
            } else {
                throw new IOException(location + &quot; does not contain an integer&quot;);
            }
        } catch (NumberFormatException e) {
            throw new IOException(
                    location + &quot; does not contain an integer ('&quot; + s + &quot;'&quot;);
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/win/WinMenuItemDelegate.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui.win;

import com.sun.glass.events.KeyEvent;
import com.sun.glass.ui.MenuItem;
import com.sun.glass.ui.MenuItem.Callback;
import com.sun.glass.ui.Pixels;
import com.sun.glass.ui.delegate.MenuItemDelegate;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

final class WinMenuItemDelegate implements MenuItemDelegate {
    final private MenuItem owner;

    private WinMenuImpl parent = null;

    private int cmdID = -1;

    public WinMenuItemDelegate(MenuItem item) {
        owner = item;
    }

    public MenuItem getOwner() {
        return owner;
    }

    @Override public boolean createMenuItem(String title, Callback callback,
            int shortcutKey, int shortcutModifiers, Pixels pixels,
            boolean enabled, boolean checked) {
        // nothing to to
        return true;
    }
<A NAME="28"></A>
    // all methods report success status (true - success, false - failure)

    <FONT color="#717d7d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#28',2,'match46-top.html#28',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Override public boolean setTitle(String title) {
        if (parent != null) {
            title = getTitle(title, getOwner().getShortcutKey(),
                    getOwner().getShortcutModifiers</B></FONT>());
            return parent.setItemTitle(this, title);
        }
        return true;
    }

    @Override public boolean setCallback(Callback callback) {
        // nothing to do
        return true;
    }

    @Override public boolean setShortcut(int shortcutKey, int shortcutModifiers) {
        if (parent != null) {
            String title = getTitle(getOwner().getTitle(),
                    shortcutKey, shortcutModifiers);
            return parent.setItemTitle(this, title);
        }
        return true;
    }

    @Override public boolean setPixels(Pixels pixels) {
        // TODO: implement images in menuItem
        return false;
    }

    @Override public boolean setEnabled(boolean enabled) {
        if (parent != null) {
            return parent.enableItem(this, enabled);
        }
        return true;
    }

    @Override public boolean setChecked(boolean checked) {
        if (parent != null) {
            return parent.checkItem(this, checked);
        }
        return true;
    }


    /**
     * Obtains title for the specified title &amp; shortcut
     */
    private String getTitle(String title, int key, int modifiers) {
        if (key == KeyEvent.VK_UNDEFINED) {
            return title;
        }
        return title;
    }

    WinMenuImpl getParent() {
        return parent;
    }

    void setParent(WinMenuImpl newParent) {
        // we always switch parent through null (i.e. oldParent =&gt; null =&gt; newParent)
        if (parent != null) {
            CommandIDManager.freeID(cmdID);
            cmdID = -1;
        }
        if (newParent != null) {
            cmdID = CommandIDManager.getID(this);
        }
        parent = newParent;
    }

    int getCmdID() {
        return cmdID;
    }


    static class CommandIDManager {
        final private static int FIRST_ID = 1;
        final private static int LAST_ID = 0xFFFF;
        private static List&lt;Integer&gt; freeList = new ArrayList&lt;Integer&gt;();

        final private static Map&lt;Integer, WinMenuItemDelegate&gt; map =
                new HashMap&lt;Integer, WinMenuItemDelegate&gt;();
        private static int nextID = FIRST_ID;

        public static synchronized int getID(WinMenuItemDelegate menu) {
            Integer id;
            if (freeList.isEmpty()) {
                if (nextID &gt; LAST_ID) {
                    // TODO: handle
                    nextID = FIRST_ID;
                }
                id = nextID;
                nextID++;
            } else {
                // get &amp; remove last item in the list (it's faster for ArrayList)
                id = freeList.remove(freeList.size() - 1);
            }
            map.put(id, menu);
            return id;
        }

        public static synchronized void freeID(int cmdID) {
            Integer id = Integer.valueOf(cmdID);
            if (map.remove(id) != null) {
                freeList.add(id);
            }
        }

        public static WinMenuItemDelegate getHandler(int cmdID) {
            return map.get(Integer.valueOf(cmdID));
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/font/PrismFontFile.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.font;


import java.lang.ref.WeakReference;
import java.io.File;
import java.io.FileNotFoundException;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.font.FontFileReader.Buffer;
import static com.sun.javafx.font.PrismMetrics.*;

public abstract class PrismFontFile implements FontResource, FontConstants {

    private int fontInstallationType = -1; // unknown, 0=embedded, 1=system

    // TrueType fonts can have multiple names, most notably split up by
    // platform and locale. Whilst fonts that have different names for
    // different platforms are arguable buggy, those with localised names
    // are not. This can cause problems. Suppose that a font has English,
    // French and German names, and the platform enumerates the name that
    // is most appropriate for the user locale. Then suppose a French
    // developer uses the French name, but for his German user this font
    // is not located by the platform because it reports the German name
    // for that font. At runtime we no longer have any connection to the
    // locale of the developer so we can't look for the name for that
    // locale, even if the platform have us a performant option for that.
    //
    // The English name which some might think is supposed
    // to be the interoperable name is not treated at all specially in
    // the font format and doesn't even come up for either the user or
    // the developer, and in fact doesn't even have to be present.
    // Having said that we'll probably have the best luck for most users
    // and fonts by assuming the English name if the locale name doesn't
    // work. But either way, without platform API support for this
    // then its really expensive as all font files need to be opened.
    //
    String familyName;           /* Family font name (English) */
    String fullName;             /* Full font name (English)   */
    String psName;               /* PostScript font name       */
    String localeFamilyName;
    String localeFullName;
    String styleName;
    String localeStyleName;
    String filename;
    int filesize;
    FontFileReader filereader;
    int numGlyphs = -1;
    short indexToLocFormat;
    int fontIndex; // into a TTC.
    boolean isCFF;
    boolean isEmbedded = false;
    boolean isCopy = false;
    boolean isTracked = false;
    boolean isDecoded = false;
    boolean isRegistered = true;

    /* The glyph image data is stored only in a texture, and we
     * manage how much of that is kept around. We clearly want
     * to keep a reference to the strike that created that data.
     */
    Map&lt;FontStrikeDesc, WeakReference&lt;PrismFontStrike&gt;&gt; strikeMap =
        new ConcurrentHashMap&lt;FontStrikeDesc, WeakReference&lt;PrismFontStrike&gt;&gt;();

    protected PrismFontFile(String name, String filename, int fIndex,
                          boolean register, boolean embedded,
                          boolean copy, boolean tracked) throws Exception {
        this.filename = filename;
        this.isRegistered = register;
        this.isEmbedded = embedded;
        this.isCopy = copy;
        this.isTracked = tracked;
        init(name, fIndex);
    }

    WeakReference&lt;PrismFontFile&gt; createFileDisposer(PrismFontFactory factory,
                                                    FileRefCounter rc) {
        FileDisposer disposer = new FileDisposer(filename, isTracked, rc);
        WeakReference&lt;PrismFontFile&gt; ref = Disposer.addRecord(this, disposer);
        disposer.setFactory(factory, ref);
        return ref;
    }

    void setIsDecoded(boolean decoded) {
        isDecoded = decoded;
    }

    /* This is called only for fonts where a temp file was created
     */
    protected synchronized void disposeOnShutdown() {
        if (isCopy || isDecoded) {
            AccessController.doPrivileged(
                    (PrivilegedAction&lt;Void&gt;) () -&gt; {
                        try {
                            /* Although there is likely no harm in calling
                             * delete on a file &gt; once, we want to refrain
                             * from deleting it until the shutdown hook
                             * code in subclasses has had an opportunity
                             * to clean up native accesses on the resource.
                             */
                            if (decFileRefCount() &gt; 0) {
                                return null;
                            }
                            boolean delOK = (new File(filename)).delete();
                            if (!delOK &amp;&amp; PrismFontFactory.debugFonts) {
                                 System.err.println(&quot;Temp file not deleted : &quot;
                                                    + filename);
                            }
                            /* Embedded fonts (copy) can also be decoded.
                             * Set both flags to false to avoid double deletes.
                             */
                            isCopy = isDecoded = false;
                        } catch (Exception e) {
                        }
                        return null;
                    }
            );
            if (PrismFontFactory.debugFonts) {
                System.err.println(&quot;Temp file deleted: &quot; + filename);
            }
        }
    }

    public int getDefaultAAMode() {
        return AA_GREYSCALE;
    }

    public boolean isInstalledFont() {
        if (fontInstallationType == -1) {
            PrismFontFactory factory = PrismFontFactory.getFontFactory();
            fontInstallationType = factory.isInstalledFont(filename) ? 1 : 0;
        }
        return fontInstallationType &gt; 0;
    }


    /* A TTC file resource is shared, so reference count and delete
     * only when no longer using the file from any PrismFontFile instance
     */
   static class FileRefCounter {
       private int refCnt = 1; // start with 1.

       synchronized int getRefCount() {
           return refCnt;
       }

       synchronized int increment() {
           return ++refCnt;
       }

       synchronized int decrement() {
           return (refCnt == 0) ? 0 : --refCnt;
       }
    }

    private FileRefCounter refCounter = null;

    FileRefCounter getFileRefCounter() {
        return refCounter;
    }

    FileRefCounter createFileRefCounter() {
        refCounter = new FileRefCounter();
        return refCounter;
    }

    void setAndIncFileRefCounter(FileRefCounter rc) {
          this.refCounter = rc;
          this.refCounter.increment();
    }

    int decFileRefCount() {
        if (refCounter == null) {
            return 0;
         } else {
            return refCounter.decrement();
         }
    }

    static class FileDisposer implements DisposerRecord {
        String fileName;
        boolean isTracked;
        FileRefCounter refCounter;
        PrismFontFactory factory;
        WeakReference&lt;PrismFontFile&gt; refKey;

        public FileDisposer(String fileName, boolean isTracked,
                            FileRefCounter rc) {
            this.fileName = fileName;
            this.isTracked = isTracked;
            this.refCounter = rc;
        }

        public void setFactory(PrismFontFactory factory,
                               WeakReference&lt;PrismFontFile&gt; refKey) {
            this.factory = factory;
            this.refKey = refKey;
        }

        public synchronized void dispose() {
            if (fileName != null) {
                AccessController.doPrivileged(
                        (PrivilegedAction&lt;Void&gt;) () -&gt; {
                            try {
                                if (refCounter != null &amp;&amp;
                                    refCounter.decrement() &gt; 0)
                                {
                                    return null;
                                }
                                File file = new File(fileName);
                                int size = (int)file.length();
                                file.delete();
                                // decrement tracker only after
                                // successful deletion.
                                if (isTracked) {
                                    FontFileWriter.FontTracker.
                                        getTracker().subBytes(size);
                                }
                                if (factory != null &amp;&amp; refKey != null) {
                                    Object o = refKey.get();
                                    if (o == null) {
                                        factory.removeTmpFont(refKey);
                                        factory = null;
                                        refKey = null;
                                    }
                                }
                                if (PrismFontFactory.debugFonts) {
                                    System.err.println(&quot;FileDisposer=&quot; + fileName);
                                }
                            } catch (Exception e) {
                                if (PrismFontFactory.debugFonts) {
                                    e.printStackTrace();
                                }
                            }
                            return null;
                        }
                );
                fileName = null;
            }
        }
    }

    public String getFileName() {
        return filename;
    }

    protected int getFileSize() {
        return filesize;
    }

    protected int getFontIndex() {
        return fontIndex;
    }

    public String getFullName() {
        return fullName;
    }

    public String getPSName() {
        if (psName == null) {
            psName = fullName;
        }
        return psName;
    }

    public String getFamilyName() {
        return familyName;
    }

    public String getStyleName() {
        return styleName;
    }

    public String getLocaleFullName() {
        return localeFullName;
    }

    public String getLocaleFamilyName() {
        return localeFamilyName;
    }

    public String getLocaleStyleName() {
        return localeStyleName;
    }

    /*
     * Returns the features the font supports.
     */
    public int getFeatures() {
        //TODO check font file for features
        return -1;
    }

    public Map getStrikeMap() {
        return strikeMap;
    }

    protected abstract PrismFontStrike createStrike(float size,
                                                    BaseTransform transform,
                                                    int aaMode,
                                                    FontStrikeDesc desc);

    public FontStrike getStrike(float size, BaseTransform transform,
                                int aaMode) {
        FontStrikeDesc desc = new FontStrikeDesc(size, transform, aaMode);
        WeakReference&lt;PrismFontStrike&gt; ref = strikeMap.get(desc);
        PrismFontStrike strike = null;
        if (ref != null) {
            strike = ref.get();
        }
        if (strike == null) {
            strike = createStrike(size, transform, aaMode, desc);
            DisposerRecord disposer = strike.getDisposer();
            if (disposer != null) {
                ref = Disposer.addRecord(strike, disposer);
            } else {
                ref = new WeakReference&lt;PrismFontStrike&gt;(strike);
            }
            strikeMap.put(desc, ref);
        }
        return strike;
    }

    HashMap&lt;Integer, int[]&gt; bbCache = null;
    static final int[] EMPTY_BOUNDS = new int[4];

    protected abstract int[] createGlyphBoundingBox(int gc);

    @Override
    public float[] getGlyphBoundingBox(int gc, float size, float[] retArr) {
        if (retArr == null || retArr.length &lt; 4) {
            retArr = new float[4];
        }
        if (gc &gt;= getNumGlyphs()) {
            retArr[0] = retArr[1] = retArr[2] = retArr[3] = 0;
            return retArr;
        }
        if (bbCache == null) {
            bbCache = new HashMap&lt;Integer, int[]&gt;();
        }
        int[] bb = bbCache.get(gc);
        if (bb == null) {
            bb = createGlyphBoundingBox(gc);
            if (bb == null) bb = EMPTY_BOUNDS;
            bbCache.put(gc, bb);
        }
        float scale = size / getUnitsPerEm();
        retArr[0] = bb[0] * scale;
        retArr[1] = bb[1] * scale;
        retArr[2] = bb[2] * scale;
        retArr[3] = bb[3] * scale;
        return retArr;
    }

    int getNumGlyphs() {
        if (numGlyphs == -1) {
            Buffer buffer = readTable(maxpTag);
            numGlyphs = buffer.getChar(4); // offset 4 bytes in MAXP table.
        }
        return numGlyphs;
    }

    protected boolean isCFF() {
        return isCFF;
    }

    private Object peer;
    public Object getPeer() {
        return peer;
    }

    public void setPeer(Object peer) {
        this.peer = peer;
    }

    synchronized Buffer readTable(int tag) {
        Buffer buffer = null;
        boolean openedFile = false;
        try {
            openedFile = filereader.openFile();
            DirectoryEntry tagDE = getDirectoryEntry(tag);
            if (tagDE != null) {
                buffer = filereader.readBlock(tagDE.offset, tagDE.length);
            }
        } catch (Exception e) {
            if (PrismFontFactory.debugFonts) {
                e.printStackTrace();
            }
        } finally {
            if (openedFile) {
                try {
                    filereader.closeFile();
                } catch (Exception e2) {
                }
            }
        }
        return buffer;
    }

    int directoryCount = 1;

    /**
     * @return number of logical fonts. Is &quot;1&quot; for all but TTC files
     */
    public int getFontCount() {
        return directoryCount;
    }

    int numTables;
    DirectoryEntry[] tableDirectory;
    static class DirectoryEntry {
        int tag;
        int offset;
        int length;
    }

    DirectoryEntry getDirectoryEntry(int tag) {
        for (int i=0;i&lt;numTables;i++) {
            if (tableDirectory[i].tag == tag) {
                return tableDirectory[i];
            }
        }
        return null;
    }

    /* Called from the constructor. Does the basic work of finding
     * the right font in a TTC, the font names and enough info
     * (the table offset directory) to be able to locate tables later.
     * Throws an exception if it doesn't like what it finds.
     */
    private void init(String name, int fIndex) throws Exception {
        filereader = new FontFileReader(filename);
        WoffDecoder decoder = null;
        try {
            if (!filereader.openFile()) {
                throw new FileNotFoundException(&quot;Unable to create FontResource&quot;
                        + &quot; for file &quot; + filename);
            }
            Buffer buffer = filereader.readBlock(0, TTCHEADERSIZE);
            int sfntTag = buffer.getInt();

            /* Handle wOFF files */
            if (sfntTag == woffTag) {
                decoder = new WoffDecoder();
                File file = decoder.openFile();
                decoder.decode(filereader);
                decoder.closeFile();

                /* Create a new reader with the decoded file */
                filereader.closeFile();
                filereader = new FontFileReader(file.getPath());
                if (!filereader.openFile()) {
                    throw new FileNotFoundException(&quot;Unable to create &quot;
                            + &quot;FontResource for file &quot; + filename);
                }
                buffer = filereader.readBlock(0, TTCHEADERSIZE);
                sfntTag = buffer.getInt();
            }

            filesize = (int)filereader.getLength();
            int headerOffset = 0;
            if (sfntTag == ttcfTag) {
                buffer.getInt(); // skip TTC version ID
                directoryCount = buffer.getInt();
                if (fIndex &gt;= directoryCount) {
                    throw new Exception(&quot;Bad collection index&quot;);
                }
                fontIndex = fIndex;
                buffer = filereader.readBlock(TTCHEADERSIZE+4*fIndex, 4);
                headerOffset = buffer.getInt();
                buffer = filereader.readBlock(headerOffset, 4);
                sfntTag = buffer.getInt();
            }

            switch (sfntTag) {
            case v1ttTag:
            case trueTag:
                break;

            case ottoTag:
                isCFF = true;
                break;

            default:
                throw new Exception(&quot;Unsupported sfnt &quot; + filename);
            }

            /* Now have the offset of this TT font (possibly within a TTC)
             * After the TT version/scaler type field, is the short
             * representing the number of tables in the table directory.
             * The table directory begins at 12 bytes after the header.
             * Each table entry is 16 bytes long (4 32-bit ints)
             */
            buffer = filereader.readBlock(headerOffset+4, 2);
            numTables = buffer.getShort();
            int directoryOffset = headerOffset+DIRECTORYHEADERSIZE;
            Buffer ibuffer = filereader.
                    readBlock(directoryOffset, numTables*DIRECTORYENTRYSIZE);
            DirectoryEntry table;
            tableDirectory = new DirectoryEntry[numTables];
            for (int i=0; i&lt;numTables;i++) {
                tableDirectory[i] = table = new DirectoryEntry();
                table.tag   =  ibuffer.getInt();
                /* checksum */ ibuffer.skip(4);
                table.offset = ibuffer.getInt();
                table.length = ibuffer.getInt();
                if (table.offset + table.length &gt; filesize) {
                    throw new Exception(&quot;bad table, tag=&quot;+table.tag);
                }
            }

            DirectoryEntry headDE = getDirectoryEntry(headTag);
            Buffer headTable = filereader.readBlock(headDE.offset,
                                                    headDE.length);
            // Important font attribute must be set in order to prevent div by zero
            upem = (float)(headTable.getShort(18) &amp; 0xffff);
            if (!(16 &lt;= upem &amp;&amp; upem &lt;= 16384)) {
                upem = 2048;
            }

            indexToLocFormat = headTable.getShort(50);
            // 0 for short offsets, 1 for long
            if (indexToLocFormat &lt; 0 || indexToLocFormat &gt; 1) {
                throw new Exception(&quot;Bad indexToLocFormat&quot;);
            }

            // In a conventional optimised layout, the
            // hhea table immediately follows the 'head' table.
            Buffer hhea = readTable(hheaTag);
            if (hhea == null) {
                numHMetrics = -1;
            } else {
                // the font table has the sign of ascent and descent
                // reversed from our coordinate system.
                ascent = -(float)hhea.getShort(4);
                descent = -(float)hhea.getShort(6);
                linegap = (float)hhea.getShort(8);
                // advanceWidthMax is max horizontal advance of all glyphs in
                // font. For some fonts advanceWidthMax is much larger then &quot;M&quot;
                // advanceWidthMax = (float)hhea.getChar(10);
                numHMetrics = hhea.getChar(34) &amp; 0xffff;
            }

            // maxp table is before the OS/2 table. Read it now
            // while file is open - will be very cheap as its just
            // 32 bytes and we already have it in a byte[].
            getNumGlyphs();

            setStyle();

            // sanity check the cmap table
            checkCMAP();

            /* Get names last, as the name table is far from the file header.
             * Although its also likely too big to fit in the read cache
             * in which case that would remain valid, but also will help
             * any file read implementation which doesn't have random access.
             */
            initNames();

            if (familyName == null || fullName == null) {
                String fontName = name != null ? name : &quot;&quot;;
                if (fullName == null) {
                    fullName = familyName != null ? familyName : fontName;
                }
                if (familyName == null) {
                    familyName = fullName != null ? fullName : fontName;
                }
                throw new Exception(&quot;Font name not found.&quot;);
            }

            /* update the font resource only if the file was decoded
             * and initialized successfully.
             */
            if (decoder != null) {
                isDecoded = true;
                filename = filereader.getFilename();
                PrismFontFactory.getFontFactory().addDecodedFont(this);
            }
        } catch (Exception e) {
            if (decoder != null) {
                decoder.deleteFile();
            }
            throw e;
        } finally {
            filereader.closeFile();
        }
    }

    /* TrueTypeFont can use the fsSelection fields of OS/2 table
     * or macStyleBits of the 'head' table to determine the style.
     */
    private static final int fsSelectionItalicBit  = 0x00001;
    private static final int fsSelectionBoldBit    = 0x00020;

    private static final int MACSTYLE_BOLD_BIT   = 0x1;
    private static final int MACSTYLE_ITALIC_BIT = 0x2;

    // Comment out some of this until we have both a need and a way to use it.
    // private int embeddingInfo;
    //private int fontWeight;
    private boolean isBold;
    private boolean isItalic;
    private float upem;
    private float ascent, descent, linegap; // in design units
    private int numHMetrics;

    private void setStyle() {
        // A number of fonts on Mac OS X do not have an OS/2
        // table. For those need to get info from a different source.
        DirectoryEntry os2_DE = getDirectoryEntry(os_2Tag);
        if (os2_DE != null) {
            // os2 Table ver 4      DataType    Offset
            //version               USHORT      0
            //xAvgCharWidth         SHORT       2
            //usWeightClass         USHORT      4
            //usWidthClass          USHORT      6
            //fsType                USHORT      8
            //ySubscriptXSize       SHORT      10
            //ySubscriptYSize       SHORT      12
            //ySubscriptXOffset     SHORT      14
            //ySubscriptYOffset     SHORT      16
            //ySuperscriptXSize     SHORT      18
            //ySuperscriptYSize     SHORT      20
            //ySuperscriptXOffset   SHORT      22
            //ySuperscriptYOffset   SHORT      24
            //yStrikeoutSize        SHORT      26
            //yStrikeoutPosition    SHORT      28
            //sFamilyClass          SHORT      30
            //panose[10]            BYTE       32
            //ulUnicodeRange1       ULONG      42
            //ulUnicodeRange2       ULONG      46
            //ulUnicodeRange3       ULONG      50
            //ulUnicodeRange4       ULONG      54
            //achVendID[4]          CHAR       58
            //fsSelection           USHORT     62
            //usFirstCharIndex      USHORT     64
            //usLastCharIndex       USHORT     66
            //sTypoAscender         SHORT      68
            //sTypoDescender        SHORT      70
            //sTypoLineGap          SHORT      72
            //usWinAscent           USHORT     74
            //usWinDescent          USHORT     76
            //ulCodePageRange1      ULONG      78
            //ulCodePageRange2      ULONG      82
            //sxHeight              SHORT      86
            //sCapHeight            SHORT      88
            //usDefaultChar         USHORT     90
            //usBreakChar           USHORT     92
            //usMaxContext          USHORT     94

            Buffer os_2Table = filereader.readBlock(os2_DE.offset,
                                                    os2_DE.length);
            int fsSelection = os_2Table.getChar(62) &amp; 0xffff;
            isItalic = (fsSelection &amp; fsSelectionItalicBit) != 0;
            isBold   = (fsSelection &amp; fsSelectionBoldBit) != 0;
        } else {
            DirectoryEntry headDE = getDirectoryEntry(headTag);
            Buffer headTable = filereader.readBlock(headDE.offset,
                                                    headDE.length);
            short macStyleBits = headTable.getShort(44);
            isItalic = (macStyleBits &amp; MACSTYLE_ITALIC_BIT) != 0;
            isBold = (macStyleBits &amp; MACSTYLE_BOLD_BIT) != 0;
        }
    }

    public boolean isBold() {
        return isBold;
    }

    public boolean isItalic() {
        return isItalic;
    }

    public boolean isDecoded() {
        return isDecoded;
    }

    public boolean isRegistered() {
        return isRegistered;
    }

    public boolean isEmbeddedFont() {
        return isEmbedded;
    }

    /**
     * per the OT spec. this is an unsigned short.
     */
    public int getUnitsPerEm() {
        return (int)upem;
    }

    public short getIndexToLocFormat() {
        return indexToLocFormat;
    }

    /**
     * per the OT spec. this is an unsigned short.
     */
    public int getNumHMetrics() {
        return numHMetrics;
    }

    /* -- ID's used in the 'name' table */
    public static final int MAC_PLATFORM_ID = 1;
    public static final int MACROMAN_SPECIFIC_ID = 0;
    public static final int MACROMAN_ENGLISH_LANG = 0;

    public static final int MS_PLATFORM_ID = 3;
    /* MS locale id for US English is the &quot;default&quot; */
    public static final short MS_ENGLISH_LOCALE_ID = 0x0409; // 1033 decimal
    public static final int FAMILY_NAME_ID = 1;
    public static final int STYLE_NAME_ID = 2;
    public static final int FULL_NAME_ID = 4;
    public static final int PS_NAME_ID = 6;

    void initNames() throws Exception {
        byte[] name = new byte[256];

        DirectoryEntry nameDE = getDirectoryEntry(nameTag);
        Buffer buffer = filereader.readBlock(nameDE.offset, nameDE.length);

        buffer.skip(2); // format - not needed.
        short numRecords = buffer.getShort();
        /* The name table uses unsigned shorts. Many of these
         * are known small values that fit in a short.
         * The values that are sizes or offsets into the table could be
         * greater than 32767, so read and store those as ints
         */
        int stringPtr = buffer.getShort() &amp; 0xffff;

        /* Microsoft Windows font names are preferred but numerous Mac
         * fonts do not have these, so we must also accept these in the
         * absence of the preferred Windows names.
         */
        for (int i=0; i&lt;numRecords; i++) {
            short platformID = buffer.getShort();
            if (platformID != MS_PLATFORM_ID &amp;&amp;
                platformID != MAC_PLATFORM_ID) {
                buffer.skip(10);
                continue; // skip over this record.
            }
            short encodingID = buffer.getShort();
            // only want UTF-16 (inc. symbol) encodingIDs for Windows,
            // or MacRoman on Mac.
            if ((platformID == MS_PLATFORM_ID &amp;&amp; encodingID &gt; 1) ||
                (platformID == MAC_PLATFORM_ID &amp;&amp;
                 encodingID != MACROMAN_SPECIFIC_ID)) {
                buffer.skip(8);
                continue;
            }
            short langID     = buffer.getShort();
            if (platformID == MAC_PLATFORM_ID &amp;&amp;
                langID != MACROMAN_ENGLISH_LANG) {
                buffer.skip(6);
                continue;
            }
            short nameID     = buffer.getShort();
            int nameLen    = ((int)buffer.getShort()) &amp; 0xffff;
            int namePtr    = (((int)buffer.getShort()) &amp; 0xffff) + stringPtr;
            String tmpName = null;
            String enc;
            switch (nameID) {

            case FAMILY_NAME_ID:

                if (familyName == null || langID == MS_ENGLISH_LOCALE_ID ||
                    langID == nameLocaleID)
                    {
                        buffer.get(namePtr, name, 0, nameLen);
                        if (platformID == MAC_PLATFORM_ID) {
                            enc = &quot;US-ASCII&quot;;
                        } else {
                            enc = &quot;UTF-16BE&quot;;
                        }
                        tmpName = new String(name, 0, nameLen, enc);

                        if (familyName == null ||
                            langID == MS_ENGLISH_LOCALE_ID){
                            familyName = tmpName;
                        }
                        if (langID == nameLocaleID) {
                            localeFamilyName = tmpName;
                        }
                    }
                    break;

                case FULL_NAME_ID:

                    if (fullName == null ||
                        langID == MS_ENGLISH_LOCALE_ID ||
                        langID == nameLocaleID)
                    {
                        buffer.get(namePtr, name, 0, nameLen);
                        if (platformID == MAC_PLATFORM_ID) {
                            enc = &quot;US-ASCII&quot;;
                        } else {
                            enc = &quot;UTF-16BE&quot;;
                        }
                        tmpName = new String(name, 0, nameLen, enc);

                        if (fullName == null ||
                            langID == MS_ENGLISH_LOCALE_ID) {
                            fullName = tmpName;
                        }
                        if (langID == nameLocaleID) {
                            localeFullName = tmpName;
                        }
                    }
                    break;

                case PS_NAME_ID:

                    if (psName == null) {
                        buffer.get(namePtr, name, 0, nameLen);
                        if (platformID == MAC_PLATFORM_ID) {
                            enc = &quot;US-ASCII&quot;;
                        } else {
                            enc = &quot;UTF-16BE&quot;;
                        }
                        psName = new String(name, 0, nameLen, enc);
                    }
                    break;

                case STYLE_NAME_ID:

                    if (styleName == null ||
                        langID == MS_ENGLISH_LOCALE_ID ||
                        langID == nameLocaleID)
                    {
                        buffer.get(namePtr, name, 0, nameLen);
                        if (platformID == MAC_PLATFORM_ID) {
                            enc = &quot;US-ASCII&quot;;
                        } else {
                            enc = &quot;UTF-16BE&quot;;
                        }
                        tmpName = new String(name, 0, nameLen, enc);

                        if (styleName == null ||
                            langID == MS_ENGLISH_LOCALE_ID) {
                            styleName = tmpName;
                        }
                        if (langID == nameLocaleID) {
                            localeStyleName = tmpName;
                        }
                    }
                    break;

            default:
                break;
            }

            if (localeFamilyName == null) {
                localeFamilyName = familyName;
            }
<A NAME="38"></A>            if (localeFullName == null) {
                localeFullName = fullName;
            }
            <FONT color="#348781"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#38',2,'match46-top.html#38',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (localeStyleName == null) {
                localeStyleName = styleName;
            }
        }
    }

    private void checkCMAP() throws Exception {
        DirectoryEntry cmapDE = getDirectoryEntry(FontConstants.cmapTag)</B></FONT>;
        if (cmapDE != null) {
            if (cmapDE.length &lt; 4) {
                throw new Exception(&quot;Invalid cmap table length&quot;);
            }
            Buffer cmapTableHeader = filereader.readBlock(cmapDE.offset, 4);
            short version = cmapTableHeader.getShort();
            short numberSubTables = cmapTableHeader.getShort();
            int indexLength = numberSubTables * 8;
            if (numberSubTables &lt;= 0 || cmapDE.length &lt; indexLength + 4) {
                throw new Exception(&quot;Invalid cmap subtables count&quot;);
            }
            Buffer cmapTableIndex = filereader.readBlock(cmapDE.offset + 4, indexLength);
            for (int i = 0; i &lt; numberSubTables; i++) {
                short platformID = cmapTableIndex.getShort();
                short encodingID = cmapTableIndex.getShort();
                int offset = cmapTableIndex.getInt();
                if (offset &lt; 0 || offset &gt;= cmapDE.length) {
                    throw new Exception(&quot;Invalid cmap subtable offset&quot;);
                }
            }
        }
    }

    /*** BEGIN LOCALE_ID MAPPING ****/

    private static Map&lt;String, Short&gt; lcidMap;

    // Return a Microsoft LCID from the given Locale.
    // Used when getting localized font data.

    private static void addLCIDMapEntry(Map&lt;String, Short&gt; map,
                                        String key, short value) {
        map.put(key, Short.valueOf(value));
    }

    private static synchronized void createLCIDMap() {
        if (lcidMap != null) {
            return;
        }

        Map&lt;String, Short&gt; map = new HashMap&lt;String, Short&gt;(200);
        addLCIDMapEntry(map, &quot;ar&quot;, (short) 0x0401);
        addLCIDMapEntry(map, &quot;bg&quot;, (short) 0x0402);
        addLCIDMapEntry(map, &quot;ca&quot;, (short) 0x0403);
        addLCIDMapEntry(map, &quot;zh&quot;, (short) 0x0404);
        addLCIDMapEntry(map, &quot;cs&quot;, (short) 0x0405);
        addLCIDMapEntry(map, &quot;da&quot;, (short) 0x0406);
        addLCIDMapEntry(map, &quot;de&quot;, (short) 0x0407);
        addLCIDMapEntry(map, &quot;el&quot;, (short) 0x0408);
        addLCIDMapEntry(map, &quot;es&quot;, (short) 0x040a);
        addLCIDMapEntry(map, &quot;fi&quot;, (short) 0x040b);
        addLCIDMapEntry(map, &quot;fr&quot;, (short) 0x040c);
        addLCIDMapEntry(map, &quot;iw&quot;, (short) 0x040d);
        addLCIDMapEntry(map, &quot;hu&quot;, (short) 0x040e);
        addLCIDMapEntry(map, &quot;is&quot;, (short) 0x040f);
        addLCIDMapEntry(map, &quot;it&quot;, (short) 0x0410);
        addLCIDMapEntry(map, &quot;ja&quot;, (short) 0x0411);
        addLCIDMapEntry(map, &quot;ko&quot;, (short) 0x0412);
        addLCIDMapEntry(map, &quot;nl&quot;, (short) 0x0413);
        addLCIDMapEntry(map, &quot;no&quot;, (short) 0x0414);
        addLCIDMapEntry(map, &quot;pl&quot;, (short) 0x0415);
        addLCIDMapEntry(map, &quot;pt&quot;, (short) 0x0416);
        addLCIDMapEntry(map, &quot;rm&quot;, (short) 0x0417);
        addLCIDMapEntry(map, &quot;ro&quot;, (short) 0x0418);
        addLCIDMapEntry(map, &quot;ru&quot;, (short) 0x0419);
        addLCIDMapEntry(map, &quot;hr&quot;, (short) 0x041a);
        addLCIDMapEntry(map, &quot;sk&quot;, (short) 0x041b);
        addLCIDMapEntry(map, &quot;sq&quot;, (short) 0x041c);
        addLCIDMapEntry(map, &quot;sv&quot;, (short) 0x041d);
        addLCIDMapEntry(map, &quot;th&quot;, (short) 0x041e);
        addLCIDMapEntry(map, &quot;tr&quot;, (short) 0x041f);
        addLCIDMapEntry(map, &quot;ur&quot;, (short) 0x0420);
        addLCIDMapEntry(map, &quot;in&quot;, (short) 0x0421);
        addLCIDMapEntry(map, &quot;uk&quot;, (short) 0x0422);
        addLCIDMapEntry(map, &quot;be&quot;, (short) 0x0423);
        addLCIDMapEntry(map, &quot;sl&quot;, (short) 0x0424);
        addLCIDMapEntry(map, &quot;et&quot;, (short) 0x0425);
        addLCIDMapEntry(map, &quot;lv&quot;, (short) 0x0426);
        addLCIDMapEntry(map, &quot;lt&quot;, (short) 0x0427);
        addLCIDMapEntry(map, &quot;fa&quot;, (short) 0x0429);
        addLCIDMapEntry(map, &quot;vi&quot;, (short) 0x042a);
        addLCIDMapEntry(map, &quot;hy&quot;, (short) 0x042b);
        addLCIDMapEntry(map, &quot;eu&quot;, (short) 0x042d);
        addLCIDMapEntry(map, &quot;mk&quot;, (short) 0x042f);
        addLCIDMapEntry(map, &quot;tn&quot;, (short) 0x0432);
        addLCIDMapEntry(map, &quot;xh&quot;, (short) 0x0434);
        addLCIDMapEntry(map, &quot;zu&quot;, (short) 0x0435);
        addLCIDMapEntry(map, &quot;af&quot;, (short) 0x0436);
        addLCIDMapEntry(map, &quot;ka&quot;, (short) 0x0437);
        addLCIDMapEntry(map, &quot;fo&quot;, (short) 0x0438);
        addLCIDMapEntry(map, &quot;hi&quot;, (short) 0x0439);
        addLCIDMapEntry(map, &quot;mt&quot;, (short) 0x043a);
        addLCIDMapEntry(map, &quot;se&quot;, (short) 0x043b);
        addLCIDMapEntry(map, &quot;gd&quot;, (short) 0x043c);
        addLCIDMapEntry(map, &quot;ms&quot;, (short) 0x043e);
        addLCIDMapEntry(map, &quot;kk&quot;, (short) 0x043f);
        addLCIDMapEntry(map, &quot;ky&quot;, (short) 0x0440);
        addLCIDMapEntry(map, &quot;sw&quot;, (short) 0x0441);
        addLCIDMapEntry(map, &quot;tt&quot;, (short) 0x0444);
        addLCIDMapEntry(map, &quot;bn&quot;, (short) 0x0445);
        addLCIDMapEntry(map, &quot;pa&quot;, (short) 0x0446);
        addLCIDMapEntry(map, &quot;gu&quot;, (short) 0x0447);
        addLCIDMapEntry(map, &quot;ta&quot;, (short) 0x0449);
        addLCIDMapEntry(map, &quot;te&quot;, (short) 0x044a);
        addLCIDMapEntry(map, &quot;kn&quot;, (short) 0x044b);
        addLCIDMapEntry(map, &quot;ml&quot;, (short) 0x044c);
        addLCIDMapEntry(map, &quot;mr&quot;, (short) 0x044e);
        addLCIDMapEntry(map, &quot;sa&quot;, (short) 0x044f);
        addLCIDMapEntry(map, &quot;mn&quot;, (short) 0x0450);
        addLCIDMapEntry(map, &quot;cy&quot;, (short) 0x0452);
        addLCIDMapEntry(map, &quot;gl&quot;, (short) 0x0456);
        addLCIDMapEntry(map, &quot;dv&quot;, (short) 0x0465);
        addLCIDMapEntry(map, &quot;qu&quot;, (short) 0x046b);
        addLCIDMapEntry(map, &quot;mi&quot;, (short) 0x0481);
        addLCIDMapEntry(map, &quot;ar_IQ&quot;, (short) 0x0801);
        addLCIDMapEntry(map, &quot;zh_CN&quot;, (short) 0x0804);
        addLCIDMapEntry(map, &quot;de_CH&quot;, (short) 0x0807);
        addLCIDMapEntry(map, &quot;en_GB&quot;, (short) 0x0809);
        addLCIDMapEntry(map, &quot;es_MX&quot;, (short) 0x080a);
        addLCIDMapEntry(map, &quot;fr_BE&quot;, (short) 0x080c);
        addLCIDMapEntry(map, &quot;it_CH&quot;, (short) 0x0810);
        addLCIDMapEntry(map, &quot;nl_BE&quot;, (short) 0x0813);
        addLCIDMapEntry(map, &quot;no_NO_NY&quot;, (short) 0x0814);
        addLCIDMapEntry(map, &quot;pt_PT&quot;, (short) 0x0816);
        addLCIDMapEntry(map, &quot;ro_MD&quot;, (short) 0x0818);
        addLCIDMapEntry(map, &quot;ru_MD&quot;, (short) 0x0819);
        addLCIDMapEntry(map, &quot;sr_CS&quot;, (short) 0x081a);
        addLCIDMapEntry(map, &quot;sv_FI&quot;, (short) 0x081d);
        addLCIDMapEntry(map, &quot;az_AZ&quot;, (short) 0x082c);
        addLCIDMapEntry(map, &quot;se_SE&quot;, (short) 0x083b);
        addLCIDMapEntry(map, &quot;ga_IE&quot;, (short) 0x083c);
        addLCIDMapEntry(map, &quot;ms_BN&quot;, (short) 0x083e);
        addLCIDMapEntry(map, &quot;uz_UZ&quot;, (short) 0x0843);
        addLCIDMapEntry(map, &quot;qu_EC&quot;, (short) 0x086b);
        addLCIDMapEntry(map, &quot;ar_EG&quot;, (short) 0x0c01);
        addLCIDMapEntry(map, &quot;zh_HK&quot;, (short) 0x0c04);
        addLCIDMapEntry(map, &quot;de_AT&quot;, (short) 0x0c07);
        addLCIDMapEntry(map, &quot;en_AU&quot;, (short) 0x0c09);
        addLCIDMapEntry(map, &quot;fr_CA&quot;, (short) 0x0c0c);
        addLCIDMapEntry(map, &quot;sr_CS&quot;, (short) 0x0c1a);
        addLCIDMapEntry(map, &quot;se_FI&quot;, (short) 0x0c3b);
        addLCIDMapEntry(map, &quot;qu_PE&quot;, (short) 0x0c6b);
        addLCIDMapEntry(map, &quot;ar_LY&quot;, (short) 0x1001);
        addLCIDMapEntry(map, &quot;zh_SG&quot;, (short) 0x1004);
        addLCIDMapEntry(map, &quot;de_LU&quot;, (short) 0x1007);
        addLCIDMapEntry(map, &quot;en_CA&quot;, (short) 0x1009);
        addLCIDMapEntry(map, &quot;es_GT&quot;, (short) 0x100a);
        addLCIDMapEntry(map, &quot;fr_CH&quot;, (short) 0x100c);
        addLCIDMapEntry(map, &quot;hr_BA&quot;, (short) 0x101a);
        addLCIDMapEntry(map, &quot;ar_DZ&quot;, (short) 0x1401);
        addLCIDMapEntry(map, &quot;zh_MO&quot;, (short) 0x1404);
        addLCIDMapEntry(map, &quot;de_LI&quot;, (short) 0x1407);
        addLCIDMapEntry(map, &quot;en_NZ&quot;, (short) 0x1409);
        addLCIDMapEntry(map, &quot;es_CR&quot;, (short) 0x140a);
        addLCIDMapEntry(map, &quot;fr_LU&quot;, (short) 0x140c);
        addLCIDMapEntry(map, &quot;bs_BA&quot;, (short) 0x141a);
        addLCIDMapEntry(map, &quot;ar_MA&quot;, (short) 0x1801);
        addLCIDMapEntry(map, &quot;en_IE&quot;, (short) 0x1809);
        addLCIDMapEntry(map, &quot;es_PA&quot;, (short) 0x180a);
        addLCIDMapEntry(map, &quot;fr_MC&quot;, (short) 0x180c);
        addLCIDMapEntry(map, &quot;sr_BA&quot;, (short) 0x181a);
        addLCIDMapEntry(map, &quot;ar_TN&quot;, (short) 0x1c01);
        addLCIDMapEntry(map, &quot;en_ZA&quot;, (short) 0x1c09);
        addLCIDMapEntry(map, &quot;es_DO&quot;, (short) 0x1c0a);
        addLCIDMapEntry(map, &quot;sr_BA&quot;, (short) 0x1c1a);
        addLCIDMapEntry(map, &quot;ar_OM&quot;, (short) 0x2001);
        addLCIDMapEntry(map, &quot;en_JM&quot;, (short) 0x2009);
        addLCIDMapEntry(map, &quot;es_VE&quot;, (short) 0x200a);
        addLCIDMapEntry(map, &quot;ar_YE&quot;, (short) 0x2401);
        addLCIDMapEntry(map, &quot;es_CO&quot;, (short) 0x240a);
        addLCIDMapEntry(map, &quot;ar_SY&quot;, (short) 0x2801);
        addLCIDMapEntry(map, &quot;en_BZ&quot;, (short) 0x2809);
        addLCIDMapEntry(map, &quot;es_PE&quot;, (short) 0x280a);
        addLCIDMapEntry(map, &quot;ar_JO&quot;, (short) 0x2c01);
        addLCIDMapEntry(map, &quot;en_TT&quot;, (short) 0x2c09);
        addLCIDMapEntry(map, &quot;es_AR&quot;, (short) 0x2c0a);
        addLCIDMapEntry(map, &quot;ar_LB&quot;, (short) 0x3001);
        addLCIDMapEntry(map, &quot;en_ZW&quot;, (short) 0x3009);
        addLCIDMapEntry(map, &quot;es_EC&quot;, (short) 0x300a);
        addLCIDMapEntry(map, &quot;ar_KW&quot;, (short) 0x3401);
        addLCIDMapEntry(map, &quot;en_PH&quot;, (short) 0x3409);
        addLCIDMapEntry(map, &quot;es_CL&quot;, (short) 0x340a);
        addLCIDMapEntry(map, &quot;ar_AE&quot;, (short) 0x3801);
        addLCIDMapEntry(map, &quot;es_UY&quot;, (short) 0x380a);
        addLCIDMapEntry(map, &quot;ar_BH&quot;, (short) 0x3c01);
        addLCIDMapEntry(map, &quot;es_PY&quot;, (short) 0x3c0a);
        addLCIDMapEntry(map, &quot;ar_QA&quot;, (short) 0x4001);
        addLCIDMapEntry(map, &quot;es_BO&quot;, (short) 0x400a);
        addLCIDMapEntry(map, &quot;es_SV&quot;, (short) 0x440a);
        addLCIDMapEntry(map, &quot;es_HN&quot;, (short) 0x480a);
        addLCIDMapEntry(map, &quot;es_NI&quot;, (short) 0x4c0a);
        addLCIDMapEntry(map, &quot;es_PR&quot;, (short) 0x500a);

        lcidMap = map;
    }

    private static short getLCIDFromLocale(Locale locale) {
        // optimize for common case
        if (locale.equals(Locale.US) || locale.getLanguage().equals(&quot;en&quot;)) {
            return MS_ENGLISH_LOCALE_ID;
        }

        if (lcidMap == null) {
            createLCIDMap();
        }

        String key = locale.toString();
        while (!key.isEmpty()) {
            Short lcidObject = (Short) lcidMap.get(key);
            if (lcidObject != null) {
                return lcidObject.shortValue();
            }
            int pos = key.lastIndexOf('_');
            if (pos &lt; 1) {
                return MS_ENGLISH_LOCALE_ID;
            }
            key = key.substring(0, pos);
        }

        return MS_ENGLISH_LOCALE_ID;
    }


    /* On Windows this is set to the System Locale, which matches how
     * GDI enumerates font names. For display purposes we may want
     * the user locale which could be different.
     */
    static short nameLocaleID = getSystemLCID();

    private static short getSystemLCID() {
        if (PrismFontFactory.isWindows) {
            return PrismFontFactory.getSystemLCID();
        } else {
            return getLCIDFromLocale(Locale.getDefault());
        }
    }

    private OpenTypeGlyphMapper mapper = null;

    public CharToGlyphMapper getGlyphMapper() {
        if (mapper == null) {
            mapper = new OpenTypeGlyphMapper(this);
        }
        return mapper;
    }

    public FontStrike getStrike(float size, BaseTransform transform) {
        return getStrike(size, transform, getDefaultAAMode());
    }

    char[] advanceWidths = null;
    /*
     * This is returning the unhinted advance, should be OK so
     * long as we do unhinted rendering. If we are doing hinted glyphs
     * and I suppose, integer metrics, then we can use the hdmx table.
     * But since the hdmx table doesn't provide anything except integers
     * it will only be useful for some cases. Also even then the ptSize
     * alone doesn't help, since we need to know the graphics scale
     * to know the real glyph size that's required, then of course we
     * have to translate that back into user space. So all of that will
     * need to be looked into, or we reserve this path for unhinted rendering.
     * Note that if there's no hdmx entry for a given size, then we need
     * to scale the glyph to get the hinted advance. However before doing
     * so we should consult the 'gasp' table to see it its a size at
     * which hinting should be performed anyway.
     * (1) The GASP table indicates size at which hinting should be applied
     * usually this is all larger sizes so probably wouldn't help, however
     * (2) If there is a LTSH (Linear Threshold) table, we can use that
     * to see if for the requested 'ppem' size, the glyph scales linearly.
     *
     * Interestingly Amble sets the 'head' flags bit to say non-linear
     * scaling and so legitimately has a LTSH table but this all may be
     * a hold-over from when its gasp table said to apply hints at some sizes.
     * I suppose I am not 100% certain if the gasp table can be trusted to
     * use as a short-cut for when you don't need to scale, or if choosing
     * not to hint means you can always just assume linear scaling, but I
     * do find that to be consistent with the data in Microsoft fonts where
     * they do not provide hdmx entry for sizes below that where hinting is
     * required, suggesting the htmx table is fine for such cases.
     */
    public float getAdvance(int glyphCode, float ptSize) {
        if (glyphCode == CharToGlyphMapper.INVISIBLE_GLYPH_ID)
            return 0f;

        // If we haven't initialised yet, do so now.
        if (advanceWidths == null &amp;&amp; numHMetrics &gt; 0) {
            synchronized (this) {
                Buffer hmtx = readTable(hmtxTag);
                if (hmtx == null) {
                    numHMetrics = -1;
                    return 0;
                }
                char[] aw = new char[numHMetrics];
                for (int i=0; i&lt;numHMetrics; i++) {
                    aw[i] = hmtx.getChar(i*4);
                }
                advanceWidths = aw;
            }
        }

        // If we have a valid numHMetrics, look up the advance
        if (numHMetrics &gt; 0) {
            char cadv;
            if (glyphCode &lt; numHMetrics) {
                cadv = advanceWidths[glyphCode];
            } else {
                cadv = advanceWidths[numHMetrics-1];
            }
            return ((float)(cadv &amp; 0xffff)*ptSize)/upem;
        } else { // no valid lookup.
            return 0f;
        }
    }

    public PrismMetrics getFontMetrics(float ptSize) {
        return new PrismMetrics((ascent*ptSize)/upem,
                              (descent*ptSize)/upem,
                              (linegap*ptSize)/upem,
                              this, ptSize);
    }

    private float[] styleMetrics;
    float[] getStyleMetrics(float ptSize) {
        if (styleMetrics == null) {
            float [] smetrics = new float[METRICS_TOTAL];

            Buffer os_2 = readTable(os_2Tag);
            int length = os_2 != null ? os_2.capacity() : 0;

            if (length &gt;= 30) {
                smetrics[STRIKETHROUGH_THICKNESS] = os_2.getShort(26) / upem;
                smetrics[STRIKETHROUGH_OFFSET] = -os_2.getShort(28) / upem;
            } else {
                smetrics[STRIKETHROUGH_THICKNESS] = 0.05f;
                smetrics[STRIKETHROUGH_OFFSET] = -0.4f;
            }
            if (length &gt;= 74) {
                // ascent, descent, leading are set in constructor
                smetrics[TYPO_ASCENT] = -os_2.getShort(68) / upem;
                smetrics[TYPO_DESCENT] = -os_2.getShort(70) / upem;
                smetrics[TYPO_LINEGAP] = os_2.getShort(72) / upem;
            } else {
                smetrics[TYPO_ASCENT] = ascent / upem;
                smetrics[TYPO_DESCENT] = descent / upem;
                smetrics[TYPO_LINEGAP] = linegap / upem;
            }
            // REMIND : OpenType spec introduced xHeight, many fonts
            // won't have this info.
            // xHeight should be available in OS2 font table ver. 3 or greater
            if (length &gt;= 90) {
                smetrics[XHEIGHT] = os_2.getShort(86) / upem;
                smetrics[CAPHEIGHT] = os_2.getShort(88);

                /* Some fonts have bad values for capHeight. For example,
                 * Comic Sans MS. The fix is to ignore the capHeight in the
                 * font file when it is less than half of the ascent */
                if ((smetrics[CAPHEIGHT] / ascent) &lt; 0.5) {
                    smetrics[CAPHEIGHT] = 0;
                } else {
                    smetrics[CAPHEIGHT] /= upem;
                }
            }

            if (smetrics[XHEIGHT] == 0 || smetrics[CAPHEIGHT] == 0) {
                FontStrike strike = getStrike(ptSize, BaseTransform.IDENTITY_TRANSFORM);
                CharToGlyphMapper mapper = getGlyphMapper();
                int missingGlyph = mapper.getMissingGlyphCode();

                if (smetrics[XHEIGHT] == 0) {
                    int gc = mapper.charToGlyph('x');
                    if (gc != missingGlyph) {
                        RectBounds fbds = strike.getGlyph(gc).getBBox();
                        smetrics[XHEIGHT] = fbds.getHeight() / ptSize;
                    } else {
                        smetrics[XHEIGHT] = -ascent * 0.6f / upem;
                    }
                }
                if (smetrics[CAPHEIGHT] == 0) {
                    int gc = mapper.charToGlyph('H');
                    if (gc != missingGlyph) {
                        RectBounds fbds = strike.getGlyph(gc).getBBox();
                        smetrics[CAPHEIGHT] = fbds.getHeight() / ptSize;
                    } else {
                        smetrics[CAPHEIGHT] = -ascent * 0.9f / upem;
                    }
                }
            }

            Buffer postTable = readTable(postTag);
            if (postTable == null || postTable.capacity() &lt; 12) {
                smetrics[UNDERLINE_OFFSET] = 0.1f;
                smetrics[UNDERLINE_THICKESS] = 0.05f;
            } else {
                smetrics[UNDERLINE_OFFSET] = -postTable.getShort(8) / upem;
                smetrics[UNDERLINE_THICKESS] = postTable.getShort(10) / upem;
            }
            styleMetrics = smetrics;
        }

        float[] metrics = new float[METRICS_TOTAL];
        for (int i = 0; i &lt; METRICS_TOTAL; i++) {
            metrics[i] = styleMetrics[i] * ptSize;
        }

        return metrics;
    }

    byte[] getTableBytes(int tag) {
        Buffer buffer = readTable(tag);
        byte[] table = null;
        if(buffer != null){
            table = new byte[buffer.capacity()];
            buffer.get(0, table, 0, buffer.capacity());
        }
        return table;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (!(obj instanceof PrismFontFile)) {
            return false;
        }
        final PrismFontFile other = (PrismFontFile)obj;
        return filename.equals(other.filename) &amp;&amp; fullName.equals(other.fullName);
    }

    @Override
    public int hashCode() {
        return filename.hashCode() + (71 * fullName.hashCode());
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/geom/Vec2d.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.geom;

/**
 * A 2-dimensional, double-precision, floating-point vector.
 *
 */
public class Vec2d {
    /**
     * The x coordinate.
     */
    public double x;

    /**
     * The y coordinate.
     */
    public double y;
<A NAME="33"></A>
    public Vec2d() { }

    <FONT color="#736aff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#33',2,'match46-top.html#33',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>public Vec2d(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public Vec2d(Vec2d v) {
        set(v);
    }

    public Vec2d(Vec2f v) {
        set(v);
    }

    public void set(Vec2d v) {</B></FONT>
        this.x = v.x;
        this.y = v.y;
    }

    public void set(Vec2f v) {
        this.x = v.x;
        this.y = v.y;
    }

    public void set(double x, double y) {
        this.x = x;
        this.y = y;
    }

    /**
     * Returns the square of the distance between two points.
     *
     * @param x1 the X coordinate of the first specified point
     * @param y1 the Y coordinate of the first specified point
     * @param x2 the X coordinate of the second specified point
     * @param y2 the Y coordinate of the second specified point
     * @return the square of the distance between the two
     * sets of specified coordinates.
     */
    public static double distanceSq(double x1, double y1, double x2, double y2) {
        x1 -= x2;
        y1 -= y2;
        return (x1 * x1 + y1 * y1);
    }

    /**
     * Returns the distance between two points.
     *
     * @param x1 the X coordinate of the first specified point
     * @param y1 the Y coordinate of the first specified point
     * @param x2 the X coordinate of the second specified point
     * @param y2 the Y coordinate of the second specified point
     * @return the distance between the two sets of specified
     * coordinates.
     */
    public static double distance(double x1, double y1, double x2, double y2) {
        x1 -= x2;
        y1 -= y2;
        return Math.sqrt(x1 * x1 + y1 * y1);
    }

    /**
     * Returns the square of the distance from this
     * &lt;code&gt;Vec2d&lt;/code&gt; to a specified point.
     *
     * @param vx the X coordinate of the specified point to be measured
     *           against this &lt;code&gt;Vec2d&lt;/code&gt;
     * @param vy the Y coordinate of the specified point to be measured
     *           against this &lt;code&gt;Vec2d&lt;/code&gt;
     * @return the square of the distance between this
     * &lt;code&gt;Vec2d&lt;/code&gt; and the specified point.
     */
    public double distanceSq(double vx, double vy) {
        vx -= x;
        vy -= y;
        return (vx * vx + vy * vy);
    }

    /**
     * Returns the square of the distance from this
     * &lt;code&gt;Vec2d&lt;/code&gt; to a specified &lt;code&gt;Vec2d&lt;/code&gt;.
     *
     * @param v the specified point to be measured
     *           against this &lt;code&gt;Vec2d&lt;/code&gt;
     * @return the square of the distance between this
     * &lt;code&gt;Vec2d&lt;/code&gt; to a specified &lt;code&gt;Vec2d&lt;/code&gt;.
     */
    public double distanceSq(Vec2d v) {
        double vx = v.x - this.x;
        double vy = v.y - this.y;
        return (vx * vx + vy * vy);
    }

    /**
     * Returns the distance from this &lt;code&gt;Vec2d&lt;/code&gt; to
     * a specified point.
     *
     * @param vx the X coordinate of the specified point to be measured
     *           against this &lt;code&gt;Vec2d&lt;/code&gt;
     * @param vy the Y coordinate of the specified point to be measured
     *           against this &lt;code&gt;Vec2d&lt;/code&gt;
     * @return the distance between this &lt;code&gt;Vec2d&lt;/code&gt;
     * and a specified point.
     */
    public double distance(double vx, double vy) {
        vx -= x;
        vy -= y;
        return Math.sqrt(vx * vx + vy * vy);
    }

    /**
     * Returns the distance from this &lt;code&gt;Vec2d&lt;/code&gt; to a
     * specified &lt;code&gt;Vec2d&lt;/code&gt;.
     *
     * @param v the specified point to be measured
     *           against this &lt;code&gt;Vec2d&lt;/code&gt;
     * @return the distance between this &lt;code&gt;Vec2d&lt;/code&gt; and
     * the specified &lt;code&gt;Vec2d&lt;/code&gt;.
     */
    public double distance(Vec2d v) {
        double vx = v.x - this.x;
        double vy = v.y - this.y;
        return Math.sqrt(vx * vx + vy * vy);
    }

    /**
     * Returns the hashcode for this &lt;code&gt;Vec2d&lt;/code&gt;.
     * @return      a hash code for this &lt;code&gt;Vec2d&lt;/code&gt;.
     */
    @Override
    public int hashCode() {
        long bits = 7L;
        bits = 31L * bits + Double.doubleToLongBits(x);
        bits = 31L * bits + Double.doubleToLongBits(y);
        return (int) (bits ^ (bits &gt;&gt; 32));
    }

    /**
     * Determines whether or not two 2D points or vectors are equal.
     * Two instances of &lt;code&gt;Vec2d&lt;/code&gt; are equal if the values of their
     * &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; member fields, representing
     * their position in the coordinate space, are the same.
     * @param obj an object to be compared with this &lt;code&gt;Vec2d&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if the object to be compared is
     *         an instance of &lt;code&gt;Vec2d&lt;/code&gt; and has
     *         the same values; &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof Vec2d) {
            Vec2d v = (Vec2d) obj;
            return (x == v.x) &amp;&amp; (y == v.y);
        }
        return false;
    }

    /**
     * Returns a &lt;code&gt;String&lt;/code&gt; that represents the value
     * of this &lt;code&gt;Vec2d&lt;/code&gt;.
     * @return a string representation of this &lt;code&gt;Vec2d&lt;/code&gt;.
     */
    @Override
    public String toString() {
        return &quot;Vec2d[&quot; + x + &quot;, &quot; + y + &quot;]&quot;;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/iio/bmp/BMPImageLoaderFactory.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.iio.bmp;

import com.sun.javafx.iio.*;
import com.sun.javafx.iio.common.*;
import java.io.*;
import java.nio.ByteBuffer;

final class BMPDescriptor extends ImageDescriptor {

    static final String formatName = &quot;BMP&quot;;
    static final String extensions[] = { &quot;bmp&quot; };
    static final Signature signatures[] = {new Signature((byte)0x42, (byte)0x4D)};
    static final ImageDescriptor theInstance = new BMPDescriptor();

    private BMPDescriptor() {
        super(formatName, extensions, signatures);
    }
}

// the difference of LEInputStream from DataInputStream is Endianness
final class LEInputStream {

    final public InputStream in;

    LEInputStream(InputStream is) {
        in = is;
    }

    public final short readShort() throws IOException {
        int ch1 = in.read();
        int ch2 = in.read();
        if ((ch1 | ch2) &lt; 0) {
            throw new EOFException();
        }
        return (short)((ch2 &lt;&lt; 8) + ch1);
    }

    public final int readInt() throws IOException {
        int ch1 = in.read();
        int ch2 = in.read();
        int ch3 = in.read();
        int ch4 = in.read();
<A NAME="19"></A>        if ((ch1 | ch2 | ch3 | ch4) &lt; 0) {
            throw new EOFException();
        }
        <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#19',2,'match46-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return ((ch4 &lt;&lt; 24) + (ch3 &lt;&lt; 16) + (ch2 &lt;&lt; 8) + ch1);
    }

    public final void skipBytes(int n) throws IOException {
        ImageTools.skipFully(in, n);
    }
}</B></FONT>

final class BitmapInfoHeader {

    static final int BIH_SIZE = 40;
    static final int BIH4_SIZE = 108;
    static final int BIH5_SIZE = 124;
    static final int BI_RGB = 0;
    static final int BI_RLE8 = 1;
    static final int BI_RLE4 = 2;
    static final int BI_BITFIELDS = 3;
    static final int BI_JPEG = 4;
    static final int BI_PNG = 5;

    final int    biSize;
    final int    biWidth;
    final int    biHeight;
    final short  biPlanes;
    final short  biBitCount;
    final int    biCompression;
    final int    biSizeImage;
    final int    biXPelsPerMeter;
    final int    biYPelsPerMeter;
    final int    biClrUsed;
    final int    biClrImportant;

    BitmapInfoHeader(LEInputStream data) throws IOException {
        biSize = data.readInt();
        biWidth = data.readInt();
        biHeight = data.readInt();
        biPlanes = data.readShort();
        biBitCount = data.readShort();
        biCompression = data.readInt();
        biSizeImage = data.readInt();
        biXPelsPerMeter = data.readInt();
        biYPelsPerMeter = data.readInt();
        biClrUsed = data.readInt();
        biClrImportant = data.readInt();

        if (biSize &gt; BIH_SIZE) {
            if (biSize == BIH4_SIZE || biSize == BIH5_SIZE) {
                data.skipBytes(biSize - BIH_SIZE);
            } else {
                throw new IOException(&quot;BitmapInfoHeader is corrupt&quot;);
            }
        }
        validate();
    }

    void validate() throws IOException {
        if (biBitCount &lt; 1 ||
                biCompression == BI_JPEG || biCompression == BI_PNG)
        {
            throw new IOException(&quot;Unsupported BMP image: &quot; +
                    &quot;Embedded JPEG or PNG images are not supported&quot;);
        }

        switch (biCompression) {
            case BI_RLE4:
                if (biBitCount != 4) {
                    throw new IOException(&quot;Invalid BMP image: &quot; +
                            &quot;Only 4 bpp images can be RLE4 compressed&quot;);
                }
                break;
            case BI_RLE8:
                if (biBitCount != 8) {
                    throw new IOException(&quot;Invalid BMP image: &quot; +
                            &quot;Only 8 bpp images can be RLE8 compressed&quot;);
                }
                break;
            case BI_BITFIELDS:
                if (biBitCount != 16 &amp;&amp; biBitCount != 32) {
                    throw new IOException(&quot;Invalid BMP image: &quot; +
                            &quot;Only 16 or 32 bpp images can use BITFIELDS compression&quot;);
                }
                break;
            case BI_RGB:
                break;
            default:
                throw new IOException(&quot;Unknown BMP compression type&quot;);
        }
    }
}

final class BMPImageLoader extends ImageLoaderImpl {

    static final short BM = 0x4D42;
    static final int BFH_SIZE = 14;

    final LEInputStream data;

    int   bfSize;
    int   bfOffBits;
    byte  bgra_palette[];
    BitmapInfoHeader bih;

    // BI_BITFIELDS support
    int bitMasks[];
    int bitOffsets[];

    BMPImageLoader(InputStream input) throws IOException {
        super(BMPDescriptor.theInstance);
        data = new LEInputStream(input);
        if (data.readShort() != BM) {
            throw new IOException(&quot;Invalid BMP file signature&quot;);
        }
        readHeader();
    }

    private void readHeader() throws IOException {
        bfSize = data.readInt();
        data.skipBytes(4); // 32  bits reserved
        bfOffBits = data.readInt();
        bih = new BitmapInfoHeader(data);
        if (bfOffBits &lt; bih.biSize + BFH_SIZE) {
            throw new IOException(&quot;Invalid bitmap bits offset&quot;);
        }

        if (bih.biSize + BFH_SIZE != bfOffBits) {
            int length = bfOffBits - bih.biSize - BFH_SIZE;
            int paletteSize = length / 4;
            bgra_palette = new byte[paletteSize * 4];
            int read = data.in.read(bgra_palette);
            // goto bitmap bits
            if (read &lt; length) {
                data.skipBytes(length - read);
            }
        }

        if (bih.biCompression == BitmapInfoHeader.BI_BITFIELDS) {
            parseBitfields();
        } else if (bih.biCompression == BitmapInfoHeader.BI_RGB &amp;&amp;
                bih.biBitCount == 16)
        {
            bitMasks = new int[] { 0x7C00, 0x3E0, 0x1F };
            bitOffsets = new int[] { 10, 5, 0 };
        }
    }

    private void parseBitfields() throws IOException {
        if (bgra_palette.length != 12) {
            throw new IOException(&quot;Invalid bit masks&quot;);
        }
        bitMasks = new int[3];
        bitOffsets = new int[3];
        for (int i = 0; i &lt; 3; i++) {
            int mask = getDWord(bgra_palette, i * 4);
            bitMasks[i] = mask;
            int offset = 0;
            if (mask != 0) {
                while ((mask &amp; 1) == 0) {
                    offset++;
                    mask = mask &gt;&gt;&gt; 1;
                }
                if (!isPow2Minus1(mask)) {
                    throw new IOException(&quot;Bit mask is not contiguous&quot;);
                }
            }
            bitOffsets[i] = offset;
        }
        if (!checkDisjointMasks(bitMasks[0], bitMasks[1], bitMasks[2])) {
            throw new IOException(&quot;Bit masks overlap&quot;);
        }
    }

    static boolean checkDisjointMasks(int m1, int m2, int m3) {
        return ((m1 &amp; m2) | (m1 &amp; m3) | (m2 &amp; m3)) == 0;
    }

    static boolean isPow2Minus1(int i) {
        return (i &amp; (i + 1)) == 0;
    }

    @Override
    public void dispose() {
    }

    private void readRLE(byte[] image, int rowLength, int hght, boolean isRLE4)
            throws IOException
    {
        int imgSize = bih.biSizeImage;
        if (imgSize == 0) {
            imgSize = bfSize - bfOffBits;
        }
        byte imgData[] = new byte[imgSize];
        ImageTools.readFully(data.in, imgData);

        boolean isBottomUp = bih.biHeight &gt; 0;
        int line = isBottomUp ? hght - 1 : 0;
        int i = 0;
        int dstOffset = line * rowLength;
        while (i &lt; imgSize) {
            int b1 = getByte(imgData, i++);
            int b2 = getByte(imgData, i++);
            if (b1 == 0) { // absolute
                switch (b2) {
                    case 0: // end of line
                        line += isBottomUp ? -1 : 1;
                        dstOffset = line * rowLength;
                        break;
                    case 1: // end of bitmap
                        return;
                    case 2: // delta
                        int deltaX = getByte(imgData, i++);
                        int deltaY = getByte(imgData, i++);
                        line += deltaY;
                        dstOffset += (deltaY * rowLength);
                        dstOffset += deltaX * 3;
                        break;
                    default:
                        int indexData = 0;
                        int index;
                        for (int p = 0; p &lt; b2; p++) {
                            if (isRLE4) {
                                if ((p &amp; 1) == 0) {
                                    indexData = getByte(imgData, i++);
                                    index = (indexData &amp; 0xf0) &gt;&gt; 4;
                                } else {
                                    index = indexData &amp; 0x0f;
                                }
                            } else {
                                index = getByte(imgData, i++);
                            }
                            dstOffset = setRGBFromPalette(image, dstOffset, index);
                        }
                        if (isRLE4) {
                            if ((b2 &amp; 3) == 1 || (b2 &amp; 3) == 2) i++;
                        } else {
                            if ((b2 &amp; 1) == 1) i++;
                        }
                        break;
                }
            } else { // encoded
                if (isRLE4) {
                    int index1 = (b2 &amp; 0xf0) &gt;&gt; 4;
                    int index2 = b2 &amp; 0x0f;
                    for (int p = 0; p &lt; b1; p++) {
                        dstOffset = setRGBFromPalette(image, dstOffset,
                                (p &amp; 1) == 0 ? index1 : index2);
                    }
                } else {
                    for (int p = 0; p &lt; b1; p++) {
                        dstOffset = setRGBFromPalette(image, dstOffset, b2);
                    }
                }
            }
        }

    }

    private int setRGBFromPalette(byte[] image, int dstOffset, int index) {
        index *= 4;
        image[dstOffset++] = bgra_palette[index + 2];
        image[dstOffset++] = bgra_palette[index + 1];
        image[dstOffset++] = bgra_palette[index];
        return dstOffset;
    }

    private void readPackedBits(byte[] image, int rowLength, int hght)
            throws IOException
    {
        int pixPerByte = 8 / bih.biBitCount;
        int bytesPerLine = (bih.biWidth + pixPerByte - 1) / pixPerByte;
        int srcStride = (bytesPerLine + 3) &amp; ~3;
        int bitMask = (1 &lt;&lt; bih.biBitCount) - 1;

        byte lineBuf[] = new byte[srcStride];
        for (int i = 0; i != hght; ++i) {
            ImageTools.readFully(data.in, lineBuf);
            int line = bih.biHeight &lt; 0 ? i : hght - i - 1;
            int dstOffset = line * rowLength;

            for (int x = 0; x != bih.biWidth; x++) {
                int bitnum = x * bih.biBitCount;
                int element = lineBuf[bitnum / 8];
                int shift = 8 - (bitnum &amp; 7) - bih.biBitCount;
                int index = (element &gt;&gt; shift) &amp; bitMask;
                dstOffset = setRGBFromPalette(image, dstOffset, index);
            }
        }
    }

    private static int getDWord(byte[] buf, int pos) {
        return ((buf[pos    ] &amp; 0xff)     ) |
               ((buf[pos + 1] &amp; 0xff) &lt;&lt; 8) |
               ((buf[pos + 2] &amp; 0xff) &lt;&lt; 16) |
               ((buf[pos + 3] &amp; 0xff) &lt;&lt; 24);
    }

    private static int getWord(byte[] buf, int pos) {
        return ((buf[pos    ] &amp; 0xff)     ) |
               ((buf[pos + 1] &amp; 0xff) &lt;&lt; 8);
    }

    private static int getByte(byte[] buf, int pos) {
        return buf[pos] &amp; 0xff;
    }

    @FunctionalInterface
    private interface BitConverter {
        public byte convert(int i, int mask, int offset);
    }

    private static byte convertFrom5To8Bit(int i, int mask, int offset) {
        int b = (i &amp; mask) &gt;&gt;&gt; offset;
        return (byte)(b &lt;&lt; 3 | b &gt;&gt; 2);
    }

    private static byte convertFromXTo8Bit(int i, int mask, int offset) {
        int b = (i &amp; mask) &gt;&gt;&gt; offset;
        return (byte)(b * 255.0 / (mask &gt;&gt;&gt; offset));
    }

    private void read16Bit(byte[] image, int rowLength, int hght, BitConverter converter)
            throws IOException
    {
        int bytesPerLine = bih.biWidth * 2;
        int srcStride = (bytesPerLine + 3) &amp; ~3;
        byte lineBuf[] = new byte[srcStride];
        for (int i = 0; i != hght; ++i) {
            ImageTools.readFully(data.in, lineBuf);
            int line = bih.biHeight &lt; 0 ? i : hght - i - 1;
            int dstOffset = line * rowLength;

            for (int x = 0; x != bih.biWidth; x++) {
                int element = getWord(lineBuf, x * 2);
                for (int j = 0; j &lt; 3; j++) {
                    image[dstOffset++] =
                            converter.convert(element, bitMasks[j], bitOffsets[j]);
                }
            }
        }
    }

    private void read32BitRGB(byte[] image, int rowLength, int hght) throws IOException {
        int bytesPerLine = bih.biWidth * 4;
        byte lineBuf[] = new byte[bytesPerLine];
        for (int i = 0; i != hght; ++i) {
            ImageTools.readFully(data.in, lineBuf);
            int line = bih.biHeight &lt; 0 ? i : hght - i - 1;
            int dstOff = line * rowLength;

            for (int x = 0; x != bih.biWidth; x++) {
                int srcOff = x * 4;
                image[dstOff++] = lineBuf[srcOff + 2];
                image[dstOff++] = lineBuf[srcOff + 1];
                image[dstOff++] = lineBuf[srcOff    ];
            }
        }
    }

    private void read32BitBF(byte[] image, int rowLength, int hght) throws IOException {
        int bytesPerLine = bih.biWidth * 4;
        byte lineBuf[] = new byte[bytesPerLine];
        for (int i = 0; i != hght; ++i) {
            ImageTools.readFully(data.in, lineBuf);
            int line = bih.biHeight &lt; 0 ? i : hght - i - 1;
            int dstOff = line * rowLength;

            for (int x = 0; x != bih.biWidth; x++) {
                int srcOff = x * 4;
                int element = getDWord(lineBuf, srcOff);
                for (int j = 0; j &lt; 3; j++) {
                    image[dstOff++] =
                            convertFromXTo8Bit(element, bitMasks[j], bitOffsets[j]);
                }
            }
        }
    }

    private void read24Bit(byte[] image, int rowLength, int hght) throws IOException {
        int bmpStride = (rowLength + 3) &amp; ~3;
        int padding = bmpStride - rowLength;

        for (int i = 0; i != hght; ++i) {
            int line = bih.biHeight &lt; 0 ? i : hght - i - 1;
            int lineOffset = line * rowLength;
            ImageTools.readFully(data.in, image, lineOffset, rowLength);
            data.skipBytes(padding);
            BGRtoRGB(image, lineOffset, rowLength);
        }
    }

    static void BGRtoRGB(byte data[], int pos, int size) {
        for (int sz = size / 3; sz != 0; --sz) {
            byte b = data[pos], r = data[pos + 2];
            data[pos + 2] = b; data[pos] = r;
            pos += 3;
        }
    }

    public ImageFrame load(int imageIndex, int width, int height,
            boolean preserveAspectRatio, boolean smooth) throws IOException
    {
        if (0 != imageIndex) {
            return null;
        }

        int hght = Math.abs(bih.biHeight);

        int[] outWH = ImageTools.computeDimensions(bih.biWidth, hght, width, height, preserveAspectRatio);
        width = outWH[0];
        height = outWH[1];

        // Pass image metadata to any listeners.
        ImageMetadata imageMetadata = new ImageMetadata(null, Boolean.TRUE,
            null, null, null, null, null, width, height,
            null, null, null);
        updateImageMetadata(imageMetadata);

        int bpp = 3;
        int stride = bih.biWidth * bpp;

        byte image[] = new byte[stride * hght];

        switch (bih.biBitCount) {
            case 1:
                readPackedBits(image, stride, hght);
                break;
            case 4:
                if (bih.biCompression == BitmapInfoHeader.BI_RLE4) {
                    readRLE(image, stride, hght, true);
                } else {
                    readPackedBits(image, stride, hght);
                }
                break;
            case 8:
                if (bih.biCompression == BitmapInfoHeader.BI_RLE8) {
                    readRLE(image, stride, hght, false);
                } else {
                    readPackedBits(image, stride, hght);
                }
                break;
            case 16:
                if (bih.biCompression == BitmapInfoHeader.BI_BITFIELDS) {
                    read16Bit(image, stride, hght, BMPImageLoader::convertFromXTo8Bit);
                } else {
                    read16Bit(image, stride, hght, BMPImageLoader::convertFrom5To8Bit);
                }
                break;
            case 32:
                if (bih.biCompression == BitmapInfoHeader.BI_BITFIELDS) {
                    read32BitBF(image, stride, hght);
                } else {
                    read32BitRGB(image, stride, hght);
                }
                break;
            case 24:
                read24Bit(image, stride, hght);
                break;
            default:
                throw new IOException(&quot;Unknown BMP bit depth&quot;);
        }

        ByteBuffer img = ByteBuffer.wrap(image);
        if (bih.biWidth != width || hght != height) {
            img = ImageTools.scaleImage(img, bih.biWidth, hght, bpp,
                    width, height, smooth);
        }

        return new ImageFrame(ImageStorage.ImageType.RGB, img,
                width, height, width * bpp, null, imageMetadata);
    }
}

public final class BMPImageLoaderFactory implements ImageLoaderFactory {

    private static final BMPImageLoaderFactory theInstance =
            new BMPImageLoaderFactory();

    public static ImageLoaderFactory getInstance() {
        return theInstance;
    }

    public ImageFormatDescription getFormatDescription() {
        return BMPDescriptor.theInstance;
    }

    public ImageLoader createImageLoader(InputStream input) throws IOException {
        return new BMPImageLoader(input);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/iio/gif/GIFImageLoader2.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.iio.gif;

import com.sun.javafx.iio.ImageFrame;
import com.sun.javafx.iio.ImageMetadata;
import com.sun.javafx.iio.ImageStorage;
<A NAME="35"></A>import com.sun.javafx.iio.common.ImageLoaderImpl;
import com.sun.javafx.iio.common.ImageTools;
import java.io.EOFException;
<FONT color="#41a317"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#35',2,'match46-top.html#35',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.util.Arrays;

/*
 * loader implementation for GIF89 file format
 */

public class GIFImageLoader2 extends ImageLoaderImpl {

    static final byte FILE_SIG87[] = {'G', 'I', 'F', '8', '7', 'a'};
    static final byte FILE_SIG89[] = {'G', 'I', 'F', '8', '9', 'a'};
    static final byte NETSCAPE_SIG[] = {'N', 'E', 'T', 'S', 'C', 'A', 'P', 'E', '2', '.', '0'}</B></FONT>;
    static final int DEFAULT_FPS = 25;

    InputStream stream = null;
    int screenW, screenH, bgColor;
    byte globalPalette[][];  // r,g,b,a
    byte image[];
    int loopCount = 1;

    public GIFImageLoader2(InputStream input) throws IOException {
        super(GIFDescriptor.getInstance());
        this.stream = input;
        readGlobalHeader();
    }

    // read GIF file header
    private void readGlobalHeader() throws IOException {
        byte signature[] = readBytes(new byte[6]);
        if (!Arrays.equals(FILE_SIG87, signature) &amp;&amp; !Arrays.equals(FILE_SIG89, signature)) {
            throw new IOException(&quot;Bad GIF signature!&quot;);
        }
        screenW = readShort();
        screenH = readShort();
        int cInfo = readByte();
        bgColor = readByte();
        int aspectR = readByte();

        if ((cInfo &amp; 0x80) != 0) {
            globalPalette = readPalete(2 &lt;&lt; (cInfo &amp; 7), -1);
        }
        image = new byte[screenW * screenH * 4];
    }

    // read palette data from the stream
    private byte[][] readPalete(int size, int trnsIndex) throws IOException {
        byte palette[][] = new byte[4][size];
        byte paletteData[] = readBytes(new byte[size*3]);
        for (int i = 0, idx = 0; i != size; ++i) {
            for (int k = 0; k != 3; ++k) {
                palette[k][i] = paletteData[idx++];
            }
            palette[3][i] = (i == trnsIndex) ? 0 : (byte)0xFF;
        }
        return palette;
    }

    // skip an extension
    private void consumeAnExtension() throws IOException {
        for (int blSize = readByte(); blSize != 0; blSize = readByte()) {
            skipBytes(blSize);
        }
    }

    private void readAppExtension() throws IOException {
        int size = readByte();
        byte buf[] = readBytes(new byte[size]);
        if (Arrays.equals(NETSCAPE_SIG, buf)) {
            for (int subBlockSize = readByte(); subBlockSize != 0; subBlockSize = readByte()) {
                byte subBlock[] = readBytes(new byte[subBlockSize]);
                int subBlockId = subBlock[0];
                if (subBlockSize == 3 &amp;&amp; subBlockId == 1) { // loop count extension
                    loopCount = (subBlock[1] &amp; 0xff) | ((subBlock[2] &amp; 0xff) &lt;&lt; 8);
                }
            }
        } else {
            consumeAnExtension(); // read data sub-blocks
        }
    }

    // reads Image Control extension information
    // returns ((pField &amp; 0x1F) &lt;&lt; 24) + (trnsIndex &lt;&lt; 16) + frameDelay;
    private int readControlCode() throws IOException {
        int size = readByte();
        int pField = readByte();
        int frameDelay = readShort();
        int trnsIndex = readByte();

        if (size != 4 || readByte() != 0) {
            throw new IOException(&quot;Bad GIF GraphicControlExtension&quot;);
        }
        return ((pField &amp; 0x1F) &lt;&lt; 24) + (trnsIndex &lt;&lt; 16) + frameDelay;
    }

    // The method waits until image data in the stream
    // The method also reads and return Image Control extension information
    // returns -1 if EOF reached or the value of readControlCode
    private int waitForImageFrame() throws IOException {
        int controlData = 0;
        while (true) {
            int ch = stream.read();
            switch (ch) {
                case 0x2C:
                    return controlData;
                case 0x21:
                    switch (readByte()) {
                        case 0xF9:
                            controlData = readControlCode();
                            break;
                        case 0xFF:
                            readAppExtension();
                            break;
                        default:
                            consumeAnExtension();
                    }
                    break;
                case -1: case 0x3B: // EOF or end of GIF
                    return -1;
                default:
                    throw new IOException(&quot;Unexpected GIF control characher 0x&quot;
                            + String.format(&quot;%02X&quot;, ch));
            }
        }
    }

    // Decode the one frame of GIF form the input stread using internal LZWDecoder class
    private void decodeImage(byte image[], int w, int h, int interlace[]) throws IOException {
        LZWDecoder dec = new LZWDecoder();
        byte data[] = dec.getString();
        int y = 0, iPos = 0, xr = w;
        while (true) {
            int len = dec.readString();
            if (len == -1) { // end of stream
                dec.waitForTerminator();
                return;
            }
            for (int pos = 0; pos != len;) {
                int ax = xr &lt; (len - pos) ? xr : (len - pos);
                System.arraycopy(data, pos, image, iPos, ax);
                iPos += ax;
                pos += ax;
                if ((xr -= ax) == 0) {
                    if (++y == h) { // image is full
                        dec.waitForTerminator();
                        return;
                    }
                    int iY = interlace == null ? y : interlace[y];
                    iPos = iY * w;
                    xr = w;
                }
            }
        }
    }

    // computes row re-index for interlaced case
    private int[] computeInterlaceReIndex(int h) {
        int data[] = new int[h], pos = 0;
        for (int i = 0; i &lt; h; i += 8) data[pos++] = i;
        for (int i = 4; i &lt; h; i += 8) data[pos++] = i;
        for (int i = 2; i &lt; h; i += 4) data[pos++] = i;
        for (int i = 1; i &lt; h; i += 2) data[pos++] = i;
        return data;
    }

    // loads next image frame or null if no more
    public ImageFrame load(int imageIndex, int width, int height, boolean preserveAspectRatio, boolean smooth) throws IOException {
        int imageControlCode = waitForImageFrame();

        if (imageControlCode &lt; 0) {
            return null;
        }

        int left = readShort(), top = readShort(), w = readShort(), h = readShort();

        // check if the image is in the virtual screen boundaries
        if (left + w &gt; screenW || top + h &gt; screenH) {
            throw new IOException(&quot;Wrong GIF image frame size&quot;);
        }

        int imgCtrl = readByte();

        boolean isTRNS = ((imageControlCode &gt;&gt;&gt; 24) &amp; 1) == 1;
        int trnsIndex = isTRNS ? (imageControlCode &gt;&gt;&gt; 16) &amp; 0xFF : -1;
        boolean localPalette = (imgCtrl &amp; 0x80) != 0;
        boolean isInterlaced = (imgCtrl &amp; 0x40) != 0;

        byte palette[][] = localPalette ? readPalete(2 &lt;&lt; (imgCtrl &amp; 7), trnsIndex) : globalPalette;

        int[] outWH = ImageTools.computeDimensions(screenW, screenH, width, height, preserveAspectRatio);
        width = outWH[0];
        height = outWH[1];

        ImageMetadata metadata = updateMetadata(width, height, imageControlCode &amp; 0xFFFF);

        int disposalCode = (imageControlCode &gt;&gt;&gt; 26) &amp; 7;
        byte pImage[] = new byte[w * h];
        decodeImage(pImage, w, h, isInterlaced ? computeInterlaceReIndex(h) : null);

        ByteBuffer img = decodePalette(pImage, palette, trnsIndex,
                left, top, w, h, disposalCode);

        if (screenW != width || screenH != height) {
            img = ImageTools.scaleImage(img, screenW, screenH, 4,
                    width, height, smooth);
        }

        return new ImageFrame(ImageStorage.ImageType.RGBA, img,
                width, height, width * 4, null, metadata);
    }

    // IO helpers
    private int readByte() throws IOException {
        int ch = stream.read();
        if (ch &lt; 0) {
            throw new EOFException();
        }
        return ch;
    }

    private int readShort() throws IOException {
        int lsb = readByte(), msb = readByte();
        return lsb + (msb &lt;&lt; 8);
    }

    private byte[] readBytes(byte data[]) throws IOException {
        return readBytes(data, 0, data.length);
    }

    private byte[] readBytes(byte data[], int offs, int size) throws IOException {
        while (size &gt; 0) {
            int sz = stream.read(data, offs, size);
            if (sz &lt; 0) {
                throw new EOFException();
            }
            offs += sz;
            size -= sz;
        }
        return data;
    }

    private void skipBytes(int n) throws IOException {
        ImageTools.skipFully(stream, n);
    }

    public void dispose() {}

    // GIF specification states that restore to background should fill the frame
    // with background color, but actually all modern programs fill with transparent color.
    private void restoreToBackground(byte img[], int left, int top, int w, int h) {
        for (int y = 0; y != h; ++y) {
            int iPos = ((top + y) * screenW + left) * 4;
            for (int x = 0; x != w; iPos += 4, ++x) {
                img[iPos + 3] = 0;
            }
        }
    }

    // decode palletized image into RGBA
    private ByteBuffer decodePalette(byte[] srcImage, byte[][] palette, int trnsIndex,
            int left, int top, int w, int h, int disposalCode) {

        byte img[] = (disposalCode == 3) ? image.clone() : image;

        for (int y = 0; y != h; ++y) {
            int iPos = ((top + y) * screenW + left) * 4;
            int i = y * w;
            if (trnsIndex &lt; 0) {
                for (int x = 0; x != w; iPos += 4, ++x) {
                    int index = 0xFF &amp; srcImage[i + x];
                    img[iPos + 0] = palette[0][index];
                    img[iPos + 1] = palette[1][index];
                    img[iPos + 2] = palette[2][index];
                    img[iPos + 3] = palette[3][index];
                }
            } else {
                for (int x = 0; x != w; iPos += 4, ++x) {
                    int index = 0xFF &amp; srcImage[i + x];
                    if (index != trnsIndex) {
                        img[iPos + 0] = palette[0][index];
                        img[iPos + 1] = palette[1][index];
                        img[iPos + 2] = palette[2][index];
                        img[iPos + 3] = palette[3][index];
                    }
                }
            }
        }

        if (disposalCode != 3) img = img.clone();
        if (disposalCode == 2) restoreToBackground(image, left, top, w, h);

        return ByteBuffer.wrap(img);
    }

    // fill metadata
    private ImageMetadata updateMetadata(int w, int h, int delayTime) {
        ImageMetadata metaData = new ImageMetadata(null, true, null, null, null,
                delayTime != 0 ? delayTime*10 : 1000/DEFAULT_FPS, loopCount, w, h, null, null, null);
        updateImageMetadata(metaData);
        return metaData;
    }

    class LZWDecoder {
        private final int initCodeSize, clearCode, eofCode;
        private int codeSize, codeMask, tableIndex, oldCode;

        // input data buffer
        private int blockLength = 0, blockPos = 0;
        private byte block[] = new byte[255];
        private int inData = 0, inBits = 0;

        // table
        private int[] prefix = new int[4096];
        private byte[] suffix = new byte[4096];
        private byte[] initial = new byte[4096];
        private int[] length = new int[4096];
        private byte[] string = new byte[4096];

        public LZWDecoder() throws IOException {
            initCodeSize = readByte();
            clearCode = 1 &lt;&lt; initCodeSize;
            eofCode = clearCode + 1;
            initTable();
        }

        // decode next string of data, which can be accessed by getString() method
        public final int readString() throws IOException {
            int code = getCode();
            if (code == eofCode) {
                return -1;
            } else if (code == clearCode) {
                initTable();
                code = getCode();
                if (code == eofCode) {
                    return -1;
                }
            } else {
                int newSuffixIndex;
                int ti = tableIndex;
                if (code &lt; ti) {
                    newSuffixIndex = code;
                } else { // code == tableIndex
                    newSuffixIndex = oldCode;
                    if (code != ti) {
                        throw new IOException(&quot;Bad GIF LZW: Out-of-sequence code!&quot;);
                    }
                }

                int oc = oldCode;

                prefix[ti] = oc;
                suffix[ti] = initial[newSuffixIndex];
                initial[ti] = initial[oc];
                length[ti] = length[oc] + 1;

                ++tableIndex;
                if ((tableIndex == (1 &lt;&lt; codeSize)) &amp;&amp; (tableIndex &lt; 4096)) {
                    ++codeSize;
                    codeMask = (1 &lt;&lt; codeSize) - 1;
                }
            }
            // Reverse code
            int c = code;
            int len = length[c];
            for (int i = len - 1; i &gt;= 0; i--) {
                string[i] = suffix[c];
                c = prefix[c];
            }

            oldCode = code;
            return len;
        }

        // data accessor, the data length returned by readString method
        public final byte[] getString() { return string; }

        // waits until data ends
        public final void waitForTerminator() throws IOException {
            consumeAnExtension();
        }

        // initialize LZW dctionary
        private void initTable() {
            int numEntries = 1 &lt;&lt; initCodeSize;
            for (int i = 0; i &lt; numEntries; i++) {
                prefix[i] = -1;
                suffix[i] = (byte) i;
                initial[i] = (byte) i;
                length[i] = 1;
            }

            // fill in the entire table for robustness against
            // out-of-sequence codes.
            for (int i = numEntries; i &lt; 4096; i++) {
                prefix[i] = -1;
                length[i] = 1;
            }

            codeSize = initCodeSize + 1;
            codeMask = (1 &lt;&lt; codeSize) - 1;
            tableIndex = numEntries + 2;
            oldCode = 0;
        }

        // reads codeSize bits from the stream
        private int getCode()  throws IOException  {
            while (inBits &lt; codeSize) {
                inData |= nextByte() &lt;&lt; inBits;
                inBits += 8;
            }
            int code = inData &amp; codeMask;
            inBits -= codeSize;
            inData &gt;&gt;&gt;= codeSize;
            return code;
        }

        // reads next in byte
        private int nextByte() throws IOException {
            if (blockPos == blockLength) {
                readData();
            }
            return (int)block[blockPos++] &amp; 0xFF;
        }

        // reads next block if data
        private void readData() throws IOException {
            blockPos = 0;
            blockLength = readByte();
            if (blockLength &gt; 0) {
                readBytes(block, 0, blockLength);
            } else {
                throw new EOFException();
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/iio/ios/IosImageLoader.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.iio.ios;

import com.sun.glass.utils.NativeLibLoader;
import com.sun.javafx.iio.common.*;
import com.sun.javafx.iio.ImageFrame;
import com.sun.javafx.iio.ImageMetadata;
import com.sun.javafx.iio.ImageStorage.ImageType;
import com.sun.javafx.iio.common.ImageLoaderImpl;
import com.sun.javafx.iio.common.ImageTools;

import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.security.AccessController;
import java.security.PrivilegedAction;

import java.util.Map;
import java.util.HashMap;

import java.net.URL;
import java.net.MalformedURLException;

/**
 * A loader for images on iOS platform.
 */
public class IosImageLoader extends ImageLoaderImpl {

    /** These constants must match with those in native */
    public static final int GRAY = 0;
    public static final int GRAY_ALPHA = 1;
    public static final int GRAY_ALPHA_PRE = 2;
    public static final int PALETTE = 3;
    public static final int PALETTE_ALPHA = 4;
    public static final int PALETTE_ALPHA_PRE = 5;
<A NAME="36"></A>    public static final int PALETTE_TRANS = 6;
    public static final int RGB = 7;
    public static final int RGBA = 8;
    <FONT color="#ff00ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#36',2,'match46-top.html#36',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>public static final int RGBA_PRE = 9;

    private static final Map&lt;Integer, ImageType&gt; colorSpaceMapping = new HashMap&lt;Integer, ImageType&gt;();

    /** Pointer to the native loader */
    private long structPointer;

    /** Set by native code */
    private int inWidth;
    private int inHeight;
    private int nImages;

    private boolean isDisposed = false;

    private int delayTime; // applicable to animated images only
    private int loopCount; // applicable to animated images only

    /***************************** Native Loader methods ******************************************/

    /** Set up static method IDs for calls back to Java. */
    private static na</B></FONT>tive void initNativeLoading();

    /** Create a loader and buffer data from the InputStream. Report progress if requested. */
    private native long loadImage(final InputStream stream, boolean reportProgress) throws IOException;

    /** Create a loader for the given URL. Report progress if requested. */
    private native long loadImageFromURL(final String url, boolean reportProgress) throws IOException;

    /** Set native image size */
    private native void resizeImage(long structPointer, int width, int height);

    /** Return a buffer with decompressed image data */
    private native byte[] getImageBuffer(long structPointer, int imageIndex);

    /** Return the number of color components */
    private native int getNumberOfComponents(long structPointer);

    /** Return image color space model code */
    private native int getColorSpaceCode(long structPointer);

    /** Return image duration for animated images */
    private native int getDelayTime(long structPointer);

    /** Destroy a loader. */
    private static native void disposeLoader(long structPointer);

    /*************************** End of Native Loader methods ***************************************/


    static {
        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
            NativeLibLoader.loadLibrary(&quot;nativeiio&quot;);
            return null;
        });

        colorSpaceMapping.put(GRAY, ImageType.GRAY);
        colorSpaceMapping.put(GRAY_ALPHA, ImageType.GRAY_ALPHA);
        colorSpaceMapping.put(GRAY_ALPHA_PRE, ImageType.GRAY_ALPHA_PRE);
        colorSpaceMapping.put(PALETTE, ImageType.PALETTE);
        colorSpaceMapping.put(PALETTE_ALPHA, ImageType.PALETTE_ALPHA);
        colorSpaceMapping.put(PALETTE_ALPHA_PRE, ImageType.PALETTE_ALPHA_PRE);
        colorSpaceMapping.put(PALETTE_TRANS, ImageType.PALETTE_TRANS);
        colorSpaceMapping.put(RGB, ImageType.RGB);
        colorSpaceMapping.put(RGBA, ImageType.RGBA);
        colorSpaceMapping.put(RGBA_PRE, ImageType.RGBA_PRE);

        initNativeLoading();
    }

    /** Called by the native code when input parameters are known. */
    private void setInputParameters(
            int width,
            int height,
            int imageCount,
            int loopCount) {

        inWidth = width;
        inHeight = height;
        nImages = imageCount;
        this.loopCount = loopCount;
    }

    private void updateProgress(float progressPercentage) {
        updateImageProgress(progressPercentage);
    }

    private boolean shouldReportProgress() {
        return listeners != null &amp;&amp; !listeners.isEmpty();
    }

    private void checkNativePointer() throws IOException {
        if (structPointer == 0L) {
            throw new IOException(&quot;Unable to initialize image native loader!&quot;);
        }
    }

    private void retrieveDelayTime() {
        if (nImages &gt; 1) {
            delayTime = getDelayTime(structPointer);
        }
    }

    public IosImageLoader(final String urlString, final ImageDescriptor desc) throws IOException {
        super(desc);

        // see if the given URL is valid
        try {
            final URL url = new URL(urlString);
        }
        catch (MalformedURLException mue) {
            throw new IllegalArgumentException(&quot;Image loader: Malformed URL!&quot;);
        }

        try {
            structPointer = loadImageFromURL(urlString, shouldReportProgress());
        } catch (IOException e) {
            dispose();
            throw e;
        }

        checkNativePointer();
        retrieveDelayTime();
    }

    public IosImageLoader(final InputStream inputStream, final ImageDescriptor desc) throws IOException {
        super(desc);
        if (inputStream == null) {
            throw new IllegalArgumentException(&quot;Image loader: input stream == null&quot;);
        }

        try {
            structPointer = loadImage(inputStream, shouldReportProgress());
        } catch (IOException e) {
            dispose();
            throw e;
        }

        checkNativePointer();
        retrieveDelayTime();
    }

    /**
     * @inheritDoc
     */
    public synchronized void dispose() {
        if (!isDisposed &amp;&amp; structPointer != 0L) {
            isDisposed = true;
            IosImageLoader.disposeLoader(structPointer);
            structPointer = 0L;
        }
    }

    protected void finalize() {
        dispose();
    }

   /**
    * @inheritDoc
    */
    public ImageFrame load(int imageIndex, int width, int height, boolean preserveAspectRatio, boolean smooth)
            throws IOException {

        if (imageIndex &gt;= nImages) {
            dispose();
            return null;
        }

        // Determine output image dimensions.
        int[] widthHeight = ImageTools.computeDimensions(inWidth, inHeight, width, height, preserveAspectRatio);
        width = widthHeight[0];
        height = widthHeight[1];

        final ImageMetadata md = new ImageMetadata(
                null, // gamma
                true, // whether smaller values represent darker shades
                null, // a palette index to use as background
                null, // background color
                null, // a palette index to be used as transparency
                delayTime == 0 ? null : delayTime, // the amount of time to pause at the current image (milliseconds).
                nImages &gt; 1 ? loopCount : null, // number of loops
                width, // image width
                height, // image height
                null, // image left offset
                null, // image top offset
                null); // disposal method

        updateImageMetadata(md);

        resizeImage(structPointer, width, height);

        // the color model and the number of components can change when resizing
        final int nComponents = getNumberOfComponents(structPointer);
        final int colorSpaceCode = getColorSpaceCode(structPointer);
        final ImageType imageType = colorSpaceMapping.get(colorSpaceCode);

        final byte[] pixels = getImageBuffer(structPointer, imageIndex);

        return new ImageFrame(imageType,
                ByteBuffer.wrap(pixels),
                width,
                height,
                width * nComponents,
                null,
                md);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/scene/traversal/Hueristic2D.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.traversal;

import java.util.List;
import java.util.Stack;
import javafx.geometry.BoundingBox;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.scene.Node;

import static com.sun.javafx.scene.traversal.Direction.*;
import java.util.function.Function;


public class Hueristic2D implements Algorithm {

    Hueristic2D() {
    }

    @Override
    public Node select(Node node, Direction dir, TraversalContext context) {
        Node newNode = null;

        cacheTraversal(node, dir);

        if (NEXT.equals(dir) || NEXT_IN_LINE.equals(dir)) {
            newNode = TabOrderHelper.findNextFocusablePeer(node, context.getRoot(), dir == NEXT);
        }
        else if (PREVIOUS.equals(dir)) {
            newNode = TabOrderHelper.findPreviousFocusablePeer(node, context.getRoot());
        }
        else if (UP.equals(dir) || DOWN.equals(dir) || LEFT.equals(dir) || RIGHT.equals(dir) ) {
            /*
            ** if there is a node top of stack then make sure it's traversable
            */
            if (reverseDirection == true &amp;&amp; !traversalNodeStack.empty()) {
                if (!traversalNodeStack.peek().isFocusTraversable()) {
                    traversalNodeStack.clear();
                }
                else {
                    newNode = traversalNodeStack.pop();
                }
            }

            if (newNode == null) {
                Bounds currentB = node.localToScene(node.getLayoutBounds());
                if (cacheStartTraversalNode != null) {
                    Bounds cachedB = cacheStartTraversalNode.localToScene(cacheStartTraversalNode.getLayoutBounds());
                    switch (dir) {
                        case UP:
                        case DOWN:
                            newNode = getNearestNodeUpOrDown(currentB, cachedB, context, dir);
                            break;
                        case LEFT:
                        case RIGHT:
                            newNode = getNearestNodeLeftOrRight(currentB, cachedB, context, dir);
                            break;
                        default:
                            break;
                    }
                }
            }
        }

        /*
        ** newNode will be null if there are no
        ** possible targets in the direction.
        ** don't cache null, there's no coming back from that!
        */
        if (newNode != null) {
            cacheLastTraversalNode = newNode;
            if (reverseDirection == false) {
                traversalNodeStack.push(node);
            }
        }
        return newNode;
    }

    @Override
    public Node selectFirst(TraversalContext context) {
        return TabOrderHelper.getFirstTargetNode(context.getRoot());
    }

    @Override
    public Node selectLast(TraversalContext context) {
        return TabOrderHelper.getLastTargetNode(context.getRoot());
    }

    private boolean isOnAxis(Direction dir, Bounds cur, Bounds tgt) {

        final double cmin, cmax, tmin, tmax;

        if (dir == UP || dir == DOWN) {
            cmin = cur.getMinX();
            cmax = cur.getMaxX();
            tmin = tgt.getMinX();
            tmax = tgt.getMaxX();
        }
        else { // dir == LEFT || dir == RIGHT
            cmin = cur.getMinY();
            cmax = cur.getMaxY();
            tmin = tgt.getMinY();
            tmax = tgt.getMaxY();
        }

        return tmin &lt;= cmax &amp;&amp; tmax &gt;= cmin;
    }

    /**
     * Compute the out-distance to the near edge of the target in the
     * traversal direction. Negative means the near edge is &quot;behind&quot;.
     */
    private double outDistance(Direction dir, Bounds cur, Bounds tgt) {

        final double distance;
        if (dir == UP) {
            distance = cur.getMinY() - tgt.getMaxY();
        }
        else if (dir == DOWN) {
            distance = tgt.getMinY() - cur.getMaxY();
        }
        else if (dir == LEFT) {
            distance = cur.getMinX() - tgt.getMaxX();
        }
        else { // dir == RIGHT
            distance = tgt.getMinX() - cur.getMaxX();
        }
        return distance;
    }

    /**
     * Computes the side distance from current center to target center.
     * Always positive. This is only used for on-axis nodes.
     */
    private double centerSideDistance(Direction dir, Bounds cur, Bounds tgt) {
        final double cc; // current center
        final double tc; // target center

        if (dir == UP || dir == DOWN) {
            cc = cur.getMinX() + cur.getWidth() / 2.0f;
            tc = tgt.getMinX() + tgt.getWidth() / 2.0f;
        }
        else { // dir == LEFT || dir == RIGHT
            cc = cur.getMinY() + cur.getHeight() / 2.0f;
            tc = tgt.getMinY() + tgt.getHeight() / 2.0f;
        }
        return Math.abs(tc - cc);
    }

    /**
     * Computes the side distance between the closest corners of the current
     * and target. Always positive. This is only used for off-axis nodes.
     */
    private double cornerSideDistance(Direction dir, Bounds cur, Bounds tgt) {

        final double distance;

        if (dir == UP || dir == DOWN) {
            if (tgt.getMinX() &gt; cur.getMaxX()) {
                // on the right
                distance = tgt.getMinX() - cur.getMaxX();
            }
            else {
                // on the left
                distance = cur.getMinX() - tgt.getMaxX();
            }
        }
        else { // dir == LEFT or dir == RIGHT

            if (tgt.getMinY() &gt; cur.getMaxY()) {
                // below
                distance = tgt.getMinY() - cur.getMaxY();
            }
            else {
                // above
                distance = cur.getMinY() - tgt.getMaxY();
            }
        }
        return distance;
    }

    protected Node cacheStartTraversalNode = null;
    protected Direction cacheStartTraversalDirection = null;
    protected boolean reverseDirection = false;
    protected Node cacheLastTraversalNode = null;
    protected Stack&lt;Node&gt; traversalNodeStack = new Stack();

    private void cacheTraversal(Node node, Direction dir) {
        if (!traversalNodeStack.empty() &amp;&amp; node != cacheLastTraversalNode) {
            /*
            ** we didn't get here by arrow key,
            ** dump the cache
            */
            traversalNodeStack.clear();
        }
<A NAME="40"></A>        /*
        ** Next or Previous cancels the row caching
        */
        <FONT color="#347235"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#40',2,'match46-top.html#40',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (dir == Direction.NEXT || dir == Direction.PREVIOUS) {
            traversalNodeStack.clear();
            reverseDirection = false;
        } else {
            if (cacheStartTraversalNode == null || dir != cacheStartTraversalDirection) {</B></FONT>

                if ((dir == UP &amp;&amp; cacheStartTraversalDirection == DOWN) ||
                    (dir == DOWN &amp;&amp; cacheStartTraversalDirection == UP) ||
                    (dir == LEFT &amp;&amp; cacheStartTraversalDirection == RIGHT) ||
                    (dir == RIGHT &amp;&amp; cacheStartTraversalDirection == LEFT) &amp;&amp; !traversalNodeStack.empty()) {
                    reverseDirection = true;
                } else {
                    /*
                     ** if we don't have a row set, or the direction has changed, then
                    ** make the current node the row.
                    ** otherwise we are moving in the same direction as last time, so
                    ** we'll just leave it alone.
                    */
                    cacheStartTraversalNode = node;
                    cacheStartTraversalDirection = dir;
                    reverseDirection = false;
                    traversalNodeStack.clear();
                }
            } else {
                /*
                ** we're going this way again!
                */
                reverseDirection = false;
            }
        }
    }

    private static final Function&lt;Bounds, Double&gt; BOUNDS_TOP_SIDE = t -&gt; t.getMinY();

    private static final Function&lt;Bounds, Double&gt; BOUNDS_BOTTOM_SIDE = t -&gt; t.getMaxY();

    protected Node getNearestNodeUpOrDown(Bounds currentB, Bounds originB, TraversalContext context, Direction dir) {

        List&lt;Node&gt; nodes = context.getAllTargetNodes();

        Function&lt;Bounds, Double&gt; ySideInDirection = dir == DOWN ? BOUNDS_BOTTOM_SIDE : BOUNDS_TOP_SIDE;
        Function&lt;Bounds, Double&gt; ySideInOpositeDirection = dir == DOWN ? BOUNDS_TOP_SIDE : BOUNDS_BOTTOM_SIDE;

        Bounds biasedB = new BoundingBox(originB.getMinX(), currentB.getMinY(), originB.getWidth(), currentB.getHeight());

        Point2D currentMid2D = new Point2D(currentB.getMinX()+(currentB.getWidth()/2), ySideInDirection.apply(currentB));
        Point2D biasedMid2D = new Point2D(originB.getMinX()+(originB.getWidth()/2), ySideInDirection.apply(currentB));
        Point2D currentLeftCorner2D = new Point2D(currentB.getMinX(),ySideInDirection.apply(currentB));
        Point2D biasedLeftCorner2D = new Point2D(originB.getMinX(),ySideInDirection.apply(currentB));
        Point2D currentRightCorner2D = new Point2D(currentB.getMaxX(), ySideInDirection.apply(currentB));
        Point2D biasedRightCorner2D = new Point2D(originB.getMaxX(), ySideInDirection.apply(currentB));

        Point2D originLeftCorner2D = new Point2D(originB.getMinX(), ySideInDirection.apply(originB));

        TargetNode targetNode = new TargetNode();
        TargetNode nearestNodeCurrentSimple2D = null;
        TargetNode nearestNodeOriginSimple2D = null;
        TargetNode nearestNodeAverage = null;
        TargetNode nearestNodeOnOriginX = null;
        TargetNode nearestNodeOnCurrentX = null;
        TargetNode nearestNodeLeft = null;
        TargetNode nearestNodeAnythingAnywhere = null;

        for (int nodeIndex = 0; nodeIndex &lt; nodes.size(); nodeIndex++) {
            final Node n = nodes.get(nodeIndex);

            Bounds targetBounds = n.localToScene(n.getLayoutBounds());
            /*
             ** check that the target node starts after we
             ** and the target node ends after we end
             */
            if (dir == UP ? (currentB.getMinY() &gt; targetBounds.getMaxY())
                    : currentB.getMaxY() &lt; targetBounds.getMinY()) {

                targetNode.node = n;
                targetNode.bounds = targetBounds;

                /*
                 * closest biased : simple 2d
                 * Negative means the Node is on the same Y axis. This will result in outdB == 0, making this a preferred Node.
                 */
                double outdB = Math.max(0, outDistance(dir, biasedB, targetBounds));

                if (isOnAxis(dir, biasedB, targetBounds)) {
                    targetNode.biased2DMetric = outdB + centerSideDistance(dir, biasedB, targetBounds) / 100;
                } else {
                    final double cosd = cornerSideDistance(dir, biasedB, targetBounds);
                    targetNode.biased2DMetric = 100000 + outdB * outdB + 9 * cosd * cosd;
                }
                /*
                 * closest current : simple 2d
                 * Negative means the Node is on the same Y axis. This will result in outdB == 0, making this a preferred Node.
                 */
                double outdC = Math.max(0, outDistance(dir, currentB, targetBounds));

                if (isOnAxis(dir, currentB, targetBounds)) {
                    targetNode.current2DMetric = outdC + centerSideDistance(dir, currentB, targetBounds) / 100;
                } else {
                    final double cosd = cornerSideDistance(dir, currentB, targetBounds);
                    targetNode.current2DMetric = 100000 + outdC * outdC + 9 * cosd * cosd;
                }

                targetNode.leftCornerDistance = currentLeftCorner2D.distance(targetBounds.getMinX(), ySideInOpositeDirection.apply(targetBounds));
                targetNode.rightCornerDistance = currentRightCorner2D.distance(targetBounds.getMaxX(), ySideInOpositeDirection.apply(targetBounds));

                double midDistance = currentMid2D.distance(targetBounds.getMinX() + (targetBounds.getWidth() / 2), ySideInOpositeDirection.apply(targetBounds));
                double currentLeftToTargetMidDistance = currentLeftCorner2D.distance(targetBounds.getMinX() + (targetBounds.getWidth() / 2), ySideInOpositeDirection.apply(targetBounds));
                double currentLeftToTargetRightDistance = currentLeftCorner2D.distance(targetBounds.getMaxX(), ySideInOpositeDirection.apply(targetBounds));
                double currentRightToTargetLeftDistance = currentRightCorner2D.distance(targetBounds.getMinX(), ySideInOpositeDirection.apply(targetBounds));
                double currentRightToTargetMidDistance = currentRightCorner2D.distance(targetBounds.getMinX() + (targetBounds.getWidth() / 2), ySideInOpositeDirection.apply(targetBounds));
                double currentRightToTargetRightDistance = currentRightCorner2D.distance(targetBounds.getMaxX(), ySideInOpositeDirection.apply(targetBounds));
                double currentMidToTargetLeftDistance = currentMid2D.distance(targetBounds.getMinX(), ySideInOpositeDirection.apply(targetBounds));
                double currentMidToTargetMidDistance = currentMid2D.distance(targetBounds.getMinX() + (targetBounds.getWidth() / 2), ySideInOpositeDirection.apply(targetBounds));
                double currentMidToTargetRightDistance = currentMid2D.distance(targetBounds.getMaxX(), ySideInOpositeDirection.apply(targetBounds));

                double biasLeftToTargetMidDistance = biasedLeftCorner2D.distance(targetBounds.getMinX() + (targetBounds.getWidth() / 2), ySideInOpositeDirection.apply(targetBounds));
                double biasLeftToTargetRightDistance = biasedLeftCorner2D.distance(targetBounds.getMaxX(), ySideInOpositeDirection.apply(targetBounds));
                double biasRightToTargetMidDistance = biasedRightCorner2D.distance(targetBounds.getMinX() + (targetBounds.getWidth() / 2), ySideInOpositeDirection.apply(targetBounds));
                double biasMidToTargetRightDistance = biasedMid2D.distance(targetBounds.getMaxX(), ySideInOpositeDirection.apply(targetBounds));

                targetNode.averageDistance
                        = (targetNode.leftCornerDistance + biasLeftToTargetMidDistance + biasLeftToTargetRightDistance
                        + currentRightToTargetLeftDistance + targetNode.rightCornerDistance + biasRightToTargetMidDistance + midDistance) / 7;

                targetNode.biasShortestDistance
                        = findMin(targetNode.leftCornerDistance, biasLeftToTargetMidDistance, biasLeftToTargetRightDistance,
                                currentRightToTargetLeftDistance, biasRightToTargetMidDistance, targetNode.rightCornerDistance,
                                currentMidToTargetLeftDistance, midDistance, biasMidToTargetRightDistance);

                targetNode.shortestDistance
                        = findMin(targetNode.leftCornerDistance, currentLeftToTargetMidDistance, currentLeftToTargetRightDistance,
                                currentRightToTargetLeftDistance, currentRightToTargetMidDistance, currentRightToTargetRightDistance,
                                currentMidToTargetLeftDistance, currentMidToTargetMidDistance, currentMidToTargetRightDistance);

                /*
                 ** closest biased : simple 2d
                 */
                if (outdB &gt;= 0.0) {
                    if (nearestNodeOriginSimple2D == null || targetNode.biased2DMetric &lt; nearestNodeOriginSimple2D.biased2DMetric) {

                        if (nearestNodeOriginSimple2D == null) {
                            nearestNodeOriginSimple2D = new TargetNode();
                        }
                        nearestNodeOriginSimple2D.copy(targetNode);
                    }
                }
                /*
                 ** closest current : simple 2d
                 */
                if (outdC &gt;= 0.0) {
                    if (nearestNodeCurrentSimple2D == null || targetNode.current2DMetric &lt; nearestNodeCurrentSimple2D.current2DMetric) {

                        if (nearestNodeCurrentSimple2D == null) {
                            nearestNodeCurrentSimple2D = new TargetNode();
                        }
                        nearestNodeCurrentSimple2D.copy(targetNode);
                    }
                }
                /*
                 ** on the Origin X
                 */
                if ((originB.getMaxX() &gt; targetBounds.getMinX()) &amp;&amp; (targetBounds.getMaxX() &gt; originB.getMinX())) {
                    if (nearestNodeOnOriginX == null || nearestNodeOnOriginX.biasShortestDistance &gt; targetNode.biasShortestDistance) {

                        if (nearestNodeOnOriginX == null) {
                            nearestNodeOnOriginX = new TargetNode();
                        }
                        nearestNodeOnOriginX.copy(targetNode);
                    }
                }
                /*
                 ** on the Current X
                 */
                if ((currentB.getMaxX() &gt; targetBounds.getMinX()) &amp;&amp; (targetBounds.getMaxX() &gt; currentB.getMinX())) {
                    if (nearestNodeOnCurrentX == null || nearestNodeOnCurrentX.biasShortestDistance &gt; targetNode.biasShortestDistance) {

                        if (nearestNodeOnCurrentX == null) {
                            nearestNodeOnCurrentX = new TargetNode();
                        }
                        nearestNodeOnCurrentX.copy(targetNode);
                    }
                }
                /*
                 ** Closest top left / bottom left corners.
                 */
                if (nearestNodeLeft == null || nearestNodeLeft.leftCornerDistance &gt; targetNode.leftCornerDistance) {
                    if (((originB.getMinX() &gt;= currentB.getMinX()) &amp;&amp; (targetBounds.getMinX() &gt;= currentB.getMinX()))
                            || ((originB.getMinX() &lt;= currentB.getMinX()) &amp;&amp; (targetBounds.getMinX() &lt;= currentB.getMinX()))) {

                        if (nearestNodeLeft == null) {
                            nearestNodeLeft = new TargetNode();
                        }
                        nearestNodeLeft.copy(targetNode);
                    }
                }

                if (nearestNodeAverage == null || nearestNodeAverage.averageDistance &gt; targetNode.averageDistance) {
                    if (((originB.getMinX() &gt;= currentB.getMinX()) &amp;&amp; (targetBounds.getMinX() &gt;= currentB.getMinX()))
                            || ((originB.getMinX() &lt;= currentB.getMinX()) &amp;&amp; (targetBounds.getMinX() &lt;= currentB.getMinX()))) {

                        if (nearestNodeAverage == null) {
                            nearestNodeAverage = new TargetNode();
                        }
                        nearestNodeAverage.copy(targetNode);
                    }
                }

                if (nearestNodeAnythingAnywhere == null || nearestNodeAnythingAnywhere.shortestDistance &gt; targetNode.shortestDistance) {

                    if (nearestNodeAnythingAnywhere == null) {
                        nearestNodeAnythingAnywhere = new TargetNode();
                    }
                    nearestNodeAnythingAnywhere.copy(targetNode);
                }
            }
        }
        nodes.clear();

        if (nearestNodeOnOriginX != null) {
            nearestNodeOnOriginX.originLeftCornerDistance = originLeftCorner2D.distance(nearestNodeOnOriginX.bounds.getMinX(), ySideInOpositeDirection.apply(nearestNodeOnOriginX.bounds));
        }

        if (nearestNodeOnCurrentX != null) {
            nearestNodeOnCurrentX.originLeftCornerDistance = originLeftCorner2D.distance(nearestNodeOnCurrentX.bounds.getMinX(), ySideInOpositeDirection.apply(nearestNodeOnCurrentX.bounds));
        }

        if (nearestNodeAverage != null) {
            nearestNodeAverage.originLeftCornerDistance = originLeftCorner2D.distance(nearestNodeAverage.bounds.getMinX(), ySideInOpositeDirection.apply(nearestNodeAverage.bounds));
        }

        if (nearestNodeOnOriginX != null) {
            /*
            ** there's a preference, all else being equal, to return nearestNodeOnOriginX
            */
            if (nearestNodeOnCurrentX != null &amp;&amp; nearestNodeOnOriginX.node == nearestNodeOnCurrentX.node
                    &amp;&amp; ((nearestNodeAverage != null &amp;&amp; nearestNodeOnOriginX.node == nearestNodeAverage.node)
                    || (nearestNodeOriginSimple2D != null &amp;&amp; nearestNodeOnOriginX.node == nearestNodeOriginSimple2D.node)
                    || (nearestNodeLeft != null &amp;&amp; nearestNodeOnOriginX.node == nearestNodeLeft.node)
                    || (nearestNodeAnythingAnywhere != null &amp;&amp; nearestNodeOnOriginX.node == nearestNodeAnythingAnywhere.node))) {
                return nearestNodeOnOriginX.node;
            }
            if (nearestNodeAverage != null &amp;&amp; nearestNodeOnOriginX.node == nearestNodeAverage.node) {
                return nearestNodeOnOriginX.node;
            }

            if (nearestNodeOnCurrentX != null) {
                if ((nearestNodeOnCurrentX.leftCornerDistance &lt; nearestNodeOnOriginX.leftCornerDistance) &amp;&amp;
                    (nearestNodeOnCurrentX.originLeftCornerDistance &lt; nearestNodeOnOriginX.originLeftCornerDistance) &amp;&amp;
                (nearestNodeOnCurrentX.bounds.getMinX() - currentLeftCorner2D.getX()) &lt; (nearestNodeOnOriginX.bounds.getMinX() - currentLeftCorner2D.getX())) {

                    return nearestNodeOnCurrentX.node;
                } else if (nearestNodeAverage == null || nearestNodeOnOriginX.averageDistance &lt; nearestNodeAverage.averageDistance) {
                    return nearestNodeOnOriginX.node;
                }
            }
        } else {
            if (nearestNodeOnCurrentX == null &amp;&amp; nearestNodeCurrentSimple2D != null) {
                if (nearestNodeAverage != null &amp;&amp; nearestNodeLeft != null &amp;&amp; (nearestNodeAverage.node == nearestNodeLeft.node &amp;&amp; nearestNodeAverage.node == nearestNodeAnythingAnywhere.node)) {
                    return nearestNodeAverage.node;
                }
                return nearestNodeCurrentSimple2D.node;
            } else if (nearestNodeAverage != null &amp;&amp; nearestNodeLeft != null &amp;&amp; nearestNodeAnythingAnywhere != null
                    &amp;&amp;     nearestNodeAverage.biasShortestDistance == nearestNodeLeft.biasShortestDistance &amp;&amp;
                     nearestNodeAverage.biasShortestDistance == nearestNodeAnythingAnywhere.biasShortestDistance &amp;&amp;
                     nearestNodeAverage.biasShortestDistance &lt; Double.MAX_VALUE) {

                    return nearestNodeAverage.node;
            }
        }

        /*
        ** is the average closer?
        */
        if (nearestNodeAverage != null &amp;&amp; (nearestNodeOnOriginX == null || (nearestNodeAverage.biasShortestDistance &lt; nearestNodeOnOriginX.biasShortestDistance))) {
            /*
            ** but is one in the way
            */
            if (nearestNodeOnOriginX != null &amp;&amp; (ySideInOpositeDirection.apply(nearestNodeOnOriginX.bounds) &gt;= ySideInOpositeDirection.apply(nearestNodeAverage.bounds))) {
                return nearestNodeOnOriginX.node;
            }
            if (nearestNodeOriginSimple2D != null) {
                if (nearestNodeOriginSimple2D.current2DMetric &lt;= nearestNodeAverage.current2DMetric) {
                    return nearestNodeOriginSimple2D.node;
                }
                if (ySideInOpositeDirection.apply(nearestNodeOriginSimple2D.bounds) &gt;= ySideInOpositeDirection.apply(nearestNodeAverage.bounds)) {
                    return nearestNodeOriginSimple2D.node;
                }
            }
            return nearestNodeAverage.node;
        }

        /*
        ** this is an odd one, in that is isn't the closest on current, or on the
        ** origin, but it looks better for most cases...
        */
        if ((nearestNodeCurrentSimple2D != null &amp;&amp; nearestNodeOnCurrentX != null &amp;&amp; nearestNodeAverage != null &amp;&amp; nearestNodeLeft != null &amp;&amp; nearestNodeAnythingAnywhere != null) &amp;&amp;
            (nearestNodeCurrentSimple2D.node == nearestNodeOnCurrentX.node) &amp;&amp;
            (nearestNodeCurrentSimple2D.node ==  nearestNodeAverage.node) &amp;&amp;
            (nearestNodeCurrentSimple2D.node == nearestNodeLeft.node) &amp;&amp;
            (nearestNodeCurrentSimple2D.node == nearestNodeAnythingAnywhere.node)) {
            return nearestNodeCurrentSimple2D.node;
        }

        if (nearestNodeOnOriginX != null &amp;&amp; (nearestNodeOnCurrentX == null || (nearestNodeOnOriginX.rightCornerDistance &lt; nearestNodeOnCurrentX.rightCornerDistance))) {
            return nearestNodeOnOriginX.node;
        }
        /*
        ** There isn't a clear winner, just go to the one nearest the current
         ** focus owner, or if invalid then try the other contenders.
         */
        if (nearestNodeOnOriginX != null) {
            return nearestNodeOnOriginX.node;
        } else if (nearestNodeOriginSimple2D != null) {
            return nearestNodeOriginSimple2D.node;
        } else if (nearestNodeOnCurrentX != null) {
            return nearestNodeOnCurrentX.node;
        } else if (nearestNodeAverage != null) {
            return nearestNodeAverage.node;
        } else if (nearestNodeLeft != null) {
            return nearestNodeLeft.node;
        } else if (nearestNodeAnythingAnywhere != null) {
            return nearestNodeAnythingAnywhere.node;
        }
        return null;
    }

    private static final Function&lt;Bounds, Double&gt; BOUNDS_LEFT_SIDE = t -&gt; t.getMinX();

    private static final Function&lt;Bounds, Double&gt; BOUNDS_RIGHT_SIDE = t -&gt; t.getMaxX();

    protected Node getNearestNodeLeftOrRight(Bounds currentB, Bounds originB, TraversalContext context, Direction dir) {

        List&lt;Node&gt; nodes = context.getAllTargetNodes();

        Function&lt;Bounds, Double&gt; xSideInDirection = dir == LEFT ? BOUNDS_LEFT_SIDE : BOUNDS_RIGHT_SIDE;
        Function&lt;Bounds, Double&gt; xSideInOpositeDirection = dir == LEFT ? BOUNDS_RIGHT_SIDE : BOUNDS_LEFT_SIDE;

        Bounds biasedB = new BoundingBox(currentB.getMinX(), originB.getMinY(), currentB.getWidth(), originB.getHeight());

        Point2D currentMid2D = new Point2D(xSideInDirection.apply(currentB), currentB.getMinY()+(currentB.getHeight()/2));
        Point2D biasedMid2D = new Point2D(xSideInDirection.apply(currentB), originB.getMinY()+(originB.getHeight()/2));
        Point2D currentTopCorner2D = new Point2D(xSideInDirection.apply(currentB), currentB.getMinY());
        Point2D biasedTopCorner2D = new Point2D(xSideInDirection.apply(currentB), originB.getMinY());
        Point2D currentBottomCorner2D = new Point2D(xSideInDirection.apply(currentB), currentB.getMaxY());
        Point2D biasedBottomCorner2D = new Point2D(xSideInDirection.apply(currentB), originB.getMaxY());

        Point2D originTopCorner2D = new Point2D(xSideInDirection.apply(originB), originB.getMinY());

        TargetNode targetNode = new TargetNode();
        TargetNode nearestNodeCurrentSimple2D = null;
        TargetNode nearestNodeOriginSimple2D = null;
        TargetNode nearestNodeAverage = null;
        TargetNode nearestNodeOnOriginY = null;
        TargetNode nearestNodeOnCurrentY = null;
        TargetNode nearestNodeTopLeft = null;
        TargetNode nearestNodeAnythingAnywhereLeft = null;

        for (int nodeIndex = 0; nodeIndex &lt; nodes.size(); nodeIndex++) {
            final Node n = nodes.get(nodeIndex);

            Bounds targetBounds = n.localToScene(n.getLayoutBounds());
            /*
             ** check that the target node starts after we start
             ** and the target node ends after we end
             */
            if (dir == LEFT ? currentB.getMinX() &gt; targetBounds.getMinX()
                    : currentB.getMaxX() &lt; targetBounds.getMaxX()) {

                targetNode.node = n;
                targetNode.bounds = targetBounds;

                /*
                 * closest biased : simple 2d.
                 * Negative means the Node is on the same Y axis. This will result in outdB == 0, making this a preferred Node.
                 */
                double outdB = Math.max(0, outDistance(dir, biasedB, targetBounds));

                if (isOnAxis(dir, biasedB, targetBounds)) {
                    targetNode.biased2DMetric = outdB + centerSideDistance(dir, biasedB, targetBounds) / 100;
                } else {
                    final double cosd = cornerSideDistance(dir, biasedB, targetBounds);
                    targetNode.biased2DMetric = 100000 + outdB * outdB + 9 * cosd * cosd;
                }
                /*
                 * closest current : simple 2d
                 *Negative means the Node is on the same Y axis. This will result in outdB == 0, making this a preferred Node.
                 */
                double outdC = Math.max(0, outDistance(dir, currentB, targetBounds));

                if (isOnAxis(dir, currentB, targetBounds)) {
                    targetNode.current2DMetric = outdC + centerSideDistance(dir, currentB, targetBounds) / 100;
                } else {
                    final double cosd = cornerSideDistance(dir, currentB, targetBounds);
                    targetNode.current2DMetric = 100000 + outdC * outdC + 9 * cosd * cosd;
                }

                targetNode.topCornerDistance = currentTopCorner2D.distance(xSideInOpositeDirection.apply(targetBounds), targetBounds.getMinY());
                targetNode.bottomCornerDistance = currentBottomCorner2D.distance(xSideInOpositeDirection.apply(targetBounds), targetBounds.getMaxY());

                double midDistance = currentMid2D.distance(xSideInOpositeDirection.apply(targetBounds), targetBounds.getMinY() + (targetBounds.getHeight() / 2));
                double currentTopToTargetBottomDistance = currentTopCorner2D.distance(xSideInOpositeDirection.apply(targetBounds), targetBounds.getMaxY());
                double currentTopToTargetMidDistance = currentTopCorner2D.distance(xSideInOpositeDirection.apply(targetBounds), targetBounds.getMinY() + (targetBounds.getHeight() / 2));
                double currentBottomToTargetTopDistance = currentBottomCorner2D.distance(xSideInOpositeDirection.apply(targetBounds), targetBounds.getMinY());
                double currentBottomToTargetBottomDistance = currentBottomCorner2D.distance(xSideInOpositeDirection.apply(targetBounds), targetBounds.getMaxY());
                double currentBottomToTargetMidDistance = currentBottomCorner2D.distance(xSideInOpositeDirection.apply(targetBounds), targetBounds.getMinY() + (targetBounds.getHeight() / 2));
                double currentMidToTargetTopDistance = currentMid2D.distance(xSideInOpositeDirection.apply(targetBounds), targetBounds.getMinY());
                double currentMidToTargetBottomDistance = currentMid2D.distance(xSideInOpositeDirection.apply(targetBounds), targetBounds.getMaxY());
                double currentMidToTargetMidDistance = currentMid2D.distance(xSideInOpositeDirection.apply(targetBounds), targetBounds.getMinY() + (targetBounds.getHeight() / 2));

                double biasTopToTargetBottomDistance = biasedTopCorner2D.distance(xSideInOpositeDirection.apply(targetBounds), targetBounds.getMaxY());
                double biasTopToTargetMidDistance = biasedTopCorner2D.distance(xSideInOpositeDirection.apply(targetBounds), targetBounds.getMinY() + (targetBounds.getHeight() / 2));
                double biasBottomToTargetMidDistance = biasedBottomCorner2D.distance(xSideInOpositeDirection.apply(targetBounds), targetBounds.getMinY() + (targetBounds.getHeight() / 2));
                double biasMidToTargetBottomDistance = biasedMid2D.distance(xSideInOpositeDirection.apply(targetBounds), targetBounds.getMaxY());

                targetNode.averageDistance
                        = (targetNode.topCornerDistance + biasTopToTargetBottomDistance + biasTopToTargetMidDistance
                        + currentBottomToTargetTopDistance + targetNode.bottomCornerDistance + biasBottomToTargetMidDistance + midDistance) / 7;

                targetNode.biasShortestDistance
                        = findMin(targetNode.topCornerDistance, biasTopToTargetBottomDistance, biasTopToTargetMidDistance,
                                currentBottomToTargetTopDistance, targetNode.bottomCornerDistance, biasBottomToTargetMidDistance,
                                currentMidToTargetTopDistance, biasMidToTargetBottomDistance, midDistance);

                targetNode.shortestDistance
                        = findMin(targetNode.topCornerDistance, currentTopToTargetBottomDistance, currentTopToTargetMidDistance,
                                currentBottomToTargetTopDistance, currentBottomToTargetBottomDistance, currentBottomToTargetMidDistance,
                                currentMidToTargetTopDistance, currentMidToTargetBottomDistance, currentMidToTargetMidDistance);

                /*
                 ** closest biased : simple 2d
                 */
                if (outdB &gt;= 0.0) {
                    if (nearestNodeOriginSimple2D == null || targetNode.biased2DMetric &lt; nearestNodeOriginSimple2D.biased2DMetric) {

                        if (nearestNodeOriginSimple2D == null) {
                            nearestNodeOriginSimple2D = new TargetNode();
                        }
                        nearestNodeOriginSimple2D.copy(targetNode);
                    }
                }
                /*
                 ** closest current : simple 2d
                 */
                if (outdC &gt;= 0.0) {
                    if (nearestNodeCurrentSimple2D == null || targetNode.current2DMetric &lt; nearestNodeCurrentSimple2D.current2DMetric) {

                        if (nearestNodeCurrentSimple2D == null) {
                            nearestNodeCurrentSimple2D = new TargetNode();
                        }
                        nearestNodeCurrentSimple2D.copy(targetNode);
                    }
                }
                /*
                 ** on the Origin Y
                 */
                if ((originB.getMaxY() &gt; targetBounds.getMinY()) &amp;&amp; (targetBounds.getMaxY() &gt; originB.getMinY())) {
                    if (nearestNodeOnOriginY == null || nearestNodeOnOriginY.topCornerDistance &gt; targetNode.topCornerDistance) {

                        if (nearestNodeOnOriginY == null) {
                            nearestNodeOnOriginY = new TargetNode();
                        }
                        nearestNodeOnOriginY.copy(targetNode);
                    }
                }
                /*
                 ** on the Current Y
                 */
                if ((currentB.getMaxY() &gt; targetBounds.getMinY()) &amp;&amp; (targetBounds.getMaxY() &gt; currentB.getMinY())) {
                    if (nearestNodeOnCurrentY == null || nearestNodeOnCurrentY.topCornerDistance &gt; targetNode.topCornerDistance) {

                        if (nearestNodeOnCurrentY == null) {
                            nearestNodeOnCurrentY = new TargetNode();
                        }
                        nearestNodeOnCurrentY.copy(targetNode);
                    }
                }
                /*
                 ** Closest top left / top right corners.
                 */
                if (nearestNodeTopLeft == null || nearestNodeTopLeft.topCornerDistance &gt; targetNode.topCornerDistance) {

                    if (nearestNodeTopLeft == null) {
                        nearestNodeTopLeft = new TargetNode();
                    }
                    nearestNodeTopLeft.copy(targetNode);
                }

                if (nearestNodeAverage == null || nearestNodeAverage.averageDistance &gt; targetNode.averageDistance) {

                    if (nearestNodeAverage == null) {
                        nearestNodeAverage = new TargetNode();
                    }
                    nearestNodeAverage.copy(targetNode);
                }

                if (nearestNodeAnythingAnywhereLeft == null || nearestNodeAnythingAnywhereLeft.shortestDistance &gt; targetNode.shortestDistance) {

                    if (nearestNodeAnythingAnywhereLeft == null) {
                        nearestNodeAnythingAnywhereLeft = new TargetNode();
                    }
                    nearestNodeAnythingAnywhereLeft.copy(targetNode);
                }
            }
        }
        nodes.clear();

        if (nearestNodeOnOriginY != null) {
            nearestNodeOnOriginY.originTopCornerDistance = originTopCorner2D.distance(xSideInOpositeDirection.apply(nearestNodeOnOriginY.bounds), nearestNodeOnOriginY.bounds.getMinY());
        }

        if (nearestNodeOnCurrentY != null) {
            nearestNodeOnCurrentY.originTopCornerDistance = originTopCorner2D.distance(xSideInOpositeDirection.apply(nearestNodeOnCurrentY.bounds), nearestNodeOnCurrentY.bounds.getMinY());
        }

        if (nearestNodeAverage != null) {
            nearestNodeAverage.originTopCornerDistance = originTopCorner2D.distance(xSideInOpositeDirection.apply(nearestNodeAverage.bounds), nearestNodeAverage.bounds.getMinY());
        }

        if (nearestNodeOnCurrentY == null &amp;&amp; nearestNodeOnOriginY == null) {
            cacheStartTraversalNode = null;
            cacheStartTraversalDirection = null;
            reverseDirection = false;
            traversalNodeStack.clear();
        }

        if (nearestNodeOnOriginY != null) {
            /*
             ** there's a preference, all else being equal, to return nearestNodeOnOriginY
             */
            if (nearestNodeOnCurrentY != null &amp;&amp; nearestNodeOnOriginY.node == nearestNodeOnCurrentY.node
                    &amp;&amp; ((nearestNodeAverage != null &amp;&amp; nearestNodeOnOriginY.node == nearestNodeAverage.node)
                    || (nearestNodeTopLeft != null &amp;&amp; nearestNodeOnOriginY.node == nearestNodeTopLeft.node)
                    || (nearestNodeAnythingAnywhereLeft != null &amp;&amp; nearestNodeOnOriginY.node == nearestNodeAnythingAnywhereLeft.node))) {
                return nearestNodeOnOriginY.node;
            }

            if (nearestNodeAverage != null &amp;&amp; nearestNodeOnOriginY.node == nearestNodeAverage.node) {
                return nearestNodeOnOriginY.node;
            }

            if (nearestNodeOnCurrentY != null) {
                if ((nearestNodeOnCurrentY.bottomCornerDistance &lt; nearestNodeOnOriginY.bottomCornerDistance)
                        &amp;&amp; (nearestNodeOnCurrentY.originTopCornerDistance &lt; nearestNodeOnOriginY.originTopCornerDistance)
                        &amp;&amp; (nearestNodeOnCurrentY.bounds.getMinY() - currentTopCorner2D.getY()) &lt; (nearestNodeOnOriginY.bounds.getMinY() - currentTopCorner2D.getY())) {

                    return nearestNodeOnCurrentY.node;
                } else if (nearestNodeAverage == null || nearestNodeOnOriginY.averageDistance &lt; nearestNodeAverage.averageDistance) {
                    return nearestNodeOnOriginY.node;
                }
            }
        } else {
            if (nearestNodeOnCurrentY == null &amp;&amp; nearestNodeCurrentSimple2D != null) {
                if (nearestNodeAverage != null &amp;&amp; nearestNodeTopLeft != null
                        &amp;&amp; nearestNodeAverage.node == nearestNodeTopLeft.node &amp;&amp; nearestNodeAverage.node == nearestNodeAnythingAnywhereLeft.node) {
                    return nearestNodeAverage.node;
                }
                return nearestNodeCurrentSimple2D.node;
            } else if (nearestNodeAverage != null &amp;&amp; nearestNodeTopLeft != null &amp;&amp; nearestNodeAnythingAnywhereLeft != null
                    &amp;&amp; nearestNodeAverage.biasShortestDistance == nearestNodeTopLeft.biasShortestDistance
                    &amp;&amp; nearestNodeAverage.biasShortestDistance == nearestNodeAnythingAnywhereLeft.biasShortestDistance
                    &amp;&amp; nearestNodeAverage.biasShortestDistance &lt; Double.MAX_VALUE) {
                    return nearestNodeAverage.node;
            }
        }

        /*
        ** is the average closer?
        */
        if (nearestNodeAverage != null &amp;&amp; (nearestNodeOnOriginY == null || nearestNodeAverage.biasShortestDistance &lt; nearestNodeOnOriginY.biasShortestDistance)) {
            /*
            ** but is one in the way
            */
            if (nearestNodeOnOriginY != null &amp;&amp; (xSideInOpositeDirection.apply(nearestNodeOnOriginY.bounds) &gt;= xSideInOpositeDirection.apply(nearestNodeAverage.bounds))) {
                return nearestNodeOnOriginY.node;
            }
            /*
            ** maybe Origin is better than this?
            */
            if (nearestNodeOnOriginY != null &amp;&amp; nearestNodeOnCurrentY != null &amp;&amp; nearestNodeOnOriginY.biasShortestDistance &lt; Double.MAX_VALUE &amp;&amp; (nearestNodeOnOriginY.node == nearestNodeOnCurrentY.node)) {
                return nearestNodeOnOriginY.node;
            }

            if (nearestNodeOnCurrentY != null &amp;&amp; nearestNodeOnOriginY != null &amp;&amp; nearestNodeOnCurrentY.biasShortestDistance &lt; Double.MAX_VALUE &amp;&amp; (nearestNodeOnCurrentY.biasShortestDistance &lt; nearestNodeOnOriginY.biasShortestDistance)) {
                return nearestNodeOnCurrentY.node;
            }

            if (nearestNodeOnOriginY != null &amp;&amp; nearestNodeOnOriginY.biasShortestDistance &lt; Double.MAX_VALUE &amp;&amp; (nearestNodeOnOriginY.originTopCornerDistance &lt; nearestNodeAverage.originTopCornerDistance)) {
                return nearestNodeOnOriginY.node;
            }
            return nearestNodeAverage.node;
        }


        if (nearestNodeOnOriginY != null &amp;&amp; nearestNodeOnCurrentY != null &amp;&amp; nearestNodeOnOriginY.bottomCornerDistance &lt; nearestNodeOnCurrentY.bottomCornerDistance) {
            return nearestNodeOnOriginY.node;
        }

        /*
        ** if any of the remaining match we'll take that
        */
        if (nearestNodeOnCurrentY != null &amp;&amp; nearestNodeTopLeft != null &amp;&amp; nearestNodeOnCurrentY.biasShortestDistance &lt; Double.MAX_VALUE &amp;&amp; (nearestNodeOnCurrentY.node == nearestNodeTopLeft.node)) {
            return nearestNodeOnCurrentY.node;
        }
        /*
        ** There isn't a clear winner, just go to the one nearest the current
        ** focus owner, or if invalid then try the other contenders.
        */
        if (nearestNodeOnOriginY != null) {
            return nearestNodeOnOriginY.node;
        } else if (nearestNodeOriginSimple2D != null) {
            return nearestNodeOriginSimple2D.node;
        } else if (nearestNodeOnCurrentY != null) {
            return nearestNodeOnCurrentY.node;
        } else if (nearestNodeAverage != null) {
            return nearestNodeAverage.node;
        } else if (nearestNodeTopLeft != null) {
            return nearestNodeTopLeft.node;
        } else if (nearestNodeAnythingAnywhereLeft != null) {
            return nearestNodeAnythingAnywhereLeft.node;
        }
        return null;
    }

    static final class TargetNode {
        Node node = null;
        Bounds bounds = null;
        double biased2DMetric = Double.MAX_VALUE;
        double current2DMetric = Double.MAX_VALUE;

        double leftCornerDistance = Double.MAX_VALUE;
        double rightCornerDistance = Double.MAX_VALUE;
        double topCornerDistance = Double.MAX_VALUE;
        double bottomCornerDistance = Double.MAX_VALUE;

        double shortestDistance = Double.MAX_VALUE;
        double biasShortestDistance = Double.MAX_VALUE;
        double averageDistance = Double.MAX_VALUE;

        double originLeftCornerDistance = Double.MAX_VALUE;
        double originTopCornerDistance = Double.MAX_VALUE;

        void copy(TargetNode source) {
            node = source.node;
            bounds = source.bounds;
            biased2DMetric = source.biased2DMetric;
            current2DMetric = source.current2DMetric;

            leftCornerDistance = source.leftCornerDistance;
            rightCornerDistance = source.rightCornerDistance;

            shortestDistance = source.shortestDistance;
            biasShortestDistance = source.biasShortestDistance;
            averageDistance = source.averageDistance;

            topCornerDistance = source.topCornerDistance;
            bottomCornerDistance = source.bottomCornerDistance;
            originLeftCornerDistance = source.originLeftCornerDistance;
            originTopCornerDistance = source.originTopCornerDistance;
        }
    }

    public static double findMin(double... values) {

        double minValue = Double.MAX_VALUE;

        for (int i = 0 ; i &lt; values.length ; i++) {
            minValue = (minValue &lt; values[i]) ? minValue : values[i];
        }
        return minValue;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/d3d/D3DResource.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.d3d;

import com.sun.prism.impl.BaseGraphicsResource;
import com.sun.prism.impl.Disposer;

/**
 * This class provides base functionality for tracking and releasing native
 * d3d-related resources.
 *
 * When a Direct3D resource (such as texture, swap chain or pixel shader) is
 * created at the native level it is added to the list of resources (see
 * D3DResourceManager.cc) on both native and java level.
 *
 * This is needed because if a d3d device is lost
 * and needs to be reset we must release all resources created in the default
 * pool first. We must have references to all allocated resources in order to
 * do that. In some cases we need to release all resources (when the device
 * needs to be released, which may happen when a monitor is added or removed).
 *
 * There are several different ways a resource could be disposed of:
 *  - explicit disposal (dispose() is called) - the resource is released by the
 * resource manager at the native level, disposer record is updated to reflect
 * that
 *  - resource became unreachable - then the disposer will eventulally call
 * dispose() for this resource
 *  - resource is disposed of at the native level when trying to reset the
 * device. In this case the native code will call appropriate method to mark
 * default pool or all resources as released (the release itself will happen
 * at the native level) - see {@link D3DResourceManager}
 *
 * In all these cases resource disposal happens on the same thread (the
 * Rendering Thread).
 *
 * Note that some d3d-related resources are not derived from this class - like
 * D3DTexture. This is a bit confusing. But they do use this class's disposer
 * record (they must).
 */
class D3DResource extends BaseGraphicsResource {

    protected final D3DRecord d3dResRecord;

    D3DResource(D3DRecord disposerRecord) {
        super(disposerRecord);
        this.d3dResRecord = disposerRecord;
    }

    @Override
    public void dispose() {
        d3dResRecord.dispose();
    }

    static class D3DRecord implements Disposer.Record {

        private final D3DContext context;
        private long pResource;
        private boolean isDefaultPool;

        D3DRecord(D3DContext context, long pResource) {
            this.context = context;
            this.pResource = pResource;
            if (pResource != 0L) {
                // only add to the list of resources if there's something to
                // dispose of
                context.getResourceFactory().addRecord(this);
                isDefaultPool = D3DResourceFactory.nIsDefaultPool(pResource);
            } else {
                isDefaultPool = false;
            }
        }

        long getResource() {
            return pResource;
        }

        D3DContext getContext() {
            return context;
        }

        boolean isDefaultPool() {
            return isDefaultPool;
        }

        protected void markDisposed() {
<A NAME="12"></A>            pResource = 0L;
        }

        public void dispose() <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#12',2,'match46-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
            if (pResource != 0L) {
                context.getResourceFactory().removeRecord(this);
                D3DResourceFactory.nReleaseResource(context.getContextHandle(),
                                                               pResource);
                pResource = 0L;

                // res is always S_OK, no need to validate anything here
                // context.validate(res);
            }
        }</B></FONT>
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/es2/ES2Shader.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.es2;

import com.sun.prism.impl.BaseGraphicsResource;
import com.sun.prism.impl.Disposer;
import com.sun.prism.ps.Shader;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Represents an OpenGL shader program object, which can be constructed from
 * the source code for a vertex shader, a fragment shader, or both.
 * Contains convenience methods for enabling/disabling shader state.
 * &lt;p&gt;
 * Usage example:
 * &lt;pre&gt;
 *     String source =
 *         &quot;uniform sampler2D myTex;&quot; +
 *         &quot;void main(void)&quot; +
 *         &quot;{&quot; +
 *         &quot;    vec4 src = texture2D(myTex, gl_TexCoord[0].st);&quot; +
 *         &quot;    gl_FragColor = src.bgra;&quot; + // swizzle!
 *         &quot;}&quot;;
 *     ES2Shader shader = new ES2Shader(source);
 *     shader.setConstant(&quot;myTex&quot;, 0); // myTex will be on texture unit 0
 *     ...
 *     shader.enable();
 *     texture.enable();
 *     texture.bind();
 *     ...
 *     texture.disable();
 *     shader.disable();
 * };
 * &lt;/pre&gt;
 */
public class ES2Shader extends BaseGraphicsResource implements Shader {

    private static class Uniform {

        private int location;
        private Object values;
    }

    /**
     * The handle to the OpenGL shader program object.
     */
    private int programID;
    private final ES2Context context;
    private final Map&lt;String, Uniform&gt; uniforms = new HashMap&lt;String, Uniform&gt;();
    private final int maxTexCoordIndex;
    private final boolean isPixcoordUsed;
    private boolean valid;
    private float[] currentMatrix;

    private ES2Shader(ES2Context context, int programID,
            int vertexShaderID, int[] fragmentShaderID,
            Map&lt;String, Integer&gt; samplers,
            int maxTexCoordIndex, boolean isPixcoordUsed)
            throws RuntimeException {
        super(new ES2ShaderDisposerRecord(context,
                vertexShaderID,
                fragmentShaderID,
                programID));
        this.context = context;
        this.programID = programID;
        this.maxTexCoordIndex = maxTexCoordIndex;
        this.isPixcoordUsed = isPixcoordUsed;
        this.valid = (programID != 0);

        if (valid &amp;&amp; samplers != null) {
            // save/restore the current program (creating an ES2Shader
            // should not affect context state)
            int currentProgram = context.getShaderProgram();
            context.setShaderProgram(programID);
            for (String key : samplers.keySet()) {
                setConstant(key, samplers.get(key));
            }
            context.setShaderProgram(currentProgram);
        }
    }

    static ES2Shader createFromSource(ES2Context context,
            String vert, String[] frag,
            Map&lt;String, Integer&gt; samplers,
            Map&lt;String, Integer&gt; attributes,
            int maxTexCoordIndex,
            boolean isPixcoordUsed) {
        GLContext glCtx = context.getGLContext();
        if (!glCtx.isShaderCompilerSupported()) {
            throw new RuntimeException(&quot;Shader compiler not available on this device&quot;);
        }

        if (vert == null || frag == null || frag.length == 0) {
            throw new RuntimeException(
                    &quot;Both vertexShaderSource and fragmentShaderSource &quot;
                    + &quot;must be specified&quot;);
        }

        int vertexShaderID = glCtx.compileShader(vert, true);
        if (vertexShaderID == 0) {
            throw new RuntimeException(&quot;Error creating vertex shader&quot;);
        }

        int[] fragmentShaderID = new int[frag.length];
        for (int i = 0; i &lt; frag.length; i++) {
            fragmentShaderID[i] = glCtx.compileShader(frag[i], false);
            if (fragmentShaderID[i] == 0) {
                glCtx.deleteShader(vertexShaderID);
                //TODO: delete any fragment shaders already created
                throw new RuntimeException(&quot;Error creating fragment shader&quot;);
            }
        }

        String[] attrs = new String[attributes.size()];
        int[] indexs = new int[attrs.length];
        int i = 0;
        for (String attr : attributes.keySet()) {
            attrs[i] = attr;
            indexs[i] = attributes.get(attr);
            i++;
        }
        int programID = glCtx.createProgram(vertexShaderID, fragmentShaderID,
                attrs, indexs);
        if (programID == 0) {
            // createProgram() will have already detached/deleted
            // vertexShader and fragmentShader resources
            throw new RuntimeException(&quot;Error creating shader program&quot;);
        }

        return new ES2Shader(context,
                programID, vertexShaderID, fragmentShaderID,
                samplers, maxTexCoordIndex, isPixcoordUsed);
    }

    static ES2Shader createFromSource(ES2Context context,
            String vert, InputStream frag,
            Map&lt;String, Integer&gt; samplers,
            Map&lt;String, Integer&gt; attributes,
            int maxTexCoordIndex,
            boolean isPixcoordUsed) {
        String[] fragmentShaderSource = new String[] {readStreamIntoString(frag)};
        return createFromSource(context, vert, fragmentShaderSource, samplers,
                attributes, maxTexCoordIndex, isPixcoordUsed);
    }

    static String readStreamIntoString(InputStream in) {
        StringBuffer sb = new StringBuffer(1024);
        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
        try {
            char[] chars = new char[1024];
            int numRead = 0;
            while ((numRead = reader.read(chars)) &gt; -1) {
                sb.append(String.valueOf(chars, 0, numRead));
            }
        } catch (IOException e) {
            throw new RuntimeException(&quot;Error reading shader stream&quot;);
        } finally {
            try {
                reader.close();
            } catch (IOException e) {
                throw new RuntimeException(&quot;Error closing reader&quot;);
            }
        }
        return sb.toString();
    }

    /**
     * Returns the underlying OpenGL program object handle for this fragment
     * shader. Most applications will not need to access this, since it is
     * handled automatically by the enable() and dispose() methods.
     *
     * @return the OpenGL program object handle for this fragment shader
     */
    public int getProgramObject() {
        return programID;
    }

    /**
     * Returns the maximum texcoord index referenced by this shader program.
     *
     * @return the maximum texcoord index referenced by this shader program
     */
    public int getMaxTexCoordIndex() {
        return maxTexCoordIndex;
    }

    /**
     * Returns true if this shader uses the special pixcoord variable,
     * otherwise returns false
     *
     * @return true if this shader uses the special pixcoord variable
     */
    public boolean isPixcoordUsed() {
        return isPixcoordUsed;
    }

    private Uniform getUniform(String name) {
        Uniform uniform = uniforms.get(name);
        if (uniform == null) {
            // cache native uniform locations in a hashmap for quicker access
            int loc = context.getGLContext().getUniformLocation(programID, name);
            uniform = new Uniform();
            uniform.location = loc;
<A NAME="29"></A>            uniforms.put(name, uniform);
        }
        return uniform;
    <FONT color="#faafba"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#29',2,'match46-top.html#29',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    /**
     * Enables this shader program in the current GL context's state.
     *
     * @throws RuntimeException if no OpenGL context was current or if any
     * OpenGL-related errors occurred
     */
    public void enable() throws RuntimeException {
        context.updateShaderProgram(programID);
    }

    /**
     * Disables this shader program in the current GL context's state.
     *
     * @throws RuntimeException if no OpenGL context was current or if any
     * OpenGL-related errors occurred
     */
    public void disable() throws RuntimeException {
        // TODO: remove disable() method from Shader interface... (RT-27442)
        context.updateShaderProgram(0);
    }

    public boolean isValid() {
        return valid;
    }

    /**
     * Sets the uniform variable of the given name with the provided
     * integer value.
     *
     * @param name the name of the uniform variable to be set
     * @param i0 the first uniform parameter
     * @throws RuntimeException if no OpenGL context was current or if any
     * OpenGL-related errors occurred
     */
    public void</B></FONT> setConstant(String name, int i0)
            throws RuntimeException {
        Uniform uniform = getUniform(name);
        if (uniform.location == -1) {
            return;
        }
        if (uniform.values == null) {
            uniform.values = new int[1];
        }
        int[] values = (int[]) uniform.values;
        if (values[0] != i0) {
            values[0] = i0;
            context.getGLContext().uniform1i(uniform.location, i0);
        }
    }

    /**
     * Sets the uniform variable of the given name with the provided
     * integer values.
     *
     * @param name the name of the uniform variable to be set
     * @param i0 the first uniform parameter
     * @param i1 the second uniform parameter
     * @throws RuntimeException if no OpenGL context was current or if any
     * OpenGL-related errors occurred
     */
    public void setConstant(String name, int i0, int i1)
            throws RuntimeException {
        Uniform uniform = getUniform(name);
        if (uniform.location == -1) {
            return;
        }
        if (uniform.values == null) {
            uniform.values = new int[2];
        }
        int[] values = (int[]) uniform.values;
        if (values[0] != i0 || values[1] != i1) {
            values[0] = i0;
            values[1] = i1;
            context.getGLContext().uniform2i(uniform.location, i0, i1);
        }
    }

    /**
     * Sets the uniform variable of the given name with the provided
     * integer values.
     *
     * @param name the name of the uniform variable to be set
     * @param i0 the first uniform parameter
     * @param i1 the second uniform parameter
     * @param i2 the third uniform parameter
     * @throws RuntimeException if no OpenGL context was current or if any
     * OpenGL-related errors occurred
     */
    public void setConstant(String name, int i0, int i1, int i2)
            throws RuntimeException {
        Uniform uniform = getUniform(name);
        if (uniform.location == -1) {
            return;
        }
        if (uniform.values == null) {
            uniform.values = new int[3];
        }
        int[] values = (int[]) uniform.values;
        if (values[0] != i0 || values[1] != i1 || values[2] != i2) {
            values[0] = i0;
            values[1] = i1;
            values[2] = i2;
            context.getGLContext().uniform3i(uniform.location, i0, i1, i2);
        }
    }

    /**
     * Sets the uniform variable of the given name with the provided
     * integer values.
     *
     * @param name the name of the uniform variable to be set
     * @param i0 the first uniform parameter
     * @param i1 the second uniform parameter
     * @param i2 the third uniform parameter
     * @param i3 the fourth uniform parameter
     * @throws RuntimeException if no OpenGL context was current or if any
     * OpenGL-related errors occurred
     */
    public void setConstant(String name, int i0, int i1, int i2, int i3)
            throws RuntimeException {
        Uniform uniform = getUniform(name);
        if (uniform.location == -1) {
            return;
        }
        if (uniform.values == null) {
            uniform.values = new int[4];
        }
        int[] values = (int[]) uniform.values;
        if (values[0] != i0 || values[1] != i1 || values[2] != i2 || values[3] != i3) {
            values[0] = i0;
            values[1] = i1;
            values[2] = i2;
            values[3] = i3;
            context.getGLContext().uniform4i(uniform.location, i0, i1, i2, i3);
        }
    }

    /**
     * Sets the uniform variable of the given name with the provided
     * float value.
     *
     * @param name the name of the uniform variable to be set
     * @param f0 the first uniform parameter
     * @throws RuntimeException if no OpenGL context was current or if any
     * OpenGL-related errors occurred
     */
    public void setConstant(String name, float f0)
            throws RuntimeException {
        Uniform uniform = getUniform(name);
        if (uniform.location == -1) {
            return;
        }
        if (uniform.values == null) {
            uniform.values = new float[1];
        }
        float[] values = (float[]) uniform.values;
        if (values[0] != f0) {
            values[0] = f0;
            context.getGLContext().uniform1f(uniform.location, f0);
        }
    }

    /**
     * Sets the uniform variable of the given name with the provided
     * float values.
     *
     * @param name the name of the uniform variable to be set
     * @param f0 the first uniform parameter
     * @param f1 the second uniform parameter
     * @throws RuntimeException if no OpenGL context was current or if any
     * OpenGL-related errors occurred
     */
    public void setConstant(String name, float f0, float f1)
            throws RuntimeException {
        Uniform uniform = getUniform(name);
        if (uniform.location == -1) {
            return;
        }
        if (uniform.values == null) {
            uniform.values = new float[2];
        }
        float[] values = (float[]) uniform.values;
        if (values[0] != f0 || values[1] != f1) {
            values[0] = f0;
            values[1] = f1;
            context.getGLContext().uniform2f(uniform.location, f0, f1);
        }
    }

    /**
     * Sets the uniform variable of the given name with the provided
     * float values.
     *
     * @param name the name of the uniform variable to be set
     * @param f0 the first uniform parameter
     * @param f1 the second uniform parameter
     * @param f2 the third uniform parameter
     * @throws RuntimeException if no OpenGL context was current or if any
     * OpenGL-related errors occurred
     */
    public void setConstant(String name, float f0, float f1, float f2)
            throws RuntimeException {
        Uniform uniform = getUniform(name);
        if (uniform.location == -1) {
            return;
        }
        if (uniform.values == null) {
            uniform.values = new float[3];
        }
        float[] values = (float[]) uniform.values;
        if (values[0] != f0 || values[1] != f1 || values[2] != f2) {
            values[0] = f0;
            values[1] = f1;
            values[2] = f2;
            context.getGLContext().uniform3f(uniform.location, f0, f1, f2);
        }
    }

    /**
     * Sets the uniform variable of the given name with the provided
     * float values.
     *
     * @param name the name of the uniform variable to be set
     * @param f0 the first uniform parameter
     * @param f1 the second uniform parameter
     * @param f2 the third uniform parameter
     * @param f3 the fourth uniform parameter
     * @throws RuntimeException if no OpenGL context was current or if any
     * OpenGL-related errors occurred
     */
    public void setConstant(String name, float f0, float f1, float f2, float f3)
            throws RuntimeException {
        Uniform uniform = getUniform(name);
        if (uniform.location == -1) {
            return;
        }
        if (uniform.values == null) {
            uniform.values = new float[4];
        }
        float[] values = (float[]) uniform.values;
        if (values[0] != f0 || values[1] != f1 || values[2] != f2 || values[3] != f3) {
            values[0] = f0;
            values[1] = f1;
            values[2] = f2;
            values[3] = f3;
            context.getGLContext().uniform4f(uniform.location, f0, f1, f2, f3);
        }
    }

    /**
     * Sets the uniform array variable of the given name with the provided
     * int array values.
     *
     * @param name the name of the uniform variable to be set
     * @param buf the array values to be set
     * @param off the offset into the vals array
     * @param count the number of ivec4 elements in the array
     * @throws RuntimeException if no OpenGL context was current or if any
     * OpenGL-related errors occurred
     */
    public void setConstants(String name, IntBuffer buf, int off, int count)
            throws RuntimeException {
        // TODO: remove off param in favor of IntBuffer.position() (RT-27442)
        int loc = getUniform(name).location;
        if (loc == -1) {
            return;
        }
        context.getGLContext().uniform4iv(loc, count, buf);

    }

    /**
     * Sets the uniform array variable of the given name with the provided
     * float array values.
     *
     * @param name the name of the uniform variable to be set
     * @param buf the array values to be set
     * @param count the number of vec4 elements in the array
     * @param off the offset into the vals array
     * @throws RuntimeException if no OpenGL context was current or if any
     * OpenGL-related errors occurred
     */
    public void setConstants(String name, FloatBuffer buf, int off, int count)
            throws RuntimeException {
        int loc = getUniform(name).location;
        if (loc == -1) {
            return;
        }
        context.getGLContext().uniform4fv(loc, count, buf);
    }

    /**
     * Sets the uniform matrix variable of the given name with the provided
     * float array values.
     *
     * @param name the name of the uniform variable to be set
     * @param buf the matrix values to be set
     * @throws RuntimeException if no OpenGL context was current or if any
     * OpenGL-related errors occurred
     */
    public void setMatrix(String name, float buf[]) throws RuntimeException {
        int loc = getUniform(name).location;
        if (loc == -1) {
            return;
        }

        if (currentMatrix == null) {
            currentMatrix = new float[GLContext.NUM_MATRIX_ELEMENTS];
        }

        if (Arrays.equals(currentMatrix, buf) == false) {
            context.getGLContext().uniformMatrix4fv(loc, false, buf);
            System.arraycopy(buf, 0, currentMatrix, 0, buf.length);
        }
    }

    /**
     * Disposes the native resources used by this program object.
     *
     * @throws RuntimeException if no OpenGL context was current or if any
     * OpenGL-related errors occurred
     */
    public void dispose() throws RuntimeException {
        if (programID != 0) {
            disposerRecord.dispose();
            programID = 0;
        }
        valid = false;
    }

    private static class ES2ShaderDisposerRecord implements Disposer.Record {

        private final ES2Context context;
        private int vertexShaderID;
        private int[] fragmentShaderID;
        private int programID;

        private ES2ShaderDisposerRecord(ES2Context context,
                int vertexShaderID,
                int[] fragmentShaderID,
                int programID) {
            this.context = context;
            this.vertexShaderID = vertexShaderID;
            this.fragmentShaderID = fragmentShaderID;
            this.programID = programID;
        }

        public void dispose() {
            if (programID != 0) {
                context.getGLContext().disposeShaders(programID,
                        vertexShaderID, fragmentShaderID);
                programID = vertexShaderID = 0;
                fragmentShaderID = null;
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/impl/Disposer.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.impl;

import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.PhantomReference;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.util.Hashtable;
import java.util.LinkedList;

/**
 * This class is used for registering and disposing the native
 * data associated with Java objects.
 *
 * The object can register itself by calling one of the addRecord
 * methods and providing either the pointer to the native disposal
 * method or a descendant of the Disposer.Record interface with overridden
 * dispose() method.
 *
 * When the object becomes unreachable, the dispose() method
 * of the associated Disposer.Record object will be called.
 */
public class Disposer {

    private static Disposer disposerInstance;
    private static final int WEAK = 0;
    private static final int PHANTOM = 1;
    private static final int SOFT = 2;
    private static int refType = PHANTOM;

    static {
        String type = PrismSettings.refType;
        if (type != null) {
            if (type.equals(&quot;weak&quot;)) {
                refType = WEAK;
                if (PrismSettings.verbose) System.err.println(&quot;Using WEAK refs&quot;);
            } else if (type.equals(&quot;soft&quot;)) {
                refType = SOFT;
                if (PrismSettings.verbose) System.err.println(&quot;Using SOFT refs&quot;);
            } else {
                refType = PHANTOM;
                if (PrismSettings.verbose) System.err.println(&quot;Using PHANTOM refs&quot;);
            }
        }
<A NAME="4"></A>        disposerInstance = new Disposer();
    }

    <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#4',2,'match46-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private final ReferenceQueue queue = new ReferenceQueue();
    private final Hashtable records = new Hashtable();
    private final LinkedList&lt;Record&gt; disposalQueue = new LinkedList&lt;Record&gt;();

    /**
     * Private constructor to prevent outside instantiation.
     */
    private Disposer() {
    }

//    /**
//     * Registers the object and the native data for later disposal.
//     * @param target Object to be registered
//     * @param disposeMethod pointer to the native disposal method
//     * @param pData pointer to the data to be passed to the
//     *              native disposal method
//     */
//    public static void addRecord(Object target,
//                                 long disposeMethod, long pData)
//    {
//        disposerInstance.add(target,
//                             new DefaultDisposerRecord(disposeMethod, pData));
//    }

    /**
     * Registers the target object and the native data for later disposal when
     * the target is unreachable.
     * .
     * @param target Object to be registered
     * @param rec the associated DisposerRecord object
     * @see DisposerRecord
     */
    public st</B></FONT>atic void addRecord(Object target, Disposer.Record rec) {
        disposerInstance.add(target, rec);
    }

    /**
     * Add the object to the disposal queue. The object will be disposed
     * the next time cleanup is called.
     *
     * @param rec the DisposerRecord object to be disposed
     */
    public static void disposeRecord(Disposer.Record rec) {
        disposerInstance.addToDisposalQueue(rec);
    }

    /**
     * Disposes all unreachable objects and all objects in the disposal queue.
     * It first polls the reference queue, calling the dispose method of each
     * unreachable object. It then iterates the list of objects in the
     * disposal queue, calling the dispose method of each object.
     *
     * NOTE: This method must only be called from the Render Thread (the
     * thread on which  the resources were created).
     */
    public static void cleanUp() {
        disposerInstance.disposeUnreachables();
        disposerInstance.processDisposalQueue();
    }

    /**
     * Performs the actual registration of the target object to be disposed.
     * @param target Object to be registered, or if target is an instance
     *               of DisposerTarget, its associated disposer referent
     *               will be the Object that is registered
     * @param rec the associated DisposerRecord object
     * @see DisposerRecord
     */
    synchronized private void add(Object target, Disposer.Record rec) {
        if (target instanceof Disposer.Target) {
            target = ((Disposer.Target)target).getDisposerReferent();
        }
        Reference ref;
        if (refType == PHANTOM) {
            ref = new PhantomReference(target, queue);
        } else if (refType == SOFT) {
            ref = new SoftReference(target, queue);
        } else {
            ref = new WeakReference(target, queue);
        }
        records.put(ref, rec);
    }

    synchronized private void addToDisposalQueue(Disposer.Record rec) {
        disposalQueue.add(rec);
    }

    /**
     * Polls the reference queue to see if there are any unreachable objects
     * to be disposed.  If there is work to be done, this method disposes all
     * unreachable objects in the queue, otherwise it returns immediately.
     */
    synchronized private void disposeUnreachables() {
        Object obj;
        while ((obj = queue.poll()) != null) {
            try {
                ((Reference)obj).clear();
                Disposer.Record rec = (Disposer.Record)records.remove(obj);
                rec.dispose();
                obj = null;
                rec = null;
            } catch (Exception e) {
                System.out.println(&quot;Exception while removing reference: &quot; + e);
                e.printStackTrace();
            }
        }
    }

    synchronized private void processDisposalQueue() {
        // disposalQueue is always empty in the case of Windows using the d3d pipe.
        while (!disposalQueue.isEmpty()) {
            disposalQueue.remove().dispose();
        }
    }

    /**
     * This interface is used to hold the resource to be disposed.
     */
    public static interface Record {
        public void dispose();
    }

    /**
     * This is an interface which should be implemented by
     * the classes which use Disposer.
     */
    public static interface Target {
        /**
         * Returns an object which will be
         * used as the referent in the ReferenceQueue.
         */
        public Object getDisposerReferent();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/j2d/print/J2DPrinterJob.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.j2d.print;

import javafx.print.Collation;
import javafx.print.JobSettings;
import javafx.print.PageLayout;
import javafx.print.PageOrientation;
import javafx.print.PageRange;
import javafx.print.Paper;
import javafx.print.PaperSource;
import javafx.print.PrintColor;
import javafx.print.PrintResolution;
import javafx.print.PrintSides;
import javafx.print.Printer;
import javafx.print.Printer.MarginType;
import javafx.print.PrinterAttributes;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Window;
import javax.print.PrintService;
import javax.print.attribute.HashPrintRequestAttributeSet;
import javax.print.attribute.PrintRequestAttribute;
import javax.print.attribute.PrintRequestAttributeSet;
import javax.print.attribute.ResolutionSyntax;
import javax.print.attribute.Size2DSyntax;
import javax.print.attribute.standard.Chromaticity;
import javax.print.attribute.standard.Copies;
import javax.print.attribute.standard.DialogTypeSelection;
import javax.print.attribute.standard.Media;
import javax.print.attribute.standard.MediaPrintableArea;
import javax.print.attribute.standard.MediaSize;
import javax.print.attribute.standard.MediaSizeName;
import javax.print.attribute.standard.MediaTray;
import javax.print.attribute.standard.OrientationRequested;
import javax.print.attribute.standard.PageRanges;
import javax.print.attribute.standard.PrintQuality;
import javax.print.attribute.standard.PrinterResolution;
import javax.print.attribute.standard.SheetCollate;
import javax.print.attribute.standard.Sides;
import java.awt.*;
import java.awt.print.PageFormat;
import java.awt.print.Pageable;
import java.awt.print.Printable;
import java.awt.print.PrinterException;
import java.util.ArrayList;
import java.util.Set;
import com.sun.glass.ui.Application;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.print.PrintHelper;
import com.sun.javafx.print.PrinterImpl;
import com.sun.javafx.print.PrinterJobImpl;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.stage.WindowHelper;
import com.sun.javafx.tk.TKStage;
import com.sun.javafx.tk.Toolkit;
import com.sun.glass.utils.NativeLibLoader;
import com.sun.prism.impl.PrismSettings;

import com.sun.prism.j2d.PrismPrintGraphics;

import java.lang.reflect.Constructor;
import java.security.AccessController;
import java.security.PrivilegedAction;

public class J2DPrinterJob implements PrinterJobImpl {

    static {
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            String libName = &quot;prism_common&quot;;

            if (PrismSettings.verbose) {
                System.out.println(&quot;Loading Prism common native library ...&quot;);
            }
            NativeLibLoader.loadLibrary(libName);
            if (PrismSettings.verbose) {
                System.out.println(&quot;\tsucceeded.&quot;);
            }
            return null;
        });
    }

    javafx.print.PrinterJob fxPrinterJob;
    java.awt.print.PrinterJob pJob2D;
    javafx.print.Printer fxPrinter;
    J2DPrinter j2dPrinter;

    private JobSettings settings;
    private PrintRequestAttributeSet printReqAttrSet;
    private volatile Object elo = null;

    private static Class onTopClass = null;
    PrintRequestAttribute getAlwaysOnTop(final long id) {
        return AccessController.doPrivileged(
            (PrivilegedAction&lt;PrintRequestAttribute&gt;) () -&gt; {

            PrintRequestAttribute alwaysOnTop = null;
            try {
                if (onTopClass == null) {
                    onTopClass =
                        Class.forName(&quot;javax.print.attribute.standard.DialogOwner&quot;);
                }
                if (id == 0) {
                    Constructor&lt;PrintRequestAttribute&gt;
                         cons = onTopClass.getConstructor();
                    alwaysOnTop = cons.newInstance();
                } else {
                    alwaysOnTop = getAlwaysOnTop(onTopClass, id);
                }
            } catch (Throwable t) {
            }
            return alwaysOnTop;
        });
    }

    private static native
        PrintRequestAttribute getAlwaysOnTop(Class onTopClass, long id);

    public J2DPrinterJob(javafx.print.PrinterJob fxJob) {

        fxPrinterJob = fxJob;
        fxPrinter = fxPrinterJob.getPrinter();
        j2dPrinter = getJ2DPrinter(fxPrinter);
        settings = fxPrinterJob.getJobSettings();
        pJob2D = java.awt.print.PrinterJob.getPrinterJob();
        try {
            pJob2D.setPrintService(j2dPrinter.getService());
        } catch (PrinterException pe) {
        }
        printReqAttrSet = new HashPrintRequestAttributeSet();
        printReqAttrSet.add(DialogTypeSelection.NATIVE);
        j2dPageable = new J2DPageable();
        pJob2D.setPageable(j2dPageable);
    }

    private void setEnabledState(Window owner, boolean state) {
        if (owner == null) {
           return;
        }
        final TKStage stage = WindowHelper.getPeer(owner);
        if (stage == null) { // just in case.
            return;
        }
        Application.invokeAndWait(() -&gt; stage.setEnabled(state));
    }

    public boolean showPrintDialog(Window owner) {

        if (jobRunning || jobDone) {
            return false;
        }

        if (GraphicsEnvironment.isHeadless()) {
            return true;
        }

        if (onTopClass != null) {
            printReqAttrSet.remove(onTopClass);
        }
        if (owner != null) {
            long id = 0L;
            if (PlatformUtil.isWindows()) {
                id = WindowHelper.getPeer(owner).getRawHandle();
            }
            PrintRequestAttribute alwaysOnTop = getAlwaysOnTop(id);
            if (alwaysOnTop != null) {
                printReqAttrSet.add(alwaysOnTop);
            }
        }

        boolean rv = false;
        syncSettingsToAttributes();
        try {
            setEnabledState(owner, false);
            if (!Toolkit.getToolkit().isFxUserThread()) {
                rv = pJob2D.printDialog(printReqAttrSet);
            } else {
                // If we are on the event thread, we need to check whether
                // we are allowed to call a nested event handler.
                if (!Toolkit.getToolkit().canStartNestedEventLoop()) {
                    throw new IllegalStateException(
              &quot;Printing is not allowed during animation or layout processing&quot;);
                }
                rv = showPrintDialogWithNestedLoop(owner);
            }
            if (rv) {
                updateSettingsFromDialog();
            }
        } finally {
            setEnabledState(owner, true);
        }
        return rv;
    }

    private class PrintDialogRunnable implements Runnable {

        public void run() {
            boolean rv = false;
            try {
                rv = pJob2D.printDialog(printReqAttrSet);
            } catch (Exception e) {
            } finally {
                Application.invokeLater(new ExitLoopRunnable(this, rv));
            }
        }
    }

    private boolean showPrintDialogWithNestedLoop(Window owner) {
        PrintDialogRunnable dr = new PrintDialogRunnable();
        Thread prtThread = new Thread(dr, &quot;FX Print Dialog Thread&quot;);
        prtThread.start();
        // the nested event loop will return after the runnable exits.
        Object rv = Toolkit.getToolkit().enterNestedEventLoop(dr);

        boolean rvbool = false;
        try {
            rvbool = ((Boolean)rv).booleanValue();
        } catch (Exception e) {
        }
        return rvbool;
    }

    public boolean showPageDialog(Window owner) {
        if (jobRunning || jobDone) {
            return false;
        }
        if (GraphicsEnvironment.isHeadless()) {
            return true;
        }

        if (onTopClass != null) {
            printReqAttrSet.remove(onTopClass);
        }
        if (owner != null) {
            long id = 0L;
            if (PlatformUtil.isWindows()) {
                id = WindowHelper.getPeer(owner).getRawHandle();
            }
            PrintRequestAttribute alwaysOnTop = getAlwaysOnTop(id);
            if (alwaysOnTop != null) {
                printReqAttrSet.add(alwaysOnTop);
            }
        }

        boolean rv = false;
        syncSettingsToAttributes();
        try {
            setEnabledState(owner, false);
            if (!Toolkit.getToolkit().isFxUserThread()) {
                PageFormat pf = pJob2D.pageDialog(printReqAttrSet);
                rv = pf != null;
            } else {
                // If we are on the event thread, we need to check whether
                // we are allowed to call a nested event handler.
                if (!Toolkit.getToolkit().canStartNestedEventLoop()) {
                    throw new IllegalStateException(
               &quot;Printing is not allowed during animation or layout processing&quot;);
                }
                rv = showPageDialogFromNestedLoop(owner);
            }
        } finally {
            setEnabledState(owner, true);
        }
        if (rv) {
            updateSettingsFromDialog();
        }
        return rv;
    }

    private class PageDialogRunnable implements Runnable {

        public void run() {
            PageFormat pf = null;
            try {
                pf = pJob2D.pageDialog(printReqAttrSet);
            } catch (Exception e) {
            } finally {
                Boolean rv = Boolean.valueOf(pf != null);
                Application.invokeLater(new ExitLoopRunnable(this, rv));
            }
        }
    }

    private boolean showPageDialogFromNestedLoop(Window owner) {

        PageDialogRunnable dr = new PageDialogRunnable();
        Thread prtThread = new Thread(dr, &quot;FX Page Setup Dialog Thread&quot;);
        prtThread.start();
        // the nested event loop will return after the runnable exits.
        Object rv = Toolkit.getToolkit().enterNestedEventLoop(dr);
        boolean rvbool = false;
        try {
            rvbool = ((Boolean)rv).booleanValue();
        } catch (Exception e) {
        }
        return rvbool;
    }

    /*
     * The update-Foo methods here are only used to update the
     * FX JobSettings as a result of changes by user interaction
     * with a print dialog. The new values are stored in the
     * PrintRequestAttributeSet and pulled from there in to the
     * equivalent FX public API JobSettings.
     */
    private void updateJobName() {
        String name =  pJob2D.getJobName();
        if (!name.equals(settings.getJobName())) {
            settings.setJobName(name);
        }
    }
    private void updateCopies() {
        int nCopies = pJob2D.getCopies();
        if (settings.getCopies() != nCopies) {
            settings.setCopies(nCopies);
        }
    }

    private void updatePageRanges() {
        PageRanges ranges = (PageRanges)printReqAttrSet.get(PageRanges.class);
        // JDK sets default to 1,Integer.MAX_VALUE
        // So in this case I think we can just check for non-null and
        // only set if its non-null.
        if (ranges != null) {
            int[][] members = ranges.getMembers();
            if (members.length == 1) {
                PageRange range = new PageRange(members[0][0], members[0][1]);
                settings.setPageRanges(range);
            } else if (members.length &gt; 0) {
                try {
                    ArrayList&lt;PageRange&gt; prList = new ArrayList&lt;PageRange&gt;();
                    int last = 0;
                    for (int i=0; i&lt;members.length;i++) {
                        int s = members[i][0];
                        int e = members[i][1];
                        if (s &lt;= last || e &lt; s) {
                            return;
                        }
                        last = e;
                        prList.add(new PageRange(s, e));
                    }
                    settings.setPageRanges(prList.toArray(new PageRange[0]));
                } catch (Exception e) {
                }
            }
        }
    }

    private void updateSides() {
        Sides sides = (Sides)printReqAttrSet.get(Sides.class);
        if (sides == null) {
            sides = (Sides)j2dPrinter.getService().
                getDefaultAttributeValue(Sides.class);
        }
        if (sides == Sides.ONE_SIDED) {
            settings.setPrintSides(PrintSides.ONE_SIDED);
        } else if (sides == Sides.DUPLEX) {
            settings.setPrintSides(PrintSides.DUPLEX);
        } else if (sides == Sides.TUMBLE) {
            settings.setPrintSides(PrintSides.TUMBLE);
        }
    }

    /* If the attribute set has an explicit setting for
     * collation, then its been set by the user at some point,
     * even if the current value is the printer default.
     * If there is no value for collation in the attribute set,
     * it means that we are u  sing the printer default.
     */
    private void updateCollation() {
        SheetCollate collate =
            (SheetCollate)printReqAttrSet.get(SheetCollate.class);
        if (collate == null) {
            collate = j2dPrinter.getDefaultSheetCollate();
        }
        if (collate == SheetCollate.UNCOLLATED) {
            settings.setCollation(Collation.UNCOLLATED);
        } else {
            settings.setCollation(Collation.COLLATED);
        }
    }

    private void updateColor() {
        Chromaticity color =
            (Chromaticity)printReqAttrSet.get(Chromaticity.class);
        if (color == null) {
            color = j2dPrinter.getDefaultChromaticity();
        }
        if (color == Chromaticity.COLOR) {
            settings.setPrintColor(PrintColor.COLOR);
        } else {
            settings.setPrintColor(PrintColor.MONOCHROME);
        }
    }

    private void updatePrintQuality() {
        PrintQuality quality =
            (PrintQuality)printReqAttrSet.get(PrintQuality.class);
        if (quality == null) {
            quality = j2dPrinter.getDefaultPrintQuality();
        }

        if (quality == PrintQuality.DRAFT) {
            settings.
                setPrintQuality(javafx.print.PrintQuality.DRAFT);
        } else if (quality == PrintQuality.HIGH) {
            settings.
                setPrintQuality(javafx.print.PrintQuality.HIGH);
        } else {
            settings.
                setPrintQuality(javafx.print.PrintQuality.NORMAL);
        }
    }

    private void updatePrintResolution() {
        PrinterResolution res =
            (PrinterResolution)printReqAttrSet.get(PrinterResolution.class);
        if (res == null) {
            res = j2dPrinter.getDefaultPrinterResolution();
        }
        int cfr = res.getCrossFeedResolution(ResolutionSyntax.DPI);
        int fr = res.getFeedResolution(ResolutionSyntax.DPI);
        settings.setPrintResolution(PrintHelper.createPrintResolution(cfr, fr));
    }

    private void updatePageLayout() {
        Media media = (Media)printReqAttrSet.get(Media.class);
        Paper paper = j2dPrinter.getPaperForMedia(media);
        OrientationRequested o = (OrientationRequested)
            printReqAttrSet.get(OrientationRequested.class);
        PageOrientation orient = J2DPrinter.reverseMapOrientation(o);
        MediaPrintableArea mpa =
            (MediaPrintableArea)printReqAttrSet.get(MediaPrintableArea.class);
        PageLayout newLayout;
        if (mpa == null) {
            newLayout = fxPrinter.createPageLayout(paper, orient,
                                                   MarginType.DEFAULT);
        } else {
            double pWid = paper.getWidth();
            double pHgt = paper.getHeight();
            int INCH = MediaPrintableArea.INCH;
            double mpaX = mpa.getX(INCH) * 72;
            double mpaY = mpa.getY(INCH) * 72;
            double mpaW = mpa.getWidth(INCH) * 72;
            double mpaH = mpa.getHeight(INCH) * 72;
            double lm=0, rm=0, tm=0, bm=0;
            switch (orient) {
            case PORTRAIT:
                lm = mpaX;
                rm = pWid - mpaX - mpaW;
                tm = mpaY;
                bm = pHgt - mpaY - mpaH;
                break;
            case REVERSE_PORTRAIT:
                lm = pWid - mpaX - mpaW;
                rm = mpaX;
                tm = pHgt - mpaY - mpaH;
                bm = mpaY;
                break;
            case LANDSCAPE:
                lm = mpaY;
                rm = pHgt - mpaY - mpaH;
                tm = pWid - mpaX - mpaW;
                bm = mpaX;
                break;
            case REVERSE_LANDSCAPE:
                lm = pHgt - mpaY - mpaH;
                tm = mpaX;
                rm = mpaY;
                bm = pWid - mpaX - mpaW;
                break;
            }
            if (Math.abs(lm) &lt; 0.01) lm = 0;
            if (Math.abs(rm) &lt; 0.01) rm = 0;
            if (Math.abs(tm) &lt; 0.01) tm = 0;
            if (Math.abs(bm) &lt; 0.01) bm = 0;
            newLayout = fxPrinter.createPageLayout(paper, orient,
                                                   lm, rm, tm, bm);
        }
        settings.setPageLayout(newLayout);
    }

    private void updatePaperSource() {
        Media m = (Media)printReqAttrSet.get(Media.class);
        if (m instanceof MediaTray) {
            PaperSource s = j2dPrinter.getPaperSource((MediaTray)m);
            if (s != null) {
                settings.setPaperSource(s);
            }
        }
    }

    private Printer getFXPrinterForService(PrintService service) {
        Set&lt;Printer&gt; printerSet = Printer.getAllPrinters();
        for (Printer p : printerSet) {
            J2DPrinter p2d = (J2DPrinter)PrintHelper.getPrinterImpl(p);
            PrintService s = p2d.getService();
            if (s.equals(service)) {
                return p;
            }
        }
        return fxPrinter; // current printer.
    }

    public void setPrinterImpl(PrinterImpl impl) {
        j2dPrinter = (J2DPrinter)impl;
        fxPrinter = j2dPrinter.getPrinter();
        try {
            pJob2D.setPrintService(j2dPrinter.getService());
        } catch (PrinterException pe) {
        }
    }

    public PrinterImpl getPrinterImpl() {
        return j2dPrinter;
    }

    private J2DPrinter getJ2DPrinter(Printer printer) {
        return (J2DPrinter)PrintHelper.getPrinterImpl(printer);
    }

    public Printer getPrinter() {
        return fxPrinter;
    }

    public void setPrinter(Printer printer) {
        fxPrinter = printer;
        j2dPrinter = getJ2DPrinter(printer);
        try {
            pJob2D.setPrintService(j2dPrinter.getService());
        } catch (PrinterException pe) {
        }
    }

    private void updatePrinter() {
        PrintService currService = j2dPrinter.getService();
        PrintService jobService = pJob2D.getPrintService();
        if (currService.equals(jobService)) {
            return; // no change
        }
        Printer newFXPrinter = getFXPrinterForService(jobService);
        // The public setPrinter call also updates the job to be valid for
        // the new printer. Any old values not supported will be updated
        // to supported values. If we do that, then apply the new user
        // settings, any listener will see both sets of changes.
        // Its best to just see the single transition.
        fxPrinterJob.setPrinter(newFXPrinter);
    }

    private void updateSettingsFromDialog() {
        updatePrinter();
        updateJobName();
        updateCopies();
        updatePageRanges();
        updateSides();
        updateCollation();
        updatePageLayout();
        updatePaperSource();
        updateColor();
        updatePrintQuality();
        updatePrintResolution();
    }

    private void syncSettingsToAttributes() {
        syncJobName();
        syncCopies();
<A NAME="32"></A>        syncPageRanges();
        syncSides();
        syncCollation();
        <FONT color="#82cafa"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#32',2,'match46-top.html#32',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>syncPageLayout();
        syncPaperSource();
        syncColor();
        syncPrintQuality();
        syncPrintResolution();
    }

    private void syncJobName() {
        pJob2D.setJobName(settings.getJobName());
    }

    private void syncCopies() {
        pJob2D.setCopies</B></FONT>(settings.getCopies());
        printReqAttrSet.add(new Copies(settings.getCopies()));
    }

    private void syncPageRanges() {
        printReqAttrSet.remove(PageRanges.class);
        PageRange[] prArr = settings.getPageRanges();
        if (prArr != null &amp;&amp; prArr.length&gt;0) {
            int len = prArr.length;
            int[][] ranges = new int[len][2];
            for (int i=0;i&lt;len;i++) {
                ranges[i][0] = prArr[i].getStartPage();
                ranges[i][1] = prArr[i].getEndPage();
            }
            printReqAttrSet.add(new PageRanges(ranges));
        }
    }

    private void syncSides() {
        Sides j2dSides = Sides.ONE_SIDED;
        PrintSides sides = settings.getPrintSides();
        if (sides == PrintSides.DUPLEX) {
            j2dSides = Sides.DUPLEX;
        } else if (sides == PrintSides.TUMBLE) {
            j2dSides = Sides.TUMBLE;
        }
        printReqAttrSet.add(j2dSides);
    }

    private void syncCollation() {
        if (settings.getCollation() == Collation.UNCOLLATED) {
            printReqAttrSet.add(SheetCollate.UNCOLLATED);
        } else {
            printReqAttrSet.add(SheetCollate.COLLATED);
        }

    }

    private void syncPageLayout() {
        PageLayout layout = settings.getPageLayout();
        PageOrientation orient = layout.getPageOrientation();
        printReqAttrSet.add(J2DPrinter.mapOrientation(orient));
        double pWid = layout.getPaper().getWidth();
        double pHgt = layout.getPaper().getHeight();
        float widthInInches = (float)(pWid/72.0);
        float heightInInches = (float)(pHgt/72.0);
        MediaSizeName media = MediaSize.findMedia(widthInInches,
                                                  heightInInches,
                                                  Size2DSyntax.INCH);
        if (media == null) {
            media = MediaSizeName.NA_LETTER;
        }
        printReqAttrSet.add(media);
        double ix=0, iy=0, iw=pWid, ih=pHgt;
        switch (orient) {
        case PORTRAIT:
            ix = layout.getLeftMargin();
            iy = layout.getTopMargin();
            iw = pWid - ix - layout.getRightMargin();
            ih = pHgt - iy - layout.getBottomMargin();
            break;
        case REVERSE_PORTRAIT:
            ix = layout.getRightMargin();
            iy = layout.getBottomMargin();
            iw = pWid - ix - layout.getLeftMargin();
            ih = pHgt - iy - layout.getTopMargin();
            break;
        case LANDSCAPE:
            ix = layout.getBottomMargin();
            iy = layout.getLeftMargin();
            iw = pWid - ix - layout.getTopMargin();
            ih = pHgt - iy - layout.getRightMargin();
            break;
        case REVERSE_LANDSCAPE:
            ix = layout.getTopMargin();
            iy = layout.getRightMargin();
            iw = pWid - ix - layout.getBottomMargin();
            ih = pHgt - iy - layout.getLeftMargin();
        }
        ix /= 72.0;
        iy /= 72.0;
        ih /= 72.0;
        iw /= 72.0;
        MediaPrintableArea mpa =
            new MediaPrintableArea((float)ix, (float)iy,
                                   (float)iw, (float)ih,
                                   MediaPrintableArea.INCH);
        printReqAttrSet.add(mpa);
    }

    private void syncPaperSource() {
        Media m = (Media)printReqAttrSet.get(Media.class);
        if (m != null &amp;&amp; m instanceof MediaTray) {
            printReqAttrSet.remove(Media.class);
        }
        PaperSource source = settings.getPaperSource();
        if (!source.equals(j2dPrinter.defaultPaperSource())) {
            MediaTray tray = j2dPrinter.getTrayForPaperSource(source);
            if (tray != null) {
                printReqAttrSet.add(tray);
            }
        }
    }

    private void syncColor() {
        if (settings.getPrintColor() == PrintColor.MONOCHROME) {
            printReqAttrSet.add(Chromaticity.MONOCHROME);
        } else {
            printReqAttrSet.add(Chromaticity.COLOR);
        }
    }

    private void syncPrintQuality() {
        javafx.print.PrintQuality
            quality = settings.getPrintQuality();
        PrintQuality j2DQuality;
        if (quality == javafx.print.PrintQuality.DRAFT) {
            j2DQuality = PrintQuality.DRAFT;
        } else if (quality == javafx.print.PrintQuality.HIGH) {
          j2DQuality = PrintQuality.HIGH;
        } else {
            j2DQuality = PrintQuality.NORMAL;
        }
        printReqAttrSet.add(j2DQuality);
    }

    private void syncPrintResolution() {
        /* An unsupported resolution results in incorrect scaling by J2D, so
         * remove any unsupported value, and only replace with a supported value.
         */
        PrintService ps = pJob2D.getPrintService();
        if (!ps.isAttributeCategorySupported(PrinterResolution.class)) {
            printReqAttrSet.remove(PrinterResolution.class);
            return;
        }
        PrinterResolution pres =
            (PrinterResolution)printReqAttrSet.get(PrinterResolution.class);
        if (pres != null &amp;&amp; !ps.isAttributeValueSupported(pres, null, null)) {
            printReqAttrSet.remove(PrinterResolution.class);
        };

        // Any resolution is now at least known to be supported for this device.
        PrintResolution res = settings.getPrintResolution();
        if (res == null) {
            return;
        }
        int cfRes = res.getCrossFeedResolution();
        int fRes = res.getFeedResolution();
        pres = new PrinterResolution(cfRes, fRes, ResolutionSyntax.DPI);
        if (!ps.isAttributeValueSupported(pres, null, null)) {
            return;
        }
        // We have validated its a supported value, so add it.
        printReqAttrSet.add(pres);
    }

    public PageLayout validatePageLayout(PageLayout pageLayout) {
        boolean needsNewLayout = false;
        PrinterAttributes caps = fxPrinter.getPrinterAttributes();
        Paper p = pageLayout.getPaper();
        if (!caps.getSupportedPapers().contains(p)) {
            needsNewLayout = true;
            p = caps.getDefaultPaper();
        }
        PageOrientation o = pageLayout.getPageOrientation();
        if (!caps.getSupportedPageOrientations().contains(o)) {
            needsNewLayout = true;
            o = caps.getDefaultPageOrientation();
        }
        if (needsNewLayout) {
            pageLayout = fxPrinter.createPageLayout(p, o, MarginType.DEFAULT);
        }
        return pageLayout;
    }

    private boolean jobRunning = false;
    private boolean jobError = false;
    private boolean jobDone = false;
    private J2DPageable j2dPageable = null;

    /*
     * Permissions were already checked when creating the job,
     * and when setting output file, but this is a final check
     * to be made before we start the underlying native job.
     */
    private void checkPermissions() {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkPrintJobAccess();
        }
    }

    /*
     * 2D uses a call back model. So the 2D PrinterJob needs to run
     * on a different thread than the one that the FX app uses.
     * This gets really interesting if the FX Node is attached to a
     * scene, as you are only supposed to update it on the FX thread
     * and the PG code can only access it during sync.
     */
    public boolean print(PageLayout pageLayout, Node node) {
        if (Toolkit.getToolkit().isFxUserThread()) {
            // If we are on the event thread, we need to check whether we are
            // allowed to call a nested event handler.
            if (!Toolkit.getToolkit().canStartNestedEventLoop()) {
                throw new IllegalStateException(&quot;Printing is not allowed during animation or layout processing&quot;);
            }
        }

        if (jobError || jobDone) {
            return false;
        }

        if (!jobRunning) {
            checkPermissions();
            syncSettingsToAttributes();
            PrintJobRunnable runnable = new PrintJobRunnable();
            Thread prtThread = new Thread(runnable, &quot;Print Job Thread&quot;);
            prtThread.start();
            jobRunning = true;
        }
        try {
            j2dPageable.implPrintPage(pageLayout, node);
        } catch (Throwable t) {
            if (com.sun.prism.impl.PrismSettings.debug) {
                System.err.println(&quot;printPage caught exception.&quot;);
                t.printStackTrace();
            }
            jobError = true;
            jobDone = true;
        }
        return !jobError;
    }

    private class PrintJobRunnable implements Runnable {

        public void run() {

            try {
                pJob2D.print(printReqAttrSet);
                jobDone = true;
            } catch (Throwable t) { /* subsumes declared PrinterException */
                if (com.sun.prism.impl.PrismSettings.debug) {
                    System.err.println(&quot;print caught exception.&quot;);
                    t.printStackTrace();
                }
                jobError = true;
                jobDone = true;
            }
            /*
             * If the job ends because its reached a page range limit
             * rather than calling getPage() we need to exit the nested loop.
             */
            if (elo != null) {
                Application.invokeLater(new ExitLoopRunnable(elo, null));
            }
        }
    }

    static class LayoutRunnable implements Runnable {
        PageInfo pageInfo;

        LayoutRunnable(PageInfo info) {
            pageInfo = info;
        }

        public void run() {
            if (pageInfo.tempScene &amp;&amp; pageInfo.root.getScene() == null) {
                new Scene(pageInfo.root);
            }
            NodeHelper.layoutNodeForPrinting(pageInfo.root);
        }
    }

    static class ClearSceneRunnable implements Runnable {
        PageInfo pageInfo;

        ClearSceneRunnable(PageInfo info) {
            pageInfo = info;
        }

        public void run() {
            pageInfo.clearScene();
        }
    }

    private static class PageInfo {

        private PageLayout pageLayout;
        private Node node;
        private Parent root;
        private Node topNode;
        private Group group;
        private boolean tempGroup;
        private boolean tempScene;
        private boolean sceneInited;

        PageInfo(PageLayout pageLayout, Node node) {
            this.pageLayout = pageLayout;
            this.node = node;
        }

        Node getNode() {
            initScene();
            return node;
        }

        PageLayout getPageLayout() {
            return pageLayout;
        }

        /*
         * There are 4 scenarios here.
         * 1. We are passed the root node of a Scene.
         * 2. We are passed a child node of a Scene, but not the root
         * 3. We are passed a root node (no parent) but its not attached
         * to a Scene.
         * 4. We are passed a child node, but its not part of a Scene.
         * In addition we may be called on the FX thread, or not.
         * The code here is trying to make all of these work without
         * the application needing to do anything special, and hopefully
         * without affecting the application.
         * The application should not be surprised if we request layout for it,
         * since we can't display or print an unlaid out hiearchy.
         *
         * If this is the FX thread, then we can do everything directly.
         * If not, we must add the node to a scene (if needed) and
         * request layout on another thread.
         * I am assuming here that layout will be a quick no-op if
         * everything is already laid out.
         * Eventually all of this should be able to be performed on any
         * thread, and without attaching to a scene, so this is largely
         * workaround. One part I'm not so sure about is whether it
         * will ever be the case that being passed a node that is part
         * of a hierarchy, but not its root, will be able to be laid out
         * directly, or if you need to traverse to the root.
         */
        void initScene() {
            if (sceneInited) {
               return;
            }
            if (node.getScene() == null) {
                tempScene = true;
                Node topNode = node;
                while (topNode.getParent() != null) {
                    topNode = topNode.getParent();
                }
                if (topNode instanceof Group) {
                    group = (Group)topNode;
                } else {
                    tempGroup = true;
                    group = new Group();
                    group.getChildren().add(topNode);
                }
                root = group;
            } else {
                root = node.getScene().getRoot();
            }
            if (Toolkit.getToolkit().isFxUserThread()) {
                if (tempScene &amp;&amp; root.getScene() == null) {
                    new Scene(root); // don't need to keep the scene variable
                }
                NodeHelper.layoutNodeForPrinting(root);
            } else {
                Application.invokeAndWait(new LayoutRunnable(this));
            }
            sceneInited = true;
        }

        private void clearScene() {
            if (tempGroup) {
                group.getChildren().removeAll(root);
            }
            tempGroup = false;
            tempScene = false;
            root = null;
            group = null;
            topNode = null;
            sceneInited = false;
        }
    }

    private Object monitor = new Object();

    static class ExitLoopRunnable implements Runnable {
        Object elo, rv;

        ExitLoopRunnable(Object elo, Object rv) {
            this.elo = elo;
            this.rv = rv;
        }

        public void run() {
            Toolkit.getToolkit().exitNestedEventLoop(elo, rv);
        }
    }

    private class J2DPageable implements Pageable, Printable {

        private volatile boolean pageDone;

        private int currPageIndex = -1;

        private volatile PageInfo newPageInfo = null;
        private PageInfo currPageInfo;
        private PageFormat currPageFormat;


        private boolean waitForNextPage(int pageIndex) {

            if (elo != null &amp;&amp; currPageInfo != null) {
                Application.invokeLater(new ExitLoopRunnable(elo, null));
            }

            if (currPageInfo != null) {
                if (Toolkit.getToolkit().isFxUserThread()) {
                    currPageInfo.clearScene();
                } else {
                    Application.
                        invokeAndWait(new ClearSceneRunnable(currPageInfo));
                }
            }
            currPageInfo = null;
            pageDone = true;
            synchronized (monitor) {
                if (newPageInfo == null) {
                    monitor.notify(); // page is printed and no new page to print
                }
                while (newPageInfo == null &amp;&amp; !jobDone &amp;&amp; !jobError) {
                    try {
                        monitor.wait(1000);
                    } catch (InterruptedException e) {
                    }
                }
            }
            if (jobDone || jobError) {
                return false;
            }
            currPageInfo = newPageInfo;
            newPageInfo = null;
            currPageIndex = pageIndex;
            currPageFormat = getPageFormatFromLayout(currPageInfo.getPageLayout());
            return true;
        }

        private PageFormat getPageFormatFromLayout(PageLayout layout) {
            java.awt.print.Paper paper = new java.awt.print.Paper();
            double pWid = layout.getPaper().getWidth();
            double pHgt = layout.getPaper().getHeight();
            double ix=0, iy=0, iw=pWid, ih=pHgt;
            PageOrientation orient = layout.getPageOrientation();
            switch (orient) {
            case PORTRAIT:
                ix = layout.getLeftMargin();
                iy = layout.getTopMargin();
                iw = pWid - ix - layout.getRightMargin();
                ih = pHgt - iy - layout.getBottomMargin();
                break;
            case REVERSE_PORTRAIT:
                ix = layout.getRightMargin();
                iy = layout.getBottomMargin();
                iw = pWid - ix - layout.getLeftMargin();
                ih = pHgt - iy - layout.getTopMargin();
                break;
            case LANDSCAPE:
                ix = layout.getBottomMargin();
                iy = layout.getLeftMargin();
                iw = pWid - ix - layout.getTopMargin();
                ih = pHgt - iy - layout.getRightMargin();
                break;
            case REVERSE_LANDSCAPE:
                ix = layout.getTopMargin();
                iy = layout.getRightMargin();
                iw = pWid - ix - layout.getBottomMargin();
                ih = pHgt - iy - layout.getLeftMargin();
            }
            paper.setSize(pWid, pHgt);
            paper.setImageableArea(ix, iy, iw, ih);
            PageFormat format = new PageFormat();
            format.setOrientation(J2DPrinter.getOrientID(orient));
            format.setPaper(paper);
            return format;
        }

        private boolean getPage(int pageIndex) {
            if (pageIndex == currPageIndex) {
                return true;
            }
            boolean nextPage = false;
            if (pageIndex &gt; currPageIndex) {
                nextPage = waitForNextPage(pageIndex);
            }
            return nextPage;
        }

        public int print(Graphics g, PageFormat pf, int pageIndex) {
            if (jobError || jobDone || !getPage(pageIndex)) {
                return Printable.NO_SUCH_PAGE;
            }
            int x = (int)pf.getImageableX();
            int y = (int)pf.getImageableY();
            int w = (int)pf.getImageableWidth();
            int h = (int)pf.getImageableHeight();
            Node appNode = currPageInfo.getNode();
            g.translate(x, y);
            printNode(appNode, g, w, h);
            return Printable.PAGE_EXISTS;
        }

        private void printNode(Node node, Graphics g, int w, int h) {
            PrismPrintGraphics ppg =
                    new PrismPrintGraphics((Graphics2D) g, w, h);
            NGNode pgNode = NodeHelper.getPeer(node);
            boolean errored = false;
            try {
                pgNode.render(ppg);
            } catch (Throwable t) {
                if (com.sun.prism.impl.PrismSettings.debug) {
                    System.err.println(&quot;printNode caught exception.&quot;);
                    t.printStackTrace();
                }
                errored = true;
            }
            ppg.getResourceFactory()
                    .getTextureResourcePool()
                    .freeDisposalRequestedAndCheckResources(errored);
        }

        public Printable getPrintable(int pageIndex) {
            getPage(pageIndex);
            return this;
        }

        public PageFormat getPageFormat(int pageIndex) {
            getPage(pageIndex);
            return currPageFormat;
        }

        /*
         * Since we return unknown number of pages, then
         * the behaviour must be that we can only signal
         * end of the job by returning NO_SUCH_PAGE from
         * the print(..) method.
         */
        public int getNumberOfPages() {
            return Pageable.UNKNOWN_NUMBER_OF_PAGES;
        }

        /*
         * Executed on the application's thread.
         * Messages over to the printing thread.
         */
        private void implPrintPage(PageLayout pageLayout, Node node) {

            /* The public API printPage() is synchronized, so we know
             * that the app can't call it from 2 threads at the same
             * time, not that this is encouraged either.
             * Therefore when we are in this code, we know that any
             * previous page rendering has completed.
             * We also know that this means the app can't have 'queued up'
             * pages.
             * So, when we are in here, we know that the app is providing
             * the info for the next page.
             */
            pageDone = false;
            synchronized (monitor) {
                newPageInfo = new PageInfo(pageLayout, node);
                monitor.notify();
            }
            if (Toolkit.getToolkit().isFxUserThread()) {
                elo = new Object();
                Toolkit.getToolkit().enterNestedEventLoop(elo);
                elo = null;
            } else {
                while (!pageDone &amp;&amp; !jobDone &amp;&amp; !jobError) {
                    synchronized (monitor) {
                        try {
                            if (!pageDone) {
                                monitor.wait(1000);
                            }
                        } catch (InterruptedException e) {
                        }
                    }
                }
            }
        }

    } /* END J2DPageable class */


    public boolean endJob() {
        if (jobRunning &amp;&amp; !jobDone &amp;&amp; !jobError) {
            jobDone = true;
            try {
                synchronized (monitor) {
                    monitor.notify();
                    return jobDone;
                }
            } catch (IllegalStateException e) {
                if (com.sun.prism.impl.PrismSettings.debug) {
                    System.err.println(&quot;Internal Error &quot; + e);
                }
            }
        } else {
            return jobDone &amp;&amp; !jobError;
        }
        return jobDone;
    }

    public void cancelJob() {
        if (!pJob2D.isCancelled()) {
            pJob2D.cancel();
        }
        jobDone = true;
        if (jobRunning) {
            jobRunning = false;
            try {
                synchronized (monitor) {
                    monitor.notify();
                }
            } catch (IllegalStateException e) {
                if (com.sun.prism.impl.PrismSettings.debug) {
                    System.err.println(&quot;Internal Error &quot; + e);
                }
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/Camera.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.geometry.Point2D;
import javafx.geometry.Point3D;
import javafx.scene.transform.Transform;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.BoxBounds;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.javafx.scene.CameraHelper;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.transform.TransformHelper;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.logging.PlatformLogger;


/**
 * Base class for a camera used to render a scene.
 * The camera defines the mapping of the scene coordinate space onto the window.
 * Camera is an abstract class with two concrete subclasses:
 * {@link ParallelCamera} and {@link PerspectiveCamera}.
 *
 * &lt;p&gt;
 * The default camera is positioned in the scene such that its projection plane
 * in the scene coordinate space is at Z = 0, and it is looking into the screen in
 * the positive Z direction. The distance in Z from the camera to the projection
 * plane is determined by the {@code width} and {@code height} of the Scene to
 * which it is attached and its {@code fieldOfView}.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The {@code nearClip} and {@code farClip} of this camera are specified in the
 * eye coordinate space. This space is defined such that the eye is at its
 * origin and the projection plane is one unit in front of the eye in the
 * positive Z direction.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The following pseudo code is the math used to compute the near and far clip
 * distances in the scene coordinate space:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * final double tanOfHalfFOV = Math.tan(Math.toRadians(FOV) / 2.0);
 * final double halfHeight = HEIGHT / 2;
 * final double focalLenght = halfHeight / tanOfHalfFOV;
 * final double eyePositionZ = -1.0 * focalLenght;
 * final double nearClipDistance = focalLenght * NEAR + eyePositionZ;
 * final double farClipDistance = focalLenght * FAR + eyePositionZ;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * where {@code FOV} is {@code fieldOfView} in degrees,
 * {@code NEAR} is {@code nearClip} specified in eye space,
 * and {@code FAR} is {@code farClip} specified in eye space.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Note: Since the ParallelCamera class has no {@code fieldOfView} property, a
 * 30 degrees vertical field of view is used.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Note: For the case of a PerspectiveCamera where the fixedEyeAtCameraZero
 * attribute is true, the scene coordinate space is normalized in order to fit
 * into the view frustum (see {@link PerspectiveCamera} for more details). In
 * this mode, the eye coordinate space is the same as this Camera node's local
 * coordinate space. Hence the conversion formula mentioned above is not used.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * An application should not extend the Camera class directly. Doing so may lead to
 * an UnsupportedOperationException being thrown.
 * &lt;/p&gt;
 *
 * @since JavaFX 2.0
 */
public abstract class Camera extends Node {
    static {
         // This is used by classes in different packages to get access to
         // private and package private methods.
        CameraHelper.setCameraAccessor(new CameraHelper.CameraAccessor() {
            @Override
            public void doMarkDirty(Node node, DirtyBits dirtyBit) {
                ((Camera) node).doMarkDirty(dirtyBit);
            }

            @Override
            public void doUpdatePeer(Node node) {
                ((Camera) node).doUpdatePeer();
            }

            @Override
            public BaseBounds doComputeGeomBounds(Node node,
                    BaseBounds bounds, BaseTransform tx) {
                return ((Camera) node).doComputeGeomBounds(bounds, tx);
            }

            @Override
            public boolean doComputeContains(Node node, double localX, double localY) {
                return ((Camera) node).doComputeContains(localX, localY);
            }

            @Override
            public Point2D project(Camera camera, Point3D p) {
                return camera.project(p);
            }

            @Override
            public Point2D pickNodeXYPlane(Camera camera, Node node, double x, double y) {
                return camera.pickNodeXYPlane(node, x, y);
            }

            @Override
            public Point3D pickProjectPlane(Camera camera, double x, double y) {
                return camera.pickProjectPlane(x, y);
            }
        });
    }

    private Affine3D localToSceneTx = new Affine3D();

    {
        // To initialize the class helper at the begining each constructor of this class
        CameraHelper.initHelper(this);
    }

    protected Camera() {
        InvalidationListener dirtyTransformListener = observable
                -&gt; NodeHelper.markDirty(this, DirtyBits.NODE_CAMERA_TRANSFORM);

        this.localToSceneTransformProperty().addListener(dirtyTransformListener);
        // if camera is removed from scene it needs to stop using its transforms
        this.sceneProperty().addListener(dirtyTransformListener);
    }

    // NOTE: farClipInScene and nearClipInScene are valid only if there is no rotation
    private double farClipInScene;
    private double nearClipInScene;

    // only one of them can be non-null at a time
    private Scene ownerScene = null;
    private SubScene ownerSubScene = null;

    private GeneralTransform3D projViewTx = new GeneralTransform3D();
    private GeneralTransform3D projTx = new GeneralTransform3D();
    private Affine3D viewTx = new Affine3D();
    private double viewWidth = 1.0;
    private double viewHeight = 1.0;
    private Vec3d position = new Vec3d();

    private boolean clipInSceneValid = false;
    private boolean projViewTxValid = false;
    private boolean localToSceneValid = false;
    private boolean sceneToLocalValid = false;

    double getFarClipInScene() {
        updateClipPlane();
        return farClipInScene;
    }

    double getNearClipInScene() {
        updateClipPlane();
        return nearClipInScene;
    }

    private void updateClipPlane() {
        if (!clipInSceneValid) {
            final Transform localToSceneTransform = getLocalToSceneTransform();
            nearClipInScene = localToSceneTransform.transform(0, 0, getNearClip()).getZ();
            farClipInScene = localToSceneTransform.transform(0, 0, getFarClip()).getZ();
            clipInSceneValid = true;
        }
    }

    /**
     * An affine transform that holds the computed scene-to-local transform.
     * It is used to convert node to camera coordinate when rotation is involved.
     */
    private Affine3D sceneToLocalTx = new Affine3D();

    Affine3D getSceneToLocalTransform() {
        if (!sceneToLocalValid) {
            sceneToLocalTx.setTransform(getCameraTransform());
            try {
                sceneToLocalTx.invert();
            } catch (NoninvertibleTransformException ex) {
                String logname = Camera.class.getName();
                PlatformLogger.getLogger(logname).severe(&quot;getSceneToLocalTransform&quot;, ex);
                sceneToLocalTx.setToIdentity();
            }
            sceneToLocalValid = true;
        }

        return sceneToLocalTx;
    }

    /**
     * Specifies the distance from the eye of the near clipping plane of
     * this {@code Camera} in the eye coordinate space.
     * Objects closer to the eye than {@code nearClip} are not drawn.
     * {@code nearClip} is specified as a value greater than zero. A value less
     * than or equal to zero is treated as a very small positive number.
     *
     * @defaultValue 0.1
     * @since JavaFX 8.0
     */
    private DoubleProperty nearClip;

    public final void setNearClip(double value){
        nearClipProperty().set(value);
    }

    public final double getNearClip() {
        return nearClip == null ? 0.1 : nearClip.get();
    }

    public final DoubleProperty nearClipProperty() {
        if (nearClip == null) {
            nearClip = new SimpleDoubleProperty(Camera.this, &quot;nearClip&quot;, 0.1) {
                @Override
                protected void invalidated() {
                    clipInSceneValid = false;
                    NodeHelper.markDirty(Camera.this, DirtyBits.NODE_CAMERA);
                }
            };
        }
        return nearClip;
    }

    /**
     * Specifies the distance from the eye of the far clipping plane of
     * this {@code Camera} in the eye coordinate space.
     * Objects farther away from the eye than {@code farClip} are not
     * drawn.
     * {@code farClip} is specified as a value greater than {@code nearClip}.
     * A value less than or equal to {@code nearClip} is treated as
     * {@code nearClip} plus a very small positive number.
     *
     * @defaultValue 100.0
     * @since JavaFX 8.0
     */
    private DoubleProperty farClip;

    public final void setFarClip(double value){
        farClipProperty().set(value);
    }

    public final double getFarClip() {
        return farClip == null ? 100.0 : farClip.get();
    }

    public final DoubleProperty farClipProperty() {
        if (farClip == null) {
            farClip = new SimpleDoubleProperty(Camera.this, &quot;farClip&quot;, 100.0) {
                @Override
                protected void invalidated() {
                    clipInSceneValid = false;
                    NodeHelper.markDirty(Camera.this, DirtyBits.NODE_CAMERA);
                }
            };
        }
        return farClip;
    }

    Camera copy() {
        return this;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        NGCamera peer = getPeer();
        if (!NodeHelper.isDirtyEmpty(this)) {
            if (isDirty(DirtyBits.NODE_CAMERA)) {
                peer.setNearClip((float) getNearClip());
                peer.setFarClip((float) getFarClip());
                peer.setViewWidth(getViewWidth());
                peer.setViewHeight(getViewHeight());
            }
            if (isDirty(DirtyBits.NODE_CAMERA_TRANSFORM)) {
                // TODO: 3D - For now, we are treating the scene as world.
                // This may need to change for the fixed eye position case.
                peer.setWorldTransform(getCameraTransform());
            }

            peer.setProjViewTransform(getProjViewTransform());

            position = computePosition(position);
            getCameraTransform().transform(position, position);
            peer.setPosition(position);
        }
    }

    void setViewWidth(double width) {
        this.viewWidth = width;
        NodeHelper.markDirty(this, DirtyBits.NODE_CAMERA);
    }

    double getViewWidth() {
        return viewWidth;
    }

    void setViewHeight(double height) {
        this.viewHeight = height;
        NodeHelper.markDirty(this, DirtyBits.NODE_CAMERA);
    }

    double getViewHeight() {
        return viewHeight;
    }

    void setOwnerScene(Scene s) {
        if (s == null) {
            ownerScene = null;
        } else if (s != ownerScene) {
            if (ownerScene != null || ownerSubScene != null) {
                throw new IllegalArgumentException(this
                        + &quot;is already set as camera in other scene or subscene&quot;);
            }
            ownerScene = s;
            markOwnerDirty();
        }
    }

    void setOwnerSubScene(SubScene s) {
        if (s == null) {
            ownerSubScene = null;
        } else if (s != ownerSubScene) {
            if (ownerScene != null || ownerSubScene != null) {
                throw new IllegalArgumentException(this
                        + &quot;is already set as camera in other scene or subscene&quot;);
            }
            ownerSubScene = s;
            markOwnerDirty();
        }
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doMarkDirty(DirtyBits dirtyBit) {
        if (dirtyBit == DirtyBits.NODE_CAMERA_TRANSFORM) {
            localToSceneValid = false;
            sceneToLocalValid = false;
            clipInSceneValid = false;
            projViewTxValid = false;
        } else if (dirtyBit == DirtyBits.NODE_CAMERA) {
            projViewTxValid = false;
        }
        markOwnerDirty();
    }

    private void markOwnerDirty() {
        // if the camera is part of the scene/subScene, we will need to notify
        // the owner to mark the entire scene/subScene dirty.
        if (ownerScene != null) {
            ownerScene.markCameraDirty();
        }
        if (ownerSubScene != null) {
            ownerSubScene.markContentDirty();
        }
    }

    /**
     * Returns the local-to-scene transform of this camera.
     * Package private, for use in our internal subclasses.
     * Returns directly the internal instance, it must not be altered.
     */
    Affine3D getCameraTransform() {
        if (!localToSceneValid) {
            localToSceneTx.setToIdentity();
            TransformHelper.apply(getLocalToSceneTransform(), localToSceneTx);
            localToSceneValid = true;
        }
        return localToSceneTx;
    }

    abstract void computeProjectionTransform(GeneralTransform3D proj);
    abstract void computeViewTransform(Affine3D view);

    /**
     * Returns the projView transform of this camera.
     * Package private, for internal use.
<A NAME="41"></A>     * Returns directly the internal instance, it must not be altered.
     */
    GeneralTransform3D getProjViewTransform() {
        <FONT color="#f87a17"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#41',2,'match46-top.html#41',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (!projViewTxValid) {
            computeProjectionTransform(projTx);
            computeViewTransform(viewTx);

            projViewTx.set(projTx);
            projViewTx.mul(viewTx);
            projViewTx.mul(getSceneToLocalTransform());

            projViewTxValid = true;
        }</B></FONT>

        return projViewTx;
    }

    /**
     * Transforms the given 3D point to the flat projected coordinates.
     */
    private Point2D project(Point3D p) {

        final Vec3d vec = getProjViewTransform().transform(new Vec3d(
                p.getX(), p.getY(), p.getZ()));

        final double halfViewWidth = getViewWidth() / 2.0;
        final double halfViewHeight = getViewHeight() / 2.0;

        return new Point2D(
                halfViewWidth * (1 + vec.x),
                halfViewHeight * (1 - vec.y));
    }

    /**
     * Computes intersection point of the pick ray cast by the given coordinates
     * and the node's local XY plane.
     */
    private Point2D pickNodeXYPlane(Node node, double x, double y) {
        final PickRay ray = computePickRay(x, y, null);

        final Affine3D localToScene = new Affine3D();
        TransformHelper.apply(node.getLocalToSceneTransform(), localToScene);

        final Vec3d o = ray.getOriginNoClone();
        final Vec3d d = ray.getDirectionNoClone();

        try {
            localToScene.inverseTransform(o, o);
            localToScene.inverseDeltaTransform(d, d);
        } catch (NoninvertibleTransformException e) {
            return null;
        }

        if (almostZero(d.z)) {
            return null;
        }

        final double t = -o.z / d.z;
        return new Point2D(o.x + (d.x * t), o.y + (d.y * t));
    }

    /**
     * Computes intersection point of the pick ray cast by the given coordinates
     * and the projection plane.
<A NAME="45"></A>     */
    Point3D pickProjectPlane(double x, double y) {
        final PickRay ray = computePickRay(x, y, null);
        <FONT color="#79d867"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#45',2,'match46-top.html#45',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>final Vec3d p = new Vec3d();
        p.add(ray.getOriginNoClone(), ray.getDirectionNoClone());

        return new Point3D(p.x, p.y, p.z);
    }


    /**
     * Computes pick ray for the content rendered by this camera.
     * @param x horizontal coordinate of the pick ray in the projected
     *               view, usually mouse cursor position
     * @param y vertical coordinate of the pick ray in the projected
     *               view, usually mouse cursor position
     * @param pickRay pick ray to be reused. New instance is created in case
     *                of null.
     * @return The PickRay instance computed based on this camera and the given
     *         arguments.
     */
    abstract PickR</B></FONT>ay computePickRay(double x, double y, PickRay pickRay);

    /**
     * Computes local position of the camera in the scene.
     * @param position Position to be reused. New instance is created in case
     *                 of null.
     * @return The position of the camera in the scene in camera local coords
     */
    abstract Vec3d computePosition(Vec3d position);

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {
        return new BoxBounds(0, 0, 0, 0, 0, 0);
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeContains(double localX, double localY) {
        return false;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/ParallelCamera.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene;

import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.scene.ParallelCameraHelper;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.sg.prism.NGParallelCamera;

/**
 * Specifies a parallel camera for rendering a scene without perspective correction.
 *
 * &lt;p&gt;If a scene contains only 2D transforms, then the following details are not
 * relevant.
 * This camera defines a viewing volume for a parallel (orthographic) projection;
 * a rectangular box. This camera is always located at center of the window and
 * looks along the positive z-axis. The coordinate system defined by this camera
 * has its origin in the upper left corner of the panel with the Y-axis pointing
 * down and the Z axis pointing away from the viewer (into the screen). The
 * units are in pixel coordinates.
 *
 * @since JavaFX 2.0
 */
public class ParallelCamera extends Camera {
    static {
        ParallelCameraHelper.setParallelCameraAccessor(new ParallelCameraHelper.ParallelCameraAccessor() {
            @Override
            public NGNode doCreatePeer(Node node) {
                return ((ParallelCamera) node).doCreatePeer();
            }
        });
    }

    {
        // To initialize the class helper at the begining each constructor of this class
        ParallelCameraHelper.initHelper(this);
    }

    /**
     * Creates an empty instance of ParallelCamera.
     */
    public ParallelCamera() {
    }

<A NAME="11"></A>    @Override
    Camera copy() {
        ParallelCamera c = new ParallelCamera();
        <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#11',2,'match46-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>c.setNearClip(getNearClip());
        c.setFarClip(getFarClip());
        return c;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private NGNode doCreatePeer() {
        final NGParallelCamera peer = new NGParallelCamera()</B></FONT>;
        peer.setNearClip((float) getNearClip());
        peer.setFarClip((float) getFarClip());
        return peer;
    }

    @Override
    final PickRay computePickRay(double x, double y, PickRay pickRay) {
        return PickRay.computeParallelPickRay(x, y, getViewHeight(),
                getCameraTransform(),
                getNearClip(), getFarClip(), pickRay);
    }

    @Override
    void computeProjectionTransform(GeneralTransform3D proj) {
        final double viewWidth = getViewWidth();
        final double viewHeight = getViewHeight();
        final double halfDepth =
                (viewWidth &gt; viewHeight) ? viewWidth / 2.0 : viewHeight / 2.0;

        proj.ortho(0.0, viewWidth, viewHeight, 0.0, -halfDepth, halfDepth);
    }

    @Override
    void computeViewTransform(Affine3D view) {
        view.setToIdentity();
    }

    @Override
    Vec3d computePosition(Vec3d position) {
        if (position == null) {
            position = new Vec3d();
        }

        // This is the same math as in PerspectiveCamera, fixed for the default
        // 30 degrees vertical field of view.
        final double halfViewWidth = getViewWidth() / 2.0;
        final double halfViewHeight = getViewHeight() / 2.0;
        final double distanceZ = halfViewHeight / Math.tan(Math.toRadians(15.0));
        position.set(halfViewWidth, halfViewHeight, -distanceZ);

        return position;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/PerspectiveCamera.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene;

import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.PerspectiveCameraHelper;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.sg.prism.NGPerspectiveCamera;
import javafx.application.ConditionalFeature;
import javafx.application.Platform;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleDoubleProperty;
import com.sun.javafx.logging.PlatformLogger;



/**
 * Specifies a perspective camera for rendering a scene.
 *
 * &lt;p&gt; This camera defines a viewing volume for a perspective projection;
 * a truncated right pyramid.
 * The {@code fieldOfView} value can be used to change viewing volume.
 * By default, this camera is located at center of the scene and looks along the
 * positive z-axis. The coordinate system defined by this camera has its
 * origin in the upper left corner of the panel with the Y-axis pointing
 * down and the Z axis pointing away from the viewer (into the screen).
 * If a {@code PerspectiveCamera} node is added to the scene graph,
 * the transformed position and orientation of the camera will define the
 * position of the camera and the direction that the camera is looking.
 *
 * &lt;p&gt; In the default camera, where fixedEyeAtCameraZero is false, the Z value
 * of the eye position is adjusted in Z such that the projection matrix generated
 * using the specified {@code fieldOfView} will produce units at
 * Z = 0 (the projection plane), in device-independent pixels, matches that of
 * the ParallelCamera.
 * When the Scene is resized,
 * the objects in the scene at the projection plane (Z = 0) will stay the same size,
 * but more or less content of the scene is viewable.
 *
 * &lt;p&gt; If fixedEyeAtCameraZero is true, the eye position is fixed at (0, 0, 0)
 * in the local coordinates of the camera. The projection matrix is generated
 * using the specified {@code fieldOfView} and the projection volume is mapped
 * onto the viewport (window) such that it is stretched over more or fewer
 * device-independent pixels at the projection plane.
 * When the Scene is resized,
 * the objects in the scene will shrink or grow proportionally,
 * but the visible portion of the content is unchanged.
 *
 * &lt;p&gt; We recommend setting fixedEyeAtCameraZero to true if you are going to
 * transform (move) the camera. Transforming the camera when fixedEyeAtCameraZero
 * is set to false may lead to results that are not intuitive.
 *
 * &lt;p&gt; Note that this is a conditional feature. See
 * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 * for more information.
 *
 * @since JavaFX 2.0
 */
public class PerspectiveCamera extends Camera {

    private boolean fixedEyeAtCameraZero = false;

    // Lookat transform for legacy case
    private static final Affine3D LOOK_AT_TX = new Affine3D();

    // Lookat transform for fixedEyeAtCameraZero case
    private static final Affine3D LOOK_AT_TX_FIXED_EYE = new Affine3D();

    static {
        PerspectiveCameraHelper.setPerspectiveCameraAccessor(new PerspectiveCameraHelper.PerspectiveCameraAccessor() {
            @Override
            public NGNode doCreatePeer(Node node) {
                return ((PerspectiveCamera) node).doCreatePeer();
            }

            @Override
            public void doUpdatePeer(Node node) {
                ((PerspectiveCamera) node).doUpdatePeer();
            }
        });

        // Compute the legacy look at matrix such that the zero point ends up at
        // the z=-1 plane.
        LOOK_AT_TX.setToTranslation(0, 0, -1);
        // Y-axis pointing down
        LOOK_AT_TX.rotate(Math.PI, 1, 0, 0);

        // Compute the fixed eye at (0, 0, 0) look at matrix such that the zero point
        // ends up at the z=0 plane and Y-axis pointing down
        LOOK_AT_TX_FIXED_EYE.rotate(Math.PI, 1, 0, 0);
    }

    /**
     * Specifies the field of view angle of the camera's projection,
     * measured in degrees.
     *
     * @defaultValue 30.0
     */
    private DoubleProperty fieldOfView;

    public final void setFieldOfView(double value){
        fieldOfViewProperty().set(value);
    }

    public final double getFieldOfView() {
        return fieldOfView == null ? 30 : fieldOfView.get();
    }

    public final DoubleProperty fieldOfViewProperty() {
        if (fieldOfView == null) {
            fieldOfView = new SimpleDoubleProperty(PerspectiveCamera.this, &quot;fieldOfView&quot;, 30) {
                @Override
                protected void invalidated() {
                    NodeHelper.markDirty(PerspectiveCamera.this, DirtyBits.NODE_CAMERA);
                }
            };
        }
        return fieldOfView;
    }

    /**
     * Defines whether the {@code fieldOfView} property will apply to the vertical
     * dimension of the projection. If it is false, {@code fieldOfView} will
     * apply to the horizontal dimension of the projection.
     *
     * @defaultValue true
     * @since JavaFX 8.0
     */
    private BooleanProperty verticalFieldOfView;

    public final void setVerticalFieldOfView(boolean value) {
        verticalFieldOfViewProperty().set(value);
    }

    public final boolean isVerticalFieldOfView() {
        return verticalFieldOfView == null ? true : verticalFieldOfView.get();
    }

    public final BooleanProperty verticalFieldOfViewProperty() {
        if (verticalFieldOfView == null) {
            verticalFieldOfView = new SimpleBooleanProperty(PerspectiveCamera.this, &quot;verticalFieldOfView&quot;, true) {
                @Override
                protected void invalidated() {
                    NodeHelper.markDirty(PerspectiveCamera.this, DirtyBits.NODE_CAMERA);
                }
            };
        }
        return verticalFieldOfView;
    }

    {
        // To initialize the class helper at the begining each constructor of this class
        PerspectiveCameraHelper.initHelper(this);
    }

    /**
     * Creates an empty instance of PerspectiveCamera.
     */
    public PerspectiveCamera() {
        this(false);
    }

    /**
     * Constructs a PerspectiveCamera with the specified fixedEyeAtCameraZero flag.
     *
     * &lt;p&gt; In the default camera, where fixedEyeAtCameraZero is false, the Z value of
     * the eye position is adjusted in Z such that the projection matrix generated
     * using the specified {@code fieldOfView} will produce units at
     * Z = 0 (the projection plane), in device-independent pixels, matches that of
     * the ParallelCamera.
     * When the Scene is resized,
     * the objects in the scene at the projection plane (Z = 0) will stay the same size,
     * but more or less content of the scene is viewable.
     *
     * &lt;p&gt; If fixedEyeAtCameraZero is true, the eye position is fixed at (0, 0, 0)
     * in the local coordinates of the camera. The projection matrix is generated
     * using the specified {@code fieldOfView} and the projection volume is mapped
     * onto the viewport (window) such that it is stretched over more or fewer
     * device-independent pixels at the projection plane.
     * When the Scene is resized,
     * the objects in the scene will shrink or grow proportionally,
     * but the visible portion of the content is unchanged.
     *
     * &lt;p&gt; We recommend setting fixedEyeAtCameraZero to true if you are going to
     * transform (move) the camera. Transforming the camera when fixedEyeAtCameraZero
     * is set to false may lead to results that are not intuitive.
     *
     * @param fixedEyeAtCameraZero true if the the eye position is fixed at
     * (0, 0, 0) in the local coordinates of the camera.
     * @since JavaFX 8.0
     */
    public PerspectiveCamera(boolean fixedEyeAtCameraZero) {
        if (!Platform.isSupported(ConditionalFeature.SCENE3D)) {
            String logname = PerspectiveCamera.class.getName();
            PlatformLogger.getLogger(logname).warning(&quot;System can't support &quot;
                    + &quot;ConditionalFeature.SCENE3D&quot;);
        }
        this.fixedEyeAtCameraZero = fixedEyeAtCameraZero;
    }

    /**
     * Returns a flag indicating whether this camera uses a fixed eye position
     * at the origin of the camera. If {@code fixedEyeAtCameraZero} is {@code true},
     * the the eye position is fixed at (0, 0, 0) in the local coordinates
     * of the camera. This attribute is immutable.
     *
     * @return a flag indicating whether this camera uses a fixed eye position
     * at the origin of the camera
     *
     * @since JavaFX 8.0
     */
    public final boolean isFixedEyeAtCameraZero() {
        return fixedEyeAtCameraZero;
    }

    @Override
    final PickRay computePickRay(double x, double y, PickRay pickRay) {

        return PickRay.computePerspectivePickRay(x, y, fixedEyeAtCameraZero,
                getViewWidth(), getViewHeight(),
                Math.toRadians(getFieldOfView()), isVerticalFieldOfView(),
                getCameraTransform(),
                getNearClip(), getFarClip(),
                pickRay);
    }

    @Override Camera copy() {
<A NAME="18"></A>        PerspectiveCamera c = new PerspectiveCamera(fixedEyeAtCameraZero);
        c.setNearClip(getNearClip());
        c.setFarClip(getFarClip());
        c.setFieldOfView(<FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#18',2,'match46-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getFieldOfView());
        return c;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private NGNode doCreatePeer() {
        NGPerspectiveCamera peer = new NGPerspectiveCamera(fixedEyeAtCameraZero);
        peer.setNearClip</B></FONT>((float) getNearClip());
        peer.setFarClip((float) getFarClip());
        peer.setFieldOfView((float) getFieldOfView());
        return peer;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        NGPerspectiveCamera pgPerspectiveCamera = getPeer();
        if (isDirty(DirtyBits.NODE_CAMERA)) {
            pgPerspectiveCamera.setVerticalFieldOfView(isVerticalFieldOfView());
            pgPerspectiveCamera.setFieldOfView((float) getFieldOfView());
        }
    }

    @Override
    void computeProjectionTransform(GeneralTransform3D proj) {
        proj.perspective(isVerticalFieldOfView(), Math.toRadians(getFieldOfView()),
                getViewWidth() / getViewHeight(), getNearClip(), getFarClip());
    }

    @Override
    void computeViewTransform(Affine3D view) {

        // In the case of fixedEyeAtCameraZero the camera position is (0,0,0) in
        // local coord. of the camera node. In non-fixed eye case, the camera
        // position is (w/2, h/2, h/2/tan) in local coord. of the camera.
        if (isFixedEyeAtCameraZero()) {
            view.setTransform(LOOK_AT_TX_FIXED_EYE);
        } else {
            final double viewWidth = getViewWidth();
            final double viewHeight = getViewHeight();
            final boolean verticalFOV = isVerticalFieldOfView();

            final double aspect = viewWidth / viewHeight;
            final double tanOfHalfFOV = Math.tan(Math.toRadians(getFieldOfView()) / 2.0);

            // Translate the zero point to the upper-left corner
            final double xOffset = -tanOfHalfFOV * (verticalFOV ? aspect : 1.0);
            final double yOffset = tanOfHalfFOV * (verticalFOV ? 1.0 : 1.0 / aspect);

            // Compute scale factor as 2/viewport.width or height, after adjusting for fov
            final double scale = 2.0 * tanOfHalfFOV /
                    (verticalFOV ? viewHeight : viewWidth);

            view.setToTranslation(xOffset, yOffset, 0.0);
            view.concatenate(LOOK_AT_TX);
            view.scale(scale, scale, scale);
        }
    }

    @Override
    Vec3d computePosition(Vec3d position) {
        if (position == null) {
            position = new Vec3d();
        }

        if (fixedEyeAtCameraZero) {
            position.set(0.0, 0.0, 0.0);
        } else {
            final double halfViewWidth = getViewWidth() / 2.0;
            final double halfViewHeight = getViewHeight() / 2.0;
            final double halfViewDim = isVerticalFieldOfView()
                    ? halfViewHeight : halfViewWidth;
            final double distanceZ = halfViewDim
                    / Math.tan(Math.toRadians(getFieldOfView() / 2.0));

            position.set(halfViewWidth, halfViewHeight, -distanceZ);
        }
        return position;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/transform/Affine.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.transform;


import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.geometry.Point2D;
import javafx.geometry.Point3D;

// PENDING_DOC_REVIEW of this whole class
/**
 * &lt;p&gt;
 * The {@code Affine} class represents a general affine transform. An affine
 * transform performs a linear mapping from 2D/3D coordinates to other 2D/3D
 * coordinates while preserving the &quot;straightness&quot; and &quot;parallelness&quot;
 * of lines.
 * Affine transformations can be constructed using sequence rotations,
 * translations, scales, and shears.&lt;/p&gt;
 *
 * &lt;p&gt;
 * For simple transformations application developers should use the
 * specific {@code Translate}, {@code Scale}, {@code Rotate}, or {@code Shear}
 * transforms, which are more lightweight and thus more optimal for this simple
 * purpose. The {@code Affine} class, on the other hand, has the advantage
 * of being able to represent a general affine transform and perform matrix
 * operations on it in place, so it fits better for more complex transformation
 * usages.&lt;/p&gt;

 * &lt;p&gt;
 * Such a coordinate transformation can be represented by a 3 row by
 * 4 column matrix. This matrix transforms source coordinates {@code (x,y,z)}
 * into destination coordinates {@code (x',y',z')} by considering
 * them to be a column vector and multiplying the coordinate vector
 * by the matrix according to the following process:&lt;/p&gt;
 *
 * &lt;pre&gt;
 *      [ x']   [  mxx  mxy  mxz  tx  ] [ x ]   [ mxx * x + mxy * y + mxz * z + tx ]
 *      [ y'] = [  myx  myy  myz  ty  ] [ y ] = [ myx * x + myy * y + myz * z + ty ]
 *      [ z']   [  mzx  mzy  mzz  tz  ] [ z ]   [ mzx * x + mzy * y + mzz * z + tz ]
 *                                      [ 1 ]
 * &lt;/pre&gt;
 * @since JavaFX 2.0
 */
public class Affine extends Transform {

    /**
     * Tracks atomic changes of more elements.
     */
    AffineAtomicChange atomicChange = new AffineAtomicChange();

    /**
     * This constant is used for the internal state2d variable to indicate
     * that no calculations need to be performed and that the source
     * coordinates only need to be copied to their destinations to
     * complete the transformation equation of this transform.
     * @see #state2d
     */
    private static final int APPLY_IDENTITY = 0;

    /**
     * This constant is used for the internal state2d and state3d variables
     * that the translation components of the matrix need to be added
     * to complete the transformation equation of this transform.
     * @see #state2d
     * @see #state3d
     */
    private static final int APPLY_TRANSLATE = 1;

    /**
     * This constant is used for the internal state2d and state3d variables
     * to indicate that the scaling components of the matrix need
     * to be factored in to complete the transformation equation of
     * this transform. If the APPLY_SHEAR bit is also set then it
     * indicates that the scaling components are 0.0.  If the
     * APPLY_SHEAR bit is not also set then it indicates that the
     * scaling components are not 1.0. If neither the APPLY_SHEAR
     * nor the APPLY_SCALE bits are set then the scaling components
     * are 1.0, which means that the x and y components contribute
     * to the transformed coordinate, but they are not multiplied by
     * any scaling factor.
     * @see #state2d
     * @see #state3d
     */
    private static final int APPLY_SCALE = 2;

    /**
     * This constant is used for the internal state2d variable to indicate
     * that the shearing components of the matrix (mxy and myx) need
     * to be factored in to complete the transformation equation of this
     * transform.  The presence of this bit in the state variable changes
     * the interpretation of the APPLY_SCALE bit as indicated in its
     * documentation.
     * @see #state2d
     */
    private static final int APPLY_SHEAR = 4;

    /**
     * This constant is used for the internal state3d variable to indicate
     * that the matrix represents a 2D-only transform.
     */
    private static final int APPLY_NON_3D = 0;

    /**
     * This constant is used for the internal state3d variable to indicate
     * that the matrix is not in any of the recognized simple states
     * and therefore needs a full usage of all elements to complete
     * the transformation equation of this transform.
     */
    private static final int APPLY_3D_COMPLEX = 4;

    /**
     * If this is a 2D transform, this field keeps track of which components
     * of the matrix need to be applied when performing a transformation.
     * If this is a 3D transform, its state is store in the state3d variable
     * and value of state2d is undefined.
     * @see #APPLY_IDENTITY
     * @see #APPLY_TRANSLATE
     * @see #APPLY_SCALE
     * @see #APPLY_SHEAR
     * @see #state3d
     * @see #updateState()
     */
    private transient int state2d;

    /**
     * This field keeps track of whether or not this transform is 3D and if so
     * it tracks several simple states that can be treated faster. If the state
     * is equal to APPLY_NON_3D, this is a 2D transform with its state stored
     * in the state2d variable. If the state is equal to APPLY_3D_COMPLEX,
     * the matrix is not in any of the simple states and needs to be fully
     * processed. Otherwise we recognize scale (mxx, myy and mzz
     * are not all equal to 1.0), translation (tx, ty and tz are not all
     * equal to 0.0) and their combination. In one of the simple states
     * all of the other elements of the matrix are equal to 0.0 (not even
     * shear is allowed).
     * @see #APPLY_NON_3D
     * @see #APPLY_TRANSLATE
     * @see #APPLY_SCALE
     * @see #APPLY_3D_COMPLEX
     * @see #state2d
     * @see #updateState()
     */
    private transient int state3d;

    // Variables used for the elements until user requests creation
    // of the heavy-weight properties
    private double xx;
    private double xy;
    private double xz;
    private double yx;
    private double yy;
    private double yz;
    private double zx;
    private double zy;
    private double zz;
    private double xt;
    private double yt;
    private double zt;

    /**
     * Creates a new instance of {@code Affine} containing an identity transform.
     */
    public Affine() {
        xx = yy = zz = 1.0;
    }

    /**
     * Creates a new instance of {@code Affine} filled with the values from
     * the specified transform.
     * @param transform transform whose matrix is to be filled to the new
     *        instance
     * @throws NullPointerException if the specified {@code transform} is null
     * @since JavaFX 8.0
     */
    public Affine(Transform transform) {
        this(transform.getMxx(), transform.getMxy(), transform.getMxz(),
                                                             transform.getTx(),
             transform.getMyx(), transform.getMyy(), transform.getMyz(),
                                                             transform.getTy(),
             transform.getMzx(), transform.getMzy(), transform.getMzz(),
                                                             transform.getTz());
    }

    /**
     * Creates a new instance of {@code Affine} with a 2D transform specified
     * by the element values.
     * @param mxx the X coordinate scaling element
     * @param mxy the XY coordinate element
     * @param tx the X coordinate translation element
     * @param myx the YX coordinate element
     * @param myy the Y coordinate scaling element
     * @param ty the Y coordinate translation element
     * @since JavaFX 8.0
     */
    public Affine(double mxx, double mxy, double tx,
                  double myx, double myy, double ty) {
        xx = mxx;
        xy = mxy;
        xt = tx;

        yx = myx;
        yy = myy;
        yt = ty;

        zz = 1.0;

        updateState2D();
    }

    /**
     * Creates a new instance of {@code Affine} with a transform specified
     * by the element values.
     * @param mxx the X coordinate scaling element
     * @param mxy the XY coordinate element
     * @param mxz the XZ coordinate element
     * @param tx the X coordinate translation element
     * @param myx the YX coordinate element
     * @param myy the Y coordinate scaling element
     * @param myz the YZ coordinate element
     * @param ty the Y coordinate translation element
     * @param mzx the ZX coordinate element
     * @param mzy the ZY coordinate element
     * @param mzz the Z coordinate scaling element
     * @param tz the Z coordinate translation element
     * @since JavaFX 8.0
     */
    public Affine(double mxx, double mxy, double mxz, double tx,
                  double myx, double myy, double myz, double ty,
                  double mzx, double mzy, double mzz, double tz) {
        xx = mxx;
        xy = mxy;
        xz = mxz;
        xt = tx;

        yx = myx;
        yy = myy;
        yz = myz;
        yt = ty;

        zx = mzx;
        zy = mzy;
        zz = mzz;
        zt = tz;

        updateState();
    }

    /**
     * Creates a new instance of {@code Affine} with a transformation matrix
     * specified by an array.
     * @param matrix array containing the flattened transformation matrix
     * @param type type of matrix contained in the array
     * @param offset offset of the first element in the array
     * @throws IndexOutOfBoundsException if the array is too short for
     *         the specified {@code type} and {@code offset}
     * @throws IllegalArgumentException if the specified matrix is not affine
     *         (the last line of a 2D 3x3 matrix is not {@code [0, 0, 1]} or
     *          the last line of a 3D 4x4 matrix is not {@code [0, 0, 0, 1]}.
     * @throws NullPointerException if the specified {@code matrix}
     *         or {@code type} is null
     * @since JavaFX 8.0
     */
    public Affine(double[] matrix, MatrixType type, int offset) {
        if (matrix.length &lt; offset + type.elements()) {
            throw new IndexOutOfBoundsException(&quot;The array is too short.&quot;);
        }

        switch(type) {
            default:
                stateError();
                // cannot reach
            case MT_2D_3x3:
                if (matrix[offset + 6] != 0.0 ||
                        matrix[offset + 7] != 0.0 ||
                        matrix[offset + 8] != 1.0) {
                    throw new IllegalArgumentException(&quot;The matrix is &quot;
                            + &quot;not affine&quot;);
                }
                // fall-through
            case MT_2D_2x3:
                xx = matrix[offset++];
                xy = matrix[offset++];
                xt = matrix[offset++];
                yx = matrix[offset++];
                yy = matrix[offset++];
                yt = matrix[offset];
                zz = 1.0;
                updateState2D();
                return;
            case MT_3D_4x4:
                if (matrix[offset + 12] != 0.0 ||
                        matrix[offset + 13] != 0.0 ||
                        matrix[offset + 14] != 0.0 ||
                        matrix[offset + 15] != 1.0) {
                    throw new IllegalArgumentException(&quot;The matrix is &quot;
                            + &quot;not affine&quot;);
                }
                // fall-through
            case MT_3D_3x4:
                xx = matrix[offset++];
                xy = matrix[offset++];
                xz = matrix[offset++];
                xt = matrix[offset++];
                yx = matrix[offset++];
                yy = matrix[offset++];
                yz = matrix[offset++];
                yt = matrix[offset++];
                zx = matrix[offset++];
                zy = matrix[offset++];
                zz = matrix[offset++];
                zt = matrix[offset];
                updateState();
                return;
        }
    }

    /**
     * Defines the X coordinate scaling element of the 3x4 matrix.
     */
    private AffineElementProperty mxx;


    public final void setMxx(double value) {
        if (mxx == null) {
            if (xx != value) {
                xx = value;
                postProcessChange();
            }
        } else {
            mxxProperty().set(value);
        }
    }

    @Override
    public final double getMxx() {
        return mxx == null ? xx : mxx.get();
    }

    public final DoubleProperty mxxProperty() {
        if (mxx == null) {
            mxx = new AffineElementProperty(xx) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;mxx&quot;;
                }
            };
        }
        return mxx;
    }

    /**
     * Defines the XY coordinate element of the 3x4 matrix.
     */
    private AffineElementProperty mxy;


    public final void setMxy(double value) {
        if (mxy == null) {
            if (xy != value) {
                xy = value;
                postProcessChange();
            }
        } else {
            mxyProperty().set(value);
        }
    }

    @Override
    public final double getMxy() {
        return mxy == null ? xy : mxy.get();
    }

    public final DoubleProperty mxyProperty() {
        if (mxy == null) {
            mxy = new AffineElementProperty(xy) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;mxy&quot;;
                }
            };
        }
        return mxy;
    }

    /**
     * Defines the XZ coordinate element of the 3x4 matrix.
     */
    private AffineElementProperty mxz;


    public final void setMxz(double value) {
        if (mxz == null) {
            if (xz != value) {
                xz = value;
                postProcessChange();
            }
        } else {
            mxzProperty().set(value);
        }
    }

    @Override
    public final double getMxz() {
        return mxz == null ? xz : mxz.get();
    }

    public final DoubleProperty mxzProperty() {
        if (mxz == null) {
            mxz = new AffineElementProperty(xz) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;mxz&quot;;
                }
            };
        }
        return mxz;
    }

    /**
     * Defines the X coordinate translation element of the 3x4 matrix.
     */
    private AffineElementProperty tx;


    public final void setTx(double value) {
        if (tx == null) {
            if (xt != value) {
                xt = value;
                postProcessChange();
            }
        } else {
            txProperty().set(value);
        }
    }

    @Override
    public final double getTx() {
        return tx == null ? xt : tx.get();
    }

    public final DoubleProperty txProperty() {
        if (tx == null) {
            tx = new AffineElementProperty(xt) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;tx&quot;;
                }
            };
        }
        return tx;
    }

    /**
     * Defines the YX coordinate element of the 3x4 matrix.
     */
    private AffineElementProperty myx;


    public final void setMyx(double value) {
        if (myx == null) {
            if (yx != value) {
                yx = value;
                postProcessChange();
            }
        } else {
            myxProperty().set(value);
        }
    }

    @Override
    public final double getMyx() {
        return myx == null ? yx : myx.get();
    }

    public final DoubleProperty myxProperty() {
        if (myx == null) {
            myx = new AffineElementProperty(yx) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;myx&quot;;
                }
            };
        }
        return myx;
    }

    /**
     * Defines the Y coordinate scaling element of the 3x4 matrix.
     */
    private AffineElementProperty myy;


    public final void setMyy(double value) {
        if (myy == null) {
            if (yy != value) {
                yy = value;
                postProcessChange();
            }
        } else{
            myyProperty().set(value);
        }
    }

    @Override
    public final double getMyy() {
        return myy == null ? yy : myy.get();
    }

    public final DoubleProperty myyProperty() {
        if (myy == null) {
            myy = new AffineElementProperty(yy) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;myy&quot;;
                }
            };
        }
        return myy;
    }

    /**
     * Defines the YZ coordinate element of the 3x4 matrix.
     */
    private AffineElementProperty myz;


    public final void setMyz(double value) {
        if (myz == null) {
            if (yz != value) {
                yz = value;
                postProcessChange();
            }
        } else {
            myzProperty().set(value);
        }
    }

    @Override
    public final double getMyz() {
        return myz == null ? yz : myz.get();
    }

    public final DoubleProperty myzProperty() {
        if (myz == null) {
            myz = new AffineElementProperty(yz) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;myz&quot;;
                }
            };
        }
        return myz;
    }

    /**
     * Defines the Y coordinate translation element of the 3x4 matrix.
     */
    private AffineElementProperty ty;


    public final void setTy(double value) {
        if (ty == null) {
            if (yt != value) {
                yt = value;
                postProcessChange();
            }
        } else {
            tyProperty().set(value);
        }
    }

    @Override
    public final double getTy() {
        return ty == null ? yt : ty.get();
    }

    public final DoubleProperty tyProperty() {
        if (ty == null) {
            ty = new AffineElementProperty(yt) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;ty&quot;;
                }
            };
        }
        return ty;
    }

    /**
     * Defines the ZX coordinate element of the 3x4 matrix.
     */
    private AffineElementProperty mzx;


    public final void setMzx(double value) {
        if (mzx == null) {
            if (zx != value) {
                zx = value;
                postProcessChange();
            }
        } else {
            mzxProperty().set(value);
        }
    }

    @Override
    public final double getMzx() {
        return mzx == null ? zx : mzx.get();
    }

    public final DoubleProperty mzxProperty() {
        if (mzx == null) {
            mzx = new AffineElementProperty(zx) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;mzx&quot;;
                }
            };
        }
        return mzx;
    }

    /**
     * Defines the ZY coordinate element of the 3x4 matrix.
     */
    private AffineElementProperty mzy;


    public final void setMzy(double value) {
        if (mzy == null) {
            if (zy != value) {
                zy = value;
                postProcessChange();
            }
        } else {
            mzyProperty().set(value);
        }
    }

    @Override
    public final double getMzy() {
        return mzy == null ? zy : mzy.get();
    }

    public final DoubleProperty mzyProperty() {
        if (mzy == null) {
            mzy = new AffineElementProperty(zy) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;mzy&quot;;
                }
            };
        }
        return mzy;
    }

    /**
     * Defines the Z coordinate scaling element of the 3x4 matrix.
     */
    private AffineElementProperty mzz;


    public final void setMzz(double value) {
        if (mzz == null) {
            if (zz != value) {
                zz = value;
                postProcessChange();
            }
        } else {
            mzzProperty().set(value);
        }
    }

    @Override
    public final double getMzz() {
        return mzz == null ? zz : mzz.get();
    }

    public final DoubleProperty mzzProperty() {
        if (mzz == null) {
            mzz = new AffineElementProperty(zz) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;mzz&quot;;
                }
            };
        }
        return mzz;
    }

    /**
     * Defines the Z coordinate translation element of the 3x4 matrix.
     */
    private AffineElementProperty tz;


    public final void setTz(double value) {
        if (tz == null) {
            if (zt != value) {
                zt = value;
                postProcessChange();
            }
        } else {
            tzProperty().set(value);
        }
    }

    @Override
    public final double getTz() {
        return tz == null ? zt : tz.get();
    }

    public final DoubleProperty tzProperty() {
        if (tz == null) {
            tz = new AffineElementProperty(zt) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;tz&quot;;
                }
            };
        }
        return tz;
    }

    /**
     * Sets the specified element of the transformation matrix.
     * @param type type of matrix to work with
     * @param row zero-based row number
     * @param column zero-based column number
     * @param value new value of the specified transformation matrix element
     * @throws IndexOutOfBoundsException if the indices are not within
     *         the specified matrix type
     * @throws IllegalArgumentException if setting the value would break
     *         transform's affinity (for convenience the method allows to set
     *         the elements of the last line of a 2D 3x3 matrix to
     *         {@code [0, 0, 1]} and the elements of the last line
     *         of a 3D 4x4 matrix to {@code [0, 0, 0, 1]}).
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public void setElement(MatrixType type, int row, int column, double value) {
        if (row &lt; 0 || row &gt;= type.rows() ||
                column &lt; 0 || column &gt;= type.columns()) {
            throw new IndexOutOfBoundsException(&quot;Index outside of affine &quot;
                    + &quot;matrix &quot; + type + &quot;: [&quot; + row + &quot;, &quot; + column + &quot;]&quot;);
        }
        switch(type) {
            default:
                stateError();
                // cannot reach
            case MT_2D_2x3:
                // fall-through
            case MT_2D_3x3:
                if (!isType2D()) {
                    throw new IllegalArgumentException(&quot;Cannot access 2D matrix &quot;
                            + &quot;of a 3D transform&quot;);
                }
                switch(row) {
                    case 0:
                        switch(column) {
                            case 0: setMxx(value); return;
                            case 1: setMxy(value); return;
                            case 2: setTx(value); return;
                        }
                    case 1:
                        switch(column) {
                            case 0: setMyx(value); return;
                            case 1: setMyy(value); return;
                            case 2: setTy(value); return;
                        }
                    case 2:
                        switch(column) {
                            case 0: if (value == 0.0) return; else break;
                            case 1: if (value == 0.0) return; else break;
                            case 2: if (value == 1.0) return; else break;
                        }
                }
                break;
            case MT_3D_3x4:
                // fall-through
            case MT_3D_4x4:
                switch(row) {
                    case 0:
                        switch(column) {
                            case 0: setMxx(value); return;
                            case 1: setMxy(value); return;
                            case 2: setMxz(value); return;
                            case 3: setTx(value); return;
                        }
                    case 1:
                        switch(column) {
                            case 0: setMyx(value); return;
                            case 1: setMyy(value); return;
                            case 2: setMyz(value); return;
                            case 3: setTy(value); return;
                        }
                    case 2:
                        switch(column) {
                            case 0: setMzx(value); return;
                            case 1: setMzy(value); return;
                            case 2: setMzz(value); return;
                            case 3: setTz(value); return;
                        }
                    case 3:
                        switch(column) {
                            case 0: if (value == 0.0) return; else break;
                            case 1: if (value == 0.0) return; else break;
                            case 2: if (value == 0.0) return; else break;
                            case 3: if (value == 1.0) return; else break;
                        }
                }
                break;
        }
        // reaches here when last line is set to something else than 0 .. 0 1
        throw new IllegalArgumentException(&quot;Cannot set affine matrix &quot; + type +
                &quot; element &quot; + &quot;[&quot; + row + &quot;, &quot; + column + &quot;] to &quot; + value);
    }

    /**
     * Affine element property which handles the atomic changes of more
     * properties.
     */
    private class AffineElementProperty extends SimpleDoubleProperty {

        private boolean needsValueChangedEvent = false;
        private double oldValue;

        public AffineElementProperty(double initialValue) {
            super(initialValue);
        }

        @Override
        public void invalidated() {
            // if an atomic change runs, postpone the change notifications
            if (!atomicChange.runs()) {
                updateState();
                transformChanged();
            }
        }

        @Override
        protected void fireValueChangedEvent() {
            // if an atomic change runs, postpone the change notifications
            if (!atomicChange.runs()) {
                super.fireValueChangedEvent();
            } else {
                needsValueChangedEvent = true;
            }
        }

        /**
         * Called before an atomic change
         */
        private void preProcessAtomicChange() {
            // remember the value before an atomic change
            oldValue = get();
        }

        /**
         * Called after an atomic change
         */
        private void postProcessAtomicChange() {
            // if there was a change notification  during the atomic change,
            // fire it now
            if (needsValueChangedEvent) {
                needsValueChangedEvent = false;
                // the value might have change back an forth
                // (happens quite commonly for transforms with pivot)
                if (oldValue != get()) {
                    super.fireValueChangedEvent();
                }
            }
        }
    }

    /**
     * Called by each element property after value change to
     * update the state variables and call transform change notifications.
     * If an atomic change runs, this is a NOP and the work is done
     * in the end of the entire atomic change.
     */
    private void postProcessChange() {
        if (!atomicChange.runs()) {
            updateState();
            transformChanged();
        }
    }

    /* *************************************************************************
     *                                                                         *
     *                           State getters                                 *
     *                                                                         *
     **************************************************************************/

    @Override
    boolean computeIs2D() {
        return (state3d == APPLY_NON_3D);
    }

    @Override
    boolean computeIsIdentity() {
        return state3d == APPLY_NON_3D &amp;&amp; state2d == APPLY_IDENTITY;
    }

    @Override
    public double determinant() {
        if (state3d == APPLY_NON_3D) {
            return getDeterminant2D();
        } else {
            return getDeterminant3D();
        }
    }

    /**
     * 2D implementation of {@code determinant()}.
     * The behavior is undefined if this is a 3D transform.
     * @return determinant
     */
    private double getDeterminant2D() {
        // assert(state3d == APPLY_NON_3D)
        switch (state2d) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SHEAR | APPLY_SCALE:
                return getMxx() * getMyy() - getMxy() * getMyx();
            case APPLY_SHEAR | APPLY_TRANSLATE:
            case APPLY_SHEAR:
                return -(getMxy() * getMyx());
            case APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SCALE:
                return getMxx() * getMyy();
            case APPLY_TRANSLATE:
            case APPLY_IDENTITY:
                return 1.0;
        }
    }

    /**
     * 3D implementation of {@code determinant()}.
     * The behavior is undefined if this is a 2D transform.
     * @return determinant
     */
    private double getDeterminant3D() {
        // assert(state3d != APPLY_NON_3D)
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_TRANSLATE:
                return 1.0;
            case APPLY_SCALE:
            case APPLY_SCALE | APPLY_TRANSLATE:
                return getMxx() * getMyy() * getMzz();
            case APPLY_3D_COMPLEX:
                final double myx = getMyx();
                final double myy = getMyy();
                final double myz = getMyz();
                final double mzx = getMzx();
                final double mzy = getMzy();
                final double mzz = getMzz();

                return (getMxx() * (myy * mzz - mzy * myz) +
                        getMxy() * (myz * mzx - mzz * myx) +
                        getMxz() * (myx * mzy - mzx * myy));
        }
    }

    /* *************************************************************************
     *                                                                         *
     *                         Transform creators                              *
     *                                                                         *
     **************************************************************************/

    @Override
    public Transform createConcatenation(Transform transform) {
        Affine a = clone();
        a.append(transform);
        return a;
    }

    @Override
    public Affine createInverse() throws NonInvertibleTransformException {
        Affine t = clone();
        t.invert();
        return t;
    }

    @Override
    public Affine clone() {
        return new Affine(this);
    }

    /* *************************************************************************
     *                                                                         *
     *                           Matrix setters                                *
     *                                                                         *
     **************************************************************************/

    /**
     * Sets the values of this instance to the values provided by the specified
     * transform.
     * @param transform transform whose matrix is to be filled to this instance
     * @throws NullPointerException if the specified {@code transform} is null
     * @since JavaFX 8.0
     */
    public void setToTransform(Transform transform) {
        setToTransform(
                transform.getMxx(), transform.getMxy(),
                                         transform.getMxz(), transform.getTx(),
                transform.getMyx(), transform.getMyy(),
                                         transform.getMyz(), transform.getTy(),
                transform.getMzx(), transform.getMzy(),
                                         transform.getMzz(), transform.getTz());
    }

    /**
     * Sets the values of this instance to the 2D transform specified
     * by the element values.
     * @param mxx the X coordinate scaling element
     * @param mxy the XY coordinate element
     * @param tx the X coordinate translation element
     * @param myx the YX coordinate element
     * @param myy the Y coordinate scaling element
     * @param ty the Y coordinate translation element
     * @since JavaFX 8.0
     */
    public void setToTransform(double mxx, double mxy, double tx,
                               double myx, double myy, double ty) {
        setToTransform(mxx, mxy, 0.0, tx,
                myx, myy, 0.0, ty,
                0.0, 0.0, 1.0, 0.0);
    }

    /**
     * Sets the values of this instance to the transform specified
     * by the element values.
     * @param mxx the X coordinate scaling element
     * @param mxy the XY coordinate element
     * @param mxz the XZ coordinate element
     * @param tx the X coordinate translation element
     * @param myx the YX coordinate element
     * @param myy the Y coordinate scaling element
     * @param myz the YZ coordinate element
     * @param ty the Y coordinate translation element
     * @param mzx the ZX coordinate element
     * @param mzy the ZY coordinate element
     * @param mzz the Z coordinate scaling element
     * @param tz the Z coordinate translation element
     * @since JavaFX 8.0
     */
    public void setToTransform(double mxx, double mxy, double mxz, double tx,
                               double myx, double myy, double myz, double ty,
                               double mzx, double mzy, double mzz, double tz)
    {
        atomicChange.start();

        setMxx(mxx);
        setMxy(mxy);
        setMxz(mxz);
        setTx(tx);

        setMyx(myx);
        setMyy(myy);
        setMyz(myz);
        setTy(ty);

        setMzx(mzx);
        setMzy(mzy);
        setMzz(mzz);
        setTz(tz);

        updateState();
        atomicChange.end();
    }

    /**
     * Sets the values of this instance to the transformation matrix
     * specified by an array.
     * @param matrix array containing the flattened transformation matrix
     * @param type type of matrix contained in the array
     * @param offset offset of the first element in the array
     * @throws IndexOutOfBoundsException if the array is too short for
     *         the specified {@code type} and {@code offset}
     * @throws IllegalArgumentException if the specified matrix is not affine
     *         (the last line of a 2D 3x3 matrix is not {@code [0, 0, 1]} or
     *          the last line of a 3D 4x4 matrix is not {@code [0, 0, 0, 1]}.
     * @throws NullPointerException if the specified {@code matrix}
     *         or {@code type} is null
     * @since JavaFX 8.0
     */
    public void setToTransform(double[] matrix, MatrixType type, int offset) {
        if (matrix.length &lt; offset + type.elements()) {
            throw new IndexOutOfBoundsException(&quot;The array is too short.&quot;);
        }

        switch(type) {
            default:
                stateError();
                // cannot reach
            case MT_2D_3x3:
                if (matrix[offset + 6] != 0.0 ||
                        matrix[offset + 7] != 0.0 ||
                        matrix[offset + 8] != 1.0) {
                    throw new IllegalArgumentException(&quot;The matrix is &quot;
                            + &quot;not affine&quot;);
                }
                // fall-through
            case MT_2D_2x3:
                setToTransform(matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++]);
                return;
            case MT_3D_4x4:
                if (matrix[offset + 12] != 0.0 ||
                        matrix[offset + 13] != 0.0 ||
                        matrix[offset + 14] != 0.0 ||
                        matrix[offset + 15] != 1.0) {
                    throw new IllegalArgumentException(&quot;The matrix is &quot;
                            + &quot;not affine&quot;);
                }
                // fall-through
            case MT_3D_3x4:
                setToTransform(matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++]);
                return;
        }
    }

    /**
     * Resets this transform to the identity transform.
     * @since JavaFX 8.0
     */
    public void setToIdentity() {
        atomicChange.start();

        if (state3d != APPLY_NON_3D) {
            setMxx(1.0); setMxy(0.0); setMxz(0.0); setTx(0.0);
            setMyx(0.0); setMyy(1.0); setMyz(0.0); setTy(0.0);
            setMzx(0.0); setMzy(0.0); setMzz(1.0); setTz(0.0);
            state3d = APPLY_NON_3D;
            state2d = APPLY_IDENTITY;
        } else if (state2d != APPLY_IDENTITY) {
            setMxx(1.0); setMxy(0.0); setTx(0.0);
            setMyx(0.0); setMyy(1.0); setTy(0.0);
            state2d = APPLY_IDENTITY;
        }

        atomicChange.end();
    }

    /* *************************************************************************
     *                                                                         *
     *                           Matrix operations                             *
     *                                                                         *
     **************************************************************************/


               /* *************************************************
                *                   Inversion                     *
                **************************************************/

    /**
     * Inverts this transform in place.
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @since JavaFX 8.0
     */
    public void invert() throws NonInvertibleTransformException {
        atomicChange.start();

        if (state3d == APPLY_NON_3D) {
            invert2D();
            updateState2D();
        } else {
            invert3D();
            updateState();
        }

        atomicChange.end();
    }

    /**
     * 2D implementation of {@code invert()}.
     * The behavior is undefined for a 3D transform.
     */
    private void invert2D() throws NonInvertibleTransformException {
        double Mxx, Mxy, Mxt;
        double Myx, Myy, Myt;
        double det;
        // assert(state3d == APPLY_NON_3D)

        switch (state2d) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                Mxx = getMxx(); Mxy = getMxy(); Mxt = getTx();
                Myx = getMyx(); Myy = getMyy(); Myt = getTy();
                det = getDeterminant2D();
                if (det == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                setMxx(Myy / det);
                setMyx(-Myx / det);
                setMxy(-Mxy / det);
                setMyy(Mxx / det);
                setTx((Mxy * Myt - Myy * Mxt) / det);
                setTy((Myx * Mxt - Mxx * Myt) / det);
                return;
            case APPLY_SHEAR | APPLY_SCALE:
                Mxx = getMxx(); Mxy = getMxy();
                Myx = getMyx(); Myy = getMyy();
                det = getDeterminant2D();
                if (det == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                setMxx(Myy / det);
                setMyx(-Myx / det);
                setMxy(-Mxy / det);
                setMyy(Mxx / det);
                return;
            case APPLY_SHEAR | APPLY_TRANSLATE:
                Mxy = getMxy(); Mxt = getTx();
                Myx = getMyx(); Myt = getTy();
                if (Mxy == 0.0 || Myx == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                setMyx(1.0 / Mxy);
                setMxy(1.0 / Myx);
                setTx(-Myt / Myx);
                setTy(-Mxt / Mxy);
                return;
            case APPLY_SHEAR:
                Mxy = getMxy();
                Myx = getMyx();
                if (Mxy == 0.0 || Myx == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                setMyx(1.0 / Mxy);
                setMxy(1.0 / Myx);
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                Mxx = getMxx(); Mxt = getTx();
                Myy = getMyy(); Myt = getTy();
                if (Mxx == 0.0 || Myy == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                setMxx(1.0 / Mxx);
                setMyy(1.0 / Myy);
                setTx(-Mxt / Mxx);
                setTy(-Myt / Myy);
                return;
            case APPLY_SCALE:
                Mxx = getMxx();
                Myy = getMyy();
                if (Mxx == 0.0 || Myy == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                setMxx(1.0 / Mxx);
                setMyy(1.0 / Myy);
                return;
            case APPLY_TRANSLATE:
                setTx(-getTx());
                setTy(-getTy());
                return;
            case APPLY_IDENTITY:
                return;
        }
    }

    /**
     * 3D implementation of {@code invert()}.
     * The behavior is undefined if this is a 2D transform.
     */
    private void invert3D() throws NonInvertibleTransformException {

        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_TRANSLATE:
                setTx(-getTx());
                setTy(-getTy());
                setTz(-getTz());
                return;
            case APPLY_SCALE:
                final double mxx_s = getMxx();
                final double myy_s = getMyy();
                final double mzz_s = getMzz();
                if (mxx_s == 0.0 || myy_s == 0.0 || mzz_s == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                setMxx(1.0 / mxx_s);
                setMyy(1.0 / myy_s);
                setMzz(1.0 / mzz_s);
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                final double mxx_st = getMxx();
                final double tx_st = getTx();
                final double myy_st = getMyy();
                final double ty_st = getTy();
                final double mzz_st = getMzz();
                final double tz_st = getTz();
                if (mxx_st == 0.0 || myy_st == 0.0 || mzz_st == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                setMxx(1.0 / mxx_st);
                setMyy(1.0 / myy_st);
                setMzz(1.0 / mzz_st);
                setTx(-tx_st / mxx_st);
                setTy(-ty_st / myy_st);
                setTz(-tz_st / mzz_st);
                return;
            case APPLY_3D_COMPLEX:

                // InvM = Transpose(Cofactor(M)) / det(M)
                // Cofactor(M) = matrix of cofactors(0..3,0..3)
                // cofactor(r,c) = (-1 if r+c is odd) * minor(r,c)
                // minor(r,c) = det(M with row r and col c removed)
                // For an Affine3D matrix, minor(r, 3) is {0, 0, 0, det}
                // which generates {0, 0, 0, 1} and so can be ignored.

                final double mxx = getMxx();
                final double mxy = getMxy();
                final double mxz = getMxz();
                final double tx = getTx();
                final double myx = getMyx();
                final double myy = getMyy();
                final double myz = getMyz();
                final double ty = getTy();
                final double mzy = getMzy();
                final double mzx = getMzx();
                final double mzz = getMzz();
                final double tz = getTz();

                final double det =
                        mxx * (myy * mzz - mzy * myz) +
                        mxy * (myz * mzx - mzz * myx) +
                        mxz * (myx * mzy - mzx * myy);

                if (det == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }

                final double cxx =   myy * mzz - myz * mzy;
                final double cyx = - myx * mzz + myz * mzx;
                final double czx =   myx * mzy - myy * mzx;
                final double cxt = - mxy * (myz * tz - mzz  * ty)
                                   - mxz * (ty  * mzy - tz  * myy)
                                   - tx  * (myy * mzz - mzy * myz);
                final double cxy = - mxy * mzz + mxz * mzy;
                final double cyy =   mxx * mzz - mxz * mzx;
                final double czy = - mxx * mzy + mxy * mzx;
                final double cyt =   mxx * (myz * tz  - mzz * ty)
                                   + mxz * (ty  * mzx - tz  * myx)
                                   + tx  * (myx * mzz - mzx * myz);
                final double cxz =   mxy * myz - mxz * myy;
                final double cyz = - mxx * myz + mxz * myx;
                final double czz =   mxx * myy - mxy * myx;
                final double czt = - mxx * (myy * tz - mzy  * ty)
                                   - mxy * (ty  * mzx - tz  * myx)
                                   - tx  * (myx * mzy - mzx * myy);

                setMxx(cxx / det);
                setMxy(cxy / det);
                setMxz(cxz / det);
                setTx(cxt / det);
                setMyx(cyx / det);
                setMyy(cyy / det);
                setMyz(cyz / det);
                setTy(cyt / det);
                setMzx(czx / det);
                setMzy(czy / det);
                setMzz(czz / det);
                setTz(czt / det);
                return;
        }
    }

               /* *************************************************
                *             General concatenations              *
                **************************************************/

    /**
     * &lt;p&gt;
     * Appends the specified transform to this instance.
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding the two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * {@code transform} second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified transform.
     * &lt;/p&gt;
     *
     * @param transform transform to be appended to this instance
     * @throws NullPointerException if the specified {@code transform} is null
     * @since JavaFX 8.0
     */
    public void append(Transform transform) {
        transform.appendTo(this);
    }

    /**
     * &lt;p&gt;
     * Appends the 2D transform specified by the element values to this instance.
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding the two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * {@code transform} second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified transform.
     * &lt;/p&gt;
     * @param mxx the X coordinate scaling element of the transform to be
     *            appended
     * @param mxy the XY coordinate element of the transform to be appended
     * @param tx the X coordinate translation element of the transform to be
     *            appended
     * @param myx the YX coordinate element of the transform to be appended
     * @param myy the Y coordinate scaling element of the transform to be
     *            appended
     * @param ty the Y coordinate translation element of the transform to be
     *            appended
     * @since JavaFX 8.0
     */
    public void append(double mxx, double mxy, double tx,
                        double myx, double myy, double ty) {

        if (state3d == APPLY_NON_3D) {

            atomicChange.start();

            final double m_xx = getMxx();
            final double m_xy = getMxy();
            final double m_yx = getMyx();
            final double m_yy = getMyy();

            setMxx(m_xx * mxx + m_xy * myx);
            setMxy(m_xx * mxy + m_xy * myy);
            setTx(m_xx * tx + m_xy * ty + getTx());
            setMyx(m_yx * mxx + m_yy * myx);
            setMyy(m_yx * mxy + m_yy * myy);
            setTy(m_yx * tx + m_yy * ty + getTy());

            updateState();
            atomicChange.end();
        } else {
            append(mxx, mxy, 0.0, tx,
                    myx, myy, 0.0, ty,
                    0.0, 0.0, 1.0, 0.0);
        }
    }

    /**
     * &lt;p&gt;
     * Appends the transform specified by the element values to this instance.
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding the two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * {@code transform} second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified transform.
     * &lt;/p&gt;
     *
     * @param mxx the X coordinate scaling element of the transform to be
     *            appended
     * @param mxy the XY coordinate element of the transform to be appended
     * @param mxz the XZ coordinate element of the transform to be appended
     * @param tx the X coordinate translation element of the transform to be
     *            appended
     * @param myx the YX coordinate element of the transform to be appended
     * @param myy the Y coordinate scaling element of the transform to be
     *            appended
     * @param myz the YZ coordinate element of the transform to be appended
     * @param ty the Y coordinate translation element of the transform to be
     *            appended
     * @param mzx the ZX coordinate element of the transform to be appended
     * @param mzy the ZY coordinate element of the transform to be appended
     * @param mzz the Z coordinate scaling element of the transform to be
     *            appended
     * @param tz the Z coordinate translation element of the transform to be
     *            appended
     * @since JavaFX 8.0
     */
    public void append(double mxx, double mxy, double mxz, double tx,
                       double myx, double myy, double myz, double ty,
                       double mzx, double mzy, double mzz, double tz)
    {
        atomicChange.start();

        final double m_xx = getMxx();
        final double m_xy = getMxy();
        final double m_xz = getMxz();
        final double t_x = getTx();
        final double m_yx = getMyx();
        final double m_yy = getMyy();
        final double m_yz = getMyz();
        final double t_y = getTy();
        final double m_zx = getMzx();
        final double m_zy = getMzy();
        final double m_zz = getMzz();
        final double t_z = getTz();

        setMxx(m_xx * mxx + m_xy * myx + m_xz * mzx);
        setMxy(m_xx * mxy + m_xy * myy + m_xz * mzy);
        setMxz(m_xx * mxz + m_xy * myz + m_xz * mzz);
        setTx( m_xx * tx + m_xy * ty + m_xz * tz + t_x);
        setMyx(m_yx * mxx + m_yy * myx + m_yz * mzx);
        setMyy(m_yx * mxy + m_yy * myy + m_yz * mzy);
        setMyz(m_yx * mxz + m_yy * myz + m_yz * mzz);
        setTy( m_yx * tx + m_yy * ty + m_yz * tz + t_y);
        setMzx(m_zx * mxx + m_zy * myx + m_zz * mzx);
        setMzy(m_zx * mxy + m_zy * myy + m_zz * mzy);
        setMzz(m_zx * mxz + m_zy * myz + m_zz * mzz);
        setTz( m_zx * tx + m_zy * ty + m_zz * tz + t_z);

        updateState();
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the transform specified by the array to this instance.
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding the two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * {@code transform} second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified transform.
     * &lt;/p&gt;
     *
     * @param matrix array containing the flattened transformation matrix
     *               to be appended
     * @param type type of matrix contained in the array
     * @param offset offset of the first matrix element in the array
     * @throws IndexOutOfBoundsException if the array is too short for
     *         the specified {@code type} and {@code offset}
     * @throws IllegalArgumentException if the specified matrix is not affine
     *         (the last line of a 2D 3x3 matrix is not {@code [0, 0, 1]} or
     *          the last line of a 3D 4x4 matrix is not {@code [0, 0, 0, 1]}.
     * @throws NullPointerException if the specified {@code matrix}
     *         or {@code type} is null
     * @since JavaFX 8.0
     */
    public void append(double[] matrix, MatrixType type, int offset) {
        if (matrix.length &lt; offset + type.elements()) {
            throw new IndexOutOfBoundsException(&quot;The array is too short.&quot;);
        }

        switch(type) {
            default:
                stateError();
                // cannot reach
            case MT_2D_3x3:
                if (matrix[offset + 6] != 0.0 ||
                        matrix[offset + 7] != 0.0 ||
                        matrix[offset + 8] != 1.0) {
                    throw new IllegalArgumentException(&quot;The matrix is &quot;
                            + &quot;not affine&quot;);
                }
                // fall-through
            case MT_2D_2x3:
                append(matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++]);
                return;
            case MT_3D_4x4:
                if (matrix[offset + 12] != 0.0 ||
                        matrix[offset + 13] != 0.0 ||
                        matrix[offset + 14] != 0.0 ||
                        matrix[offset + 15] != 1.0) {
                    throw new IllegalArgumentException(&quot;The matrix is &quot;
                            + &quot;not affine&quot;);
                }
                // fall-through
            case MT_3D_3x4:
                append(matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++]);
                return;
        }
    }

    @Override
    void appendTo(Affine a) {
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch(state2d) {
                    case APPLY_IDENTITY:
                        return;
                    case APPLY_TRANSLATE:
                        a.appendTranslation(getTx(), getTy());
                        return;
                    case APPLY_SCALE:
                        a.appendScale(getMxx(), getMyy());
                        return;
                    case APPLY_SCALE | APPLY_TRANSLATE:
                        a.appendTranslation(getTx(), getTy());
                        a.appendScale(getMxx(), getMyy());
                        return;
                    default:
                        a.append(getMxx(), getMxy(), getTx(),
                                 getMyx(), getMyy(), getTy());
                        return;
                }
            case APPLY_TRANSLATE:
                a.appendTranslation(getTx(), getTy(), getTz());
                return;
            case APPLY_SCALE:
                a.appendScale(getMxx(), getMyy(), getMzz());
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                a.appendTranslation(getTx(), getTy(), getTz());
                a.appendScale(getMxx(), getMyy(), getMzz());
                return;
            case APPLY_3D_COMPLEX:
                a.append(getMxx(), getMxy(), getMxz(), getTx(),
                         getMyx(), getMyy(), getMyz(), getTy(),
                         getMzx(), getMzy(), getMzz(), getTz());
                return;
        }
    }

    /**
     * &lt;p&gt;
     * Prepends the specified transform to this instance.
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding the two transforms to its
     * {@code getTransforms()} list, the specified {@code transform} first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified transform.
     * &lt;/p&gt;
     *
     * @param transform transform to be prepended to this instance
     * @throws NullPointerException if the specified {@code transform} is null
     * @since JavaFX 8.0
     */
    public void prepend(Transform transform) {
        transform.prependTo(this);
    }

    /**
     * &lt;p&gt;
     * Prepends the 2D transform specified by the element values to this instance.
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding the two transforms to its
     * {@code getTransforms()} list, the specified {@code transform} first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified transform.
     * &lt;/p&gt;
     *
     * @param mxx the X coordinate scaling element of the transform to be
     *            prepended
     * @param mxy the XY coordinate element of the transform to be prepended
     * @param tx the X coordinate translation element of the transform to be
     *            prepended
     * @param myx the YX coordinate element of the transform to be prepended
     * @param myy the Y coordinate scaling element of the transform to be
     *            prepended
     * @param ty the Y coordinate translation element of the transform to be
     *            prepended
     * @since JavaFX 8.0
     */
    public void prepend(double mxx, double mxy, double tx,
                        double myx, double myy, double ty) {

        if (state3d == APPLY_NON_3D) {
            atomicChange.start();

            final double m_xx = getMxx();
            final double m_xy = getMxy();
            final double t_x = getTx();
            final double m_yx = getMyx();
            final double m_yy = getMyy();
            final double t_y = getTy();

            setMxx(mxx * m_xx + mxy * m_yx);
            setMxy(mxx * m_xy + mxy * m_yy);
            setTx(mxx * t_x + mxy * t_y + tx);
            setMyx(myx * m_xx + myy * m_yx);
            setMyy(myx * m_xy + myy * m_yy);
            setTy(myx * t_x + myy * t_y + ty);

            updateState2D();
            atomicChange.end();
        } else {
            prepend(mxx, mxy, 0.0, tx,
                   myx, myy, 0.0, ty,
                   0.0, 0.0, 1.0, 0.0);
        }
    }

    /**
     * &lt;p&gt;
     * Prepends the transform specified by the element values to this instance.
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding the two transforms to its
     * {@code getTransforms()} list, the specified {@code transform} first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified transform.
     * &lt;/p&gt;
     *
     * @param mxx the X coordinate scaling element of the transform to be
     *            prepended
     * @param mxy the XY coordinate element of the transform to be prepended
     * @param mxz the XZ coordinate element of the transform to be prepended
     * @param tx the X coordinate translation element of the transform to be
     *            prepended
     * @param myx the YX coordinate element of the transform to be prepended
     * @param myy the Y coordinate scaling element of the transform to be
     *            prepended
     * @param myz the YZ coordinate element of the transform to be prepended
     * @param ty the Y coordinate translation element of the transform to be
     *            prepended
     * @param mzx the ZX coordinate element of the transform to be prepended
     * @param mzy the ZY coordinate element of the transform to be prepended
     * @param mzz the Z coordinate scaling element of the transform to be
     *            prepended
     * @param tz the Z coordinate translation element of the transform to be
     *            prepended
     * @since JavaFX 8.0
     */
    public void prepend(double mxx, double mxy, double mxz, double tx,
                        double myx, double myy, double myz, double ty,
                        double mzx, double mzy, double mzz, double tz) {
        atomicChange.start();

        final double m_xx = getMxx();
        final double m_xy = getMxy();
        final double m_xz = getMxz();
        final double t_x = getTx();
        final double m_yx = getMyx();
        final double m_yy = getMyy();
        final double m_yz = getMyz();
        final double t_y = getTy();
        final double m_zx = getMzx();
        final double m_zy = getMzy();
        final double m_zz = getMzz();
        final double t_z = getTz();

        setMxx(mxx * m_xx + mxy * m_yx + mxz * m_zx);
        setMxy(mxx * m_xy + mxy * m_yy + mxz * m_zy);
        setMxz(mxx * m_xz + mxy * m_yz + mxz * m_zz);
        setTx( mxx * t_x + mxy * t_y + mxz * t_z + tx);
        setMyx(myx * m_xx + myy * m_yx + myz * m_zx);
        setMyy(myx * m_xy + myy * m_yy + myz * m_zy);
        setMyz(myx * m_xz + myy * m_yz + myz * m_zz);
        setTy( myx * t_x + myy * t_y + myz * t_z + ty);
        setMzx(mzx * m_xx + mzy * m_yx + mzz * m_zx);
        setMzy(mzx * m_xy + mzy * m_yy + mzz * m_zy);
        setMzz(mzx * m_xz + mzy * m_yz + mzz * m_zz);
        setTz( mzx * t_x + mzy * t_y + mzz * t_z + tz);

        updateState();
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the transform specified by the array to this instance.
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding the two transforms to its
     * {@code getTransforms()} list, the specified {@code transform} first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified transform.
     * &lt;/p&gt;
     *
     * @param matrix array containing the flattened transformation matrix
     *               to be prepended
     * @param type type of matrix contained in the array
     * @param offset offset of the first matrix element in the array
     * @throws IndexOutOfBoundsException if the array is too short for
     *         the specified {@code type} and {@code offset}
     * @throws IllegalArgumentException if the specified matrix is not affine
     *         (the last line of a 2D 3x3 matrix is not {@code [0, 0, 1]} or
     *          the last line of a 3D 4x4 matrix is not {@code [0, 0, 0, 1]}.
     * @throws NullPointerException if the specified {@code matrix}
     *         or {@code type} is null
     * @since JavaFX 8.0
     */
    public void prepend(double[] matrix, MatrixType type, int offset) {
        if (matrix.length &lt; offset + type.elements()) {
            throw new IndexOutOfBoundsException(&quot;The array is too short.&quot;);
        }

        switch(type) {
            default:
                stateError();
                // cannot reach
            case MT_2D_3x3:
                if (matrix[offset + 6] != 0.0 ||
                        matrix[offset + 7] != 0.0 ||
                        matrix[offset + 8] != 1.0) {
                    throw new IllegalArgumentException(&quot;The matrix is &quot;
                            + &quot;not affine&quot;);
                }
                // fall-through
            case MT_2D_2x3:
                prepend(matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++]);
                return;
            case MT_3D_4x4:
                if (matrix[offset + 12] != 0.0 ||
                        matrix[offset + 13] != 0.0 ||
                        matrix[offset + 14] != 0.0 ||
                        matrix[offset + 15] != 1.0) {
                    throw new IllegalArgumentException(&quot;The matrix is &quot;
                            + &quot;not affine&quot;);
                }
                // fall-through
            case MT_3D_3x4:
                prepend(matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++]);
                return;
        }
    }

    @Override
    void prependTo(Affine a) {
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch(state2d) {
                    case APPLY_IDENTITY:
                        return;
                    case APPLY_TRANSLATE:
                        a.prependTranslation(getTx(), getTy());
                        return;
                    case APPLY_SCALE:
                        a.prependScale(getMxx(), getMyy());
                        return;
                    case APPLY_SCALE | APPLY_TRANSLATE:
                        a.prependScale(getMxx(), getMyy());
                        a.prependTranslation(getTx(), getTy());
                        return;
                    default:
                        a.prepend(getMxx(), getMxy(), getTx(),
                                  getMyx(), getMyy(), getTy());
                        return;
                }
            case APPLY_TRANSLATE:
                a.prependTranslation(getTx(), getTy(), getTz());
                return;
            case APPLY_SCALE:
                a.prependScale(getMxx(), getMyy(), getMzz());
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                a.prependScale(getMxx(), getMyy(), getMzz());
                a.prependTranslation(getTx(), getTy(), getTz());
                return;
            case APPLY_3D_COMPLEX:
                a.prepend(getMxx(), getMxy(), getMxz(), getTx(),
                          getMyx(), getMyy(), getMyz(), getTy(),
                          getMzx(), getMzy(), getMzz(), getTz());
                return;
        }
    }


               /* *************************************************
                *                    Translate                    *
                **************************************************/

    /**
     * &lt;p&gt;
     * Appends the 2D translation to this instance.
     * It is equivalent to {@code append(new Translate(tx, ty))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * translation second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified translation.
     * &lt;/p&gt;
     * @param tx the X coordinate translation
     * @param ty the Y coordinate translation
     * @since JavaFX 8.0
     */
    public void appendTranslation(double tx, double ty) {
        atomicChange.start();
        translate2D(tx, ty);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the translation to this instance.
     * It is equivalent to {@code append(new Translate(tx, ty, tz))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * translation second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified translation.
     * &lt;/p&gt;
     * @param tx the X coordinate translation
     * @param ty the Y coordinate translation
     * @param tz the Z coordinate translation
     * @since JavaFX 8.0
     */
    public void appendTranslation(double tx, double ty, double tz) {
        atomicChange.start();
        translate3D(tx, ty, tz);
        atomicChange.end();
    }

    /**
     * 2D implementation of {@code appendTranslation()}.
     * If this is a 3D transform, the call is redirected to {@code transalte3D()}.
     */
    private void translate2D(double tx, double ty) {
        if (state3d != APPLY_NON_3D) {
            translate3D(tx, ty, 0.0);
            return;
        }

        switch (state2d) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                setTx(tx * getMxx() + ty * getMxy() + getTx());
                setTy(tx * getMyx() + ty * getMyy() + getTy());
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = APPLY_SHEAR | APPLY_SCALE;
                }
                return;
            case APPLY_SHEAR | APPLY_SCALE:
                setTx(tx * getMxx() + ty * getMxy());
                setTy(tx * getMyx() + ty * getMyy());
                if (getTx() != 0.0 || getTy() != 0.0) {
                    state2d = APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE;
                }
                return;
            case APPLY_SHEAR | APPLY_TRANSLATE:
                setTx(ty * getMxy() + getTx());
                setTy(tx * getMyx() + getTy());
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = APPLY_SHEAR;
                }
                return;
            case APPLY_SHEAR:
                setTx(ty * getMxy());
                setTy(tx * getMyx());
                if (getTx() != 0.0 || getTy() != 0.0) {
                    state2d = APPLY_SHEAR | APPLY_TRANSLATE;
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                setTx(tx * getMxx() + getTx());
                setTy(ty * getMyy() + getTy());
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = APPLY_SCALE;
                }
                return;
            case APPLY_SCALE:
                setTx(tx * getMxx());
                setTy(ty * getMyy());
                if (getTx() != 0.0 || getTy() != 0.0) {
                    state2d = APPLY_SCALE | APPLY_TRANSLATE;
                }
                return;
            case APPLY_TRANSLATE:
                setTx(tx + getTx());
                setTy(ty + getTy());
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = APPLY_IDENTITY;
                }
                return;
            case APPLY_IDENTITY:
                setTx(tx);
                setTy(ty);
                if (tx != 0.0 || ty != 0.0) {
                    state2d = APPLY_TRANSLATE;
                }
                return;
        }
    }

    /**
     * 3D implementation of {@code appendTranslation()}.
     * Works fine if this is a 2D transform.
     */
    private void translate3D(double tx, double ty, double tz) {
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                translate2D(tx, ty);
                if (tz != 0.0) {
                    setTz(tz);
                    if ((state2d &amp; APPLY_SHEAR) == 0) {
                        state3d = (state2d &amp; APPLY_SCALE) | APPLY_TRANSLATE;
                    } else {
                        state3d = APPLY_3D_COMPLEX;
                    }
                }
                return;
            case APPLY_TRANSLATE:
                setTx(tx + getTx());
                setTy(ty + getTy());
                setTz(tz + getTz());
                if (getTz() == 0.0) {
                    state3d = APPLY_NON_3D;
                    if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                        state2d = APPLY_IDENTITY;
                    } else {
                        state2d = APPLY_TRANSLATE;
                    }
                }
                return;
            case APPLY_SCALE:
                setTx(tx * getMxx());
                setTy(ty * getMyy());
                setTz(tz * getMzz());
                if (getTx() != 0.0 || getTy() != 0.0 || getTz() != 0.0) {
                    state3d |= APPLY_TRANSLATE;
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                setTx(tx * getMxx() + getTx());
                setTy(ty * getMyy() + getTy());
                setTz(tz * getMzz() + getTz());
                if (getTz() == 0.0) {
                    if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                        state3d = APPLY_SCALE;
                    }
                    if (getMzz() == 1.0) {
                        state2d = state3d;
                        state3d = APPLY_NON_3D;
                    }
                }
                return;
            case APPLY_3D_COMPLEX:
                setTx(tx * getMxx() + ty * getMxy() + tz * getMxz() + getTx());
                setTy(tx * getMyx() + ty * getMyy() + tz * getMyz() + getTy());
                setTz(tx * getMzx() + ty * getMzy() + tz * getMzz() + getTz());
                updateState();
                return;
        }
    }

    /**
     * &lt;p&gt;
     * Prepends the translation to this instance.
     * It is equivalent to {@code prepend(new Translate(tx, ty, tz))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified translation first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified translation.
     * &lt;/p&gt;
     * @param tx the X coordinate translation
     * @param ty the Y coordinate translation
     * @param tz the Z coordinate translation
     * @since JavaFX 8.0
     */
    public void prependTranslation(double tx, double ty, double tz) {
        atomicChange.start();
        preTranslate3D(tx, ty, tz);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the 2D translation to this instance.
     * It is equivalent to {@code prepend(new Translate(tx, ty))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified translation first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified translation.
     * &lt;/p&gt;
     * @param tx the X coordinate translation
     * @param ty the Y coordinate translation
     * @since JavaFX 8.0
     */
    public void prependTranslation(double tx, double ty) {
        atomicChange.start();
        preTranslate2D(tx, ty);
        atomicChange.end();
    }

    /**
     * 2D implementation of {@code prependTranslation()}.
     * If this is a 3D transform, the call is redirected to
     * {@code preTransalte3D}.
     * @since JavaFX 8.0
     */
    private void preTranslate2D(double tx, double ty) {
        if (state3d != APPLY_NON_3D) {
            preTranslate3D(tx, ty, 0.0);
            return;
        }

        setTx(getTx() + tx);
        setTy(getTy() + ty);

        if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
            state2d &amp;= ~APPLY_TRANSLATE;
        } else {
            state2d |= APPLY_TRANSLATE;
        }
    }

    /**
     * 3D implementation of {@code prependTranslation()}.
     * Works fine if this is a 2D transform.
     */
    private void preTranslate3D(double tx, double ty, double tz) {
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                preTranslate2D(tx, ty);

                if (tz != 0.0) {
                    setTz(tz);

                    if ((state2d &amp; APPLY_SHEAR) == 0) {
                        state3d = (state2d &amp; APPLY_SCALE) | APPLY_TRANSLATE;
                    } else {
                        state3d = APPLY_3D_COMPLEX;
                    }
                }
                return;
            case APPLY_TRANSLATE:
                setTx(getTx() + tx);
                setTy(getTy() + ty);
                setTz(getTz() + tz);
                if (getTz() == 0.0) {
                    state3d = APPLY_NON_3D;
                    if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                        state2d = APPLY_IDENTITY;
                    } else {
                        state2d = APPLY_TRANSLATE;
                    }
                }
                return;
            case APPLY_SCALE:
                setTx(tx);
                setTy(ty);
                setTz(tz);
                if (tx != 0.0 || ty != 0.0 || tz != 0.0) {
                    state3d |= APPLY_TRANSLATE;
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                setTx(getTx() + tx);
                setTy(getTy() + ty);
                setTz(getTz() + tz);

                if (getTz() == 0.0) {
                    if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                        state3d = APPLY_SCALE;
                    }
                    if (getMzz() == 1.0) {
                        state2d = state3d;
                        state3d = APPLY_NON_3D;
                    }
                }
                return;
            case APPLY_3D_COMPLEX:
                setTx(getTx() + tx);
                setTy(getTy() + ty);
                setTz(getTz() + tz);
                if (getTz() == 0.0 &amp;&amp; getMxz() == 0.0 &amp;&amp; getMyz() == 0.0 &amp;&amp;
                        getMzx() == 0.0 &amp;&amp; getMzy() == 0.0 &amp;&amp; getMzz() == 1.0) {
                    state3d = APPLY_NON_3D;
                    updateState2D();
                } // otherwise state remains COMPLEX
                return;
        }
    }

               /* *************************************************
                *                      Scale                      *
                **************************************************/

    /**
     * &lt;p&gt;
     * Appends the 2D scale to this instance.
     * It is equivalent to {@code append(new Scale(sx, sy))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * scale second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @since JavaFX 8.0
     */
    public void appendScale(double sx, double sy) {
        atomicChange.start();
        scale2D(sx, sy);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the 2D scale with pivot to this instance.
     * It is equivalent to {@code append(new Scale(sx, sy, pivotX, pivotY))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * scale second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param pivotX the X coordinate of the point about which the scale occurs
     * @param pivotY the Y coordinate of the point about which the scale occurs
     * @since JavaFX 8.0
     */
    public void appendScale(double sx, double sy,
            double pivotX, double pivotY) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0) {
            translate2D(pivotX, pivotY);
            scale2D(sx, sy);
            translate2D(-pivotX, -pivotY);
        } else {
            scale2D(sx, sy);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the 2D scale with pivot to this instance.
     * It is equivalent to
     * {@code append(new Scale(sx, sy, pivot.getX(), pivot.getY())}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * scale second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param pivot the point about which the scale occurs
     * @throws NullPointerException if the specified {@code pivot} is null
     * @since JavaFX 8.0
     */
    public void appendScale(double sx, double sy, Point2D pivot) {
        appendScale(sx, sy, pivot.getX(), pivot.getY());
    }

    /**
     * &lt;p&gt;
     * Appends the scale to this instance.
     * It is equivalent to {@code append(new Scale(sx, sy, sz))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * scale second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param sz the Z coordinate scale factor
     * @since JavaFX 8.0
     */
    public void appendScale(double sx, double sy, double sz) {
        atomicChange.start();
        scale3D(sx, sy, sz);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the scale with pivot to this instance.
     * It is equivalent to {@code append(new Scale(sx, sy, sz, pivotX,
     * pivotY, pivotZ))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * scale second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param sz the Z coordinate scale factor
     * @param pivotX the X coordinate of the point about which the scale occurs
     * @param pivotY the Y coordinate of the point about which the scale occurs
     * @param pivotZ the Z coordinate of the point about which the scale occurs
     * @since JavaFX 8.0
     */
    public void appendScale(double sx, double sy, double sz,
            double pivotX, double pivotY, double pivotZ) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0 || pivotZ != 0.0) {
            translate3D(pivotX, pivotY, pivotZ);
            scale3D(sx, sy, sz);
            translate3D(-pivotX, -pivotY, -pivotZ);
        } else {
            scale3D(sx, sy, sz);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the scale with pivot to this instance.
     * It is equivalent to {@code append(new Scale(sx, sy, sz, pivot.getX(),
     * pivot.getY(), pivot.getZ()))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * scale second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param sz the Z coordinate scale factor
     * @param pivot the point about which the scale occurs
     * @throws NullPointerException if the specified {@code pivot} is null
     * @since JavaFX 8.0
     */
    public void appendScale(double sx, double sy, double sz, Point3D pivot) {
        appendScale(sx, sy, sz, pivot.getX(), pivot.getY(), pivot.getZ());
    }

    /**
     * 2D implementation of {@code appendScale()}.
     * If this is a 3D transform, the call is redirected to {@code scale3D()}.
     */
    private void scale2D(double sx, double sy) {
        if (state3d != APPLY_NON_3D) {
            scale3D(sx, sy, 1.0);
            return;
        }

        int mystate = state2d;
        switch (mystate) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SHEAR | APPLY_SCALE:
                setMxx(getMxx() * sx);
                setMyy(getMyy() * sy);
                // fall-through
            case APPLY_SHEAR | APPLY_TRANSLATE:
            case APPLY_SHEAR:
                setMxy(getMxy() * sy);
                setMyx(getMyx() * sx);
                if (getMxy() == 0.0 &amp;&amp; getMyx() == 0.0) {
                    mystate &amp;= APPLY_TRANSLATE;
                    if (getMxx() != 1.0 || getMyy() != 1.0) {
                        mystate |= APPLY_SCALE;
                    }
                    state2d = mystate;
                } else if (getMxx() == 0.0 &amp;&amp; getMyy() == 0.0) {
                    state2d &amp;= ~APPLY_SCALE;
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SCALE:
                setMxx(getMxx() * sx);
                setMyy(getMyy() * sy);
                if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
                    state2d = (mystate &amp;= APPLY_TRANSLATE);
                }
                return;
            case APPLY_TRANSLATE:
            case APPLY_IDENTITY:
                setMxx(sx);
                setMyy(sy);
                if (sx != 1.0 || sy != 1.0) {
                    state2d = (mystate | APPLY_SCALE);
                }
                return;
        }
    }

    /**
     * 3D implementation of {@code appendScale()}.
     * Works fine if this is a 2D transform.
     */
    private void scale3D(double sx, double sy, double sz) {
        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                scale2D(sx, sy);
                if (sz != 1.0) {
                    setMzz(sz);
                    if ((state2d &amp; APPLY_SHEAR) == 0) {
                        state3d = (state2d &amp; APPLY_TRANSLATE) | APPLY_SCALE;
                    } else {
                        state3d = APPLY_3D_COMPLEX;
                    }
                }
                return;
            case APPLY_TRANSLATE:
                setMxx(sx);
                setMyy(sy);
                setMzz(sz);
                if (sx != 1.0 || sy != 1.0 || sz != 1.0) {
                    state3d |= APPLY_SCALE;
                }
                return;
            case APPLY_SCALE:
                setMxx(getMxx() * sx);
                setMyy(getMyy() * sy);
                setMzz(getMzz() * sz);
                if (getMzz() == 1.0) {
                    state3d = APPLY_NON_3D;
                    if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
                        state2d = APPLY_IDENTITY;
                    } else {
                        state2d = APPLY_SCALE;
                    }
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                setMxx(getMxx() * sx);
                setMyy(getMyy() * sy);
                setMzz(getMzz() * sz);

                if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0 &amp;&amp; getMzz() == 1.0) {
                    state3d &amp;= ~APPLY_SCALE;
                }
                if (getTz() == 0.0 &amp;&amp; getMzz() == 1.0) {
                    state2d = state3d;
                    state3d = APPLY_NON_3D;
                }
                return;
            case APPLY_3D_COMPLEX:
                setMxx(getMxx() * sx);
                setMxy(getMxy() * sy);
                setMxz(getMxz() * sz);

                setMyx(getMyx() * sx);
                setMyy(getMyy() * sy);
                setMyz(getMyz() * sz);

                setMzx(getMzx() * sx);
                setMzy(getMzy() * sy);
                setMzz(getMzz() * sz);

                if (sx == 0.0 || sy == 0.0 || sz == 0.0) {
                    updateState();
                } // otherwise state remains COMPLEX
                return;
        }
    }

    /**
     * &lt;p&gt;
     * Prepends the 2D scale to this instance.
     * It is equivalent to {@code prepend(new Scale(sx, sy))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified scale first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @since JavaFX 8.0
     */
    public void prependScale(double sx, double sy) {

        atomicChange.start();
        preScale2D(sx, sy);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the 2D scale with pivot to this instance.
     * It is equivalent to {@code prepend(new Scale(sx, sy, pivotX, pivotY))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified scale first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param pivotX the X coordinate of the point about which the scale occurs
     * @param pivotY the Y coordinate of the point about which the scale occurs
     * @since JavaFX 8.0
     */
    public void prependScale(double sx, double sy,
            double pivotX, double pivotY) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0) {
            preTranslate2D(-pivotX, -pivotY);
            preScale2D(sx, sy);
            preTranslate2D(pivotX, pivotY);
        } else {
            preScale2D(sx, sy);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the 2D scale with pivot to this instance.
     * It is equivalent to {@code prepend(new Scale(sx, sy, pivot.getX(),
     * &lt;/p&gt;pivot.getY()))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified scale first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param pivot the point about which the scale occurs
     * @throws NullPointerException if the specified {@code pivot} is null
     * @since JavaFX 8.0
     */
    public void prependScale(double sx, double sy, Point2D pivot) {
        prependScale(sx, sy, pivot.getX(), pivot.getY());
    }

    /**
     * &lt;p&gt;
     * Prepends the scale to this instance.
     * It is equivalent to {@code prepend(new Scale(sx, sy, sz))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified scale first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param sz the Z coordinate scale factor
     * @since JavaFX 8.0
     */
    public void prependScale(double sx, double sy, double sz) {
        atomicChange.start();
        preScale3D(sx, sy, sz);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the scale with pivot to this instance.
     * It is equivalent to
     * {@code prepend(new Scale(sx, sy, sz, pivotX, pivotY, pivotZ))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified scale first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param sz the Z coordinate scale factor
     * @param pivotX the X coordinate of the point about which the scale occurs
     * @param pivotY the Y coordinate of the point about which the scale occurs
     * @param pivotZ the Z coordinate of the point about which the scale occurs
     * @since JavaFX 8.0
     */
    public void prependScale(double sx, double sy, double sz,
            double pivotX, double pivotY, double pivotZ) {

        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0 || pivotZ != 0.0) {
            preTranslate3D(-pivotX, -pivotY, -pivotZ);
            preScale3D(sx, sy, sz);
            preTranslate3D(pivotX, pivotY, pivotZ);
        } else {
            preScale3D(sx, sy, sz);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the scale with pivot to this instance.
     * It is equivalent to {@code prepend(new Scale(sx, sy, sz, pivot.getX(),
     * pivot.getY(), pivot.getZ()))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified scale first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param sz the Z coordinate scale factor
     * @param pivot the point about which the scale occurs
     * @throws NullPointerException if the specified {@code pivot} is null
     * @since JavaFX 8.0
     */
    public void prependScale(double sx, double sy, double sz, Point3D pivot) {
        prependScale(sx, sy, sz, pivot.getX(), pivot.getY(), pivot.getZ());
    }

    /**
     * 2D implementation of {@code prependScale()}.
     * If this is a 3D transform, the call is redirected to {@code preScale3D()}.
     */
    private void preScale2D(double sx, double sy) {

        if (state3d != APPLY_NON_3D) {
            preScale3D(sx, sy, 1.0);
            return;
        }

        int mystate = state2d;
        switch (mystate) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                setTx(getTx() * sx);
                setTy(getTy() * sy);
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    mystate = mystate &amp; ~APPLY_TRANSLATE;
                    state2d = mystate;
                }
                // fall-through
            case APPLY_SHEAR | APPLY_SCALE:
                setMxx(getMxx() * sx);
                setMyy(getMyy() * sy);
                // fall-through
            case APPLY_SHEAR:
                setMxy(getMxy() * sx);
                setMyx(getMyx() * sy);
                if (getMxy() == 0.0 &amp;&amp; getMyx() == 0.0) {
                    mystate &amp;= APPLY_TRANSLATE;
                    if (getMxx() != 1.0 || getMyy() != 1.0) {
                        mystate |= APPLY_SCALE;
                    }
                    state2d = mystate;
                }
                return;
            case APPLY_SHEAR | APPLY_TRANSLATE:
                setTx(getTx() * sx);
                setTy(getTy() * sy);
                setMxy(getMxy() * sx);
                setMyx(getMyx() * sy);
                if (getMxy() == 0.0 &amp;&amp; getMyx() == 0.0) {
                    if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
<A NAME="42"></A>                        state2d = APPLY_SCALE;
                    } else {
                        state2d = APPLY_SCALE | APPLY_TRANSLATE;
                    <FONT color="#c57717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#42',2,'match46-top.html#42',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
                } else if (getTx() ==0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = APPLY_SHEAR;
                }</B></FONT>
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                setTx(getTx() * sx);
                setTy(getTy() * sy);
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    mystate = mystate &amp; ~APPLY_TRANSLATE;
                    state2d = mystate;
                }
                // fall-through
            case APPLY_SCALE:
                setMxx(getMxx() * sx);
                setMyy(getMyy() * sy);
                if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
                    state2d = (mystate &amp;= APPLY_TRANSLATE);
                }
                return;
            case APPLY_TRANSLATE:
                setTx(getTx() * sx);
                setTy(getTy() * sy);
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    mystate = mystate &amp; ~APPLY_TRANSLATE;
                    state2d = mystate;
                }
                // fall-through
            case APPLY_IDENTITY:
                setMxx(sx);
                setMyy(sy);
                if (sx != 1.0 || sy != 1.0) {
                    state2d = mystate | APPLY_SCALE;
                }
                return;
        }
    }

    /**
     * 3D implementation of {@code prependScale()}.
     * Works fine if this is a 2D transform.
     */
    private void preScale3D(double sx, double sy, double sz) {
        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                preScale2D(sx, sy);
                if (sz != 1.0) {
                    setMzz(sz);
                    if ((state2d &amp; APPLY_SHEAR) == 0) {
                        state3d = (state2d &amp; APPLY_TRANSLATE) | APPLY_SCALE;
                    } else {
                        state3d = APPLY_3D_COMPLEX;
                    }
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                setTx(getTx() * sx);
                setTy(getTy() * sy);
                setTz(getTz() * sz);
                setMxx(getMxx() * sx);
                setMyy(getMyy() * sy);
                setMzz(getMzz() * sz);
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0 &amp;&amp; getTz() == 0.0) {
                    state3d &amp;= ~APPLY_TRANSLATE;
                }
                if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0 &amp;&amp; getMzz() == 1.0) {
                    state3d &amp;= ~APPLY_SCALE;
                }
                if (getTz() == 0.0 &amp;&amp; getMzz() == 1.0) {
                    state2d = state3d;
                    state3d = APPLY_NON_3D;
                }
                return;
            case APPLY_SCALE:
                setMxx(getMxx() * sx);
                setMyy(getMyy() * sy);
                setMzz(getMzz() * sz);
                if (getMzz() == 1.0) {
                    state3d = APPLY_NON_3D;
                    if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
                        state2d = APPLY_IDENTITY;
                    } else {
                        state2d = APPLY_SCALE;
                    }
                }
                return;
            case APPLY_TRANSLATE:
                setTx(getTx() * sx);
                setTy(getTy() * sy);
                setTz(getTz() * sz);
                setMxx(sx);
                setMyy(sy);
                setMzz(sz);
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0 &amp;&amp; getTz() == 0.0) {
                    state3d &amp;= ~APPLY_TRANSLATE;
                }
                if (sx != 1.0 || sy != 1.0 || sz != 1.0) {
                    state3d |= APPLY_SCALE;
                }
                return;
            case APPLY_3D_COMPLEX:
                setMxx(getMxx() * sx);
                setMxy(getMxy() * sx);
                setMxz(getMxz() * sx);
                setTx(getTx() * sx);

                setMyx(getMyx() * sy);
                setMyy(getMyy() * sy);
                setMyz(getMyz() * sy);
                setTy(getTy() * sy);

                setMzx(getMzx() * sz);
                setMzy(getMzy() * sz);
                setMzz(getMzz() * sz);
                setTz(getTz() * sz);

                if (sx == 0.0 || sy == 0.0 || sz == 0.0) {
                    updateState();
                } // otherwise state remains COMPLEX
                return;
        }
    }

               /* *************************************************
                *                     Shear                       *
                **************************************************/

    /**
     * &lt;p&gt;
     * Appends the shear to this instance.
     * It is equivalent to {@code append(new Shear(sx, sy))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * shear second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified shear.
     * &lt;/p&gt;
     * @param shx the XY coordinate element
     * @param shy the YX coordinate element
     * @since JavaFX 8.0
     */
    public void appendShear(double shx, double shy) {
        atomicChange.start();
        shear2D(shx, shy);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the shear with pivot to this instance.
     * It is equivalent to {@code append(new Shear(sx, sy, pivotX, pivotY))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * shear second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified shear.
     * &lt;/p&gt;
     * @param shx the XY coordinate element
     * @param shy the YX coordinate element
     * @param pivotX the X coordinate of the shear pivot point
     * @param pivotY the Y coordinate of the shear pivot point
     * @since JavaFX 8.0
     */
    public void appendShear(double shx, double shy,
            double pivotX, double pivotY) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0) {
            translate2D(pivotX, pivotY);
            shear2D(shx, shy);
            translate2D(-pivotX, -pivotY);
        } else {
            shear2D(shx, shy);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the shear with pivot to this instance.
     * It is equivalent to {@code append(new Shear(sx, sy,
     * pivot.getX(), pivot.getY()))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * shear second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified shear.
     * &lt;/p&gt;
     * @param shx the XY coordinate element
     * @param shy the YX coordinate element
     * @param pivot the shear pivot point
     * @throws NullPointerException if the specified {@code pivot} is null
     * @since JavaFX 8.0
     */
    public void appendShear(double shx, double shy, Point2D pivot) {
        appendShear(shx, shy, pivot.getX(), pivot.getY());
    }

    /**
     * 2D implementation of {@code appendShear()}.
     * If this is a 3D transform, the call is redirected to {@code shear3D()}.
     */
    private void shear2D(double shx, double shy) {

        if (state3d != APPLY_NON_3D) {
            shear3D(shx, shy);
            return;
        }

        int mystate = state2d;
        switch (mystate) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SHEAR | APPLY_SCALE:
                double M0, M1;
                M0 = getMxx();
                M1 = getMxy();
                setMxx(M0 + M1 * shy);
                setMxy(M0 * shx + M1);

                M0 = getMyx();
                M1 = getMyy();
                setMyx(M0 + M1 * shy);
                setMyy(M0 * shx + M1);
                updateState2D();
                return;
            case APPLY_SHEAR | APPLY_TRANSLATE:
            case APPLY_SHEAR:
                setMxx(getMxy() * shy);
                setMyy(getMyx() * shx);
                if (getMxx() != 0.0 || getMyy() != 0.0) {
                    state2d = mystate | APPLY_SCALE;
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SCALE:
                setMxy(getMxx() * shx);
                setMyx(getMyy() * shy);
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state2d = mystate | APPLY_SHEAR;
                }
                return;
            case APPLY_TRANSLATE:
            case APPLY_IDENTITY:
                setMxy(shx);
                setMyx(shy);
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state2d = mystate | APPLY_SCALE | APPLY_SHEAR;
                }
                return;
        }
    }

    /**
     * 3D implementation of {@code appendShear()}.
     * Works fine if this is a 2D transform.
     */
    private void shear3D(double shx, double shy) {
        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                // cannot happen because currently there is no 3D appendShear
                // that would call this method directly
                shear2D(shx, shy);
                return;
            case APPLY_TRANSLATE:
                setMxy(shx);
                setMyx(shy);
                if (shx != 0.0 || shy != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_SCALE:
            case APPLY_SCALE | APPLY_TRANSLATE:
                setMxy(getMxx() * shx);
                setMyx(getMyy() * shy);
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_3D_COMPLEX:
                final double m_xx = getMxx();
                final double m_xy = getMxy();
                final double m_yx = getMyx();
                final double m_yy = getMyy();
                final double m_zx = getMzx();
                final double m_zy = getMzy();

                setMxx(m_xx + m_xy * shy);
                setMxy(m_xy + m_xx * shx);
                setMyx(m_yx + m_yy * shy);
                setMyy(m_yy + m_yx * shx);
                setMzx(m_zx + m_zy * shy);
                setMzy(m_zy + m_zx * shx);
                updateState();
                return;
        }
    }

    /**
     * &lt;p&gt;
     * Prepends the shear to this instance.
     * It is equivalent to {@code prepend(new Shear(sx, sy))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified shear first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified shear.
     * &lt;/p&gt;
     * @param shx the XY coordinate element
     * @param shy the YX coordinate element
     * @since JavaFX 8.0
     */
    public void prependShear(double shx, double shy) {
        atomicChange.start();
        preShear2D(shx, shy);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the shear with pivot to this instance.
     * It is equivalent to {@code prepend(new Shear(sx, sy, pivotX, pivotY))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified shear first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified shear.
     * &lt;/p&gt;
     * @param shx the XY coordinate element
     * @param shy the YX coordinate element
     * @param pivotX the X coordinate of the shear pivot point
     * @param pivotY the Y coordinate of the shear pivot point
     * @since JavaFX 8.0
     */
    public void prependShear(double shx, double shy,
            double pivotX, double pivotY) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0) {
            preTranslate2D(-pivotX, -pivotY);
            preShear2D(shx, shy);
            preTranslate2D(pivotX, pivotY);
        } else {
            preShear2D(shx, shy);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the shear with pivot to this instance.
     * It is equivalent to {@code prepend(new Shear(sx, sy, pivot.getX(),
     * pivot.getY()))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified shear first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified shear.
     * &lt;/p&gt;
     * @param shx the XY coordinate element
     * @param shy the YX coordinate element
     * @param pivot the shear pivot point
     * @throws NullPointerException if the specified {@code pivot} is null
     * @since JavaFX 8.0
     */
    public void prependShear(double shx, double shy, Point2D pivot) {
        prependShear(shx, shy, pivot.getX(), pivot.getY());
    }

    /**
     * 2D implementation of {@code prependShear()}.
     * If this is a 3D transform, the call is redirected to {@code preShear3D()}.
     */
    private void preShear2D(double shx, double shy) {

        if (state3d != APPLY_NON_3D) {
            preShear3D(shx, shy);
            return;
        }

        int mystate = state2d;

        switch (mystate) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SHEAR | APPLY_TRANSLATE:
                final double t_x_1 = getTx();
                final double t_y_1 = getTy();
                setTx(t_x_1 + shx * t_y_1);
                setTy(t_y_1 + shy * t_x_1);
                // fall-through
            case APPLY_SHEAR | APPLY_SCALE:
            case APPLY_SHEAR:
                final double m_xx = getMxx();
                final double m_xy = getMxy();
                final double m_yx = getMyx();
                final double m_yy = getMyy();

                setMxx(m_xx + shx * m_yx);
                setMxy(m_xy + shx * m_yy);
                setMyx(shy * m_xx + m_yx);
                setMyy(shy * m_xy + m_yy);
                updateState2D();
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                final double t_x_2 = getTx();
                final double t_y_2 = getTy();
                setTx(t_x_2 + shx * t_y_2);
                setTy(t_y_2 + shy * t_x_2);
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    mystate = mystate &amp; ~APPLY_TRANSLATE;
                    state2d = mystate;
                }
                // fall-through
            case APPLY_SCALE:
                setMxy(shx * getMyy());
                setMyx(shy * getMxx());
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state2d = mystate | APPLY_SHEAR;
                }
                return;
            case APPLY_TRANSLATE:
                final double t_x_3 = getTx();
                final double t_y_3 = getTy();
                setTx(t_x_3 + shx * t_y_3);
                setTy(t_y_3 + shy * t_x_3);
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    mystate = mystate &amp; ~APPLY_TRANSLATE;
                    state2d = mystate;
                }
                // fall-through
            case APPLY_IDENTITY:
                setMxy(shx);
                setMyx(shy);
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state2d = mystate | APPLY_SCALE | APPLY_SHEAR;
                }
                return;
        }
    }

    /**
     * 3D implementation of {@code prependShear()}.
     * Works fine if this is a 2D transform.
     */
    private void preShear3D(double shx, double shy) {

        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                // cannot happen because currently there is no 3D prependShear
                // that would call this method directly
                preShear2D(shx, shy);
                return;
            case APPLY_TRANSLATE:
                final double tx_t = getTx();
                setMxy(shx);
                setTx(tx_t + getTy() * shx);
                setMyx(shy);
                setTy(tx_t * shy + getTy());

                if (shx != 0.0 || shy != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_SCALE:
                setMxy(getMyy() * shx);
                setMyx(getMxx() * shy);

                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                final double tx_st = getTx();
                setMxy(getMyy() * shx);
                setTx(tx_st + getTy() * shx);
                setMyx(getMxx() * shy);
                setTy(tx_st * shy + getTy());

                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_3D_COMPLEX:

                final double m_xx = getMxx();
                final double m_xy = getMxy();
                final double m_yx = getMyx();
                final double t_x = getTx();
                final double m_yy = getMyy();
                final double m_xz = getMxz();
                final double m_yz = getMyz();
                final double t_y = getTy();

                setMxx(m_xx + m_yx * shx);
                setMxy(m_xy + m_yy * shx);
                setMxz(m_xz + m_yz * shx);
                setTx(t_x + t_y * shx);
                setMyx(m_xx * shy + m_yx);
                setMyy(m_xy * shy + m_yy);
                setMyz(m_xz * shy + m_yz);
                setTy(t_x * shy + t_y);

                updateState();
                return;
        }
    }

               /* *************************************************
                *                     Rotate                      *
                **************************************************/

    /**
     * &lt;p&gt;
     * Appends the 2D rotation to this instance.
     * It is equivalent to {@code append(new Rotate(angle))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * rotation second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @since JavaFX 8.0
     */
    public void appendRotation(double angle) {
        atomicChange.start();
        rotate2D(angle);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the 2D rotation with pivot to this instance.
     * It is equivalent to {@code append(new Rotate(angle, pivotX, pivotY))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * rotation second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @since JavaFX 8.0
     */
    public void appendRotation(double angle,
            double pivotX, double pivotY) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0) {
            translate2D(pivotX, pivotY);
            rotate2D(angle);
            translate2D(-pivotX, -pivotY);
        } else {
            rotate2D(angle);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the 2D rotation with pivot to this instance.
     * It is equivalent to {@code append(new Rotate(angle, pivot.getX(),
     * pivot.getY()))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * rotation second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivot the rotation pivot point
     * @throws NullPointerException if the specified {@code pivot} is null
     * @since JavaFX 8.0
     */
    public void appendRotation(double angle, Point2D pivot) {
        appendRotation(angle, pivot.getX(), pivot.getY());
    }

    /**
     * &lt;p&gt;
     * Appends the rotation to this instance.
     * It is equivalent to {@code append(new Rotate(angle, pivotX, pivotY,
     * pivotZ, new Point3D(axisX, axisY, axisZ)))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * rotation second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @param pivotZ the Z coordinate of the rotation pivot point
     * @param axisX the X coordinate magnitude of the rotation axis
     * @param axisY the Y coordinate magnitude of the rotation axis
     * @param axisZ the Z coordinate magnitude of the rotation axis
     * @since JavaFX 8.0
     */
    public void appendRotation(double angle,
            double pivotX, double pivotY, double pivotZ,
            double axisX, double axisY, double axisZ) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0 || pivotZ != 0.0) {
            translate3D(pivotX, pivotY, pivotZ);
            rotate3D(angle, axisX, axisY, axisZ);
            translate3D(-pivotX, -pivotY, -pivotZ);
        } else {
            rotate3D(angle, axisX, axisY, axisZ);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the rotation to this instance.
     * It is equivalent to {@code append(new Rotate(angle, pivotX, pivotY,
     * pivotZ, axis))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * rotation second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @param pivotZ the Z coordinate of the rotation pivot point
     * @param axis the rotation axis
     * @throws NullPointerException if the specified {@code axis} is null
     * @since JavaFX 8.0
     */
    public void appendRotation(double angle,
            double pivotX, double pivotY, double pivotZ,
            Point3D axis) {
        appendRotation(angle, pivotX, pivotY, pivotZ,
                axis.getX(), axis.getY(), axis.getZ());
    }

    /**
     * &lt;p&gt;
     * Appends the rotation to this instance.
     * It is equivalent to {@code append(new Rotate(angle, pivot.getX(),
     * pivot.getY(), pivot.getZ(), axis))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * rotation second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivot the rotation pivot point
     * @param axis the rotation axis
     * @throws NullPointerException if the specified {@code pivot}
     *         or {@code axis} is null
     * @since JavaFX 8.0
     */
    public void appendRotation(double angle, Point3D pivot, Point3D axis) {
        appendRotation(angle, pivot.getX(), pivot.getY(), pivot.getZ(),
                axis.getX(), axis.getY(), axis.getZ());
    }

    /**
     * Implementation of the {@code appendRotation()} around an arbitrary axis.
     */
    private void rotate3D(double angle, double axisX, double axisY, double axisZ) {
        if (axisX == 0.0 &amp;&amp; axisY == 0.0) {
            if (axisZ &gt; 0.0) {
                rotate3D(angle);
            } else if (axisZ &lt; 0.0) {
                rotate3D(-angle);
            } // else rotating about zero vector - NOP
            return;
        }

        double mag = Math.sqrt(axisX * axisX + axisY * axisY + axisZ * axisZ);

        if (mag == 0.0) {
            return;
        }

        mag = 1.0 / mag;
        final double ax = axisX * mag;
        final double ay = axisY * mag;
        final double az = axisZ * mag;

        final double sinTheta = Math.sin(Math.toRadians(angle));
        final double cosTheta = Math.cos(Math.toRadians(angle));
        final double t = 1.0 - cosTheta;

        final double xz = ax * az;
        final double xy = ax * ay;
        final double yz = ay * az;

        final double Txx = t * ax * ax + cosTheta;
        final double Txy = t * xy - sinTheta * az;
        final double Txz = t * xz + sinTheta * ay;

        final double Tyx = t * xy + sinTheta * az;
        final double Tyy = t * ay * ay + cosTheta;
        final double Tyz = t * yz - sinTheta * ax;

        final double Tzx = t * xz - sinTheta * ay;
        final double Tzy = t * yz + sinTheta * ax;
        final double Tzz = t * az * az + cosTheta;

        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch (state2d) {
                    default:
                        stateError();
                        // cannot reach
                    case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                    case APPLY_SHEAR | APPLY_SCALE:
                        final double xx_sst = getMxx();
                        final double xy_sst = getMxy();
                        final double yx_sst = getMyx();
                        final double yy_sst = getMyy();
                        setMxx(xx_sst * Txx + xy_sst * Tyx);
                        setMxy(xx_sst * Txy + xy_sst * Tyy);
                        setMxz(xx_sst * Txz + xy_sst * Tyz);
                        setMyx(yx_sst * Txx + yy_sst * Tyx);
                        setMyy(yx_sst * Txy + yy_sst * Tyy);
                        setMyz(yx_sst * Txz + yy_sst * Tyz);
                        setMzx(Tzx);
                        setMzy(Tzy);
                        setMzz(Tzz);
                        break;
                    case APPLY_SHEAR | APPLY_TRANSLATE:
                    case APPLY_SHEAR:
                        final double xy_sht = getMxy();
                        final double yx_sht = getMyx();
                        setMxx(xy_sht * Tyx);
                        setMxy(xy_sht * Tyy);
                        setMxz(xy_sht * Tyz);
                        setMyx(yx_sht * Txx);
                        setMyy(yx_sht * Txy);
                        setMyz(yx_sht * Txz);
                        setMzx(Tzx);
                        setMzy(Tzy);
                        setMzz(Tzz);
                        break;
                    case APPLY_SCALE | APPLY_TRANSLATE:
                    case APPLY_SCALE:
                        final double xx_s = getMxx();
                        final double yy_s = getMyy();
                        setMxx(xx_s * Txx);
                        setMxy(xx_s * Txy);
                        setMxz(xx_s * Txz);
                        setMyx(yy_s * Tyx);
                        setMyy(yy_s * Tyy);
                        setMyz(yy_s * Tyz);
                        setMzx(Tzx);
                        setMzy(Tzy);
                        setMzz(Tzz);
                        break;
                    case APPLY_TRANSLATE:
                    case APPLY_IDENTITY:
                        setMxx(Txx);
                        setMxy(Txy);
                        setMxz(Txz);
                        setMyx(Tyx);
                        setMyy(Tyy);
                        setMyz(Tyz);
                        setMzx(Tzx);
                        setMzy(Tzy);
                        setMzz(Tzz);
                        break;
                }
                break;
            case APPLY_TRANSLATE:
                setMxx(Txx);
                setMxy(Txy);
                setMxz(Txz);
                setMyx(Tyx);
                setMyy(Tyy);
                setMyz(Tyz);
                setMzx(Tzx);
                setMzy(Tzy);
                setMzz(Tzz);
                break;
            case APPLY_SCALE:
            case APPLY_SCALE | APPLY_TRANSLATE:
                final double xx_st = getMxx();
                final double yy_st = getMyy();
                final double zz_st = getMzz();
                setMxx(xx_st * Txx);
                setMxy(xx_st * Txy);
                setMxz(xx_st * Txz);
                setMyx(yy_st * Tyx);
                setMyy(yy_st * Tyy);
                setMyz(yy_st * Tyz);
                setMzx(zz_st * Tzx);
                setMzy(zz_st * Tzy);
                setMzz(zz_st * Tzz);
                break;
            case APPLY_3D_COMPLEX:
                final double m_xx = getMxx();
                final double m_xy = getMxy();
                final double m_xz = getMxz();
                final double m_yx = getMyx();
                final double m_yy = getMyy();
                final double m_yz = getMyz();
                final double m_zx = getMzx();
                final double m_zy = getMzy();
                final double m_zz = getMzz();
                setMxx(m_xx * Txx + m_xy * Tyx + m_xz * Tzx /* + mxt * 0.0 */);
                setMxy(m_xx * Txy + m_xy * Tyy + m_xz * Tzy /* + mxt * 0.0 */);
                setMxz(m_xx * Txz + m_xy * Tyz + m_xz * Tzz /* + mxt * 0.0 */);
                setMyx(m_yx * Txx + m_yy * Tyx + m_yz * Tzx /* + myt * 0.0 */);
                setMyy(m_yx * Txy + m_yy * Tyy + m_yz * Tzy /* + myt * 0.0 */);
                setMyz(m_yx * Txz + m_yy * Tyz + m_yz * Tzz /* + myt * 0.0 */);
                setMzx(m_zx * Txx + m_zy * Tyx + m_zz * Tzx /* + mzt * 0.0 */);
                setMzy(m_zx * Txy + m_zy * Tyy + m_zz * Tzy /* + mzt * 0.0 */);
                setMzz(m_zx * Txz + m_zy * Tyz + m_zz * Tzz /* + mzt * 0.0 */);
                break;
        }
        updateState();
    }

    /**
     * Table of 2D state changes during predictable quadrant rotations where
     * the shear and scaleAffine values are swapped and negated.
     */
    private static final int rot90conversion[] = {
        /* IDENTITY =&gt; */        APPLY_SHEAR,
        /* TRANSLATE (TR) =&gt; */  APPLY_SHEAR | APPLY_TRANSLATE,
        /* SCALE (SC) =&gt; */      APPLY_SHEAR,
        /* SC | TR =&gt; */         APPLY_SHEAR | APPLY_TRANSLATE,
        /* SHEAR (SH) =&gt; */      APPLY_SCALE,
        /* SH | TR =&gt; */         APPLY_SCALE | APPLY_TRANSLATE,
        /* SH | SC =&gt; */         APPLY_SHEAR | APPLY_SCALE,
        /* SH | SC | TR =&gt; */    APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE,
    };

    /**
     * 2D implementation of {@code appendRotation}.
     * If this is a 3D transform, the call is redirected to {@code rotate3D()}.
     */
    private void rotate2D(double theta) {
        if (state3d != APPLY_NON_3D) {
            rotate3D(theta);
            return;
        }

        double sin = Math.sin(Math.toRadians(theta));
        if (sin == 1.0) {
            rotate2D_90();
        } else if (sin == -1.0) {
            rotate2D_270();
        } else {
            double cos = Math.cos(Math.toRadians(theta));
            if (cos == -1.0) {
                rotate2D_180();
            } else if (cos != 1.0) {
                double M0, M1;
                M0 = getMxx();
                M1 = getMxy();
                setMxx(cos * M0 + sin * M1);
                setMxy(-sin * M0 + cos * M1);
                M0 = getMyx();
                M1 = getMyy();
                setMyx(cos * M0 + sin * M1);
                setMyy(-sin * M0 + cos * M1);
                updateState2D();
            }
        }
    }

    /**
     * 2D implementation of {@code appendRotation} for 90 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 3D transform.
     */
    private void rotate2D_90() {
        double M0 = getMxx();
        setMxx(getMxy());
        setMxy(-M0);
        M0 = getMyx();
        setMyx(getMyy());
        setMyy(-M0);
        int newstate = rot90conversion[state2d];
        if ((newstate &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SCALE &amp;&amp;
                getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
            newstate -= APPLY_SCALE;
        } else if ((newstate &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SHEAR &amp;&amp;
                getMxy() == 0.0 &amp;&amp; getMyx() == 0.0) {
            newstate = (newstate &amp; ~APPLY_SHEAR | APPLY_SCALE);
        }
        state2d = newstate;
    }

    /**
     * 2D implementation of {@code appendRotation} for 180 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 3D transform.
     */
    private void rotate2D_180() {
        setMxx(-getMxx());
        setMyy(-getMyy());
        int oldstate = state2d;
        if ((oldstate &amp; (APPLY_SHEAR)) != 0) {
            // If there was a shear, then this rotation has no
            // effect on the state.
            setMxy(-getMxy());
            setMyx(-getMyx());
        } else {
            // No shear means the SCALE state may toggle when
            // m00 and m11 are negated.
            if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
                state2d = oldstate &amp; ~APPLY_SCALE;
            } else {
                state2d = oldstate | APPLY_SCALE;
            }
        }
    }

    /**
     * 2D implementation of {@code appendRotation} for 270 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 3D transform.
     */
    private void rotate2D_270() {
        double M0 = getMxx();
        setMxx(-getMxy());
        setMxy(M0);
        M0 = getMyx();
        setMyx(-getMyy());
        setMyy(M0);
        int newstate = rot90conversion[state2d];
        if ((newstate &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SCALE &amp;&amp;
                getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
            newstate -= APPLY_SCALE;
        } else if ((newstate &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SHEAR &amp;&amp;
                getMxy() == 0.0 &amp;&amp; getMyx() == 0.0) {
            newstate = (newstate &amp; ~APPLY_SHEAR | APPLY_SCALE);
        }
        state2d = newstate;
    }

    /**
     * 3D implementation of {@code appendRotation} around Z axis.
     * If this is a 2D transform, the call is redirected to {@code rotate2D()}.
     */
    private void rotate3D(double theta) {
        if (state3d == APPLY_NON_3D) {
            rotate2D(theta);
            return;
        }

        double sin = Math.sin(Math.toRadians(theta));
        if (sin == 1.0) {
            rotate3D_90();
        } else if (sin == -1.0) {
            rotate3D_270();
        } else {
            double cos = Math.cos(Math.toRadians(theta));
            if (cos == -1.0) {
                rotate3D_180();
            } else if (cos != 1.0) {
                double M0, M1;
                M0 = getMxx();
                M1 = getMxy();
                setMxx(cos * M0 + sin * M1);
                setMxy(-sin * M0 + cos * M1);
                M0 = getMyx();
                M1 = getMyy();
                setMyx(cos * M0 + sin * M1);
                setMyy(-sin * M0 + cos * M1);
                M0 = getMzx();
                M1 = getMzy();
                setMzx(cos * M0 + sin * M1);
                setMzy(-sin * M0 + cos * M1);
                updateState();
            }
        }
    }

    /**
     * 3D implementation of {@code appendRotation} for 90 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 2D transform.
     */
    private void rotate3D_90() {
        double M0 = getMxx();
        setMxx(getMxy());
        setMxy(-M0);
        M0 = getMyx();
        setMyx(getMyy());
        setMyy(-M0);
        M0 = getMzx();
        setMzx(getMzy());
        setMzy(-M0);
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_TRANSLATE:
                state3d = APPLY_3D_COMPLEX;
                return;
            case APPLY_SCALE:
            case APPLY_SCALE | APPLY_TRANSLATE:
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_3D_COMPLEX:
                updateState();
                return;
        }
    }

    /**
     * 3D implementation of {@code appendRotation} for 180 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 2D transform.
     */
    private void rotate3D_180() {
        final double mxx = getMxx();
        final double myy = getMyy();
        setMxx(-mxx);
        setMyy(-myy);
        if (state3d == APPLY_3D_COMPLEX) {
            setMxy(-getMxy());
            setMyx(-getMyx());
            setMzx(-getMzx());
            setMzy(-getMzy());
            updateState();
            return;
        }

        if (mxx == -1.0 &amp;&amp; myy == -1.0 &amp;&amp; getMzz() == 1.0) {
            // must have been 3d because of translation, which remained
            state3d &amp;= ~APPLY_SCALE;
        } else {
            state3d |= APPLY_SCALE;
        }
    }

    /**
     * 3D implementation of {@code appendRotation} for 270 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 2D transform.
     */
    private void rotate3D_270() {
        double M0 = getMxx();
        setMxx(-getMxy());
        setMxy(M0);
        M0 = getMyx();
        setMyx(-getMyy());
        setMyy(M0);
        M0 = getMzx();
        setMzx(-getMzy());
        setMzy(M0);
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_TRANSLATE:
                state3d = APPLY_3D_COMPLEX;
                return;
            case APPLY_SCALE:
            case APPLY_SCALE | APPLY_TRANSLATE:
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_3D_COMPLEX:
                updateState();
                return;
        }
    }

    /**
     * &lt;p&gt;
     * Prepends the 2D rotation to this instance.
     * It is equivalent to {@code prepend(new Rotate(angle))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified rotation first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @since JavaFX 8.0
     */
    public void prependRotation(double angle) {
        atomicChange.start();
        preRotate2D(angle);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the 2D rotation with pivot to this instance.
     * It is equivalent to {@code prepend(new Rotate(angle, pivotX, pivotY))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified rotation first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @since JavaFX 8.0
     */
    public void prependRotation(double angle, double pivotX, double pivotY) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0) {
            preTranslate2D(-pivotX, -pivotY);
            preRotate2D(angle);
            preTranslate2D(pivotX, pivotY);
        } else {
            preRotate2D(angle);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the 2D rotation with pivot to this instance.
     * It is equivalent to {@code prepend(new Rotate(angle, pivot.getX(),
     * pivot.getY()))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified rotation first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivot the rotation pivot point
     * @throws NullPointerException if the specified {@code pivot} is null
     * @since JavaFX 8.0
     */
    public void prependRotation(double angle, Point2D pivot) {
        prependRotation(angle, pivot.getX(), pivot.getY());
    }

    /**
     * &lt;p&gt;
     * Prepends the rotation to this instance.
     * It is equivalent to {@code prepend(new Rotate(angle, pivotX, pivotY,
     * pivotZ, new Point3D(axisX, axisY, axisZ)))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified rotation first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @param pivotZ the Z coordinate of the rotation pivot point
     * @param axisX the X coordinate magnitude of the rotation axis
     * @param axisY the Y coordinate magnitude of the rotation axis
     * @param axisZ the Z coordinate magnitude of the rotation axis
     * @since JavaFX 8.0
     */
    public void prependRotation(double angle,
            double pivotX, double pivotY, double pivotZ,
            double axisX, double axisY, double axisZ) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0 || pivotZ != 0.0) {
            preTranslate3D(-pivotX, -pivotY, -pivotZ);
            preRotate3D(angle, axisX, axisY, axisZ);
            preTranslate3D(pivotX, pivotY, pivotZ);
        } else {
            preRotate3D(angle, axisX, axisY, axisZ);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the rotation to this instance.
     * It is equivalent to {@code prepend(new Rotate(angle, pivotX, pivotY,
     * pivotZ, axis))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified rotation first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @param pivotZ the Z coordinate of the rotation pivot point
     * @param axis the rotation axis
     * @throws NullPointerException if the specified {@code axis} is null
     * @since JavaFX 8.0
     */
    public void prependRotation(double angle,
            double pivotX, double pivotY, double pivotZ,
            Point3D axis) {
        prependRotation(angle, pivotX, pivotY, pivotZ,
                axis.getX(), axis.getY(), axis.getZ());
    }

    /**
     * &lt;p&gt;
     * Prepends the rotation to this instance.
     * It is equivalent to {@code prepend(new Rotate(angle, pivot.getX(),
     * pivot.getY(), pivot.getZ(), axis))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified rotation first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivot the rotation pivot point
     * @param axis the rotation axis
     * @throws NullPointerException if the specified {@code pivot}
     *         or {@code axis} is null
     * @since JavaFX 8.0
     */
    public void prependRotation(double angle, Point3D pivot, Point3D axis) {
        prependRotation(angle, pivot.getX(), pivot.getY(), pivot.getZ(),
                axis.getX(), axis.getY(), axis.getZ());
    }

    /**
     * Implementation of the {@code prependRotation()} around an arbitrary axis.
     */
    private void preRotate3D(double angle,
            double axisX, double axisY, double axisZ) {

        if (axisX == 0.0 &amp;&amp; axisY == 0.0) {
            if (axisZ &gt; 0.0) {
                preRotate3D(angle);
            } else if (axisZ &lt; 0.0) {
                preRotate3D(-angle);
            } // else rotating about zero vector - NOP
            return;
        }

        double mag = Math.sqrt(axisX * axisX + axisY * axisY + axisZ * axisZ);

        if (mag == 0.0) {
            return;
        }

        mag = 1.0 / mag;
        final double ax = axisX * mag;
        final double ay = axisY * mag;
        final double az = axisZ * mag;

        final double sinTheta = Math.sin(Math.toRadians(angle));
        final double cosTheta = Math.cos(Math.toRadians(angle));
        final double t = 1.0 - cosTheta;

        final double xz = ax * az;
        final double xy = ax * ay;
        final double yz = ay * az;

        final double Txx = t * ax * ax + cosTheta;
        final double Txy = t * xy - sinTheta * az;
        final double Txz = t * xz + sinTheta * ay;

        final double Tyx = t * xy + sinTheta * az;
        final double Tyy = t * ay * ay + cosTheta;
        final double Tyz = t * yz - sinTheta * ax;

        final double Tzx = t * xz - sinTheta * ay;
        final double Tzy = t * yz + sinTheta * ax;
        final double Tzz = t * az * az + cosTheta;

        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch (state2d) {
                    default:
                        stateError();
                        // cannot reach
                    case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                        final double xx_sst = getMxx();
                        final double xy_sst = getMxy();
                        final double tx_sst = getTx();
                        final double yx_sst = getMyx();
                        final double yy_sst = getMyy();
                        final double ty_sst = getTy();
                        setMxx(Txx * xx_sst + Txy * yx_sst);
                        setMxy(Txx * xy_sst + Txy * yy_sst);
                        setMxz(Txz);
                        setTx( Txx * tx_sst  + Txy * ty_sst);
                        setMyx(Tyx * xx_sst + Tyy * yx_sst);
                        setMyy(Tyx * xy_sst + Tyy * yy_sst);
                        setMyz(Tyz);
                        setTy( Tyx * tx_sst  + Tyy * ty_sst);
                        setMzx(Tzx * xx_sst + Tzy * yx_sst);
                        setMzy(Tzx * xy_sst + Tzy * yy_sst);
                        setMzz(Tzz);
                        setTz( Tzx * tx_sst  + Tzy * ty_sst);
                        break;
                    case APPLY_SHEAR | APPLY_SCALE:
                        final double xx_ss = getMxx();
                        final double xy_ss = getMxy();
                        final double yx_ss = getMyx();
                        final double yy_ss = getMyy();
                        setMxx(Txx * xx_ss + Txy * yx_ss);
                        setMxy(Txx * xy_ss + Txy * yy_ss);
                        setMxz(Txz);
                        setMyx(Tyx * xx_ss + Tyy * yx_ss);
                        setMyy(Tyx * xy_ss + Tyy * yy_ss);
                        setMyz(Tyz);
                        setMzx(Tzx * xx_ss + Tzy * yx_ss);
                        setMzy(Tzx * xy_ss + Tzy * yy_ss);
                        setMzz(Tzz);
                        break;
                    case APPLY_SHEAR | APPLY_TRANSLATE:
                        final double xy_sht = getMxy();
                        final double tx_sht = getTx();
                        final double yx_sht = getMyx();
                        final double ty_sht = getTy();
                        setMxx(Txy * yx_sht);
                        setMxy(Txx * xy_sht);
                        setMxz(Txz);
                        setTx( Txx * tx_sht  + Txy * ty_sht);
                        setMyx(Tyy * yx_sht);
                        setMyy(Tyx * xy_sht);
                        setMyz(Tyz);
                        setTy( Tyx * tx_sht  + Tyy * ty_sht);
                        setMzx(Tzy * yx_sht);
                        setMzy(Tzx * xy_sht);
                        setMzz(Tzz);
                        setTz( Tzx * tx_sht  + Tzy * ty_sht);
                        break;
                    case APPLY_SHEAR:
                        final double xy_sh = getMxy();
                        final double yx_sh = getMyx();
                        setMxx(Txy * yx_sh);
                        setMxy(Txx * xy_sh);
                        setMxz(Txz);
                        setMyx(Tyy * yx_sh);
                        setMyy(Tyx * xy_sh);
                        setMyz(Tyz);
                        setMzx(Tzy * yx_sh);
                        setMzy(Tzx * xy_sh);
                        setMzz(Tzz);
                        break;
                    case APPLY_SCALE | APPLY_TRANSLATE:
                        final double xx_st = getMxx();
                        final double tx_st = getTx();
                        final double yy_st = getMyy();
                        final double ty_st = getTy();
                        setMxx(Txx * xx_st);
                        setMxy(Txy * yy_st);
                        setMxz(Txz);
                        setTx( Txx * tx_st  + Txy * ty_st);
                        setMyx(Tyx * xx_st);
                        setMyy(Tyy * yy_st);
                        setMyz(Tyz);
                        setTy( Tyx * tx_st  + Tyy * ty_st);
                        setMzx(Tzx * xx_st);
                        setMzy(Tzy * yy_st);
                        setMzz(Tzz);
                        setTz( Tzx * tx_st  + Tzy * ty_st);
                        break;
                    case APPLY_SCALE:
                        final double xx_s = getMxx();
                        final double yy_s = getMyy();
                        setMxx(Txx * xx_s);
                        setMxy(Txy * yy_s);
                        setMxz(Txz);
                        setMyx(Tyx * xx_s);
                        setMyy(Tyy * yy_s);
                        setMyz(Tyz);
                        setMzx(Tzx * xx_s);
                        setMzy(Tzy * yy_s);
                        setMzz(Tzz);
                        break;
                    case APPLY_TRANSLATE:
                        final double tx_t = getTx();
                        final double ty_t = getTy();
                        setMxx(Txx);
                        setMxy(Txy);
                        setMxz(Txz);
                        setTx( Txx * tx_t  + Txy * ty_t);
                        setMyx(Tyx);
                        setMyy(Tyy);
                        setMyz(Tyz);
                        setTy( Tyx * tx_t  + Tyy * ty_t);
                        setMzx(Tzx);
                        setMzy(Tzy);
                        setMzz(Tzz);
                        setTz( Tzx * tx_t  + Tzy * ty_t);
                        break;
                    case APPLY_IDENTITY:
                        setMxx(Txx);
                        setMxy(Txy);
                        setMxz(Txz);
                        setMyx(Tyx);
                        setMyy(Tyy);
                        setMyz(Tyz);
                        setMzx(Tzx);
                        setMzy(Tzy);
                        setMzz(Tzz);
                        break;
                }
                break;
            case APPLY_TRANSLATE:
                final double tx_t = getTx();
                final double ty_t = getTy();
                final double tz_t = getTz();
                setMxx(Txx);
                setMxy(Txy);
                setMxz(Txz);
                setMyx(Tyx);
                setMyy(Tyy);
                setMyz(Tyz);
                setMzx(Tzx);
                setMzy(Tzy);
                setMzz(Tzz);
                setTx( Txx * tx_t  + Txy * ty_t  + Txz * tz_t);
                setTy( Tyx * tx_t  + Tyy * ty_t  + Tyz * tz_t);
                setTz( Tzx * tx_t  + Tzy * ty_t  + Tzz * tz_t);
                break;
            case APPLY_SCALE:
                final double xx_s = getMxx();
                final double yy_s = getMyy();
                final double zz_s = getMzz();
                setMxx(Txx * xx_s);
                setMxy(Txy * yy_s);
                setMxz(Txz * zz_s);
                setMyx(Tyx * xx_s);
                setMyy(Tyy * yy_s);
                setMyz(Tyz * zz_s);
                setMzx(Tzx * xx_s);
                setMzy(Tzy * yy_s);
                setMzz(Tzz * zz_s);
                break;
            case APPLY_SCALE | APPLY_TRANSLATE:
                final double xx_st = getMxx();
                final double tx_st = getTx();
                final double yy_st = getMyy();
                final double ty_st = getTy();
                final double zz_st = getMzz();
                final double tz_st = getTz();
                setMxx(Txx * xx_st);
                setMxy(Txy * yy_st);
                setMxz(Txz * zz_st);
                setTx( Txx * tx_st  + Txy * ty_st  + Txz * tz_st);
                setMyx(Tyx * xx_st);
                setMyy(Tyy * yy_st);
                setMyz(Tyz * zz_st);
                setTy( Tyx * tx_st  + Tyy * ty_st  + Tyz * tz_st);
                setMzx(Tzx * xx_st);
                setMzy(Tzy * yy_st);
                setMzz(Tzz * zz_st);
                setTz( Tzx * tx_st  + Tzy * ty_st  + Tzz * tz_st);
                break;
            case APPLY_3D_COMPLEX:
                final double m_xx = getMxx();
                final double m_xy = getMxy();
                final double m_xz = getMxz();
                final double t_x = getTx();
                final double m_yx = getMyx();
                final double m_yy = getMyy();
                final double m_yz = getMyz();
                final double t_y = getTy();
                final double m_zx = getMzx();
                final double m_zy = getMzy();
                final double m_zz = getMzz();
                final double t_z = getTz();
                setMxx(Txx * m_xx + Txy * m_yx + Txz * m_zx /* + Ttx * 0.0 */);
                setMxy(Txx * m_xy + Txy * m_yy + Txz * m_zy /* + Ttx * 0.0 */);
                setMxz(Txx * m_xz + Txy * m_yz + Txz * m_zz /* + Ttx * 0.0 */);
                setTx( Txx * t_x  + Txy * t_y  + Txz * t_z  /* + Ttx * 0.0 */);
                setMyx(Tyx * m_xx + Tyy * m_yx + Tyz * m_zx /* + Tty * 0.0 */);
                setMyy(Tyx * m_xy + Tyy * m_yy + Tyz * m_zy /* + Tty * 0.0 */);
                setMyz(Tyx * m_xz + Tyy * m_yz + Tyz * m_zz /* + Tty * 0.0 */);
                setTy( Tyx * t_x  + Tyy * t_y  + Tyz * t_z  /* + Tty * 0.0 */);
                setMzx(Tzx * m_xx + Tzy * m_yx + Tzz * m_zx /* + Ttz * 0.0 */);
                setMzy(Tzx * m_xy + Tzy * m_yy + Tzz * m_zy /* + Ttz * 0.0 */);
                setMzz(Tzx * m_xz + Tzy * m_yz + Tzz * m_zz /* + Ttz * 0.0 */);
                setTz( Tzx * t_x  + Tzy * t_y  + Tzz * t_z  /* + Ttz * 0.0 */);
                break;
        }

        updateState();
    }

    /**
     * 2D implementation of {@code prependRotation}.
     * If this is a 3D transform, the call is redirected to {@code preRotate3D()}.
     */
    private void preRotate2D(double theta) {

        if (state3d != APPLY_NON_3D) {
            preRotate3D(theta);
            return;
        }

        double sin = Math.sin(Math.toRadians(theta));
        if (sin == 1.0) {
            preRotate2D_90();
        } else if (sin == -1.0) {
            preRotate2D_270();
        } else {
            double cos = Math.cos(Math.toRadians(theta));
            if (cos == -1.0) {
                preRotate2D_180();
            } else if (cos != 1.0) {
                double M0, M1;
                M0 = getMxx();
                M1 = getMyx();
                setMxx(cos * M0 - sin * M1);
                setMyx(sin * M0 + cos * M1);
                M0 = getMxy();
                M1 = getMyy();
                setMxy(cos * M0 - sin * M1);
                setMyy(sin * M0 + cos * M1);
                M0 = getTx();
                M1 = getTy();
                setTx(cos * M0 - sin * M1);
                setTy(sin * M0 + cos * M1);
                updateState2D();
            }
        }
    }

    /**
     * 2D implementation of {@code prependRotation} for 90 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 3D transform.
     */
    private void preRotate2D_90() {
        double M0 = getMxx();
        setMxx(-getMyx());
        setMyx(M0);
        M0 = getMxy();
        setMxy(-getMyy());
        setMyy(M0);
        M0 = getTx();
        setTx(-getTy());
        setTy(M0);

        int newstate = rot90conversion[state2d];
        if ((newstate &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SCALE &amp;&amp;
                getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
            newstate -= APPLY_SCALE;
        } else if ((newstate &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SHEAR &amp;&amp;
                getMxy() == 0.0 &amp;&amp; getMyx() == 0.0) {
            newstate = (newstate &amp; ~APPLY_SHEAR | APPLY_SCALE);
        }
        state2d = newstate;
    }

    /**
     * 2D implementation of {@code prependRotation} for 180 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 3D transform.
     */
    private void preRotate2D_180() {
        setMxx(-getMxx());
        setMxy(-getMxy());
        setTx(-getTx());
        setMyx(-getMyx());
        setMyy(-getMyy());
        setTy(-getTy());

        if ((state2d &amp; APPLY_SHEAR) != 0) {
            if (getMxx() == 0.0 &amp;&amp; getMyy() == 0.0) {
                state2d &amp;= ~APPLY_SCALE;
            } else {
                state2d |= APPLY_SCALE;
            }
        } else {
            if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
                state2d &amp;= ~APPLY_SCALE;
            } else {
                state2d |= APPLY_SCALE;
            }
        }
    }

    /**
     * 2D implementation of {@code prependRotation} for 270 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 3D transform.
     */
    private void preRotate2D_270() {
        double M0 = getMxx();
        setMxx(getMyx());
        setMyx(-M0);
        M0 = getMxy();
        setMxy(getMyy());
        setMyy(-M0);
        M0 = getTx();
        setTx(getTy());
        setTy(-M0);

        int newstate = rot90conversion[state2d];
        if ((newstate &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SCALE &amp;&amp;
                getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
            newstate -= APPLY_SCALE;
        } else if ((newstate &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SHEAR &amp;&amp;
                getMxy() == 0.0 &amp;&amp; getMyx() == 0.0) {
            newstate = (newstate &amp; ~APPLY_SHEAR | APPLY_SCALE);
        }
        state2d = newstate;
    }

    /**
     * 3D implementation of {@code prependRotation} around Z axis.
     * If this is a 2D transform, the call is redirected to {@code preRotate2D()}.
     */
    private void preRotate3D(double theta) {
        if (state3d == APPLY_NON_3D) {
            preRotate2D(theta);
            return;
        }

        double sin = Math.sin(Math.toRadians(theta));
        if (sin == 1.0) {
            preRotate3D_90();
        } else if (sin == -1.0) {
            preRotate3D_270();
        } else {
            double cos = Math.cos(Math.toRadians(theta));
            if (cos == -1.0) {
                preRotate3D_180();
            } else if (cos != 1.0) {
                double M0, M1;
                M0 = getMxx();
                M1 = getMyx();
                setMxx(cos * M0 - sin * M1);
                setMyx(sin * M0 + cos * M1);
                M0 = getMxy();
                M1 = getMyy();
                setMxy(cos * M0 - sin * M1);
                setMyy(sin * M0 + cos * M1);
                M0 = getMxz();
                M1 = getMyz();
                setMxz(cos * M0 - sin * M1);
                setMyz(sin * M0 + cos * M1);
                M0 = getTx();
                M1 = getTy();
                setTx(cos * M0 - sin * M1);
                setTy(sin * M0 + cos * M1);
                updateState();
            }
        }
    }

    /**
     * 3D implementation of {@code prependRotation} for 90 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 2D transform.
     */
    private void preRotate3D_90() {
        double M0 = getMxx();
        setMxx(-getMyx());
        setMyx(M0);
        M0 = getMxy();
        setMxy(-getMyy());
        setMyy(M0);
        M0 = getMxz();
        setMxz(-getMyz());
        setMyz(M0);
        M0 = getTx();
        setTx(-getTy());
        setTy(M0);

        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_TRANSLATE:
                state3d = APPLY_3D_COMPLEX;
                return;
            case APPLY_SCALE:
            case APPLY_SCALE | APPLY_TRANSLATE:
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_3D_COMPLEX:
                updateState();
                return;
        }
    }

    /**
     * 3D implementation of {@code prependRotation} for 180 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 2D transform.
     */
    private void preRotate3D_180() {
        final double mxx = getMxx();
        final double myy = getMyy();
        setMxx(-mxx);
        setMyy(-myy);
        setTx(-getTx());
        setTy(-getTy());

        if (state3d == APPLY_3D_COMPLEX) {
            setMxy(-getMxy());
            setMxz(-getMxz());
            setMyx(-getMyx());
            setMyz(-getMyz());
            updateState();
            return;
        }

        if (mxx == -1.0 &amp;&amp; myy == -1.0 &amp;&amp; getMzz() == 1.0) {
            // must have been 3d because of translation, which remained
            state3d &amp;= ~APPLY_SCALE;
        } else {
            state3d |= APPLY_SCALE;
        }
    }

    /**
     * 3D implementation of {@code prependRotation} for 270 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 2D transform.
     */
    private void preRotate3D_270() {
        double M0 = getMxx();
        setMxx(getMyx());
        setMyx(-M0);
        M0 = getMxy();
        setMxy(getMyy());
        setMyy(-M0);
        M0 = getMxz();
        setMxz(getMyz());
        setMyz(-M0);
        M0 = getTx();
        setTx(getTy());
        setTy(-M0);

        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_TRANSLATE:
                state3d = APPLY_3D_COMPLEX;
                return;
            case APPLY_SCALE:
            case APPLY_SCALE | APPLY_TRANSLATE:
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_3D_COMPLEX:
                updateState();
                return;
        }
    }

    /* *************************************************************************
     *                                                                         *
     *                     Transform, Inverse Transform                        *
     *                                                                         *
     **************************************************************************/

    @Override
    public Point2D transform(double x, double y) {
        ensureCanTransform2DPoint();

        switch (state2d) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                return new Point2D(
                    getMxx() * x + getMxy() * y + getTx(),
                    getMyx() * x + getMyy() * y + getTy());
            case APPLY_SHEAR | APPLY_SCALE:
                return new Point2D(
                    getMxx() * x + getMxy() * y,
                    getMyx() * x + getMyy() * y);
            case APPLY_SHEAR | APPLY_TRANSLATE:
                return new Point2D(
                        getMxy() * y + getTx(),
                        getMyx() * x + getTy());
            case APPLY_SHEAR:
                return new Point2D(getMxy() * y, getMyx() * x);
            case APPLY_SCALE | APPLY_TRANSLATE:
                return new Point2D(
                        getMxx() * x + getTx(),
                        getMyy() * y + getTy());
            case APPLY_SCALE:
                return new Point2D(getMxx() * x, getMyy() * y);
            case APPLY_TRANSLATE:
                return new Point2D(x + getTx(), y + getTy());
            case APPLY_IDENTITY:
                return new Point2D(x, y);
        }
    }

    @Override
    public Point3D transform(double x, double y, double z) {
        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch (state2d) {
                    default:
                        stateError();
                        // cannot reach
                    case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                        return new Point3D(
                            getMxx() * x + getMxy() * y + getTx(),
                            getMyx() * x + getMyy() * y + getTy(), z);
                    case APPLY_SHEAR | APPLY_SCALE:
                        return new Point3D(
                            getMxx() * x + getMxy() * y,
                            getMyx() * x + getMyy() * y, z);
                    case APPLY_SHEAR | APPLY_TRANSLATE:
                        return new Point3D(
                                getMxy() * y + getTx(), getMyx() * x + getTy(),
                                z);
                    case APPLY_SHEAR:
                        return new Point3D(getMxy() * y, getMyx() * x, z);
                    case APPLY_SCALE | APPLY_TRANSLATE:
                        return new Point3D(
                                getMxx() * x + getTx(), getMyy() * y + getTy(),
                                z);
                    case APPLY_SCALE:
                        return new Point3D(getMxx() * x, getMyy() * y, z);
                    case APPLY_TRANSLATE:
                        return new Point3D(x + getTx(), y + getTy(), z);
                    case APPLY_IDENTITY:
                        return new Point3D(x, y, z);
                }
            case APPLY_TRANSLATE:
                return new Point3D(x + getTx(), y + getTy(), z + getTz());
            case APPLY_SCALE:
                return new Point3D(getMxx() * x, getMyy() * y, getMzz() * z);
            case APPLY_SCALE | APPLY_TRANSLATE:
                return new Point3D(
                        getMxx() * x + getTx(),
                        getMyy() * y + getTy(),
                        getMzz() * z + getTz());
            case APPLY_3D_COMPLEX:
                return new Point3D(
                    getMxx() * x + getMxy() * y + getMxz() * z + getTx(),
                    getMyx() * x + getMyy() * y + getMyz() * z + getTy(),
                    getMzx() * x + getMzy() * y + getMzz() * z + getTz());
        }
    }

    @Override
    void transform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {

        double mxx, mxy, tx, myx, myy, ty;

        switch (state2d) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                mxx = getMxx(); mxy = getMxy(); tx = getTx();
                myx = getMyx(); myy = getMyy(); ty = getTy();
                while (--numPts &gt;= 0) {
                    final double x = srcPts[srcOff++];
                    final double y = srcPts[srcOff++];
                    dstPts[dstOff++] = mxx * x + mxy * y + tx;
                    dstPts[dstOff++] = myx * x + myy * y + ty;
                }
                return;
            case APPLY_SHEAR | APPLY_SCALE:
                mxx = getMxx(); mxy = getMxy();
                myx = getMyx(); myy = getMyy();
                while (--numPts &gt;= 0) {
                    final double x = srcPts[srcOff++];
                    final double y = srcPts[srcOff++];
                    dstPts[dstOff++] = mxx * x + mxy * y;
                    dstPts[dstOff++] = myx * x + myy * y;
                }
                return;
            case APPLY_SHEAR | APPLY_TRANSLATE:
                mxy = getMxy(); tx = getTx();
                myx = getMyx(); ty = getTy();
                while (--numPts &gt;= 0) {
                    final double x = srcPts[srcOff++];
                    dstPts[dstOff++] = mxy * srcPts[srcOff++] + tx;
                    dstPts[dstOff++] = myx * x + ty;
                }
                return;
            case APPLY_SHEAR:
                mxy = getMxy();
                myx = getMyx();
                while (--numPts &gt;= 0) {
                    final double x = srcPts[srcOff++];
                    dstPts[dstOff++] = mxy * srcPts[srcOff++];
                    dstPts[dstOff++] = myx * x;
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                mxx = getMxx(); tx = getTx();
                myy = getMyy(); ty = getTy();
                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = mxx * srcPts[srcOff++] + tx;
                    dstPts[dstOff++] = myy * srcPts[srcOff++] + ty;
                }
                return;
            case APPLY_SCALE:
                mxx = getMxx();
                myy = getMyy();
                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = mxx * srcPts[srcOff++];
                    dstPts[dstOff++] = myy * srcPts[srcOff++];
                }
                return;
            case APPLY_TRANSLATE:
                tx = getTx();
                ty = getTy();
                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = srcPts[srcOff++] + tx;
                    dstPts[dstOff++] = srcPts[srcOff++] + ty;
                }
                return;
            case APPLY_IDENTITY:
                if (srcPts != dstPts || srcOff != dstOff) {
                    System.arraycopy(srcPts, srcOff, dstPts, dstOff,
                                     numPts * 2);
                }
                return;
        }
    }

    @Override
    void transform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {

        double mxx, mxy, tx, myx, myy, ty, mzz, tz;

        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch (state2d) {
                    default:
                        stateError();
                        // cannot reach
                    case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                        mxx = getMxx(); mxy = getMxy(); tx = getTx();
                        myx = getMyx(); myy = getMyy(); ty = getTy();
                        while (--numPts &gt;= 0) {
                            final double x = srcPts[srcOff++];
                            final double y = srcPts[srcOff++];
                            dstPts[dstOff++] = mxx * x + mxy * y + tx;
                            dstPts[dstOff++] = myx * x + myy * y + ty;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_SHEAR | APPLY_SCALE:
                        mxx = getMxx(); mxy = getMxy();
                        myx = getMyx(); myy = getMyy();
                        while (--numPts &gt;= 0) {
                            final double x = srcPts[srcOff++];
                            final double y = srcPts[srcOff++];
                            dstPts[dstOff++] = mxx * x + mxy * y;
                            dstPts[dstOff++] = myx * x + myy * y;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_SHEAR | APPLY_TRANSLATE:
                        mxy = getMxy(); tx = getTx();
                        myx = getMyx(); ty = getTy();
                        while (--numPts &gt;= 0) {
                            final double x = srcPts[srcOff++];
                            dstPts[dstOff++] = mxy * srcPts[srcOff++] + tx;
                            dstPts[dstOff++] = myx * x + ty;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_SHEAR:
                        mxy = getMxy();
                        myx = getMyx();
                        while (--numPts &gt;= 0) {
                            final double x = srcPts[srcOff++];
                            dstPts[dstOff++] = mxy * srcPts[srcOff++];
                            dstPts[dstOff++] = myx * x;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_SCALE | APPLY_TRANSLATE:
                        mxx = getMxx(); tx = getTx();
                        myy = getMyy(); ty = getTy();
                        while (--numPts &gt;= 0) {
                            dstPts[dstOff++] = mxx * srcPts[srcOff++] + tx;
                            dstPts[dstOff++] = myy * srcPts[srcOff++] + ty;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_SCALE:
                        mxx = getMxx();
                        myy = getMyy();
                        while (--numPts &gt;= 0) {
                            dstPts[dstOff++] = mxx * srcPts[srcOff++];
                            dstPts[dstOff++] = myy * srcPts[srcOff++];
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_TRANSLATE:
                        tx = getTx();
                        ty = getTy();
                        while (--numPts &gt;= 0) {
                            dstPts[dstOff++] = srcPts[srcOff++] + tx;
                            dstPts[dstOff++] = srcPts[srcOff++] + ty;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_IDENTITY:
                        if (srcPts != dstPts || srcOff != dstOff) {
                            System.arraycopy(srcPts, srcOff, dstPts, dstOff,
                                             numPts * 3);
                        }
                        return;
                }
                // cannot reach
            case APPLY_TRANSLATE:
                tx = getTx();
                ty = getTy();
                tz = getTz();
                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = srcPts[srcOff++] + tx;
                    dstPts[dstOff++] = srcPts[srcOff++] + ty;
                    dstPts[dstOff++] = srcPts[srcOff++] + tz;
                }
                return;
            case APPLY_SCALE:
                mxx = getMxx();
                myy = getMyy();
                mzz = getMzz();
                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = mxx * srcPts[srcOff++];
                    dstPts[dstOff++] = myy * srcPts[srcOff++];
                    dstPts[dstOff++] = mzz * srcPts[srcOff++];
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                mxx = getMxx(); tx = getTx();
                myy = getMyy(); ty = getTy();
                mzz = getMzz(); tz = getTz();
                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = mxx * srcPts[srcOff++] + tx;
                    dstPts[dstOff++] = myy * srcPts[srcOff++] + ty;
                    dstPts[dstOff++] = mzz * srcPts[srcOff++] + tz;
                }
                return;
            case APPLY_3D_COMPLEX:
                mxx = getMxx();
                mxy = getMxy();
                double mxz = getMxz();
                tx = getTx();
                myx = getMyx();
                myy = getMyy();
                double myz = getMyz();
                ty = getTy();
                double mzx = getMzx();
                double mzy = getMzy();
                mzz = getMzz();
                tz = getTz();

                while (--numPts &gt;= 0) {
                    final double x = srcPts[srcOff++];
                    final double y = srcPts[srcOff++];
                    final double z = srcPts[srcOff++];

                    dstPts[dstOff++] = mxx * x + mxy * y + mxz * z + tx;
                    dstPts[dstOff++] = myx * x + myy * y + myz * z + ty;
                    dstPts[dstOff++] = mzx * x + mzy * y + mzz * z + tz;
                }
                return;
        }
    }

    @Override
    public Point2D deltaTransform(double x, double y) {
        ensureCanTransform2DPoint();

        switch (state2d) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SHEAR | APPLY_SCALE:
                return new Point2D(
                    getMxx() * x + getMxy() * y,
                    getMyx() * x + getMyy() * y);
            case APPLY_SHEAR | APPLY_TRANSLATE:
            case APPLY_SHEAR:
                return new Point2D(getMxy() * y, getMyx() * x);
            case APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SCALE:
                return new Point2D(getMxx() * x, getMyy() * y);
            case APPLY_TRANSLATE:
            case APPLY_IDENTITY:
                return new Point2D(x, y);
        }
    }

    @Override
    public Point3D deltaTransform(double x, double y, double z) {
        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch (state2d) {
                    default:
                        stateError();
                        // cannot reach
                    case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                    case APPLY_SHEAR | APPLY_SCALE:
                        return new Point3D(
                            getMxx() * x + getMxy() * y,
                            getMyx() * x + getMyy() * y, z);
                    case APPLY_SHEAR | APPLY_TRANSLATE:
                    case APPLY_SHEAR:
                        return new Point3D(getMxy() * y, getMyx() * x, z);
                    case APPLY_SCALE | APPLY_TRANSLATE:
                    case APPLY_SCALE:
                        return new Point3D(getMxx() * x, getMyy() * y, z);
                    case APPLY_TRANSLATE:
                    case APPLY_IDENTITY:
                        return new Point3D(x, y, z);
                }
            case APPLY_TRANSLATE:
                return new Point3D(x, y, z);
            case APPLY_SCALE:
            case APPLY_SCALE | APPLY_TRANSLATE:
                return new Point3D(getMxx() * x, getMyy() * y, getMzz() * z);
            case APPLY_3D_COMPLEX:
                return new Point3D(
                    getMxx() * x + getMxy() * y + getMxz() * z,
                    getMyx() * x + getMyy() * y + getMyz() * z,
                    getMzx() * x + getMzy() * y + getMzz() * z);
        }
    }

    @Override
    public Point2D inverseTransform(double x, double y)
            throws NonInvertibleTransformException {
        ensureCanTransform2DPoint();

        switch (state2d) {
            default:
                return super.inverseTransform(x, y);
            case APPLY_SHEAR | APPLY_TRANSLATE:
                final double mxy_st = getMxy();
                final double myx_st = getMyx();
                if (mxy_st == 0.0 || myx_st == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point2D(
                        (1.0 / myx_st) * y - getTy() / myx_st,
                        (1.0 / mxy_st) * x - getTx() / mxy_st);
            case APPLY_SHEAR:
                final double mxy_s = getMxy();
                final double myx_s = getMyx();
                if (mxy_s == 0.0 || myx_s == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point2D((1.0 / myx_s) * y, (1.0 / mxy_s) * x);
            case APPLY_SCALE | APPLY_TRANSLATE:
                final double mxx_st = getMxx();
                final double myy_st = getMyy();
                if (mxx_st == 0.0 || myy_st == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point2D(
                        (1.0 / mxx_st) * x - getTx() / mxx_st,
                        (1.0 / myy_st) * y - getTy() / myy_st);
            case APPLY_SCALE:
                final double mxx_s = getMxx();
                final double myy_s = getMyy();
                if (mxx_s == 0.0 || myy_s == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point2D((1.0 / mxx_s) * x, (1.0 / myy_s) * y);
            case APPLY_TRANSLATE:
                return new Point2D(x - getTx(), y - getTy());
            case APPLY_IDENTITY:
                return new Point2D(x, y);
        }
    }

    @Override
    public Point3D inverseTransform(double x, double y, double z)
            throws NonInvertibleTransformException {
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch (state2d) {
                    default:
                        return super.inverseTransform(x, y, z);
                    case APPLY_SHEAR | APPLY_TRANSLATE:
                        final double mxy_st = getMxy();
                        final double myx_st = getMyx();
                        if (mxy_st == 0.0 || myx_st == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }
                        return new Point3D(
                                (1.0 / myx_st) * y - getTy() / myx_st,
                                (1.0 / mxy_st) * x - getTx() / mxy_st, z);
                    case APPLY_SHEAR:
                        final double mxy_s = getMxy();
                        final double myx_s = getMyx();
                        if (mxy_s == 0.0 || myx_s == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }
                        return new Point3D(
                                (1.0 / myx_s) * y,
                                (1.0 / mxy_s) * x, z);
                    case APPLY_SCALE | APPLY_TRANSLATE:
                        final double mxx_st = getMxx();
                        final double myy_st = getMyy();
                        if (mxx_st == 0.0 || myy_st == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }
                        return new Point3D(
                                (1.0 / mxx_st) * x - getTx() / mxx_st,
                                (1.0 / myy_st) * y - getTy() / myy_st, z);
                    case APPLY_SCALE:
                        final double mxx_s = getMxx();
                        final double myy_s = getMyy();
                        if (mxx_s == 0.0 || myy_s == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }
                        return new Point3D((1.0 / mxx_s) * x, (1.0 / myy_s) * y, z);
                    case APPLY_TRANSLATE:
                        return new Point3D(x - getTx(), y - getTy(), z);
                    case APPLY_IDENTITY:
                        return new Point3D(x, y, z);
                }
            case APPLY_TRANSLATE:
                return new Point3D(x - getTx(), y - getTy(), z - getTz());
            case APPLY_SCALE:
                final double mxx_s = getMxx();
                final double myy_s = getMyy();
                final double mzz_s = getMzz();
                if (mxx_s == 0.0 || myy_s == 0.0 || mzz_s == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point3D(
                        (1.0 / mxx_s) * x,
                        (1.0 / myy_s) * y,
                        (1.0 / mzz_s) * z);
            case APPLY_SCALE | APPLY_TRANSLATE:
                final double mxx_st = getMxx();
                final double myy_st = getMyy();
                final double mzz_st = getMzz();
                if (mxx_st == 0.0 || myy_st == 0.0 || mzz_st == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point3D(
                        (1.0 / mxx_st) * x - getTx() / mxx_st,
                        (1.0 / myy_st) * y - getTy() / myy_st,
                        (1.0 / mzz_st) * z - getTz() / mzz_st);
            case APPLY_3D_COMPLEX:
                return super.inverseTransform(x, y, z);
        }
    }

    @Override
    void inverseTransform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts)
            throws NonInvertibleTransformException {

        double mxx, mxy, tx, myx, myy, ty, tmp;

        switch (state2d) {
            default:
                super.inverseTransform2DPointsImpl(srcPts, srcOff,
                        dstPts, dstOff, numPts);
                return;

            case APPLY_SHEAR | APPLY_TRANSLATE:
                mxy = getMxy(); tx = getTx();
                myx = getMyx(); ty = getTy();
                if (mxy == 0.0 || myx == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }

                tmp = tx;
                tx = -ty / myx;
                ty = -tmp / mxy;

                tmp = myx;
                myx = 1.0 / mxy;
                mxy = 1.0 / tmp;

                while (--numPts &gt;= 0) {
                    final double x = srcPts[srcOff++];
                    dstPts[dstOff++] = mxy * srcPts[srcOff++] + tx;
                    dstPts[dstOff++] = myx * x + ty;
                }
                return;
            case APPLY_SHEAR:
                mxy = getMxy();
                myx = getMyx();
                if (mxy == 0.0 || myx == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }

                tmp = myx;
                myx = 1.0 / mxy;
                mxy = 1.0 / tmp;

                while (--numPts &gt;= 0) {
                    final double x = srcPts[srcOff++];
                    dstPts[dstOff++] = mxy * srcPts[srcOff++];
                    dstPts[dstOff++] = myx * x;
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                mxx = getMxx(); tx = getTx();
                myy = getMyy(); ty = getTy();
                if (mxx == 0.0 || myy == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }

                tx = -tx / mxx;
                ty = -ty / myy;
                mxx = 1.0 / mxx;
                myy = 1.0 / myy;

                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = mxx * srcPts[srcOff++] + tx;
                    dstPts[dstOff++] = myy * srcPts[srcOff++] + ty;
                }
                return;
            case APPLY_SCALE:
                mxx = getMxx();
                myy = getMyy();
                if (mxx == 0.0 || myy == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }

                mxx = 1.0 / mxx;
                myy = 1.0 / myy;

                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = mxx * srcPts[srcOff++];
                    dstPts[dstOff++] = myy * srcPts[srcOff++];
                }
                return;
            case APPLY_TRANSLATE:
                tx = getTx();
                ty = getTy();
                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = srcPts[srcOff++] - tx;
                    dstPts[dstOff++] = srcPts[srcOff++] - ty;
                }
                return;
            case APPLY_IDENTITY:
                if (srcPts != dstPts || srcOff != dstOff) {
                    System.arraycopy(srcPts, srcOff, dstPts, dstOff,
                                     numPts * 2);
                }
                return;
        }
    }

    @Override
    void inverseTransform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts)
            throws NonInvertibleTransformException {

        double mxx, mxy, tx, myx, myy, ty, mzz, tz, tmp;

        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch (state2d) {
                    default:
                        super.inverseTransform3DPointsImpl(srcPts, srcOff,
                                dstPts, dstOff, numPts);
                        return;

                    case APPLY_SHEAR | APPLY_TRANSLATE:
                        mxy = getMxy(); tx = getTx();
                        myx = getMyx(); ty = getTy();
                        if (mxy == 0.0 || myx == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }

                        tmp = tx;
                        tx = -ty / myx;
                        ty = -tmp / mxy;

                        tmp = myx;
                        myx = 1.0 / mxy;
                        mxy = 1.0 / tmp;

                        while (--numPts &gt;= 0) {
                            final double x = srcPts[srcOff++];
                            dstPts[dstOff++] = mxy * srcPts[srcOff++] + tx;
                            dstPts[dstOff++] = myx * x + ty;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_SHEAR:
                        mxy = getMxy();
                        myx = getMyx();
                        if (mxy == 0.0 || myx == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }

                        tmp = myx;
                        myx = 1.0 / mxy;
                        mxy = 1.0 / tmp;

                        while (--numPts &gt;= 0) {
                            final double x = srcPts[srcOff++];
                            dstPts[dstOff++] = mxy * srcPts[srcOff++];
                            dstPts[dstOff++] = myx * x;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_SCALE | APPLY_TRANSLATE:
                        mxx = getMxx(); tx = getTx();
                        myy = getMyy(); ty = getTy();
                        if (mxx == 0.0 || myy == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }

                        tx = -tx / mxx;
                        ty = -ty / myy;
                        mxx = 1.0 / mxx;
                        myy = 1.0 / myy;

                        while (--numPts &gt;= 0) {
                            dstPts[dstOff++] = mxx * srcPts[srcOff++] + tx;
                            dstPts[dstOff++] = myy * srcPts[srcOff++] + ty;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_SCALE:
                        mxx = getMxx();
                        myy = getMyy();
                        if (mxx == 0.0 || myy == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }

                        mxx = 1.0 / mxx;
                        myy = 1.0 / myy;

                        while (--numPts &gt;= 0) {
                            dstPts[dstOff++] = mxx * srcPts[srcOff++];
                            dstPts[dstOff++] = myy * srcPts[srcOff++];
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_TRANSLATE:
                        tx = getTx();
                        ty = getTy();
                        while (--numPts &gt;= 0) {
                            dstPts[dstOff++] = srcPts[srcOff++] - tx;
                            dstPts[dstOff++] = srcPts[srcOff++] - ty;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_IDENTITY:
                        if (srcPts != dstPts || srcOff != dstOff) {
                            System.arraycopy(srcPts, srcOff, dstPts, dstOff,
                                             numPts * 3);
                        }
                        return;
                }
                // cannot reach
            case APPLY_TRANSLATE:
                tx = getTx();
                ty = getTy();
                tz = getTz();
                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = srcPts[srcOff++] - tx;
                    dstPts[dstOff++] = srcPts[srcOff++] - ty;
                    dstPts[dstOff++] = srcPts[srcOff++] - tz;
                }
                return;
            case APPLY_SCALE:
                mxx = getMxx();
                myy = getMyy();
                mzz = getMzz();
                if (mxx == 0.0 || myy == 0.0 | mzz == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }

                mxx = 1.0 / mxx;
                myy = 1.0 / myy;
                mzz = 1.0 / mzz;

                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = mxx * srcPts[srcOff++];
                    dstPts[dstOff++] = myy * srcPts[srcOff++];
                    dstPts[dstOff++] = mzz * srcPts[srcOff++];
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                mxx = getMxx(); tx = getTx();
                myy = getMyy(); ty = getTy();
                mzz = getMzz(); tz = getTz();
                if (mxx == 0.0 || myy == 0.0 || mzz == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }

                tx = -tx / mxx;
                ty = -ty / myy;
                tz = -tz / mzz;
                mxx = 1.0 / mxx;
                myy = 1.0 / myy;
                mzz = 1.0 / mzz;

                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = mxx * srcPts[srcOff++] + tx;
                    dstPts[dstOff++] = myy * srcPts[srcOff++] + ty;
                    dstPts[dstOff++] = mzz * srcPts[srcOff++] + tz;
                }
                return;
            case APPLY_3D_COMPLEX:
                super.inverseTransform3DPointsImpl(srcPts, srcOff,
                        dstPts, dstOff, numPts);
                return;
        }
    }

    @Override
    public Point2D inverseDeltaTransform(double x, double y)
            throws NonInvertibleTransformException {
        ensureCanTransform2DPoint();

        switch (state2d) {
            default:
                return super.inverseDeltaTransform(x, y);
            case APPLY_SHEAR | APPLY_TRANSLATE:
            case APPLY_SHEAR:
                final double mxy_s = getMxy();
                final double myx_s = getMyx();
                if (mxy_s == 0.0 || myx_s == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point2D((1.0 / myx_s) * y, (1.0 / mxy_s) * x);
            case APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SCALE:
                final double mxx_s = getMxx();
                final double myy_s = getMyy();
                if (mxx_s == 0.0 || myy_s == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point2D((1.0 / mxx_s) * x, (1.0 / myy_s) * y);
            case APPLY_TRANSLATE:
            case APPLY_IDENTITY:
                return new Point2D(x, y);
        }
    }

    @Override
    public Point3D inverseDeltaTransform(double x, double y, double z)
            throws NonInvertibleTransformException {
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch (state2d) {
                    default:
                        return super.inverseDeltaTransform(x, y, z);
                    case APPLY_SHEAR | APPLY_TRANSLATE:
                    case APPLY_SHEAR:
                        final double mxy_s = getMxy();
                        final double myx_s = getMyx();
                        if (mxy_s == 0.0 || myx_s == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }
                        return new Point3D(
                                (1.0 / myx_s) * y,
                                (1.0 / mxy_s) * x, z);
                    case APPLY_SCALE | APPLY_TRANSLATE:
                    case APPLY_SCALE:
                        final double mxx_s = getMxx();
                        final double myy_s = getMyy();
                        if (mxx_s == 0.0 || myy_s == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }
                        return new Point3D(
                                (1.0 / mxx_s) * x,
                                (1.0 / myy_s) * y, z);
                    case APPLY_TRANSLATE:
                    case APPLY_IDENTITY:
                        return new Point3D(x, y, z);
                }

            case APPLY_TRANSLATE:
                return new Point3D(x, y, z);
            case APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SCALE:
                final double mxx_s = getMxx();
                final double myy_s = getMyy();
                final double mzz_s = getMzz();
                if (mxx_s == 0.0 || myy_s == 0.0 || mzz_s == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point3D(
                        (1.0 / mxx_s) * x,
                        (1.0 / myy_s) * y,
                        (1.0 / mzz_s) * z);
            case APPLY_3D_COMPLEX:
                return super.inverseDeltaTransform(x, y, z);
        }
    }

    /* *************************************************************************
     *                                                                         *
     *                               Other API                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns a string representation of this {@code Affine} object.
     * @return a string representation of this {@code Affine} object.
     */
    @Override
    public String toString() {
       final StringBuilder sb = new StringBuilder(&quot;Affine [\n&quot;);

        sb.append(&quot;\t&quot;).append(getMxx());
        sb.append(&quot;, &quot;).append(getMxy());
        sb.append(&quot;, &quot;).append(getMxz());
        sb.append(&quot;, &quot;).append(getTx());
        sb.append('\n');
        sb.append(&quot;\t&quot;).append(getMyx());
        sb.append(&quot;, &quot;).append(getMyy());
        sb.append(&quot;, &quot;).append(getMyz());
        sb.append(&quot;, &quot;).append(getTy());
        sb.append('\n');
        sb.append(&quot;\t&quot;).append(getMzx());
        sb.append(&quot;, &quot;).append(getMzy());
        sb.append(&quot;, &quot;).append(getMzz());
        sb.append(&quot;, &quot;).append(getTz());

        return sb.append(&quot;\n]&quot;).toString();
    }

    /* *************************************************************************
     *                                                                         *
     *                    Internal implementation stuff                        *
     *                                                                         *
     **************************************************************************/

    /**
     * Manually recalculates the state of the transform when the matrix
     * changes too much to predict the effects on the state.
     * The following tables specify what the various settings of the
     * state fields say about the values of the corresponding matrix
     * element fields.
     *
     * &lt;h4&gt;state3d:&lt;/h4&gt;
     * &lt;pre&gt;
     *                     SCALE          TRANSLATE        OTHER ELEMENTS
     *                 mxx, myy, mzz      tx, ty, tz       all remaining
     *
     * TRANSLATE (TR)       1.0           not all 0.0           0.0
     * SCALE (SC)       not all 1.0           0.0               0.0
     * TR | SC          not all 1.0       not all 0.0           0.0
     * 3D_COMPLEX           any               any            not all 0.0
     * NON_3D: mxz, myz, mzx, mzy, tz are 0.0, mzz is 1.0, for the rest
     *         see state2d
     * &lt;/pre&gt;
     *
     * &lt;h4&gt;state2d:&lt;/h4&gt;
     * Contains meaningful value only if state3d == APPLY_NON_3D.
     * Note that the rules governing the SCALE fields are slightly
     * different depending on whether the SHEAR flag is also set.
     * &lt;pre&gt;
     *                     SCALE            SHEAR          TRANSLATE
     *                    mxx/myy          mxy/myx           tx/ty
     *
     * IDENTITY             1.0              0.0              0.0
     * TRANSLATE (TR)       1.0              0.0          not both 0.0
     * SCALE (SC)       not both 1.0         0.0              0.0
     * TR | SC          not both 1.0         0.0          not both 0.0
     * SHEAR (SH)           0.0          not both 0.0         0.0
     * TR | SH              0.0          not both 0.0     not both 0.0
     * SC | SH          not both 0.0     not both 0.0         0.0
     * TR | SC | SH     not both 0.0     not both 0.0     not both 0.0
     * &lt;/pre&gt;
     */
    private void updateState() {
        updateState2D();

        state3d = APPLY_NON_3D;

        if (getMxz() != 0.0 ||
            getMyz() != 0.0 ||
            getMzx() != 0.0 ||
            getMzy() != 0.0)
        {
            state3d = APPLY_3D_COMPLEX;
        } else {
            if ((state2d &amp; APPLY_SHEAR) == 0) {
                if (getTz() != 0.0) {
                    state3d |= APPLY_TRANSLATE;
                }
                if (getMzz() != 1.0) {
                    state3d |= APPLY_SCALE;
                }
                if (state3d != APPLY_NON_3D) {
                    state3d |= (state2d &amp; (APPLY_SCALE | APPLY_TRANSLATE));
                }
            } else {
                if (getMzz() != 1.0 || getTz() != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
            }
        }
    }

    /**
     * 2D part of {@code updateState()}. It is sufficient to call this method
     * when we know this this a 2D transform and the operation was 2D-only
     * so it could not switch the transform to 3D.
     */
    private void updateState2D() {
        if (getMxy() == 0.0 &amp;&amp; getMyx() == 0.0) {
            if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = APPLY_IDENTITY;
                } else {
                    state2d = APPLY_TRANSLATE;
                }
            } else {
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = APPLY_SCALE;
                } else {
                    state2d = (APPLY_SCALE | APPLY_TRANSLATE);
                }
            }
        } else {
            if (getMxx() == 0.0 &amp;&amp; getMyy() == 0.0) {
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = APPLY_SHEAR;
                } else {
                    state2d = (APPLY_SHEAR | APPLY_TRANSLATE);
                }
            } else {
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = (APPLY_SHEAR | APPLY_SCALE);
                } else {
                    state2d = (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE);
                }
            }
        }
    }

    /**
     * Convenience method used internally to throw exceptions when
     * a case was forgotten in a switch statement.
     */
    private static void stateError() {
        throw new InternalError(&quot;missing case in a switch&quot;);
    }

    @Override
    void apply(final Affine3D trans) {
        trans.concatenate(getMxx(), getMxy(), getMxz(), getTx(),
                          getMyx(), getMyy(), getMyz(), getTy(),
                          getMzx(), getMzy(), getMzz(), getTz());
    }

    @Override
    BaseTransform derive(final BaseTransform trans) {
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch(state2d) {
                    case APPLY_IDENTITY:
                        return trans;
                    case APPLY_TRANSLATE:
                        return trans.deriveWithTranslation(getTx(), getTy());
                    case APPLY_SCALE:
                        return trans.deriveWithScale(getMxx(), getMyy(), 1.0);
                    case APPLY_SCALE | APPLY_TRANSLATE:
                        // fall through
                    default:
                        return trans.deriveWithConcatenation(
                                getMxx(), getMyx(),
                                getMxy(), getMyy(),
                                getTx(), getTy());
                }
            case APPLY_TRANSLATE:
                return trans.deriveWithTranslation(getTx(), getTy(), getTz());
            case APPLY_SCALE:
                return trans.deriveWithScale(getMxx(), getMyy(), getMzz());
            case APPLY_SCALE | APPLY_TRANSLATE:
                // fall through
            case APPLY_3D_COMPLEX:
                return trans.deriveWithConcatenation(
                        getMxx(), getMxy(), getMxz(), getTx(),
                        getMyx(), getMyy(), getMyz(), getTy(),
                        getMzx(), getMzy(), getMzz(), getTz());
        }
    }

    /**
     * Keeps track of the atomic changes of more elements.
     * Don't forget to end or cancel a running atomic operation
     * when an exception is to be thrown during one.
     */
    private class AffineAtomicChange {
        private boolean running = false;

        private void start() {
            if (running) {
                throw new InternalError(&quot;Affine internal error: &quot;
                        + &quot;trying to run inner atomic operation&quot;);
            }
            if (mxx != null) mxx.preProcessAtomicChange();
            if (mxy != null) mxy.preProcessAtomicChange();
            if (mxz != null) mxz.preProcessAtomicChange();
            if (tx != null) tx.preProcessAtomicChange();
            if (myx != null) myx.preProcessAtomicChange();
            if (myy != null) myy.preProcessAtomicChange();
            if (myz != null) myz.preProcessAtomicChange();
            if (ty != null) ty.preProcessAtomicChange();
            if (mzx != null) mzx.preProcessAtomicChange();
            if (mzy != null) mzy.preProcessAtomicChange();
            if (mzz != null) mzz.preProcessAtomicChange();
            if (tz != null) tz.preProcessAtomicChange();
            running = true;
        }

        private void end() {
            running = false;
            transformChanged();
            if (mxx != null) mxx.postProcessAtomicChange();
            if (mxy != null) mxy.postProcessAtomicChange();
            if (mxz != null) mxz.postProcessAtomicChange();
            if (tx != null) tx.postProcessAtomicChange();
            if (myx != null) myx.postProcessAtomicChange();
            if (myy != null) myy.postProcessAtomicChange();
            if (myz != null) myz.postProcessAtomicChange();
            if (ty != null) ty.postProcessAtomicChange();
            if (mzx != null) mzx.postProcessAtomicChange();
            if (mzy != null) mzy.postProcessAtomicChange();
            if (mzz != null) mzz.postProcessAtomicChange();
            if (tz != null) tz.postProcessAtomicChange();
        }

        private void cancel() {
            running = false;
        }

        private boolean runs() {
            return running;
        }
    }

    /**
     * Used only by tests to check the 2d matrix state
     */
    int getState2d() {
        return state2d;
    }

    /**
     * Used only by tests to check the 3d matrix state
     */
    int getState3d() {
        return state3d;
    }

    /**
     * Used only by tests to check the atomic operation state
     */
    boolean atomicChangeRuns() {
        return atomicChange.runs();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/transform/Transform.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.transform;

import java.util.Iterator;

import com.sun.javafx.geometry.BoundsUtils;
import javafx.event.EventDispatchChain;

import javafx.scene.Node;

import com.sun.javafx.util.WeakReferenceQueue;
import com.sun.javafx.binding.ExpressionHelper;
import com.sun.javafx.event.EventHandlerManager;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.transform.TransformHelper;
import com.sun.javafx.scene.transform.TransformUtils;
import java.lang.ref.SoftReference;
import javafx.beans.InvalidationListener;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ChangeListener;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.event.EventType;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.geometry.Point3D;

// PENDING_DOC_REVIEW of this whole class
/**
 * This class is a base class for different affine transformations.
 * It provides factory methods for the simple transformations - rotating,
 * scaling, shearing, and translation. It allows to get the transformation
 * matrix elements for any transform.
 *
 * &lt;p&gt;Example:&lt;/p&gt;
 *
 * &lt;pre&gt;{@code
 *  Rectangle rect = new Rectangle(50,50, Color.RED);
 *  rect.getTransforms().add(new Rotate(45,0,0)); //rotate by 45 degrees
 * }&lt;/pre&gt;
 * @since JavaFX 2.0
 */
public abstract class Transform implements Cloneable, EventTarget {

    static {
        // This is used by classes in different packages to get access to
        // private and package private methods.
        TransformHelper.setTransformAccessor(new TransformHelper.TransformAccessor() {

            @Override
            public void add(Transform transform, Node node) {
                transform.add(node);
            }

            @Override
            public void remove(Transform transform, Node node) {
                transform.remove(node);
            }

            @Override
            public void apply(Transform transform, Affine3D affine3D) {
                transform.apply(affine3D);
            }

            @Override
            public BaseTransform derive(Transform transform, BaseTransform baseTransform) {
                return transform.derive(baseTransform);
            }

            @Override
            public Transform createImmutableTransform() {
                return Transform.createImmutableTransform();
            }

            @Override
            public Transform createImmutableTransform(
                    double mxx, double mxy, double mxz, double tx,
                    double myx, double myy, double myz, double ty,
                    double mzx, double mzy, double mzz, double tz) {
                return Transform.createImmutableTransform(mxx, mxy, mxz, tx,
                        myx, myy, myz, ty, mzx, mzy, mzz, tz);
            }

            @Override
            public Transform createImmutableTransform(Transform transform,
                    double mxx, double mxy, double mxz, double tx,
                    double myx, double myy, double myz, double ty,
                    double mzx, double mzy, double mzz, double tz) {
                return Transform.createImmutableTransform(transform,
                        mxx, mxy, mxz, tx, myx, myy, myz, ty, mzx, mzy, mzz, tz);
            }

            @Override
            public Transform createImmutableTransform(Transform transform,
                    Transform left, Transform right) {
                return Transform.createImmutableTransform(transform, left, right);
            }
        });
    }

    /* *************************************************************************
     *                                                                         *
     *                            Factories                                    *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns a new {@code Affine} object from 12 number
     * values representing the 6 specifiable entries of the 3x4
     * Affine transformation matrix.
     *
     * @param mxx the X coordinate scaling element of the 3x4 matrix
     * @param myx the Y coordinate shearing element of the 3x4 matrix
     * @param mxy the X coordinate shearing element of the 3x4 matrix
     * @param myy the Y coordinate scaling element of the 3x4 matrix
     * @param tx the X coordinate translation element of the 3x4 matrix
     * @param ty the Y coordinate translation element of the 3x4 matrix
     * @return a new {@code Affine} object derived from specified parameters
     */
    public static Affine affine(
        double mxx, double myx, double mxy, double myy, double tx, double ty) {
        final Affine affine = new Affine();
        affine.setMxx(mxx);
        affine.setMxy(mxy);
        affine.setTx(tx);
        affine.setMyx(myx);
        affine.setMyy(myy);
        affine.setTy(ty);
        return affine;
    }


    /**
     * Returns a new {@code Affine} object from 12 number
     * values representing the 12 specifiable entries of the 3x4
     * Affine transformation matrix.
     *
     * @param mxx the X coordinate scaling element of the 3x4 matrix
     * @param mxy the XY element of the 3x4 matrix
     * @param mxz the XZ element of the 3x4 matrix
     * @param tx the X coordinate translation element of the 3x4 matrix
     * @param myx the YX element of the 3x4 matrix
     * @param myy the Y coordinate scaling element of the 3x4 matrix
     * @param myz the YZ element of the 3x4 matrix
     * @param ty the Y coordinate translation element of the 3x4 matrix
     * @param mzx the ZX element of the 3x4 matrix
     * @param mzy the ZY element of the 3x4 matrix
     * @param mzz the Z coordinate scaling element of the 3x4 matrix
     * @param tz the Z coordinate translation element of the 3x4 matrix
     * @return a new {@code Affine} object derived from specified parameters
     */
    public static Affine affine(
        double mxx, double mxy, double mxz, double tx,
        double myx, double myy, double myz, double ty,
        double mzx, double mzy, double mzz, double tz) {
        final Affine affine = new Affine();
        affine.setMxx(mxx);
        affine.setMxy(mxy);
        affine.setMxz(mxz);
        affine.setTx(tx);
        affine.setMyx(myx);
        affine.setMyy(myy);
        affine.setMyz(myz);
        affine.setTy(ty);
        affine.setMzx(mzx);
        affine.setMzy(mzy);
        affine.setMzz(mzz);
        affine.setTz(tz);
        return affine;
    }


    /**
     * Returns a {@code Translate} object representing a translation transformation.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Translate(x, y);
     * &lt;/pre&gt;
     * @param x the translate x value
     * @param y the translate y value
     * @return the Translate object representing a translation transformation
<A NAME="50"></A>     */
    public static Translate translate(double x, double y) {
        final Translate translate = new Translate();
        <FONT color="#ff0000"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#50',2,'match46-top.html#50',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>translate.setX(x);
        translate.setY(y);
        return translate;
    }


    /**
     * Returns a {@code Rotate} object that rotates coordinates around a pivot
     * point.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Rotate(angle, pivotX, pivotY);
     * &lt;/pre&gt;
     * @param angle the rotation angle
     * @param pivotX the pivot x value
     * @param pivotY the pivot y value
     * @return the Rotate object that rotates coordinates around a pivot point
     */
    public static Rotate rotate(double angle, double pivotX, double pivotY) {
        final Rotate rotate = new Rotate();
        rotate.setAngle(angle);
        rotate.setPivotX(pivotX);
        rotate.setPivotY</B></FONT>(pivotY);
        return rotate;
    }


    /**
     * Returns a {@code Scale} object representing a scaling transformation.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Scale(x, y);
     * &lt;/pre&gt;
     * @param x the scale x value
     * @param y the scale y value
     * @return the Scale object representing a scaling transformation
     */
    public static Scale scale(double x, double y) {
        final Scale scale = new Scale();
        scale.setX(x);
        scale.setY(y);
        return scale;
    }


    /**
     * Returns a {@code Scale} object representing a scaling transformation.
     * The returned scale operation will be about the given pivot point.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Scale(x, y, pivotX, pivotY);
     * &lt;/pre&gt;
     * @param x the scale x value
     * @param y the scale y value
     * @param pivotX the pivot x value
     * @param pivotY the pivot y value
     * @return the Scale object representing a scaling transformation
     */
    public static Scale scale(double x, double y, double pivotX, double pivotY) {
        final Scale scale = new Scale();
        scale.setX(x);
        scale.setY(y);
        scale.setPivotX(pivotX);
        scale.setPivotY(pivotY);
        return scale;
    }


    /**
     * Returns a {@code Shear} object representing a shearing transformation.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Shear(x, y);
     * &lt;/pre&gt;
     * @param x the shear x value
     * @param y the shear y value
     * @return the Shear object representing a shearing transformation
     */
    public static Shear shear(double x, double y) {
        final Shear shear = new Shear();
        shear.setX(x);
        shear.setY(y);
        return shear;
    }

    /**
     * Returns a {@code Shear} object representing a shearing transformation.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Shear(x, y, pivotX, pivotY);
     * &lt;/pre&gt;
     * @param x the shear x value
     * @param y the shear y value
     * @param pivotX the pivot x value
     * @param pivotY the pivot y value
     * @return the Shear object representing a shearing transformation
     */
    public static Shear shear(double x, double y, double pivotX, double pivotY) {
        final Shear shear = new Shear();
        shear.setX(x);
        shear.setY(y);
        shear.setPivotX(pivotX);
        shear.setPivotY(pivotY);
        return shear;
    }

    /**
     * For transforms with expensive inversion we cache the inverted matrix
     * once it is needed and computed for some operation.
     */
    private SoftReference&lt;Transform&gt; inverseCache = null;

    private WeakReferenceQueue nodes = new WeakReferenceQueue();

    /* *************************************************************************
     *                                                                         *
     *                         Element getters                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Gets the X coordinate scaling element of the 3x4 matrix.
     *
     * @return the X coordinate scaling element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMxx() {
        return 1.0;
    }

    /**
     * Gets the XY coordinate element of the 3x4 matrix.
     *
     * @return the XY coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMxy() {
        return 0.0;
    }

    /**
     * Gets the XZ coordinate element of the 3x4 matrix.
     *
     * @return the XZ coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMxz() {
        return 0.0;
    }

    /**
     * Gets the X coordinate translation element of the 3x4 matrix.
     *
     * @return the X coordinate translation element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getTx() {
        return 0.0;
    }

    /**
     * Gets the YX coordinate element of the 3x4 matrix.
     *
     * @return the YX coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMyx() {
        return 0.0;
    }

    /**
     * Gets the Y coordinate scaling element of the 3x4 matrix.
     *
     * @return the Y coordinate scaling element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMyy() {
        return 1.0;
    }

    /**
     * Gets the YZ coordinate element of the 3x4 matrix.
     *
     * @return the YZ coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMyz() {
        return 0.0;
    }

    /**
     * Gets the Y coordinate translation element of the 3x4 matrix.
     *
     * @return the Y coordinate translation element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getTy() {
        return 0.0;
    }

    /**
     * Gets the ZX coordinate element of the 3x4 matrix.
     *
     * @return the ZX coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMzx() {
        return 0.0;
    }

    /**
     * Gets the ZY coordinate element of the 3x4 matrix.
     *
     * @return the ZY coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMzy() {
        return 0.0;
    }

    /**
     * Gets the Z coordinate scaling element of the 3x4 matrix.
     *
     * @return the Z coordinate scaling element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMzz() {
        return 1.0;
    }

    /**
     * Gets the Z coordinate translation element of the 3x4 matrix.
     *
     * @return the Z coordinate translation element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getTz() {
        return 0.0;
    }

    /**
     * Gets the specified element of the transformation matrix.
     * @param type type of matrix to get the value from
     * @param row zero-based row number
     * @param column zero-based column number
     * @return value of the specified transformation matrix element
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws IndexOutOfBoundsException if the indices are not within
     *         the specified matrix type
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double getElement(MatrixType type, int row, int column) {
        if (row &lt; 0 || row &gt;= type.rows() || column &lt; 0 || column &gt;= type.columns()) {
            throw new IndexOutOfBoundsException(&quot;Index outside of affine &quot;
                    + &quot;matrix &quot; + type + &quot;: [&quot; + row + &quot;, &quot; + column + &quot;]&quot;);
        }
        switch(type) {
            case MT_2D_2x3:
                // fall-through
            case MT_2D_3x3:
                if (!isType2D()) {
                    throw new IllegalArgumentException(&quot;Cannot access 2D matrix &quot;
                            + &quot;of a 3D transform&quot;);
                }
                switch(row) {
                    case 0:
                        switch(column) {
                            case 0: return getMxx();
                            case 1: return getMxy();
                            case 2: return getTx();
                        }
                    case 1:
                        switch(column) {
                            case 0: return getMyx();
                            case 1: return getMyy();
                            case 2: return getTy();
                        }
                    case 2:
                        switch(column) {
                            case 0: return 0.0;
                            case 1: return 0.0;
                            case 2: return 1.0;
                        }
                }
                break;
            case MT_3D_3x4:
                // fall-through
            case MT_3D_4x4:
                switch(row) {
                    case 0:
                        switch(column) {
                            case 0: return getMxx();
                            case 1: return getMxy();
                            case 2: return getMxz();
                            case 3: return getTx();
                        }
                    case 1:
                        switch(column) {
                            case 0: return getMyx();
                            case 1: return getMyy();
                            case 2: return getMyz();
                            case 3: return getTy();
                        }
                    case 2:
                        switch(column) {
                            case 0: return getMzx();
                            case 1: return getMzy();
                            case 2: return getMzz();
                            case 3: return getTz();
                        }
                    case 3:
                        switch(column) {
                            case 0: return 0.0;
                            case 1: return 0.0;
                            case 2: return 0.0;
                            case 3: return 1.0;
                        }
                }
                break;
        }
        // cannot reach here
        throw new InternalError(&quot;Unsupported matrix type &quot; + type);
    }

    /* *************************************************************************
     *                                                                         *
     *                           State getters                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Computes if this transform is currently a 2D transform (has no effect
     * in the direction of Z axis).
     * Used by the subclasses to effectively provide value of the type2D
     * property.
     * @return true if this transform is currently 2D-only
     */
    boolean computeIs2D() {
        return getMxz() == 0.0 &amp;&amp; getMzx() == 0.0 &amp;&amp; getMzy() == 0.0 &amp;&amp;
                    getMzz() == 1.0 &amp;&amp; getTz() == 0.0;
    }

    /**
     * Computes if this transform is currently an identity (has
     * no effect in any direction).
     * Used by the subclasses to effectively provide value of the identity
     * property.
     * @return true if this transform is currently an identity transform
     */
    boolean computeIsIdentity() {
        return
            getMxx() == 1.0 &amp;&amp; getMxy() == 0.0 &amp;&amp; getMxz() == 0.0 &amp;&amp; getTx() == 0.0 &amp;&amp;
            getMyx() == 0.0 &amp;&amp; getMyy() == 1.0 &amp;&amp; getMyz() == 0.0 &amp;&amp; getTy() == 0.0 &amp;&amp;
            getMzx() == 0.0 &amp;&amp; getMzy() == 0.0 &amp;&amp; getMzz() == 1.0 &amp;&amp; getTz() == 0.0;
    }

    /**
     * Computes determinant of the transformation matrix.
     * Among other things, determinant can be used for testing this transform's
     * invertibility - it is invertible if determinant is not equal to zero.
     * @return Determinant of the transformation matrix
     * @since JavaFX 8.0
     */
    public double determinant() {
        final double myx = getMyx();
        final double myy = getMyy();
        final double myz = getMyz();
        final double mzx = getMzx();
        final double mzy = getMzy();
        final double mzz = getMzz();

        return (getMxx() * (myy * mzz - mzy * myz) +
                getMxy() * (myz * mzx - mzz * myx) +
                getMxz() * (myx * mzy - mzx * myy));
    }

    /**
     * Determines if this is currently a 2D transform.
     * Transform is 2D if it has no effect along the Z axis.
     * @since JavaFX 8.0
     */
    private LazyBooleanProperty type2D;

    public final boolean isType2D() {
        return type2D == null ? computeIs2D() : type2D.get();
    }

    public final ReadOnlyBooleanProperty type2DProperty() {
        if (type2D == null) {
            type2D = new LazyBooleanProperty() {

                @Override
                protected boolean computeValue() {
                    return computeIs2D();
                }

                @Override
                public Object getBean() {
                    return Transform.this;
                }

                @Override
                public String getName() {
                    return &quot;type2D&quot;;
                }
            };
        }
        return type2D;
    }

    /**
     * Determines if this is currently an identity transform.
     * Identity transform has no effect on the transformed nodes.
     * @since JavaFX 8.0
     */
    private LazyBooleanProperty identity;

    public final boolean isIdentity() {
        return identity == null ? computeIsIdentity() : identity.get();
    }

    public final ReadOnlyBooleanProperty identityProperty() {
        if (identity == null) {
            identity = new LazyBooleanProperty() {

                @Override
                protected boolean computeValue() {
                    return computeIsIdentity();
                }

                @Override
                public Object getBean() {
                    return Transform.this;
                }

                @Override
                public String getName() {
                    return &quot;identity&quot;;
                }
            };
        }
        return identity;
    }

    /**
     * Lazily computed read-only boolean property implementation.
     * Used for type2D and identity properties.
     */
    private static abstract class LazyBooleanProperty
            extends ReadOnlyBooleanProperty {

        private ExpressionHelper&lt;Boolean&gt; helper;
        private boolean valid;
        private boolean value;

        @Override
        public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public boolean get() {
            if (!valid) {
                value = computeValue();
                valid = true;
            }

            return value;
        }

        public void invalidate() {
            if (valid) {
                valid = false;
                ExpressionHelper.fireValueChangedEvent(helper);
            }
        }

        protected abstract boolean computeValue();
    }

    /**
     * Transforms the specified point by this transform and by the specified
     * transform and returns distance of the result points. Used for similarTo
     * method. Has to be used only for 2D transforms (otherwise throws an
     * exception).
     * @param t the other transform
     * @param x point's X coordinate
     * @param y point's Y coordinate
     * @return distance of the transformed points
     */
    private double transformDiff(Transform t, double x, double y) {
        final Point2D byThis = transform(x, y);
        final Point2D byOther = t.transform(x, y);
        return byThis.distance(byOther);
    }

    /**
     * Transforms the specified point by this transform and by the specified
     * transform and returns distance of the result points. Used for similarTo
     * method.
     * @param t the other transform
     * @param x point's X coordinate
     * @param y point's Y coordinate
     * @param z point's Z coordinate
     * @return distance of the transformed points
     */
    private double transformDiff(Transform t, double x, double y, double z) {
        final Point3D byThis = transform(x, y, z);
        final Point3D byOther = t.transform(x, y, z);
        return byThis.distance(byOther);
    }

    /**
     * Checks if this transform is similar to the specified transform.
     * The two transforms are considered similar if any point from
     * {@code range} is transformed by them to points that are no farther
     * than {@code maxDelta} from each other.
     * @param transform transform to be compared to this transform
     * @param range region of interest on which the two transforms are compared
     * @param maxDelta maximum allowed distance for the results of transforming
     *                 any single point from {@code range} by the two transforms
     * @return true if the transforms are similar according to the specified
     *              criteria
     * @throws NullPointerException if the specified {@code transform}
     *         or {@code range} is null
     * @since JavaFX 8.0
     */
    public boolean similarTo(Transform transform, Bounds range, double maxDelta) {

        double cornerX, cornerY, cornerZ;

        if (isType2D() &amp;&amp; transform.isType2D()) {
            cornerX = range.getMinX();
            cornerY = range.getMinY();

            if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
                return false;
            }

            cornerY = range.getMaxY();
            if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
                return false;
            }

            cornerX = range.getMaxX();
            cornerY = range.getMinY();
            if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
                return false;
            }

            cornerY = range.getMaxY();
            if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
                return false;
            }

            return true;
        }

        cornerX = range.getMinX();
        cornerY = range.getMinY();
        cornerZ = range.getMinZ();
        if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
            return false;
        }

        cornerY = range.getMaxY();
        if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
            return false;
        }

        cornerX = range.getMaxX();
        cornerY = range.getMinY();
        if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
            return false;
        }

        cornerY = range.getMaxY();
        if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
            return false;
        }

        if (range.getDepth() != 0.0) {
            cornerX = range.getMinX();
            cornerY = range.getMinY();
            cornerZ = range.getMaxZ();
            if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
                return false;
            }

            cornerY = range.getMaxY();
            if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
                return false;
            }

            cornerX = range.getMaxX();
            cornerY = range.getMinY();
            if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
                return false;
            }

            cornerY = range.getMaxY();
            if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
                return false;
            }
        }

        return true;
    }

    /* *************************************************************************
     *                                                                         *
     *                           Array getters                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Core of the toArray implementation for the 2D case.
     * All of the checks has been made by the enclosing method as well as
     * the constant elements filled, this method only fills the varying
     * elements to the array. Used by subclasses to fill
     * the elements efficiently.
     * @param array array to be filled with the 6 2D elements
     */
    void fill2DArray(double[] array) {
        array[0] = getMxx();
        array[1] = getMxy();
        array[2] = getTx();
        array[3] = getMyx();
        array[4] = getMyy();
        array[5] = getTy();
    }

    /**
     * Core of the toArray implementation for the 3D case.
     * All of the checks has been made by the enclosing method as well as
     * the constant elements filled, this method only fills the varying
     * elements to the array. Used by subclasses to fill
     * the elements efficiently.
     * @param array array to be filled with the 12 3D elements
     */
    void fill3DArray(double[] array) {
        array[0] = getMxx();
        array[1] = getMxy();
        array[2] = getMxz();
        array[3] = getTx();
        array[4] = getMyx();
        array[5] = getMyy();
        array[6] = getMyz();
        array[7] = getTy();
        array[8] = getMzx();
        array[9] = getMzy();
        array[10] = getMzz();
        array[11] = getTz();
    }

    /**
     * Returns an array containing the flattened transformation matrix.
     * If the requested matrix type fits in the specified array, it is returned
     * therein. Otherwise, a new array is created.
     * @param type matrix type to be filled in the array
     * @param array array into which the elements of the matrix are to be
     *              stored, if it is non-null and big enough; otherwise,
     *              a new array is created for this purpose.
     * @return an array containing the elements of the requested matrix type
     *         representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] toArray(MatrixType type, double[] array) {
        checkRequestedMAT(type);

        if (array == null || array.length &lt; type.elements()) {
            array = new double[type.elements()];
        }

        switch (type) {
            case MT_2D_3x3:
                array[6] = 0.0;
                array[7] = 0.0;
                array[8] = 1.0;
                // fall-through
            case MT_2D_2x3:
                fill2DArray(array);
                break;
            case MT_3D_4x4:
                array[12] = 0.0;
                array[13] = 0.0;
                array[14] = 0.0;
                array[15] = 1.0;
                // fall-through
            case MT_3D_3x4:
                fill3DArray(array);
                break;
            default:
                throw new InternalError(&quot;Unsupported matrix type &quot; + type);
        }

        return array;
    }

    /**
     * Returns an array containing the flattened transformation matrix.
     * @param type matrix type to be filled in the array
     * @return an array containing the elements of the requested matrix type
     *         representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] toArray(MatrixType type) {
        return toArray(type, null);
    }

    /**
     * Returns an array containing a row of the transformation matrix.
     * If the row of the requested matrix type fits in the specified array,
     * it is returned therein. Otherwise, a new array is created.
     * @param type matrix type whose row is to be filled in the array
     * @param row zero-based index of the row
     * @param array array into which the elements of the row are to be
     *              stored, if it is non-null and big enough; otherwise,
     *              a new array is created for this purpose.
     * @return an array containing the requested row of the requested matrix
     *         type representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws IndexOutOfBoundsException if the {@code row} index is not within
     *         the number of rows of the specified matrix type
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] row(MatrixType type, int row, double[] array) {

        checkRequestedMAT(type);

        if (row &lt; 0 || row &gt;= type.rows()) {
            throw new IndexOutOfBoundsException(
                    &quot;Cannot get row &quot; + row + &quot; from &quot; + type);
        }

        if (array == null || array.length &lt; type.columns()) {
            array = new double[type.columns()];
        }

        switch(type) {
            case MT_2D_2x3:
            case MT_2D_3x3:
                switch (row) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMxy();
                        array[2] = getTx();
                        break;
                    case 1:
                        array[0] = getMyx();
                        array[1] = getMyy();
                        array[2] = getTy();
                        break;
                    case 2:
                        array[0] = 0.0;
                        array[1] = 0.0;
                        array[2] = 1.0;
                        break;
                }
                break;
            case MT_3D_3x4:
            case MT_3D_4x4:
                switch (row) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMxy();
                        array[2] = getMxz();
                        array[3] = getTx();
                        break;
                    case 1:
                        array[0] = getMyx();
                        array[1] = getMyy();
                        array[2] = getMyz();
                        array[3] = getTy();
                        break;
                    case 2:
                        array[0] = getMzx();
                        array[1] = getMzy();
                        array[2] = getMzz();
                        array[3] = getTz();
                        break;
                    case 3:
                        array[0] = 0.0;
                        array[1] = 0.0;
                        array[2] = 0.0;
                        array[3] = 1.0;
                        break;
                }
                break;
            default:
                throw new InternalError(&quot;Unsupported row &quot; + row + &quot; of &quot; + type);
        }
        return array;
    }

    /**
     * Returns an array containing a row of the transformation matrix.
     * @param type matrix type whose row is to be filled in the array
     * @param row zero-based index of the row
     * @return an array containing the requested row of the requested matrix
     *         type representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws IndexOutOfBoundsException if the {@code row} index is not within
     *         the number of rows of the specified matrix type
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] row(MatrixType type, int row) {
        return row(type, row, null);
    }

    /**
     * Returns an array containing a column of the transformation matrix.
     * If the column of the requested matrix type fits in the specified array,
     * it is returned therein. Otherwise, a new array is created.
     * @param type matrix type whose column is to be filled in the array
     * @param column zero-based index of the column
     * @param array array into which the elements of the column are to be
     *              stored, if it is non-null and big enough; otherwise,
     *              a new array is created for this purpose.
     * @return an array containing the requested column of the requested matrix
     *         type representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws IndexOutOfBoundsException if the {@code column} index
     *         is not within the number of columns of the specified matrix type
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] column(MatrixType type, int column, double[] array) {

        checkRequestedMAT(type);

        if (column &lt; 0 || column &gt;= type.columns()) {
            throw new IndexOutOfBoundsException(
                    &quot;Cannot get row &quot; + column + &quot; from &quot; + type);
        }

        if (array == null || array.length &lt; type.rows()) {
            array = new double[type.rows()];
        }

        switch(type) {
            case MT_2D_2x3:
                switch (column) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMyx();
                        break;
                    case 1:
                        array[0] = getMxy();
                        array[1] = getMyy();
                        break;
                    case 2:
                        array[0] = getTx();
                        array[1] = getTy();
                        break;
                }
                break;
            case MT_2D_3x3:
                switch (column) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMyx();
                        array[2] = 0.0;
                        break;
                    case 1:
                        array[0] = getMxy();
                        array[1] = getMyy();
                        array[2] = 0.0;
                        break;
                    case 2:
                        array[0] = getTx();
                        array[1] = getTy();
                        array[2] = 1.0;
                        break;
                }
                break;
            case MT_3D_3x4:
                switch (column) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMyx();
                        array[2] = getMzx();
                        break;
                    case 1:
                        array[0] = getMxy();
                        array[1] = getMyy();
                        array[2] = getMzy();
                        break;
                    case 2:
                        array[0] = getMxz();
                        array[1] = getMyz();
                        array[2] = getMzz();
                        break;
                    case 3:
                        array[0] = getTx();
                        array[1] = getTy();
                        array[2] = getTz();
                        break;
                }
                break;
            case MT_3D_4x4:
                switch (column) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMyx();
                        array[2] = getMzx();
                        array[3] = 0.0;
                        break;
                    case 1:
                        array[0] = getMxy();
                        array[1] = getMyy();
                        array[2] = getMzy();
                        array[3] = 0.0;
                        break;
                    case 2:
                        array[0] = getMxz();
                        array[1] = getMyz();
                        array[2] = getMzz();
                        array[3] = 0.0;
                        break;
                    case 3:
                        array[0] = getTx();
                        array[1] = getTy();
                        array[2] = getTz();
                        array[3] = 1.0;
                        break;
                }
                break;
            default:
                throw new InternalError(&quot;Unsupported column &quot; + column + &quot; of &quot;
                        + type);
        }
        return array;
    }

    /**
     * Returns an array containing a column of the transformation matrix.
     * @param type matrix type whose column is to be filled in the array
     * @param column zero-based index of the column
     * @return an array containing the requested column of the requested matrix
     *         type representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws IndexOutOfBoundsException if the {@code column} index
     *         is not within the number of columns of the specified matrix type
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] column(MatrixType type, int column) {
        return column(type, column, null);
    }

    /* *************************************************************************
     *                                                                         *
     *                         Transform creators                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns the concatenation of this transform and the specified transform.
     * Applying the resulting transform to a node has the same effect as
     * adding the two transforms to its {@code getTransforms()} list,
     * {@code this} transform first and the specified {@code transform} second.
     * @param transform transform to be concatenated with this transform
     * @return The concatenated transform
     * @throws NullPointerException if the specified {@code transform} is null
     * @since JavaFX 8.0
     */
    public Transform createConcatenation(Transform transform) {
        final double txx = transform.getMxx();
        final double txy = transform.getMxy();
        final double txz = transform.getMxz();
        final double ttx = transform.getTx();
        final double tyx = transform.getMyx();
        final double tyy = transform.getMyy();
        final double tyz = transform.getMyz();
        final double tty = transform.getTy();
        final double tzx = transform.getMzx();
        final double tzy = transform.getMzy();
        final double tzz = transform.getMzz();
        final double ttz = transform.getTz();
        return new Affine(
            (getMxx() * txx + getMxy() * tyx + getMxz() * tzx),
            (getMxx() * txy + getMxy() * tyy + getMxz() * tzy),
            (getMxx() * txz + getMxy() * tyz + getMxz() * tzz),
            (getMxx() * ttx + getMxy() * tty + getMxz() * ttz + getTx()),
            (getMyx() * txx + getMyy() * tyx + getMyz() * tzx),
            (getMyx() * txy + getMyy() * tyy + getMyz() * tzy),
            (getMyx() * txz + getMyy() * tyz + getMyz() * tzz),
            (getMyx() * ttx + getMyy() * tty + getMyz() * ttz + getTy()),
            (getMzx() * txx + getMzy() * tyx + getMzz() * tzx),
            (getMzx() * txy + getMzy() * tyy + getMzz() * tzy),
            (getMzx() * txz + getMzy() * tyz + getMzz() * tzz),
            (getMzx() * ttx + getMzy() * tty + getMzz() * ttz + getTz()));
    }

    /**
     * Returns the inverse transform of this transform.
     * @return the inverse transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @since JavaFX 8.0
     */
    public Transform createInverse() throws NonInvertibleTransformException {
        return getInverseCache().clone();
    }

    /**
     * Returns a deep copy of this transform.
     * @return a copy of this transform
     * @since JavaFX 8.0
     */
    @Override
    public Transform clone() {
        return TransformUtils.immutableTransform(this);
    }

    /* *************************************************************************
     *                                                                         *
     *                     Transform, Inverse Transform                        *
     *                                                                         *
     **************************************************************************/

    /**
     * Transforms the specified point by this transform.
     * This method can be used only for 2D transforms.
     * @param x the X coordinate of the point
     * @param y the Y coordinate of the point
     * @return the transformed point
     * @throws IllegalStateException if this is a 3D transform
     * @since JavaFX 8.0
     */
    public Point2D transform(double x, double y) {
        ensureCanTransform2DPoint();

        return new Point2D(
            getMxx() * x + getMxy() * y + getTx(),
            getMyx() * x + getMyy() * y + getTy());
    }

    /**
     * Transforms the specified point by this transform.
     * This method can be used only for 2D transforms.
     * @param point the point to be transformed
     * @return the transformed point
     * @throws IllegalStateException if this is a 3D transform
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point2D transform(Point2D point) {
        return transform(point.getX(), point.getY());
    }

    /**
     * Transforms the specified point by this transform.
     * @param x the X coordinate of the point
     * @param y the Y coordinate of the point
     * @param z the Z coordinate of the point
     * @return the transformed point
     * @since JavaFX 8.0
     */
    public Point3D transform(double x, double y, double z) {
        return new Point3D(
            getMxx() * x + getMxy() * y + getMxz() * z + getTx(),
            getMyx() * x + getMyy() * y + getMyz() * z + getTy(),
            getMzx() * x + getMzy() * y + getMzz() * z + getTz());
    }

    /**
     * Transforms the specified point by this transform.
     * @param point the point to be transformed
     * @return the transformed point
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point3D transform(Point3D point) {
        return transform(point.getX(), point.getY(), point.getZ());
    }

    /**
     * Transforms the specified bounds by this transform.
     * @param bounds the bounds to be transformed
     * @return the transformed bounds
     * @since JavaFX 8.0
     */
    public Bounds transform(Bounds bounds) {
        if (isType2D() &amp;&amp; (bounds.getMinZ() == 0) &amp;&amp; (bounds.getMaxZ() == 0)) {
            Point2D p1 = transform(bounds.getMinX(), bounds.getMinY());
            Point2D p2 = transform(bounds.getMaxX(), bounds.getMinY());
            Point2D p3 = transform(bounds.getMaxX(), bounds.getMaxY());
            Point2D p4 = transform(bounds.getMinX(), bounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        Point3D p1 = transform(bounds.getMinX(), bounds.getMinY(), bounds.getMinZ());
        Point3D p2 = transform(bounds.getMinX(), bounds.getMinY(), bounds.getMaxZ());
        Point3D p3 = transform(bounds.getMinX(), bounds.getMaxY(), bounds.getMinZ());
        Point3D p4 = transform(bounds.getMinX(), bounds.getMaxY(), bounds.getMaxZ());
        Point3D p5 = transform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMinZ());
        Point3D p6 = transform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMaxZ());
        Point3D p7 = transform(bounds.getMaxX(), bounds.getMinY(), bounds.getMinZ());
        Point3D p8 = transform(bounds.getMaxX(), bounds.getMinY(), bounds.getMaxZ());

        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
    }

    /**
     * Core of the transform2DPoints method.
     * All the checks has been performed and the care of the overlaps has been
     * taken by the enclosing method, this method only transforms the points
     * and fills them to the array. Used by the subclasses to perform
     * the transform efficiently.
     */
    void transform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {
        final double xx = getMxx();
        final double xy = getMxy();
        final double tx = getTx();
        final double yx = getMyx();
        final double yy = getMyy();
        final double ty = getTy();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];

            dstPts[dstOff++] = xx * x + xy * y + tx;
            dstPts[dstOff++] = yx * x + yy * y + ty;
        }
    }

    /**
     * Core of the transform3DPoints method.
     * All the checks has been performed and the care of the overlaps has been
     * taken by the enclosing method, this method only transforms the points
     * and fills them to the array. Used by the subclasses to perform
     * the transform efficiently.
     */
    void transform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {

        final double xx = getMxx();
        final double xy = getMxy();
        final double xz = getMxz();
        final double tx = getTx();
        final double yx = getMyx();
        final double yy = getMyy();
        final double yz = getMyz();
        final double ty = getTy();
        final double zx = getMzx();
        final double zy = getMzy();
        final double zz = getMzz();
        final double tz = getTz();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];
            final double z = srcPts[srcOff++];

            dstPts[dstOff++] = xx * x + xy * y + xz * z + tx;
            dstPts[dstOff++] = yx * x + yy * y + yz * z + ty;
            dstPts[dstOff++] = zx * x + zy * y + zz * z + tz;
        }
    }

    /**
     * Transforms an array of coordinates by this transform.
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are overwritten by a
     * previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.
     * This method can be used only for 2D transforms.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&amp;nbsp;y coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a pair of x,&amp;nbsp;y
     * coordinates.
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of points to be transformed
     * @throws IllegalStateException if this is a 3D transform
     * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
     * @since JavaFX 8.0
     */
    public void transform2DPoints(double[] srcPts, int srcOff,
                          double[] dstPts, int dstOff,
                          int numPts) {

        if (srcPts == null || dstPts == null) {
            throw new NullPointerException();
        }

        if (!isType2D()) {
            throw new IllegalStateException(&quot;Cannot transform 2D points &quot;
                    + &quot;with a 3D transform&quot;);
        }

        // deal with overlapping arrays
        srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 2);

        // do the transformations
        transform2DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
    }

    /**
     * Transforms an array of floating point coordinates by this transform.
     * The three coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are overwritten by a
     * previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order &lt;code&gt;[x0, y0, z0, x1, y1, z1, ..., xn, yn, zn]&lt;/code&gt;.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a tiplet of x,&amp;nbsp;y,&amp;nbsp;z coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a triplet of x,&amp;nbsp;y,&amp;nbsp;z
     * coordinates.
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of points to be transformed
     * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
     * @since JavaFX 8.0
     */
    public void transform3DPoints(double[] srcPts, int srcOff,
                          double[] dstPts, int dstOff,
                          int numPts) {

        if (srcPts == null || dstPts == null) {
            throw new NullPointerException();
        }

        // deal with overlapping arrays
        srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 3);

        // do the transformations
        transform3DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
    }

    /**
     * Transforms the relative magnitude vector by this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * This method can be used only for a 2D transform.
     * @param x vector magnitude in the direction of the X axis
     * @param y vector magnitude in the direction of the Y axis
     * @return the transformed relative magnitude vector represented
     *         by a {@code Point2D} instance
     * @throws IllegalStateException if this is a 3D transform
     * @since JavaFX 8.0
     */
    public Point2D deltaTransform(double x, double y) {
        ensureCanTransform2DPoint();

        return new Point2D(
            getMxx() * x + getMxy() * y,
            getMyx() * x + getMyy() * y);
    }

    /**
     * Transforms the relative magnitude vector represented by the specified
     * {@code Point2D} instance by this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * This method can be used only for a 2D transform.
     * @param point the relative magnitude vector
     * @return the transformed relative magnitude vector represented
     *         by a {@code Point2D} instance
     * @throws IllegalStateException if this is a 3D transform
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point2D deltaTransform(Point2D point) {
        return deltaTransform(point.getX(), point.getY());
    }

    /**
     * Transforms the relative magnitude vector by this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * @param x vector magnitude in the direction of the X axis
     * @param y vector magnitude in the direction of the Y axis
     * @param z vector magnitude in the direction of the Z axis
     * @return the transformed relative magnitude vector represented
     *         by a {@code Point3D} instance
     * @since JavaFX 8.0
     */
    public Point3D deltaTransform(double x, double y, double z) {
        return new Point3D(
            getMxx() * x + getMxy() * y + getMxz() * z,
            getMyx() * x + getMyy() * y + getMyz() * z,
            getMzx() * x + getMzy() * y + getMzz() * z);
    }

    /**
     * Transforms the relative magnitude vector represented by the specified
     * {@code Point3D} instance by this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * @param point the relative magnitude vector
     * @return the transformed relative magnitude vector represented
     *         by a {@code Point3D} instance
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point3D deltaTransform(Point3D point) {
        return deltaTransform(point.getX(), point.getY(), point.getZ());
    }

    /**
     * Transforms the specified point by the inverse of this transform.
     * This method can be used only for 2D transforms.
     * @param x the X coordinate of the point
     * @param y the Y coordinate of the point
     * @return the inversely transformed point
     * @throws IllegalStateException if this is a 3D transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @since JavaFX 8.0
     */
    public Point2D inverseTransform(double x, double y)
            throws NonInvertibleTransformException {

        ensureCanTransform2DPoint();

        return getInverseCache().transform(x, y);
    }

    /**
     * Transforms the specified point by the inverse of this transform.
     * This method can be used only for 2D transforms.
     * @param point the point to be transformed
     * @return the inversely transformed point
     * @throws IllegalStateException if this is a 3D transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point2D inverseTransform(Point2D point)
            throws NonInvertibleTransformException {
        return inverseTransform(point.getX(), point.getY());
    }

    /**
     * Transforms the specified point by the inverse of this transform.
     * @param x the X coordinate of the point
     * @param y the Y coordinate of the point
     * @param z the Z coordinate of the point
     * @return the inversely transformed point
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @since JavaFX 8.0
     */
    public Point3D inverseTransform(double x, double y, double z)
            throws NonInvertibleTransformException {

        return getInverseCache().transform(x, y, z);
    }

    /**
     * Transforms the specified point by the inverse of this transform.
     * @param point the point to be transformed
     * @return the inversely transformed point
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point3D inverseTransform(Point3D point)
            throws NonInvertibleTransformException {
        return inverseTransform(point.getX(), point.getY(), point.getZ());
    }

    /**
     * Transforms the specified bounds by the inverse of this transform.
     * @param bounds the bounds to be transformed
     * @return the inversely transformed bounds
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if the specified {@code bounds} is null
     * @since JavaFX 8.0
     */
    public Bounds inverseTransform(Bounds bounds)
            throws NonInvertibleTransformException {
        if (isType2D() &amp;&amp; (bounds.getMinZ() == 0) &amp;&amp; (bounds.getMaxZ() == 0)) {
            Point2D p1 = inverseTransform(bounds.getMinX(), bounds.getMinY());
            Point2D p2 = inverseTransform(bounds.getMaxX(), bounds.getMinY());
            Point2D p3 = inverseTransform(bounds.getMaxX(), bounds.getMaxY());
            Point2D p4 = inverseTransform(bounds.getMinX(), bounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        Point3D p1 = inverseTransform(bounds.getMinX(), bounds.getMinY(), bounds.getMinZ());
        Point3D p2 = inverseTransform(bounds.getMinX(), bounds.getMinY(), bounds.getMaxZ());
        Point3D p3 = inverseTransform(bounds.getMinX(), bounds.getMaxY(), bounds.getMinZ());
        Point3D p4 = inverseTransform(bounds.getMinX(), bounds.getMaxY(), bounds.getMaxZ());
        Point3D p5 = inverseTransform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMinZ());
        Point3D p6 = inverseTransform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMaxZ());
        Point3D p7 = inverseTransform(bounds.getMaxX(), bounds.getMinY(), bounds.getMinZ());
        Point3D p8 = inverseTransform(bounds.getMaxX(), bounds.getMinY(), bounds.getMaxZ());

        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);

    }

    /**
     * Core of the inverseTransform2DPoints method.
     * All the checks has been performed and the care of the overlaps has been
     * taken by the enclosing method, this method only transforms the points
     * and fills them to the array. Used by the subclasses to perform
     * the transform efficiently.
     */
    void inverseTransform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts)
            throws NonInvertibleTransformException {

        getInverseCache().transform2DPointsImpl(srcPts, srcOff,
                dstPts, dstOff, numPts);
    }

    /**
     * Core of the inverseTransform3DPoints method.
     * All the checks has been performed and the care of the overlaps has been
     * taken by the enclosing method, this method only transforms the points
     * and fills them to the array. Used by the subclasses to perform
     * the transform efficiently.
     */
    void inverseTransform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts)
            throws NonInvertibleTransformException {

        getInverseCache().transform3DPointsImpl(srcPts, srcOff,
                dstPts, dstOff, numPts);
    }

    /**
     * Transforms an array of coordinates by the inverse of this transform.
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are overwritten by a
     * previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.
     * This method can be used only for 2D transforms.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&amp;nbsp;y coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a pair of x,&amp;nbsp;y
     * coordinates.
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of points to be transformed
     * @throws IllegalStateException if this is a 3D transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
     * @since JavaFX 8.0
     */
    public void inverseTransform2DPoints(double[] srcPts, int srcOff,
                          double[] dstPts, int dstOff,
                          int numPts) throws NonInvertibleTransformException{

        if (srcPts == null || dstPts == null) {
            throw new NullPointerException();
        }

        if (!isType2D()) {
            throw new IllegalStateException(&quot;Cannot transform 2D points &quot;
                    + &quot;with a 3D transform&quot;);
        }

        // deal with overlapping arrays
        srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 2);

        // do the transformations
        inverseTransform2DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
    }

    /**
     * Transforms an array of floating point coordinates by the inverse
     * of this transform.
     * The three coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are overwritten by a
     * previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order &lt;code&gt;[x0, y0, z0, x1, y1, z1, ..., xn, yn, zn]&lt;/code&gt;.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a triplet of x,&amp;nbsp;y,&amp;nbsp;z coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a triplet of x,&amp;nbsp;y,&amp;nbsp;z
     * coordinates.
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of points to be transformed
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
     * @since JavaFX 8.0
     */
    public void inverseTransform3DPoints(double[] srcPts, int srcOff,
                          double[] dstPts, int dstOff,
                          int numPts) throws NonInvertibleTransformException {

        if (srcPts == null || dstPts == null) {
            throw new NullPointerException();
        }

        // deal with overlapping arrays
        srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 3);

        // do the transformations
        inverseTransform3DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
    }

    /**
     * Transforms the relative magnitude vector by the inverse of this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * This method can be used only for a 2D transform.
     * @param x vector magnitude in the direction of the X axis
     * @param y vector magnitude in the direction of the Y axis
     * @return the inversely transformed relative magnitude vector represented
     *         by a {@code Point2D} instance
     * @throws IllegalStateException if this is a 3D transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @since JavaFX 8.0
     */
    public Point2D inverseDeltaTransform(double x, double y)
            throws NonInvertibleTransformException {

        ensureCanTransform2DPoint();

        return getInverseCache().deltaTransform(x, y);
    }

    /**
     * Transforms the relative magnitude vector represented by the specified
     * {@code Point2D} instance by the inverse of this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * This method can be used only for a 2D transform.
     * @param point the relative magnitude vector
     * @return the inversely transformed relative magnitude vector represented
     *         by a {@code Point2D} instance
     * @throws IllegalStateException if this is a 3D transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point2D inverseDeltaTransform(Point2D point)
            throws NonInvertibleTransformException {
        return inverseDeltaTransform(point.getX(), point.getY());
    }

    /**
     * Transforms the relative magnitude vector by the inverse of this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * @param x vector magnitude in the direction of the X axis
     * @param y vector magnitude in the direction of the Y axis
     * @param z vector magnitude in the direction of the Z axis
     * @return the inversely transformed relative magnitude vector represented
     *         by a {@code Point3D} instance
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @since JavaFX 8.0
     */
    public Point3D inverseDeltaTransform(double x, double y, double z)
            throws NonInvertibleTransformException {

        return getInverseCache().deltaTransform(x, y, z);
    }

    /**
     * Transforms the relative magnitude vector represented by the specified
     * {@code Point3D} instance by the inverse of this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * @param point the relative magnitude vector
     * @return the inversely transformed relative magnitude vector represented
     *         by a {@code Point3D} instance
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point3D inverseDeltaTransform(Point3D point)
            throws NonInvertibleTransformException {
        return inverseDeltaTransform(point.getX(), point.getY(), point.getZ());
    }

    /**
     * Helper method for transforming arrays of points that deals with
     * overlapping arrays.
     * @return the (if necessary fixed) srcOff
     */
    private int getFixedSrcOffset(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff,
            int numPts, int dimensions) {

        if (dstPts == srcPts &amp;&amp;
            dstOff &gt; srcOff &amp;&amp; dstOff &lt; srcOff + numPts * dimensions)
        {
            // If the arrays overlap partially with the destination higher
            // than the source and we transform the coordinates normally
            // we would overwrite some of the later source coordinates
            // with results of previous transformations.
            // To get around this we use arraycopy to copy the points
            // to their final destination with correct overwrite
            // handling and then transform them in place in the new
            // safer location.
            System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * dimensions);
            return dstOff;
        }

        return srcOff;
    }

    /* *************************************************************************
     *                                                                         *
     *                         Event Dispatch                                  *
     *                                                                         *
     **************************************************************************/

    private EventHandlerManager internalEventDispatcher;
    private EventHandlerManager getInternalEventDispatcher() {
        if (internalEventDispatcher == null) {
            internalEventDispatcher = new EventHandlerManager(this);
        }
        return internalEventDispatcher;
    }
    private ObjectProperty&lt;EventHandler&lt;? super TransformChangedEvent&gt;&gt;
            onTransformChanged;

    @Override
    public EventDispatchChain buildEventDispatchChain(EventDispatchChain tail) {
        return internalEventDispatcher == null
                ? tail : tail.append(getInternalEventDispatcher());
    }

    /**
     * &lt;p&gt;
     * Registers an event handler to this transform. Any event filters are first
     * processed, then the specified onFoo event handlers, and finally any
     * event handlers registered by this method.
     * &lt;/p&gt;&lt;p&gt;
     * Currently the only event delivered to a {@code Transform} is the
     * {@code TransformChangedEvent} with it's single type
     * {@code TRANSFORM_CHANGED}.
     * &lt;/p&gt;
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the type of the events to receive by the handler
     * @param eventHandler the handler to register
     * @throws NullPointerException if the event type or handler is null
     * @since JavaFX 8.0
     */
    public final &lt;T extends Event&gt; void addEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher()
                .addEventHandler(eventType, eventHandler);
        // need to validate all properties to get the change events
        validate();
    }

    /**
     * Unregisters a previously registered event handler from this transform.
     * One handler might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the handler.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type from which to unregister
     * @param eventHandler the handler to unregister
     * @throws NullPointerException if the event type or handler is null
     * @since JavaFX 8.0
     */
    public final &lt;T extends Event&gt; void removeEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher()
                .removeEventHandler(eventType, eventHandler);
    }

    /**
     * &lt;p&gt;
     * Registers an event filter to this transform. Registered event filters get
     * an event before any associated event handlers.
     * &lt;/p&gt;&lt;p&gt;
     * Currently the only event delivered to a {@code Transform} is the
     * {@code TransformChangedEvent} with it's single type
     * {@code TRANSFORM_CHANGED}.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the type of the events to receive by the filter
     * @param eventFilter the filter to register
     * @throws NullPointerException if the event type or filter is null
     * @since JavaFX 8.0
     */
    public final &lt;T extends Event&gt; void addEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher()
                .addEventFilter(eventType, eventFilter);
        // need to validate all properties to get the change events
        validate();
    }

    /**
     * Unregisters a previously registered event filter from this transform. One
     * filter might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the filter.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the event type from which to unregister
     * @param eventFilter the filter to unregister
     * @throws NullPointerException if the event type or filter is null
     * @since JavaFX 8.0
     */
    public final &lt;T extends Event&gt; void removeEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher()
                .removeEventFilter(eventType, eventFilter);
    }

    /**
     * Sets the onTransformChanged event handler which is called whenever
     * the transform changes any of its parameters.
     *
     * @param value the event handler, can be null to clear it
     * @since JavaFX 8.0
     */
    public final void setOnTransformChanged(
            EventHandler&lt;? super TransformChangedEvent&gt; value) {
        onTransformChangedProperty().set(value);
        // need to validate all properties to get the change events
        validate();
    }

    /**
     * Gets the onTransformChanged event handler.
     * @return the event handler previously set by {@code setOnTransformChanged}
     * method, null if the handler is not set.
     * @since JavaFX 8.0
     */
    public final EventHandler&lt;? super TransformChangedEvent&gt; getOnTransformChanged() {
        return (onTransformChanged == null) ? null : onTransformChanged.get();
    }

    /**
     * The onTransformChanged event handler is called whenever the transform
     * changes any of its parameters.
     * @return the onTransformChanged event handler
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;EventHandler&lt;? super TransformChangedEvent&gt;&gt;
            onTransformChangedProperty() {
        if (onTransformChanged == null) {

            onTransformChanged = new SimpleObjectProperty&lt;EventHandler
                    &lt;? super TransformChangedEvent&gt;&gt;(this, &quot;onTransformChanged&quot;) {

                @Override protected void invalidated() {
                    getInternalEventDispatcher().setEventHandler(
                            TransformChangedEvent.TRANSFORM_CHANGED, get());
                }
            };
        }

        return onTransformChanged;
    }

    /* *************************************************************************
     *                                                                         *
     *                    Internal implementation stuff                        *
     *                                                                         *
     **************************************************************************/

    /**
     * Makes sure the specified matrix type can be requested from this transform.
     * Is used for convenience in various methods that accept
     * the MatrixType argument.
     * @param type matrix type to check
     * @throws IllegalArgumentException if this is a 3D transform and
     *                                  a 2D type is requested
     */
    void checkRequestedMAT(MatrixType type) throws IllegalArgumentException{
        if (type.is2D() &amp;&amp; !isType2D()) {
            throw new IllegalArgumentException(&quot;Cannot access 2D matrix &quot;
                    + &quot;for a 3D transform&quot;);
        }
    }

    /**
     * Makes sure this is a 2D transform.
     * Is used for convenience in various 2D point transformation methods.
     * @throws IllegalStateException if this is a 2D transform
     */
    void ensureCanTransform2DPoint() throws IllegalStateException {
        if (!isType2D()) {
            throw new IllegalStateException(&quot;Cannot transform 2D point &quot;
                    + &quot;with a 3D transform&quot;);
        }
    }

    /**
     * Needed for the proper delivery of the TransformChangedEvent.
     * If the members are invalid, the transformChanged() notification
     * is not called and the event is not delivered. To avoid that
     * we need to manually validate all properties. Subclasses validate
     * their specific properties.
     */
    void validate() {
        getMxx(); getMxy(); getMxz(); getTx();
        getMyx(); getMyy(); getMyz(); getTy();
        getMzx(); getMzy(); getMzz(); getTz();
    }

    abstract void apply(Affine3D t);

    abstract BaseTransform derive(BaseTransform t);

    void add(final Node node) {
        nodes.add(node);
    }

    void remove(final Node node) {
        nodes.remove(node);
    }

    /**
     * This method must be called by all transforms whenever any of their
     * parameters changes. It is typically called when any of the transform's
     * properties is invalidated (it is OK to skip the call if an invalid
     * property is set).
     * @since JavaFX 8.0
     */
    protected void transformChanged() {
        inverseCache = null;
        final Iterator iterator = nodes.iterator();
        while (iterator.hasNext()) {
            NodeHelper.transformsChanged(((Node) iterator.next()));
        }

        if (type2D != null) {
            type2D.invalidate();
        }

        if (identity != null) {
            identity.invalidate();
        }

        if (internalEventDispatcher != null) {
            // need to validate all properties for the event to be fired next time
            validate();
            Event.fireEvent(this, new TransformChangedEvent(this, this));
        }
    }

    /**
     * Visitor from {@code Affine} class which provides an efficient
     * {@code append} operation for the subclasses.
     * @param a {@code Affine} instance to append to
     */
    void appendTo(Affine a) {
        a.append(getMxx(), getMxy(), getMxz(), getTx(),
                 getMyx(), getMyy(), getMyz(), getTy(),
                 getMzx(), getMzy(), getMzz(), getTz());
    }

    /**
     * Visitor from {@code Affine} class which provides an efficient
     * {@code prepend} operation for the subclasses.
     * @param a {@code Affine} instance to prepend to
     */
    void prependTo(Affine a) {
        a.prepend(getMxx(), getMxy(), getMxz(), getTx(),
                  getMyx(), getMyy(), getMyz(), getTy(),
                  getMzx(), getMzy(), getMzz(), getTz());
    }

    /**
     * &lt;p&gt;
     * Gets the inverse transform cache.
     * &lt;/p&gt;&lt;p&gt;
     * Computing the inverse transform is generally an expensive operation,
     * so once it is needed we cache the result (throwing it away when the
     * transform changes). The subclasses may avoid using the cache if their
     * inverse can be computed quickly on the fly.
     * &lt;/p&gt;&lt;p&gt;
     * This method computes the inverse if the cache is not valid.
     * &lt;/p&gt;
     * @return the cached inverse transformation
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     */
    private Transform getInverseCache() throws NonInvertibleTransformException {
        if (inverseCache == null || inverseCache.get() == null) {
            Affine inv = new Affine(
                    getMxx(), getMxy(), getMxz(), getTx(),
                    getMyx(), getMyy(), getMyz(), getTy(),
                    getMzx(), getMzy(), getMzz(), getTz());
            inv.invert();
            inverseCache = new SoftReference&lt;Transform&gt;(inv);
            return inv;
        }

        return inverseCache.get();
    }

    /**
     * Used only by tests to emulate garbage collecting the soft references
     */
    void clearInverseCache() {
        if (inverseCache != null) {
            inverseCache.clear();
        }
    }

    /**************************************************************************
     *  ImmutableTransform Class and supporting methods
     **************************************************************************/

    static Transform createImmutableTransform() {
        return new ImmutableTransform();
    }

    static Transform createImmutableTransform(
            double mxx, double mxy, double mxz, double tx,
            double myx, double myy, double myz, double ty,
            double mzx, double mzy, double mzz, double tz) {
        return new ImmutableTransform(
                mxx, mxy, mxz, tx,
                myx, myy, myz, ty,
                mzx, mzy, mzz, tz);
    }

    static Transform createImmutableTransform(Transform transform,
            double mxx, double mxy, double mxz, double tx,
            double myx, double myy, double myz, double ty,
            double mzx, double mzy, double mzz, double tz) {
        if (transform == null) {
            return new ImmutableTransform(
                    mxx, mxy, mxz, tx,
                    myx, myy, myz, ty,
                    mzx, mzy, mzz, tz);
        }
        ((Transform.ImmutableTransform) transform).setToTransform(
                mxx, mxy, mxz, tx,
                myx, myy, myz, ty,
                mzx, mzy, mzz, tz);
        return transform;
    }

    static Transform createImmutableTransform(Transform transform,
            Transform left, Transform right) {
        if (transform == null) {
            transform = new ImmutableTransform();
        }
        ((Transform.ImmutableTransform) transform).setToConcatenation(
                (ImmutableTransform) left, (ImmutableTransform) right);
        return transform;
    }

    /**
     * Immutable transformation with performance optimizations based on Affine.
     *
     * From user's perspective, this transform is immutable. However, we can
     * modify it internally. This allows for reusing instances that were
     * not handed to users. The caller is responsible for not modifying
     * user-visible instances.
     *
     * Note: can't override Transform's package private methods so they cannot
     * be optimized. Currently not a big deal.
     */
    static class ImmutableTransform extends Transform {

        private static final int APPLY_IDENTITY = 0;
        private static final int APPLY_TRANSLATE = 1;
        private static final int APPLY_SCALE = 2;
        private static final int APPLY_SHEAR = 4;
        private static final int APPLY_NON_3D = 0;
        private static final int APPLY_3D_COMPLEX = 4;
        private transient int state2d;
        private transient int state3d;

        private double xx;
        private double xy;
        private double xz;
        private double yx;
        private double yy;
        private double yz;
        private double zx;
        private double zy;
        private double zz;
        private double xt;
        private double yt;
        private double zt;

        ImmutableTransform() {
            xx = yy = zz = 1.0;
        }

        ImmutableTransform(Transform transform) {
            this(transform.getMxx(), transform.getMxy(), transform.getMxz(),
                                                                 transform.getTx(),
                 transform.getMyx(), transform.getMyy(), transform.getMyz(),
                                                                 transform.getTy(),
                 transform.getMzx(), transform.getMzy(), transform.getMzz(),
                                                                 transform.getTz());
        }

        ImmutableTransform(double mxx, double mxy, double mxz, double tx,
                      double myx, double myy, double myz, double ty,
                      double mzx, double mzy, double mzz, double tz) {
            xx = mxx;
            xy = mxy;
            xz = mxz;
            xt = tx;

            yx = myx;
            yy = myy;
            yz = myz;
            yt = ty;

            zx = mzx;
            zy = mzy;
            zz = mzz;
            zt = tz;

            updateState();
        }

        // Beware: this is modifying immutable transform!
        // It is private and it is there just for the purpose of reusing
        // instances not given to users
        private void setToTransform(double mxx, double mxy, double mxz, double tx,
                                    double myx, double myy, double myz, double ty,
                                    double mzx, double mzy, double mzz, double tz)
        {
            xx = mxx;
            xy = mxy;
            xz = mxz;
            xt = tx;
            yx = myx;
            yy = myy;
            yz = myz;
            yt = ty;
            zx = mzx;
            zy = mzy;
            zz = mzz;
            zt = tz;
            updateState();
        }

        // Beware: this is modifying immutable transform!
        // It is private and it is there just for the purpose of reusing
        // instances not given to users
        private void setToConcatenation(ImmutableTransform left, ImmutableTransform right) {
            if (left.state3d == APPLY_NON_3D &amp;&amp; right.state3d == APPLY_NON_3D) {
                xx = left.xx * right.xx + left.xy * right.yx;
                xy = left.xx * right.xy + left.xy * right.yy;
                xt = left.xx * right.xt + left.xy * right.yt + left.xt;
                yx = left.yx * right.xx + left.yy * right.yx;
                yy = left.yx * right.xy + left.yy * right.yy;
                yt = left.yx * right.xt + left.yy * right.yt + left.yt;
                if (state3d != APPLY_NON_3D) {
                    xz = yz = zx = zy = zt = 0.0;
                    zz = 1.0;
                    state3d = APPLY_NON_3D;
                }
                updateState2D();
            } else {
                xx = left.xx * right.xx + left.xy * right.yx + left.xz * right.zx;
                xy = left.xx * right.xy + left.xy * right.yy + left.xz * right.zy;
                xz = left.xx * right.xz + left.xy * right.yz + left.xz * right.zz;
                xt = left.xx * right.xt + left.xy * right.yt + left.xz * right.zt + left.xt;
                yx = left.yx * right.xx + left.yy * right.yx + left.yz * right.zx;
                yy = left.yx * right.xy + left.yy * right.yy + left.yz * right.zy;
                yz = left.yx * right.xz + left.yy * right.yz + left.yz * right.zz;
                yt = left.yx * right.xt + left.yy * right.yt + left.yz * right.zt + left.yt;
                zx = left.zx * right.xx + left.zy * right.yx + left.zz * right.zx;
                zy = left.zx * right.xy + left.zy * right.yy + left.zz * right.zy;
                zz = left.zx * right.xz + left.zy * right.yz + left.zz * right.zz;
                zt = left.zx * right.xt + left.zy * right.yt + left.zz * right.zt + left.zt;
                updateState();
            }
            // could be further optimized using the states, but that would
            // require a lot of code (see Affine and all its append* methods)
        }

        @Override
        public double getMxx() {
            return xx;
        }

        @Override
        public double getMxy() {
            return xy;
        }

        @Override
        public double getMxz() {
            return xz;
        }

        @Override
        public double getTx() {
            return xt;
        }

        @Override
        public double getMyx() {
            return yx;
        }

        @Override
        public double getMyy() {
            return yy;
        }

        @Override
        public double getMyz() {
            return yz;
        }

        @Override
        public double getTy() {
            return yt;
        }

        @Override
        public double getMzx() {
            return zx;
        }

        @Override
        public double getMzy() {
            return zy;
        }

        @Override
        public double getMzz() {
            return zz;
        }

        @Override
        public double getTz() {
            return zt;
        }

    /* *************************************************************************
     *                                                                         *
     *                           State getters                                 *
     *                                                                         *
     **************************************************************************/

        @Override
        public double determinant() {
            switch(state3d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_NON_3D:
                    switch (state2d) {
                        default:
                            stateError();
                            // cannot reach
                        case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                        case APPLY_SHEAR | APPLY_SCALE:
                            return xx * yy - xy * yx;
                        case APPLY_SHEAR | APPLY_TRANSLATE:
                        case APPLY_SHEAR:
                            return -(xy* yx);
                        case APPLY_SCALE | APPLY_TRANSLATE:
                        case APPLY_SCALE:
                            return xx * yy;
                        case APPLY_TRANSLATE:
                        case APPLY_IDENTITY:
                            return 1.0;
                    }
                case APPLY_TRANSLATE:
                    return 1.0;
                case APPLY_SCALE:
                case APPLY_SCALE | APPLY_TRANSLATE:
                    return xx * yy * zz;
                case APPLY_3D_COMPLEX:
                    return (xx* (yy * zz - zy * yz) +
                            xy* (yz * zx - zz * yx) +
                            xz* (yx * zy - zx * yy));
            }
        }

        @Override
        public Transform createConcatenation(Transform transform) {
            javafx.scene.transform.Affine a = new Affine(this);
            a.append(transform);
            return a;
        }

        @Override
        public javafx.scene.transform.Affine createInverse() throws NonInvertibleTransformException {
            javafx.scene.transform.Affine t = new Affine(this);
            t.invert();
            return t;
        }

        @Override
        public Transform clone() {
            return new ImmutableTransform(this);
        }

        /* *************************************************************************
         *                                                                         *
         *                     Transform, Inverse Transform                        *
         *                                                                         *
         **************************************************************************/

        @Override
        public Point2D transform(double x, double y) {
            ensureCanTransform2DPoint();

            switch (state2d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                    return new Point2D(
                        xx * x + xy * y + xt,
                        yx * x + yy * y + yt);
                case APPLY_SHEAR | APPLY_SCALE:
                    return new Point2D(
                        xx * x + xy * y,
                        yx * x + yy * y);
                case APPLY_SHEAR | APPLY_TRANSLATE:
                    return new Point2D(
                            xy * y + xt,
                            yx * x + yt);
                case APPLY_SHEAR:
                    return new Point2D(xy * y, yx * x);
                case APPLY_SCALE | APPLY_TRANSLATE:
                    return new Point2D(
                            xx * x + xt,
                            yy * y + yt);
                case APPLY_SCALE:
                    return new Point2D(xx * x, yy * y);
                case APPLY_TRANSLATE:
                    return new Point2D(x + xt, y + yt);
                case APPLY_IDENTITY:
                    return new Point2D(x, y);
            }
        }

        @Override
        public Point3D transform(double x, double y, double z) {
            switch (state3d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_NON_3D:
                    switch (state2d) {
                        default:
                            stateError();
                            // cannot reach
                        case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                            return new Point3D(
                                xx * x + xy * y + xt,
                                yx * x + yy * y + yt, z);
                        case APPLY_SHEAR | APPLY_SCALE:
                            return new Point3D(
                                xx * x + xy * y,
                                yx * x + yy * y, z);
                        case APPLY_SHEAR | APPLY_TRANSLATE:
                            return new Point3D(
                                    xy * y + xt, yx * x + yt,
                                    z);
                        case APPLY_SHEAR:
                            return new Point3D(xy * y, yx * x, z);
                        case APPLY_SCALE | APPLY_TRANSLATE:
                            return new Point3D(
                                    xx * x + xt, yy * y + yt,
                                    z);
                        case APPLY_SCALE:
                            return new Point3D(xx * x, yy * y, z);
                        case APPLY_TRANSLATE:
                            return new Point3D(x + xt, y + yt, z);
                        case APPLY_IDENTITY:
                            return new Point3D(x, y, z);
                    }
                case APPLY_TRANSLATE:
                    return new Point3D(x + xt, y + yt, z + zt);
                case APPLY_SCALE:
                    return new Point3D(xx * x, yy * y, zz * z);
                case APPLY_SCALE | APPLY_TRANSLATE:
                    return new Point3D(
                            xx * x + xt,
                            yy * y + yt,
                            zz * z + zt);
                case APPLY_3D_COMPLEX:
                    return new Point3D(
                        xx * x + xy * y + xz * z + xt,
                        yx * x + yy * y + yz * z + yt,
                        zx * x + zy * y + zz * z + zt);
            }
        }

        @Override
        public Point2D deltaTransform(double x, double y) {
            ensureCanTransform2DPoint();

            switch (state2d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                case APPLY_SHEAR | APPLY_SCALE:
                    return new Point2D(
                        xx * x + xy * y,
                        yx * x + yy * y);
                case APPLY_SHEAR | APPLY_TRANSLATE:
                case APPLY_SHEAR:
                    return new Point2D(xy * y, yx * x);
                case APPLY_SCALE | APPLY_TRANSLATE:
                case APPLY_SCALE:
                    return new Point2D(xx * x, yy * y);
                case APPLY_TRANSLATE:
                case APPLY_IDENTITY:
                    return new Point2D(x, y);
            }
        }

        @Override
        public Point3D deltaTransform(double x, double y, double z) {
            switch (state3d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_NON_3D:
                    switch (state2d) {
                        default:
                            stateError();
                            // cannot reach
                        case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                        case APPLY_SHEAR | APPLY_SCALE:
                            return new Point3D(
                                xx * x + xy * y,
                                yx * x + yy * y, z);
                        case APPLY_SHEAR | APPLY_TRANSLATE:
                        case APPLY_SHEAR:
                            return new Point3D(xy * y, yx * x, z);
                        case APPLY_SCALE | APPLY_TRANSLATE:
                        case APPLY_SCALE:
                            return new Point3D(xx * x, yy * y, z);
                        case APPLY_TRANSLATE:
                        case APPLY_IDENTITY:
                            return new Point3D(x, y, z);
                    }
                case APPLY_TRANSLATE:
                    return new Point3D(x, y, z);
                case APPLY_SCALE:
                case APPLY_SCALE | APPLY_TRANSLATE:
                    return new Point3D(xx * x, yy * y, zz * z);
                case APPLY_3D_COMPLEX:
                    return new Point3D(
                        xx * x + xy * y + xz * z,
                        yx * x + yy * y + yz * z,
                        zx * x + zy * y + zz * z);
            }
        }

        @Override
        public Point2D inverseTransform(double x, double y)
                throws NonInvertibleTransformException {
            ensureCanTransform2DPoint();

            switch (state2d) {
                default:
                    return super.inverseTransform(x, y);
                case APPLY_SHEAR | APPLY_TRANSLATE:
                    if (xy == 0.0 || yx == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D(
                            (1.0 / yx) * y - yt / yx,
                            (1.0 / xy) * x - xt / xy);
                case APPLY_SHEAR:
                    if (xy == 0.0 || yx == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D((1.0 / yx) * y, (1.0 / xy) * x);
                case APPLY_SCALE | APPLY_TRANSLATE:
                    if (xx == 0.0 || yy == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D(
                            (1.0 / xx) * x - xt / xx,
                            (1.0 / yy) * y - yt / yy);
                case APPLY_SCALE:
                    if (xx == 0.0 || yy == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D((1.0 / xx) * x, (1.0 / yy) * y);
                case APPLY_TRANSLATE:
                    return new Point2D(x - xt, y - yt);
                case APPLY_IDENTITY:
                    return new Point2D(x, y);
            }
        }

        @Override
        public Point3D inverseTransform(double x, double y, double z)
                throws NonInvertibleTransformException {
            switch(state3d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_NON_3D:
                    switch (state2d) {
                        default:
                            return super.inverseTransform(x, y, z);
                        case APPLY_SHEAR | APPLY_TRANSLATE:
                            if (xy == 0.0 || yx == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D(
                                    (1.0 / yx) * y - yt / yx,
                                    (1.0 / xy) * x - xt / xy, z);
                        case APPLY_SHEAR:
                            if (xy == 0.0 || yx == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D(
                                    (1.0 / yx) * y,
                                    (1.0 / xy) * x, z);
                        case APPLY_SCALE | APPLY_TRANSLATE:
                            if (xx == 0.0 || yy == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D(
                                    (1.0 / xx) * x - xt / xx,
                                    (1.0 / yy) * y - yt / yy, z);
                        case APPLY_SCALE:
                            if (xx == 0.0 || yy == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D((1.0 / xx) * x, (1.0 / yy) * y, z);
                        case APPLY_TRANSLATE:
                            return new Point3D(x - xt, y - yt, z);
                        case APPLY_IDENTITY:
                            return new Point3D(x, y, z);
                    }
                case APPLY_TRANSLATE:
                    return new Point3D(x - xt, y - yt, z - zt);
                case APPLY_SCALE:
                    if (xx == 0.0 || yy == 0.0 || zz == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point3D(
                            (1.0 / xx) * x,
                            (1.0 / yy) * y,
                            (1.0 / zz) * z);
                case APPLY_SCALE | APPLY_TRANSLATE:
                    if (xx == 0.0 || yy == 0.0 || zz == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point3D(
                            (1.0 / xx) * x - xt / xx,
                            (1.0 / yy) * y - yt / yy,
                            (1.0 / zz) * z - zt / zz);
                case APPLY_3D_COMPLEX:
                    return super.inverseTransform(x, y, z);
            }
        }

        @Override
        public Point2D inverseDeltaTransform(double x, double y)
                throws NonInvertibleTransformException {
            ensureCanTransform2DPoint();

            switch (state2d) {
                default:
                    return super.inverseDeltaTransform(x, y);
                case APPLY_SHEAR | APPLY_TRANSLATE:
                case APPLY_SHEAR:
                    if (xy == 0.0 || yx == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D((1.0 / yx) * y, (1.0 / xy) * x);
                case APPLY_SCALE | APPLY_TRANSLATE:
                case APPLY_SCALE:
                    if (xx == 0.0 || yy == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D((1.0 / xx) * x, (1.0 / yy) * y);
                case APPLY_TRANSLATE:
                case APPLY_IDENTITY:
                    return new Point2D(x, y);
            }
        }

        @Override
        public Point3D inverseDeltaTransform(double x, double y, double z)
                throws NonInvertibleTransformException {
            switch(state3d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_NON_3D:
                    switch (state2d) {
                        default:
                            return super.inverseDeltaTransform(x, y, z);
                        case APPLY_SHEAR | APPLY_TRANSLATE:
                        case APPLY_SHEAR:
                            if (xy == 0.0 || yx == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D(
                                    (1.0 / yx) * y,
                                    (1.0 / xy) * x, z);
                        case APPLY_SCALE | APPLY_TRANSLATE:
                        case APPLY_SCALE:
                            if (xx == 0.0 || yy == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D(
                                    (1.0 / xx) * x,
                                    (1.0 / yy) * y, z);
                        case APPLY_TRANSLATE:
                        case APPLY_IDENTITY:
                            return new Point3D(x, y, z);
                    }

                case APPLY_TRANSLATE:
                    return new Point3D(x, y, z);
                case APPLY_SCALE | APPLY_TRANSLATE:
                case APPLY_SCALE:
                    if (xx == 0.0 || yy == 0.0 || zz == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point3D(
                            (1.0 / xx) * x,
                            (1.0 / yy) * y,
                            (1.0 / zz) * z);
                case APPLY_3D_COMPLEX:
                    return super.inverseDeltaTransform(x, y, z);
            }
        }

        /* *************************************************************************
         *                                                                         *
         *                               Other API                                 *
         *                                                                         *
         **************************************************************************/

        @Override
        public String toString() {
           final StringBuilder sb = new StringBuilder(&quot;Transform [\n&quot;);

            sb.append(&quot;\t&quot;).append(xx);
            sb.append(&quot;, &quot;).append(xy);
            sb.append(&quot;, &quot;).append(xz);
            sb.append(&quot;, &quot;).append(xt);
            sb.append('\n');
            sb.append(&quot;\t&quot;).append(yx);
            sb.append(&quot;, &quot;).append(yy);
            sb.append(&quot;, &quot;).append(yz);
            sb.append(&quot;, &quot;).append(yt);
            sb.append('\n');
            sb.append(&quot;\t&quot;).append(zx);
            sb.append(&quot;, &quot;).append(zy);
            sb.append(&quot;, &quot;).append(zz);
            sb.append(&quot;, &quot;).append(zt);

            return sb.append(&quot;\n]&quot;).toString();
        }

        /* *************************************************************************
         *                                                                         *
         *                    Internal implementation stuff                        *
         *                                                                         *
         **************************************************************************/

        private void updateState() {
            updateState2D();

            state3d = APPLY_NON_3D;

            if (xz != 0.0 ||
                yz != 0.0 ||
                zx != 0.0 ||
                zy != 0.0)
            {
                state3d = APPLY_3D_COMPLEX;
            } else {
                if ((state2d &amp; APPLY_SHEAR) == 0) {
                    if (zt != 0.0) {
                        state3d |= APPLY_TRANSLATE;
                    }
                    if (zz != 1.0) {
                        state3d |= APPLY_SCALE;
                    }
                    if (state3d != APPLY_NON_3D) {
                        state3d |= (state2d &amp; (APPLY_SCALE | APPLY_TRANSLATE));
                    }
                } else {
                    if (zz != 1.0 || zt != 0.0) {
                        state3d = APPLY_3D_COMPLEX;
                    }
                }
            }
        }

        private void updateState2D() {
            if (xy == 0.0 &amp;&amp; yx == 0.0) {
                if (xx == 1.0 &amp;&amp; yy == 1.0) {
                    if (xt == 0.0 &amp;&amp; yt == 0.0) {
                        state2d = APPLY_IDENTITY;
                    } else {
                        state2d = APPLY_TRANSLATE;
                    }
                } else {
                    if (xt == 0.0 &amp;&amp; yt == 0.0) {
                        state2d = APPLY_SCALE;
                    } else {
                        state2d = (APPLY_SCALE | APPLY_TRANSLATE);
                    }
                }
            } else {
                if (xx == 0.0 &amp;&amp; yy == 0.0) {
                    if (xt == 0.0 &amp;&amp; yt == 0.0) {
                        state2d = APPLY_SHEAR;
                    } else {
                        state2d = (APPLY_SHEAR | APPLY_TRANSLATE);
                    }
                } else {
                    if (xt == 0.0 &amp;&amp; yt == 0.0) {
                        state2d = (APPLY_SHEAR | APPLY_SCALE);
                    } else {
                        state2d = (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE);
                    }
                }
            }
        }

        void ensureCanTransform2DPoint() throws IllegalStateException {
            if (state3d != APPLY_NON_3D) {
                throw new IllegalStateException(&quot;Cannot transform 2D point &quot;
                        + &quot;with a 3D transform&quot;);
            }
        }

        private static void stateError() {
            throw new InternalError(&quot;missing case in a switch&quot;);
        }


        @Override
        void apply(final Affine3D trans) {
            trans.concatenate(xx, xy, xz, xt,
                              yx, yy, yz, yt,
                              zx, zy, zz, zt);
        }

        @Override
        BaseTransform derive(final BaseTransform trans) {
            return trans.deriveWithConcatenation(xx, xy, xz, xt,
                                                 yx, yy, yz, yt,
                                                 zx, zy, zz, zt);
        }

        /**
         * Used only by tests to check the 2d matrix state
         */
        int getState2d() {
            return state2d;
        }

        /**
         * Used only by tests to check the 3d matrix state
         */
        int getState3d() {
            return state3d;
        }

    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.media/com/sun/media/jfxmediaimpl/NativeMediaManager.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.jfxmediaimpl;

import com.sun.glass.utils.NativeLibLoader;
import com.sun.media.jfxmedia.*;
import com.sun.media.jfxmedia.events.MediaErrorListener;
import com.sun.media.jfxmedia.locator.Locator;
import com.sun.media.jfxmedia.logging.Logger;
import com.sun.media.jfxmediaimpl.platform.PlatformManager;
import java.lang.ref.WeakReference;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.WeakHashMap;

/**
 * A class representing a native media engine.
 */
public class NativeMediaManager {
    /**
     * Whether the native layer has been initialized.
     */
    private static boolean isNativeLayerInitialized = false;
    /**
     * The {@link MediaErrorListener}s.
     */
    // FIXME: Change to WeakHashMap&lt;MediaErrorListener,Boolean&gt; as it's more efficient
    private final List&lt;WeakReference&lt;MediaErrorListener&gt;&gt; errorListeners =
            new ArrayList();
    private final static NativeMediaPlayerDisposer playerDisposer =
            new NativeMediaPlayerDisposer();
    /**
     * List of all un-disposed players.
     */
    private final static Map&lt;MediaPlayer,Boolean&gt; allMediaPlayers =
            new WeakHashMap();

    // cached content types, so we don't have to poll and sort each time, this list
    // should never change once we're initialized
    private final List&lt;String&gt; supportedContentTypes =
            new ArrayList();
    private final List&lt;String&gt; supportedProtocols =
            new ArrayList&lt;&gt;();

    /**
     * The NativeMediaManager singleton.
     */
    private static class NativeMediaManagerInitializer {
        private static final NativeMediaManager globalInstance
                = new NativeMediaManager();
    }

    /**
     * Get the default
     * &lt;code&gt;NativeMediaManager&lt;/code&gt;.
     *
     * @return the singleton
     * &lt;code&gt;NativeMediaManager&lt;/code&gt; instance.
     */
    public static NativeMediaManager getDefaultInstance() {
        return NativeMediaManagerInitializer.globalInstance;
    }

    //**************************************************************************
    //***** Constructors
    //**************************************************************************
    /**
     * Create a &lt;code&gt;NativeMediaManager&lt;/code&gt;.
     */
    protected NativeMediaManager() {
        /*
         * Load native libraries. This must be done early as platforms may need
         * to attempt loading their own native libs that are dependent on these
         * This is a slight performance hit, but necessary otherwise we could
         * erroneously report content types for platforms that cannot be loaded
         */
        try {
            AccessController.doPrivileged((PrivilegedExceptionAction) () -&gt; {
                ArrayList&lt;String&gt; dependencies = new ArrayList&lt;&gt;();
                if (HostUtils.isWindows() || HostUtils.isMacOSX()) {
                    NativeLibLoader.loadLibrary(&quot;glib-lite&quot;);
                }

                if (!HostUtils.isLinux() &amp;&amp; !HostUtils.isIOS()) {
                    NativeLibLoader.loadLibrary(&quot;gstreamer-lite&quot;);
<A NAME="14"></A>                } else {
                    dependencies.add(&quot;gstreamer-lite&quot;);
                }
                <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#14',2,'match46-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (HostUtils.isLinux()) {
                    dependencies.add(&quot;fxplugins&quot;);
                    dependencies.add(&quot;avplugin&quot;);
                    dependencies.add(&quot;avplugin-54&quot;);
                    dependencies.add(&quot;avplugin-56&quot;);
                    dependencies.add(&quot;avplugin-57&quot;);
                    dependencies.add(&quot;avplugin-ffmpeg-56&quot;);
                    dependencies.add(&quot;avplugin-ffmpeg-57&quot;);
                }
                if (HostUtils.isMacOSX()) {
                    dependencies.add(&quot;fxplugins&quot;);
                    dependencies.add</B></FONT>(&quot;glib-lite&quot;);
                    dependencies.add(&quot;jfxmedia_avf&quot;);
                }
                if (HostUtils.isWindows()) {
                    dependencies.add(&quot;fxplugins&quot;);
                    dependencies.add(&quot;glib-lite&quot;);
                }
                NativeLibLoader.loadLibrary(&quot;jfxmedia&quot;, dependencies);
                return null;
            });
        } catch (PrivilegedActionException pae) {
            MediaUtils.error(null, MediaError.ERROR_MANAGER_ENGINEINIT_FAIL.code(),
                    &quot;Unable to load one or more dependent libraries.&quot;, pae);
        }

        // Get the Logger native side rolling before we load platforms
        if (!Logger.initNative()) {
            MediaUtils.error(null, MediaError.ERROR_MANAGER_LOGGER_INIT.code(),
                    &quot;Unable to init logger&quot;, null);
        }
    }

    /**
     * Initialize the native layer if it has not been so already.
     */
    synchronized static void initNativeLayer() {
        if (!isNativeLayerInitialized) {
            // load platforms
            PlatformManager.getManager().loadPlatforms();

            // Set the native initialization flag, even if initialization failed.
            isNativeLayerInitialized = true;
        }
    }

    //**************************************************************************
    //***** Public control functions
    //**************************************************************************

    private synchronized void loadContentTypes() {
        if (!supportedContentTypes.isEmpty()) {
            // already populated, just return
            return;
        }

        List&lt;String&gt; npt = PlatformManager.getManager().getSupportedContentTypes();
        if (null != npt &amp;&amp; !npt.isEmpty()) {
            supportedContentTypes.addAll(npt);
        }

        if (Logger.canLog(Logger.DEBUG)) {
            StringBuilder sb = new StringBuilder(&quot;JFXMedia supported content types:\n&quot;);
            for (String type : supportedContentTypes) {
                sb.append(&quot;    &quot;);
                sb.append(type);
                sb.append(&quot;\n&quot;);
            }
            Logger.logMsg(Logger.DEBUG, sb.toString());
        }
    }

    private synchronized void loadProtocols() {
        if (!supportedProtocols.isEmpty()) {
            // already populated, just return
            return;
        }

        List&lt;String&gt; npt = PlatformManager.getManager().getSupportedProtocols();
        if (null != npt &amp;&amp; !npt.isEmpty()) {
            supportedProtocols.addAll(npt);
        }

        if (Logger.canLog(Logger.DEBUG)) {
            StringBuilder sb = new StringBuilder(&quot;JFXMedia supported protocols:\n&quot;);
            for (String type : supportedProtocols) {
                sb.append(&quot;    &quot;);
                sb.append(type);
                sb.append(&quot;\n&quot;);
            }
            Logger.logMsg(Logger.DEBUG, sb.toString());
        }
    }

    /**
     * Whether a media source having the indicated content type may be played.
     *
     * @see MediaManager#canPlayContentType(java.lang.String)
     *
     * @throws IllegalArgumentException if
     * &lt;code&gt;contentType&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     */
    public boolean canPlayContentType(String contentType) {
        if (contentType == null) {
            throw new IllegalArgumentException(&quot;contentType == null!&quot;);
        }

        if (supportedContentTypes.isEmpty()) {
            loadContentTypes();
        }

        /*
         * Don't just use supportedContentType.contains(contentType) as that
         * is case sensitive, which we do not want
         */
        for (String type : supportedContentTypes) {
            if (contentType.equalsIgnoreCase(type)) {
                return true;
            }
        }

        return false;
    }

    public String[] getSupportedContentTypes() {
        if (supportedContentTypes.isEmpty()) {
            loadContentTypes();
        }

        return supportedContentTypes.toArray(new String[1]);
    }

    /**
     * Whether a media source having the indicated protocol may be played.
     *
     * @see MediaManager#canPlayProtocol(java.lang.String)
     *
     * @throws IllegalArgumentException if
     * &lt;code&gt;protocol&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     */
    public boolean canPlayProtocol(String protocol) {
        if (protocol == null) {
            throw new IllegalArgumentException(&quot;protocol == null!&quot;);
        }

        if (supportedProtocols.isEmpty()) {
            loadProtocols();
        }

        /*
         * Don't just use supportedProtocols.contains(protocol) as that
         * is case sensitive, which we do not want
         */
        for (String type : supportedProtocols) {
            if (protocol.equalsIgnoreCase(type)) {
                return true;
            }
        }

        return false;
    }

    public static MetadataParser getMetadataParser(Locator locator) {
        return PlatformManager.getManager().createMetadataParser(locator);
    }

    /**
     * @see MediaManager#getPlayer(com.sun.media.jfxmedia.locator.Locator, int)
     */
    public MediaPlayer getPlayer(Locator locator) {
        // FIXME: remove this
        initNativeLayer();

        MediaPlayer player = PlatformManager.getManager().createMediaPlayer(locator);
        if (null == player) {
            throw new MediaException(&quot;Could not create player!&quot;);
        }

        // Cache a reference to the player.
        allMediaPlayers.put(player, Boolean.TRUE);

        return player;
    }

    /**
     * Get a player for the media locator. A preference may be set as to whether
     * to allow a full scan of the media.
     *
     * FIXME: Nuke permitFullScan, it is unused and has no effect
     *
     * @param locator
     * @param permitFullScan
     * @return MediaPlayer object
     */
    public Media getMedia(Locator locator) {
        initNativeLayer();
        return PlatformManager.getManager().createMedia(locator);
    }

    /**
     * @see
     * MediaManager#addMediaErrorListener(com.sun.media.jfxmedia.events.MediaErrorListener)
     */
    public void addMediaErrorListener(MediaErrorListener listener) {
        if (listener != null) {
            // Since we have only one instance of NativeMediaManager, all media players
            // created during application lifecycle will keep weak references to error
            // listeners in errorListeners. Lets clean up unused references.
            // FIXME: change to WeakHashMap&lt;MEL,Boolean&gt; as it's more efficient
            for (ListIterator&lt;WeakReference&lt;MediaErrorListener&gt;&gt; it = errorListeners.listIterator(); it.hasNext();) {
                MediaErrorListener l = it.next().get();
                if (l == null) {
                    it.remove();
                }
            }

            this.errorListeners.add(new WeakReference&lt;MediaErrorListener&gt;(listener));
        }
    }

    /**
     * @see
     * MediaManager#removeMediaErrorListener(com.sun.media.jfxmedia.events.MediaErrorListener)
     */
    public void removeMediaErrorListener(MediaErrorListener listener) {
        if (listener != null) {
            // FIXME: change to WeakHashMap&lt;MEL,Boolean&gt; as it's more efficient
            for (ListIterator&lt;WeakReference&lt;MediaErrorListener&gt;&gt; it = errorListeners.listIterator(); it.hasNext();) {
                MediaErrorListener l = it.next().get();
                if (l == null || l == listener) {
                    it.remove();
            }
        }
    }
        }

    /**
     * This function will register MediaPlayer for disposing when obj parameter
     * does not have any strong reference.
     *
     * FIXME: Nuke this and use MediaDisposer instead
     *
     * @param obj - Object to watch for strong references
     * @param player - MediaPlayer to dispose
     */
    public static void registerMediaPlayerForDispose(Object obj, MediaPlayer player) {
        MediaDisposer.addResourceDisposer(obj, player, playerDisposer);
    }

    /**
     * Retrieve all un-disposed {@link MediaPlayer}s.
     *
     * @return a {@link List} of all un-disposed players or
     * &lt;code&gt;null&lt;/code&gt;.
     */
    public List&lt;MediaPlayer&gt; getAllMediaPlayers() {
        List&lt;MediaPlayer&gt; allPlayers = null;

        if (!allMediaPlayers.isEmpty()) {
            allPlayers = new ArrayList&lt;MediaPlayer&gt;(allMediaPlayers.keySet());
        }

        return allPlayers;
    }

    //**************************************************************************
    //***** Private functions
    //**************************************************************************
    List&lt;WeakReference&lt;MediaErrorListener&gt;&gt; getMediaErrorListeners() {
        return this.errorListeners;
    }

    private static class NativeMediaPlayerDisposer implements MediaDisposer.ResourceDisposer {

        public void disposeResource(Object resource) {
            // resource is a MediaPlayer
            MediaPlayer player = (MediaPlayer) resource;
            if (player != null) {
                player.dispose();
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.media/javafx/scene/media/MediaView.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.media;

import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.media.MediaViewHelper;
import com.sun.javafx.sg.prism.MediaFrameTracker;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.tk.Toolkit;
import com.sun.media.jfxmediaimpl.HostUtils;
import com.sun.media.jfxmedia.control.MediaPlayerOverlay;
import javafx.application.Platform;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.*;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableObjectValue;
import javafx.beans.value.ObservableValue;
import javafx.collections.ObservableMap;
import javafx.event.EventHandler;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Rectangle2D;
import javafx.scene.Node;
import javafx.scene.Parent;

/**
 * A {@link Node} that provides a view of {@link Media} being played by a
 * {@link MediaPlayer}.
 *
 * &lt;p&gt;The following code snippet provides a simple example of an
 * {@link javafx.application.Application#start(javafx.stage.Stage) Application.start()}
 * method which displays a video:
 * &lt;/p&gt;
 * &lt;pre&gt;{@code
 * public void start(Stage stage) {
 *     // Create and set the Scene.
 *     Scene scene = new Scene(new Group(), 540, 209);
 *     stage.setScene(scene);
 *
 *     // Name and display the Stage.
 *     stage.setTitle(&quot;Hello Media&quot;);
 *     stage.show();
 *
 *     // Create the media source.
 *     String source = getParameters().getRaw().get(0);
 *     Media media = new Media(source);
 *
 *     // Create the player and set to play automatically.
 *     MediaPlayer mediaPlayer = new MediaPlayer(media);
 *     mediaPlayer.setAutoPlay(true);
 *
 *     // Create the view and add it to the Scene.
 *     MediaView mediaView = new MediaView(mediaPlayer);
 *     ((Group) scene.getRoot()).getChildren().add(mediaView);
 * }
 * }&lt;/pre&gt;
 * The foregoing code will display the video as:
 * &lt;br&gt;
 * &lt;br&gt;
 * &lt;img src=&quot;doc-files/mediaview.png&quot; alt=&quot;Hello Media&quot;&gt;
 *
 * @since JavaFX 2.0
 */
public class MediaView extends Node {
    static {
         // This is used by classes in different packages to get access to
         // private and package private methods.
        MediaViewHelper.setMediaViewAccessor(new MediaViewHelper.MediaViewAccessor() {
            @Override
            public NGNode doCreatePeer(Node node) {
                return ((MediaView) node).doCreatePeer();
            }

            @Override
            public void doUpdatePeer(Node node) {
                ((MediaView) node).doUpdatePeer();
            }

            @Override
            public void doTransformsChanged(Node node) {
                ((MediaView) node).doTransformsChanged();
            }

            @Override
            public BaseBounds doComputeGeomBounds(Node node,
                    BaseBounds bounds, BaseTransform tx) {
                return ((MediaView) node).doComputeGeomBounds(bounds, tx);
            }

            @Override
            public boolean doComputeContains(Node node, double localX, double localY) {
                return ((MediaView) node).doComputeContains(localX, localY);
            }
        });
    }

    /**
     * The name of the property in the {@link ObservableMap} returned by
     * {@link #getProperties()}. This value must also be defined as a JVM
     * command line definition for the frame rate to be added to the properties.
     */
    private static final String VIDEO_FRAME_RATE_PROPERTY_NAME = &quot;jfxmedia.decodedVideoFPS&quot;;

    private static final String DEFAULT_STYLE_CLASS = &quot;media-view&quot;;

    /**
     * Inner class used to convert a &lt;code&gt;MediaPlayer&lt;/code&gt; error into a
     * &lt;code&gt;Bean&lt;/code&gt; event.
     */
    private class MediaErrorInvalidationListener implements InvalidationListener {

        @Override public void invalidated(Observable value) {
            ObservableObjectValue&lt;MediaException&gt; errorProperty = (ObservableObjectValue&lt;MediaException&gt;)value;
            fireEvent(new MediaErrorEvent(getMediaPlayer(), getMediaView(), errorProperty.get()));
        }
    }

    /** Listener which converts &lt;code&gt;MediaPlayer&lt;/code&gt; errors to events. */
    private InvalidationListener errorListener = new MediaErrorInvalidationListener();

    /** Listener which causes the geometry to be updated when the media dimension changes. */
    private InvalidationListener mediaDimensionListener = value -&gt; {
        NodeHelper.markDirty(this, DirtyBits.NODE_VIEWPORT);
        NodeHelper.geomChanged(this);
    };

    /** Listener for decoded frame rate. */
    private com.sun.media.jfxmedia.events.VideoFrameRateListener decodedFrameRateListener;
    private boolean registerVideoFrameRateListener = false;

    /** Creates a decoded frame rate listener. Will return &lt;code&gt;null&lt;/code&gt; if
     * the security manager does not permit retrieve system properties or if
     * VIDEO_FRAME_RATE_PROPERTY_NAME is not set to &quot;true.&quot;
     */
    private com.sun.media.jfxmedia.events.VideoFrameRateListener createVideoFrameRateListener() {
        String listenerProp = null;
        try {
            listenerProp = System.getProperty(VIDEO_FRAME_RATE_PROPERTY_NAME);
        } catch (Throwable t) {
        }

        if (listenerProp == null || !Boolean.getBoolean(VIDEO_FRAME_RATE_PROPERTY_NAME)) {
            return null;
        } else {
            return videoFrameRate -&gt; {
                Platform.runLater(() -&gt; {
                    ObservableMap props = getProperties();
                    props.put(VIDEO_FRAME_RATE_PROPERTY_NAME, videoFrameRate);
                });
            };
        }
    }

    /***************************************** Media Player Overlay support ***************************/

    private MediaPlayerOverlay mediaPlayerOverlay = null;

    private ChangeListener&lt;Parent&gt; parentListener;
    private ChangeListener&lt;Boolean&gt; treeVisibleListener;
    private ChangeListener&lt;Number&gt; opacityListener;

    private void createListeners() {
        parentListener = (ov2, oldParent, newParent) -&gt; {
            updateOverlayVisibility();
        };

        treeVisibleListener = (ov1, oldVisible, newVisible) -&gt; {
            updateOverlayVisibility();
        };

        opacityListener = (ov, oldOpacity, newOpacity) -&gt; {
            updateOverlayOpacity();
        };
    }

    private boolean determineVisibility() {
        return (getParent() != null &amp;&amp; isVisible());
    }

    private synchronized void updateOverlayVisibility() {
        if (mediaPlayerOverlay != null) {
            mediaPlayerOverlay.setOverlayVisible(determineVisibility());
        }
    }

    private synchronized void updateOverlayOpacity() {
        if (mediaPlayerOverlay != null) {
            mediaPlayerOverlay.setOverlayOpacity(getOpacity());
        }
    }

    private synchronized void updateOverlayX() {
        if (mediaPlayerOverlay != null) {
            mediaPlayerOverlay.setOverlayX(getX());
        }
    }

    private synchronized void updateOverlayY() {
        if (mediaPlayerOverlay != null) {
            mediaPlayerOverlay.setOverlayY(getY());
        }
    }

    private synchronized void updateOverlayWidth() {
        if (mediaPlayerOverlay != null) {
            mediaPlayerOverlay.setOverlayWidth(getFitWidth());
        }
    }

    private synchronized void updateOverlayHeight() {
        if (mediaPlayerOverlay != null) {
            mediaPlayerOverlay.setOverlayHeight(getFitHeight());
        }
    }

    private synchronized void updateOverlayPreserveRatio() {
        if (mediaPlayerOverlay != null) {
            mediaPlayerOverlay.setOverlayPreserveRatio(isPreserveRatio());
        }
    }

    private static Affine3D calculateNodeToSceneTransform(Node node) {
        final Affine3D transform = new Affine3D();
        do {
            transform.preConcatenate(NodeHelper.getLeafTransform(node));
            node = node.getParent();
        } while (node != null);

        return transform;
    }

    private void updateOverlayTransform() {
        if (mediaPlayerOverlay != null) {
            final Affine3D trans = MediaView.calculateNodeToSceneTransform(this);
            mediaPlayerOverlay.setOverlayTransform(
                    trans.getMxx(), trans.getMxy(), trans.getMxz(), trans.getMxt(),
                    trans.getMyx(), trans.getMyy(), trans.getMyz(), trans.getMyt(),
                    trans.getMzx(), trans.getMzy(), trans.getMzz(), trans.getMzt());
        }
    }

    private void updateMediaPlayerOverlay() {
        mediaPlayerOverlay.setOverlayX(getX());
        mediaPlayerOverlay.setOverlayY(getY());
        mediaPlayerOverlay.setOverlayPreserveRatio(isPreserveRatio());
        mediaPlayerOverlay.setOverlayWidth(getFitWidth());
        mediaPlayerOverlay.setOverlayHeight(getFitHeight());
        mediaPlayerOverlay.setOverlayOpacity(getOpacity());
        mediaPlayerOverlay.setOverlayVisible(determineVisibility());
        updateOverlayTransform();
    }

    /*
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doTransformsChanged() {
        if (mediaPlayerOverlay != null) {
            updateOverlayTransform();
        }
    }

    /******************************************* End of iOS specific stuff ***************************/

    /**
     * @return reference to MediaView
     */
    private MediaView getMediaView() {
        return this;
    }

    {
        // To initialize the class helper at the begining each constructor of this class
        MediaViewHelper.initHelper(this);
    }

    /**
     * Creates a &lt;code&gt;MediaView&lt;/code&gt; instance with no associated
     * {@link MediaPlayer}.
     */
    public MediaView() {
        getStyleClass().add(DEFAULT_STYLE_CLASS);
        setSmooth(Toolkit.getToolkit().getDefaultImageSmooth());
        decodedFrameRateListener = createVideoFrameRateListener();
        setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
    }

    /**
     * Creates a &lt;code&gt;MediaView&lt;/code&gt; instance associated with the specified
     * {@link MediaPlayer}. Equivalent to
     * &lt;pre&gt;&lt;code&gt;
     * MediaPlayer player; // initialization omitted
     * MediaView view = new MediaView();
     * view.setMediaPlayer(player);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param mediaPlayer the {@link MediaPlayer} the playback of which is to be
     * viewed via this class.
     */
    public MediaView(MediaPlayer mediaPlayer) {
        this();
        setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
        setMediaPlayer(mediaPlayer);
    }
    /**
     * The &lt;code&gt;mediaPlayer&lt;/code&gt; whose output will be handled by this view.
     *
     * Setting this value does not affect the status of the &lt;code&gt;MediaPlayer&lt;/code&gt;,
     * e.g., if the &lt;code&gt;MediaPlayer&lt;/code&gt; was playing prior to setting
     * &lt;code&gt;mediaPlayer&lt;/code&gt; then it will continue playing.
     *
     * @see MediaException
     * @see MediaPlayer
     */
    private ObjectProperty&lt;MediaPlayer&gt; mediaPlayer;

    /**
     * Sets the &lt;code&gt;MediaPlayer&lt;/code&gt; whose output will be handled by this view.
     * @param value the associated &lt;code&gt;MediaPlayer&lt;/code&gt;.
     */
    public final void setMediaPlayer (MediaPlayer value) {
        mediaPlayerProperty().set(value);
    }

    /**
     * Retrieves the &lt;code&gt;MediaPlayer&lt;/code&gt; whose output is being handled by
     * this view.
     * @return the associated &lt;code&gt;MediaPlayer&lt;/code&gt;.
     */
    public final MediaPlayer getMediaPlayer() {
        return mediaPlayer == null ? null : mediaPlayer.get();
    }

    public final ObjectProperty&lt;MediaPlayer&gt; mediaPlayerProperty() {
        if (mediaPlayer == null) {
            mediaPlayer = new ObjectPropertyBase&lt;MediaPlayer&gt;() {
                MediaPlayer oldValue = null;
                @Override protected void invalidated() {
                    if (oldValue != null) {
                        Media media = oldValue.getMedia();
                        if (media != null) {
                            media.widthProperty().removeListener(mediaDimensionListener);
                            media.heightProperty().removeListener(mediaDimensionListener);
                        }
                        if (decodedFrameRateListener != null &amp;&amp; getMediaPlayer().retrieveJfxPlayer() != null) {
                            getMediaPlayer().retrieveJfxPlayer().getVideoRenderControl().removeVideoFrameRateListener(decodedFrameRateListener);
                        }
                        oldValue.errorProperty().removeListener(errorListener);
                        oldValue.removeView(getMediaView());
                    }

                    //Uncomment the line below to print whether media is using Prism or Swing frame handler.
                    //System.err.println(getPGMediaView().getClass().getName());
                    //Uncomment the line below to print whether media is using Prism or Swing frame handler.
                    //System.err.println(getPGMediaView().getClass().getName());
                    MediaPlayer newValue = get();
                    if (newValue != null) {
                        newValue.addView(getMediaView());
                        newValue.errorProperty().addListener(errorListener);
                        if (decodedFrameRateListener != null &amp;&amp; getMediaPlayer().retrieveJfxPlayer() != null) {
                            getMediaPlayer().retrieveJfxPlayer().getVideoRenderControl().addVideoFrameRateListener(decodedFrameRateListener);
                        } else if (decodedFrameRateListener != null) {
                            registerVideoFrameRateListener = true;
                        }
                        Media media = newValue.getMedia();
                        if (media != null) {
                            media.widthProperty().addListener(mediaDimensionListener);
                            media.heightProperty().addListener(mediaDimensionListener);
                        }
                    }
                    NodeHelper.markDirty(MediaView.this, DirtyBits.MEDIAVIEW_MEDIA);
                    NodeHelper.geomChanged(MediaView.this);
                    oldValue = newValue;
                }
                @Override
                public Object getBean() {
                    return MediaView.this;
                }

                @Override
                public String getName() {
                    return &quot;mediaPlayer&quot;;
                }
            };
        }
        return mediaPlayer;
    }
    /**
     * Event handler to be invoked whenever an error occurs on this
     * &lt;code&gt;MediaView&lt;/code&gt;.
     *
     * @see MediaErrorEvent
     */
    private ObjectProperty&lt;EventHandler&lt;MediaErrorEvent&gt;&gt; onError;

    /**
     * Sets the error event handler.
     * @param value the error event handler.
     */
    public final void setOnError(EventHandler&lt;MediaErrorEvent&gt; value) {
        onErrorProperty().set( value);
    }

    /**
     * Retrieves the error event handler.
     * @return the error event handler.
     */
    public final EventHandler&lt;MediaErrorEvent&gt; getOnError() {
        return onError == null ? null : onError.get();
    }

    public final ObjectProperty&lt;EventHandler&lt;MediaErrorEvent&gt;&gt; onErrorProperty() {
        if (onError == null) {
            onError = new ObjectPropertyBase&lt;EventHandler&lt;MediaErrorEvent&gt;&gt;() {

                @Override
                protected void invalidated() {
                    setEventHandler(MediaErrorEvent.MEDIA_ERROR, get());
                }

                @Override
                public Object getBean() {
                    return MediaView.this;
                }

                @Override
                public String getName() {
                    return &quot;onError&quot;;
                }
            };
        }
        return onError;
    }
    /**
     * Whether to preserve the aspect ratio (width / height) of the media when
     * scaling it to fit the node. If the aspect ratio is not preserved, the
     * media will be stretched or sheared in both dimensions to fit the
     * dimensions of the node. The default value is &lt;code&gt;true&lt;/code&gt;.
     */
    private BooleanProperty preserveRatio;

    /**
     * Sets whether to preserve the media aspect ratio when scaling.
     * @param value whether to preserve the media aspect ratio.
     */
    public final void setPreserveRatio(boolean value) {
        preserveRatioProperty().set(value);
    };

    /**
     * Returns whether the media aspect ratio is preserved when scaling.
     * @return whether the media aspect ratio is preserved.
     */
    public final boolean isPreserveRatio() {
        return preserveRatio == null ? true : preserveRatio.get();
    }

    public final BooleanProperty preserveRatioProperty() {
        if (preserveRatio == null) {
            preserveRatio = new BooleanPropertyBase(true) {

                @Override
                protected void invalidated() {
                    if (HostUtils.isIOS()) {
                        updateOverlayPreserveRatio();
                    }
                    else {
                        NodeHelper.markDirty(MediaView.this, DirtyBits.NODE_VIEWPORT);
                        NodeHelper.geomChanged(MediaView.this);
                    }
                }

                @Override
                public Object getBean() {
                    return MediaView.this;
                }

                @Override
                public String getName() {
                    return &quot;preserveRatio&quot;;
                }
            };
        }
        return preserveRatio;
    }
    /**
     * If set to &lt;code&gt;true&lt;/code&gt; a better quality filtering
     * algorithm will be used when scaling this video to fit within the
     * bounding box provided by &lt;code&gt;fitWidth&lt;/code&gt; and &lt;code&gt;fitHeight&lt;/code&gt; or
     * when transforming.
     *
     * If set to &lt;code&gt;false&lt;/code&gt; a faster but lesser quality filtering
     * will be used.
     *
     * The default value depends on platform configuration.
     */
    private BooleanProperty smooth;

    /**
     * Sets whether to smooth the media when scaling.
     * @param value whether to smooth the media.
     */
    public final void setSmooth(boolean value) {
        smoothProperty().set(value);
    }

    /**
     * Returns whether to smooth the media when scaling.
     * @return whether to smooth the media
     */
    public final boolean isSmooth() {
        return smooth == null ? false : smooth.get();
    }

    public final BooleanProperty smoothProperty() {
        if (smooth == null) {
            smooth = new BooleanPropertyBase() {

                @Override
                protected void invalidated() {
                    NodeHelper.markDirty(MediaView.this, DirtyBits.NODE_SMOOTH);
                }

                @Override
                public Object getBean() {
                    return MediaView.this;
                }

                @Override
                public String getName() {
                    return &quot;smooth&quot;;
                }
            };
        }
        return smooth;
    }
    // PENDING_DOC_REVIEW
    /**
     * Defines the current x coordinate of the &lt;code&gt;MediaView&lt;/code&gt; origin.
     */
    private DoubleProperty x;

    /**
     * Sets the x coordinate of the &lt;code&gt;MediaView&lt;/code&gt; origin.
     * @param value the x coordinate of the origin of the view.
     */
    public final void setX(double value) {
        xProperty().set(value);
    }

    /**
     * Retrieves the x coordinate of the &lt;code&gt;MediaView&lt;/code&gt; origin.
     * @return the x coordinate of the origin of the view.
     */
    public final double getX() {
        return x == null ? 0.0 : x.get();
    }

    public final DoubleProperty xProperty() {
        if (x == null) {
            x = new DoublePropertyBase() {

                @Override
                protected void invalidated() {
                    if (HostUtils.isIOS()) {
                        updateOverlayX();
                    }
                    else {
                        NodeHelper.markDirty(MediaView.this, DirtyBits.NODE_GEOMETRY);
                        NodeHelper.geomChanged(MediaView.this);
                    }
                }

                @Override
                public Object getBean() {
                    return MediaView.this;
                }

                @Override
                public String getName() {
                    return &quot;x&quot;;
                }
            };
        }
        return x;
    }
    // PENDING_DOC_REVIEW
    /**
     * Defines the current y coordinate of the &lt;code&gt;MediaView&lt;/code&gt; origin.
     */
    private DoubleProperty y;

    /**
     * Sets the y coordinate of the &lt;code&gt;MediaView&lt;/code&gt; origin.
     * @param value the y coordinate of the origin of the view.
     */
    public final void setY(double value) {
        yProperty().set(value);
    }

    /**
     * Retrieves the y coordinate of the &lt;code&gt;MediaView&lt;/code&gt; origin.
     * @return the y coordinate of the origin of the view.
     */
    public final double getY() {
        return y == null ? 0.0 : y.get();
    }

    public final DoubleProperty yProperty() {
        if (y == null) {
            y = new DoublePropertyBase() {

                @Override
                protected void invalidated() {
                    if (HostUtils.isIOS()) {
                        updateOverlayY();
                    }
                    else {
                        NodeHelper.markDirty(MediaView.this, DirtyBits.NODE_GEOMETRY);
                        NodeHelper.geomChanged(MediaView.this);
                    }
                }

                @Override
                public Object getBean() {
                    return MediaView.this;
                }

                @Override
                public String getName() {
                    return &quot;y&quot;;
                }
            };
        }
        return y;
    }
    // PENDING_DOC_REVIEW
    /**
     * Determines the width of the bounding box within which the source media is
     * resized as necessary to fit. If &lt;code&gt;value &amp;le; 0&lt;/code&gt;, then the width
     * of the bounding box will be set to the natural width of the media, but
     * &lt;code&gt;fitWidth&lt;/code&gt; will be set to the supplied parameter, even if
     * non-positive.
     * &lt;p&gt;
     * See {@link #preserveRatioProperty preserveRatio} for information on interaction
     * between media views &lt;code&gt;fitWidth&lt;/code&gt;, &lt;code&gt;fitHeight&lt;/code&gt; and
     * &lt;code&gt;preserveRatio&lt;/code&gt; attributes.
     * &lt;/p&gt;
     */
    private DoubleProperty fitWidth;

    /**
     * Sets the width of the bounding box of the resized media.
     * @param value the width of the resized media.
     */
    public final void setFitWidth(double value) {
        fitWidthProperty().set(value);
    }

    /**
     * Retrieves the width of the bounding box of the resized media.
     * @return the height of the resized media.
     */
    public final double getFitWidth() {
        return fitWidth == null ? 0.0 : fitWidth.get();
    }

    public final DoubleProperty fitWidthProperty() {
        if (fitWidth == null) {
            fitWidth = new DoublePropertyBase() {

                @Override
                protected void invalidated() {
                    if (HostUtils.isIOS()) {
                        updateOverlayWidth();
                    }
                    else {
                        NodeHelper.markDirty(MediaView.this, DirtyBits.NODE_VIEWPORT);
                        NodeHelper.geomChanged(MediaView.this);
                    }
                }

                @Override
                public Object getBean() {
                    return MediaView.this;
                }

                @Override
                public String getName() {
                    return &quot;fitWidth&quot;;
                }
            };
        }
        return fitWidth;
    }
    // PENDING_DOC_REVIEW
    /**
     * Determines the height of the bounding box within which the source media is
     * resized as necessary to fit. If &lt;code&gt;value &amp;le; 0&lt;/code&gt;, then the height
     * of the bounding box will be set to the natural height of the media, but
     * &lt;code&gt;fitHeight&lt;/code&gt; will be set to the supplied parameter, even if
     * non-positive.
     * &lt;p&gt;
     * See {@link #preserveRatioProperty preserveRatio} for information on interaction
     * between media views &lt;code&gt;fitWidth&lt;/code&gt;, &lt;code&gt;fitHeight&lt;/code&gt; and
     * &lt;code&gt;preserveRatio&lt;/code&gt; attributes.
     * &lt;/p&gt;
     */
    private DoubleProperty fitHeight;

    /**
     * Sets the height of the bounding box of the resized media.
     * @param value the height of the resized media.
     */
    public final void setFitHeight(double value) {
        fitHeightProperty().set(value);
    };

    /**
     * Retrieves the height of the bounding box of the resized media.
     * @return the height of the resized media.
     */
    public final double getFitHeight() {
        return fitHeight == null ? 0.0 : fitHeight.get();
    }

    public final DoubleProperty fitHeightProperty() {
        if (fitHeight == null) {
            fitHeight = new DoublePropertyBase() {

                @Override
                protected void invalidated() {
                    if (HostUtils.isIOS()) {
                        updateOverlayHeight();
                    }
                    else {
                        NodeHelper.markDirty(MediaView.this, DirtyBits.NODE_VIEWPORT);
                        NodeHelper.geomChanged(MediaView.this);
                    }
                }

                @Override
                public Object getBean() {
                    return MediaView.this;
                }

                @Override
                public String getName() {
                    return &quot;fitHeight&quot;;
                }
            };
        }
        return fitHeight;
    }
    // PENDING_DOC_REVIEW
    /**
     * Specifies a rectangular viewport into the media frame.
     * The viewport is a rectangle specified in the coordinates of the media frame.
     * The resulting bounds prior to scaling will
     * be the size of the viewport. The displayed image will include the
     * intersection of the frame and the viewport. The viewport can exceed the
     * size of the frame, but only the intersection will be displayed.
     * Setting &lt;code&gt;viewport&lt;/code&gt; to null will clear the viewport.
     */
    private ObjectProperty&lt;Rectangle2D&gt; viewport;

    /**
     * Sets the rectangular viewport into the media frame.
     * @param value the rectangular viewport.
     */
    public final void setViewport(Rectangle2D value) {
        viewportProperty().set(value);
    };

    /**
     * Retrieves the rectangular viewport into the media frame.
     * @return the rectangular viewport.
     */
    public final Rectangle2D getViewport() {
        return viewport == null ? null : viewport.get();
    }

    public final ObjectProperty&lt;Rectangle2D&gt; viewportProperty() {
        if (viewport == null) {
            viewport = new ObjectPropertyBase&lt;Rectangle2D&gt;() {

                @Override
                protected void invalidated() {
                    NodeHelper.markDirty(MediaView.this, DirtyBits.NODE_VIEWPORT);
                    NodeHelper.geomChanged(MediaView.this);
                }

                @Override
                public Object getBean() {
                    return MediaView.this;
                }

                @Override
                public String getName() {
                    return &quot;viewport&quot;;
                }
            };
        }
        return viewport;
    }

    void notifyMediaChange() {
        MediaPlayer player = getMediaPlayer();
        if (player != null) {
            final NGMediaView peer = NodeHelper.getPeer(this);
            peer.setMediaProvider(player);
        }

        NodeHelper.markDirty(this, DirtyBits.MEDIAVIEW_MEDIA);
        NodeHelper.geomChanged(this);
    }

    void notifyMediaSizeChange() {
        NodeHelper.markDirty(this, DirtyBits.NODE_VIEWPORT);
        NodeHelper.geomChanged(this);
    }
<A NAME="7"></A>
    void notifyMediaFrameUpdated() {
        decodedFrameCount++;
        <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#7',2,'match46-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>NodeHelper.markDirty(this, DirtyBits.NODE_CONTENTS);
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private NGNode doCreatePeer() {
        NGMediaView peer = new NGMediaView();
        // this has to be done on the main toolkit thread...
        peer.setFrameTracker(new</B></FONT> MediaViewFrameTracker());
        return peer;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {

        // need to figure out the width/height to use for computing bounds
        Media media = (getMediaPlayer() == null) ? null : getMediaPlayer().getMedia();
        double w = media != null ? media.getWidth()  : 0; // if media is null, width will be 0
        double h = media != null ? media.getHeight() : 0; // if media is null, height will be 0
        double newW = getFitWidth();
        double newH = getFitHeight();
        final double vw = getViewport() != null ? getViewport().getWidth()  : 0; // if viewport is null, width will be 0
        final double vh = getViewport() != null ? getViewport().getHeight() : 0; // if viewport is null, height will be 0

        if (vw &gt; 0 &amp;&amp; vh &gt; 0) {
            w = vw;
            h = vh;
        }

        if (getFitWidth() &lt;= 0.0 &amp;&amp; getFitHeight() &lt;= 0.0) {
            newW = w;
            newH = h;
        } else if (isPreserveRatio()) {
            if (getFitWidth() &lt;= 0.0) {
                newW = h &gt; 0 ? w * (getFitHeight() / h) : 0.0F;
                newH = getFitHeight();
            } else if (getFitHeight() &lt;= 0.0) {
                newW = getFitWidth();
                newH = w &gt; 0 ? h * (getFitWidth() / w) : 0.0F;
            } else {
                if (w == 0.0) w = getFitWidth();
                if (h == 0.0) h = getFitHeight();
                double scale = Math.min(getFitWidth() / w, getFitHeight() / h);
                newW = w * scale;
                newH = h * scale;
            }
        } else if (getFitHeight() &lt;= 0.0) {
            newH = h;
        } else if (getFitWidth() &lt;= 0.0) {
            newW = w;
        }
        if (newH &lt; 1.0F) {
            newH = 1.0F;
        }
        if (newW &lt; 1.0F) {
            newW = 1.0F;
        }

        w = newW;
        h = newH;

        // if the w or h are non-positive, then there is no size
        // for the media view
        if (w &lt;= 0 || h &lt;= 0) {
            return bounds.makeEmpty();
        }
        bounds = bounds.deriveWithNewBounds((float)getX(), (float)getY(), 0.0f,
                (float)(getX()+w), (float)(getY()+h), 0.0f);
        bounds = tx.transform(bounds, bounds);
        return bounds;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeContains(double localX, double localY) {
        // Currently this is simply a local bounds test which is already tested
        // by the caller (Node.contains()).
        return true;
    }

    void updateViewport() {

        if (getMediaPlayer() == null) {
            return;
        }

        final NGMediaView peer = NodeHelper.getPeer(this);
        if (getViewport() != null) {
            peer.setViewport((float)getFitWidth(), (float)getFitHeight(),
                             (float)getViewport().getMinX(), (float)getViewport().getMinY(),
                             (float)getViewport().getWidth(), (float)getViewport().getHeight(),
                             isPreserveRatio());
        } else {
            peer.setViewport((float)getFitWidth(), (float)getFitHeight(),
                             0.0F, 0.0F, 0.0F, 0.0F,
                             isPreserveRatio());
        }
    }


    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        final NGMediaView peer = NodeHelper.getPeer(this);
        if (NodeHelper.isDirty(this, DirtyBits.NODE_GEOMETRY)) {
            peer.setX((float)getX());
            peer.setY((float)getY());
        }
        if (NodeHelper.isDirty(this, DirtyBits.NODE_SMOOTH)) {
            peer.setSmooth(isSmooth());
        }
        if (NodeHelper.isDirty(this, DirtyBits.NODE_VIEWPORT)) {
            updateViewport();
        }
        if (NodeHelper.isDirty(this, DirtyBits.NODE_CONTENTS)) {
            peer.renderNextFrame();
        }
        if (NodeHelper.isDirty(this, DirtyBits.MEDIAVIEW_MEDIA)) {
            MediaPlayer player = getMediaPlayer();
            if (player != null) {
                peer.setMediaProvider(player);
                updateViewport();
            } else {
                peer.setMediaProvider(null);
            }
        }
    }


    private int decodedFrameCount;
    private int renderedFrameCount;

    void perfReset() {
        decodedFrameCount = 0;
        renderedFrameCount = 0;
    }

    /**
     * @return number of frames that have been submitted for rendering
     */
    int perfGetDecodedFrameCount() {
        return decodedFrameCount;
    }

    /**
     * @return number of frames that have been rendered
     */
    int perfGetRenderedFrameCount() {
        return renderedFrameCount;
    }

    private class MediaViewFrameTracker implements MediaFrameTracker {
        @Override
        public void incrementDecodedFrameCount(int count) {
            decodedFrameCount += count;
        }

        @Override
        public void incrementRenderedFrameCount(int count) {
            renderedFrameCount += count;
        }
    }

    /**
     * Called by MediaPlayer when it becomes ready
     */
    void _mediaPlayerOnReady() {
        com.sun.media.jfxmedia.MediaPlayer jfxPlayer = getMediaPlayer().retrieveJfxPlayer();
        if (jfxPlayer != null) {
            if (decodedFrameRateListener != null &amp;&amp; registerVideoFrameRateListener) {
                jfxPlayer.getVideoRenderControl().addVideoFrameRateListener(decodedFrameRateListener);
                registerVideoFrameRateListener = false;
            }

            // Get media player overlay
            mediaPlayerOverlay = jfxPlayer.getMediaPlayerOverlay();
            if (mediaPlayerOverlay != null) {
                // Init media player overlay support
                createListeners();
                parentProperty().addListener(parentListener);
                NodeHelper.treeVisibleProperty(this).addListener(treeVisibleListener);
                opacityProperty().addListener(opacityListener);

                synchronized (this) {
                    updateMediaPlayerOverlay();
                }
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/Controller/TroChoiVietDemo.java</CENTER></H3><HR>
<PRE>
/*
  RMIT University Vietnam
  Course: INTE2512 Object-Oriented Programming
  Semester: 2019C
  Assessment: Assignment 2
  Author: Hoang Quoc Dai
  ID: s3426353
  Created  date: 15/12/2019
  Last modified: 16/12/2019
  Acknowledgement: If you use any resources, acknowledge here. Failure to do so will be considered as plagiarism.
*/
package sample.Controller;

import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.stage.Stage;
import sample.Sound.*;
import sample.View.*;
import java.util.*;
import javafx.animation.Interpolator;
import javafx.animation.RotateTransition;
import javafx.animation.SequentialTransition;
import javafx.scene.Node;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

public class TroChoiVietDemo extends Application {
    private int  matches;
    private Queue&lt;Card&gt; queue = new LinkedList&lt;&gt;();
    private Scene startScene;
    private Scene gameScene;
    private Scene endScene;
    private StartView startView;
    private GameView gameView;
    private EndView endView;
    private int timeLevel;
    private Stage primaryStage;
    private Sound sound;

    @Override
    public void start(Stage primaryStage){
        // Create stage
        setPrimaryStage(new Stage());
        // Add sound
        setSound(new Sound());
        //Create startView, set viewID, width, height and background by css file
        setStartView(new StartView());
        getStartView().setId(&quot;startScene&quot;);
        setStartScene(new Scene(getStartView(), 810, 960));
        getStartScene().getStylesheets().add(TroChoiVietDemo.class.getResource(&quot;style.css&quot;).toExternalForm());
        // Create EndScene, set viewID, width, height and background by css file
        setEndView(new EndView());
        getEndView().setId(&quot;endScene&quot;);
        setEndScene(new Scene(getEndView(), 710, 444));
        getEndScene().getStylesheets().add(TroChoiVietDemo.class.getResource(&quot;style.css&quot;).toExternalForm());
        //Set primaryStage firstly show startScene
        getPrimaryStage().setScene(getStartScene());
        getPrimaryStage().setTitle(&quot;Tro Choi Viet&quot;);
        getPrimaryStage().show();
        //


        // Set action for btLevel 1
        getStartView().getBtLevel1().setId(&quot;btLevel1&quot;);
        getStartView().getBtLevel1().setOnAction(getMyHandler());

        // Set action for btLevel 2
        getStartView().getBtLevel2().setId(&quot;btLevel2&quot;);
        getStartView().getBtLevel2().setOnAction(getMyHandler());

        // Set action for btLevel 3
        getStartView().getBtLevel3().setId(&quot;btLevel3&quot;);
        getStartView().getBtLevel3().setOnAction(getMyHandler());
        //
        getStartView().getBtSoundPlay().setId(&quot;play&quot;);
        getStartView().getBtSoundPlay().setOnAction(getMyHandler());
        //
        getStartView().getBtSoundPause().setId(&quot;pause&quot;);
        getStartView().getBtSoundPause().setOnAction(getMyHandler());

        // Set btQuit, btPlayAgain
        getEndView().getBtQuit().setId(&quot;btQuit&quot;);
        getEndView().getBtQuit().setOnAction(getMyHandler());
        getEndView().getBtPlayAgain().setId(&quot;btPlayAgain&quot;);
        getEndView().getBtPlayAgain().setOnAction(getMyHandler());
    }

    private EventHandler&lt;ActionEvent&gt; myHandler = new EventHandler&lt;ActionEvent&gt;() {
        @Override
        public void handle(ActionEvent event) {
            Button x = (Button) event.getSource();
            if (x.getId().equals(getEndView().getBtQuit().getId()))
                System.exit(0);
            else if (x.getId().equals(getEndView().getBtPlayAgain().getId()))
                getPrimaryStage().setScene(getStartScene());
            else if (x.getId().equals(getStartView().getBtLevel1().getId())) {
                setTimeLevel(3);
                setGameLevel();
            }
            else if (x.getId().equals(getStartView().getBtLevel2().getId())) {
                setTimeLevel(2);
                setGameLevel();
            }
            else if (x.getId().equals(getStartView().getBtLevel3().getId())) {
                setTimeLevel(1);
                setGameLevel();
            }
            else if (x.getId().equals(getStartView().getBtSoundPlay().getId()))
                getSound().playMusic();
            else if (x.getId().equals(getStartView().getBtSoundPause().getId()))
                getSound().pauseMusic();
        }
    };

    private void setGameLevel() {
        setGameView(new GameView());
        getGameView().setId(&quot;gameScene&quot;);
        setGameScene(new Scene(getGameView(), 1280, 720));
        getGameScene().getStylesheets().add(TroChoiVietDemo.class.getResource(&quot;style.css&quot;).toExternalForm());
        getPrimaryStage().setScene(getGameScene());
        setMatches(0);
        // if 10 matches -&gt; switch to endScene
        checkMatches();
        if (getMatches() ==  10) {
            getPrimaryStage().setScene(getEndScene()); }
    }

    private void checkMatches() {
        ArrayList&lt;Card&gt; cards = getGameView().getCards();
        for (Card card : cards){
            card.setOnMouseClicked(event -&gt; {
                getQueue().add(card);
                if(getQueue().size() &lt;= 2){
                    rotateCard(card);
                }
                if(getQueue().size() == 2){
                    Card card1 = getQueue().peek();
                    getQueue().remove();
                    Card card2 = getQueue().peek();
                    getQueue().remove();
                    //Check cardID by print out to the console
                    System.out.println(card1.getCardID());
                    System.out.println(card2.getCardID());
                    // If 2 cards are the same
                    if(card1.getCardID() == card2.getCardID()){
                        showFront2Cards(card1, card2);
                        setMatches(getMatches() + 1);
                        if (getMatches() ==  10) { getPrimaryStage().setScene(getEndScene()); }
                    }
                }
            });
        }
    }

    private void showFront2Cards(Card card1, Card card2) {
        card1.imageProperty().unbind();
        card1.setImage(card1.getFrontSide());
        card2.imageProperty().unbind();
        card2.setImage(card2.getFrontSide());
    }

    private void rotateCard(Card card) {
        RotateTransition rotator1 = createRotator(card);
        rotator1.setOnFinished(evt -&gt; {
            card.getIsFront().set(true);
        }); // When rotator1 completed, the status is true
        RotateTransition rotator2 = new RotateTransition(Duration.millis(getTimeLevel() * 1000), card);
        rotator2.setAxis(Rotate.Y_AXIS);
        rotator2.setFromAngle(0);
        rotator2.setToAngle(0);
        rotator2.setInterpolator(Interpolator.LINEAR);
        rotator2.setOnFinished(evt -&gt; {
            card.getIsFront().set(false);
        }); // When rotator2 completed, the status is false
        RotateTransition rotator3 = createRotator(card);
        SequentialTransition rotator = new SequentialTransition(card, rotator1, rotator2, rotator3);
<A NAME="23"></A>        rotator.play();
    }

    <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#23',2,'match46-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private RotateTransition createRotator(Node card) {
        // animation length proportional to the rotation angle
        RotateTransition rotator = new RotateTransition(Duration.millis(100), card);
        rotator.setAxis(Rotate.Y_AXIS);
        rotator.setFromAngle(0);
        rotator.setToAngle(180);
        rotator.setInterpolator(Interpolator.LINEAR);

        return rotator;
    }</B></FONT>

    private int getMatches() {
        return matches;
    }
    private void setMatches(int number) {
        this.matches = number;
    }

    private Queue&lt;Card&gt; getQueue() {
        return queue;
    }

    private void setQueue(Queue&lt;Card&gt; queue) {
        this.queue = queue;
    }

    private Scene getStartScene() {
        return startScene;
    }
    private void setStartScene(Scene startScene) {
        this.startScene = startScene;
    }

    private int getTimeLevel() {
        return timeLevel;
    }

    private void setTimeLevel(int time) {
        this.timeLevel = time;
    }

    private StartView getStartView() {
        return startView;
    }

    private void setStartView(StartView startView) {
        this.startView = startView;
    }

    private Scene getGameScene() {
        return gameScene;
    }

    private void setGameScene(Scene gameScene) {
        this.gameScene = gameScene;
    }

    private Scene getEndScene() {
        return endScene;
    }

    private void setEndScene(Scene endScene) {
        this.endScene = endScene;
    }

    private GameView getGameView() {
        return gameView;
    }

    private void setGameView(GameView gameView) {
        this.gameView = gameView;
    }

    private EndView getEndView() {
        return endView;
    }

    private void setEndView(EndView endView) {
        this.endView = endView;
    }

    private Stage getPrimaryStage() {
        return primaryStage;
    }

    private void setPrimaryStage(Stage primaryStage) {
        this.primaryStage = primaryStage;
    }

    private EventHandler&lt;ActionEvent&gt; getMyHandler() {
        return myHandler;
    }

    public void setSound(Sound sound) {
        this.sound = sound;
    }

    public Sound getSound() {
        return sound;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/View/Card.java</CENTER></H3><HR>
<PRE>
/*
  RMIT University Vietnam
  Course: INTE2512 Object-Oriented Programming
  Semester: 2019C
  Assessment: Assignment 2
  Author: Hoang Quoc Dai
  ID: s3426353
  Created  date: 14/12/2019
  Last modified: 16/12/2019
  Acknowledgement: If you use any resources, acknowledge here. Failure to do so will be considered as plagiarism.
*/
package sample.View;

import javafx.beans.binding.Bindings;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;

public class Card extends ImageView{
    private int cardID;
    private Image frontSide;
    private Image backSide;
    private BooleanProperty isFront = new SimpleBooleanProperty(false);
    private boolean isFrontOn = false;


    public Card(String url) {

        cardID = Integer.parseInt(url.substring(7,8));
        frontSide = new Image(Card.class.getResourceAsStream(url));
        backSide = new Image(Card.class.getResourceAsStream(&quot;Images/PhotoBehindCard.jpg&quot;));
        this.setImage(backSide);

//         show front/back depending on value of the showFront property
        this.imageProperty().bind(Bindings.when(isFront).then(frontSide).otherwise(backSide));
//         mirror image, when backside is shown to prevent wrong orientation
        this.scaleXProperty().bind(Bindings.when(isFront).then(1d).otherwise(-1d));
    }

    public int getCardID() {
        return cardID;
    }

    public Image getBackSide() {
<A NAME="52"></A>        return backSide;
    }

    public Image getFrontSide() <FONT color="#2b60de"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#52',2,'match46-top.html#52',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        return frontSide;
    }

    public BooleanProperty getIsFront() {
        return isFront;
    }

}</B></FONT>
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/View/GameView.java</CENTER></H3><HR>
<PRE>
/*
  RMIT University Vietnam
  Course: INTE2512 Object-Oriented Programming
  Semester: 2019C
  Assessment: Assignment 2
  Author: Hoang Quoc Dai
  ID: s3426353
  Created  date: 15/12/2019
  Last modified: 16/12/2019
  Acknowledgement: If you use any resources, acknowledge here. Failure to do so will be considered as plagiarism.
*/
package sample.View;

import javafx.geometry.Pos;
import javafx.scene.image.Image;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontPosture;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import java.util.ArrayList;
import java.util.Random;
import java.util.Timer;
import java.util.TimerTask;

public class GameView extends VBox{
    int[] cardIndices = { 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10};
    ArrayList &lt;Card&gt; cards = new ArrayList&lt;&gt;();
    private GridPane matrixCards;
    private TimeBar timeBar;
    private Image image;
    private Text timeDisplay;
    private Timer timer;
    private int min = 1;
    private int sec = 59;
    private int milliSec = 99;
    private int totalFront;

    public GameView() {
        setSpacing(20);
        setAlignment(Pos.CENTER_RIGHT);

        matrixCards = new GridPane();
        String prefix = &quot;Images/&quot;;
        String postfix = &quot;.jpg&quot;;
        shuffleCards();
        for (int col = 1; col &lt;= 5; col++) {
            for (int row = 1; row &lt;= 4; row++) {
                String cardID = Integer.toString(cardIndices[row - 1 + 4*(col-1)]);
                Card temp = new Card(prefix + cardID + postfix);
                matrixCards.add(temp, col, row);
                cards.add(temp);
            }
        }
        setTimeBar(new TimeBar());
        getChildren().addAll(matrixCards, getTimeBar());

        //Set timeDisplay
        setTimeDisplay(new Text(&quot;Time: 00:00:00&quot;));
        getTimeDisplay().setFill(Color.YELLOW);
        getTimeDisplay().setFont(Font.font(&quot;Courier&quot;, FontWeight.BOLD, FontPosture.REGULAR, 15));
        getChildren().add(getTimeDisplay());
        timerProcess(); //Set timer
    }

<A NAME="46"></A>    //For Card
    public void shuffleCards() {
        Random rand = new Random();
        <FONT color="#92c7c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#46',2,'match46-top.html#46',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>for (int i = 0; i &lt; cardIndices.length; i++) {
            int randomIndexToSwap = rand.nextInt(cardIndices.length);
            int temp = cardIndices[randomIndexToSwap];
            cardIndices[randomIndexToSwap] = cardIndices[i];
            cardIndices[i] = temp;
        }
    }
    //For timer
    private void timerProcess() {</B></FONT>

        setTotalFront(0);
        int delay = 40;
        int period = 40;
        setTimer(new Timer());
        getTimer().scheduleAtFixedRate(new TimerTask() {
            public void run() {
                getTimeDisplay().setText(&quot;Time: &quot;+ showCountDown());
            }
        }, delay, period);
    }

    //For timer
    private String showCountDown() {
        setMilliSec(getMilliSec() -4);
        if (getMilliSec() &lt; 0){
            setMilliSec(99);
            setSec(getSec() - 1);
        }
        if (getSec() == 0){
            setSec(59);
            setMin(getMin() - 1);
        }
        if (getMin() &lt; 0) {
            getTimer().cancel();
            return &quot;00:00:00&quot;;
        };
        if (getTotalFront() == 20){
            getTimer().cancel();
        }
        return &quot;0&quot;+Integer.toString(getMin())+&quot;:&quot;+Integer.toString(getSec()/10)+Integer.toString(getSec()%10)+&quot;:&quot;+Integer.toString(getMilliSec());
    }

    private TimeBar getTimeBar() {
        return timeBar;
    }

    private void setTimeBar(TimeBar timeBar) {
        this.timeBar = timeBar;
    }

    private Image getImage() {
        return image;
    }

    private void setImage(Image image) {
        this.image = image;
    }

    public ArrayList&lt;Card&gt; getCards() {
        return cards;
    }

    private Text getTimeDisplay() {
        return timeDisplay;
    }

    private void setTimeDisplay(Text timeDisplay) {
        this.timeDisplay = timeDisplay;
    }

    private Timer getTimer() {
        return timer;
    }

    private void setTimer(Timer timer) {
        this.timer = timer;
    }

    private int getMin() {
        return min;
    }

    private void setMin(int min) {
        this.min = min;
    }

    private int getSec() {
        return sec;
    }

    private void setSec(int sec) {
        this.sec = sec;
    }

    private int getMilliSec() {
        return milliSec;
    }

    private void setMilliSec(int milliSec) {
        this.milliSec = milliSec;
    }

    private int getTotalFront() {
        return totalFront;
    }

    private void setTotalFront(int totalFront) {
        this.totalFront = totalFront;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/View/StartView.java</CENTER></H3><HR>
<PRE>
/*
  RMIT University Vietnam
  Course: INTE2512 Object-Oriented Programming
  Semester: 2019C
  Assessment: Assignment 2
  Author: Hoang Quoc Dai
  ID: s3426353
  Created  date: 15/12/2019
<A NAME="26"></A>  Last modified: 16/12/2019
  Acknowledgement: If you use any resources, acknowledge here. Failure to do so will be considered as plagiarism.
*/
<FONT color="#95b9c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#26',2,'match46-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package sample.View;

import javafx.geometry.Pos;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;


public class StartView extends VBox {
    private Button btLevel1;
    private Button btLevel2;
    private Button btLevel3;
    private Button btSoundPlay;
    private Button btSoundPause;
    private Label message;
    private Label message1;

    public StartView() {</B></FONT>
        // Create a vBox
        HBox hBox = new HBox();
        hBox.setSpacing(10);
        hBox.setAlignment(Pos.CENTER);
        // Set name for buttons and message label
        setBtLevel1(new Button(&quot;Level 1&quot;));
        setBtLevel2(new Button(&quot;Level 2&quot;));
        setBtLevel3(new Button(&quot;Level 3&quot;));
        setBtSoundPlay(new Button(&quot;Music On&quot;));
        setBtSoundPause(new Button(&quot;Music Pause&quot;));
        setMessage(new Label(&quot;Hello, QUOC DAI ! &quot;));
        setMessage1(new Label(&quot;PLEASE CHOOSE THE LEVEL TO START !&quot;));
        //Set Front, Size, Color for Message
        getMessage().setFont(new Font(&quot;Arial&quot;, 40));
        getMessage().setTextFill(Color.WHITE);
        //Set Front, Size, Color for Message1
        getMessage1().setFont(new Font(&quot;Arial&quot;, 40));
        getMessage1().setTextFill(Color.WHITE);
        // add 4 buttons to hBox
        hBox.getChildren().addAll(getBtLevel1(), getBtLevel2(), getBtLevel3(), getBtSoundPlay(), getBtSoundPause());

        setAlignment(Pos.CENTER);
        setSpacing(10);

        // add hBox and label to vBox
        getChildren().addAll(getMessage(), getMessage1(),hBox);
    }

    public Button getBtLevel1() {
        return btLevel1;
    }

    public Button getBtLevel2() {
        return btLevel2;
    }
<A NAME="51"></A>
    public Button getBtLevel3() {
        return btLevel3;
    <FONT color="#b38481"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#51',2,'match46-top.html#51',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    private void setBtLevel1(Button btLevel1) {
        this.btLevel1 = btLevel1;
    }

    private void setBtLevel2(Button btLevel2) {
        this.btLevel2 = btLevel2;
    }

    private void setBtLevel3(Button btLevel3) {
        this.btLevel3 = btLevel3;
    }

    private Label getMessage() {
        return message;
    }

    private vo</B></FONT>id setMessage(Label message) {
        this.message = message;
    }

    private Label getMessage1() {
        return message1;
    }

    private void setMessage1(Label message1) {
        this.message1 = message1;
    }

    public Button getBtSoundPlay() {
        return btSoundPlay;
    }

    private void setBtSoundPlay(Button btSoundPlay) {
        this.btSoundPlay = btSoundPlay;
    }

    public Button getBtSoundPause() {
        return btSoundPause;
    }

    private void setBtSoundPause(Button btSoundPause) {
        this.btSoundPause = btSoundPause;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/View/TimeBar.java</CENTER></H3><HR>
<PRE>
package sample.View;

import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;


public class TimeBar extends AnchorPane{
    private Timeline timeline;
<A NAME="31"></A>
    public TimeBar() {
        //Create rectangle
        Rectangle rectangle = <FONT color="#3ea99f"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match46-0.html#31',2,'match46-top.html#31',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new Rectangle(1280, 30);
        rectangle.setFill(Color.YELLOW);
        // Create pane and add rectangle to it
        Pane pane = new Pane();
        pane.getChildren().add(rectangle);
        pane.setStyle(&quot;-fx-background-color: white;&quot;);
        AnchorPane.setTopAnchor(pane, 0.0);
        AnchorPane.setLeftAnchor</B></FONT>(pane, 0.0);
        AnchorPane.setRightAnchor(pane, 0.0);
        AnchorPane.setBottomAnchor(pane,0.0);
        getChildren().addAll(pane);
        // Create Timeline animation
        double paneWidth = pane.getWidth(); //
        double rectangleWidth = rectangle.getLayoutBounds().getWidth();
        KeyValue initKeyValue1 = new KeyValue(rectangle.translateXProperty(), paneWidth);
        KeyValue initKeyValue2 = new KeyValue(rectangle.scaleXProperty(), 1.0);
        KeyFrame initFrame = new KeyFrame(Duration.ZERO, initKeyValue1, initKeyValue2);
        KeyValue endKeyValue1 = new KeyValue(rectangle.translateXProperty(), -1.0 * rectangleWidth);
        KeyValue endKeyValue2 = new KeyValue(rectangle.scaleXProperty(), 0.2);
        KeyFrame endFrame = new KeyFrame(Duration.minutes(2), endKeyValue1, endKeyValue2);
        setTimeline(new Timeline(25 , initFrame, endFrame));
        getTimeline().setCycleCount(1);
        getTimeline().setRate(1);
        getTimeline().setAutoReverse(false);
        getTimeline().play();
    }

    private Timeline getTimeline() {
        return timeline;
    }

    private void setTimeline(Timeline timeline) {
        this.timeline = timeline;
    }
}
</PRE>

</BODY>
</HTML>
