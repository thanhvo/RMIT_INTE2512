<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>daihoangquoc_</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.base/javafx/beans/property/ReadOnlyMapPropertyBase.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.beans.property;

import com.sun.javafx.binding.MapExpressionHelper;
import javafx.beans.InvalidationListener;
import javafx.beans.value.ChangeListener;
import javafx.collections.MapChangeListener;
import javafx.collections.ObservableMap;

/**
 * Base class for all readonly properties wrapping an {@link javafx.collections.ObservableMap}.
 * This class provides a default implementation to attach listener.
 *
 * @see ReadOnlyMapProperty
 * @since JavaFX 2.1
 */
public abstract class ReadOnlyMapPropertyBase&lt;K, V&gt; extends ReadOnlyMapProperty&lt;K, V&gt; {

    private MapExpressionHelper&lt;K, V&gt; helper;

    @Override
    public void addListener(InvalidationListener listener) {
        helper = MapExpressionHelper.addListener(helper, this, listener);
    }

    @Override
    public void removeListener(InvalidationListener listener) {
        helper = MapExpressionHelper.removeListener(helper, listener);
    }

    @Override
    public void addListener(ChangeListener&lt;? super ObservableMap&lt;K, V&gt;&gt; listener) {
        helper = MapExpressionHelper.addListener(helper, this, listener);
    }

    @Override
    public void removeListener(ChangeListener&lt;? super ObservableMap&lt;K, V&gt;&gt; listener) {
        helper = MapExpressionHelper.removeListener(helper, listener);
    }

    @Override
    public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
        helper = MapExpressionHelper.addListener(helper, this, listener);
    }

    @Override
    public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
        helper = MapExpressionHelper.removeListener(helper, listener);
    }

    /**
     * This method needs to be called if the reference to the
     * {@link javafx.collections.ObservableList} changes.
     *
     * It sends notifications to all attached
     * {@link javafx.beans.InvalidationListener InvalidationListeners},
     * {@link javafx.beans.value.ChangeListener ChangeListeners}, and
     * {@link javafx.collections.ListChangeListener}.
     *
<A NAME="1"></A>     * This method needs to be called, if the value of this property changes.
     */
    protected void fireValueChangedEvent() {
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#1',2,'match51-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>MapExpressionHelper.fireValueChangedEvent(helper);
    }

    /**
     * This method needs to be called if the content of the referenced
     * {@link javafx.collections.ObservableList} changes.
     *
     * Sends notifications to all attached
     * {@link javafx.beans.InvalidationListener InvalidationListeners},
     * {@link javafx.beans.value.ChangeListener ChangeListeners}, and
     * {@link javafx.collections.ListChangeListener}.
     *
     * This method is called when the content of the list changes.
     *
     * @param change the change that needs to be propagated
     */
    protected void fireValueChangedEvent(MapChangeListener.Change&lt;? extends K, ? extends V&gt; change) {
        MapExpressionHelper.fireValueChangedEvent(helper, change);
    }



}</B></FONT>
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.base/javafx/collections/FXCollections.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.collections;

import com.sun.javafx.collections.ListListenerHelper;
import com.sun.javafx.collections.MapListenerHelper;
import com.sun.javafx.collections.SetListenerHelper;
import java.lang.reflect.Array;
import java.util.AbstractList;
import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Random;
import java.util.Set;

import javafx.beans.InvalidationListener;

import com.sun.javafx.collections.ObservableListWrapper;
import com.sun.javafx.collections.ObservableMapWrapper;
import com.sun.javafx.collections.ObservableSetWrapper;
import com.sun.javafx.collections.MapAdapterChange;
import com.sun.javafx.collections.ObservableFloatArrayImpl;
import com.sun.javafx.collections.ObservableIntegerArrayImpl;
import com.sun.javafx.collections.ObservableSequentialListWrapper;
import com.sun.javafx.collections.SetAdapterChange;
import com.sun.javafx.collections.SortableList;
import com.sun.javafx.collections.SourceAdapterChange;
import java.util.RandomAccess;
import javafx.beans.Observable;
import javafx.collections.ListChangeListener.Change;
import javafx.util.Callback;

/**
 * Utility class that consists of static methods that are 1:1 copies of java.util.Collections methods.
 * &lt;br&gt;&lt;br&gt;
 * The wrapper methods (like synchronizedObservableList or emptyObservableList) has exactly the same
 * functionality as the methods in Collections, with exception that they return ObservableList and are
 * therefore suitable for methods that require ObservableList on input.
 * &lt;br&gt;&lt;br&gt;
 * The utility methods are here mainly for performance reasons. All methods are optimized in a way that
 * they yield only limited number of notifications. On the other hand, java.util.Collections methods
 * might call &quot;modification methods&quot; on an ObservableList multiple times, resulting in a number of notifications.
 *
 * @since JavaFX 2.0
 */
public class FXCollections {
    /** Not to be instantiated. */
    private FXCollections() { }

    /**
     * Constructs an ObservableList that is backed by the specified list.
     * Mutation operations on the ObservableList instance will be reported
     * to observers that have registered on that instance.&lt;br&gt;
     * Note that mutation operations made directly to the underlying list are
     * &lt;em&gt;not&lt;/em&gt; reported to observers of any ObservableList that
     * wraps it.
     *
     * @param &lt;E&gt; The type of List to be wrapped
     * @param list a concrete List that backs this ObservableList
     * @return a newly created ObservableList
     */
    public static &lt;E&gt; ObservableList&lt;E&gt; observableList(List&lt;E&gt; list) {
        if (list == null) {
            throw new NullPointerException();
        }
        return list instanceof RandomAccess ? new ObservableListWrapper&lt;E&gt;(list) :
                new ObservableSequentialListWrapper&lt;E&gt;(list);
    }

    /**
     * Constructs an ObservableList that is backed by the specified list.
     * Mutation operations on the ObservableList instance will be reported
     * to observers that have registered on that instance.&lt;br&gt;
     * Note that mutation operations made directly to the underlying list are
     * &lt;em&gt;not&lt;/em&gt; reported to observers of any ObservableList that
     * wraps it.
     * &lt;br&gt;
     * This list also reports mutations of the elements in it by using &lt;code&gt;extractor&lt;/code&gt;.
     * Observable objects returned by extractor (applied to each list element) are listened for changes
     * and transformed into &quot;update&quot; change of ListChangeListener.
     *
     * @param &lt;E&gt; The type of List to be wrapped
     * @param list a concrete List that backs this ObservableList
     * @param extractor element to Observable[] convertor
     * @since JavaFX 2.1
     * @return a newly created ObservableList
     */
    public static &lt;E&gt; ObservableList&lt;E&gt; observableList(List&lt;E&gt; list, Callback&lt;E, Observable[]&gt; extractor) {
        if (list == null || extractor == null) {
            throw new NullPointerException();
        }
        return list instanceof RandomAccess ? new ObservableListWrapper&lt;E&gt;(list, extractor) :
            new ObservableSequentialListWrapper&lt;E&gt;(list, extractor);
    }

    /**
     * Constructs an ObservableMap that is backed by the specified map.
     * Mutation operations on the ObservableMap instance will be reported
     * to observers that have registered on that instance.&lt;br&gt;
     * Note that mutation operations made directly to the underlying map are &lt;em&gt;not&lt;/em&gt;
     * reported to observers of any ObservableMap that wraps it.
     * @param &lt;K&gt; the type of the wrapped key
     * @param &lt;V&gt; the type of the wrapped value
     * @param map a Map that backs this ObservableMap
     * @return a newly created ObservableMap
     */
    public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; observableMap(Map&lt;K, V&gt; map) {
        if (map == null) {
            throw new NullPointerException();
        }
        return new ObservableMapWrapper&lt;K, V&gt;(map);
    }

    /**
     * Constructs an ObservableSet that is backed by the specified set.
     * Mutation operations on the ObservableSet instance will be reported
     * to observers that have registered on that instance.&lt;br&gt;
     * Note that mutation operations made directly to the underlying set are &lt;em&gt;not&lt;/em&gt;
     * reported to observers of any ObservableSet that wraps it.
     * @param &lt;E&gt; The type of List to be wrapped
     * @param set a Set that backs this ObservableSet
     * @return a newly created ObservableSet
     * @since JavaFX 2.1
     */
    public static &lt;E&gt; ObservableSet&lt;E&gt; observableSet(Set&lt;E&gt; set) {
        if (set == null) {
            throw new NullPointerException();
        }
        return new ObservableSetWrapper&lt;E&gt;(set);
    }

    /**
     * Constructs an ObservableSet backed by a HashSet
     * that contains all the specified elements.
     * @param &lt;E&gt; The type of List to be wrapped
     * @param elements elements that will be added into returned ObservableSet
     * @return a newly created ObservableSet
     * @since JavaFX 2.1
     */
    public static &lt;E&gt; ObservableSet&lt;E&gt; observableSet(E... elements) {
        if (elements == null) {
            throw new NullPointerException();
        }
        Set&lt;E&gt; set = new HashSet&lt;E&gt;(elements.length);
        Collections.addAll(set, elements);
        return new ObservableSetWrapper&lt;E&gt;(set);
    }

    /**
     * Constructs a read-only interface to the specified ObservableMap. Only
     * mutation operations made to the underlying ObservableMap will be reported
     * to observers that have registered on the unmodifiable instance. This allows
     * clients to track changes in a Map but disallows the ability to modify it.
     * @param &lt;K&gt; the type of the wrapped key
     * @param &lt;V&gt; the type of the wrapped value
     * @param map an ObservableMap that is to be monitored by this interface
     * @return a newly created UnmodifiableObservableMap
     */
    public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; unmodifiableObservableMap(ObservableMap&lt;K, V&gt; map) {
        if (map == null) {
            throw new NullPointerException();
        }
        return new com.sun.javafx.collections.UnmodifiableObservableMap&lt;K, V&gt;(map);
    }

    /**
     * Creates and returns a typesafe wrapper on top of provided observable map.
     * @param &lt;K&gt; the type of the wrapped key
     * @param &lt;V&gt; the type of the wrapped value
     * @param map an Observable map to be wrapped
     * @param keyType the type of key that {@code map} is permitted to hold
     * @param valueType the type of value that {@code map} is permitted to hold
     * @return a dynamically typesafe view of the specified map
     * @see Collections#checkedMap(java.util.Map, java.lang.Class, java.lang.Class)
     * @since JavaFX 8.0
     */
    public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; checkedObservableMap(ObservableMap&lt;K, V&gt; map, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
        if (map == null || keyType == null || valueType == null) {
            throw new NullPointerException();
        }
        return new CheckedObservableMap&lt;K, V&gt;(map, keyType, valueType);
    }

    /**
     * Creates and returns a synchronized wrapper on top of provided observable map.
     * @param &lt;K&gt; the type of the wrapped key
     * @param &lt;V&gt; the type of the wrapped value
     * @param  map the map to be &quot;wrapped&quot; in a synchronized map.
     * @return A synchronized version of the observable map
     * @see Collections#synchronizedMap(java.util.Map)
     * @since JavaFX 8.0
     */
    public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; synchronizedObservableMap(ObservableMap&lt;K, V&gt; map) {
        if (map == null) {
            throw new NullPointerException();
        }
        return new SynchronizedObservableMap&lt;K, V&gt;(map);
    }

    private static ObservableMap EMPTY_OBSERVABLE_MAP = new EmptyObservableMap();

    /**
     * Creates an empty unmodifiable observable map.
     * @param &lt;K&gt; the type of the wrapped key
     * @param &lt;V&gt; the type of the wrapped value
     * @return An empty unmodifiable observable map
     * @see Collections#emptyMap()
     * @since JavaFX 8.0
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;K, V&gt; ObservableMap&lt;K, V&gt; emptyObservableMap() {
        return EMPTY_OBSERVABLE_MAP;
    }

    /**
     * Creates a new empty observable integer array.
     * @return a newly created ObservableIntegerArray
     * @since JavaFX 8.0
     */
    public static ObservableIntegerArray observableIntegerArray() {
        return new ObservableIntegerArrayImpl();
    }

    /**
     * Creates a new observable integer array with {@code values} set to it.
     * @param values the values that will be in the new observable integer array
     * @return a newly created ObservableIntegerArray
     * @since JavaFX 8.0
     */
    public static ObservableIntegerArray observableIntegerArray(int... values) {
        return new ObservableIntegerArrayImpl(values);
    }

    /**
     * Creates a new observable integer array with copy of elements in given
     * {@code array}.
     * @param array observable integer array to copy
     * @return a newly created ObservableIntegerArray
     * @since JavaFX 8.0
     */
    public static ObservableIntegerArray observableIntegerArray(ObservableIntegerArray array) {
        return new ObservableIntegerArrayImpl(array);
    }

    /**
     * Creates a new empty observable float array.
     * @return a newly created ObservableFloatArray
     * @since JavaFX 8.0
     */
    public static ObservableFloatArray observableFloatArray() {
        return new ObservableFloatArrayImpl();
    }

    /**
     * Creates a new observable float array with {@code values} set to it.
     * @param values the values that will be in the new observable float array
     * @return a newly created ObservableFloatArray
     * @since JavaFX 8.0
     */
    public static ObservableFloatArray observableFloatArray(float... values) {
        return new ObservableFloatArrayImpl(values);
    }

    /**
     * Creates a new observable float array with copy of elements in given
     * {@code array}.
     * @param array observable float array to copy
     * @return a newly created ObservableFloatArray
     * @since JavaFX 8.0
     */
    public static ObservableFloatArray observableFloatArray(ObservableFloatArray array) {
        return new ObservableFloatArrayImpl(array);
    }

    /**
     * Creates a new empty observable list that is backed by an arraylist.
     * @see #observableList(java.util.List)
     * @param &lt;E&gt; The type of List to be wrapped
     * @return a newly created ObservableList
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList() {
        return observableList(new ArrayList());
    }

    /**
     * Creates a new empty observable list backed by an arraylist.
     *
     * This list reports element updates.
     * @param &lt;E&gt; The type of List to be wrapped
     * @param extractor element to Observable[] convertor. Observable objects are listened for changes on the element.
     * @see #observableList(java.util.List, javafx.util.Callback)
     * @since JavaFX 2.1
     * @return a newly created ObservableList
     */
    public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList(Callback&lt;E, Observable[]&gt; extractor) {
        return observableList(new ArrayList(), extractor);
    }

    /**
     * Creates a new observable array list with {@code items} added to it.
     * @param &lt;E&gt; The type of List to be wrapped
     * @param items the items that will be in the new observable ArrayList
     * @return a newly created observableArrayList
     * @see #observableArrayList()
     */
    public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList(E... items) {
        ObservableList&lt;E&gt; list = observableArrayList();
        list.addAll(items);
        return list;
    }

    /**
     * Creates a new observable array list and adds a content of collection {@code col}
     * to it.
     * @param &lt;E&gt; The type of List to be wrapped
     * @param col a collection which content should be added to the observableArrayList
     * @return a newly created observableArrayList
     */
    public static &lt;E&gt; ObservableList&lt;E&gt; observableArrayList(Collection&lt;? extends E&gt; col) {
        ObservableList&lt;E&gt; list = observableArrayList();
        list.addAll(col);
        return list;
    }

    /**
     * Creates a new empty observable map that is backed by a HashMap.
     * @param &lt;K&gt; the type of the wrapped key
     * @param &lt;V&gt; the type of the wrapped value
     * @return a newly created observable HashMap
     */
    public static &lt;K,V&gt; ObservableMap&lt;K,V&gt; observableHashMap() {
        return observableMap(new HashMap&lt;K, V&gt;());
    }

    /**
     * Concatenates more observable lists into one. The resulting list
     * would be backed by an arraylist.
     * @param &lt;E&gt; The type of List to be wrapped
     * @param lists lists to concatenate
     * @return new observable array list concatenated from the arguments
     */
    public static &lt;E&gt; ObservableList&lt;E&gt; concat(ObservableList&lt;E&gt;... lists) {
        if (lists.length == 0 ) {
            return observableArrayList();
        }
        if (lists.length == 1) {
            return observableArrayList(lists[0]);
        }
        ArrayList&lt;E&gt; backingList = new ArrayList&lt;E&gt;();
        for (ObservableList&lt;E&gt; s : lists) {
            backingList.addAll(s);
        }

        return observableList(backingList);
    }

    /**
     * Creates and returns unmodifiable wrapper list on top of provided observable list.
     * @param list  an ObservableList that is to be wrapped
     * @param &lt;E&gt; The type of List to be wrapped
     * @return an ObserableList wrapper that is unmodifiable
     * @see Collections#unmodifiableList(java.util.List)
     */
    public static&lt;E&gt; ObservableList&lt;E&gt; unmodifiableObservableList(ObservableList&lt;E&gt; list) {
        if (list == null) {
            throw new NullPointerException();
        }
        return new UnmodifiableObservableListImpl&lt;E&gt;(list);
    }

    /**
     * Creates and returns a typesafe wrapper on top of provided observable list.
     * @param &lt;E&gt; The type of List to be wrapped
     * @param list  an Observable list to be wrapped
     * @param type   the type of element that {@code list} is permitted to hold
     * @return a dynamically typesafe view of the specified list
     * @see Collections#checkedList(java.util.List, java.lang.Class)
     */
    public static&lt;E&gt; ObservableList&lt;E&gt; checkedObservableList(ObservableList&lt;E&gt; list, Class&lt;E&gt; type) {
        if (list == null) {
            throw new NullPointerException();
        }
        return new CheckedObservableList&lt;E&gt;(list, type);
    }

    /**
     * Creates and returns a synchronized wrapper on top of provided observable list.
     * @param &lt;E&gt; The type of List to be wrapped
     * @param  list the list to be &quot;wrapped&quot; in a synchronized list.
     * @return A synchronized version of the observable list
     * @see Collections#synchronizedList(java.util.List)
     */
    public static&lt;E&gt; ObservableList&lt;E&gt; synchronizedObservableList(ObservableList&lt;E&gt; list) {
        if (list == null) {
            throw new NullPointerException();
        }
        return new SynchronizedObservableList&lt;E&gt;(list);
    }

    private static ObservableList EMPTY_OBSERVABLE_LIST = new EmptyObservableList();


    /**
     * Creates an empty unmodifiable observable list.
     * @param &lt;E&gt; The type of List to be wrapped
     * @return An empty unmodifiable observable list
     * @see Collections#emptyList()
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static&lt;E&gt; ObservableList&lt;E&gt; emptyObservableList() {
        return EMPTY_OBSERVABLE_LIST;
    }

    /**
     * Creates an unmodifiable observable list with single element.
     * @param &lt;E&gt; The type of List to be wrapped
     * @param e the only elements that will be contained in this singleton observable list
     * @return a singleton observable list
     * @see Collections#singletonList(java.lang.Object)
     */
    public static&lt;E&gt; ObservableList&lt;E&gt; singletonObservableList(E e) {
        return new SingletonObservableList&lt;E&gt;(e);
    }

    /**
     * Creates and returns unmodifiable wrapper on top of provided observable set.
     * @param &lt;E&gt; The type of List to be wrapped
     * @param set an ObservableSet that is to be wrapped
     * @return an ObserableSet wrapper that is unmodifiable
     * @see Collections#unmodifiableSet(java.util.Set)
     * @since JavaFX 8.0
     */
    public static&lt;E&gt; ObservableSet&lt;E&gt; unmodifiableObservableSet(ObservableSet&lt;E&gt; set) {
        if (set == null) {
            throw new NullPointerException();
        }
        return new UnmodifiableObservableSet&lt;E&gt;(set);
    }

    /**
     * Creates and returns a typesafe wrapper on top of provided observable set.
     * @param &lt;E&gt; The type of List to be wrapped
     * @param set an Observable set to be wrapped
     * @param type  the type of element that {@code set} is permitted to hold
     * @return a dynamically typesafe view of the specified set
     * @see Collections#checkedSet(java.util.Set, java.lang.Class)
     * @since JavaFX 8.0
     */
    public static&lt;E&gt; ObservableSet&lt;E&gt; checkedObservableSet(ObservableSet&lt;E&gt; set, Class&lt;E&gt; type) {
        if (set == null) {
            throw new NullPointerException();
        }
        return new CheckedObservableSet&lt;E&gt;(set, type);
    }

    /**
     * Creates and returns a synchronized wrapper on top of provided observable set.
     * @param &lt;E&gt; The type of List to be wrapped
     * @param  set the set to be &quot;wrapped&quot; in a synchronized set.
     * @return A synchronized version of the observable set
     * @see Collections#synchronizedSet(java.util.Set)
     * @since JavaFX 8.0
     */
    public static&lt;E&gt; ObservableSet&lt;E&gt; synchronizedObservableSet(ObservableSet&lt;E&gt; set) {
        if (set == null) {
            throw new NullPointerException();
        }
        return new SynchronizedObservableSet&lt;E&gt;(set);
    }

    private static ObservableSet EMPTY_OBSERVABLE_SET = new EmptyObservableSet();

    /**
     * Creates an empty unmodifiable observable set.
     * @param &lt;E&gt; The type of List to be wrapped
     * @return An empty unmodifiable observable set
     * @see Collections#emptySet()
     * @since JavaFX 8.0
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static&lt;E&gt; ObservableSet&lt;E&gt; emptyObservableSet() {
        return EMPTY_OBSERVABLE_SET;
    }

    /**
     * Copies elements from src to dest. Fires only &lt;b&gt;one&lt;/b&gt; change notification on dest.
     * @param &lt;T&gt; The type of List to be wrapped
     * @param dest the destination observable list
     * @param src the source list
     * @see Collections#copy(java.util.List, java.util.List)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; void copy(ObservableList&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {
        final int srcSize = src.size();
        if (srcSize &gt; dest.size()) {
            throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;);
        }
        T[] destArray = (T[]) dest.toArray();
        System.arraycopy(src.toArray(), 0, destArray, 0, srcSize);
        dest.setAll(destArray);
    }

    /**
     * Fills the provided list with obj. Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
     * @param &lt;T&gt; The type of List to be wrapped
     * @param list the list to fill
     * @param obj the object to fill the list with
     * @see Collections#fill(java.util.List, java.lang.Object)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; void fill(ObservableList&lt;? super T&gt; list, T obj) {
        T[] newContent = (T[]) new Object[list.size()];
        Arrays.fill(newContent, obj);
        list.setAll(newContent);
    }

    /**
     * Replace all oldVal elements in the list with newVal element.
     * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
     * @param &lt;T&gt; The type of List to be wrapped
     * @param list the list which will have it's elements replaced
     * @param oldVal the element that is going to be replace
     * @param newVal the replacement
     * @return true if the list was modified
     * @see Collections#replaceAll(java.util.List, java.lang.Object, java.lang.Object)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; boolean replaceAll(ObservableList&lt;T&gt; list, T oldVal, T newVal) {
        T[] newContent = (T[]) list.toArray();
        boolean modified = false;
        for (int i = 0 ; i &lt; newContent.length; ++i) {
            if (newContent[i].equals(oldVal)) {
                newContent[i] = newVal;
                modified = true;
            }
        }
        if (modified) {
            list.setAll(newContent);
        }
        return modified;
    }

    /**
     * Reverse the order in the list
     * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
     * @param list the list to be reversed
     * @see Collections#reverse(java.util.List)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static void reverse(ObservableList list) {
        Object[] newContent = list.toArray();
        for (int i = 0; i &lt; newContent.length / 2; ++i) {
            Object tmp = newContent[i];
            newContent[i] = newContent[newContent.length - i - 1];
            newContent[newContent.length -i - 1] = tmp;
        }
        list.setAll(newContent);
    }

    /**
     * Rotates the list by distance.
     * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
     * @param list the list to be rotated
     * @param distance the distance of rotation
     * @see Collections#rotate(java.util.List, int)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static void rotate(ObservableList list, int distance) {
        Object[] newContent = list.toArray();

        int size = list.size();
        distance = distance % size;
        if (distance &lt; 0)
            distance += size;
        if (distance == 0)
            return;

        for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) {
            Object displaced = newContent[cycleStart];
            Object tmp;
            int i = cycleStart;
            do {
                i += distance;
                if (i &gt;= size)
                    i -= size;
                tmp = newContent[i];
                newContent[i] = displaced;
                displaced = tmp;
                nMoved ++;
            } while(i != cycleStart);
        }
        list.setAll(newContent);
    }

    /**
     * Shuffles all elements in the observable list.
     * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
     * @param list the list to shuffle
     * @see Collections#shuffle(java.util.List)
     */
    public static void shuffle(ObservableList&lt;?&gt; list) {
        if (r == null) {
            r = new Random();
        }
        shuffle(list, r);
    }
    private static Random r;

    /**
     * Shuffles all elements in the observable list.
     * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
     * @param list the list to be shuffled
     * @param rnd the random generator used for shuffling
     * @see Collections#shuffle(java.util.List, java.util.Random)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static void shuffle(ObservableList list, Random rnd) {
        Object newContent[] = list.toArray();

        for (int i = list.size(); i &gt; 1; i--) {
            swap(newContent, i - 1, rnd.nextInt(i));
        }

        list.setAll(newContent);
    }

    private static void swap(Object[] arr, int i, int j) {
        Object tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    /**
     * Sorts the provided observable list.
     * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
     * @param &lt;T&gt; The type of List to be wrapped
     * @param list the list to be sorted
     * @see Collections#sort(java.util.List)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(ObservableList&lt;T&gt; list) {
        if (list instanceof SortableList) {
            ((SortableList&lt;? extends T&gt;)list).sort();
        } else {
            List&lt;T&gt; newContent = new ArrayList&lt;T&gt;(list);
            Collections.sort(newContent);
            list.setAll((Collection&lt;T&gt;)newContent);
        }
    }

    /**
     * Sorts the provided observable list using the c comparator.
     * Fires only &lt;b&gt;one&lt;/b&gt; change notification on the list.
     * @param &lt;T&gt; The type of List to be wrapped
     * @param list the list to sort
     * @param c comparator used for sorting. Null if natural ordering is required.
     * @see Collections#sort(java.util.List, java.util.Comparator)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; void sort(ObservableList&lt;T&gt; list, Comparator&lt;? super T&gt; c) {
        if (list instanceof SortableList) {
            ((SortableList&lt;? extends T&gt;)list).sort(c);
        } else {
            List&lt;T&gt; newContent = new ArrayList&lt;T&gt;(list);
            Collections.sort(newContent, c);
            list.setAll((Collection&lt;T&gt;)newContent);
        }
    }

    private static class EmptyObservableList&lt;E&gt; extends AbstractList&lt;E&gt; implements ObservableList&lt;E&gt; {

        private static final ListIterator iterator = new ListIterator() {

            @Override
            public boolean hasNext() {
                return false;
            }

            @Override
            public Object next() {
                throw new NoSuchElementException();
            }

            @Override
            public void remove() {
                throw new UnsupportedOperationException();
            }

            @Override
            public boolean hasPrevious() {
                return false;
            }

            @Override
            public Object previous() {
                throw new NoSuchElementException();
            }

            @Override
            public int nextIndex() {
                return 0;
            }

            @Override
            public int previousIndex() {
                return -1;
            }

            @Override
            public void set(Object e) {
                throw new UnsupportedOperationException();
            }

            @Override
            public void add(Object e) {
                throw new UnsupportedOperationException();
            }
        };

        public EmptyObservableList() {
        }

        @Override
        public final void addListener(InvalidationListener listener) {
        }

        @Override
        public final void removeListener(InvalidationListener listener) {
        }


        @Override
        public void addListener(ListChangeListener&lt;? super E&gt; o) {
        }

        @Override
        public void removeListener(ListChangeListener&lt;? super E&gt; o) {
        }

        @Override
        public int size() {
            return 0;
        }

        @Override
        public boolean contains(Object o) {
            return false;
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public Iterator&lt;E&gt; iterator() {
            return iterator;
        }

        @Override
        public boolean containsAll(Collection&lt;?&gt; c) {
            return c.isEmpty();
        }

        @Override
        public E get(int index) {
            throw new IndexOutOfBoundsException();
        }

        @Override
        public int indexOf(Object o) {
            return -1;
        }

        @Override
        public int lastIndexOf(Object o) {
            return -1;
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public ListIterator&lt;E&gt; listIterator() {
            return iterator;
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public ListIterator&lt;E&gt; listIterator(int index) {
            if (index != 0) {
                throw new IndexOutOfBoundsException();
            }
            return iterator;
        }

        @Override
        public List&lt;E&gt; subList(int fromIndex, int toIndex) {
            if (fromIndex != 0 || toIndex != 0) {
                throw new IndexOutOfBoundsException();
            }
            return this;
        }

        @Override
        public boolean addAll(E... elements) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean setAll(E... elements) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean setAll(Collection&lt;? extends E&gt; col) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean removeAll(E... elements) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean retainAll(E... elements) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void remove(int from, int to) {
            throw new UnsupportedOperationException();
        }
    }

    private static class SingletonObservableList&lt;E&gt; extends AbstractList&lt;E&gt; implements ObservableList&lt;E&gt; {

        private final E element;

        public SingletonObservableList(E element) {
            if (element == null) {
                throw new NullPointerException();
            }
            this.element = element;
        }

        @Override
        public boolean addAll(E... elements) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean setAll(E... elements) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean setAll(Collection&lt;? extends E&gt; col) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean removeAll(E... elements) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean retainAll(E... elements) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void remove(int from, int to) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void addListener(InvalidationListener listener) {
        }

        @Override
        public void removeListener(InvalidationListener listener) {
        }

        @Override
        public void addListener(ListChangeListener&lt;? super E&gt; o) {
        }

        @Override
        public void removeListener(ListChangeListener&lt;? super E&gt; o) {
        }

        @Override
        public int size() {
            return 1;
        }

        @Override
        public boolean isEmpty() {
            return false;
        }

        @Override
        public boolean contains(Object o) {
            return element.equals(o);
        }

        @Override
        public E get(int index) {
            if (index != 0) {
                throw new IndexOutOfBoundsException();
            }
            return element;
        }

    }

    private static class UnmodifiableObservableListImpl&lt;T&gt; extends ObservableListBase&lt;T&gt; implements ObservableList&lt;T&gt; {

        private final ObservableList&lt;T&gt; backingList;
        private final ListChangeListener&lt;T&gt; listener;

        public UnmodifiableObservableListImpl(ObservableList&lt;T&gt; backingList) {
            this.backingList = backingList;
            listener = c -&gt; {
                fireChange(new SourceAdapterChange&lt;T&gt;(UnmodifiableObservableListImpl.this, c));
            };
            this.backingList.addListener(new WeakListChangeListener&lt;T&gt;(listener));
        }

        @Override
        public T get(int index) {
            return backingList.get(index);
        }

        @Override
        public int size() {
            return backingList.size();
        }

        @Override
        public boolean addAll(T... elements) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean setAll(T... elements) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean setAll(Collection&lt;? extends T&gt; col) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean removeAll(T... elements) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean retainAll(T... elements) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void remove(int from, int to) {
            throw new UnsupportedOperationException();
        }

    }

    private static class SynchronizedList&lt;T&gt; implements List&lt;T&gt; {
        final Object mutex;
        private final List&lt;T&gt; backingList;

        SynchronizedList(List&lt;T&gt; list, Object mutex) {
            this.backingList = list;
            this.mutex = mutex;
        }

        @Override
        public int size() {
            synchronized(mutex) {
                return backingList.size();
            }
        }

        @Override
        public boolean isEmpty() {
            synchronized(mutex) {
                return backingList.isEmpty();
            }
        }

        @Override
        public boolean contains(Object o) {
            synchronized(mutex) {
                return backingList.contains(o);
            }
        }

        @Override
        public Iterator&lt;T&gt; iterator() {
            return backingList.iterator();
        }

        @Override
        public Object[] toArray() {
            synchronized(mutex)  {
                return backingList.toArray();
            }
        }

        @Override
        public &lt;T&gt; T[] toArray(T[] a) {
            synchronized(mutex) {
                return backingList.toArray(a);
            }
        }

        @Override
        public boolean add(T e) {
            synchronized(mutex) {
                return backingList.add(e);
            }
        }

        @Override
        public boolean remove(Object o) {
            synchronized(mutex) {
                return backingList.remove(o);
            }
        }

        @Override
        public boolean containsAll(Collection&lt;?&gt; c) {
            synchronized(mutex) {
                return backingList.containsAll(c);
            }
        }

        @Override
        public boolean addAll(Collection&lt;? extends T&gt; c) {
            synchronized(mutex) {
                return backingList.addAll(c);
            }
        }

        @Override
        public boolean addAll(int index, Collection&lt;? extends T&gt; c) {
            synchronized(mutex) {
                return backingList.addAll(index, c);

            }
        }

        @Override
        public boolean removeAll(Collection&lt;?&gt; c) {
            synchronized(mutex) {
                return backingList.removeAll(c);
            }
        }

        @Override
        public boolean retainAll(Collection&lt;?&gt; c) {
            synchronized(mutex) {
                return backingList.retainAll(c);
            }
        }

        @Override
        public void clear() {
            synchronized(mutex) {
                backingList.clear();
            }
        }

        @Override
        public T get(int index) {
            synchronized(mutex) {
                return backingList.get(index);
            }
        }

        @Override
        public T set(int index, T element) {
            synchronized(mutex) {
                return backingList.set(index, element);
            }
        }

        @Override
        public void add(int index, T element) {
            synchronized(mutex) {
                backingList.add(index, element);
            }
        }

        @Override
        public T remove(int index) {
            synchronized(mutex) {
                return backingList.remove(index);
            }
        }

        @Override
        public int indexOf(Object o) {
            synchronized(mutex) {
                return backingList.indexOf(o);
            }
        }

        @Override
        public int lastIndexOf(Object o) {
            synchronized(mutex) {
                return backingList.lastIndexOf(o);
            }
        }

        @Override
        public ListIterator&lt;T&gt; listIterator() {
            return backingList.listIterator();
        }

        @Override
        public ListIterator&lt;T&gt; listIterator(int index) {
            synchronized(mutex) {
                return backingList.listIterator(index);
            }
        }

        @Override
        public List&lt;T&gt; subList(int fromIndex, int toIndex) {
            synchronized(mutex) {
                return new SynchronizedList&lt;T&gt;(backingList.subList(fromIndex, toIndex),
                        mutex);
            }
        }

        @Override
        public String toString() {
            synchronized(mutex) {
                return backingList.toString();
            }
        }

        @Override
        public int hashCode() {
            synchronized(mutex) {
                return backingList.hashCode();
            }
        }

        @Override
        public boolean equals(Object o) {
            synchronized(mutex) {
                return backingList.equals(o);
            }
        }

    }

    private static class SynchronizedObservableList&lt;T&gt; extends SynchronizedList&lt;T&gt; implements ObservableList&lt;T&gt; {

        private ListListenerHelper helper;

        private final ObservableList&lt;T&gt; backingList;
        private final ListChangeListener&lt;T&gt; listener;

        SynchronizedObservableList(ObservableList&lt;T&gt; seq, Object mutex) {
            super(seq, mutex);
            this.backingList = seq;
            listener = c -&gt; {
                ListListenerHelper.fireValueChangedEvent(helper, new SourceAdapterChange&lt;T&gt;(SynchronizedObservableList.this, c));
            };
            backingList.addListener(new WeakListChangeListener&lt;T&gt;(listener));
        }

        SynchronizedObservableList(ObservableList&lt;T&gt; seq) {
            this(seq, new Object());
        }

        @Override
        public boolean addAll(T... elements) {
            synchronized(mutex) {
                return backingList.addAll(elements);
            }
        }

        @Override
        public boolean setAll(T... elements) {
            synchronized(mutex) {
                return backingList.setAll(elements);
            }
        }

        @Override
        public boolean removeAll(T... elements) {
            synchronized(mutex) {
                return backingList.removeAll(elements);
            }
        }

        @Override
        public boolean retainAll(T... elements) {
            synchronized(mutex) {
                return backingList.retainAll(elements);
            }
        }

        @Override
        public void remove(int from, int to) {
            synchronized(mutex) {
                backingList.remove(from, to);
            }
        }

        @Override
        public boolean setAll(Collection&lt;? extends T&gt; col) {
            synchronized(mutex) {
                return backingList.setAll(col);
            }
        }

        @Override
        public final void addListener(InvalidationListener listener) {
            synchronized (mutex) {
                helper = ListListenerHelper.addListener(helper, listener);
            }
        }

        @Override
        public final void removeListener(InvalidationListener listener) {
            synchronized (mutex) {
                helper = ListListenerHelper.removeListener(helper, listener);
            }
        }

        @Override
        public void addListener(ListChangeListener&lt;? super T&gt; listener) {
            synchronized (mutex) {
                helper = ListListenerHelper.addListener(helper, listener);
            }
        }

        @Override
        public void removeListener(ListChangeListener&lt;? super T&gt; listener) {
            synchronized (mutex) {
                helper = ListListenerHelper.removeListener(helper, listener);
            }
        }


    }

    private static class CheckedObservableList&lt;T&gt; extends ObservableListBase&lt;T&gt; implements ObservableList&lt;T&gt; {

        private final ObservableList&lt;T&gt; list;
        private final Class&lt;T&gt; type;
        private final ListChangeListener&lt;T&gt; listener;

        CheckedObservableList(ObservableList&lt;T&gt; list, Class&lt;T&gt; type) {
            if (list == null || type == null) {
                throw new NullPointerException();
            }
            this.list = list;
            this.type = type;
            listener = c -&gt; {
                fireChange(new SourceAdapterChange&lt;T&gt;(CheckedObservableList.this, c));
            };
            list.addListener(new WeakListChangeListener&lt;T&gt;(listener));
        }

        void typeCheck(Object o) {
            if (o != null &amp;&amp; !type.isInstance(o)) {
                throw new ClassCastException(&quot;Attempt to insert &quot;
                        + o.getClass() + &quot; element into collection with element type &quot;
                        + type);
            }
        }

        @Override
        public int size() {
            return list.size();
        }

        @Override
        public boolean isEmpty() {
            return list.isEmpty();
        }

        @Override
        public boolean contains(Object o) {
            return list.contains(o);
        }

        @Override
        public Object[] toArray() {
            return list.toArray();
        }

        @Override
        public &lt;T&gt; T[] toArray(T[] a) {
            return list.toArray(a);
        }

        @Override
        public String toString() {
            return list.toString();
        }

        @Override
        public boolean remove(Object o) {
            return list.remove(o);
        }

        @Override
        public boolean containsAll(Collection&lt;?&gt; coll) {
            return list.containsAll(coll);
        }

        @Override
        public boolean removeAll(Collection&lt;?&gt; coll) {
            return list.removeAll(coll);
        }

        @Override
        public boolean retainAll(Collection&lt;?&gt; coll) {
            return list.retainAll(coll);
        }

        @Override
        public boolean removeAll(T... elements) {
            return list.removeAll(elements);
        }

        @Override
        public boolean retainAll(T... elements) {
            return list.retainAll(elements);
        }

        @Override
        public void remove(int from, int to) {
            list.remove(from, to);
        }

        @Override
        public void clear() {
            list.clear();
        }

        @Override
        public boolean equals(Object o) {
            return o == this || list.equals(o);
        }

        @Override
        public int hashCode() {
            return list.hashCode();
        }

        @Override
        public T get(int index) {
            return list.get(index);
        }

        @Override
        public T remove(int index) {
            return list.remove(index);
        }

        @Override
        public int indexOf(Object o) {
            return list.indexOf(o);
        }

        @Override
        public int lastIndexOf(Object o) {
            return list.lastIndexOf(o);
        }

        @Override
        public T set(int index, T element) {
            typeCheck(element);
            return list.set(index, element);
        }

        @Override
        public void add(int index, T element) {
            typeCheck(element);
            list.add(index, element);
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public boolean addAll(int index, Collection&lt;? extends T&gt; c) {
            T[] a = null;
            try {
                a = c.toArray((T[]) Array.newInstance(type, 0));
            } catch (ArrayStoreException e) {
                throw new ClassCastException();
            }

            return this.list.addAll(index, Arrays.asList(a));
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public boolean addAll(Collection&lt;? extends T&gt; coll) {
            T[] a = null;
            try {
                a = coll.toArray((T[]) Array.newInstance(type, 0));
            } catch (ArrayStoreException e) {
                throw new ClassCastException();
            }

            return this.list.addAll(Arrays.asList(a));
        }

        @Override
        public ListIterator&lt;T&gt; listIterator() {
            return listIterator(0);
        }

        @Override
        public ListIterator&lt;T&gt; listIterator(final int index) {
            return new ListIterator&lt;T&gt;() {

                ListIterator&lt;T&gt; i = list.listIterator(index);

                @Override
                public boolean hasNext() {
                    return i.hasNext();
                }

                @Override
                public T next() {
                    return i.next();
                }

                @Override
                public boolean hasPrevious() {
                    return i.hasPrevious();
                }

                @Override
                public T previous() {
                    return i.previous();
                }

                @Override
                public int nextIndex() {
                    return i.nextIndex();
                }

                @Override
                public int previousIndex() {
                    return i.previousIndex();
                }

                @Override
                public void remove() {
                    i.remove();
                }

                @Override
                public void set(T e) {
                    typeCheck(e);
                    i.set(e);
                }

                @Override
                public void add(T e) {
                    typeCheck(e);
                    i.add(e);
                }
            };
        }

        @Override
        public Iterator&lt;T&gt; iterator() {
            return new Iterator&lt;T&gt;() {

                private final Iterator&lt;T&gt; it = list.iterator();

                @Override
                public boolean hasNext() {
                    return it.hasNext();
                }

<A NAME="12"></A>                @Override
                public T next() {
                    return it.next();
                <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#12',2,'match51-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

                @Override
                public void remove() {
                    it.remove();
                }
            }</B></FONT>;
        }

        @Override
        public boolean add(T e) {
            typeCheck(e);
            return list.add(e);
        }

        @Override
        public List&lt;T&gt; subList(int fromIndex, int toIndex) {
            return Collections.checkedList(list.subList(fromIndex, toIndex), type);
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public boolean addAll(T... elements) {
            try {
                T[] array = (T[]) Array.newInstance(type, elements.length);
                System.arraycopy(elements, 0, array, 0, elements.length);
                return list.addAll(array);
            } catch (ArrayStoreException e) {
                throw new ClassCastException();
            }
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public boolean setAll(T... elements) {
            try {
                T[] array = (T[]) Array.newInstance(type, elements.length);
                System.arraycopy(elements, 0, array, 0, elements.length);
                return list.setAll(array);
            } catch (ArrayStoreException e) {
                throw new ClassCastException();
            }
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public boolean setAll(Collection&lt;? extends T&gt; col) {
            T[] a = null;
            try {
                a = col.toArray((T[]) Array.newInstance(type, 0));
            } catch (ArrayStoreException e) {
                throw new ClassCastException();
            }

            return list.setAll(Arrays.asList(a));
        }
    }

    private static class EmptyObservableSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements ObservableSet&lt;E&gt; {

        public EmptyObservableSet() {
        }

        @Override
        public void addListener(InvalidationListener listener) {
        }

        @Override
        public void removeListener(InvalidationListener listener) {
        }

        @Override
        public void addListener(SetChangeListener&lt;? super E&gt; listener) {
        }

        @Override
        public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
        }

        @Override
        public int size() {
            return 0;
        }

        @Override
        public boolean isEmpty() {
            return true;
        }

        @Override
        public boolean contains(Object obj) {
            return false;
        }

        @Override
        public boolean containsAll(Collection&lt;?&gt; c) {
            return c.isEmpty();
        }

        @Override
        public Object[] toArray() {
            return new Object[0];
        }

        @Override
        public &lt;E&gt; E[] toArray(E[] a) {
            if (a.length &gt; 0)
                a[0] = null;
            return a;
        }

        @Override
        public Iterator&lt;E&gt; iterator() {
            return new Iterator() {

                @Override
                public boolean hasNext() {
                    return false;
                }

                @Override
                public Object next() {
                    throw new NoSuchElementException();
                }

                @Override
                public void remove() {
                    throw new UnsupportedOperationException();
                }
            };
        }

    }

    private static class UnmodifiableObservableSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements ObservableSet&lt;E&gt; {

        private final ObservableSet&lt;E&gt; backingSet;
        private SetListenerHelper&lt;E&gt; listenerHelper;
        private SetChangeListener&lt;E&gt; listener;

        public UnmodifiableObservableSet(ObservableSet&lt;E&gt; backingSet) {
            this.backingSet = backingSet;
            this.listener = null;
        }

        private void initListener() {
            if (listener == null) {
                listener = c -&gt; {
                    callObservers(new SetAdapterChange&lt;E&gt;(UnmodifiableObservableSet.this, c));
                };
                this.backingSet.addListener(new WeakSetChangeListener&lt;E&gt;(listener));
            }
        }

        private void callObservers(SetChangeListener.Change&lt;? extends E&gt; change) {
            SetListenerHelper.fireValueChangedEvent(listenerHelper, change);
        }

        @Override
        public Iterator&lt;E&gt; iterator() {
            return new Iterator&lt;E&gt;() {
                private final Iterator&lt;? extends E&gt; i = backingSet.iterator();

                @Override
                public boolean hasNext() {
                    return i.hasNext();
                }

                @Override
                public E next() {
                    return i.next();
                }
            };
        }

        @Override
        public int size() {
            return backingSet.size();
        }

        @Override
        public boolean isEmpty() {
            return backingSet.isEmpty();
        }

        @Override
        public boolean contains(Object o) {
            return backingSet.contains(o);
        }

        @Override
        public void addListener(InvalidationListener listener) {
            initListener();
            listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
        }

        @Override
        public void addListener(SetChangeListener&lt;? super E&gt; listener) {
            initListener();
            listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
        }

        @Override
        public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
            listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
        }

        @Override
        public boolean add(E e) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean remove(Object o) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean addAll(Collection&lt;? extends E&gt; c) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean retainAll(Collection&lt;?&gt; c) {
            throw new UnsupportedOperationException();
        }

        @Override
        public boolean removeAll(Collection&lt;?&gt; c) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void clear() {
            throw new UnsupportedOperationException();
        }
    }

    private static class SynchronizedSet&lt;E&gt; implements Set&lt;E&gt; {
        final Object mutex;
        private final Set&lt;E&gt; backingSet;

        SynchronizedSet(Set&lt;E&gt; set, Object mutex) {
            this.backingSet = set;
            this.mutex = mutex;
        }

        SynchronizedSet(Set&lt;E&gt; set) {
            this(set, new Object());
        }

        @Override
        public int size() {
            synchronized(mutex) {
                return backingSet.size();
            }
        }

        @Override
        public boolean isEmpty() {
            synchronized(mutex) {
                return backingSet.isEmpty();
            }
        }

        @Override
        public boolean contains(Object o) {
            synchronized(mutex) {
                return backingSet.contains(o);
            }
        }

        @Override
        public Iterator&lt;E&gt; iterator() {
            return backingSet.iterator();
        }

        @Override
        public Object[] toArray() {
            synchronized(mutex) {
                return backingSet.toArray();
            }
        }

        @Override
        public &lt;E&gt; E[] toArray(E[] a) {
            synchronized(mutex) {
                return backingSet.toArray(a);
            }
        }

        @Override
        public boolean add(E e) {
            synchronized(mutex) {
                return backingSet.add(e);
            }
        }

        @Override
        public boolean remove(Object o) {
            synchronized(mutex) {
                return backingSet.remove(o);
            }
        }

        @Override
        public boolean containsAll(Collection&lt;?&gt; c) {
            synchronized(mutex) {
                return backingSet.containsAll(c);
            }
        }

        @Override
        public boolean addAll(Collection&lt;? extends E&gt; c) {
            synchronized(mutex) {
                return backingSet.addAll(c);
            }
        }

        @Override
        public boolean retainAll(Collection&lt;?&gt; c) {
            synchronized(mutex) {
                return backingSet.retainAll(c);
            }
        }

        @Override
        public boolean removeAll(Collection&lt;?&gt; c) {
            synchronized(mutex) {
                return backingSet.removeAll(c);
            }
        }

        @Override
        public void clear() {
            synchronized(mutex) {
                backingSet.clear();
            }
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            synchronized(mutex) {
                return backingSet.equals(o);
            }
        }

        @Override
        public int hashCode() {
            synchronized (mutex) {
                return backingSet.hashCode();
            }
        }
    }

    private static class SynchronizedObservableSet&lt;E&gt; extends SynchronizedSet&lt;E&gt; implements ObservableSet&lt;E&gt; {

        private final ObservableSet&lt;E&gt; backingSet;
        private SetListenerHelper listenerHelper;
        private final SetChangeListener&lt;E&gt; listener;

        SynchronizedObservableSet(ObservableSet&lt;E&gt; set, Object mutex) {
            super(set, mutex);
            backingSet = set;
            listener = c -&gt; {
                SetListenerHelper.fireValueChangedEvent(listenerHelper, new SetAdapterChange&lt;E&gt;(SynchronizedObservableSet.this, c));
            };
            backingSet.addListener(new WeakSetChangeListener&lt;E&gt;(listener));
        }

        SynchronizedObservableSet(ObservableSet&lt;E&gt; set) {
            this(set, new Object());
        }

        @Override
        public void addListener(InvalidationListener listener) {
            synchronized (mutex) {
                listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
            }
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            synchronized (mutex) {
                listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
            }
        }
        @Override
        public void addListener(SetChangeListener&lt;? super E&gt; listener) {
            synchronized (mutex) {
                listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
            }
        }

        @Override
        public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
            synchronized (mutex) {
                listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
            }
        }
    }

    private static class CheckedObservableSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements ObservableSet&lt;E&gt; {

        private final ObservableSet&lt;E&gt; backingSet;
        private final Class&lt;E&gt; type;
        private SetListenerHelper listenerHelper;
        private final SetChangeListener&lt;E&gt; listener;

        CheckedObservableSet(ObservableSet&lt;E&gt; set, Class&lt;E&gt; type) {
            if (set == null || type == null) {
                throw new NullPointerException();
            }
            backingSet = set;
            this.type = type;
            listener = c -&gt; {
                callObservers(new SetAdapterChange&lt;E&gt;(CheckedObservableSet.this, c));
            };
            backingSet.addListener(new WeakSetChangeListener&lt;E&gt;(listener));
        }

        private void callObservers(SetChangeListener.Change&lt;? extends E&gt; c) {
            SetListenerHelper.fireValueChangedEvent(listenerHelper, c);
        }

        void typeCheck(Object o) {
            if (o != null &amp;&amp; !type.isInstance(o)) {
                throw new ClassCastException(&quot;Attempt to insert &quot;
                        + o.getClass() + &quot; element into collection with element type &quot;
                        + type);
            }
        }

        @Override
        public void addListener(InvalidationListener listener) {
            listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
        }

        @Override
        public void addListener(SetChangeListener&lt;? super E&gt; listener) {
            listenerHelper = SetListenerHelper.addListener(listenerHelper, listener);
        }

        @Override
        public void removeListener(SetChangeListener&lt;? super E&gt; listener) {
            listenerHelper = SetListenerHelper.removeListener(listenerHelper, listener);
        }

        @Override
        public int size() {
            return backingSet.size();
        }

        @Override
        public boolean isEmpty() {
            return backingSet.isEmpty();
        }

        @Override
        public boolean contains(Object o) {
            return backingSet.contains(o);
        }

        @Override
        public Object[] toArray() {
            return backingSet.toArray();
        }

        @Override
        public &lt;T&gt; T[] toArray(T[] a) {
            return backingSet.toArray(a);
        }

        @Override
        public boolean add(E e) {
            typeCheck(e);
            return backingSet.add(e);
        }

        @Override
        public boolean remove(Object o) {
            return backingSet.remove(o);
        }

        @Override
        public boolean containsAll(Collection&lt;?&gt; c) {
            return backingSet.containsAll(c);
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public boolean addAll(Collection&lt;? extends E&gt; c) {
            E[] a = null;
            try {
                a = c.toArray((E[]) Array.newInstance(type, 0));
            } catch (ArrayStoreException e) {
                throw new ClassCastException();
            }

            return backingSet.addAll(Arrays.asList(a));
        }

        @Override
        public boolean retainAll(Collection&lt;?&gt; c) {
            return backingSet.retainAll(c);
        }

        @Override
        public boolean removeAll(Collection&lt;?&gt; c) {
            return backingSet.removeAll(c);
        }

        @Override
        public void clear() {
            backingSet.clear();
        }

        @Override
        public boolean equals(Object o) {
            return o == this || backingSet.equals(o);
        }

        @Override
        public int hashCode() {
            return backingSet.hashCode();
        }

        @Override
        public Iterator&lt;E&gt; iterator() {
            final Iterator&lt;E&gt; it = backingSet.iterator();

            return new Iterator&lt;E&gt;() {
                @Override
                public boolean hasNext() {
                    return it.hasNext();
                }

                @Override
                public E next() {
                    return it.next();
                }

                @Override
                public void remove() {
                    it.remove();
                }
            };
        }

    }

    private static class EmptyObservableMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ObservableMap&lt;K, V&gt; {

        public EmptyObservableMap() {
        }

        @Override
        public void addListener(InvalidationListener listener) {
        }

        @Override
        public void removeListener(InvalidationListener listener) {
        }

        @Override
        public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
        }

        @Override
        public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
        }

        @Override
        public int size() {
            return 0;
        }

        @Override
        public boolean isEmpty() {
            return true;
        }

        @Override
        public boolean containsKey(Object key) {
            return false;
        }

        @Override
        public boolean containsValue(Object value) {
            return false;
        }

        @Override
        public V get(Object key) {
            return null;
        }

        @Override
        public Set&lt;K&gt; keySet() {
            return emptyObservableSet();
        }

        @Override
        public Collection&lt;V&gt; values() {
            return emptyObservableSet();
        }

        @Override
        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
            return emptyObservableSet();
        }

        @Override
        public boolean equals(Object o) {
            return (o instanceof Map) &amp;&amp; ((Map&lt;?,?&gt;)o).isEmpty();
        }

        @Override
        public int hashCode() {
            return 0;
        }
    }

    private static class CheckedObservableMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ObservableMap&lt;K, V&gt; {

        private final ObservableMap&lt;K, V&gt; backingMap;
        private final Class&lt;K&gt; keyType;
        private final Class&lt;V&gt; valueType;
        private MapListenerHelper listenerHelper;
        private final MapChangeListener&lt;K, V&gt; listener;

        CheckedObservableMap(ObservableMap&lt;K, V&gt; map, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType) {
            backingMap = map;
            this.keyType = keyType;
            this.valueType = valueType;
            listener = c -&gt; {
                callObservers(new MapAdapterChange&lt;K, V&gt;(CheckedObservableMap.this, c));
            };
            backingMap.addListener(new WeakMapChangeListener&lt;K, V&gt;(listener));
        }

        private void callObservers(MapChangeListener.Change&lt;? extends K, ? extends V&gt; c) {
            MapListenerHelper.fireValueChangedEvent(listenerHelper, c);
        }

        void typeCheck(Object key, Object value) {
            if (key != null &amp;&amp; !keyType.isInstance(key)) {
                throw new ClassCastException(&quot;Attempt to insert &quot;
                        + key.getClass() + &quot; key into map with key type &quot;
                        + keyType);
            }

            if (value != null &amp;&amp; !valueType.isInstance(value)) {
                throw new ClassCastException(&quot;Attempt to insert &quot;
                        + value.getClass() + &quot; value into map with value type &quot;
                        + valueType);
            }
        }

        @Override
        public void addListener(InvalidationListener listener) {
            listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
        }

        @Override
        public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
            listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
        }

        @Override
        public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
            listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
        }

        @Override
        public int size() {
            return backingMap.size();
        }

        @Override
        public boolean isEmpty() {
            return backingMap.isEmpty();
        }

        @Override
        public boolean containsKey(Object key) {
            return backingMap.containsKey(key);
        }

        @Override
        public boolean containsValue(Object value) {
            return backingMap.containsValue(value);
        }

        @Override
        public V get(Object key) {
            return backingMap.get(key);
        }

        @Override
        public V put(K key, V value) {
            typeCheck(key, value);
            return backingMap.put(key, value);
        }

        @Override
        public V remove(Object key) {
            return backingMap.remove(key);
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void putAll(Map t) {
            // Satisfy the following goals:
            // - good diagnostics in case of type mismatch
            // - all-or-nothing semantics
            // - protection from malicious t
            // - correct behavior if t is a concurrent map
            Object[] entries = t.entrySet().toArray();
            List&lt;Map.Entry&lt;K,V&gt;&gt; checked =
                new ArrayList&lt;Map.Entry&lt;K,V&gt;&gt;(entries.length);
            for (Object o : entries) {
                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
                Object k = e.getKey();
                Object v = e.getValue();
                typeCheck(k, v);
                checked.add(
                    new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;((K) k, (V) v));
            }
            for (Map.Entry&lt;K,V&gt; e : checked)
                backingMap.put(e.getKey(), e.getValue());
        }

        @Override
        public void clear() {
            backingMap.clear();
        }

        @Override
        public Set&lt;K&gt; keySet() {
            return backingMap.keySet();
        }

        @Override
        public Collection&lt;V&gt; values() {
            return backingMap.values();
        }

        private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;

        @Override
        public Set entrySet() {
            if (entrySet==null)
                entrySet = new CheckedEntrySet&lt;K,V&gt;(backingMap.entrySet(), valueType);
            return entrySet;
        }

        @Override
        public boolean equals(Object o) {
            return o == this || backingMap.equals(o);
        }

        @Override
        public int hashCode() {
            return backingMap.hashCode();
        }

        static class CheckedEntrySet&lt;K,V&gt; implements Set&lt;Map.Entry&lt;K,V&gt;&gt; {
            private final Set&lt;Map.Entry&lt;K,V&gt;&gt; s;
            private final Class&lt;V&gt; valueType;

            CheckedEntrySet(Set&lt;Map.Entry&lt;K, V&gt;&gt; s, Class&lt;V&gt; valueType) {
                this.s = s;
                this.valueType = valueType;
            }

            @Override
            public int size() {
                return s.size();
            }

            @Override
            public boolean isEmpty() {
                return s.isEmpty();
            }

            @Override
            public String toString() {
                return s.toString();
            }

            @Override
            public int hashCode() {
                return s.hashCode();
            }

            @Override
            public void clear() {
                s.clear();
            }

            @Override
            public boolean add(Map.Entry&lt;K, V&gt; e) {
                throw new UnsupportedOperationException();
            }

            @Override
            public boolean addAll(Collection&lt;? extends Map.Entry&lt;K, V&gt;&gt; coll) {
                throw new UnsupportedOperationException();
            }

            @Override
            public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
                final Iterator&lt;Map.Entry&lt;K, V&gt;&gt; i = s.iterator();
                final Class&lt;V&gt; valueType = this.valueType;

                return new Iterator&lt;Map.Entry&lt;K,V&gt;&gt;() {
                    @Override
                    public boolean hasNext() {
                        return i.hasNext();
                    }

                    @Override
                    public void remove() {
                        i.remove();
                    }

                    @Override
                    public Map.Entry&lt;K,V&gt; next() {
                        return checkedEntry(i.next(), valueType);
                    }
                };
            }

            @Override
            @SuppressWarnings(&quot;unchecked&quot;)
            public Object[] toArray() {
                Object[] source = s.toArray();

                /*
                 * Ensure that we don't get an ArrayStoreException even if
                 * s.toArray returns an array of something other than Object
                 */
                Object[] dest = (CheckedEntry.class.isInstance(
                    source.getClass().getComponentType()) ? source :
                                 new Object[source.length]);

                for (int i = 0; i &lt; source.length; i++)
                    dest[i] = checkedEntry((Map.Entry&lt;K,V&gt;)source[i],
                                           valueType);
                return dest;
            }

            @Override
            @SuppressWarnings(&quot;unchecked&quot;)
            public &lt;T&gt; T[] toArray(T[] a) {
                // We don't pass a to s.toArray, to avoid window of
                // vulnerability wherein an unscrupulous multithreaded client
                // could get his hands on raw (unwrapped) Entries from s.
                T[] arr = s.toArray(a.length==0 ? a : Arrays.copyOf(a, 0));

                for (int i=0; i&lt;arr.length; i++)
                    arr[i] = (T) checkedEntry((Map.Entry&lt;K,V&gt;)arr[i],
                                              valueType);
                if (arr.length &gt; a.length)
                    return arr;

                System.arraycopy(arr, 0, a, 0, arr.length);
                if (a.length &gt; arr.length)
                    a[arr.length] = null;
                return a;
            }

            /**
             * This method is overridden to protect the backing set against
             * an object with a nefarious equals function that senses
             * that the equality-candidate is Map.Entry and calls its
             * setValue method.
             */
            @Override
            public boolean contains(Object o) {
                if (!(o instanceof Map.Entry))
                    return false;
                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;
                return s.contains(
                    (e instanceof CheckedEntry) ? e : checkedEntry(e, valueType));
            }

            /**
             * The bulk collection methods are overridden to protect
             * against an unscrupulous collection whose contains(Object o)
             * method senses when o is a Map.Entry, and calls o.setValue.
             */
            @Override
            public boolean containsAll(Collection&lt;?&gt; c) {
                for (Object o : c)
                    if (!contains(o)) // Invokes safe contains() above
                        return false;
                return true;
            }

            @Override
            public boolean remove(Object o) {
                if (!(o instanceof Map.Entry))
                    return false;
                return s.remove(new AbstractMap.SimpleImmutableEntry
                                &lt;Object, Object&gt;((Map.Entry&lt;?,?&gt;)o));
            }

            @Override
            public boolean removeAll(Collection&lt;?&gt; c) {
                return batchRemove(c, false);
            }

            @Override
            public boolean retainAll(Collection&lt;?&gt; c) {
                return batchRemove(c, true);
            }

            private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
                boolean modified = false;
                Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = iterator();
                while (it.hasNext()) {
                    if (c.contains(it.next()) != complement) {
                        it.remove();
                        modified = true;
                    }
                }
                return modified;
            }

            @Override
            public boolean equals(Object o) {
                if (o == this)
                    return true;
                if (!(o instanceof Set))
                    return false;
                Set&lt;?&gt; that = (Set&lt;?&gt;) o;
                return that.size() == s.size()
                    &amp;&amp; containsAll(that); // Invokes safe containsAll() above
            }

            static &lt;K,V,T&gt; CheckedEntry&lt;K,V,T&gt; checkedEntry(Map.Entry&lt;K,V&gt; e,
                                                            Class&lt;T&gt; valueType) {
                return new CheckedEntry&lt;K,V,T&gt;(e, valueType);
            }

            /**
             * This &quot;wrapper class&quot; serves two purposes: it prevents
             * the client from modifying the backing Map, by short-circuiting
             * the setValue method, and it protects the backing Map against
             * an ill-behaved Map.Entry that attempts to modify another
             * Map.Entry when asked to perform an equality check.
             */
            private static class CheckedEntry&lt;K,V,T&gt; implements Map.Entry&lt;K,V&gt; {
                private final Map.Entry&lt;K, V&gt; e;
                private final Class&lt;T&gt; valueType;

                CheckedEntry(Map.Entry&lt;K, V&gt; e, Class&lt;T&gt; valueType) {
                    this.e = e;
                    this.valueType = valueType;
                }

                @Override
                public K getKey() {
                    return e.getKey();
                }

                @Override
                public V getValue() {
                    return e.getValue();
                }

                @Override
                public int hashCode() {
                    return e.hashCode();
                }

                @Override
                public String toString() {
                    return e.toString();
                }

                @Override
                public V setValue(V value) {
                    if (value != null &amp;&amp; !valueType.isInstance(value))
                        throw new ClassCastException(badValueMsg(value));
                    return e.setValue(value);
                }

                private String badValueMsg(Object value) {
                    return &quot;Attempt to insert &quot; + value.getClass() +
                        &quot; value into map with value type &quot; + valueType;
                }

                @Override
                public boolean equals(Object o) {
                    if (o == this)
                        return true;
                    if (!(o instanceof Map.Entry))
                        return false;
                    return e.equals(new AbstractMap.SimpleImmutableEntry
                                    &lt;Object, Object&gt;((Map.Entry&lt;?,?&gt;)o));
                }
            }
        }

    }

    private static class SynchronizedMap&lt;K, V&gt; implements Map&lt;K, V&gt; {
        final Object mutex;
        private final Map&lt;K, V&gt; backingMap;

        SynchronizedMap(Map&lt;K, V&gt; map, Object mutex) {
            backingMap = map;
            this.mutex = mutex;
        }

        SynchronizedMap(Map&lt;K, V&gt; map) {
            this(map, new Object());
        }

        @Override
        public int size() {
            synchronized (mutex) {
                return backingMap.size();
            }
        }

        @Override
        public boolean isEmpty() {
            synchronized (mutex) {
                return backingMap.isEmpty();
            }
        }

        @Override
        public boolean containsKey(Object key) {
            synchronized (mutex) {
                return backingMap.containsKey(key);
            }
        }

        @Override
        public boolean containsValue(Object value) {
            synchronized (mutex) {
                return backingMap.containsValue(value);
            }
        }

        @Override
        public V get(Object key) {
            synchronized (mutex) {
                return backingMap.get(key);
            }
        }

        @Override
        public V put(K key, V value) {
            synchronized (mutex) {
                return backingMap.put(key, value);
            }
        }

        @Override
        public V remove(Object key) {
            synchronized (mutex) {
                return backingMap.remove(key);
            }
        }

        @Override
        public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
            synchronized (mutex) {
                backingMap.putAll(m);
            }
        }

        @Override
        public void clear() {
            synchronized (mutex) {
                backingMap.clear();
            }
        }

        private transient Set&lt;K&gt; keySet = null;
        private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null;
        private transient Collection&lt;V&gt; values = null;

        @Override
        public Set&lt;K&gt; keySet() {
            synchronized(mutex) {
                if (keySet==null)
                    keySet = new SynchronizedSet&lt;K&gt;(backingMap.keySet(), mutex);
                return keySet;
            }
        }

        @Override
        public Collection&lt;V&gt; values() {
            synchronized(mutex) {
                if (values==null)
                    values = new SynchronizedCollection&lt;V&gt;(backingMap.values(), mutex);
                return values;
            }
        }

        @Override
        public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
            synchronized(mutex) {
                if (entrySet==null)
                    entrySet = new SynchronizedSet&lt;Map.Entry&lt;K,V&gt;&gt;(backingMap.entrySet(), mutex);
                return entrySet;
            }
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            synchronized(mutex) {
                return backingMap.equals(o);
            }
        }

        @Override
        public int hashCode() {
            synchronized(mutex) {
                return backingMap.hashCode();
            }
        }

    }

    private static class SynchronizedCollection&lt;E&gt; implements Collection&lt;E&gt; {

        private final Collection&lt;E&gt; backingCollection;
        final Object mutex;

        SynchronizedCollection(Collection&lt;E&gt; c, Object mutex) {
            backingCollection = c;
            this.mutex = mutex;
        }

        SynchronizedCollection(Collection&lt;E&gt; c) {
            this(c, new Object());
        }

        @Override
        public int size() {
            synchronized (mutex) {
                return backingCollection.size();
            }
        }

        @Override
        public boolean isEmpty() {
            synchronized (mutex) {
                return backingCollection.isEmpty();
            }
        }

        @Override
        public boolean contains(Object o) {
            synchronized (mutex) {
                return backingCollection.contains(o);
            }
        }

        @Override
        public Iterator&lt;E&gt; iterator() {
            return backingCollection.iterator();
        }

        @Override
        public Object[] toArray() {
            synchronized (mutex) {
                return backingCollection.toArray();
            }
        }

        @Override
        public &lt;T&gt; T[] toArray(T[] a) {
            synchronized (mutex) {
                return backingCollection.toArray(a);
            }
        }

        @Override
        public boolean add(E e) {
            synchronized (mutex) {
                return backingCollection.add(e);
            }
        }

        @Override
        public boolean remove(Object o) {
            synchronized (mutex) {
                return backingCollection.remove(o);
            }
        }

        @Override
        public boolean containsAll(Collection&lt;?&gt; c) {
            synchronized (mutex) {
                return backingCollection.containsAll(c);
            }
        }

        @Override
        public boolean addAll(Collection&lt;? extends E&gt; c) {
            synchronized (mutex) {
                return backingCollection.addAll(c);
            }
        }

        @Override
        public boolean removeAll(Collection&lt;?&gt; c) {
            synchronized (mutex) {
                return backingCollection.removeAll(c);
            }
        }

        @Override
        public boolean retainAll(Collection&lt;?&gt; c) {
            synchronized (mutex) {
                return backingCollection.retainAll(c);
            }
        }

        @Override
        public void clear() {
            synchronized (mutex) {
                backingCollection.clear();
            }
        }
    }

    private static class SynchronizedObservableMap&lt;K, V&gt; extends SynchronizedMap&lt;K, V&gt; implements ObservableMap&lt;K, V&gt; {

        private final ObservableMap&lt;K, V&gt; backingMap;
        private MapListenerHelper listenerHelper;
        private final MapChangeListener&lt;K, V&gt; listener;

        SynchronizedObservableMap(ObservableMap&lt;K, V&gt; map, Object mutex) {
            super(map, mutex);
            backingMap = map;
            listener = c -&gt; {
                MapListenerHelper.fireValueChangedEvent(listenerHelper, new MapAdapterChange&lt;K, V&gt;(SynchronizedObservableMap.this, c));
            };
            backingMap.addListener(new WeakMapChangeListener&lt;K, V&gt;(listener));
        }

        SynchronizedObservableMap(ObservableMap&lt;K, V&gt; map) {
            this(map, new Object());
        }

        @Override
        public void addListener(InvalidationListener listener) {
            synchronized (mutex) {
                listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
            }
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            synchronized (mutex) {
                listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
            }
        }

        @Override
        public void addListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
            synchronized (mutex) {
                listenerHelper = MapListenerHelper.addListener(listenerHelper, listener);
            }
        }

        @Override
        public void removeListener(MapChangeListener&lt;? super K, ? super V&gt; listener) {
            synchronized (mutex) {
                listenerHelper = MapListenerHelper.removeListener(listenerHelper, listener);
            }
        }

    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/DatePickerContent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import java.time.DateTimeException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DecimalStyle;
import java.time.chrono.Chronology;
import java.time.chrono.ChronoLocalDate;
import java.time.temporal.ChronoUnit;
import java.time.temporal.ValueRange;
import java.time.temporal.WeekFields;
import java.time.YearMonth;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import static java.time.temporal.ChronoField.*;
import static java.time.temporal.ChronoUnit.*;

import com.sun.javafx.scene.control.skin.*;
import javafx.application.Platform;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.WeakChangeListener;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.DatePicker;
import javafx.scene.control.DateCell;
import javafx.scene.control.Label;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.layout.StackPane;

import com.sun.javafx.scene.control.skin.resources.ControlResources;
import com.sun.javafx.scene.traversal.Direction;

import static com.sun.javafx.PlatformUtil.*;
import com.sun.javafx.scene.NodeHelper;

/**
 * The full content for the DatePicker popup. This class could
 * probably be used more or less as-is with an embeddable type of date
 * picker that doesn't use a popup.
 */
public class DatePickerContent extends VBox {
    protected DatePicker datePicker;
    private Button backMonthButton;
    private Button forwardMonthButton;
    private Button backYearButton;
    private Button forwardYearButton;
    private Label monthLabel;
    private Label yearLabel;
    protected GridPane gridPane;

    private int daysPerWeek;
    private List&lt;DateCell&gt; dayNameCells = new ArrayList&lt;DateCell&gt;();
    private List&lt;DateCell&gt; weekNumberCells = new ArrayList&lt;DateCell&gt;();
    protected List&lt;DateCell&gt; dayCells = new ArrayList&lt;DateCell&gt;();
    private LocalDate[] dayCellDates;
    private DateCell lastFocusedDayCell = null;

    final DateTimeFormatter monthFormatter =
        DateTimeFormatter.ofPattern(&quot;MMMM&quot;);

    final DateTimeFormatter monthFormatterSO =
            DateTimeFormatter.ofPattern(&quot;LLLL&quot;); // Standalone month name

    final DateTimeFormatter yearFormatter =
        DateTimeFormatter.ofPattern(&quot;y&quot;);

    final DateTimeFormatter yearWithEraFormatter =
        DateTimeFormatter.ofPattern(&quot;GGGGy&quot;); // For Japanese. What to use for others??

    final DateTimeFormatter weekNumberFormatter =
        DateTimeFormatter.ofPattern(&quot;w&quot;);

    final DateTimeFormatter weekDayNameFormatter =
            DateTimeFormatter.ofPattern(&quot;ccc&quot;); // Standalone day name

    final DateTimeFormatter dayCellFormatter =
        DateTimeFormatter.ofPattern(&quot;d&quot;);

    static String getString(String key) {
        return ControlResources.getString(&quot;DatePicker.&quot;+key);
    }

    public DatePickerContent(final DatePicker datePicker) {
        this.datePicker = datePicker;

        getStyleClass().add(&quot;date-picker-popup&quot;);

        daysPerWeek = getDaysPerWeek();

        {
            LocalDate date = datePicker.getValue();
            displayedYearMonth.set((date != null) ? YearMonth.from(date) : YearMonth.now());
        }

        displayedYearMonth.addListener((observable, oldValue, newValue) -&gt; {
            updateValues();
<A NAME="34"></A>        });


        getChildren().add(<FONT color="#827d6b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#34',2,'match51-top.html#34',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>createMonthYearPane());

        gridPane = new GridPane() {
            @Override protected double computePrefWidth(double height) {
                final double width = super.computePrefWidth(height);

                // RT-30903: Make sure width snaps to pixel when divided by
                // number of columns. GridPane doesn't do this with percentage
                // width constraints. See GridPane.adjustColumnWidths().
                final int nCols = daysPerWeek + (datePicker.isShowWeekNumbers() ? 1 : 0)</B></FONT>;
                final double snaphgap = snapSpaceX(getHgap());
                final double left = snapSpaceX(getInsets().getLeft());
                final double right = snapSpaceX(getInsets().getRight());
                final double hgaps = snaphgap * (nCols - 1);
                final double contentWidth = width - left - right - hgaps;
                return ((snapSizeX(contentWidth / nCols)) * nCols) + left + right + hgaps;
            }

            @Override protected void layoutChildren() {
                // Prevent AssertionError in GridPane
                if (getWidth() &gt; 0 &amp;&amp; getHeight() &gt; 0) {
                    super.layoutChildren();
                }
            }
        };
        gridPane.setFocusTraversable(true);
        gridPane.getStyleClass().add(&quot;calendar-grid&quot;);
        gridPane.setVgap(-1);
        gridPane.setHgap(-1);

        // Add a focus owner listener to Scene when it becomes available.
        final WeakChangeListener&lt;Node&gt; weakFocusOwnerListener =
            new WeakChangeListener&lt;Node&gt;((ov2, oldFocusOwner, newFocusOwner) -&gt; {
                if (newFocusOwner == gridPane) {
                    if (oldFocusOwner instanceof DateCell) {
                        // Backwards traversal, skip gridPane.
                        NodeHelper.traverse(gridPane, Direction.PREVIOUS);
                    } else {
                        // Forwards traversal, pass focus to day cell.
                        if (lastFocusedDayCell != null) {
                            Platform.runLater(() -&gt; {
                                lastFocusedDayCell.requestFocus();
                            });
                        } else {
                            clearFocus();
                        }
                    }
                }
            });
        gridPane.sceneProperty().addListener(new WeakChangeListener&lt;Scene&gt;((ov, oldScene, newScene) -&gt; {
            if (oldScene != null) {
                oldScene.focusOwnerProperty().removeListener(weakFocusOwnerListener);
            }
            if (newScene != null) {
                Platform.runLater(() -&gt; {
                    newScene.focusOwnerProperty().addListener(weakFocusOwnerListener);
                });
            }
        }));
        if (gridPane.getScene() != null) {
            gridPane.getScene().focusOwnerProperty().addListener(weakFocusOwnerListener);
        }

        // get the weekday labels starting with the weekday that is the
        // first-day-of-the-week according to the locale in the
        // displayed LocalDate
        for (int i = 0; i &lt; daysPerWeek; i++) {
            DateCell cell = new DateCell();
            cell.getStyleClass().add(&quot;day-name-cell&quot;);
            dayNameCells.add(cell);
        }

        // Week number column
        for (int i = 0; i &lt; 6; i++) {
            DateCell cell = new DateCell();
            cell.getStyleClass().add(&quot;week-number-cell&quot;);
            weekNumberCells.add(cell);
        }

        createDayCells();
        updateGrid();
        getChildren().add(gridPane);

        refresh();

        // RT-30511: This prevents key events from reaching the popup's owner.
        addEventHandler(KeyEvent.ANY, e -&gt; {
            Node node = getScene().getFocusOwner();
            if (node instanceof DateCell) {
                lastFocusedDayCell = (DateCell)node;
            }

            if (e.getEventType() == KeyEvent.KEY_PRESSED) {
                switch (e.getCode()) {
                  case HOME:
                      goToDate(LocalDate.now(), true);
                      e.consume();
                      break;


                  case PAGE_UP:
                      if ((isMac() &amp;&amp; e.isMetaDown()) || (!isMac() &amp;&amp; e.isControlDown())) {
                          if (!backYearButton.isDisabled()) {
                              forward(-1, YEARS, true);
                          }
                      } else {
                          if (!backMonthButton.isDisabled()) {
                              forward(-1, MONTHS, true);
                          }
                      }
                      e.consume();
                      break;

                  case PAGE_DOWN:
                      if ((isMac() &amp;&amp; e.isMetaDown()) || (!isMac() &amp;&amp; e.isControlDown())) {
                          if (!forwardYearButton.isDisabled()) {
                              forward(1, YEARS, true);
                          }
                      } else {
                          if (!forwardMonthButton.isDisabled()) {
                              forward(1, MONTHS, true);
                          }
                      }
                      e.consume();
                      break;
                }

                node = getScene().getFocusOwner();
                if (node instanceof DateCell) {
                    lastFocusedDayCell = (DateCell)node;
                }
            }

            // Consume all key events except those that control
            // showing the popup and traversal.
            switch (e.getCode()) {
              case F4:
              case F10:
              case UP:
              case DOWN:
              case LEFT:
              case RIGHT:
              case TAB:
                    break;

              case ESCAPE:
                datePicker.hide();
                e.consume();
                break;

              default:
                e.consume();
            }
        });
    }

    private ObjectProperty&lt;YearMonth&gt; displayedYearMonth =
        new SimpleObjectProperty&lt;YearMonth&gt;(this, &quot;displayedYearMonth&quot;);

    public ObjectProperty&lt;YearMonth&gt; displayedYearMonthProperty() {
        return displayedYearMonth;
    }


    protected BorderPane createMonthYearPane() {
        BorderPane monthYearPane = new BorderPane();
        monthYearPane.getStyleClass().add(&quot;month-year-pane&quot;);

        // Month spinner

        HBox monthSpinner = new HBox();
        monthSpinner.getStyleClass().add(&quot;spinner&quot;);

        backMonthButton = new Button();
        backMonthButton.getStyleClass().add(&quot;left-button&quot;);

        forwardMonthButton = new Button();
        forwardMonthButton.getStyleClass().add(&quot;right-button&quot;);

        StackPane leftMonthArrow = new StackPane();
        leftMonthArrow.getStyleClass().add(&quot;left-arrow&quot;);
        leftMonthArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        backMonthButton.setGraphic(leftMonthArrow);

        StackPane rightMonthArrow = new StackPane();
        rightMonthArrow.getStyleClass().add(&quot;right-arrow&quot;);
        rightMonthArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        forwardMonthButton.setGraphic(rightMonthArrow);


        backMonthButton.setOnAction(t -&gt; {
            forward(-1, MONTHS, false);
        });

        monthLabel = new Label();
        monthLabel.getStyleClass().add(&quot;spinner-label&quot;);
        monthLabel.fontProperty().addListener((o, ov, nv) -&gt; {
            updateMonthLabelWidth();
        });

        forwardMonthButton.setOnAction(t -&gt; {
            forward(1, MONTHS, false);
        });

        monthSpinner.getChildren().addAll(backMonthButton, monthLabel, forwardMonthButton);
        monthYearPane.setLeft(monthSpinner);

        // Year spinner

        HBox yearSpinner = new HBox();
        yearSpinner.getStyleClass().add(&quot;spinner&quot;);

        backYearButton = new Button();
        backYearButton.getStyleClass().add(&quot;left-button&quot;);

        forwardYearButton = new Button();
        forwardYearButton.getStyleClass().add(&quot;right-button&quot;);

        StackPane leftYearArrow = new StackPane();
        leftYearArrow.getStyleClass().add(&quot;left-arrow&quot;);
        leftYearArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        backYearButton.setGraphic(leftYearArrow);

        StackPane rightYearArrow = new StackPane();
        rightYearArrow.getStyleClass().add(&quot;right-arrow&quot;);
        rightYearArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        forwardYearButton.setGraphic(rightYearArrow);


        backYearButton.setOnAction(t -&gt; {
            forward(-1, YEARS, false);
        });

        yearLabel = new Label();
        yearLabel.getStyleClass().add(&quot;spinner-label&quot;);

        forwardYearButton.setOnAction(t -&gt; {
            forward(1, YEARS, false);
        });

        yearSpinner.getChildren().addAll(backYearButton, yearLabel, forwardYearButton);
        yearSpinner.setFillHeight(false);
        monthYearPane.setRight(yearSpinner);

        return monthYearPane;
    }

    private void refresh() {
        updateMonthLabelWidth();
        updateDayNameCells();
        updateValues();
    }

    public void updateValues() {
        // Note: Preserve this order, as DatePickerHijrahContent needs
        // updateDayCells before updateMonthYearPane().
        updateWeeknumberDateCells();
        updateDayCells();
        updateMonthYearPane();
    }

    public void updateGrid() {
        gridPane.getColumnConstraints().clear();
        gridPane.getChildren().clear();

        int nCols = daysPerWeek + (datePicker.isShowWeekNumbers() ? 1 : 0);

        ColumnConstraints columnConstraints = new ColumnConstraints();
        columnConstraints.setPercentWidth(100); // Treated as weight
        for (int i = 0; i &lt; nCols; i++) {
            gridPane.getColumnConstraints().add(columnConstraints);
        }

        for (int i = 0; i &lt; daysPerWeek; i++) {
            gridPane.add(dayNameCells.get(i), i + nCols - daysPerWeek, 1);  // col, row
        }

        // Week number column
        if (datePicker.isShowWeekNumbers()) {
            for (int i = 0; i &lt; 6; i++) {
                gridPane.add(weekNumberCells.get(i), 0, i + 2);  // col, row
            }
        }

        // setup: 6 rows of daysPerWeek (which is the maximum number of cells required in the worst case layout)
        for (int row = 0; row &lt; 6; row++) {
            for (int col = 0; col &lt; daysPerWeek; col++) {
                gridPane.add(dayCells.get(row*daysPerWeek+col), col + nCols - daysPerWeek, row + 2);
            }
        }
    }

    public void updateDayNameCells() {
        // first day of week, 1 = monday, 7 = sunday
        int firstDayOfWeek = WeekFields.of(getLocale()).getFirstDayOfWeek().getValue();

        // july 13th 2009 is a Monday, so a firstDayOfWeek=1 must come out of the 13th
        LocalDate date = LocalDate.of(2009, 7, 12 + firstDayOfWeek);
        for (int i = 0; i &lt; daysPerWeek; i++) {
            String name = weekDayNameFormatter.withLocale(getLocale()).format(date.plus(i, DAYS));
            dayNameCells.get(i).setText(titleCaseWord(name));
        }
    }

    public void updateWeeknumberDateCells() {
        if (datePicker.isShowWeekNumbers()) {
            final Locale locale = getLocale();
            final int maxWeeksPerMonth = 6; // TODO: Get this from chronology?

            LocalDate firstOfMonth = displayedYearMonth.get().atDay(1);
            for (int i = 0; i &lt; maxWeeksPerMonth; i++) {
                LocalDate date = firstOfMonth.plus(i, WEEKS);
                // Use a formatter to ensure correct localization,
                // such as when Thai numerals are required.
                String cellText =
                    weekNumberFormatter.withLocale(locale)
                                       .withDecimalStyle(DecimalStyle.of(locale))
                                       .format(date);
                weekNumberCells.get(i).setText(cellText);
            }
        }
    }

    public void updateDayCells() {
        Locale locale = getLocale();
        Chronology chrono = getPrimaryChronology();
        int firstOfMonthIdx = determineFirstOfMonthDayOfWeek();
        YearMonth curMonth = displayedYearMonth.get();

        // RT-31075: The following are now set in the try-catch block.
        YearMonth prevMonth = null;
        YearMonth nextMonth = null;
        int daysInCurMonth = -1;
        int daysInPrevMonth = -1;
        int daysInNextMonth = -1;

        for (int i = 0; i &lt; 6 * daysPerWeek; i++) {
            DateCell dayCell = dayCells.get(i);
            dayCell.getStyleClass().setAll(&quot;cell&quot;, &quot;date-cell&quot;, &quot;day-cell&quot;);
            dayCell.setDisable(false);
            dayCell.setStyle(null);
            dayCell.setGraphic(null);
            dayCell.setTooltip(null);

            try {
                if (daysInCurMonth == -1) {
                    daysInCurMonth = curMonth.lengthOfMonth();
                }
                YearMonth month = curMonth;
                int day = i - firstOfMonthIdx + 1;
                //int index = firstOfMonthIdx + i - 1;
                if (i &lt; firstOfMonthIdx) {
                    if (prevMonth == null) {
                        prevMonth = curMonth.minusMonths(1);
                        daysInPrevMonth = prevMonth.lengthOfMonth();
                    }
                    month = prevMonth;
                    day = i + daysInPrevMonth - firstOfMonthIdx + 1;
                    dayCell.getStyleClass().add(&quot;previous-month&quot;);
                } else if (i &gt;= firstOfMonthIdx + daysInCurMonth) {
                    if (nextMonth == null) {
                        nextMonth = curMonth.plusMonths(1);
                        daysInNextMonth = nextMonth.lengthOfMonth();
                    }
                    month = nextMonth;
                    day = i - daysInCurMonth - firstOfMonthIdx + 1;
                    dayCell.getStyleClass().add(&quot;next-month&quot;);
                }
                LocalDate date = month.atDay(day);
                dayCellDates[i] = date;
                ChronoLocalDate cDate = chrono.date(date);

                dayCell.setDisable(false);

                if (isToday(date)) {
                    dayCell.getStyleClass().add(&quot;today&quot;);
                }

                if (date.equals(datePicker.getValue())) {
                    dayCell.getStyleClass().add(&quot;selected&quot;);
                }

                String cellText =
                    dayCellFormatter.withLocale(locale)
                                    .withChronology(chrono)
                                    .withDecimalStyle(DecimalStyle.of(locale))
                                    .format(cDate);
                dayCell.setText(cellText);

                dayCell.updateItem(date, false);
            } catch (DateTimeException ex) {
                // Date is out of range.
                // System.err.println(dayCellDate(dayCell) + &quot; &quot; + ex);
                dayCell.setText(&quot; &quot;);
                dayCell.setDisable(true);
            }
        }
    }

    private int getDaysPerWeek() {
        ValueRange range = getPrimaryChronology().range(DAY_OF_WEEK);
        return (int)(range.getMaximum() - range.getMinimum() + 1);
    }

    private int getMonthsPerYear() {
        ValueRange range = getPrimaryChronology().range(MONTH_OF_YEAR);
        return (int)(range.getMaximum() - range.getMinimum() + 1);
    }

    private void updateMonthLabelWidth() {
        if (monthLabel != null) {
            int monthsPerYear = getMonthsPerYear();
            double width = 0;
            for (int i = 0; i &lt; monthsPerYear; i++) {
                YearMonth yearMonth = displayedYearMonth.get().withMonth(i + 1);
                String name = monthFormatterSO.withLocale(getLocale()).format(yearMonth);
                if (Character.isDigit(name.charAt(0))) {
                    // Fallback. The standalone format returned a number, so use standard format instead.
                    name = monthFormatter.withLocale(getLocale()).format(yearMonth);
                }
                width = Math.max(width, Utils.computeTextWidth(monthLabel.getFont(), name, 0));
            }
            monthLabel.setMinWidth(width);
        }
    }

    protected void updateMonthYearPane() {
        YearMonth yearMonth = displayedYearMonth.get();
        String str = formatMonth(yearMonth);
        monthLabel.setText(str);

        str = formatYear(yearMonth);
        yearLabel.setText(str);
        double width = Utils.computeTextWidth(yearLabel.getFont(), str, 0);
        if (width &gt; yearLabel.getMinWidth()) {
            yearLabel.setMinWidth(width);
        }

        Chronology chrono = datePicker.getChronology();
        LocalDate firstDayOfMonth = yearMonth.atDay(1);
        backMonthButton.setDisable(!isValidDate(chrono, firstDayOfMonth, -1, DAYS));
        forwardMonthButton.setDisable(!isValidDate(chrono, firstDayOfMonth, +1, MONTHS));
        backYearButton.setDisable(!isValidDate(chrono, firstDayOfMonth, -1, YEARS));
        forwardYearButton.setDisable(!isValidDate(chrono, firstDayOfMonth, +1, YEARS));
    }

    private String formatMonth(YearMonth yearMonth) {
        Chronology chrono = getPrimaryChronology();
        try {
            ChronoLocalDate cDate = chrono.date(yearMonth.atDay(1));

            String str = monthFormatterSO.withLocale(getLocale())
                                         .withChronology(chrono)
                                         .format(cDate);
            if (Character.isDigit(str.charAt(0))) {
                // Fallback. The standalone format returned a number, so use standard format instead.
                str = monthFormatter.withLocale(getLocale())
                                    .withChronology(chrono)
                                    .format(cDate);
            }
            return titleCaseWord(str);
        } catch (DateTimeException ex) {
            // Date is out of range.
            return &quot;&quot;;
        }
    }

    private String formatYear(YearMonth yearMonth) {
        Chronology chrono = getPrimaryChronology();
        try {
            DateTimeFormatter formatter = yearFormatter;
            ChronoLocalDate cDate = chrono.date(yearMonth.atDay(1));
            int era = cDate.getEra().getValue();
            int nEras = chrono.eras().size();

            /*if (cDate.get(YEAR) &lt; 0) {
                formatter = yearForNegYearFormatter;
            } else */
            if ((nEras == 2 &amp;&amp; era == 0) || nEras &gt; 2) {
                formatter = yearWithEraFormatter;
            }

            // Fixme: Format Japanese era names with Japanese text.
            String str = formatter.withLocale(getLocale())
                                  .withChronology(chrono)
                                  .withDecimalStyle(DecimalStyle.of(getLocale()))
                                  .format(cDate);

            return str;
        } catch (DateTimeException ex) {
            // Date is out of range.
            return &quot;&quot;;
        }
    }

    // Ensures that month and day names are titlecased (capitalized).
    private String titleCaseWord(String str) {
        if (str.length() &gt; 0) {
            int firstChar = str.codePointAt(0);
            if (!Character.isTitleCase(firstChar)) {
                str = new String(new int[] { Character.toTitleCase(firstChar) }, 0, 1) +
                      str.substring(Character.offsetByCodePoints(str, 0, 1));
            }
        }
        return str;
    }



    /**
     * determine on which day of week idx the first of the months is
     */
    private int determineFirstOfMonthDayOfWeek() {
        // determine with which cell to start
        int firstDayOfWeek = WeekFields.of(getLocale()).getFirstDayOfWeek().getValue();
        int firstOfMonthIdx = displayedYearMonth.get().atDay(1).getDayOfWeek().getValue() - firstDayOfWeek;
        if (firstOfMonthIdx &lt; 0) {
            firstOfMonthIdx += daysPerWeek;
        }
        return firstOfMonthIdx;
    }

    private boolean isToday(LocalDate localDate) {
        return (localDate.equals(LocalDate.now()));
    }

    protected LocalDate dayCellDate(DateCell dateCell) {
        assert (dayCellDates != null);
        return dayCellDates[dayCells.indexOf(dateCell)];
    }

    // public for behavior class
    public void goToDayCell(DateCell dateCell, int offset, ChronoUnit unit, boolean focusDayCell) {
        goToDate(dayCellDate(dateCell).plus(offset, unit), focusDayCell);
    }

    protected void forward(int offset, ChronoUnit unit, boolean focusDayCell) {
        YearMonth yearMonth = displayedYearMonth.get();
        DateCell dateCell = lastFocusedDayCell;
        if (dateCell == null || !dayCellDate(dateCell).getMonth().equals(yearMonth.getMonth())) {
            dateCell = findDayCellForDate(yearMonth.atDay(1));
        }
        goToDayCell(dateCell, offset, unit, focusDayCell);
    }

    // public for behavior class
    public void goToDate(LocalDate date, boolean focusDayCell) {
        if (isValidDate(datePicker.getChronology(), date)) {
            displayedYearMonth.set(YearMonth.from(date));
            if (focusDayCell) {
                findDayCellForDate(date).requestFocus();
            }
        }
    }

    // public for behavior class
    public void selectDayCell(DateCell dateCell) {
        datePicker.setValue(dayCellDate(dateCell));
        datePicker.hide();
    }

    private DateCell findDayCellForDate(LocalDate date) {
        for (int i = 0; i &lt; dayCellDates.length; i++) {
            if (date.equals(dayCellDates[i])) {
                return dayCells.get(i);
            }
        }
        return dayCells.get(dayCells.size()/2+1);
    }

    public void clearFocus() {
        LocalDate focusDate = datePicker.getValue();
        if (focusDate == null) {
            focusDate = LocalDate.now();
        }
        if (YearMonth.from(focusDate).equals(displayedYearMonth.get())) {
            // focus date
            goToDate(focusDate, true);
        } else {
            // focus month spinner (should not happen)
            backMonthButton.requestFocus();
        }

        // RT-31857
        if (backMonthButton.getWidth() == 0) {
            backMonthButton.requestLayout();
            forwardMonthButton.requestLayout();
            backYearButton.requestLayout();
            forwardYearButton.requestLayout();
        }
    }

    protected void createDayCells() {
        final EventHandler&lt;MouseEvent&gt; dayCellActionHandler = ev -&gt; {
            if (ev.getButton() != MouseButton.PRIMARY) {
                return;
            }

            DateCell dayCell = (DateCell)ev.getSource();
            selectDayCell(dayCell);
            lastFocusedDayCell = dayCell;
        };

        for (int row = 0; row &lt; 6; row++) {
            for (int col = 0; col &lt; daysPerWeek; col++) {
                DateCell dayCell = createDayCell();
                dayCell.addEventHandler(MouseEvent.MOUSE_CLICKED, dayCellActionHandler);
                dayCells.add(dayCell);
            }
        }

        dayCellDates = new LocalDate[6 * daysPerWeek];
    }

    private DateCell createDayCell() {
        DateCell cell = null;
        if (datePicker.getDayCellFactory() != null) {
            cell = datePicker.getDayCellFactory().call(datePicker);
        }
        if (cell == null) {
            cell = new DateCell();
        }

        return cell;
    }

    protected Locale getLocale() {
        return Locale.getDefault(Locale.Category.FORMAT);
    }

    /**
     * The primary chronology for display. This may be overridden to
     * be different than the DatePicker chronology. For example
     * DatePickerHijrahContent uses ISO as primary and Hijrah as a
     * secondary chronology.
     */
    protected Chronology getPrimaryChronology() {
        return datePicker.getChronology();
    }

    protected boolean isValidDate(Chronology chrono, LocalDate date, int offset, ChronoUnit unit) {
        if (date != null) {
            try {
                return isValidDate(chrono, date.plus(offset, unit));
            } catch (DateTimeException ex) {
            }
        }
        return false;
    }

    protected boolean isValidDate(Chronology chrono, LocalDate date) {
        try {
            if (date != null) {
                chrono.date(date);
            }
            return true;
        } catch (DateTimeException ex) {
            return false;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/TableColumnSortTypeWrapper.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
<A NAME="0"></A> */
package com.sun.javafx.scene.control;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#0',2,'match51-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import javafx.beans.value.ObservableValue;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableColumn.SortType;
import javafx.scene.control.TableColumnBase;
import javafx.scene.control.TreeTableColumn;

/**
 * Convenience class for dealing with sort types on TableColumn and TreeTableColumn,
 * although note that this will only work whilst TableColumn.SortType is
 * equivalent to TreeTableColumn.SortType. Once they diverge this code will need
 * to be replaced.
 */
public class TableColumnSortTypeWrapper {

    public static boolean isAscending(TableColumnBase&lt;?, ?&gt; column) {
        String sortTypeName = getSortTypeName(column)</B></FONT>;
        return &quot;ASCENDING&quot;.equals(sortTypeName);
    }

    public static boolean isDescending(TableColumnBase&lt;?, ?&gt; column) {
        String sortTypeName = getSortTypeName(column);
        return &quot;DESCENDING&quot;.equals(sortTypeName);
    }

    public static void setSortType(TableColumnBase&lt;?,?&gt; column, SortType sortType) {
        if (column instanceof TableColumn) {
            TableColumn tc = (TableColumn) column;
            tc.setSortType(sortType);
        } else if (column instanceof TreeTableColumn) {
            TreeTableColumn tc = (TreeTableColumn) column;
            if (sortType == SortType.ASCENDING) {
                tc.setSortType(javafx.scene.control.TreeTableColumn.SortType.ASCENDING);
            } else if (sortType == SortType.DESCENDING) {
                tc.setSortType(javafx.scene.control.TreeTableColumn.SortType.DESCENDING);
            } else if (sortType == null) {
                tc.setSortType(null);
            }
        }
    }

    public static String getSortTypeName(TableColumnBase&lt;?,?&gt; column) {
        if (column instanceof TableColumn) {
            TableColumn tc = (TableColumn) column;
            TableColumn.SortType st = tc.getSortType();
            return st == null ? null : st.name();
        } else if (column instanceof TreeTableColumn) {
            TreeTableColumn tc = (TreeTableColumn) column;
            TreeTableColumn.SortType st = tc.getSortType();
            return st == null ? null : st.name();
        }
        return null;
    }

    public static ObservableValue getSortTypeProperty(TableColumnBase&lt;?,?&gt; column) {
        if (column instanceof TableColumn) {
            return ((TableColumn) column).sortTypeProperty();
        } else if (column instanceof TreeTableColumn) {
            return ((TreeTableColumn) column).sortTypeProperty();
        }
        return null;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/ComboBoxBaseBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.scene.control.inputmap.InputMap;
import javafx.beans.Observable;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.scene.Node;
import javafx.scene.control.ComboBox;
import javafx.scene.control.ComboBoxBase;
import javafx.scene.control.DatePicker;
import javafx.scene.control.PopupControl;
import javafx.scene.control.TextField;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.scene.input.*;
import com.sun.javafx.scene.control.inputmap.KeyBinding;

import static javafx.scene.input.KeyCode.*;
import static javafx.scene.input.KeyEvent.*;
import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;
import static com.sun.javafx.scene.control.inputmap.InputMap.MouseMapping;

public class ComboBoxBaseBehavior&lt;T&gt; extends BehaviorBase&lt;ComboBoxBase&lt;T&gt;&gt; {

    private final InputMap&lt;ComboBoxBase&lt;T&gt;&gt; inputMap;

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    private TwoLevelFocusComboBehavior tlFocus;

    /**
     *
     */
    public ComboBoxBaseBehavior(final ComboBoxBase&lt;T&gt; comboBox) {
        super(comboBox);

        // create a map for comboBox-specific mappings (this reuses the default
        // InputMap installed on the control, if it is non-null, allowing us to pick up any user-specified mappings)
        inputMap = createInputMap();

        final EventHandler&lt;KeyEvent&gt; togglePopup = e -&gt; {
            // If popup is shown, KeyEvent causes popup to close
            showPopupOnMouseRelease = true;

            if (getNode().isShowing()) hide();
            else show();
        };

        // comboBox-specific mappings for key and mouse input
        KeyMapping enterPressed, enterReleased;
        addDefaultMapping(inputMap,
            new KeyMapping(F4, KEY_RELEASED, togglePopup),
            new KeyMapping(new KeyBinding(UP).alt(), togglePopup),
            new KeyMapping(new KeyBinding(DOWN).alt(), togglePopup),

            new KeyMapping(SPACE, KEY_PRESSED, this::keyPressed),
            new KeyMapping(SPACE, KEY_RELEASED, this::keyReleased),

            enterPressed = new KeyMapping(ENTER, KEY_PRESSED, this::keyPressed),
            enterReleased = new KeyMapping(ENTER, KEY_RELEASED, this::keyReleased),

            // The following keys are forwarded to the parent container
            new KeyMapping(ESCAPE, KEY_PRESSED, this::cancelEdit),
            new KeyMapping(F10,    KEY_PRESSED, this::forwardToParent),

            new MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed),
            new MouseMapping(MouseEvent.MOUSE_RELEASED, this::mouseReleased),
            new MouseMapping(MouseEvent.MOUSE_ENTERED, this::mouseEntered),
            new MouseMapping(MouseEvent.MOUSE_EXITED, this::mouseExited)
        );

        // we don't want to consume events on enter press - let them carry on through
        enterPressed.setAutoConsume(false);
        enterReleased.setAutoConsume(false);

        // ComboBoxBase also cares about focus
        comboBox.focusedProperty().addListener(this::focusChanged);

        // Only add this if we're on an embedded platform that supports 5-button navigation
        if (Utils.isTwoLevelFocus()) {
            tlFocus = new TwoLevelFocusComboBehavior(comboBox); // needs to be last.
        }
    }

    @Override public void dispose() {
        if (tlFocus != null) tlFocus.dispose();
        getNode().focusedProperty().removeListener(this::focusChanged);
        super.dispose();
    }

    @Override public InputMap&lt;ComboBoxBase&lt;T&gt;&gt; getInputMap() {
        return inputMap;
    }

    /***************************************************************************
     *                                                                         *
     * Focus change handling                                                   *
     *                                                                         *
     **************************************************************************/

    protected void focusChanged(Observable o) {
        // If we did have the key down, but are now not focused, then we must
        // disarm the box.
        final ComboBoxBase&lt;T&gt; box = getNode();
        if (keyDown &amp;&amp; !box.isFocused()) {
            keyDown = false;
            box.disarm();
        }
    }

    /***************************************************************************
     *                                                                         *
     * Key event handling                                                      *
     *                                                                         *
     **************************************************************************/

    /**
     * Indicates that a keyboard key has been pressed which represents the
     * event (this could be space bar for example). As long as keyDown is true,
     * we are also armed, and will ignore mouse events related to arming.
     * Note this is made package private solely for the sake of testing.
     */
    private boolean keyDown;

    /**
     * This function is invoked when an appropriate keystroke occurs which
     * causes this button to be armed if it is not already armed by a mouse
     * press.
     */
    private void keyPressed(KeyEvent e) {
        // If popup is shown, KeyEvent causes popup to close
        showPopupOnMouseRelease = true;

        if (Utils.isTwoLevelFocus()) {
            show();
            if (tlFocus != null) {
                tlFocus.setExternalFocus(false);
            }
        }
        else {
            if (! getNode().isPressed() &amp;&amp; ! getNode().isArmed()) {
                keyDown = true;
                getNode().arm();
            }
        }
    }

    /**
     * Invoked when a valid keystroke release occurs which causes the button
     * to fire if it was armed by a keyPress.
     */
    private void keyReleased(KeyEvent e) {
        // If popup is shown, KeyEvent causes popup to close
        showPopupOnMouseRelease = true;

        if (!Utils.isTwoLevelFocus()) {
            if (keyDown) {
                keyDown = false;
                if (getNode().isArmed()) {
                    getNode().disarm();
                }
            }
<A NAME="16"></A>        }
    }

    private void forwardToParent(KeyEvent event) <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#16',2,'match51-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        if (getNode().getParent() != null) {
            getNode().getParent().fireEvent(event);
        }
    }</B></FONT>

    private void cancelEdit(KeyEvent event) {
        /**
         * This can be cleaned up if the editor property is moved up
         * to ComboBoxBase.
         */
        ComboBoxBase comboBoxBase = getNode();
        TextField textField = null;
        if (comboBoxBase instanceof DatePicker) {
            textField = ((DatePicker)comboBoxBase).getEditor();
        } else if (comboBoxBase instanceof ComboBox) {
            textField = comboBoxBase.isEditable() ? ((ComboBox)comboBoxBase).getEditor() : null;
        }

        if (textField != null &amp;&amp; textField.getTextFormatter() != null) {
            textField.cancelEdit();
        } else {
            forwardToParent(event);
        }
    }


    /**************************************************************************
     *                                                                        *
     * Mouse Events                                                           *
     *                                                                        *
     *************************************************************************/

    public void mousePressed(MouseEvent e) {
        arm(e);
    }

    public void mouseReleased(MouseEvent e) {
        disarm();

        // The showPopupOnMouseRelease boolean was added to resolve
        // RT-18151: namely, clicking on the comboBox button shouldn't hide,
        // and then immediately show the popup, which was occurring because we
        // can't know whether the popup auto-hide was coming because of a MOUSE_PRESS
        // since PopupWindow calls hide() before it calls onAutoHide().
        if (showPopupOnMouseRelease) {
            show();
        } else {
            showPopupOnMouseRelease = true;
            hide();
        }
    }

    public void mouseEntered(MouseEvent e) {
        if (!getNode().isEditable()) {
            mouseInsideButton = true;
        } else {
            // This is strongly tied to ComboBoxBaseSkin
            final EventTarget target = e.getTarget();
            mouseInsideButton = (target instanceof Node &amp;&amp; &quot;arrow-button&quot;.equals(((Node) target).getId()));
        }
        arm();
    }

    public void mouseExited(MouseEvent e) {
        mouseInsideButton = false;
        disarm();
    }

//    private void getFocus() {
//        if (! getNode().isFocused() &amp;&amp; getNode().isFocusTraversable()) {
//            getNode().requestFocus();
//        }
//    }

    private void arm(MouseEvent e) {
        boolean valid = (e.getButton() == MouseButton.PRIMARY &amp;&amp;
            ! (e.isMiddleButtonDown() || e.isSecondaryButtonDown() ||
             e.isShiftDown() || e.isControlDown() || e.isAltDown() || e.isMetaDown()));

        if (! getNode().isArmed() &amp;&amp; valid) {
            getNode().arm();
        }
    }

    public void show() {
        if (! getNode().isShowing()) {
            if (getNode().isFocusTraversable()) {
                getNode().requestFocus();
            }
            getNode().show();
        }
    }

    public void hide() {
        if (getNode().isShowing()) {
            getNode().hide();
        }
    }

    private boolean showPopupOnMouseRelease = true;
    private boolean mouseInsideButton = false;
    public void onAutoHide(PopupControl popup) {
        // RT-18151: if the ComboBox button was clicked, and it was this that forced the
        // popup to disappear, we don't want the popup to immediately reappear.
        // If the mouse was not within the comboBox button at the time of the auto-hide occurring,
        // then showPopupOnMouseRelease returns to its default of true; otherwise, it toggles.
        // Note that this logic depends on popup.setAutoHide(true) in ComboBoxPopupControl
        hide();
        showPopupOnMouseRelease = mouseInsideButton ? !showPopupOnMouseRelease : true;
    }

    public void arm() {
        if (getNode().isPressed()) {
            getNode().arm();
        }
    }

    public void disarm() {
        if (! keyDown &amp;&amp; getNode().isArmed()) {
            getNode().disarm();
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/skin/FXVKSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.skin;

import javafx.animation.Animation;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.geometry.VPos;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.SkinBase;
import javafx.scene.control.TextInputControl;
import javafx.scene.control.TextField;
import javafx.scene.control.TextArea;
import javafx.scene.control.ComboBoxBase;
import javafx.scene.Scene;
import javafx.scene.control.skin.TextAreaSkin;
import javafx.scene.input.InputEvent;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.layout.Region;
import javafx.scene.text.Text;
import javafx.stage.Popup;
import javafx.stage.Window;
import javafx.util.Duration;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.HashMap;
import static javafx.scene.input.MouseEvent.MOUSE_PRESSED;
import static javafx.scene.input.TouchEvent.TOUCH_PRESSED;
import static javafx.scene.layout.Region.USE_PREF_SIZE;
import java.security.AccessController;
import java.security.PrivilegedAction;


public class FXVKSkin extends SkinBase&lt;FXVK&gt; {

    private static final int GAP = 6;

    private List&lt;List&lt;Key&gt;&gt; currentBoard;
    private static HashMap&lt;String, List&lt;List&lt;Key&gt;&gt;&gt; boardMap = new HashMap&lt;String, List&lt;List&lt;Key&gt;&gt;&gt;();
    private int numCols;

    private boolean capsDown = false;
    private boolean shiftDown = false;
    private boolean isSymbol = false;
    long lastTime = -1L;

    void clearShift() {
        if (shiftDown &amp;&amp; !capsDown) {
            shiftDown = false;
            updateKeys();
        }
        lastTime = -1L;
    }

    void pressShift() {
        long time = System.currentTimeMillis();

        //potential for a shift lock
        if (shiftDown &amp;&amp; !capsDown) {
            if (lastTime &gt; 0L &amp;&amp; time - lastTime &lt; 400L) {
                //set caps lock
                shiftDown = false;
                capsDown =  true;
            } else {
                //set normal
                shiftDown = false;
                capsDown =  false;
            }
        } else if (!shiftDown &amp;&amp; !capsDown) {
            // set shift
            shiftDown=true;
        } else {
            //set to normal
            shiftDown = false;
            capsDown =  false;
        }

        updateKeys();
        lastTime = time;
    }

    void clearSymbolABC() {
        isSymbol = false;
        updateKeys();
    }

    void pressSymbolABC() {
        isSymbol = !isSymbol;
        updateKeys();
    }

    void clearStateKeys() {
        capsDown = false;
        shiftDown = false;
        isSymbol = false;
        lastTime = -1L;
        updateKeys();
    }

    private void updateKeys() {
        for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {
                key.update(capsDown, shiftDown, isSymbol);
            }
        }
    }

    private static Popup vkPopup;
    private static Popup secondaryPopup;
    private static FXVK primaryVK;

    private static Timeline slideInTimeline = new Timeline();
    private static Timeline slideOutTimeline = new Timeline();
    private static boolean hideAfterSlideOut = false;

    private static FXVK secondaryVK;
    private static Timeline secondaryVKDelay;
    private static CharKey secondaryVKKey;
    private static TextInputKey repeatKey;

    private static Timeline repeatInitialDelay;
    private static Timeline repeatSubsequentDelay;

    // key repeat initial delay (ms)
    private static double KEY_REPEAT_DELAY = 400;
    private static double KEY_REPEAT_DELAY_MIN = 100;
    private static double KEY_REPEAT_DELAY_MAX = 1000;

    // key repeat rate (cps)
    private static double KEY_REPEAT_RATE = 25;
    private static double KEY_REPEAT_RATE_MIN = 2;
    private static double KEY_REPEAT_RATE_MAX = 50;

    private Node attachedNode;
    private String vkType = null;

    FXVK fxvk;

    static final double VK_HEIGHT = 243;
    static final double VK_SLIDE_MILLIS = 250;
    static final double PREF_PORTRAIT_KEY_WIDTH = 40;
    static final double PREF_KEY_HEIGHT = 56;

    static boolean vkAdjustWindow = false;
    static boolean vkLookup = false;

    static {
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            String s = System.getProperty(&quot;com.sun.javafx.vk.adjustwindow&quot;);
            if (s != null) {
                vkAdjustWindow = Boolean.valueOf(s);
            }
            s = System.getProperty(&quot;com.sun.javafx.sqe.vk.lookup&quot;);
            if (s != null) {
                vkLookup = Boolean.valueOf(s);
            }
            s = System.getProperty(&quot;com.sun.javafx.virtualKeyboard.backspaceRepeatDelay&quot;);
            if (s != null) {
                Double delay = Double.valueOf(s);
                KEY_REPEAT_DELAY = Math.min(Math.max(delay, KEY_REPEAT_DELAY_MIN), KEY_REPEAT_DELAY_MAX);
            }
            s = System.getProperty(&quot;com.sun.javafx.virtualKeyboard.backspaceRepeatRate&quot;);
            if (s != null) {
                Double rate = Double.valueOf(s);
                if (rate &lt;= 0) {
                    //disable key repeat
                    KEY_REPEAT_RATE = 0;
                } else {
                    KEY_REPEAT_RATE = Math.min(Math.max(rate, KEY_REPEAT_RATE_MIN), KEY_REPEAT_RATE_MAX);
                }
            }
            return null;
        });
    }

    // Proxy for read-only Window.yProperty() so we can animate.
    private static DoubleProperty winY = new SimpleDoubleProperty();
    static {
        winY.addListener(valueModel -&gt; {
            if (vkPopup != null) {
                vkPopup.setY(winY.get());
            }
        });
    }

    private static void startSlideIn() {
        slideOutTimeline.stop();
        slideInTimeline.playFromStart();
    }

    private static void startSlideOut(boolean doHide) {
        hideAfterSlideOut = doHide;
        slideInTimeline.stop();
        slideOutTimeline.playFromStart();
    }

    private void adjustWindowPosition(final Node node) {
        if ( !(node instanceof TextInputControl) ) {
            return;
        }

        // attached node y position in window coordinates
        double inputControlMinY = node.localToScene(0.0, 0.0).getY() + node.getScene().getY();
        double inputControlHeight = ((TextInputControl) node).getHeight();
        double inputControlMaxY = inputControlMinY + inputControlHeight;

        double screenHeight =
            com.sun.javafx.util.Utils.getScreen(node).getBounds().getHeight();
        double visibleAreaMaxY = screenHeight - VK_HEIGHT;

        double inputLineCenterY = 0.0;
        double inputLineBottomY = 0.0;
        double newWindowYPos = 0.0;
        double screenTopOffset = 10.0;

        if (node instanceof TextField) {
            inputLineCenterY = inputControlMinY + inputControlHeight / 2;
            inputLineBottomY = inputControlMaxY;
            //check for combo box
            Parent parent = attachedNode.getParent();
            if (parent instanceof ComboBoxBase) {
                //combo box
                // position near screen top
                newWindowYPos = Math.min(screenTopOffset - inputControlMinY, 0);
            } else {
                // position at center of visible screen area
                newWindowYPos = Math.min(visibleAreaMaxY / 2 - inputLineCenterY, 0);
            }
        } else if (node instanceof TextArea) {
            TextAreaSkin textAreaSkin = (TextAreaSkin)((TextArea)node).getSkin();
            Bounds caretBounds = textAreaSkin.getCaretBounds();
            double caretMinY = caretBounds.getMinY();
            double caretMaxY = caretBounds.getMaxY();
            inputLineCenterY = inputControlMinY + ( caretMinY + caretMaxY ) / 2;
            inputLineBottomY = inputControlMinY + caretMaxY;

            if (inputControlHeight &lt; visibleAreaMaxY) {
                // position at center of visible screen area
                newWindowYPos = visibleAreaMaxY / 2 - (inputControlMinY + inputControlHeight / 2);
            } else {
                // position the line containing the caret at center of visible screen area
                newWindowYPos = visibleAreaMaxY / 2 - inputLineCenterY;
            }
            newWindowYPos = Math.min(newWindowYPos, 0);

        } else {
            inputLineCenterY = inputControlMinY + inputControlHeight / 2;
            inputLineBottomY = inputControlMaxY;
            // position at center of visible screen area
            newWindowYPos = Math.min(visibleAreaMaxY / 2 - inputLineCenterY, 0);
        }

        Window w = node.getScene().getWindow();
        if (origWindowYPos + inputLineBottomY &gt; visibleAreaMaxY) {
            w.setY(newWindowYPos);
        } else {
            w.setY(origWindowYPos);
        }
    }

    private void saveWindowPosition(final Node node) {
        Window w = node.getScene().getWindow();
        origWindowYPos = w.getY();
    }

    private void restoreWindowPosition(final Node node) {
        if (node != null) {
            Scene scene = node.getScene();
            if (scene != null) {
                Window window = scene.getWindow();
                if (window != null) {
                    window.setY(origWindowYPos);
                }
            }
        }
    }

    EventHandler&lt;InputEvent&gt; unHideEventHandler;

    private boolean isVKHidden = false;
    private Double origWindowYPos = null;

    private void registerUnhideHandler(final Node node) {
        if (unHideEventHandler == null) {
            unHideEventHandler = event -&gt; {
                if (attachedNode != null &amp;&amp; isVKHidden) {
                    double screenHeight = com.sun.javafx.util.Utils.getScreen(attachedNode).getBounds().getHeight();
                    if (fxvk.getHeight() &gt; 0 &amp;&amp; (vkPopup.getY() &gt; screenHeight - fxvk.getHeight())) {
                        if (slideInTimeline.getStatus() != Animation.Status.RUNNING) {
                            startSlideIn();
                            if (vkAdjustWindow) {
                                adjustWindowPosition(attachedNode);
                            }
                        }
                    }
                }
                isVKHidden = false;
            };
        }
        node.addEventHandler(TOUCH_PRESSED, unHideEventHandler);
        node.addEventHandler(MOUSE_PRESSED, unHideEventHandler);
    }

    private void unRegisterUnhideHandler(Node node) {
        if (unHideEventHandler != null) {
            node.removeEventHandler(TOUCH_PRESSED, unHideEventHandler);
            node.removeEventHandler(MOUSE_PRESSED, unHideEventHandler);
        }
    }

    private String getNodeVKType(Node node) {
        Integer vkType = (Integer)node.getProperties().get(FXVK.VK_TYPE_PROP_KEY);
        String typeStr = null;
        if (vkType != null) {
            Object typeValue = FXVK.VK_TYPE_NAMES[vkType];
            if (typeValue instanceof String) {
                typeStr = ((String)typeValue).toLowerCase(Locale.ROOT);
            }
        }
        return (typeStr != null ? typeStr : &quot;text&quot;);
    }

    private void updateKeyboardType(Node node) {
        String oldType = vkType;
        vkType = getNodeVKType(node);
        //VK type changed, rebuild
        if ( oldType == null || !vkType.equals(oldType) ) {
            rebuildPrimaryVK(vkType);
        }
    }

    private void closeSecondaryVK() {
        if (secondaryVK != null) {
            secondaryVK.setAttachedNode(null);
            secondaryPopup.hide();
        }
    }

    private void setupPrimaryVK() {
        fxvk.setFocusTraversable(false);
        fxvk.setVisible(true);

        // init popup window and slide animations
        if (vkPopup == null) {
            vkPopup = new Popup();
            vkPopup.setAutoFix(false);
        }
        vkPopup.getContent().setAll(fxvk);

        double screenHeight =
            com.sun.javafx.util.Utils.getScreen(fxvk).getBounds().getHeight();
        double width = com.sun.javafx.util.Utils.getScreen(fxvk).getBounds().getWidth();

        //Setup VK slide animations
        slideInTimeline.getKeyFrames().setAll(
            new KeyFrame(Duration.millis(VK_SLIDE_MILLIS),
                         new KeyValue(winY, screenHeight - VK_HEIGHT,
                                      Interpolator.EASE_BOTH)));
        slideOutTimeline.getKeyFrames().setAll(
            new KeyFrame(Duration.millis(VK_SLIDE_MILLIS),
                    event -&gt; {
                        if (hideAfterSlideOut &amp;&amp; vkPopup.isShowing()) {
                            vkPopup.hide();
                        }
                    },
                new KeyValue(winY, screenHeight, Interpolator.EASE_BOTH)));

        //Set VK size
        fxvk.setPrefWidth(width);
        fxvk.setMinWidth(USE_PREF_SIZE);
        fxvk.setMaxWidth(USE_PREF_SIZE);

        fxvk.setPrefHeight(VK_HEIGHT);
        fxvk.setMinHeight(USE_PREF_SIZE);


        //set up long-press triger for secondary VK
        if (secondaryVKDelay == null) {
            secondaryVKDelay = new Timeline();
        }
        KeyFrame kf = new KeyFrame(Duration.millis(500), event -&gt; {
            if (secondaryVKKey != null) {
                showSecondaryVK(secondaryVKKey);
            }
        });
        secondaryVKDelay.getKeyFrames().setAll(kf);

        //Setup key repeat animations
        if (KEY_REPEAT_RATE &gt; 0) {
            repeatInitialDelay = new Timeline(new KeyFrame(
                    Duration.millis(KEY_REPEAT_DELAY),
                    event -&gt; {
                        //fire current key
                        repeatKey.sendKeyEvents();
                        //Start repeat animation
                        repeatSubsequentDelay.playFromStart();
                    }
            ));
            repeatSubsequentDelay = new Timeline(new KeyFrame(
                    Duration.millis(1000.0 / KEY_REPEAT_RATE),
                    event -&gt; {
                        //fire current key
                        repeatKey.sendKeyEvents();
                    }
            ));
            repeatSubsequentDelay.setCycleCount(Animation.INDEFINITE);
        }
    }

    void prerender(Node node) {
        if (fxvk != primaryVK) {
            return;
        }

        //Preload all boards
        loadBoard(&quot;text&quot;);
        loadBoard(&quot;numeric&quot;);
        loadBoard(&quot;url&quot;);
        loadBoard(&quot;email&quot;);

        updateKeyboardType(node);
        fxvk.setVisible(true);

        if (!vkPopup.isShowing()) {
            Rectangle2D screenBounds =
                com.sun.javafx.util.Utils.getScreen(node).getBounds();

            vkPopup.setX((screenBounds.getWidth() - fxvk.prefWidth(-1)) / 2);
            winY.set(screenBounds.getHeight());
            vkPopup.show(node.getScene().getWindow());
        }
    }

    public FXVKSkin(final FXVK fxvk) {
        super(fxvk);
        this.fxvk = fxvk;
        if (fxvk == FXVK.vk) {
            primaryVK = fxvk;
        }

        if (fxvk == primaryVK) {
            setupPrimaryVK();
        }

        fxvk.attachedNodeProperty().addListener(new InvalidationListener() {
            @Override public void invalidated(Observable valueModel) {
                Node oldNode = attachedNode;
                attachedNode = fxvk.getAttachedNode();
                if (fxvk != primaryVK) {
                    return;
                }

                closeSecondaryVK();

                if (attachedNode != null) {
                    if (oldNode != null) {
                        unRegisterUnhideHandler(oldNode);
                    }
                    registerUnhideHandler(attachedNode);
                    updateKeyboardType(attachedNode);

                    //owner window has changed so hide VK and show with new owner
                    if (oldNode == null || oldNode.getScene() == null || oldNode.getScene().getWindow() != attachedNode.getScene().getWindow()) {
                        if (vkPopup.isShowing()) {
                            vkPopup.hide();
                        } else {
                        }
                    }

                    if (!vkPopup.isShowing()) {
                        Rectangle2D screenBounds =
                            com.sun.javafx.util.Utils.getScreen(attachedNode).getBounds();

                        vkPopup.setX((screenBounds.getWidth() - fxvk.prefWidth(-1)) / 2);
                        if (oldNode == null || isVKHidden) {
                            //position off screen
                            winY.set(screenBounds.getHeight());
                        } else {
                            //position on screen (no slide in)
                            winY.set(screenBounds.getHeight() - VK_HEIGHT);
                        }
                        vkPopup.show(attachedNode.getScene().getWindow());
                    }

                    if (oldNode == null || isVKHidden) {
                        startSlideIn();
                    }

                    if (vkAdjustWindow) {
                        //update previous window position only if moving from non-input control node or window has changed.
                        if (oldNode == null || oldNode.getScene() == null
                            || oldNode.getScene().getWindow() != attachedNode.getScene().getWindow()) {
                            saveWindowPosition(attachedNode);
                        }
                        // Move window containing input node
                        adjustWindowPosition(attachedNode);
                    }
                } else { // attachedNode == null
                    if (oldNode != null) {
                        unRegisterUnhideHandler(oldNode);
                    }
                    startSlideOut(true);
                    // Restore window position
                    if (vkAdjustWindow) {
                        restoreWindowPosition(oldNode);
                    }
                }
                isVKHidden = false;
            }
        });
    }

    /**
     * builds secondary (long-press) VK
     */
    private void rebuildSecondaryVK() {
        if (secondaryVK.chars == null) {
        } else {
            int nKeys = secondaryVK.chars.length;
            int nRows = (int)Math.floor(Math.sqrt(Math.max(1, nKeys - 2)));
            int nKeysPerRow = (int)Math.ceil(nKeys / (double)nRows);

            Key tmpKey;
            List&lt;List&lt;Key&gt;&gt; rows = new ArrayList&lt;List&lt;Key&gt;&gt;(2);

            for (int i = 0; i &lt; nRows; i++) {
                int start = i * nKeysPerRow;
                int end = Math.min(start + nKeysPerRow, nKeys);
                if (start &gt;= end)
                    break;

                List&lt;Key&gt; keys = new ArrayList&lt;Key&gt;(nKeysPerRow);
                for (int j = start; j &lt; end; j++) {
                    tmpKey = new CharKey(secondaryVK.chars[j], null, null);
                    tmpKey.col= (j - start) * 2;
                    tmpKey.colSpan = 2;
                    for (String sc : tmpKey.getStyleClass()) {
                        tmpKey.text.getStyleClass().add(sc + &quot;-text&quot;);
                        tmpKey.altText.getStyleClass().add(sc + &quot;-alttext&quot;);
                        tmpKey.icon.getStyleClass().add(sc + &quot;-icon&quot;);
                    }
                    if (secondaryVK.chars[j] != null &amp;&amp; secondaryVK.chars[j].length() &gt; 1) {
                        tmpKey.text.getStyleClass().add(&quot;multi-char-text&quot;);
                    }
                    keys.add(tmpKey);
                }
                rows.add(keys);
            }
            currentBoard = rows;

            getChildren().clear();
            numCols = 0;
            for (List&lt;Key&gt; row : currentBoard) {
                for (Key key : row) {
                    numCols = Math.max(numCols, key.col + key.colSpan);
                }
                getChildren().addAll(row);
            }
        }
    }

    /**
     * builds primary VK based on the keyboard
     * type set on the VirtualKeyboard.
     */
    private void rebuildPrimaryVK(String type) {
        currentBoard = loadBoard(type);

        //Clear all state keys and updates current board
        clearStateKeys();

        getChildren().clear();
        numCols = 0;
        for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {
                numCols = Math.max(numCols, key.col + key.colSpan);
            }
            getChildren().addAll(row);
        }
    }

    // This skin is designed such that it gives equal widths to all columns. So
    // the pref width is just some hard-coded value (although I could have maybe
    // done it based on the pref width of a text node with the right font).
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return leftInset + (56 * numCols) + rightInset;
    }

    // Pref height is just some value. This isn't overly important.
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return topInset + (80 * 5) + bottomInset;
    }

    // Lays the buttons comprising the current keyboard out.
    @Override
    protected void layoutChildren(double contentX, double contentY, double contentWidth, double contentHeight) {
        // I have fixed width columns, all the same.
        int numRows = currentBoard.size();
        final double colWidth = ((contentWidth - ((numCols - 1) * GAP)) / numCols);
        double rowHeight = ((contentHeight - ((numRows - 1) * GAP)) / numRows);
        double rowY = contentY;
        for (List&lt;Key&gt; row : currentBoard) {
            for (Key key : row) {
                double startX = contentX + (key.col * (colWidth + GAP));
                double width = (key.colSpan * (colWidth + GAP)) - GAP;
                key.resizeRelocate((int)(startX + .5), (int)(rowY + .5),
                                   width, rowHeight);
            }
            rowY += rowHeight + GAP;
        }
    }


    /**
     * A Key on the virtual keyboard. This is simply a Region. Some information
     * about the key relative to other keys on the layout is given by the col
     * and colSpan fields.
     */
    private class Key extends Region {
        int col = 0;
        int colSpan = 1;
        protected final Text text;
        protected final Text altText;
        protected final Region icon;

        protected Key() {
            icon = new Region();
            text = new Text();
            text.setTextOrigin(VPos.TOP);
            altText = new Text();
            altText.setTextOrigin(VPos.TOP);
            getChildren().setAll(text, altText, icon);
            getStyleClass().setAll(&quot;key&quot;);
            addEventHandler(MouseEvent.MOUSE_PRESSED, event -&gt; {
                if (event.getButton() == MouseButton.PRIMARY)
                    press();
            });
            addEventHandler(MouseEvent.MOUSE_RELEASED, event -&gt; {
                if (event.getButton() == MouseButton.PRIMARY)
                    release();
            });
        }
        protected void press() { }
        protected void release() {
            clearShift();
        }

        public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) { }

        @Override protected void layoutChildren() {
<A NAME="11"></A>            final double left = snappedLeftInset();
            final double top = snappedTopInset();
            final double width = getWidth() - left - snappedRightInset();
            final double height = getHeight() - top - <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#11',2,'match51-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>snappedBottomInset();

            text.setVisible(icon.getBackground() == null);
            double contentPrefWidth = text.prefWidth(-1);
            double contentPrefHeight = text.prefHeight(-1);
            text.resizeRelocate(
                    (int) (left + ((width - contentPrefWidth) / 2) + .5),
                    (int) (top + ((height - contentPrefHeight) / 2) + .5),
                    (int) contentPrefWidth,
                    (int) contentPrefHeight);

            altText.setVisible(icon.getBackground() == null &amp;&amp; altText.getText</B></FONT>().length() &gt; 0);
            contentPrefWidth = altText.prefWidth(-1);
            contentPrefHeight = altText.prefHeight(-1);
            altText.resizeRelocate(
                    (int) left + (width - contentPrefWidth) + .5,
                    (int) (top + ((height - contentPrefHeight) / 2) + .5 - height/2),
                    (int) contentPrefWidth,
                    (int) contentPrefHeight);

            icon.resizeRelocate(left-8, top-8, width+16, height+16);
        }

    }

    /**
     * Any key on the keyboard which will send a KeyEvent to the client. This
     * class just maintains the state and logic for firing an event, using the
     * &quot;chars&quot; and &quot;code&quot; as the values sent in the event. A subclass must set
     * these appropriately.
     */
    private class TextInputKey extends Key {
        String chars = &quot;&quot;;

        protected void press() {
        }
        protected void release() {
            if (fxvk != secondaryVK &amp;&amp; secondaryPopup != null &amp;&amp; secondaryPopup.isShowing()) {
                return;
            }
            sendKeyEvents();
            if (fxvk == secondaryVK) {
                showSecondaryVK(null);
            }
            super.release();
        }

        protected void sendKeyEvents() {
            Node target = fxvk.getAttachedNode();
            if (target instanceof EventTarget) {
                if (chars != null) {
                    target.fireEvent(new KeyEvent(KeyEvent.KEY_TYPED, chars, &quot;&quot;, KeyCode.UNDEFINED, shiftDown, false, false, false));
                }
            }
        }
    }

    /**
     * A key which has a letter, a number or symbol on it
     *
     */
    private class CharKey extends TextInputKey {
        private final String letterChars;
        private final String altChars;
        private final String[] moreChars;

        private CharKey(String letter, String alt, String[] moreChars, String id) {
            this.letterChars = letter;
            this.altChars = alt;
            this.moreChars = moreChars;
            this.chars = this.letterChars;

            text.setText(this.chars);
            altText.setText(this.altChars);
            if (vkLookup) {
                setId((id != null ? id : chars).replaceAll(&quot;\\.&quot;, &quot;&quot;));
            }
        }

        private CharKey(String letter, String alt, String[] moreChars) {
            this(letter, alt, moreChars, null);
        }

        protected void press() {
            super.press();
            if (letterChars.equals(altChars) &amp;&amp; moreChars == null) {
                return;
            }
            if (fxvk == primaryVK) {
                showSecondaryVK(null);
                secondaryVKKey = CharKey.this;
                secondaryVKDelay.playFromStart();
            }
        }

        protected void release() {
            super.release();
            if (letterChars.equals(altChars) &amp;&amp; moreChars == null) {
                return;
            }
            if (fxvk == primaryVK) {
                secondaryVKDelay.stop();
            }
        }

        @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
            if (isSymbol) {
                chars = altChars;
                text.setText(chars);
                if (moreChars != null &amp;&amp; moreChars.length &gt; 0 &amp;&amp; !Character.isLetter(moreChars[0].charAt(0))) {
                    altText.setText(moreChars[0]);
                } else {
                    altText.setText(null);
                }
            } else {
                chars = (capsDown || shiftDown) ? letterChars.toUpperCase() : letterChars.toLowerCase();
                text.setText(chars);
                altText.setText(altChars);
            }
        }
    }

    /**
     * One of several TextInputKeys which have super powers, such as &quot;Tab&quot; and
     * &quot;Return&quot; and &quot;Backspace&quot;. These keys still send events to the client,
     * but may also have additional state related functionality on the keyboard
     * such as the &quot;Shift&quot; key.
     */
    private class SuperKey extends TextInputKey {
        private SuperKey(String letter, String code) {
            this.chars = code;
            text.setText(letter);
            getStyleClass().add(&quot;special&quot;);
            if (vkLookup) {
                setId(letter);
            }
        }
    }

    /**
     * Some keys actually do need to use KeyCode for pressed / released events,
     * and BackSpace is one of them.
     */
    private class KeyCodeKey extends SuperKey {
        private KeyCode code;

        private KeyCodeKey(String letter, String c, KeyCode code) {
            super(letter, c);
            this.code = code;
            if (vkLookup) {
                setId(letter);
            }
        }

        protected void sendKeyEvents() {
            Node target = fxvk.getAttachedNode();
            if (target instanceof EventTarget) {
                target.fireEvent(new KeyEvent(KeyEvent.KEY_PRESSED, KeyEvent.CHAR_UNDEFINED, chars, code, shiftDown, false, false, false));
                target.fireEvent(new KeyEvent(KeyEvent.KEY_TYPED, chars, &quot;&quot;, KeyCode.UNDEFINED, shiftDown, false, false, false));
                target.fireEvent(new KeyEvent(KeyEvent.KEY_RELEASED, KeyEvent.CHAR_UNDEFINED, chars, code, shiftDown, false, false, false));
            }
        }
    }

    /**
     * These keys only manipulate the state of the keyboard and never
     * send key events to the client. For example, &quot;Hide&quot;, &quot;Caps Lock&quot;,
     * etc are all KeyboardStateKeys.
     */
    private class KeyboardStateKey extends Key {
        private final String defaultText;
        private final String toggledText;

        private KeyboardStateKey(String defaultText, String toggledText, String id) {
            this.defaultText = defaultText;
            this.toggledText = toggledText;
            text.setText(this.defaultText);
            if (vkLookup &amp;&amp; id != null) {
                setId(id);
            }
            getStyleClass().add(&quot;special&quot;);
        }

        @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
            //change icon

            if (isSymbol) {
                text.setText(this.toggledText);
            } else {
                text.setText(this.defaultText);
            }
        }
    }

    private void showSecondaryVK(final CharKey key) {
        if (key != null) {
            final Node textInput = primaryVK.getAttachedNode();

            if (secondaryVK == null) {
                secondaryVK = new FXVK();
                //secondaryVK.getStyleClass().addAll(&quot;fxvk-secondary&quot;, &quot;fxvk-portrait&quot;);
                secondaryVK.setSkin(new FXVKSkin(secondaryVK));
                secondaryVK.getStyleClass().setAll(&quot;fxvk-secondary&quot;);
                secondaryPopup = new Popup();
                secondaryPopup.setAutoHide(true);
                secondaryPopup.getContent().add(secondaryVK);
            }

            secondaryVK.chars=null;
            ArrayList&lt;String&gt; secondaryList = new ArrayList&lt;String&gt;();

            // Add primary character
            if (!isSymbol) {
                if (key.letterChars != null &amp;&amp; key.letterChars.length() &gt; 0) {
                    if (shiftDown || capsDown) {
                        secondaryList.add(key.letterChars.toUpperCase());
                    } else {
                        secondaryList.add(key.letterChars);
                    }
                }
            }

            // Add secondary character
            if (key.altChars != null &amp;&amp; key.altChars.length() &gt; 0) {
                if (shiftDown || capsDown) {
                    secondaryList.add(key.altChars.toUpperCase());
                } else {
                    secondaryList.add(key.altChars);
                }
            }

            // Add more letters
            if (key.moreChars != null &amp;&amp; key.moreChars.length &gt; 0) {
                if (isSymbol) {
                    //Add non-letters
                    for (String ch : key.moreChars) {
                        if (!Character.isLetter(ch.charAt(0))) {
                            secondaryList.add(ch);
                        }
                    }
<A NAME="25"></A>                 } else {
                    //Add letters
                    for (String ch : key.moreChars) {
                        <FONT color="#87f717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#25',2,'match51-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (Character.isLetter(ch.charAt(0))) {
                            if (shiftDown || capsDown) {
                                secondaryList.add(ch.toUpperCase());
                            } else {
                                secondaryList.add</B></FONT>(ch);
                            }
                        }
                    }
                }
            }

            boolean isMultiChar = false;
            for (String s : secondaryList) {
                if (s.length() &gt; 1 ) {
                    isMultiChar = true;
                }
            }

            secondaryVK.chars = secondaryList.toArray(new String[secondaryList.size()]);

            if (secondaryVK.chars.length &gt; 1) {
                if (secondaryVK.getSkin() != null) {
                    ((FXVKSkin)secondaryVK.getSkin()).rebuildSecondaryVK();
                }

                secondaryVK.setAttachedNode(textInput);
                FXVKSkin primarySkin = (FXVKSkin)primaryVK.getSkin();
                FXVKSkin secondarySkin = (FXVKSkin)secondaryVK.getSkin();
                //Insets insets = secondarySkin.getInsets();
                int nKeys = secondaryVK.chars.length;
                int nRows = (int)Math.floor(Math.sqrt(Math.max(1, nKeys - 2)));
                int nKeysPerRow = (int)Math.ceil(nKeys / (double)nRows);

                final double w = snappedLeftInset() + snappedRightInset() +
                                 nKeysPerRow * PREF_PORTRAIT_KEY_WIDTH * (isMultiChar ? 2 : 1) + (nKeysPerRow - 1) * GAP;
                final double h = snappedTopInset() + snappedBottomInset() +
                                 nRows * PREF_KEY_HEIGHT + (nRows-1) * GAP;

                secondaryVK.setPrefWidth(w);
                secondaryVK.setMinWidth(USE_PREF_SIZE);
                secondaryVK.setPrefHeight(h);
                secondaryVK.setMinHeight(USE_PREF_SIZE);
                Platform.runLater(() -&gt; {
                    // Position popup on screen
                    Point2D nodePoint =
                        com.sun.javafx.util.Utils.pointRelativeTo(key, w, h, HPos.CENTER, VPos.TOP,
                                                             5, -3, true);
                    double x = nodePoint.getX();
                    double y = nodePoint.getY();
                    Scene scene = key.getScene();
                    x = Math.min(x, scene.getWindow().getX() + scene.getWidth() - w);
                    secondaryPopup.show(key.getScene().getWindow(), x, y);
                });
            }
        } else {
            closeSecondaryVK();
        }
    }


    private List&lt;List&lt;Key&gt;&gt; loadBoard(String type) {
        List&lt;List&lt;Key&gt;&gt; tmpBoard = boardMap.get(type);
        if (tmpBoard != null) {
            return tmpBoard;
        }

        String boardFileName = type.substring(0,1).toUpperCase() + type.substring(1).toLowerCase() + &quot;Board.txt&quot;;
        try {
            tmpBoard = new ArrayList&lt;List&lt;Key&gt;&gt;(5);
            List&lt;Key&gt; keys = new ArrayList&lt;Key&gt;(20);

            InputStream boardFile = FXVKSkin.class.getResourceAsStream(boardFileName);
            BufferedReader reader = new BufferedReader(new InputStreamReader(boardFile, &quot;UTF-8&quot;));
            String line;
            // A pointer to the current column. This will be incremented for every string
            // of text, or space.
            int c = 0;
            // The col at which the key will be placed
            int col = 0;
            // The number of columns that the key will span
            int colSpan = 1;
            // Whether the &quot;chars&quot; is an identifier, like $shift or $SymbolBoard, etc.
            boolean identifier = false;
            // The textual content of the Key
            List&lt;String&gt; charsList = new ArrayList&lt;String&gt;(10);

            while ((line = reader.readLine()) != null) {
                if (line.length() == 0 || line.charAt(0) == '#') {
                    continue;
                }
                // A single line represents a single row of buttons
                for (int i=0; i&lt;line.length(); i++) {
                    char ch = line.charAt(i);

                    // Process the char
                    if (ch == ' ') {
                        c++;
                    } else if (ch == '[') {
                        // Start of a key
                        col = c;
                        charsList = new ArrayList&lt;String&gt;(10);
                        identifier = false;
                    } else if (ch == ']') {
                        String chars = &quot;&quot;;
                        String alt = null;
                        String[] moreChars = null;

                        for (int idx = 0; idx &lt; charsList.size(); idx++) {
                            charsList.set(idx, FXVKCharEntities.get(charsList.get(idx)));
                        }

                        int listSize = charsList.size();
                        if (listSize &gt; 0) {
                            chars = charsList.get(0);
                            if (listSize &gt; 1) {
                                alt = charsList.get(1);
                                if (listSize &gt; 2) {
                                    moreChars = charsList.subList(2, listSize).toArray(new String[listSize - 2]);
                                }
                            }
                        }

                        // End of a key
                        colSpan = c - col;
                        Key key;
                        if (identifier) {
                            if (&quot;$shift&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;&quot;, null, &quot;shift&quot;) {
                                    @Override protected void release() {
                                        pressShift();
                                    }

                                    @Override public void update(boolean capsDown, boolean shiftDown, boolean isSymbol) {
                                        if (isSymbol) {
                                            this.setDisable(true);
                                            this.setVisible(false);
                                        } else {
                                            if (capsDown) {
                                                icon.getStyleClass().remove(&quot;shift-icon&quot;);
                                                icon.getStyleClass().add(&quot;capslock-icon&quot;);
                                            } else {
                                                icon.getStyleClass().remove(&quot;capslock-icon&quot;);
                                                icon.getStyleClass().add(&quot;shift-icon&quot;);
                                            }
                                            this.setDisable(false);
                                            this.setVisible(true);
                                        }
                                    }
                                };
                                key.getStyleClass().add(&quot;shift&quot;);

                            } else if (&quot;$SymbolABC&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;!#123&quot;, &quot;ABC&quot;, &quot;symbol&quot;) {
                                    @Override protected void release() {
                                        pressSymbolABC();
                                    }
                                };
                            } else if (&quot;$backspace&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;backspace&quot;, &quot;\b&quot;, KeyCode.BACK_SPACE) {
                                    @Override protected void press() {
                                        if (KEY_REPEAT_RATE &gt; 0) {
                                            clearShift();
                                            sendKeyEvents();
                                            repeatKey = this;
                                            repeatInitialDelay.playFromStart();
                                        } else {
                                            super.press();
                                        }
                                    }
                                    @Override protected void release() {
                                        if (KEY_REPEAT_RATE &gt; 0) {
                                            repeatInitialDelay.stop();
                                            repeatSubsequentDelay.stop();
                                        } else {
                                            super.release();
                                        }
                                    }
                                };
                                key.getStyleClass().add(&quot;backspace&quot;);
                            } else if (&quot;$enter&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;enter&quot;, &quot;\n&quot;, KeyCode.ENTER);
                                key.getStyleClass().add(&quot;enter&quot;);
                            } else if (&quot;$tab&quot;.equals(chars)) {
                                key = new KeyCodeKey(&quot;tab&quot;, &quot;\t&quot;, KeyCode.TAB);
                            } else if (&quot;$space&quot;.equals(chars)) {
                                key = new CharKey(&quot; &quot;, &quot; &quot;, null, &quot;space&quot;);
                            } else if (&quot;$clear&quot;.equals(chars)) {
                                key = new SuperKey(&quot;clear&quot;, &quot;&quot;);
                            } else if (&quot;$.org&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.org&quot;, &quot;.org&quot;);
                            } else if (&quot;$.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.com&quot;, &quot;.com&quot;);
                            } else if (&quot;$.net&quot;.equals(chars)) {
                                key = new SuperKey(&quot;.net&quot;, &quot;.net&quot;);
                            } else if (&quot;$oracle.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;oracle.com&quot;, &quot;oracle.com&quot;);
                            } else if (&quot;$gmail.com&quot;.equals(chars)) {
                                key = new SuperKey(&quot;gmail.com&quot;, &quot;gmail.com&quot;);
                            } else if (&quot;$hide&quot;.equals(chars)) {
                                key = new KeyboardStateKey(&quot;hide&quot;, null, &quot;hide&quot;) {
                                    @Override protected void release() {
                                        isVKHidden = true;
                                        startSlideOut(false);
                                        // Restore window position
                                        if (vkAdjustWindow) {
                                            restoreWindowPosition(attachedNode);
                                        }
                                    }
                                };
                                key.getStyleClass().add(&quot;hide&quot;);
                            } else if (&quot;$undo&quot;.equals(chars)) {
                                key = new SuperKey(&quot;undo&quot;, &quot;&quot;);
                            } else if (&quot;$redo&quot;.equals(chars)) {
                                key = new SuperKey(&quot;redo&quot;, &quot;&quot;);
                            } else {
                                //Unknown Key
                                key = null;
                            }
                        } else {
                            key = new CharKey(chars, alt, moreChars);
                        }
                        if (key != null) {
                            key.col = col;
                            key.colSpan = colSpan;
                            for (String sc : key.getStyleClass()) {
                                key.text.getStyleClass().add(sc + &quot;-text&quot;);
                                key.altText.getStyleClass().add(sc + &quot;-alttext&quot;);
                                key.icon.getStyleClass().add(sc + &quot;-icon&quot;);
                            }
                            if (chars != null &amp;&amp; chars.length() &gt; 1) {
                                key.text.getStyleClass().add(&quot;multi-char-text&quot;);
                            }
                            if (alt != null &amp;&amp; alt.length() &gt; 1) {
                                key.altText.getStyleClass().add(&quot;multi-char-text&quot;);
                            }

                            keys.add(key);
                        }
                    } else {
                        // Normal textual characters. Read all the way up to the
                        // next ] or space
                        for (int j=i; j&lt;line.length(); j++) {
                            char c2 = line.charAt(j);
                            boolean e = false;
                            if (c2 == '\\') {
                                j++;
                                i++;
                                e = true;
                                c2 = line.charAt(j);
                            }

                            if (c2 == '$' &amp;&amp; !e) {
                                identifier = true;
                            }

                            if (c2 == '|' &amp;&amp; !e) {
                                charsList.add(line.substring(i, j));
                                i = j + 1;
                            } else if ((c2 == ']' || c2 == ' ') &amp;&amp; !e) {
                                charsList.add(line.substring(i, j));
                                i = j-1;
                                break;
                            }
                        }
                        c++;
                    }
                }

                c = 0;
                col = 0;
                tmpBoard.add(keys);
                keys = new ArrayList&lt;Key&gt;(20);
            }
            reader.close();
            boardMap.put(type, tmpBoard);
            return tmpBoard;
        } catch (Exception e) {
            e.printStackTrace();
            return Collections.emptyList();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/skin/WebColorFieldSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.skin;

import java.util.Locale;

import com.sun.javafx.scene.control.WebColorField;
import javafx.beans.InvalidationListener;
import javafx.geometry.NodeOrientation;
import javafx.scene.Node;
import javafx.scene.control.skin.ColorPickerSkin;
import javafx.scene.paint.Color;

/**
 */
public class WebColorFieldSkin extends InputFieldSkin {
    private InvalidationListener integerFieldValueListener;
    private boolean noChangeInValue = false;

    /**
     * Create a new WebColorFieldSkin.
     * @param control The WebColorField
     */
    public WebColorFieldSkin(final WebColorField control) {
        super(control);

        // Whenever the value changes on the control, we need to update the text
        // in the TextField. The only time this is not the case is when the update
        // to the control happened as a result of an update in the text textField.
        control.valueProperty().addListener(integerFieldValueListener = observable -&gt; {
            updateText();
        });

        // RT-37494: Force the major text direction to LTR, so that '#' is always
        // on the left side of the text. A special style is used in CSS to keep
        // the text right-aligned when in RTL mode.
        getTextField().setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
    }

    @Override public WebColorField getSkinnable() {
        return (WebColorField) control;
    }

    @Override public Node getNode() {
        return getTextField();
    }

    /**
     * Called by a Skinnable when the Skin is replaced on the Skinnable. This method
     * allows a Skin to implement any logic necessary to clean up itself after
     * the Skin is no longer needed. It may be used to release native resources.
     * The methods {@link #getSkinnable()} and {@link #getNode()}
     * should return null following a call to dispose. Calling dispose twice
     * has no effect.
     */
    @Override public void dispose() {
        ((WebColorField) control).valueProperty().removeListener(integerFieldValueListener);
        super.dispose();
    }

    //  &quot;^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$&quot;;
    protected boolean accept(String text) {
        if (text.length() == 0) return true;
        if (text.matches(&quot;#[a-fA-F0-9]{0,6}&quot;) || text.matches(&quot;[a-fA-F0-9]{0,6}&quot;)) {
            return true;
        }
        return false;
    }

    protected void updateText() {
        Color color = ((WebColorField) control).getValue();
        if (color == null) color = Color.BLACK;
        getTextField().setText(Utils.formatHexString(color));
    }

    protected void updateValue() {
        if (noChangeInValue) return;
        Color value = ((WebColorField) control).getValue();
        String text = getTextField().getText() == null ? &quot;&quot; : getTextField().getText().trim().toUpperCase(Locale.ROOT);
        if (text.matches(&quot;#[A-F0-9]{6}&quot;) || text.matches(&quot;[A-F0-9]{6}&quot;)) {
<A NAME="27"></A>            try {
                Color newValue = (text.charAt(0) == '#')? Color.web(text) : Color.web(&quot;#&quot;+text);
                if (!newValue.equals(value)) {
                    <FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#27',2,'match51-top.html#27',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>((WebColorField) control).setValue(newValue);
                } else {
                    // calling setText results in updateValue - so we set this flag to true
                    // so that when this is true updateValue simply returns.
                    noChangeInValue = true;
                    getTextField().setText(Utils.formatHexString(newValue));
                    noChangeInValue = false;
                }
            }</B></FONT> catch (java.lang.IllegalArgumentException ex) {
                System.out.println(&quot;Failed to parse [&quot;+text+&quot;]&quot;);
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/AreaChart.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;

import java.util.*;

import javafx.animation.FadeTransition;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.NamedArg;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.scene.AccessibleRole;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.ClosePath;
import javafx.scene.shape.LineTo;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.Path;
import javafx.scene.shape.PathElement;
import javafx.scene.shape.StrokeLineJoin;
import javafx.util.Duration;

import com.sun.javafx.charts.Legend.LegendItem;
import javafx.css.converter.BooleanConverter;
import javafx.beans.property.BooleanProperty;
import javafx.css.CssMetaData;
import javafx.css.Styleable;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableProperty;
import javafx.scene.chart.LineChart.SortingPolicy;

/**
 * AreaChart - Plots the area between the line that connects the data points and
 * the 0 line on the Y axis.
 * @since JavaFX 2.0
 */
public class AreaChart&lt;X,Y&gt; extends XYChart&lt;X,Y&gt; {

    // -------------- PRIVATE FIELDS ------------------------------------------

    /** A multiplier for teh Y values that we store for each series, it is used to animate in a new series */
    private Map&lt;Series&lt;X,Y&gt;, DoubleProperty&gt; seriesYMultiplierMap = new HashMap&lt;&gt;();

    // -------------- PUBLIC PROPERTIES ----------------------------------------

    /**
     * When true, CSS styleable symbols are created for any data items that don't have a symbol node specified.
     * @since JavaFX 8.0
     */
    private BooleanProperty createSymbols = new StyleableBooleanProperty(true) {
        @Override protected void invalidated() {
            for (int seriesIndex=0; seriesIndex &lt; getData().size(); seriesIndex ++) {
                Series&lt;X,Y&gt; series = getData().get(seriesIndex);
                for (int itemIndex=0; itemIndex &lt; series.getData().size(); itemIndex ++) {
                    Data&lt;X,Y&gt; item = series.getData().get(itemIndex);
                    Node symbol = item.getNode();
                    if(get() &amp;&amp; symbol == null) { // create any symbols
                        symbol = createSymbol(series, getData().indexOf(series), item, itemIndex);
                        if (null != symbol) {
                            getPlotChildren().add(symbol);
                        }
                    } else if (!get() &amp;&amp; symbol != null) { // remove symbols
                        getPlotChildren().remove(symbol);
<A NAME="9"></A>                        symbol = null;
                        item.setNode(null);
                    }
                <FONT color="#f88017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#9',2,'match51-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
            }
            requestChartLayout();
        }

        public Object getBean() {
            return this;
        }

        public String getName() {
            return &quot;createSymbols&quot;;
        }

        public CssMeta</B></FONT>Data&lt;AreaChart&lt;?, ?&gt;,Boolean&gt; getCssMetaData() {
            return StyleableProperties.CREATE_SYMBOLS;
        }
    };

    /**
     * Indicates whether symbols for data points will be created or not.
     *
     * @return true if symbols for data points will be created and false otherwise.
     * @since JavaFX 8.0
     */
    public final boolean getCreateSymbols() { return createSymbols.getValue(); }
    public final void setCreateSymbols(boolean value) { createSymbols.setValue(value); }
    public final BooleanProperty createSymbolsProperty() { return createSymbols; }


    // -------------- CONSTRUCTORS ----------------------------------------------

    /**
     * Construct a new Area Chart with the given axis
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     */
    public AreaChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis) {
        this(xAxis,yAxis, FXCollections.&lt;Series&lt;X,Y&gt;&gt;observableArrayList());
    }

    /**
     * Construct a new Area Chart with the given axis and data
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart
     */
    public AreaChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis, @NamedArg(&quot;data&quot;) ObservableList&lt;Series&lt;X,Y&gt;&gt; data) {
        super(xAxis,yAxis);
        setData(data);
    }

    // -------------- METHODS ------------------------------------------------------------------------------------------

    private static double doubleValue(Number number) { return doubleValue(number, 0); }
    private static double doubleValue(Number number, double nullDefault) {
        return (number == null) ? nullDefault : number.doubleValue();
    }

       /** {@inheritDoc} */
    @Override protected void updateAxisRange() {
        final Axis&lt;X&gt; xa = getXAxis();
        final Axis&lt;Y&gt; ya = getYAxis();
        List&lt;X&gt; xData = null;
        List&lt;Y&gt; yData = null;
        if(xa.isAutoRanging()) xData = new ArrayList&lt;X&gt;();
        if(ya.isAutoRanging()) yData = new ArrayList&lt;Y&gt;();
        if(xData != null || yData != null) {
            for(Series&lt;X,Y&gt; series : getData()) {
                for(Data&lt;X,Y&gt; data: series.getData()) {
                    if(xData != null) xData.add(data.getXValue());
                    if(yData != null) yData.add(data.getYValue());
                }
            }
            if(xData != null &amp;&amp; !(xData.size() == 1 &amp;&amp; getXAxis().toNumericValue(xData.get(0)) == 0)) {
                xa.invalidateRange(xData);
            }
            if(yData != null &amp;&amp; !(yData.size() == 1 &amp;&amp; getYAxis().toNumericValue(yData.get(0)) == 0)) {
                ya.invalidateRange(yData);
            }
        }
    }

    @Override protected void dataItemAdded(Series&lt;X,Y&gt; series, int itemIndex, Data&lt;X,Y&gt; item) {
        final Node symbol = createSymbol(series, getData().indexOf(series), item, itemIndex);
        if (shouldAnimate()) {
            boolean animate = false;
            if (itemIndex &gt; 0 &amp;&amp; itemIndex &lt; (series.getData().size()-1)) {
                animate = true;
                Data&lt;X,Y&gt; p1 = series.getData().get(itemIndex - 1);
                Data&lt;X,Y&gt; p2 = series.getData().get(itemIndex + 1);
                double x1 = getXAxis().toNumericValue(p1.getXValue());
                double y1 = getYAxis().toNumericValue(p1.getYValue());
                double x3 = getXAxis().toNumericValue(p2.getXValue());
                double y3 = getYAxis().toNumericValue(p2.getYValue());

                double x2 = getXAxis().toNumericValue(item.getXValue());
                double y2 = getYAxis().toNumericValue(item.getYValue());

//                //1. y intercept of the line : y = ((y3-y1)/(x3-x1)) * x2 + (x3y1 - y3x1)/(x3 -x1)
                double y = ((y3-y1)/(x3-x1)) * x2 + (x3*y1 - y3*x1)/(x3-x1);
                item.setCurrentY(getYAxis().toRealValue(y));
                item.setCurrentX(getXAxis().toRealValue(x2));
                //2. we can simply use the midpoint on the line as well..
//                double x = (x3 + x1)/2;
//                double y = (y3 + y1)/2;
//                item.setCurrentX(x);
//                item.setCurrentY(y);
            } else if (itemIndex == 0 &amp;&amp; series.getData().size() &gt; 1) {
                animate = true;
                item.setCurrentX(series.getData().get(1).getXValue());
                item.setCurrentY(series.getData().get(1).getYValue());
            } else if (itemIndex == (series.getData().size() - 1) &amp;&amp; series.getData().size() &gt; 1) {
                animate = true;
                int last = series.getData().size() - 2;
                item.setCurrentX(series.getData().get(last).getXValue());
                item.setCurrentY(series.getData().get(last).getYValue());
            }
            if (symbol != null) {
                // fade in new symbol
                symbol.setOpacity(0);
                getPlotChildren().add(symbol);
                FadeTransition ft = new FadeTransition(Duration.millis(500),symbol);
                ft.setToValue(1);
                ft.play();
            }
            if (animate) {
                animate(
                    new KeyFrame(Duration.ZERO,
                            (e) -&gt; {
                                if (symbol != null &amp;&amp; !getPlotChildren().contains(symbol)) {
                                    getPlotChildren().add(symbol);
                                } },
                            new KeyValue(item.currentYProperty(),
                                    item.getCurrentY()),
                            new KeyValue(item.currentXProperty(),
                                    item.getCurrentX())
                    ),
                    new KeyFrame(Duration.millis(800), new KeyValue(item.currentYProperty(),
                                        item.getYValue(), Interpolator.EASE_BOTH),
                                        new KeyValue(item.currentXProperty(),
                                        item.getXValue(), Interpolator.EASE_BOTH))
                );
            }

        } else if (symbol != null) {
            getPlotChildren().add(symbol);
        }
    }

    @Override protected  void dataItemRemoved(final Data&lt;X,Y&gt; item, final Series&lt;X,Y&gt; series) {
        final Node symbol = item.getNode();

        if (symbol != null) {
            symbol.focusTraversableProperty().unbind();
        }

        // remove item from sorted list
        int itemIndex = series.getItemIndex(item);
        if (shouldAnimate()) {
            boolean animate = false;
            // dataSize represents size of currently visible data. After this operation, the number will decrement by 1
            final int dataSize = series.getDataSize();
            // This is the size of current data list in Series. Note that it might be totaly different from dataSize as
            // some big operation might have happened on the list.
            final int dataListSize = series.getData().size();
            if (itemIndex &gt; 0 &amp;&amp; itemIndex &lt; dataSize -1) {
                animate = true;
                Data&lt;X,Y&gt; p1 = series.getItem(itemIndex - 1);
                Data&lt;X,Y&gt; p2 = series.getItem(itemIndex + 1);
                double x1 = getXAxis().toNumericValue(p1.getXValue());
                double y1 = getYAxis().toNumericValue(p1.getYValue());
                double x3 = getXAxis().toNumericValue(p2.getXValue());
                double y3 = getYAxis().toNumericValue(p2.getYValue());

                double x2 = getXAxis().toNumericValue(item.getXValue());
                double y2 = getYAxis().toNumericValue(item.getYValue());

//                //1.  y intercept of the line : y = ((y3-y1)/(x3-x1)) * x2 + (x3y1 - y3x1)/(x3 -x1)
                double y = ((y3-y1)/(x3-x1)) * x2 + (x3*y1 - y3*x1)/(x3-x1);
                item.setCurrentX(getXAxis().toRealValue(x2));
                item.setCurrentY(getYAxis().toRealValue(y2));
                item.setXValue(getXAxis().toRealValue(x2));
                item.setYValue(getYAxis().toRealValue(y));
                //2.  we can simply use the midpoint on the line as well..
//                double x = (x3 + x1)/2;
//                double y = (y3 + y1)/2;
//                item.setCurrentX(x);
//                item.setCurrentY(y);
            } else if (itemIndex == 0 &amp;&amp; dataListSize &gt; 1) {
                animate = true;
                item.setXValue(series.getData().get(0).getXValue());
                item.setYValue(series.getData().get(0).getYValue());
            } else if (itemIndex == (dataSize - 1) &amp;&amp; dataListSize &gt; 1) {
                animate = true;
                int last = dataListSize - 1;
                item.setXValue(series.getData().get(last).getXValue());
                item.setYValue(series.getData().get(last).getYValue());
            } else if (symbol != null) {
                // fade out symbol
                symbol.setOpacity(0);
                FadeTransition ft = new FadeTransition(Duration.millis(500),symbol);
                ft.setToValue(0);
                ft.setOnFinished(actionEvent -&gt; {
                    getPlotChildren().remove(symbol);
                    removeDataItemFromDisplay(series, item);
                });
                ft.play();
            } else {
                item.setSeries(null);
                removeDataItemFromDisplay(series, item);
            }
            if (animate) {
                animate( new KeyFrame(Duration.ZERO, new KeyValue(item.currentYProperty(),
                            item.getCurrentY()), new KeyValue(item.currentXProperty(),
                            item.getCurrentX())),
                            new KeyFrame(Duration.millis(800), actionEvent -&gt; {
                                item.setSeries(null);
                                getPlotChildren().remove(symbol);
                                removeDataItemFromDisplay(series, item);
                            },
                            new KeyValue(item.currentYProperty(),
                            item.getYValue(), Interpolator.EASE_BOTH),
                            new KeyValue(item.currentXProperty(),
                            item.getXValue(), Interpolator.EASE_BOTH))
                );
            }
        } else {
            item.setSeries(null);
            getPlotChildren().remove(symbol);
            removeDataItemFromDisplay(series, item);
        }
        //Note: better animation here, point should move from old position to new position at center point between prev and next symbols
    }

    /** {@inheritDoc} */
    @Override protected void dataItemChanged(Data&lt;X, Y&gt; item) {
    }

    @Override protected void seriesChanged(ListChangeListener.Change&lt;? extends Series&gt; c) {
        // Update style classes for all series lines and symbols
        // Note: is there a more efficient way of doing this?
        for (int i = 0; i &lt; getDataSize(); i++) {
            final Series&lt;X,Y&gt; s = getData().get(i);
            Path seriesLine = (Path)((Group)s.getNode()).getChildren().get(1);
            Path fillPath = (Path)((Group)s.getNode()).getChildren().get(0);
            seriesLine.getStyleClass().setAll(&quot;chart-series-area-line&quot;, &quot;series&quot; + i, s.defaultColorStyleClass);
            fillPath.getStyleClass().setAll(&quot;chart-series-area-fill&quot;, &quot;series&quot; + i, s.defaultColorStyleClass);
            for (int j=0; j &lt; s.getData().size(); j++) {
                final Data&lt;X,Y&gt; item = s.getData().get(j);
                final Node node = item.getNode();
                if(node!=null) node.getStyleClass().setAll(&quot;chart-area-symbol&quot;, &quot;series&quot; + i, &quot;data&quot; + j, s.defaultColorStyleClass);
            }
        }
    }

    @Override protected  void seriesAdded(Series&lt;X,Y&gt; series, int seriesIndex) {
        // create new paths for series
        Path seriesLine = new Path();
        Path fillPath = new Path();
        seriesLine.setStrokeLineJoin(StrokeLineJoin.BEVEL);
        Group areaGroup = new Group(fillPath,seriesLine);
        series.setNode(areaGroup);
        // create series Y multiplier
        DoubleProperty seriesYAnimMultiplier = new SimpleDoubleProperty(this, &quot;seriesYMultiplier&quot;);
        seriesYMultiplierMap.put(series, seriesYAnimMultiplier);
        // handle any data already in series
        if (shouldAnimate()) {
            seriesYAnimMultiplier.setValue(0d);
        } else {
            seriesYAnimMultiplier.setValue(1d);
        }
        getPlotChildren().add(areaGroup);
        List&lt;KeyFrame&gt; keyFrames = new ArrayList&lt;KeyFrame&gt;();
        if (shouldAnimate()) {
            // animate in new series
            keyFrames.add(new KeyFrame(Duration.ZERO,
                new KeyValue(areaGroup.opacityProperty(), 0),
                new KeyValue(seriesYAnimMultiplier, 0)
            ));
            keyFrames.add(new KeyFrame(Duration.millis(200),
               new KeyValue(areaGroup.opacityProperty(), 1)
            ));
            keyFrames.add(new KeyFrame(Duration.millis(500),
                new KeyValue(seriesYAnimMultiplier, 1)
            ));
        }
        for (int j=0; j&lt;series.getData().size(); j++) {
            Data&lt;X,Y&gt; item = series.getData().get(j);
            final Node symbol = createSymbol(series, seriesIndex, item, j);
            if (symbol != null) {
                if (shouldAnimate()) {
                    symbol.setOpacity(0);
                    getPlotChildren().add(symbol);
                    // fade in new symbol
                    keyFrames.add(new KeyFrame(Duration.ZERO, new KeyValue(symbol.opacityProperty(), 0)));
                    keyFrames.add(new KeyFrame(Duration.millis(200), new KeyValue(symbol.opacityProperty(), 1)));
                }
                else {
                    getPlotChildren().add(symbol);
                }
            }
        }
        if (shouldAnimate()) animate(keyFrames.toArray(new KeyFrame[keyFrames.size()]));
    }

    @Override protected  void seriesRemoved(final Series&lt;X,Y&gt; series) {
        // remove series Y multiplier
        seriesYMultiplierMap.remove(series);
        // remove all symbol nodes
        if (shouldAnimate()) {
            Timeline tl = new Timeline(createSeriesRemoveTimeLine(series, 400));
            tl.play();
        } else {
            getPlotChildren().remove(series.getNode());
            for (Data&lt;X,Y&gt; d:series.getData()) getPlotChildren().remove(d.getNode());
            removeSeriesFromDisplay(series);
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutPlotChildren() {
        List&lt;LineTo&gt; constructedPath = new ArrayList&lt;&gt;(getDataSize());
        for (int seriesIndex=0; seriesIndex &lt; getDataSize(); seriesIndex++) {
            Series&lt;X, Y&gt; series = getData().get(seriesIndex);
            DoubleProperty seriesYAnimMultiplier = seriesYMultiplierMap.get(series);
            final ObservableList&lt;Node&gt; children = ((Group) series.getNode()).getChildren();
            Path fillPath = (Path) children.get(0);
            Path linePath = (Path) children.get(1);
            makePaths(this, series, constructedPath, fillPath, linePath,
                      seriesYAnimMultiplier.get(), SortingPolicy.X_AXIS);
        }
    }

    static &lt;X,Y&gt; void makePaths(XYChart&lt;X, Y&gt; chart, Series&lt;X, Y&gt; series,
                                List&lt;LineTo&gt; constructedPath,
                                Path fillPath, Path linePath,
                                double yAnimMultiplier, SortingPolicy sortAxis)
    {
        final Axis&lt;X&gt; axisX = chart.getXAxis();
        final Axis&lt;Y&gt; axisY = chart.getYAxis();
        final double hlw = linePath.getStrokeWidth() / 2.0;
        final boolean sortX = (sortAxis == SortingPolicy.X_AXIS);
        final boolean sortY = (sortAxis == SortingPolicy.Y_AXIS);
        final double dataXMin = sortX ? -hlw : Double.NEGATIVE_INFINITY;
        final double dataXMax = sortX ? axisX.getWidth() + hlw : Double.POSITIVE_INFINITY;
        final double dataYMin = sortY ? -hlw : Double.NEGATIVE_INFINITY;
        final double dataYMax = sortY ? axisY.getHeight() + hlw : Double.POSITIVE_INFINITY;
        LineTo prevDataPoint = null;
        LineTo nextDataPoint = null;
        constructedPath.clear();
        for (Iterator&lt;Data&lt;X, Y&gt;&gt; it = chart.getDisplayedDataIterator(series); it.hasNext(); ) {
            Data&lt;X, Y&gt; item = it.next();
            double x = axisX.getDisplayPosition(item.getCurrentX());
            double y = axisY.getDisplayPosition(
                    axisY.toRealValue(axisY.toNumericValue(item.getCurrentY()) * yAnimMultiplier));
            boolean skip = (Double.isNaN(x) || Double.isNaN(y));
            Node symbol = item.getNode();
            if (symbol != null) {
                final double w = symbol.prefWidth(-1);
                final double h = symbol.prefHeight(-1);
                if (skip) {
                    symbol.resizeRelocate(-w*2, -h*2, w, h);
                } else {
                    symbol.resizeRelocate(x-(w/2), y-(h/2), w, h);
                }
            }
            if (skip) continue;
            if (x &lt; dataXMin || y &lt; dataYMin) {
                if (prevDataPoint == null) {
                    prevDataPoint = new LineTo(x, y);
                } else if ((sortX &amp;&amp; prevDataPoint.getX() &lt;= x) ||
                           (sortY &amp;&amp; prevDataPoint.getY() &lt;= y))
                {
                    prevDataPoint.setX(x);
                    prevDataPoint.setY(y);
                }
            } else if (x &lt;= dataXMax &amp;&amp; y &lt;= dataYMax) {
                constructedPath.add(new LineTo(x, y));
            } else {
                if (nextDataPoint == null) {
                    nextDataPoint = new LineTo(x, y);
                } else if ((sortX &amp;&amp; x &lt;= nextDataPoint.getX()) ||
                           (sortY &amp;&amp; y &lt;= nextDataPoint.getY()))
                {
                    nextDataPoint.setX(x);
                    nextDataPoint.setY(y);
                }
            }
        }

        if (!constructedPath.isEmpty() || prevDataPoint != null || nextDataPoint != null) {
            if (sortX) {
                Collections.sort(constructedPath, (e1, e2) -&gt; Double.compare(e1.getX(), e2.getX()));
            } else if (sortY) {
                Collections.sort(constructedPath, (e1, e2) -&gt; Double.compare(e1.getY(), e2.getY()));
            } else {
                // assert prevDataPoint == null &amp;&amp; nextDataPoint == null
            }
            if (prevDataPoint != null) {
                constructedPath.add(0, prevDataPoint);
            }
            if (nextDataPoint != null) {
                constructedPath.add(nextDataPoint);
            }

            // assert !constructedPath.isEmpty()
            LineTo first = constructedPath.get(0);
            LineTo last = constructedPath.get(constructedPath.size()-1);

            final double displayYPos = first.getY();

            ObservableList&lt;PathElement&gt; lineElements = linePath.getElements();
            lineElements.clear();
            lineElements.add(new MoveTo(first.getX(), displayYPos));
            lineElements.addAll(constructedPath);

            if (fillPath != null) {
                ObservableList&lt;PathElement&gt; fillElements = fillPath.getElements();
                fillElements.clear();
                double yOrigin = axisY.getDisplayPosition(axisY.toRealValue(0.0));

                fillElements.add(new MoveTo(first.getX(), yOrigin));
                fillElements.addAll(constructedPath);
                fillElements.add(new LineTo(last.getX(), yOrigin));
                fillElements.add(new ClosePath());
            }
        }
    }

    private Node createSymbol(Series&lt;X,Y&gt; series, int seriesIndex, final Data&lt;X,Y&gt; item, int itemIndex) {
        Node symbol = item.getNode();
        // check if symbol has already been created
        if (symbol == null &amp;&amp; getCreateSymbols()) {
            symbol = new StackPane();
            symbol.setAccessibleRole(AccessibleRole.TEXT);
            symbol.setAccessibleRoleDescription(&quot;Point&quot;);
            symbol.focusTraversableProperty().bind(Platform.accessibilityActiveProperty());
            item.setNode(symbol);
        }
        // set symbol styles
        // Note: not sure if we want to add or check, ie be more careful and efficient here
        if (symbol != null) symbol.getStyleClass().setAll(&quot;chart-area-symbol&quot;, &quot;series&quot; + seriesIndex, &quot;data&quot; + itemIndex,
                series.defaultColorStyleClass);
        return symbol;
    }

    @Override
    LegendItem createLegendItemForSeries(Series&lt;X, Y&gt; series, int seriesIndex) {
        LegendItem legendItem = new LegendItem(series.getName());
        legendItem.getSymbol().getStyleClass().addAll(&quot;chart-area-symbol&quot;, &quot;series&quot; + seriesIndex,
                &quot;area-legend-symbol&quot;, series.defaultColorStyleClass);
        return legendItem;
    }

    // -------------- STYLESHEET HANDLING --------------------------------------

    private static class StyleableProperties {
        private static final CssMetaData&lt;AreaChart&lt;?,?&gt;,Boolean&gt; CREATE_SYMBOLS =
            new CssMetaData&lt;AreaChart&lt;?,?&gt;,Boolean&gt;(&quot;-fx-create-symbols&quot;,
                BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(AreaChart&lt;?,?&gt; node) {
                return node.createSymbols == null || !node.createSymbols.isBound();
}

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(AreaChart&lt;?,?&gt; node) {
                return (StyleableProperty&lt;Boolean&gt;)node.createSymbolsProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(XYChart.getClassCssMetaData());
            styleables.add(CREATE_SYMBOLS);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/LineChart.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javafx.animation.FadeTransition;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.animation.Animation;
import javafx.application.Platform;
import javafx.beans.NamedArg;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.LineTo;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.Path;
import javafx.scene.shape.PathElement;
import javafx.scene.shape.StrokeLineJoin;
import javafx.util.Duration;

import com.sun.javafx.charts.Legend.LegendItem;

import javafx.css.StyleableBooleanProperty;
import javafx.css.CssMetaData;

import javafx.css.converter.BooleanConverter;

import java.util.*;

import javafx.css.Styleable;
import javafx.css.StyleableProperty;

/**
 * Line Chart plots a line connecting the data points in a series. The data points
 * themselves can be represented by symbols optionally. Line charts are usually used
 * to view data trends over time or category.
 * @since JavaFX 2.0
 */
public class LineChart&lt;X,Y&gt; extends XYChart&lt;X,Y&gt; {

    // -------------- PRIVATE FIELDS ------------------------------------------

    /** A multiplier for the Y values that we store for each series, it is used to animate in a new series */
    private Map&lt;Series&lt;X,Y&gt;, DoubleProperty&gt; seriesYMultiplierMap = new HashMap&lt;&gt;();
    private Timeline dataRemoveTimeline;
    private Series&lt;X,Y&gt; seriesOfDataRemoved = null;
    private Data&lt;X,Y&gt; dataItemBeingRemoved = null;
    private FadeTransition fadeSymbolTransition = null;
    private Map&lt;Data&lt;X,Y&gt;, Double&gt; XYValueMap =
                                new HashMap&lt;Data&lt;X,Y&gt;, Double&gt;();
    private Timeline seriesRemoveTimeline = null;
    // -------------- PUBLIC PROPERTIES ----------------------------------------

    /** When true, CSS styleable symbols are created for any data items that don't have a symbol node specified. */
    private BooleanProperty createSymbols = new StyleableBooleanProperty(true) {
        @Override protected void invalidated() {
            for (int seriesIndex=0; seriesIndex &lt; getData().size(); seriesIndex ++) {
                Series&lt;X,Y&gt; series = getData().get(seriesIndex);
                for (int itemIndex=0; itemIndex &lt; series.getData().size(); itemIndex ++) {
                    Data&lt;X,Y&gt; item = series.getData().get(itemIndex);
                    Node symbol = item.getNode();
                    if(get() &amp;&amp; symbol == null) { // create any symbols
                        symbol = createSymbol(series, getData().indexOf(series), item, itemIndex);
                        getPlotChildren().add(symbol);
                    } else if (!get() &amp;&amp; symbol != null) { // remove symbols
                        getPlotChildren().remove(symbol);
                        symbol = null;
                        item.setNode(null);
                    }
                }
            }
            requestChartLayout();
        }

        public Object getBean() {
            return LineChart.this;
        }

        public String getName() {
            return &quot;createSymbols&quot;;
        }

        public CssMetaData&lt;LineChart&lt;?,?&gt;,Boolean&gt; getCssMetaData() {
            return StyleableProperties.CREATE_SYMBOLS;
        }
    };

    /**
     * Indicates whether symbols for data points will be created or not.
     *
     * @return true if symbols for data points will be created and false otherwise.
     */
    public final boolean getCreateSymbols() { return createSymbols.getValue(); }
    public final void setCreateSymbols(boolean value) { createSymbols.setValue(value); }
    public final BooleanProperty createSymbolsProperty() { return createSymbols; }


    /**
     * Indicates whether the data passed to LineChart should be sorted by natural order of one of the axes.
     * If this is set to {@link SortingPolicy#NONE}, the order in {@link #dataProperty()} will be used.
     *
     * @since JavaFX 8u40
     * @see SortingPolicy
     * @defaultValue SortingPolicy#X_AXIS
     */
    private ObjectProperty&lt;SortingPolicy&gt; axisSortingPolicy = new ObjectPropertyBase&lt;SortingPolicy&gt;(SortingPolicy.X_AXIS) {
        @Override protected void invalidated() {
            requestChartLayout();
        }

        public Object getBean() {
            return LineChart.this;
        }

        public String getName() {
            return &quot;axisSortingPolicy&quot;;
        }

    };

    public final SortingPolicy getAxisSortingPolicy() { return axisSortingPolicy.getValue(); }
    public final void setAxisSortingPolicy(SortingPolicy value) { axisSortingPolicy.setValue(value); }
    public final ObjectProperty&lt;SortingPolicy&gt; axisSortingPolicyProperty() { return axisSortingPolicy; }

    // -------------- CONSTRUCTORS ----------------------------------------------

    /**
     * Construct a new LineChart with the given axis.
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     */
    public LineChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis) {
        this(xAxis, yAxis, FXCollections.&lt;Series&lt;X, Y&gt;&gt;observableArrayList());
    }

    /**
     * Construct a new LineChart with the given axis and data.
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart
     */
    public LineChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis, @NamedArg(&quot;data&quot;) ObservableList&lt;Series&lt;X,Y&gt;&gt; data) {
        super(xAxis,yAxis);
        setData(data);
    }

    // -------------- METHODS ------------------------------------------------------------------------------------------

    /** {@inheritDoc} */
    @Override protected void updateAxisRange() {
        final Axis&lt;X&gt; xa = getXAxis();
        final Axis&lt;Y&gt; ya = getYAxis();
        List&lt;X&gt; xData = null;
        List&lt;Y&gt; yData = null;
        if(xa.isAutoRanging()) xData = new ArrayList&lt;X&gt;();
        if(ya.isAutoRanging()) yData = new ArrayList&lt;Y&gt;();
        if(xData != null || yData != null) {
            for(Series&lt;X,Y&gt; series : getData()) {
                for(Data&lt;X,Y&gt; data: series.getData()) {
                    if(xData != null) xData.add(data.getXValue());
                    if(yData != null) yData.add(data.getYValue());
                }
            }
            // RT-32838 No need to invalidate range if there is one data item - whose value is zero.
            if(xData != null &amp;&amp; !(xData.size() == 1 &amp;&amp; getXAxis().toNumericValue(xData.get(0)) == 0)) {
                xa.invalidateRange(xData);
            }
            if(yData != null &amp;&amp; !(yData.size() == 1 &amp;&amp; getYAxis().toNumericValue(yData.get(0)) == 0)) {
                ya.invalidateRange(yData);
            }

        }
    }

    @Override protected void dataItemAdded(final Series&lt;X,Y&gt; series, int itemIndex, final Data&lt;X,Y&gt; item) {
        final Node symbol = createSymbol(series, getData().indexOf(series), item, itemIndex);
        if (shouldAnimate()) {
            if (dataRemoveTimeline != null &amp;&amp; dataRemoveTimeline.getStatus().equals(Animation.Status.RUNNING)) {
                if (seriesOfDataRemoved == series) {
                    dataRemoveTimeline.stop();
                    dataRemoveTimeline = null;
                    getPlotChildren().remove(dataItemBeingRemoved.getNode());
                    removeDataItemFromDisplay(seriesOfDataRemoved, dataItemBeingRemoved);
                    seriesOfDataRemoved = null;
                    dataItemBeingRemoved = null;
                }
            }
            boolean animate = false;
            if (itemIndex &gt; 0 &amp;&amp; itemIndex &lt; (series.getData().size()-1)) {
                animate = true;
                Data&lt;X,Y&gt; p1 = series.getData().get(itemIndex - 1);
                Data&lt;X,Y&gt; p2 = series.getData().get(itemIndex + 1);
                if (p1 != null &amp;&amp; p2 != null) {
                    double x1 = getXAxis().toNumericValue(p1.getXValue());
                    double y1 = getYAxis().toNumericValue(p1.getYValue());
                    double x3 = getXAxis().toNumericValue(p2.getXValue());
                    double y3 = getYAxis().toNumericValue(p2.getYValue());

                    double x2 = getXAxis().toNumericValue(item.getXValue());
                    //double y2 = getYAxis().toNumericValue(item.getYValue());
                    if (x2 &gt; x1 &amp;&amp; x2 &lt; x3) {
                         //1. y intercept of the line : y = ((y3-y1)/(x3-x1)) * x2 + (x3y1 - y3x1)/(x3 -x1)
                        double y = ((y3-y1)/(x3-x1)) * x2 + (x3*y1 - y3*x1)/(x3-x1);
                        item.setCurrentY(getYAxis().toRealValue(y));
                        item.setCurrentX(getXAxis().toRealValue(x2));
                    } else {
                        //2. we can simply use the midpoint on the line as well..
                        double x = (x3 + x1)/2;
                        double y = (y3 + y1)/2;
                        item.setCurrentX(getXAxis().toRealValue(x));
                        item.setCurrentY(getYAxis().toRealValue(y));
                    }
                }
            } else if (itemIndex == 0 &amp;&amp; series.getData().size() &gt; 1) {
                animate = true;
                item.setCurrentX(series.getData().get(1).getXValue());
                item.setCurrentY(series.getData().get(1).getYValue());
            } else if (itemIndex == (series.getData().size() - 1) &amp;&amp; series.getData().size() &gt; 1) {
                animate = true;
                int last = series.getData().size() - 2;
                item.setCurrentX(series.getData().get(last).getXValue());
                item.setCurrentY(series.getData().get(last).getYValue());
            } else if(symbol != null) {
                // fade in new symbol
                symbol.setOpacity(0);
                getPlotChildren().add(symbol);
                FadeTransition ft = new FadeTransition(Duration.millis(500),symbol);
                ft.setToValue(1);
                ft.play();
            }
            if (animate) {
                animate(
                    new KeyFrame(Duration.ZERO,
                            (e) -&gt; { if (symbol != null &amp;&amp; !getPlotChildren().contains(symbol)) getPlotChildren().add(symbol); },
                                   new KeyValue(item.currentYProperty(),
                                        item.getCurrentY()),
                                        new KeyValue(item.currentXProperty(),
                                        item.getCurrentX())),
                    new KeyFrame(Duration.millis(700), new KeyValue(item.currentYProperty(),
                                        item.getYValue(), Interpolator.EASE_BOTH),
                                        new KeyValue(item.currentXProperty(),
                                        item.getXValue(), Interpolator.EASE_BOTH))
                );
            }

        } else {
            if (symbol != null) getPlotChildren().add(symbol);
        }
    }

    @Override protected  void dataItemRemoved(final Data&lt;X,Y&gt; item, final Series&lt;X,Y&gt; series) {
        final Node symbol = item.getNode();

        if (symbol != null) {
            symbol.focusTraversableProperty().unbind();
        }

        // remove item from sorted list
        int itemIndex = series.getItemIndex(item);
        if (shouldAnimate()) {
            XYValueMap.clear();
            boolean animate = false;
            // dataSize represents size of currently visible data. After this operation, the number will decrement by 1
            final int dataSize = series.getDataSize();
            // This is the size of current data list in Series. Note that it might be totaly different from dataSize as
            // some big operation might have happened on the list.
            final int dataListSize = series.getData().size();
            if (itemIndex &gt; 0 &amp;&amp; itemIndex &lt; dataSize - 1) {
                animate = true;
                Data&lt;X,Y&gt; p1 = series.getItem(itemIndex - 1);
                Data&lt;X,Y&gt; p2 = series.getItem(itemIndex + 1);
                double x1 = getXAxis().toNumericValue(p1.getXValue());
                double y1 = getYAxis().toNumericValue(p1.getYValue());
                double x3 = getXAxis().toNumericValue(p2.getXValue());
<A NAME="23"></A>                double y3 = getYAxis().toNumericValue(p2.getYValue());

                double x2 = getXAxis().toNumericValue(item.getXValue());
                double y2 = <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#23',2,'match51-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getYAxis().toNumericValue(item.getYValue());
                if (x2 &gt; x1 &amp;&amp; x2 &lt; x3) {
//                //1.  y intercept of the line : y = ((y3-y1)/(x3-x1)) * x2 + (x3y1 - y3x1)/(x3 -x1)
                    double y = ((y3-y1)/(x3-x1)) * x2 + (x3*y1 - y3*x1)/(x3-x1);
                    item.setCurrentX(getXAxis().toRealValue(x2));
                    item.setCurrentY(getYAxis().toRealValue(y2));
                    item.setXValue</B></FONT>(getXAxis().toRealValue(x2));
                    item.setYValue(getYAxis().toRealValue(y));
                } else {
                //2.  we can simply use the midpoint on the line as well..
                    double x = (x3 + x1)/2;
                    double y = (y3 + y1)/2;
                    item.setCurrentX(getXAxis().toRealValue(x));
                    item.setCurrentY(getYAxis().toRealValue(y));
                }
            } else if (itemIndex == 0 &amp;&amp; dataListSize &gt; 1) {
                animate = true;
                item.setXValue(series.getData().get(0).getXValue());
                item.setYValue(series.getData().get(0).getYValue());
            } else if (itemIndex == (dataSize - 1) &amp;&amp; dataListSize &gt; 1) {
                animate = true;
                int last = dataListSize - 1;
                item.setXValue(series.getData().get(last).getXValue());
                item.setYValue(series.getData().get(last).getYValue());
            } else if (symbol != null) {
                // fade out symbol
                fadeSymbolTransition = new FadeTransition(Duration.millis(500),symbol);
                fadeSymbolTransition.setToValue(0);
                fadeSymbolTransition.setOnFinished(actionEvent -&gt; {
                    item.setSeries(null);
                    getPlotChildren().remove(symbol);
                    removeDataItemFromDisplay(series, item);
                    symbol.setOpacity(1.0);
                });
                fadeSymbolTransition.play();
            } else {
                item.setSeries(null);
                removeDataItemFromDisplay(series, item);
            }
            if (animate) {
                dataRemoveTimeline = createDataRemoveTimeline(item, symbol, series);
                seriesOfDataRemoved = series;
                dataItemBeingRemoved = item;
                dataRemoveTimeline.play();
            }
        } else {
            item.setSeries(null);
            if (symbol != null) getPlotChildren().remove(symbol);
            removeDataItemFromDisplay(series, item);
        }
        //Note: better animation here, point should move from old position to new position at center point between prev and next symbols
    }

    /** {@inheritDoc} */
    @Override protected void dataItemChanged(Data&lt;X, Y&gt; item) {
    }

    @Override protected void seriesChanged(ListChangeListener.Change&lt;? extends Series&gt; c) {
        // Update style classes for all series lines and symbols
        // Note: is there a more efficient way of doing this?
        for (int i = 0; i &lt; getDataSize(); i++) {
            final Series&lt;X,Y&gt; s = getData().get(i);
            Node seriesNode = s.getNode();
            if (seriesNode != null) seriesNode.getStyleClass().setAll(&quot;chart-series-line&quot;, &quot;series&quot; + i, s.defaultColorStyleClass);
            for (int j=0; j &lt; s.getData().size(); j++) {
                final Node symbol = s.getData().get(j).getNode();
                if (symbol != null) symbol.getStyleClass().setAll(&quot;chart-line-symbol&quot;, &quot;series&quot; + i, &quot;data&quot; + j, s.defaultColorStyleClass);
            }
        }
    }

    @Override protected  void seriesAdded(Series&lt;X,Y&gt; series, int seriesIndex) {
        // create new path for series
        Path seriesLine = new Path();
        seriesLine.setStrokeLineJoin(StrokeLineJoin.BEVEL);
        series.setNode(seriesLine);
        // create series Y multiplier
        DoubleProperty seriesYAnimMultiplier = new SimpleDoubleProperty(this, &quot;seriesYMultiplier&quot;);
        seriesYMultiplierMap.put(series, seriesYAnimMultiplier);
        // handle any data already in series
        if (shouldAnimate()) {
            seriesLine.setOpacity(0);
            seriesYAnimMultiplier.setValue(0d);
        } else {
            seriesYAnimMultiplier.setValue(1d);
        }
        getPlotChildren().add(seriesLine);

        List&lt;KeyFrame&gt; keyFrames = new ArrayList&lt;KeyFrame&gt;();
        if (shouldAnimate()) {
            // animate in new series
            keyFrames.add(new KeyFrame(Duration.ZERO,
                new KeyValue(seriesLine.opacityProperty(), 0),
                new KeyValue(seriesYAnimMultiplier, 0)
            ));
            keyFrames.add(new KeyFrame(Duration.millis(200),
                new KeyValue(seriesLine.opacityProperty(), 1)
            ));
            keyFrames.add(new KeyFrame(Duration.millis(500),
                new KeyValue(seriesYAnimMultiplier, 1)
            ));
        }
        for (int j=0; j&lt;series.getData().size(); j++) {
            Data&lt;X,Y&gt; item = series.getData().get(j);
            final Node symbol = createSymbol(series, seriesIndex, item, j);
            if(symbol != null) {
                if (shouldAnimate()) symbol.setOpacity(0);
                getPlotChildren().add(symbol);
                if (shouldAnimate()) {
                    // fade in new symbol
                    keyFrames.add(new KeyFrame(Duration.ZERO, new KeyValue(symbol.opacityProperty(), 0)));
                    keyFrames.add(new KeyFrame(Duration.millis(200), new KeyValue(symbol.opacityProperty(), 1)));
                }
            }
        }
        if (shouldAnimate()) animate(keyFrames.toArray(new KeyFrame[keyFrames.size()]));
    }

    @Override protected  void seriesRemoved(final Series&lt;X,Y&gt; series) {
        // remove all symbol nodes
        seriesYMultiplierMap.remove(series);
        if (shouldAnimate()) {
            seriesRemoveTimeline = new Timeline(createSeriesRemoveTimeLine(series, 900));
            seriesRemoveTimeline.play();
        } else {
            getPlotChildren().remove(series.getNode());
            for (Data&lt;X,Y&gt; d:series.getData()) getPlotChildren().remove(d.getNode());
            removeSeriesFromDisplay(series);
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutPlotChildren() {
        List&lt;LineTo&gt; constructedPath = new ArrayList&lt;&gt;(getDataSize());
        for (int seriesIndex=0; seriesIndex &lt; getDataSize(); seriesIndex++) {
            Series&lt;X,Y&gt; series = getData().get(seriesIndex);
            final DoubleProperty seriesYAnimMultiplier = seriesYMultiplierMap.get(series);
            final Node seriesNode = series.getNode();
            if (seriesNode instanceof Path) {
                AreaChart.makePaths(this, series,
                                    constructedPath, null, (Path) seriesNode,
                                    seriesYAnimMultiplier.get(), getAxisSortingPolicy());
            }
        }
    }

    /** {@inheritDoc} */
    @Override void dataBeingRemovedIsAdded(Data item, Series series) {
        if (fadeSymbolTransition != null) {
            fadeSymbolTransition.setOnFinished(null);
            fadeSymbolTransition.stop();
        }
        if (dataRemoveTimeline != null) {
            dataRemoveTimeline.setOnFinished(null);
            dataRemoveTimeline.stop();
        }
        final Node symbol = item.getNode();
        if (symbol != null) getPlotChildren().remove(symbol);

        item.setSeries(null);
        removeDataItemFromDisplay(series, item);

        // restore values to item
        Double value = XYValueMap.get(item);
        if (value != null) {
            item.setYValue(value);
            item.setCurrentY(value);
        }
        XYValueMap.clear();
    }
    /** {@inheritDoc} */
    @Override void seriesBeingRemovedIsAdded(Series&lt;X,Y&gt; series) {
        if (seriesRemoveTimeline != null) {
            seriesRemoveTimeline.setOnFinished(null);
            seriesRemoveTimeline.stop();
            getPlotChildren().remove(series.getNode());
            for (Data&lt;X,Y&gt; d:series.getData()) getPlotChildren().remove(d.getNode());
            removeSeriesFromDisplay(series);
        }
    }

    private Timeline createDataRemoveTimeline(final Data&lt;X,Y&gt; item, final Node symbol, final Series&lt;X,Y&gt; series) {
        Timeline t = new Timeline();
        // save data values in case the same data item gets added immediately.
        XYValueMap.put(item, ((Number)item.getYValue()).doubleValue());

        t.getKeyFrames().addAll(new KeyFrame(Duration.ZERO, new KeyValue(item.currentYProperty(),
                item.getCurrentY()), new KeyValue(item.currentXProperty(),
                item.getCurrentX())),
                new KeyFrame(Duration.millis(500), actionEvent -&gt; {
                    if (symbol != null) getPlotChildren().remove(symbol);
                    removeDataItemFromDisplay(series, item);
                    XYValueMap.clear();
                },
                new KeyValue(item.currentYProperty(),
                item.getYValue(), Interpolator.EASE_BOTH),
                new KeyValue(item.currentXProperty(),
                item.getXValue(), Interpolator.EASE_BOTH))
        );
        return t;
    }

    private Node createSymbol(Series&lt;X, Y&gt; series, int seriesIndex, final Data&lt;X,Y&gt; item, int itemIndex) {
        Node symbol = item.getNode();
        // check if symbol has already been created
        if (symbol == null &amp;&amp; getCreateSymbols()) {
            symbol = new StackPane();
            symbol.setAccessibleRole(AccessibleRole.TEXT);
            symbol.setAccessibleRoleDescription(&quot;Point&quot;);
            symbol.focusTraversableProperty().bind(Platform.accessibilityActiveProperty());
            item.setNode(symbol);
        }
        // set symbol styles
        if (symbol != null) symbol.getStyleClass().addAll(&quot;chart-line-symbol&quot;, &quot;series&quot; + seriesIndex,
                &quot;data&quot; + itemIndex, series.defaultColorStyleClass);
        return symbol;
    }

    @Override
    LegendItem createLegendItemForSeries(Series&lt;X, Y&gt; series, int seriesIndex) {
        LegendItem legendItem = new LegendItem(series.getName());
        legendItem.getSymbol().getStyleClass().addAll(&quot;chart-line-symbol&quot;, &quot;series&quot; + seriesIndex,
                series.defaultColorStyleClass);
        return legendItem;
    }

    // -------------- STYLESHEET HANDLING --------------------------------------

    private static class StyleableProperties {
        private static final CssMetaData&lt;LineChart&lt;?,?&gt;,Boolean&gt; CREATE_SYMBOLS =
            new CssMetaData&lt;LineChart&lt;?,?&gt;,Boolean&gt;(&quot;-fx-create-symbols&quot;,
                BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(LineChart&lt;?,?&gt; node) {
                return node.createSymbols == null || !node.createSymbols.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(LineChart&lt;?,?&gt; node) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)node.createSymbolsProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(XYChart.getClassCssMetaData());
            styleables.add(CREATE_SYMBOLS);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    /**
     * This enum defines a policy for {@link LineChart#axisSortingPolicyProperty()}.
     * @since JavaFX 8u40
     */
    public static enum SortingPolicy {
        /**
         * The data should be left in the order defined by the list in {@link javafx.scene.chart.LineChart#dataProperty()}.
         */
        NONE,
        /**
         * The data is ordered by x axis.
         */
        X_AXIS,
        /**
         * The data is ordered by y axis.
         */
        Y_AXIS
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/StackedAreaChart.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;


import java.util.*;

import javafx.animation.*;
import javafx.application.Platform;
import javafx.beans.NamedArg;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.scene.AccessibleRole;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.*;
import javafx.util.Duration;

import com.sun.javafx.charts.Legend.LegendItem;
import javafx.css.converter.BooleanConverter;

import javafx.beans.property.BooleanProperty;
import javafx.beans.value.WritableValue;
import javafx.css.CssMetaData;
import javafx.css.Styleable;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableProperty;

/**
 * StackedAreaChart is a variation of {@link AreaChart} that displays trends of the
 * contribution of each value. (over time e.g.) The areas are stacked so that each
 * series adjoins but does not overlap the preceding series. This contrasts with
 * the Area chart where each series overlays the preceding series.
 *
 * The cumulative nature of the StackedAreaChart gives an idea of the total Y data
 * value at any given point along the X axis.
 *
 * Since data points across multiple series may not be common, StackedAreaChart
 * interpolates values along the line joining the data points whenever necessary.
 *
 * @since JavaFX 2.1
 */
public class StackedAreaChart&lt;X,Y&gt; extends XYChart&lt;X,Y&gt; {

    // -------------- PRIVATE FIELDS ------------------------------------------

    /** A multiplier for teh Y values that we store for each series, it is used to animate in a new series */
    private Map&lt;Series&lt;X,Y&gt;, DoubleProperty&gt; seriesYMultiplierMap = new HashMap&lt;&gt;();

    // -------------- PUBLIC PROPERTIES ----------------------------------------
    /**
     * When true, CSS styleable symbols are created for any data items that
     * don't have a symbol node specified.
     * @since JavaFX 8.0
     */
    private BooleanProperty createSymbols = new StyleableBooleanProperty(true) {
        @Override
        protected void invalidated() {
            for (int seriesIndex = 0; seriesIndex &lt; getData().size(); seriesIndex++) {
                Series&lt;X, Y&gt; series = getData().get(seriesIndex);
                for (int itemIndex = 0; itemIndex &lt; series.getData().size(); itemIndex++) {
                    Data&lt;X, Y&gt; item = series.getData().get(itemIndex);
                    Node symbol = item.getNode();
                    if (get() &amp;&amp; symbol == null) { // create any symbols
                        symbol = createSymbol(series, getData().indexOf(series), item, itemIndex);
                        if (null != symbol) {
                            getPlotChildren().add(symbol);
                        }
                    } else if (!get() &amp;&amp; symbol != null) { // remove symbols
                        getPlotChildren().remove(symbol);
                        symbol = null;
                        item.setNode(null);
                    }
                }
            }
            requestChartLayout();
        }

        public Object getBean() {
            return this;
        }

        public String getName() {
            return &quot;createSymbols&quot;;
        }

        public CssMetaData&lt;StackedAreaChart&lt;?, ?&gt;,Boolean&gt; getCssMetaData() {
            return StyleableProperties.CREATE_SYMBOLS;
        }
    };

    /**
     * Indicates whether symbols for data points will be created or not.
     *
     * @return true if symbols for data points will be created and false otherwise.
     * @since JavaFX 8.0
     */
    public final boolean getCreateSymbols() { return createSymbols.getValue(); }
    public final void setCreateSymbols(boolean value) { createSymbols.setValue(value); }
    public final BooleanProperty createSymbolsProperty() { return createSymbols; }

    // -------------- CONSTRUCTORS ----------------------------------------------

    /**
     * Construct a new Area Chart with the given axis
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     */
    public StackedAreaChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis) {
        this(xAxis,yAxis, FXCollections.&lt;Series&lt;X,Y&gt;&gt;observableArrayList());
    }

    /**
     * Construct a new Area Chart with the given axis and data.
     * &lt;p&gt;
     * Note: yAxis must be a ValueAxis, otherwise {@code IllegalArgumentException} is thrown.
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart
     *
     * @throws java.lang.IllegalArgumentException if yAxis is not a ValueAxis
     */
    public StackedAreaChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis, @NamedArg(&quot;data&quot;) ObservableList&lt;Series&lt;X,Y&gt;&gt; data) {
        super(xAxis,yAxis);
        if (!(yAxis instanceof ValueAxis)) {
            throw new IllegalArgumentException(&quot;Axis type incorrect, yAxis must be of ValueAxis type.&quot;);
        }
        setData(data);
    }

    // -------------- METHODS ------------------------------------------------------------------------------------------

    private static double doubleValue(Number number) { return doubleValue(number, 0); }
    private static double doubleValue(Number number, double nullDefault) {
        return (number == null) ? nullDefault : number.doubleValue();
    }

    @Override protected void dataItemAdded(Series&lt;X,Y&gt; series, int itemIndex, Data&lt;X,Y&gt; item) {
        final Node symbol = createSymbol(series, getData().indexOf(series), item, itemIndex);
        if (shouldAnimate()) {
            boolean animate = false;
            if (itemIndex &gt; 0 &amp;&amp; itemIndex &lt; (series.getData().size()-1)) {
                animate = true;
                Data&lt;X,Y&gt; p1 = series.getData().get(itemIndex - 1);
                Data&lt;X,Y&gt; p2 = series.getData().get(itemIndex + 1);
                double x1 = getXAxis().toNumericValue(p1.getXValue());
                double y1 = getYAxis().toNumericValue(p1.getYValue());
                double x3 = getXAxis().toNumericValue(p2.getXValue());
                double y3 = getYAxis().toNumericValue(p2.getYValue());

                double x2 = getXAxis().toNumericValue(item.getXValue());
                double y2 = getYAxis().toNumericValue(item.getYValue());

//                //1. y intercept of the line : y = ((y3-y1)/(x3-x1)) * x2 + (x3y1 - y3x1)/(x3 -x1)
                double y = ((y3-y1)/(x3-x1)) * x2 + (x3*y1 - y3*x1)/(x3-x1);
                item.setCurrentY(getYAxis().toRealValue(y));
                item.setCurrentX(getXAxis().toRealValue(x2));
                //2. we can simply use the midpoint on the line as well..
//                double x = (x3 + x1)/2;
//                double y = (y3 + y1)/2;
//                item.setCurrentX(x);
//                item.setCurrentY(y);
            } else if (itemIndex == 0 &amp;&amp; series.getData().size() &gt; 1) {
                animate = true;
                item.setCurrentX(series.getData().get(1).getXValue());
                item.setCurrentY(series.getData().get(1).getYValue());
            } else if (itemIndex == (series.getData().size() - 1) &amp;&amp; series.getData().size() &gt; 1) {
                animate = true;
                int last = series.getData().size() - 2;
                item.setCurrentX(series.getData().get(last).getXValue());
                item.setCurrentY(series.getData().get(last).getYValue());
            } else if (symbol != null) {
                // fade in new symbol
                symbol.setOpacity(0);
                getPlotChildren().add(symbol);
                FadeTransition ft = new FadeTransition(Duration.millis(500),symbol);
                ft.setToValue(1);
                ft.play();
            }
            if (animate) {
                animate(
                    new KeyFrame(Duration.ZERO,
                            (e) -&gt; {
                                if (symbol != null &amp;&amp; !getPlotChildren().contains(symbol)) {
                                    getPlotChildren().add(symbol);
                                } },
                            new KeyValue(item.currentYProperty(),
                                    item.getCurrentY()),
                            new KeyValue(item.currentXProperty(),
                                    item.getCurrentX())
                    ),
                    new KeyFrame(Duration.millis(800), new KeyValue(item.currentYProperty(),
                                        item.getYValue(), Interpolator.EASE_BOTH),
                                        new KeyValue(item.currentXProperty(),
                                        item.getXValue(), Interpolator.EASE_BOTH))
                );
            }

        } else if (symbol != null) {
            getPlotChildren().add(symbol);
        }
    }

    @Override protected  void dataItemRemoved(final Data&lt;X,Y&gt; item, final Series&lt;X,Y&gt; series) {
        final Node symbol = item.getNode();

        if (symbol != null) {
            symbol.focusTraversableProperty().unbind();
        }

        // remove item from sorted list
        int itemIndex = series.getItemIndex(item);
        if (shouldAnimate()) {
            boolean animate = false;
            // dataSize represents size of currently visible data. After this operation, the number will decrement by 1
            final int dataSize = series.getDataSize();
            // This is the size of current data list in Series. Note that it might be totaly different from dataSize as
            // some big operation might have happened on the list.
            final int dataListSize = series.getData().size();
            if (itemIndex &gt; 0 &amp;&amp; itemIndex &lt; dataSize - 1) {
                animate = true;
                Data&lt;X,Y&gt; p1 = series.getItem(itemIndex - 1);
                Data&lt;X,Y&gt; p2 = series.getItem(itemIndex + 1);
                double x1 = getXAxis().toNumericValue(p1.getXValue());
                double y1 = getYAxis().toNumericValue(p1.getYValue());
                double x3 = getXAxis().toNumericValue(p2.getXValue());
                double y3 = getYAxis().toNumericValue(p2.getYValue());

                double x2 = getXAxis().toNumericValue(item.getXValue());
                double y2 = getYAxis().toNumericValue(item.getYValue());

//                //1.  y intercept of the line : y = ((y3-y1)/(x3-x1)) * x2 + (x3y1 - y3x1)/(x3 -x1)
                double y = ((y3-y1)/(x3-x1)) * x2 + (x3*y1 - y3*x1)/(x3-x1);
                item.setCurrentX(getXAxis().toRealValue(x2));
                item.setCurrentY(getYAxis().toRealValue(y2));
                item.setXValue(getXAxis().toRealValue(x2));
                item.setYValue(getYAxis().toRealValue(y));
                //2.  we can simply use the midpoint on the line as well..
//                double x = (x3 + x1)/2;
//                double y = (y3 + y1)/2;
//                item.setCurrentX(x);
//                item.setCurrentY(y);
            } else if (itemIndex == 0 &amp;&amp; dataListSize &gt; 1) {
                animate = true;
                item.setXValue(series.getData().get(0).getXValue());
                item.setYValue(series.getData().get(0).getYValue());
            } else if (itemIndex == (dataSize - 1) &amp;&amp; dataListSize &gt; 1) {
                animate = true;
                int last = dataListSize - 1;
                item.setXValue(series.getData().get(last).getXValue());
                item.setYValue(series.getData().get(last).getYValue());
            } else if (symbol != null) {
                // fade out symbol
                symbol.setOpacity(0);
                FadeTransition ft = new FadeTransition(Duration.millis(500),symbol);
                ft.setToValue(0);
                ft.setOnFinished(actionEvent -&gt; {
                    getPlotChildren().remove(symbol);
                    removeDataItemFromDisplay(series, item);
                    symbol.setOpacity(1.0);
                });
                ft.play();
            } else {
                item.setSeries(null);
                removeDataItemFromDisplay(series, item);
            }
            if (animate) {
                animate( new KeyFrame(Duration.ZERO, new KeyValue(item.currentYProperty(),
                            item.getCurrentY()), new KeyValue(item.currentXProperty(),
                            item.getCurrentX())),
                            new KeyFrame(Duration.millis(800), actionEvent -&gt; {
                                getPlotChildren().remove(symbol);
                                removeDataItemFromDisplay(series, item);
                            },
                            new KeyValue(item.currentYProperty(),
                            item.getYValue(), Interpolator.EASE_BOTH),
                            new KeyValue(item.currentXProperty(),
                            item.getXValue(), Interpolator.EASE_BOTH))
                );
            }
        } else {
            getPlotChildren().remove(symbol);
            removeDataItemFromDisplay(series, item);
        }
        //Note: better animation here, point should move from old position to new position at center point between prev and next symbols
    }

    /** {@inheritDoc} */
    @Override protected void dataItemChanged(Data&lt;X, Y&gt; item) {
    }

    @Override protected void seriesChanged(ListChangeListener.Change&lt;? extends Series&gt; c) {
        // Update style classes for all series lines and symbols
        for (int i = 0; i &lt; getDataSize(); i++) {
            final Series&lt;X,Y&gt; s = getData().get(i);
            Path seriesLine = (Path)((Group)s.getNode()).getChildren().get(1);
            Path fillPath = (Path)((Group)s.getNode()).getChildren().get(0);
            seriesLine.getStyleClass().setAll(&quot;chart-series-area-line&quot;, &quot;series&quot; + i, s.defaultColorStyleClass);
            fillPath.getStyleClass().setAll(&quot;chart-series-area-fill&quot;, &quot;series&quot; + i, s.defaultColorStyleClass);
            for (int j=0; j &lt; s.getData().size(); j++) {
                final Data&lt;X,Y&gt; item = s.getData().get(j);
                final Node node = item.getNode();
                if(node!=null) node.getStyleClass().setAll(&quot;chart-area-symbol&quot;, &quot;series&quot; + i, &quot;data&quot; + j, s.defaultColorStyleClass);
            }
        }
    }

    @Override protected  void seriesAdded(Series&lt;X,Y&gt; series, int seriesIndex) {
        // create new paths for series
        Path seriesLine = new Path();
        Path fillPath = new Path();
        seriesLine.setStrokeLineJoin(StrokeLineJoin.BEVEL);
        fillPath.setStrokeLineJoin(StrokeLineJoin.BEVEL);
        Group areaGroup = new Group(fillPath,seriesLine);
        series.setNode(areaGroup);
        // create series Y multiplier
        DoubleProperty seriesYAnimMultiplier = new SimpleDoubleProperty(this, &quot;seriesYMultiplier&quot;);
        seriesYMultiplierMap.put(series, seriesYAnimMultiplier);
        // handle any data already in series
        if (shouldAnimate()) {
            seriesYAnimMultiplier.setValue(0d);
        } else {
            seriesYAnimMultiplier.setValue(1d);
        }
        getPlotChildren().add(areaGroup);
        List&lt;KeyFrame&gt; keyFrames = new ArrayList&lt;KeyFrame&gt;();
        if (shouldAnimate()) {
            // animate in new series
            keyFrames.add(new KeyFrame(Duration.ZERO,
                new KeyValue(areaGroup.opacityProperty(), 0),
                new KeyValue(seriesYAnimMultiplier, 0)
            ));
            keyFrames.add(new KeyFrame(Duration.millis(200),
                new KeyValue(areaGroup.opacityProperty(), 1)
            ));
            keyFrames.add(new KeyFrame(Duration.millis(500),
                new KeyValue(seriesYAnimMultiplier, 1)
            ));
        }
        for (int j=0; j&lt;series.getData().size(); j++) {
            Data&lt;X,Y&gt; item = series.getData().get(j);
            final Node symbol = createSymbol(series, seriesIndex, item, j);
            if (symbol != null) {
                if (shouldAnimate()) symbol.setOpacity(0);
                getPlotChildren().add(symbol);
                if (shouldAnimate()) {
                    // fade in new symbol
                    keyFrames.add(new KeyFrame(Duration.ZERO, new KeyValue(symbol.opacityProperty(), 0)));
                    keyFrames.add(new KeyFrame(Duration.millis(200), new KeyValue(symbol.opacityProperty(), 1)));
                }
            }
        }
        if (shouldAnimate()) animate(keyFrames.toArray(new KeyFrame[keyFrames.size()]));
    }

    @Override protected  void seriesRemoved(final Series&lt;X,Y&gt; series) {
        // remove series Y multiplier
        seriesYMultiplierMap.remove(series);
        // remove all symbol nodes
        if (shouldAnimate()) {
            Timeline tl = new Timeline(createSeriesRemoveTimeLine(series, 400));
            tl.play();
        } else {
            getPlotChildren().remove(series.getNode());
            for (Data&lt;X,Y&gt; d:series.getData()) getPlotChildren().remove(d.getNode());
            removeSeriesFromDisplay(series);
        }
    }

    /** {@inheritDoc} */
    @Override protected void updateAxisRange() {
        // This override is necessary to update axis range based on cumulative Y value for the
        // Y axis instead of the normal way where max value in the data range is used.
        final Axis&lt;X&gt; xa = getXAxis();
        final Axis&lt;Y&gt; ya = getYAxis();
        if (xa.isAutoRanging()) {
            List xData = new ArrayList&lt;Number&gt;();
            for(Series&lt;X,Y&gt; series : getData()) {
                for(Data&lt;X,Y&gt; data: series.getData()) {
                    xData.add(data.getXValue());
                }
            }
            xa.invalidateRange(xData);
        }
        if (ya.isAutoRanging()) {
            double totalMinY = Double.MAX_VALUE;
            Iterator&lt;Series&lt;X, Y&gt;&gt; seriesIterator = getDisplayedSeriesIterator();
            boolean first = true;
            NavigableMap&lt;Double, Double&gt; accum = new TreeMap&lt;&gt;();
            NavigableMap&lt;Double, Double&gt; prevAccum = new TreeMap&lt;&gt;();
            NavigableMap&lt;Double, Double&gt; currentValues = new TreeMap&lt;&gt;();
            while (seriesIterator.hasNext()) {
                currentValues.clear();
                Series&lt;X, Y&gt; series = seriesIterator.next();
<A NAME="35"></A>                for(Data&lt;X,Y&gt; item : series.getData()) {
                    if(item != null) {
                        final double xv = xa.toNumericValue(item.getXValue());
                        final double yv = <FONT color="#41a317"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#35',2,'match51-top.html#35',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ya.toNumericValue(item.getYValue());
                        currentValues.put(xv, yv);
                        if (first) {
                            // On the first pass, just fill the map
                            accum.put(xv, yv);
                            // minimum is applicable only in the first series
                            totalMinY = Math.min(totalMinY, yv);
                        } else {</B></FONT>
                            if (prevAccum.containsKey(xv)) {
                                accum.put(xv, prevAccum.get(xv) + yv);
                            } else {
                                // If the point wasn't yet in the previous (accumulated) series
                                Map.Entry&lt;Double, Double&gt; he = prevAccum.higherEntry(xv);
                                Map.Entry&lt;Double, Double&gt; le = prevAccum.lowerEntry(xv);
                                if (he != null &amp;&amp; le != null) {
                                    // If there's both point above and below this point, interpolate
                                    accum.put(xv, ((xv - le.getKey()) / (he.getKey() - le.getKey())) *
                                            (le.getValue() + he.getValue()) + yv);
                                } else if (he != null) {
                                    // The point is before the first point in the previously accumulated series
                                    accum.put(xv, he.getValue() + yv);
                                } else if (le != null) {
                                    // The point is after the last point in the previously accumulated series
                                    accum.put(xv, le.getValue() + yv);
                                } else {
                                    // The previously accumulated series is empty
                                    accum.put(xv, yv);
                                }
                            }
                        }
                    }
                }
                // Now update all the keys that were in the previous series, but not in the new one
                for (Map.Entry&lt;Double, Double&gt; e : prevAccum.entrySet()) {
                    if (accum.keySet().contains(e.getKey())) {
                        continue;
                    }
                    Double k = e.getKey();
                    final Double v = e.getValue();
                    // Look at the values of the current series
                    Map.Entry&lt;Double, Double&gt; he = currentValues.higherEntry(k);
                    Map.Entry&lt;Double, Double&gt; le = currentValues.lowerEntry(k);
                    if (he != null &amp;&amp; le != null) {
                        // Interpolate the for the point from current series and add the accumulated value
                        accum.put(k, ((k - le.getKey()) / (he.getKey() - le.getKey())) *
                                (le.getValue() + he.getValue()) + v);
                    } else if (he != null) {
                        // There accumulated value is before the first value in the current series
                        accum.put(k, he.getValue() + v);
                    } else if (le != null) {
                        // There accumulated value is after the last value in the current series
                        accum.put(k, le.getValue() + v);
                    } else {
                        // The current series are empty
                        accum.put(k, v);
                    }

                }

                prevAccum.clear();
                prevAccum.putAll(accum);
                accum.clear();
                first = (totalMinY == Double.MAX_VALUE); // If there was already some value in the series, we can consider as
                                                         // being past the first series

            }
            if(totalMinY != Double.MAX_VALUE) ya.invalidateRange(Arrays.asList(ya.toRealValue(totalMinY),
                    ya.toRealValue(Collections.max(prevAccum.values()))));

        }
    }


    /** {@inheritDoc} */
    @Override protected void layoutPlotChildren() {
        ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; currentSeriesData = new ArrayList&lt;&gt;();
        // AggregateData hold the data points of both the current and the previous series.
            // The goal is to collect all the data, sort it and iterate.
        ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; aggregateData = new ArrayList&lt;&gt;();
        for (int seriesIndex=0; seriesIndex &lt; getDataSize(); seriesIndex++) { // for every series
            Series&lt;X, Y&gt; series = getData().get(seriesIndex);
            aggregateData.clear();
            // copy currentSeriesData accumulated in the previous iteration to aggregate.
            for(DataPointInfo&lt;X, Y&gt; data : currentSeriesData) {
                data.partOf = PartOf.PREVIOUS;
                aggregateData.add(data);
            }
            currentSeriesData.clear();
            // now copy actual data of the current series.
            for (Iterator&lt;Data&lt;X, Y&gt;&gt; it = getDisplayedDataIterator(series); it.hasNext(); ) {
                Data&lt;X, Y&gt; item = it.next();
                DataPointInfo&lt;X, Y&gt; itemInfo = new DataPointInfo&lt;&gt;(item, item.getXValue(),
                        item.getYValue(), PartOf.CURRENT);
                aggregateData.add(itemInfo);
            }
            DoubleProperty seriesYAnimMultiplier = seriesYMultiplierMap.get(series);
            Path seriesLine = (Path)((Group)series.getNode()).getChildren().get(1);
            Path fillPath = (Path)((Group)series.getNode()).getChildren().get(0);
            seriesLine.getElements().clear();
            fillPath.getElements().clear();
            int dataIndex = 0;
            // Sort data points from prev and current series
            sortAggregateList(aggregateData);

            Axis&lt;Y&gt; yAxis = getYAxis();
            Axis&lt;X&gt; xAxis = getXAxis();
            boolean firstCurrent = false;
            boolean lastCurrent = false;
            int firstCurrentIndex = findNextCurrent(aggregateData, -1);
            int lastCurrentIndex = findPreviousCurrent(aggregateData, aggregateData.size());
            double basePosition = yAxis.getZeroPosition();
            if (Double.isNaN(basePosition)) {
                ValueAxis&lt;Number&gt; valueYAxis = (ValueAxis&lt;Number&gt;) yAxis;
                if (valueYAxis.getLowerBound() &gt; 0) {
                    basePosition = valueYAxis.getDisplayPosition(valueYAxis.getLowerBound());
                } else {
                    basePosition = valueYAxis.getDisplayPosition(valueYAxis.getUpperBound());
                }
            }
            // Iterate over the aggregate data : this process accumulates data points
            // cumulatively from the bottom to top of stack

            for (DataPointInfo&lt;X, Y&gt; dataInfo : aggregateData) {
                if (dataIndex == lastCurrentIndex) lastCurrent = true;
                if (dataIndex == firstCurrentIndex) firstCurrent = true;
                final Data&lt;X,Y&gt; item = dataInfo.dataItem;
                if (dataInfo.partOf.equals(PartOf.CURRENT)) { // handle data from current series
                    int pIndex = findPreviousPrevious(aggregateData, dataIndex);
                    int nIndex = findNextPrevious(aggregateData, dataIndex);
                    DataPointInfo&lt;X, Y&gt; prevPoint;
                    DataPointInfo&lt;X, Y&gt; nextPoint;
                    if (pIndex == -1 || (nIndex == -1 &amp;&amp; !(aggregateData.get(pIndex).x.equals(dataInfo.x)))) {
                        if (firstCurrent) {
                            // Need to add the drop down point.
                            Data&lt;X, Y&gt; ddItem = new Data(dataInfo.x, 0);
                            addDropDown(currentSeriesData, ddItem, ddItem.getXValue(), ddItem.getYValue(),
                                    xAxis.getDisplayPosition(ddItem.getCurrentX()), basePosition);
                        }
                        double x = xAxis.getDisplayPosition(item.getCurrentX());
                        double y = yAxis.getDisplayPosition(
                                yAxis.toRealValue(yAxis.toNumericValue(item.getCurrentY()) * seriesYAnimMultiplier.getValue()));
                        addPoint(currentSeriesData, item, item.getXValue(), item.getYValue(), x, y,
                                PartOf.CURRENT, false, (firstCurrent) ? false : true);
                        if (dataIndex == lastCurrentIndex) {
                            // need to add drop down point
                            Data&lt;X, Y&gt; ddItem = new Data(dataInfo.x, 0);
                            addDropDown(currentSeriesData, ddItem, ddItem.getXValue(), ddItem.getYValue(),
                                    xAxis.getDisplayPosition(ddItem.getCurrentX()), basePosition);
                        }
                    } else {
                        prevPoint = aggregateData.get(pIndex);
                        if (prevPoint.x.equals(dataInfo.x)) { // Need to add Y values
                            // Check if prevPoint is a dropdown - as the stable sort preserves the order.
                            // If so, find the non dropdown previous point on previous series.
                            if (prevPoint.dropDown) {
                                pIndex = findPreviousPrevious(aggregateData, pIndex);
                                prevPoint = aggregateData.get(pIndex);
                                // If lastCurrent - add this drop down
                            }
                            if (prevPoint.x.equals(dataInfo.x)) { // simply add
                                double x = xAxis.getDisplayPosition(item.getCurrentX());
                                final double yv = yAxis.toNumericValue(item.getCurrentY()) + yAxis.toNumericValue(prevPoint.y);
                                double y = yAxis.getDisplayPosition(
                                        yAxis.toRealValue(yv * seriesYAnimMultiplier.getValue()));
                                addPoint(currentSeriesData, item, dataInfo.x, yAxis.toRealValue(yv), x, y, PartOf.CURRENT, false,
                                        (firstCurrent) ? false : true);
                            }
                            if (lastCurrent) {
                                addDropDown(currentSeriesData, item, prevPoint.x, prevPoint.y, prevPoint.displayX, prevPoint.displayY);
                            }
                        } else {
                            // interpolate
                            nextPoint = (nIndex == -1) ? null : aggregateData.get(nIndex);
                            prevPoint = (pIndex == -1) ? null : aggregateData.get(pIndex);
                            final double yValue = yAxis.toNumericValue(item.getCurrentY());
                            if (prevPoint != null &amp;&amp; nextPoint != null) {
                                double x = xAxis.getDisplayPosition(item.getCurrentX());
                                double displayY = interpolate(prevPoint.displayX,
                                        prevPoint.displayY, nextPoint.displayX, nextPoint.displayY, x);
                                double dataY = interpolate(xAxis.toNumericValue(prevPoint.x),
                                        yAxis.toNumericValue(prevPoint.y),
                                        xAxis.toNumericValue(nextPoint.x),
                                        yAxis.toNumericValue(nextPoint.y),
                                        xAxis.toNumericValue(dataInfo.x));
                                if (firstCurrent) {
                                    // now create the drop down point
                                    Data&lt;X, Y&gt; ddItem = new Data(dataInfo.x, dataY);
                                    addDropDown(currentSeriesData, ddItem, dataInfo.x, yAxis.toRealValue(dataY), x, displayY);
                                }
                                double y = yAxis.getDisplayPosition(yAxis.toRealValue((yValue + dataY) * seriesYAnimMultiplier.getValue()));
                                // Add the current point
                                addPoint(currentSeriesData, item, dataInfo.x, yAxis.toRealValue(yValue + dataY), x, y, PartOf.CURRENT, false,
                                        (firstCurrent) ? false : true);
                                if (dataIndex == lastCurrentIndex) {
                                    // add drop down point
                                    Data&lt;X, Y&gt; ddItem = new Data(dataInfo.x, dataY);
                                    addDropDown(currentSeriesData, ddItem, dataInfo.x, yAxis.toRealValue(dataY), x, displayY);
                                }
                                // Note: add drop down if last current
                            }
                            else {
                                // we do not need to take care of this as it is
                                // already handled above with check of if(pIndex == -1 or nIndex == -1)
                            }
                        }
                    }

                } else { // handle data from Previous series.
                    int pIndex = findPreviousCurrent(aggregateData, dataIndex);
                    int nIndex = findNextCurrent(aggregateData, dataIndex);
                    DataPointInfo&lt;X, Y&gt; prevPoint;
                    DataPointInfo&lt;X, Y&gt; nextPoint;
                    if (dataInfo.dropDown) {
                        if (xAxis.toNumericValue(dataInfo.x) &lt;=
                                xAxis.toNumericValue(aggregateData.get(firstCurrentIndex).x) ||
                                xAxis.toNumericValue(dataInfo.x) &gt; xAxis.toNumericValue(aggregateData.get(lastCurrentIndex).x)) {
                            addDropDown(currentSeriesData, item, dataInfo.x, dataInfo.y, dataInfo.displayX, dataInfo.displayY);
                        }
                    } else {
                        if (pIndex == -1 || nIndex == -1) {
                            addPoint(currentSeriesData, item, dataInfo.x, dataInfo.y, dataInfo.displayX, dataInfo.displayY,
                                    PartOf.CURRENT, true, false);
                        } else {
                            nextPoint = aggregateData.get(nIndex);
                            if (nextPoint.x.equals(dataInfo.x)) {
                                // do nothing as the current point is already there.
                            } else {
                                // interpolate on the current series.
                                prevPoint = aggregateData.get(pIndex);
                                double x = xAxis.getDisplayPosition(item.getCurrentX());
                                  double dataY = interpolate(xAxis.toNumericValue(prevPoint.x),
                                          yAxis.toNumericValue(prevPoint.y),
                                          xAxis.toNumericValue(nextPoint.x),
                                          yAxis.toNumericValue(nextPoint.y),
                                          xAxis.toNumericValue(dataInfo.x));
                                final double yv = yAxis.toNumericValue(dataInfo.y) + dataY;
                                double y = yAxis.getDisplayPosition(
                                        yAxis.toRealValue(yv * seriesYAnimMultiplier.getValue()));
                                addPoint(currentSeriesData, new Data(dataInfo.x, dataY), dataInfo.x, yAxis.toRealValue(yv), x, y, PartOf.CURRENT, true, true);
                            }
                        }
                    }
                }
                dataIndex++;
                if (firstCurrent) firstCurrent = false;
                if (lastCurrent) lastCurrent = false;
            } // end of inner for loop

            // Draw the SeriesLine and Series fill
            if (!currentSeriesData.isEmpty()) {
                seriesLine.getElements().add(new MoveTo(currentSeriesData.get(0).displayX, currentSeriesData.get(0).displayY));
                fillPath.getElements().add(new MoveTo(currentSeriesData.get(0).displayX, currentSeriesData.get(0).displayY));
            }
            for (DataPointInfo&lt;X, Y&gt; point : currentSeriesData) {
                if (point.lineTo) {
                    seriesLine.getElements().add(new LineTo(point.displayX, point.displayY));
                } else {
                    seriesLine.getElements().add(new MoveTo(point.displayX, point.displayY));
                }
                fillPath.getElements().add(new  LineTo(point.displayX, point.displayY));
                // draw symbols only for actual data points and skip for interpolated points.
                if (!point.skipSymbol) {
                    Node symbol = point.dataItem.getNode();
                    if (symbol != null) {
                        final double w = symbol.prefWidth(-1);
                        final double h = symbol.prefHeight(-1);
                        symbol.resizeRelocate(point.displayX-(w/2), point.displayY-(h/2),w,h);
                    }
                }
            }
            for(int i = aggregateData.size()-1; i &gt; 0; i--) {
                DataPointInfo&lt;X, Y&gt; point = aggregateData.get(i);
                if (PartOf.PREVIOUS.equals(point.partOf)) {
                    fillPath.getElements().add(new  LineTo(point.displayX, point.displayY));
                }
            }
            if (!fillPath.getElements().isEmpty()) {
                fillPath.getElements().add(new ClosePath());
            }

        }  // end of out for loop
     }

    private void addDropDown(ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; currentSeriesData, Data&lt;X, Y&gt; item, X xValue, Y yValue, double x, double y) {
        DataPointInfo&lt;X, Y&gt; dropDownDataPoint = new DataPointInfo&lt;&gt;(true);
        dropDownDataPoint.setValues(item, xValue, yValue, x, y, PartOf.CURRENT, true, false);
        currentSeriesData.add(dropDownDataPoint);
    }

    private void addPoint(ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; currentSeriesData, Data&lt;X, Y&gt; item, X xValue, Y yValue, double x, double y, PartOf partof,
                          boolean symbol, boolean lineTo) {
        DataPointInfo&lt;X, Y&gt; currentDataPoint = new DataPointInfo&lt;&gt;();
        currentDataPoint.setValues(item, xValue, yValue, x, y, partof, symbol, lineTo);
        currentSeriesData.add(currentDataPoint);
    }

    //-------------------- helper methods to retrieve data points from the previous
     // or current data series.
     private int findNextCurrent(ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; points, int index) {
        for(int i = index+1; i &lt; points.size(); i++) {
            if (points.get(i).partOf.equals(PartOf.CURRENT)) {
                return i;
            }
        }
        return -1;
     }

     private int findPreviousCurrent(ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; points, int index) {
        for(int i = index-1; i &gt;= 0; i--) {
            if (points.get(i).partOf.equals(PartOf.CURRENT)) {
                return i;
            }
        }
        return -1;
     }


    private int findPreviousPrevious(ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; points, int index) {
       for(int i = index-1; i &gt;= 0; i--) {
            if (points.get(i).partOf.equals(PartOf.PREVIOUS)) {
                return i;
            }
        }
        return -1;
    }
    private int findNextPrevious(ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; points, int index) {
        for(int i = index+1; i &lt; points.size(); i++) {
            if (points.get(i).partOf.equals(PartOf.PREVIOUS)) {
                return i;
            }
        }
        return -1;
    }


     private void sortAggregateList(ArrayList&lt;DataPointInfo&lt;X, Y&gt;&gt; aggregateList) {
        Collections.sort(aggregateList, (o1, o2) -&gt; {
            Data&lt;X,Y&gt; d1 = o1.dataItem;
            Data&lt;X,Y&gt; d2 = o2.dataItem;
            double val1 = getXAxis().toNumericValue(d1.getXValue());
            double val2 = getXAxis().toNumericValue(d2.getXValue());
            return (val1 &lt; val2 ? -1 : ( val1 == val2) ? 0 : 1);
        });
     }

    private double interpolate(double lowX, double lowY, double highX, double highY, double x) {
         // using y = mx+c find the y for the given x.
         return (((highY - lowY)/(highX - lowX))*(x - lowX))+lowY;
    }

    private Node createSymbol(Series&lt;X,Y&gt; series, int seriesIndex, final Data&lt;X,Y&gt; item, int itemIndex) {
        Node symbol = item.getNode();
        // check if symbol has already been created
        if (symbol == null &amp;&amp; getCreateSymbols()) {
            symbol = new StackPane();
            symbol.setAccessibleRole(AccessibleRole.TEXT);
            symbol.setAccessibleRoleDescription(&quot;Point&quot;);
            symbol.focusTraversableProperty().bind(Platform.accessibilityActiveProperty());
            item.setNode(symbol);
        }
        // set symbol styles
        // Note not sure if we want to add or check, ie be more careful and efficient here
        if (symbol != null) symbol.getStyleClass().setAll(&quot;chart-area-symbol&quot;, &quot;series&quot; + seriesIndex, &quot;data&quot; + itemIndex,
                series.defaultColorStyleClass);
        return symbol;
    }

    @Override
    LegendItem createLegendItemForSeries(Series&lt;X, Y&gt; series, int seriesIndex) {
        LegendItem legendItem = new LegendItem(series.getName());
        legendItem.getSymbol().getStyleClass().addAll(&quot;chart-area-symbol&quot;, &quot;series&quot; + seriesIndex,
                &quot;area-legend-symbol&quot;, series.defaultColorStyleClass);
        return legendItem;
    }

    // -------------- INNER CLASSES --------------------------------------------
    /*
     * Helper class to hold data and display and other information for each
     * data point
     */
    final static class DataPointInfo&lt;X, Y&gt; {
        X x;
        Y y;
        double displayX;
        double displayY;
        Data&lt;X,Y&gt; dataItem;
        PartOf partOf;
        boolean skipSymbol = false; // interpolated point - skip drawing symbol
        boolean lineTo = false; // should there be a lineTo to this point on SeriesLine.
        boolean dropDown = false; // Is this a drop down point ( non data point).

        //----- Constructors --------------------
        DataPointInfo() {}

        DataPointInfo(Data&lt;X,Y&gt; item, X x, Y y, PartOf partOf) {
            this.dataItem = item;
            this.x = x;
            this.y = y;
            this.partOf = partOf;
        }

        DataPointInfo(boolean dropDown) {
            this.dropDown = dropDown;
        }

        void setValues(Data&lt;X,Y&gt; item, X x, Y y, double dx, double dy,
                        PartOf partOf, boolean skipSymbol, boolean lineTo) {
            this.dataItem = item;
            this.x = x;
            this.y = y;
            this.displayX = dx;
            this.displayY = dy;
            this.partOf = partOf;
            this.skipSymbol = skipSymbol;
            this.lineTo = lineTo;
        }

        public final X getX() {
            return x;
        }

        public final Y getY() {
            return y;
        }
    }

    // To indicate if the data point belongs to the current or the previous series.
    private static enum PartOf {
        CURRENT,
        PREVIOUS
    }

    // -------------- STYLESHEET HANDLING --------------------------------------

    private static class StyleableProperties {

        private static final CssMetaData&lt;StackedAreaChart&lt;?, ?&gt;, Boolean&gt; CREATE_SYMBOLS =
                new CssMetaData&lt;StackedAreaChart&lt;?, ?&gt;, Boolean&gt;(&quot;-fx-create-symbols&quot;,
                BooleanConverter.getInstance(), Boolean.TRUE) {
            @Override
            public boolean isSettable(StackedAreaChart&lt;?,?&gt; node) {
                return node.createSymbols == null || !node.createSymbols.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(StackedAreaChart&lt;?,?&gt; node) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)node.createSymbolsProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;

        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(XYChart.getClassCssMetaData());
            styleables.add(CREATE_SYMBOLS);
            STYLEABLES = Collections.unmodifiableList(styleables);

        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
         return StyleableProperties.STYLEABLES;
     }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TableView.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.WeakHashMap;

import com.sun.javafx.logging.PlatformLogger.Level;
import com.sun.javafx.scene.control.Logging;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.SelectedCellsMap;
import com.sun.javafx.scene.control.SelectedItemsReadOnlyObservableList;
import com.sun.javafx.scene.control.behavior.TableCellBehavior;
import com.sun.javafx.scene.control.behavior.TableCellBehaviorBase;
import javafx.beans.*;
import javafx.beans.Observable;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.Property;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.MapChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.collections.transformation.SortedList;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableProperty;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.layout.Region;
import javafx.util.Callback;

import com.sun.javafx.collections.MappingChange;
import com.sun.javafx.collections.NonIterableChange;
import javafx.css.converter.SizeConverter;
import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
import com.sun.javafx.scene.control.TableColumnComparatorBase.TableColumnComparator;
import javafx.scene.control.skin.TableViewSkin;

/**
 * The TableView control is designed to visualize an unlimited number of rows
 * of data, broken out into columns. A TableView is therefore very similar to the
 * {@link ListView} control, with the addition of support for columns. For an
 * example on how to create a TableView, refer to the 'Creating a TableView'
 * control section below.
 *
 * &lt;p&gt;The TableView control has a number of features, including:
 * &lt;ul&gt;
 * &lt;li&gt;Powerful {@link TableColumn} API:
 *   &lt;ul&gt;
 *   &lt;li&gt;Support for {@link TableColumn#cellFactoryProperty() cell factories} to
 *      easily customize {@link Cell cell} contents in both rendering and editing
 *      states.
 *   &lt;li&gt;Specification of {@link TableColumn#minWidthProperty() minWidth}/
 *      {@link TableColumn#prefWidthProperty() prefWidth}/
 *      {@link TableColumn#maxWidthProperty() maxWidth},
 *      and also {@link TableColumn#resizableProperty() fixed width columns}.
 *   &lt;li&gt;Width resizing by the user at runtime.
 *   &lt;li&gt;Column reordering by the user at runtime.
 *   &lt;li&gt;Built-in support for {@link TableColumn#getColumns() column nesting}
 *   &lt;/ul&gt;
 * &lt;li&gt;Different {@link #columnResizePolicyProperty() resizing policies} to
 *      dictate what happens when the user resizes columns.
 * &lt;li&gt;Support for {@link #getSortOrder() multiple column sorting} by clicking
 *      the column header (hold down Shift keyboard key whilst clicking on a
 *      header to sort by multiple columns).
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Note that TableView is intended to be used to visualize data - it is not
 * intended to be used for laying out your user interface. If you want to lay
 * your user interface out in a grid-like fashion, consider the
 * {@link javafx.scene.layout.GridPane} layout instead.&lt;/p&gt;
 *
 * &lt;h2&gt;Creating a TableView&lt;/h2&gt;
 *
 * &lt;p&gt;
 * Creating a TableView is a multi-step process, and also depends on the
 * underlying data model needing to be represented. For this example we'll use
 * an {@literal ObservableList&lt;Person&gt;}, as it is the simplest way of showing data in a
 * TableView. The {@code Person} class will consist of a first
 * name and last name properties. That is:
 *
 * &lt;pre&gt;
 * {@code
 * public class Person {
 *     private StringProperty firstName;
 *     public void setFirstName(String value) { firstNameProperty().set(value); }
 *     public String getFirstName() { return firstNameProperty().get(); }
 *     public StringProperty firstNameProperty() {
 *         if (firstName == null) firstName = new SimpleStringProperty(this, &quot;firstName&quot;);
 *         return firstName;
 *     }
 *
 *     private StringProperty lastName;
 *     public void setLastName(String value) { lastNameProperty().set(value); }
 *     public String getLastName() { return lastNameProperty().get(); }
 *     public StringProperty lastNameProperty() {
 *         if (lastName == null) lastName = new SimpleStringProperty(this, &quot;lastName&quot;);
 *         return lastName;
 *     }
 * }}&lt;/pre&gt;
 *
 * &lt;p&gt;Firstly, a TableView instance needs to be defined, as such:
 *
 * &lt;pre&gt;
 * {@code
 * TableView&lt;Person&gt; table = new TableView&lt;&gt;();}&lt;/pre&gt;
 *
 * &lt;p&gt;With the basic table defined, we next focus on the data model. As mentioned,
 * for this example, we'll be using an {@literal ObservableList&lt;Person&gt;}. We can immediately
 * set such a list directly in to the TableView, as such:
 *
 * &lt;pre&gt;
 * {@code
 * ObservableList&lt;Person&gt; teamMembers = getTeamMembers();
 * table.setItems(teamMembers);}&lt;/pre&gt;
 *
 * &lt;p&gt;With the items set as such, TableView will automatically update whenever
 * the &lt;code&gt;teamMembers&lt;/code&gt; list changes. If the items list is available
 * before the TableView is instantiated, it is possible to pass it directly into
 * the constructor.
 *
 * &lt;p&gt;At this point we now have a TableView hooked up to observe the
 * &lt;code&gt;teamMembers&lt;/code&gt; observableList. The missing ingredient
 * now is the means of splitting out the data contained within the model and
 * representing it in one or more {@link TableColumn TableColumn} instances. To
 * create a two-column TableView to show the firstName and lastName properties,
 * we extend the last code sample as follows:
 *
 * &lt;pre&gt;
 * {@code
 * ObservableList&lt;Person&gt; teamMembers = ...;
 * table.setItems(teamMembers);
 *
 * TableColumn&lt;Person,String&gt; firstNameCol = new TableColumn&lt;&gt;(&quot;First Name&quot;);
 * firstNameCol.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;firstName&quot;));
 * TableColumn&lt;Person,String&gt; lastNameCol = new TableColumn&lt;&gt;(&quot;Last Name&quot;);
 * lastNameCol.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;lastName&quot;));
 *
 * table.getColumns().setAll(firstNameCol, lastNameCol);}&lt;/pre&gt;
 *
 * &lt;p&gt;With the code shown above we have fully defined the minimum properties
 * required to create a TableView instance. Running this code (assuming the
 * people ObservableList is appropriately created) will result in a TableView being
 * shown with two columns for firstName and lastName. Any other properties of the
 * Person class will not be shown, as no TableColumns are defined.
 *
 * &lt;h3&gt;TableView support for classes that don't contain properties&lt;/h3&gt;
 *
 * &lt;p&gt;The code shown above is the shortest possible code for creating a TableView
 * when the domain objects are designed with JavaFX properties in mind
 * (additionally, {@link javafx.scene.control.cell.PropertyValueFactory} supports
 * normal JavaBean properties too, although there is a caveat to this, so refer
 * to the class documentation for more information). When this is not the case,
 * it is necessary to provide a custom cell value factory. More information
 * about cell value factories can be found in the {@link TableColumn} API
 * documentation, but briefly, here is how a TableColumn could be specified:
 *
 * &lt;pre&gt;
 * {@code
 * firstNameCol.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;Person, String&gt;, ObservableValue&lt;String&gt;&gt;() {
 *     public ObservableValue&lt;String&gt; call(CellDataFeatures&lt;Person, String&gt; p) {
 *         // p.getValue() returns the Person instance for a particular TableView row
 *         return p.getValue().firstNameProperty();
 *     }
 * });
 *
 * // or with a lambda expression:
 * firstNameCol.setCellValueFactory(p -&gt; p.getValue().firstNameProperty());
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;TableView Selection / Focus APIs&lt;/h3&gt;
 * &lt;p&gt;To track selection and focus, it is necessary to become familiar with the
 * {@link SelectionModel} and {@link FocusModel} classes. A TableView has at most
 * one instance of each of these classes, available from
 * {@link #selectionModelProperty() selectionModel} and
 * {@link #focusModelProperty() focusModel} properties respectively.
 * Whilst it is possible to use this API to set a new selection model, in
 * most circumstances this is not necessary - the default selection and focus
 * models should work in most circumstances.
 *
 * &lt;p&gt;The default {@link SelectionModel} used when instantiating a TableView is
 * an implementation of the {@link MultipleSelectionModel} abstract class.
 * However, as noted in the API documentation for
 * the {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 * property, the default value is {@link SelectionMode#SINGLE}. To enable
 * multiple selection in a default TableView instance, it is therefore necessary
 * to do the following:
 *
 * &lt;pre&gt;
 * {@code
 * tableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}&lt;/pre&gt;
 *
 * &lt;h3&gt;Customizing TableView Visuals&lt;/h3&gt;
 * &lt;p&gt;The visuals of the TableView can be entirely customized by replacing the
 * default {@link #rowFactoryProperty() row factory}. A row factory is used to
 * generate {@link TableRow} instances, which are used to represent an entire
 * row in the TableView.
 *
 * &lt;p&gt;In many cases, this is not what is desired however, as it is more commonly
 * the case that cells be customized on a per-column basis, not a per-row basis.
 * It is therefore important to note that a {@link TableRow} is not a
 * {@link TableCell}. A  {@link TableRow} is simply a container for zero or more
 * {@link TableCell}, and in most circumstances it is more likely that you'll
 * want to create custom TableCells, rather than TableRows. The primary use case
 * for creating custom TableRow instances would most probably be to introduce
 * some form of column spanning support.
 *
 * &lt;p&gt;You can create custom {@link TableCell} instances per column by assigning
 * the appropriate function to the TableColumn
 * {@link TableColumn#cellFactoryProperty() cell factory} property.
 *
 * &lt;p&gt;See the {@link Cell} class documentation for a more complete
 * description of how to write custom Cells.
 *
 * &lt;h3&gt;Sorting&lt;/h3&gt;
 * &lt;p&gt;Prior to JavaFX 8.0, the TableView control would treat the
 * {@link #getItems() items} list as the view model, meaning that any changes to
 * the list would be immediately reflected visually. TableView would also modify
 * the order of this list directly when a user initiated a sort. This meant that
 * (again, prior to JavaFX 8.0) it was not possible to have the TableView return
 * to an unsorted state (after iterating through ascending and descending
 * orders).&lt;/p&gt;
 *
 * &lt;p&gt;Starting with JavaFX 8.0 (and the introduction of {@link SortedList}), it
 * is now possible to have the collection return to the unsorted state when
 * there are no columns as part of the TableView
 * {@link #getSortOrder() sort order}. To do this, you must create a SortedList
 * instance, and bind its
 * {@link javafx.collections.transformation.SortedList#comparatorProperty() comparator}
 * property to the TableView {@link #comparatorProperty() comparator} property,
 * list so:&lt;/p&gt;
 *
 * &lt;pre&gt;
 * {@code
 * // create a SortedList based on the provided ObservableList
 * SortedList sortedList = new SortedList(FXCollections.observableArrayList(2, 1, 3));
 *
 * // create a TableView with the sorted list set as the items it will show
 * final TableView&lt;Integer&gt; tableView = new TableView&lt;&gt;(sortedList);
 *
 * // bind the sortedList comparator to the TableView comparator
 * sortedList.comparatorProperty().bind(tableView.comparatorProperty());
 *
 * // Don't forget to define columns!
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;Editing&lt;/h3&gt;
 * &lt;p&gt;This control supports inline editing of values, and this section attempts to
 * give an overview of the available APIs and how you should use them.&lt;/p&gt;
 *
 * &lt;p&gt;Firstly, cell editing most commonly requires a different user interface
 * than when a cell is not being edited. This is the responsibility of the
 * {@link Cell} implementation being used. For TableView, it is highly
 * recommended that editing be
 * {@link javafx.scene.control.TableColumn#cellFactoryProperty() per-TableColumn},
 * rather than {@link #rowFactoryProperty() per row}, as more often than not
 * you want users to edit each column value differently, and this approach allows
 * for editors specific to each column. It is your choice whether the cell is
 * permanently in an editing state (e.g. this is common for {@link CheckBox} cells),
 * or to switch to a different UI when editing begins (e.g. when a double-click
 * is received on a cell).&lt;/p&gt;
 *
 * &lt;p&gt;To know when editing has been requested on a cell,
 * simply override the {@link javafx.scene.control.Cell#startEdit()} method, and
 * update the cell {@link javafx.scene.control.Cell#textProperty() text} and
 * {@link javafx.scene.control.Cell#graphicProperty() graphic} properties as
 * appropriate (e.g. set the text to null and set the graphic to be a
 * {@link TextField}). Additionally, you should also override
 * {@link Cell#cancelEdit()} to reset the UI back to its original visual state
 * when the editing concludes. In both cases it is important that you also
 * ensure that you call the super method to have the cell perform all duties it
 * must do to enter or exit its editing mode.&lt;/p&gt;
 *
 * &lt;p&gt;Once your cell is in an editing state, the next thing you are most probably
 * interested in is how to commit or cancel the editing that is taking place. This is your
 * responsibility as the cell factory provider. Your cell implementation will know
 * when the editing is over, based on the user input (e.g. when the user presses
 * the Enter or ESC keys on their keyboard). When this happens, it is your
 * responsibility to call {@link Cell#commitEdit(Object)} or
 * {@link Cell#cancelEdit()}, as appropriate.&lt;/p&gt;
 *
 * &lt;p&gt;When you call {@link Cell#commitEdit(Object)} an event is fired to the
 * TableView, which you can observe by adding an {@link EventHandler} via
 * {@link TableColumn#setOnEditCommit(javafx.event.EventHandler)}. Similarly,
 * you can also observe edit events for
 * {@link TableColumn#setOnEditStart(javafx.event.EventHandler) edit start}
 * and {@link TableColumn#setOnEditCancel(javafx.event.EventHandler) edit cancel}.&lt;/p&gt;
 *
 * &lt;p&gt;By default the TableColumn edit commit handler is non-null, with a default
 * handler that attempts to overwrite the property value for the
 * item in the currently-being-edited row. It is able to do this as the
 * {@link Cell#commitEdit(Object)} method is passed in the new value, and this
 * is passed along to the edit commit handler via the
 * {@link javafx.scene.control.TableColumn.CellEditEvent CellEditEvent} that is
 * fired. It is simply a matter of calling
 * {@link javafx.scene.control.TableColumn.CellEditEvent#getNewValue()} to
 * retrieve this value.
 *
 * &lt;p&gt;It is very important to note that if you call
 * {@link TableColumn#setOnEditCommit(javafx.event.EventHandler)} with your own
 * {@link EventHandler}, then you will be removing the default handler. Unless
 * you then handle the writeback to the property (or the relevant data source),
 * nothing will happen. You can work around this by using the
 * {@link TableColumn#addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}
 * method to add a {@link TableColumn#editCommitEvent()} {@link EventType} with
 * your desired {@link EventHandler} as the second argument. Using this method,
 * you will not replace the default implementation, but you will be notified when
 * an edit commit has occurred.&lt;/p&gt;
 *
 * &lt;p&gt;Hopefully this summary answers some of the commonly asked questions.
 * Fortunately, JavaFX ships with a number of pre-built cell factories that
 * handle all the editing requirements on your behalf. You can find these
 * pre-built cell factories in the javafx.scene.control.cell package.&lt;/p&gt;
 *
 * @see TableColumn
 * @see TablePosition
 * @param &lt;S&gt; The type of the objects contained within the TableView items list.
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;items&quot;)
public class TableView&lt;S&gt; extends Control {

    /***************************************************************************
     *                                                                         *
     * Static properties and methods                                           *
     *                                                                         *
     **************************************************************************/

    // strings used to communicate via the TableView properties map between
    // the control and the skin. Because they are private here, the strings
    // are also duplicated in the TableViewSkin class - so any changes to these
    // strings must also be duplicated there
    static final String SET_CONTENT_WIDTH = &quot;TableView.contentWidth&quot;;

    /**
     * &lt;p&gt;Very simple resize policy that just resizes the specified column by the
     * provided delta and shifts all other columns (to the right of the given column)
     * further to the right (when the delta is positive) or to the left (when the
     * delta is negative).
     *
     * &lt;p&gt;It also handles the case where we have nested columns by sharing the new space,
     * or subtracting the removed space, evenly between all immediate children columns.
     * Of course, the immediate children may themselves be nested, and they would
     * then use this policy on their children.
     */
    public static final Callback&lt;ResizeFeatures, Boolean&gt; UNCONSTRAINED_RESIZE_POLICY = new Callback&lt;ResizeFeatures, Boolean&gt;() {
        @Override public String toString() {
            return &quot;unconstrained-resize&quot;;
        }

        @Override public Boolean call(ResizeFeatures prop) {
            double result = TableUtil.resize(prop.getColumn(), prop.getDelta());
            return Double.compare(result, 0.0) == 0;
        }
    };

    /**
     * &lt;p&gt;Simple policy that ensures the width of all visible leaf columns in
     * this table sum up to equal the width of the table itself.
     *
     * &lt;p&gt;When the user resizes a column width with this policy, the table automatically
     * adjusts the width of the right hand side columns. When the user increases a
     * column width, the table decreases the width of the rightmost column until it
     * reaches its minimum width. Then it decreases the width of the second
     * rightmost column until it reaches minimum width and so on. When all right
     * hand side columns reach minimum size, the user cannot increase the size of
     * resized column any more.
     */
    public static final Callback&lt;ResizeFeatures, Boolean&gt; CONSTRAINED_RESIZE_POLICY = new Callback&lt;ResizeFeatures, Boolean&gt;() {

        private boolean isFirstRun = true;

        @Override public String toString() {
            return &quot;constrained-resize&quot;;
        }

        @Override public Boolean call(ResizeFeatures prop) {
            TableView&lt;?&gt; table = prop.getTable();
            List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; visibleLeafColumns = table.getVisibleLeafColumns();
            Boolean result = TableUtil.constrainedResize(prop,
                                               isFirstRun,
                                               table.contentWidth,
                                               visibleLeafColumns);
            isFirstRun = ! isFirstRun ? false : ! result;
            return result;
        }
    };

    /**
     * The default {@link #sortPolicyProperty() sort policy} that this TableView
     * will use if no other policy is specified. The sort policy is a simple
     * {@link Callback} that accepts a TableView as the sole argument and expects
     * a Boolean response representing whether the sort succeeded or not. A Boolean
     * response of true represents success, and a response of false (or null) will
     * be considered to represent failure.
     * @since JavaFX 8.0
     */
    public static final Callback&lt;TableView, Boolean&gt; DEFAULT_SORT_POLICY = new Callback&lt;TableView, Boolean&gt;() {
        @Override public Boolean call(TableView table) {
            try {
                ObservableList&lt;?&gt; itemsList = table.getItems();
                if (itemsList instanceof SortedList) {
                    // it is the responsibility of the SortedList to bind to the
                    // comparator provided by the TableView. However, we don't
                    // want to fail the sort (which would put the UI in an
                    // inconsistent state), so we return true here, but only if
                    // the SortedList has its comparator bound to the TableView
                    // comparator property.
                    SortedList sortedList = (SortedList) itemsList;
                    boolean comparatorsBound = sortedList.comparatorProperty().
                            isEqualTo(table.comparatorProperty()).get();

                    if (! comparatorsBound) {
                        // this isn't a good situation to be in, so lets log it
                        // out in case the developer is unaware
                        if (Logging.getControlsLogger().isLoggable(Level.INFO)) {
                            String s = &quot;TableView items list is a SortedList, but the SortedList &quot; +
                                    &quot;comparator should be bound to the TableView comparator for &quot; +
                                    &quot;sorting to be enabled (e.g. &quot; +
                                    &quot;sortedList.comparatorProperty().bind(tableView.comparatorProperty());).&quot;;
                            Logging.getControlsLogger().info(s);
                        }
                    }
                    return comparatorsBound;
                } else {
                    if (itemsList == null || itemsList.isEmpty()) {
                        // sorting is not supported on null or empty lists
                        return true;
                    }

                    Comparator comparator = table.getComparator();
                    if (comparator == null) {
                        return true;
                    }

                    // otherwise we attempt to do a manual sort, and if successful
                    // we return true
                    FXCollections.sort(itemsList, comparator);
                    return true;
                }
            } catch (UnsupportedOperationException e) {
                // TODO might need to support other exception types including:
                // ClassCastException - if the class of the specified element prevents it from being added to this list
                // NullPointerException - if the specified element is null and this list does not permit null elements
                // IllegalArgumentException - if some property of this element prevents it from being added to this list

                // If we are here the list does not support sorting, so we gracefully
                // fail the sort request and ensure the UI is put back to its previous
                // state. This is handled in the code that calls the sort policy.

                return false;
            }
        }
    };



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default TableView control with no content.
     *
     * &lt;p&gt;Refer to the {@link TableView} class documentation for details on the
     * default state of other properties.
     */
    public TableView() {
        this(FXCollections.&lt;S&gt;observableArrayList());
    }

    /**
     * Creates a TableView with the content provided in the items ObservableList.
     * This also sets up an observer such that any changes to the items list
     * will be immediately reflected in the TableView itself.
     *
     * &lt;p&gt;Refer to the {@link TableView} class documentation for details on the
     * default state of other properties.
     *
     * @param items The items to insert into the TableView, and the list to watch
     *          for changes (to automatically show in the TableView).
     */
    public TableView(ObservableList&lt;S&gt; items) {
        getStyleClass().setAll(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.TABLE_VIEW);

        // we quite happily accept items to be null here
        setItems(items);

        // install default selection and focus models
        // it's unlikely this will be changed by many users.
        setSelectionModel(new TableViewArrayListSelectionModel&lt;S&gt;(this));
        setFocusModel(new TableViewFocusModel&lt;S&gt;(this));

        // we watch the columns list, such that when it changes we can update
        // the leaf columns and visible leaf columns lists (which are read-only).
        getColumns().addListener(weakColumnsObserver);

        // watch for changes to the sort order list - and when it changes run
        // the sort method.
        getSortOrder().addListener((ListChangeListener&lt;TableColumn&lt;S, ?&gt;&gt;) c -&gt; {
            doSort(TableUtil.SortEventType.SORT_ORDER_CHANGE, c);
        });

        // We're watching for changes to the content width such
        // that the resize policy can be run if necessary. This comes from
        // TreeViewSkin.
        getProperties().addListener(new MapChangeListener&lt;Object, Object&gt;() {
            @Override
            public void onChanged(Change&lt;? extends Object, ? extends Object&gt; c) {
                if (c.wasAdded() &amp;&amp; SET_CONTENT_WIDTH.equals(c.getKey())) {
                    if (c.getValueAdded() instanceof Number) {
                        setContentWidth((Double) c.getValueAdded());
                    }
                    getProperties().remove(SET_CONTENT_WIDTH);
                }
            }
        });

        isInited = true;
    }



    /***************************************************************************
     *                                                                         *
     * Instance Variables                                                      *
     *                                                                         *
     **************************************************************************/

    // this is the only publicly writable list for columns. This represents the
    // columns as they are given initially by the developer.
    private final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; columns = FXCollections.observableArrayList();

    // Finally, as convenience, we also have an observable list that contains
    // only the leaf columns that are currently visible.
    private final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; visibleLeafColumns = FXCollections.observableArrayList();
    private final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; unmodifiableVisibleLeafColumns = FXCollections.unmodifiableObservableList(visibleLeafColumns);


    // Allows for multiple column sorting based on the order of the TableColumns
    // in this observableArrayList. Each TableColumn is responsible for whether it is
    // sorted using ascending or descending order.
    private ObservableList&lt;TableColumn&lt;S,?&gt;&gt; sortOrder = FXCollections.observableArrayList();

    // width of VirtualFlow minus the vbar width
    private double contentWidth;

    // Used to minimise the amount of work performed prior to the table being
    // completely initialised. In particular it reduces the amount of column
    // resize operations that occur, which slightly improves startup time.
    private boolean isInited = false;



    /***************************************************************************
     *                                                                         *
     * Callbacks and Events                                                    *
     *                                                                         *
     **************************************************************************/

    private final ListChangeListener&lt;TableColumn&lt;S,?&gt;&gt; columnsObserver = new ListChangeListener&lt;TableColumn&lt;S,?&gt;&gt;() {
        @Override public void onChanged(Change&lt;? extends TableColumn&lt;S,?&gt;&gt; c) {
            final List&lt;TableColumn&lt;S,?&gt;&gt; columns = getColumns();

            // Fix for RT-39822 - don't allow the same column to be installed twice
            while (c.next()) {
                if (c.wasAdded()) {
                    List&lt;TableColumn&lt;S,?&gt;&gt; duplicates = new ArrayList&lt;&gt;();
                    for (TableColumn&lt;S,?&gt; addedColumn : c.getAddedSubList()) {
                        if (addedColumn == null) continue;

                        int count = 0;
                        for (TableColumn&lt;S,?&gt; column : columns) {
                            if (addedColumn == column) {
                                count++;
                            }
                        }

                        if (count &gt; 1) {
                            duplicates.add(addedColumn);
                        }
                    }

                    if (!duplicates.isEmpty()) {
                        String titleList = &quot;&quot;;
                        for (TableColumn&lt;S,?&gt; dupe : duplicates) {
                            titleList += &quot;'&quot; + dupe.getText() + &quot;', &quot;;
                        }
                        throw new IllegalStateException(&quot;Duplicate TableColumns detected in TableView columns list with titles &quot; + titleList);
                    }
                }
            }
            c.reset();

            // Fix for RT-15194: Need to remove removed columns from the
            // sortOrder list.
            List&lt;TableColumn&lt;S,?&gt;&gt; toRemove = new ArrayList&lt;&gt;();
            while (c.next()) {
                final List&lt;? extends TableColumn&lt;S, ?&gt;&gt; removed = c.getRemoved();
                final List&lt;? extends TableColumn&lt;S, ?&gt;&gt; added = c.getAddedSubList();

                if (c.wasRemoved()) {
                    toRemove.addAll(removed);
                    for (TableColumn&lt;S,?&gt; tc : removed) {
                        tc.setTableView(null);
                    }
                }

                if (c.wasAdded()) {
                    toRemove.removeAll(added);
                    for (TableColumn&lt;S,?&gt; tc : added) {
                        tc.setTableView(TableView.this);
                    }
                }

                // set up listeners
                TableUtil.removeColumnsListener(removed, weakColumnsObserver);
                TableUtil.addColumnsListener(added, weakColumnsObserver);

                TableUtil.removeTableColumnListener(c.getRemoved(),
                        weakColumnVisibleObserver,
                        weakColumnSortableObserver,
                        weakColumnSortTypeObserver,
                        weakColumnComparatorObserver);
                TableUtil.addTableColumnListener(c.getAddedSubList(),
                        weakColumnVisibleObserver,
                        weakColumnSortableObserver,
                        weakColumnSortTypeObserver,
                        weakColumnComparatorObserver);
            }

            // We don't maintain a bind for leafColumns, we simply call this update
            // function behind the scenes in the appropriate places.
            updateVisibleLeafColumns();

            sortOrder.removeAll(toRemove);

            // Fix for RT-38892.
            final TableViewFocusModel&lt;S&gt; fm = getFocusModel();
            final TableViewSelectionModel&lt;S&gt; sm = getSelectionModel();
            c.reset();

            // we need to collect together all removed and all added columns, because
            // the code below works on the actually removed columns. If we perform
            // the code within this while loop, we'll be deselecting columns that
            // should be deselected (because they have just moved place, for example).
            List&lt;TableColumn&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;();
            List&lt;TableColumn&lt;S,?&gt;&gt; added = new ArrayList&lt;&gt;();
            while (c.next()) {
                if (c.wasRemoved()) {
                    removed.addAll(c.getRemoved());
                }
                if (c.wasAdded()) {
                    added.addAll(c.getAddedSubList());
                }
            }
            removed.removeAll(added);

            // Fix for focus - we simply move focus to a cell to the left
            // of the focused cell if the focused cell was located within
            // a column that has been removed.
            if (fm != null) {
                TablePosition&lt;S, ?&gt; focusedCell = fm.getFocusedCell();
                boolean match = false;
                for (TableColumn&lt;S, ?&gt; tc : removed) {
                    match = focusedCell != null &amp;&amp; focusedCell.getTableColumn() == tc;
                    if (match) {
                        break;
                    }
                }

                if (match) {
                    int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(focusedCell.getTableColumn(), 0);
                    int newFocusColumnIndex =
                            matchingColumnIndex == 0 ? 0 :
                            Math.min(getVisibleLeafColumns().size() - 1, matchingColumnIndex - 1);
                    fm.focus(focusedCell.getRow(), getVisibleLeafColumn(newFocusColumnIndex));
                }
            }

            // Fix for selection - we remove selection from all cells that
            // were within the removed column.
            if (sm != null) {
                List&lt;TablePosition&gt; selectedCells = new ArrayList&lt;&gt;(sm.getSelectedCells());
                for (TablePosition selectedCell : selectedCells) {
                    boolean match = false;
                    for (TableColumn&lt;S, ?&gt; tc : removed) {
                        match = selectedCell != null &amp;&amp; selectedCell.getTableColumn() == tc;
                        if (match) break;
                    }

                    if (match) {
                        // we can't just use the selectedCell.getTableColumn(), as that
                        // column no longer exists and therefore its index is not correct.
                        int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(selectedCell.getTableColumn(), -1);
                        if (matchingColumnIndex == -1) continue;

                        if (sm instanceof TableViewArrayListSelectionModel) {
                            // Also, because the table column no longer exists in the columns
                            // list at this point, we can't just call:
                            // sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
                            // as the tableColumn would map to an index of -1, which means that
                            // selection will not be cleared. Instead, we have to create
                            // a new TablePosition with a fixed column index and use that.
                            TablePosition&lt;S,?&gt; fixedTablePosition =
                                    new TablePosition&lt;&gt;(TableView.this,
                                            selectedCell.getRow(),
                                            selectedCell.getTableColumn());
                            fixedTablePosition.fixedColumnIndex = matchingColumnIndex;

                            ((TableViewArrayListSelectionModel)sm).clearSelection(fixedTablePosition);
                        } else {
                            sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
                        }
                    }
                }
            }


            // update the lastKnownColumnIndex map
            lastKnownColumnIndex.clear();
            for (TableColumn&lt;S,?&gt; tc : getColumns()) {
                int index = getVisibleLeafIndex(tc);
                if (index &gt; -1) {
                    lastKnownColumnIndex.put(tc, index);
                }
            }
        }
    };

    private final WeakHashMap&lt;TableColumn&lt;S,?&gt;, Integer&gt; lastKnownColumnIndex = new WeakHashMap&lt;&gt;();

    private final InvalidationListener columnVisibleObserver = valueModel -&gt; {
        updateVisibleLeafColumns();
    };

    private final InvalidationListener columnSortableObserver = valueModel -&gt; {
        Object col = ((Property&lt;?&gt;)valueModel).getBean();
        if (! getSortOrder().contains(col)) return;
        doSort(TableUtil.SortEventType.COLUMN_SORTABLE_CHANGE, col);
    };

    private final InvalidationListener columnSortTypeObserver = valueModel -&gt; {
        Object col = ((Property&lt;?&gt;)valueModel).getBean();
        if (! getSortOrder().contains(col)) return;
        doSort(TableUtil.SortEventType.COLUMN_SORT_TYPE_CHANGE, col);
    };

    private final InvalidationListener columnComparatorObserver = valueModel -&gt; {
        Object col = ((Property&lt;?&gt;)valueModel).getBean();
        if (! getSortOrder().contains(col)) return;
        doSort(TableUtil.SortEventType.COLUMN_COMPARATOR_CHANGE, col);
    };

    /* proxy pseudo-class state change from selectionModel's cellSelectionEnabledProperty */
    private final InvalidationListener cellSelectionModelInvalidationListener = o -&gt; {
        final boolean isCellSelection = ((BooleanProperty)o).get();
        pseudoClassStateChanged(PSEUDO_CLASS_CELL_SELECTION,  isCellSelection);
        pseudoClassStateChanged(PSEUDO_CLASS_ROW_SELECTION,  !isCellSelection);
    };


    private final WeakInvalidationListener weakColumnVisibleObserver =
            new WeakInvalidationListener(columnVisibleObserver);

    private final WeakInvalidationListener weakColumnSortableObserver =
            new WeakInvalidationListener(columnSortableObserver);

    private final WeakInvalidationListener weakColumnSortTypeObserver =
            new WeakInvalidationListener(columnSortTypeObserver);

    private final WeakInvalidationListener weakColumnComparatorObserver =
            new WeakInvalidationListener(columnComparatorObserver);

    private final WeakListChangeListener&lt;TableColumn&lt;S,?&gt;&gt; weakColumnsObserver =
            new WeakListChangeListener&lt;TableColumn&lt;S,?&gt;&gt;(columnsObserver);

    private final WeakInvalidationListener weakCellSelectionModelInvalidationListener =
            new WeakInvalidationListener(cellSelectionModelInvalidationListener);



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/


    // --- Items
    /**
     * The underlying data model for the TableView. Note that it has a generic
     * type that must match the type of the TableView itself.
     * @return the items property
     */
    public final ObjectProperty&lt;ObservableList&lt;S&gt;&gt; itemsProperty() { return items; }
    private ObjectProperty&lt;ObservableList&lt;S&gt;&gt; items =
        new SimpleObjectProperty&lt;ObservableList&lt;S&gt;&gt;(this, &quot;items&quot;) {
            WeakReference&lt;ObservableList&lt;S&gt;&gt; oldItemsRef;

            @Override protected void invalidated() {
                final ObservableList&lt;S&gt; oldItems = oldItemsRef == null ? null : oldItemsRef.get();
                final ObservableList&lt;S&gt; newItems = getItems();

                // Fix for RT-36425
                if (newItems != null &amp;&amp; newItems == oldItems) {
                    return;
                }

                // Fix for RT-35763
                if (! (newItems instanceof SortedList)) {
                    getSortOrder().clear();
                }

                oldItemsRef = new WeakReference&lt;&gt;(newItems);
            }
        };
    public final void setItems(ObservableList&lt;S&gt; value) { itemsProperty().set(value); }
    public final ObservableList&lt;S&gt; getItems() {return items.get(); }


    // --- Table menu button visible
    private BooleanProperty tableMenuButtonVisible;
    /**
     * This controls whether a menu button is available when the user clicks
     * in a designated space within the TableView, within which is a radio menu
     * item for each TableColumn in this table. This menu allows for the user to
     * show and hide all TableColumns easily.
     * @return the tableMenuButtonVisible property
     */
    public final BooleanProperty tableMenuButtonVisibleProperty() {
        if (tableMenuButtonVisible == null) {
            tableMenuButtonVisible = new SimpleBooleanProperty(this, &quot;tableMenuButtonVisible&quot;);
        }
        return tableMenuButtonVisible;
    }
    public final void setTableMenuButtonVisible (boolean value) {
        tableMenuButtonVisibleProperty().set(value);
    }
    public final boolean isTableMenuButtonVisible() {
        return tableMenuButtonVisible == null ? false : tableMenuButtonVisible.get();
    }


    // --- Column Resize Policy
    private ObjectProperty&lt;Callback&lt;ResizeFeatures, Boolean&gt;&gt; columnResizePolicy;
    public final void setColumnResizePolicy(Callback&lt;ResizeFeatures, Boolean&gt; callback) {
        columnResizePolicyProperty().set(callback);
    }
    public final Callback&lt;ResizeFeatures, Boolean&gt; getColumnResizePolicy() {
        return columnResizePolicy == null ? UNCONSTRAINED_RESIZE_POLICY : columnResizePolicy.get();
    }

    /**
     * This is the function called when the user completes a column-resize
     * operation. The two most common policies are available as static functions
     * in the TableView class: {@link #UNCONSTRAINED_RESIZE_POLICY} and
     * {@link #CONSTRAINED_RESIZE_POLICY}.
     * @return columnResizePolicy property
     */
    public final ObjectProperty&lt;Callback&lt;ResizeFeatures, Boolean&gt;&gt; columnResizePolicyProperty() {
        if (columnResizePolicy == null) {
            columnResizePolicy = new SimpleObjectProperty&lt;Callback&lt;ResizeFeatures, Boolean&gt;&gt;(this, &quot;columnResizePolicy&quot;, UNCONSTRAINED_RESIZE_POLICY) {
                private Callback&lt;ResizeFeatures, Boolean&gt; oldPolicy;

                @Override protected void invalidated() {
                    if (isInited) {
                        get().call(new ResizeFeatures(TableView.this, null, 0.0));

                        if (oldPolicy != null) {
                            PseudoClass state = PseudoClass.getPseudoClass(oldPolicy.toString());
                            pseudoClassStateChanged(state, false);
                        }
                        if (get() != null) {
                            PseudoClass state = PseudoClass.getPseudoClass(get().toString());
                            pseudoClassStateChanged(state, true);
                        }
                        oldPolicy = get();
                    }
                }
            };
        }
        return columnResizePolicy;
    }


    // --- Row Factory
    private ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt;&gt; rowFactory;

    /**
     * A function which produces a TableRow. The system is responsible for
     * reusing TableRows. Return from this function a TableRow which
     * might be usable for representing a single row in a TableView.
     * &lt;p&gt;
     * Note that a TableRow is &lt;b&gt;not&lt;/b&gt; a TableCell. A TableRow is
     * simply a container for a TableCell, and in most circumstances it is more
     * likely that you'll want to create custom TableCells, rather than
     * TableRows. The primary use case for creating custom TableRow
     * instances would most probably be to introduce some form of column
     * spanning support.
     * &lt;p&gt;
     * You can create custom TableCell instances per column by assigning the
     * appropriate function to the cellFactory property in the TableColumn class.
     * @return rowFactory property
     */
    public final ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt;&gt; rowFactoryProperty() {
        if (rowFactory == null) {
            rowFactory = new SimpleObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt;&gt;(this, &quot;rowFactory&quot;);
        }
        return rowFactory;
    }
    public final void setRowFactory(Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt; value) {
        rowFactoryProperty().set(value);
    }
    public final Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt; getRowFactory() {
        return rowFactory == null ? null : rowFactory.get();
    }


    // --- Placeholder Node
    private ObjectProperty&lt;Node&gt; placeholder;
    /**
     * This Node is shown to the user when the table has no content to show.
     * This may be the case because the table model has no data in the first
     * place, that a filter has been applied to the table model, resulting
     * in there being nothing to show the user, or that there are no currently
     * visible columns.
     * @return placeholder property
     */
    public final ObjectProperty&lt;Node&gt; placeholderProperty() {
        if (placeholder == null) {
            placeholder = new SimpleObjectProperty&lt;Node&gt;(this, &quot;placeholder&quot;);
        }
        return placeholder;
    }
    public final void setPlaceholder(Node value) {
        placeholderProperty().set(value);
    }
    public final Node getPlaceholder() {
        return placeholder == null ? null : placeholder.get();
    }


    // --- Selection Model
    private ObjectProperty&lt;TableViewSelectionModel&lt;S&gt;&gt; selectionModel
            = new SimpleObjectProperty&lt;TableViewSelectionModel&lt;S&gt;&gt;(this, &quot;selectionModel&quot;) {

        TableViewSelectionModel&lt;S&gt; oldValue = null;

        @Override protected void invalidated() {

            if (oldValue != null) {
                oldValue.cellSelectionEnabledProperty().removeListener(weakCellSelectionModelInvalidationListener);

                if (oldValue instanceof TableViewArrayListSelectionModel) {
                    ((TableViewArrayListSelectionModel)oldValue).dispose();
                }
            }

            oldValue = get();

            if (oldValue != null) {
                oldValue.cellSelectionEnabledProperty().addListener(weakCellSelectionModelInvalidationListener);
                // fake an invalidation to ensure updated pseudo-class state
                weakCellSelectionModelInvalidationListener.invalidated(oldValue.cellSelectionEnabledProperty());
            }
        }
    };

    /**
     * The SelectionModel provides the API through which it is possible
     * to select single or multiple items within a TableView, as  well as inspect
     * which items have been selected by the user. Note that it has a generic
     * type that must match the type of the TableView itself.
     * @return selectionModel property
     */
    public final ObjectProperty&lt;TableViewSelectionModel&lt;S&gt;&gt; selectionModelProperty() {
        return selectionModel;
    }
    public final void setSelectionModel(TableViewSelectionModel&lt;S&gt; value) {
        selectionModelProperty().set(value);
    }

    public final TableViewSelectionModel&lt;S&gt; getSelectionModel() {
        return selectionModel.get();
    }


    // --- Focus Model
    private ObjectProperty&lt;TableViewFocusModel&lt;S&gt;&gt; focusModel;
    public final void setFocusModel(TableViewFocusModel&lt;S&gt; value) {
        focusModelProperty().set(value);
    }
    public final TableViewFocusModel&lt;S&gt; getFocusModel() {
        return focusModel == null ? null : focusModel.get();
    }
    /**
     * Represents the currently-installed {@link TableViewFocusModel} for this
     * TableView. Under almost all circumstances leaving this as the default
     * focus model will suffice.
     * @return focusModel property
     */
    public final ObjectProperty&lt;TableViewFocusModel&lt;S&gt;&gt; focusModelProperty() {
        if (focusModel == null) {
            focusModel = new SimpleObjectProperty&lt;TableViewFocusModel&lt;S&gt;&gt;(this, &quot;focusModel&quot;);
        }
        return focusModel;
    }


//    // --- Span Model
//    private ObjectProperty&lt;SpanModel&lt;S&gt;&gt; spanModel
//            = new SimpleObjectProperty&lt;SpanModel&lt;S&gt;&gt;(this, &quot;spanModel&quot;) {
//
//        @Override protected void invalidated() {
//            ObservableList&lt;String&gt; styleClass = getStyleClass();
//            if (getSpanModel() == null) {
//                styleClass.remove(CELL_SPAN_TABLE_VIEW_STYLE_CLASS);
//            } else if (! styleClass.contains(CELL_SPAN_TABLE_VIEW_STYLE_CLASS)) {
//                styleClass.add(CELL_SPAN_TABLE_VIEW_STYLE_CLASS);
//            }
//        }
//    };
//
//    public final ObjectProperty&lt;SpanModel&lt;S&gt;&gt; spanModelProperty() {
//        return spanModel;
//    }
//    public final void setSpanModel(SpanModel&lt;S&gt; value) {
//        spanModelProperty().set(value);
//    }
//
//    public final SpanModel&lt;S&gt; getSpanModel() {
//        return spanModel.get();
//    }

    // --- Editable
    private BooleanProperty editable;
    public final void setEditable(boolean value) {
        editableProperty().set(value);
    }
    public final boolean isEditable() {
        return editable == null ? false : editable.get();
    }
    /**
     * Specifies whether this TableView is editable - only if the TableView, the
     * TableColumn (if applicable) and the TableCells within it are both
     * editable will a TableCell be able to go into their editing state.
     * @return the editable property
     */
    public final BooleanProperty editableProperty() {
        if (editable == null) {
            editable = new SimpleBooleanProperty(this, &quot;editable&quot;, false);
        }
        return editable;
    }


    // --- Fixed cell size
    private DoubleProperty fixedCellSize;

    /**
     * Sets the new fixed cell size for this control. Any value greater than
     * zero will enable fixed cell size mode, whereas a zero or negative value
     * (or Region.USE_COMPUTED_SIZE) will be used to disabled fixed cell size
     * mode.
     *
     * @param value The new fixed cell size value, or a value less than or equal
     *              to zero (or Region.USE_COMPUTED_SIZE) to disable.
     * @since JavaFX 8.0
     */
    public final void setFixedCellSize(double value) {
        fixedCellSizeProperty().set(value);
    }

    /**
     * Returns the fixed cell size value. A value less than or equal to zero is
     * used to represent that fixed cell size mode is disabled, and a value
     * greater than zero represents the size of all cells in this control.
     *
     * @return A double representing the fixed cell size of this control, or a
     *      value less than or equal to zero if fixed cell size mode is disabled.
     * @since JavaFX 8.0
     */
    public final double getFixedCellSize() {
        return fixedCellSize == null ? Region.USE_COMPUTED_SIZE : fixedCellSize.get();
    }
    /**
     * Specifies whether this control has cells that are a fixed height (of the
     * specified value). If this value is less than or equal to zero,
     * then all cells are individually sized and positioned. This is a slow
     * operation. Therefore, when performance matters and developers are not
     * dependent on variable cell sizes it is a good idea to set the fixed cell
     * size value. Generally cells are around 24px, so setting a fixed cell size
     * of 24 is likely to result in very little difference in visuals, but a
     * improvement to performance.
     *
     * &lt;p&gt;To set this property via CSS, use the -fx-fixed-cell-size property.
     * This should not be confused with the -fx-cell-size property. The difference
     * between these two CSS properties is that -fx-cell-size will size all
     * cells to the specified size, but it will not enforce that this is the
     * only size (thus allowing for variable cell sizes, and preventing the
     * performance gains from being possible). Therefore, when performance matters
     * use -fx-fixed-cell-size, instead of -fx-cell-size. If both properties are
     * specified in CSS, -fx-fixed-cell-size takes precedence.&lt;/p&gt;
     *
     * @return fixedCellSize property
     * @since JavaFX 8.0
     */
    public final DoubleProperty fixedCellSizeProperty() {
        if (fixedCellSize == null) {
            fixedCellSize = new StyleableDoubleProperty(Region.USE_COMPUTED_SIZE) {
                @Override public CssMetaData&lt;TableView&lt;?&gt;,Number&gt; getCssMetaData() {
                    return StyleableProperties.FIXED_CELL_SIZE;
                }

                @Override public Object getBean() {
                    return TableView.this;
                }

                @Override public String getName() {
                    return &quot;fixedCellSize&quot;;
                }
            };
        }
        return fixedCellSize;
    }


    // --- Editing Cell
    private ReadOnlyObjectWrapper&lt;TablePosition&lt;S,?&gt;&gt; editingCell;
    private void setEditingCell(TablePosition&lt;S,?&gt; value) {
        editingCellPropertyImpl().set(value);
    }
    public final TablePosition&lt;S,?&gt; getEditingCell() {
        return editingCell == null ? null : editingCell.get();
    }

    /**
     * Represents the current cell being edited, or null if
     * there is no cell being edited.
     * @return the editingCell property
     */
    public final ReadOnlyObjectProperty&lt;TablePosition&lt;S,?&gt;&gt; editingCellProperty() {
        return editingCellPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyObjectWrapper&lt;TablePosition&lt;S,?&gt;&gt; editingCellPropertyImpl() {
        if (editingCell == null) {
            editingCell = new ReadOnlyObjectWrapper&lt;TablePosition&lt;S,?&gt;&gt;(this, &quot;editingCell&quot;);
        }
        return editingCell;
    }


    // --- Comparator (built via sortOrder list, so read-only)
    /**
     * The comparator property is a read-only property that is representative of the
     * current state of the {@link #getSortOrder() sort order} list. The sort
     * order list contains the columns that have been added to it either programmatically
     * or via a user clicking on the headers themselves.
     * @since JavaFX 8.0
     */
    private ReadOnlyObjectWrapper&lt;Comparator&lt;S&gt;&gt; comparator;
    private void setComparator(Comparator&lt;S&gt; value) {
        comparatorPropertyImpl().set(value);
    }
    public final Comparator&lt;S&gt; getComparator() {
        return comparator == null ? null : comparator.get();
    }
    public final ReadOnlyObjectProperty&lt;Comparator&lt;S&gt;&gt; comparatorProperty() {
        return comparatorPropertyImpl().getReadOnlyProperty();
    }
    private ReadOnlyObjectWrapper&lt;Comparator&lt;S&gt;&gt; comparatorPropertyImpl() {
        if (comparator == null) {
            comparator = new ReadOnlyObjectWrapper&lt;Comparator&lt;S&gt;&gt;(this, &quot;comparator&quot;);
        }
        return comparator;
    }


    // --- sortPolicy
    /**
     * The sort policy specifies how sorting in this TableView should be performed.
     * For example, a basic sort policy may just call
     * {@code FXCollections.sort(tableView.getItems())}, whereas a more advanced
     * sort policy may call to a database to perform the necessary sorting on the
     * server-side.
     *
     * &lt;p&gt;TableView ships with a {@link TableView#DEFAULT_SORT_POLICY default
     * sort policy} that does precisely as mentioned above: it simply attempts
     * to sort the items list in-place.
     *
     * &lt;p&gt;It is recommended that rather than override the {@link TableView#sort() sort}
     * method that a different sort policy be provided instead.
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, Boolean&gt;&gt; sortPolicy;
    public final void setSortPolicy(Callback&lt;TableView&lt;S&gt;, Boolean&gt; callback) {
        sortPolicyProperty().set(callback);
    }
    @SuppressWarnings(&quot;unchecked&quot;)
    public final Callback&lt;TableView&lt;S&gt;, Boolean&gt; getSortPolicy() {
        return sortPolicy == null ?
                (Callback&lt;TableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY :
                sortPolicy.get();
    }
    @SuppressWarnings(&quot;unchecked&quot;)
    public final ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, Boolean&gt;&gt; sortPolicyProperty() {
        if (sortPolicy == null) {
            sortPolicy = new SimpleObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, Boolean&gt;&gt;(
                    this, &quot;sortPolicy&quot;, (Callback&lt;TableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY) {
                @Override protected void invalidated() {
                    sort();
                }
            };
        }
        return sortPolicy;
    }


    // onSort
    /**
     * Called when there's a request to sort the control.
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt;&gt; onSort;

    public void setOnSort(EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; value) {
        onSortProperty().set(value);
    }

    public EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; getOnSort() {
        if( onSort != null ) {
            return onSort.get();
        }
        return null;
    }

    public ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt;&gt; onSortProperty() {
        if( onSort == null ) {
            onSort = new ObjectPropertyBase&lt;EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt;&gt;() {
                @Override protected void invalidated() {
                    EventType&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; eventType = SortEvent.sortEvent();
                    EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; eventHandler = get();
                    setEventHandler(eventType, eventHandler);
                }

                @Override public Object getBean() {
                    return TableView.this;
                }

                @Override public String getName() {
                    return &quot;onSort&quot;;
                }
            };
        }
        return onSort;
    }


    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/
    /**
     * The TableColumns that are part of this TableView. As the user reorders
     * the TableView columns, this list will be updated to reflect the current
     * visual ordering.
     *
     * &lt;p&gt;Note: to display any data in a TableView, there must be at least one
     * TableColumn in this ObservableList.&lt;/p&gt;
     * @return the columns
     */
    public final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; getColumns() {
        return columns;
    }

    /**
     * The sortOrder list defines the order in which {@link TableColumn} instances
     * are sorted. An empty sortOrder list means that no sorting is being applied
     * on the TableView. If the sortOrder list has one TableColumn within it,
     * the TableView will be sorted using the
     * {@link TableColumn#sortTypeProperty() sortType} and
     * {@link TableColumn#comparatorProperty() comparator} properties of this
     * TableColumn (assuming
     * {@link TableColumn#sortableProperty() TableColumn.sortable} is true).
     * If the sortOrder list contains multiple TableColumn instances, then
     * the TableView is firstly sorted based on the properties of the first
     * TableColumn. If two elements are considered equal, then the second
     * TableColumn in the list is used to determine ordering. This repeats until
     * the results from all TableColumn comparators are considered, if necessary.
     *
     * @return An ObservableList containing zero or more TableColumn instances.
     */
    public final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; getSortOrder() {
        return sortOrder;
    }

    /**
     * Scrolls the TableView so that the given index is visible within the viewport.
     * @param index The index of an item that should be visible to the user.
     */
    public void scrollTo(int index) {
       ControlUtils.scrollToIndex(this, index);
    }

    /**
     * Scrolls the TableView so that the given object is visible within the viewport.
     * @param object The object that should be visible to the user.
     * @since JavaFX 8.0
     */
    public void scrollTo(S object) {
        if( getItems() != null ) {
            int idx = getItems().indexOf(object);
            if( idx &gt;= 0 ) {
                ControlUtils.scrollToIndex(this, idx);
            }
        }
    }

    /**
     * Called when there's a request to scroll an index into view using {@link #scrollTo(int)}
     * or {@link #scrollTo(Object)}
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollTo;

    public void setOnScrollTo(EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; value) {
        onScrollToProperty().set(value);
    }

    public EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; getOnScrollTo() {
        if( onScrollTo != null ) {
            return onScrollTo.get();
        }
        return null;
    }

    public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollToProperty() {
        if( onScrollTo == null ) {
            onScrollTo = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt;() {
                @Override
                protected void invalidated() {
                    setEventHandler(ScrollToEvent.scrollToTopIndex(), get());
                }
                @Override
                public Object getBean() {
                    return TableView.this;
                }

                @Override
                public String getName() {
                    return &quot;onScrollTo&quot;;
                }
            };
        }
        return onScrollTo;
    }

    /**
     * Scrolls the TableView so that the given column is visible within the viewport.
     * @param column The column that should be visible to the user.
     * @since JavaFX 8.0
     */
    public void scrollToColumn(TableColumn&lt;S, ?&gt; column) {
        ControlUtils.scrollToColumn(this, column);
    }

    /**
     * Scrolls the TableView so that the given index is visible within the viewport.
     * @param columnIndex The index of a column that should be visible to the user.
     * @since JavaFX 8.0
     */
    public void scrollToColumnIndex(int columnIndex) {
        if( getColumns() != null ) {
            ControlUtils.scrollToColumn(this, getColumns().get(columnIndex));
        }
    }

    /**
     * Called when there's a request to scroll a column into view using {@link #scrollToColumn(TableColumn)}
     * or {@link #scrollToColumnIndex(int)}
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumn;

    public void setOnScrollToColumn(EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt; value) {
        onScrollToColumnProperty().set(value);
    }

    public EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt; getOnScrollToColumn() {
        if( onScrollToColumn != null ) {
            return onScrollToColumn.get();
        }
        return null;
    }

    public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumnProperty() {
        if( onScrollToColumn == null ) {
            onScrollToColumn = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt;&gt;() {
                @Override protected void invalidated() {
                    EventType&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt; type = ScrollToEvent.scrollToColumn();
                    setEventHandler(type, get());
                }

                @Override public Object getBean() {
                    return TableView.this;
                }

                @Override public String getName() {
                    return &quot;onScrollToColumn&quot;;
                }
            };
        }
        return onScrollToColumn;
    }

    /**
     * Applies the currently installed resize policy against the given column,
     * resizing it based on the delta value provided.
     * @param column the column
     * @param delta the delta
     * @return true if column resize is allowed
     */
    public boolean resizeColumn(TableColumn&lt;S,?&gt; column, double delta) {
        if (column == null || Double.compare(delta, 0.0) == 0) return false;

        boolean allowed = getColumnResizePolicy().call(new ResizeFeatures&lt;S&gt;(TableView.this, column, delta));
        if (!allowed) return false;

        return true;
    }

    /**
     * Causes the cell at the given row/column view indexes to switch into
     * its editing state, if it is not already in it, and assuming that the
     * TableView and column are also editable.
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method will cancel editing if the given row
     * value is less than zero and the given column is null.&lt;/p&gt;
     * @param row the row
     * @param column the column
     */
    public void edit(int row, TableColumn&lt;S,?&gt; column) {
        if (!isEditable() || (column != null &amp;&amp; ! column.isEditable())) {
            return;
        }

        if (row &lt; 0 &amp;&amp; column == null) {
            setEditingCell(null);
        } else {
            setEditingCell(new TablePosition&lt;&gt;(this, row, column));
        }
    }

    /**
     * Returns an unmodifiable list containing the currently visible leaf columns.
     * @return an unmodifiable list containing the currently visible leaf columns
     */
    public ObservableList&lt;TableColumn&lt;S,?&gt;&gt; getVisibleLeafColumns() {
        return unmodifiableVisibleLeafColumns;
    }

    /**
     * Returns the position of the given column, relative to all other
     * visible leaf columns.
     * @param column the column
     * @return the position of the given column, relative to all other
     * visible leaf columns
     */
    public int getVisibleLeafIndex(TableColumn&lt;S,?&gt; column) {
        return visibleLeafColumns.indexOf(column);
    }

    /**
     * Returns the TableColumn in the given column index, relative to all other
     * visible leaf columns.
     * @param column the column
     * @return the TableColumn in the given column index, relative to all other
     * visible leaf columns
     */
    public TableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
        if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
        return visibleLeafColumns.get(column);
    }

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new TableViewSkin&lt;S&gt;(this);
    }

    /**
     * The sort method forces the TableView to re-run its sorting algorithm. More
     * often than not it is not necessary to call this method directly, as it is
     * automatically called when the {@link #getSortOrder() sort order},
     * {@link #sortPolicyProperty() sort policy}, or the state of the
     * TableColumn {@link TableColumn#sortTypeProperty() sort type} properties
     * change. In other words, this method should only be called directly when
     * something external changes and a sort is required.
     * @since JavaFX 8.0
     */
    public void sort() {
        final ObservableList&lt;? extends TableColumnBase&lt;S,?&gt;&gt; sortOrder = getSortOrder();

        // update the Comparator property
        final Comparator&lt;S&gt; oldComparator = getComparator();
        setComparator(sortOrder.isEmpty() ? null : new TableColumnComparator(sortOrder));

        // fire the onSort event and check if it is consumed, if
        // so, don't run the sort
        SortEvent&lt;TableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TableView.this, TableView.this);
        fireEvent(sortEvent);
        if (sortEvent.isConsumed()) {
            // if the sort is consumed we could back out the last action (the code
            // is commented out right below), but we don't as we take it as a
            // sign that the developer has decided to handle the event themselves.

            // sortLock = true;
            // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
            // sortLock = false;
            return;
        }

        final List&lt;TablePosition&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
        final int itemCount = prevState.size();

        // we set makeAtomic to true here, so that we don't fire intermediate
        // sort events - instead we send a single permutation event at the end
        // of this method.
        getSelectionModel().startAtomic();

        // get the sort policy and run it
        Callback&lt;TableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
        if (sortPolicy == null) return;
        Boolean success = sortPolicy.call(this);

        getSelectionModel().stopAtomic();

        if (success == null || ! success) {
            // the sort was a failure. Need to backout if possible
            sortLock = true;
            TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
            setComparator(oldComparator);
            sortLock = false;
        } else {
            // sorting was a success, now we possibly fire an event on the
            // selection model that the items list has 'permutated' to a new ordering

            // FIXME we should support alternative selection model implementations!
            if (getSelectionModel() instanceof TableViewArrayListSelectionModel) {
                final TableViewArrayListSelectionModel&lt;S&gt; sm = (TableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
                final ObservableList&lt;TablePosition&lt;S,?&gt;&gt; newState = (ObservableList&lt;TablePosition&lt;S,?&gt;&gt;)(Object)sm.getSelectedCells();

                List&lt;TablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
                for (int i = 0; i &lt; itemCount; i++) {
                    TablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
                    if (!newState.contains(prevItem)) {
                        removed.add(prevItem);
                    }
                }

                if (!removed.isEmpty()) {
                    // the sort operation effectively permutates the selectedCells list,
                    // but we cannot fire a permutation event as we are talking about
                    // TablePosition's changing (which may reside in the same list
                    // position before and after the sort). Therefore, we need to fire
                    // a single add/remove event to cover the added and removed positions.
                    ListChangeListener.Change&lt;TablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(0, itemCount, removed, newState);
                    sm.fireCustomSelectedCellsListChangeEvent(c);
                }
            }
        }
    }

    /**
     * Calling {@code refresh()} forces the TableView control to recreate and
     * repopulate the cells necessary to populate the visual bounds of the control.
     * In other words, this forces the TableView to update what it is showing to
     * the user. This is useful in cases where the underlying data source has
     * changed in a way that is not observed by the TableView itself.
     *
     * @since JavaFX 8u60
     */
    public void refresh() {
        getProperties().put(Properties.RECREATE, Boolean.TRUE);
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private boolean sortLock = false;
    private TableUtil.SortEventType lastSortEventType = null;
    private Object[] lastSortEventSupportInfo = null;

    private void doSort(final TableUtil.SortEventType sortEventType, final Object... supportInfo) {
        if (sortLock) {
            return;
        }

        this.lastSortEventType = sortEventType;
        this.lastSortEventSupportInfo = supportInfo;
        sort();
        this.lastSortEventType = null;
        this.lastSortEventSupportInfo = null;
    }


    // --- Content width
    private void setContentWidth(double contentWidth) {
        this.contentWidth = contentWidth;
        if (isInited) {
            // sometimes the current column resize policy will have to modify the
            // column width of all columns in the table if the table width changes,
            // so we short-circuit the resize function and just go straight there
            // with a null TableColumn, which indicates to the resize policy function
            // that it shouldn't actually do anything specific to one column.
            getColumnResizePolicy().call(new ResizeFeatures&lt;S&gt;(TableView.this, null, 0.0));
        }
    }

    /**
     * Recomputes the currently visible leaf columns in this TableView.
     */
    private void updateVisibleLeafColumns() {
        // update visible leaf columns list
        List&lt;TableColumn&lt;S,?&gt;&gt; cols = new ArrayList&lt;TableColumn&lt;S,?&gt;&gt;();
        buildVisibleLeafColumns(getColumns(), cols);
        visibleLeafColumns.setAll(cols);

        // sometimes the current column resize policy will have to modify the
        // column width of all columns in the table if the table width changes,
        // so we short-circuit the resize function and just go straight there
        // with a null TableColumn, which indicates to the resize policy function
        // that it shouldn't actually do anything specific to one column.
        getColumnResizePolicy().call(new ResizeFeatures&lt;S&gt;(TableView.this, null, 0.0));
    }

    private void buildVisibleLeafColumns(List&lt;TableColumn&lt;S,?&gt;&gt; cols, List&lt;TableColumn&lt;S,?&gt;&gt; vlc) {
        for (TableColumn&lt;S,?&gt; c : cols) {
            if (c == null) continue;

            boolean hasChildren = ! c.getColumns().isEmpty();

            if (hasChildren) {
                buildVisibleLeafColumns(c.getColumns(), vlc);
            } else if (c.isVisible()) {
                vlc.add(c);
            }
        }
    }



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;table-view&quot;;

    private static final PseudoClass PSEUDO_CLASS_CELL_SELECTION =
            PseudoClass.getPseudoClass(&quot;cell-selection&quot;);
    private static final PseudoClass PSEUDO_CLASS_ROW_SELECTION =
            PseudoClass.getPseudoClass(&quot;row-selection&quot;);

    private static class StyleableProperties {
        private static final CssMetaData&lt;TableView&lt;?&gt;,Number&gt; FIXED_CELL_SIZE =
                new CssMetaData&lt;TableView&lt;?&gt;,Number&gt;(&quot;-fx-fixed-cell-size&quot;,
                                                    SizeConverter.getInstance(),
                                                    Region.USE_COMPUTED_SIZE) {

                    @Override public Double getInitialValue(TableView&lt;?&gt; node) {
                        return node.getFixedCellSize();
                    }

                    @Override public boolean isSettable(TableView&lt;?&gt; n) {
                        return n.fixedCellSize == null || !n.fixedCellSize.isBound();
                    }

                    @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(TableView&lt;?&gt; n) {
                        return (StyleableProperty&lt;Number&gt;) n.fixedCellSizeProperty();
                    }
                };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                    new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
            styleables.add(FIXED_CELL_SIZE);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
        return getClassCssMetaData();
    }



    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case COLUMN_COUNT: return getVisibleLeafColumns().size();
            case ROW_COUNT: return getItems().size();
            case SELECTED_ITEMS: {
                // TableViewSkin returns TableRows back to TableView.
                // TableRowSkin returns TableCells back to TableRow.
                @SuppressWarnings(&quot;unchecked&quot;)
                ObservableList&lt;TableRow&lt;S&gt;&gt; rows = (ObservableList&lt;TableRow&lt;S&gt;&gt;)super.queryAccessibleAttribute(attribute, parameters);
                List&lt;Node&gt; selection = new ArrayList&lt;&gt;();
                for (TableRow&lt;S&gt; row : rows) {
                    @SuppressWarnings(&quot;unchecked&quot;)
                    ObservableList&lt;Node&gt; cells = (ObservableList&lt;Node&gt;)row.queryAccessibleAttribute(attribute, parameters);
                    if (cells != null) selection.addAll(cells);
                }
                return FXCollections.observableArrayList(selection);
            }
            case FOCUS_ITEM: {
                Node row = (Node)super.queryAccessibleAttribute(attribute, parameters);
                if (row == null) return null;
                Node cell = (Node)row.queryAccessibleAttribute(attribute, parameters);
                /* cell equals to null means the row is a placeholder node */
                return cell != null ?  cell : row;
            }
            case CELL_AT_ROW_COLUMN: {
                @SuppressWarnings(&quot;unchecked&quot;)
                TableRow&lt;S&gt; row = (TableRow&lt;S&gt;)super.queryAccessibleAttribute(attribute, parameters);
                return row != null ? row.queryAccessibleAttribute(attribute, parameters) : null;
            }
            case MULTIPLE_SELECTION: {
                MultipleSelectionModel&lt;S&gt; sm = getSelectionModel();
                return sm != null &amp;&amp; sm.getSelectionMode() == SelectionMode.MULTIPLE;
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }


    /***************************************************************************
     *                                                                         *
     * Support Interfaces                                                      *
     *                                                                         *
     **************************************************************************/

     /**
      * An immutable wrapper class for use in the TableView
     * {@link TableView#columnResizePolicyProperty() column resize} functionality.
      * @since JavaFX 2.0
      */
     public static class ResizeFeatures&lt;S&gt; extends ResizeFeaturesBase&lt;S&gt; {
        private TableView&lt;S&gt; table;

        /**
         * Creates an instance of this class, with the provided TableView,
         * TableColumn and delta values being set and stored in this immutable
         * instance.
         *
         * @param table The TableView upon which the resize operation is occurring.
         * @param column The column upon which the resize is occurring, or null
         *      if this ResizeFeatures instance is being created as a result of a
         *      TableView resize operation.
         * @param delta The amount of horizontal space added or removed in the
         *      resize operation.
         */
        public ResizeFeatures(TableView&lt;S&gt; table, TableColumn&lt;S,?&gt; column, Double delta) {
            super(column, delta);
            this.table = table;
        }

        /**
         * Returns the column upon which the resize is occurring, or null
         * if this ResizeFeatures instance was created as a result of a
         * TableView resize operation.
         */
        @Override public TableColumn&lt;S,?&gt; getColumn() {
            return (TableColumn&lt;S,?&gt;) super.getColumn();
        }

        /**
         * Returns the TableView upon which the resize operation is occurring.
         * @return the TableView
         */
        public TableView&lt;S&gt; getTable() {
            return table;
        }
    }



    /***************************************************************************
     *                                                                         *
     * Support Classes                                                         *
     *                                                                         *
     **************************************************************************/


    /**
     * A simple extension of the {@link SelectionModel} abstract class to
     * allow for special support for TableView controls.
     * @since JavaFX 2.0
     */
    public static abstract class TableViewSelectionModel&lt;S&gt; extends TableSelectionModel&lt;S&gt; {

        /***********************************************************************
         *                                                                     *
         * Private fields                                                      *
         *                                                                     *
         **********************************************************************/

        private final TableView&lt;S&gt; tableView;

        boolean blockFocusCall = false;



        /***********************************************************************
         *                                                                     *
         * Constructors                                                        *
         *                                                                     *
         **********************************************************************/

        /**
         * Builds a default TableViewSelectionModel instance with the provided
         * TableView.
         * @param tableView The TableView upon which this selection model should
         *      operate.
         * @throws NullPointerException TableView can not be null.
         */
        public TableViewSelectionModel(final TableView&lt;S&gt; tableView) {
            if (tableView == null) {
                throw new NullPointerException(&quot;TableView can not be null&quot;);
            }

            this.tableView = tableView;
        }



        /***********************************************************************
         *                                                                     *
         * Abstract API                                                        *
         *                                                                     *
         **********************************************************************/

        /**
         * A read-only ObservableList representing the currently selected cells
         * in this TableView. Rather than directly modify this list, please
         * use the other methods provided in the TableViewSelectionModel.
         * @return a read-only ObservableList representing the currently
         * selected cells in this TableView
         */
        public abstract ObservableList&lt;TablePosition&gt; getSelectedCells();


        /***********************************************************************
         *                                                                     *
         * Generic (type erasure) bridging                                     *
         *                                                                     *
         **********************************************************************/

        // --- isSelected
        /** {@inheritDoc} */
        @Override public boolean isSelected(int row, TableColumnBase&lt;S, ?&gt; column) {
            return isSelected(row, (TableColumn&lt;S,?&gt;)column);
        }

        /**
         * Convenience function which tests whether the given row and column index
         * is currently selected in this table instance.
         * @param row the row
         * @param column the column
         * @return true if row and column index is currently selected
         */
        public abstract boolean isSelected(int row, TableColumn&lt;S, ?&gt; column);


        // --- select
        /** {@inheritDoc} */
        @Override public void select(int row, TableColumnBase&lt;S, ?&gt; column) {
            select(row, (TableColumn&lt;S,?&gt;)column);
        }

        /**
         * Selects the cell at the given row/column intersection.
         * @param row the row
         * @param column the column
         */
        public abstract void select(int row, TableColumn&lt;S, ?&gt; column);


        // --- clearAndSelect
        /** {@inheritDoc} */
        @Override public void clearAndSelect(int row, TableColumnBase&lt;S,?&gt; column) {
            clearAndSelect(row, (TableColumn&lt;S,?&gt;) column);
        }

        /**
         * Clears all selection, and then selects the cell at the given row/column
         * intersection.
         * @param row the row
         * @param column the column
         */
        public abstract void clearAndSelect(int row, TableColumn&lt;S,?&gt; column);


        // --- clearSelection
        /** {@inheritDoc} */
        @Override public void clearSelection(int row, TableColumnBase&lt;S,?&gt; column) {
            clearSelection(row, (TableColumn&lt;S,?&gt;) column);
        }

        /**
         * Removes selection from the specified row/column position (in view indexes).
         * If this particular cell (or row if the column value is -1) is not selected,
         * nothing happens.
         * @param row the row
         * @param column the column
         */
        public abstract void clearSelection(int row, TableColumn&lt;S, ?&gt; column);

        /** {@inheritDoc} */
        @Override public void selectRange(int minRow, TableColumnBase&lt;S,?&gt; minColumn,
                                          int maxRow, TableColumnBase&lt;S,?&gt; maxColumn) {
            final int minColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)minColumn);
            final int maxColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)maxColumn);
            for (int _row = minRow; _row &lt;= maxRow; _row++) {
                for (int _col = minColumnIndex; _col &lt;= maxColumnIndex; _col++) {
                    select(_row, tableView.getVisibleLeafColumn(_col));
                }
            }
        }



        /***********************************************************************
         *                                                                     *
         * Public API                                                          *
         *                                                                     *
         **********************************************************************/

        /**
         * Returns the TableView instance that this selection model is installed in.
         * @return the TableView
         */
        public TableView&lt;S&gt; getTableView() {
            return tableView;
        }

        /**
         * Convenience method that returns getTableView().getItems().
         * @return The items list of the current TableView.
         */
        protected List&lt;S&gt; getTableModel()  {
            return tableView.getItems();
        }

        /** {@inheritDoc} */
        @Override protected S getModelItem(int index) {
            if (index &lt; 0 || index &gt;= getItemCount()) return null;
            return tableView.getItems().get(index);
        }

        /** {@inheritDoc} */
        @Override protected int getItemCount() {
            return getTableModel().size();
        }

        /** {@inheritDoc} */
        @Override public void focus(int row) {
            focus(row, null);
        }

        /** {@inheritDoc} */
        @Override public int getFocusedIndex() {
            return getFocusedCell().getRow();
        }



        /***********************************************************************
         *                                                                     *
         * Private implementation                                              *
         *                                                                     *
         **********************************************************************/

        void focus(int row, TableColumn&lt;S,?&gt; column) {
            focus(new TablePosition&lt;&gt;(getTableView(), row, column));
            getTableView().notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
        }

        void focus(TablePosition&lt;S,?&gt; pos) {
            if (blockFocusCall) return;
            if (getTableView().getFocusModel() == null) return;

            getTableView().getFocusModel().focus(pos.getRow(), pos.getTableColumn());
        }

        TablePosition&lt;S,?&gt; getFocusedCell() {
            if (getTableView().getFocusModel() == null) {
                return new TablePosition&lt;&gt;(getTableView(), -1, null);
            }
            return getTableView().getFocusModel().getFocusedCell();
        }
    }



    /**
     * A primitive selection model implementation, using a List&lt;Integer&gt; to store all
     * selected indices.
     */
    // package for testing
    static class TableViewArrayListSelectionModel&lt;S&gt; extends TableViewSelectionModel&lt;S&gt; {

        private int itemCount = 0;

        private final MappingChange.Map&lt;TablePosition&lt;S,?&gt;,Integer&gt; cellToIndicesMap = f -&gt; f.getRow();

        /***********************************************************************
         *                                                                     *
         * Constructors                                                        *
         *                                                                     *
         **********************************************************************/

        public TableViewArrayListSelectionModel(final TableView&lt;S&gt; tableView) {
            super(tableView);
            this.tableView = tableView;

            this.itemsPropertyListener = new InvalidationListener() {
                private WeakReference&lt;ObservableList&lt;S&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());

                @Override public void invalidated(Observable observable) {
                    ObservableList&lt;S&gt; oldItems = weakItemsRef.get();
                    weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());
                    updateItemsObserver(oldItems, tableView.getItems());

                    ((SelectedItemsReadOnlyObservableList)getSelectedItems()).setItemsList(tableView.getItems());
                }
            };
            this.tableView.itemsProperty().addListener(itemsPropertyListener);

            selectedCellsMap = new SelectedCellsMap&lt;TablePosition&lt;S,?&gt;&gt;(this::fireCustomSelectedCellsListChangeEvent) {
                @Override public boolean isCellSelectionEnabled() {
                    return TableViewArrayListSelectionModel.this.isCellSelectionEnabled();
                }
            };

            selectedCellsSeq = new ReadOnlyUnbackedObservableList&lt;TablePosition&lt;S,?&gt;&gt;() {
                @Override public TablePosition&lt;S,?&gt; get(int i) {
                    return selectedCellsMap.get(i);
                }

                @Override public int size() {
                    return selectedCellsMap.size();
                }
            };
//            selectedCellsSeq.addListener((ListChangeListener&lt;? super TablePosition&lt;S,?&gt;&gt;) c -&gt; {
//                ControlUtils.updateSelectedIndices(this, c);
//            });


            /*
             * The following listener is used in conjunction with
             * SelectionModel.select(T obj) to allow for a developer to select
             * an item that is not actually in the data model. When this occurs,
             * we actively try to find an index that matches this object, going
             * so far as to actually watch for all changes to the items list,
             * rechecking each time.
             */

            // watching for changes to the items list content
            ObservableList&lt;S&gt; items = getTableView().getItems();
            if (items != null) {
                ((SelectedItemsReadOnlyObservableList)getSelectedItems()).setItemsList(items);
                items.addListener(weakItemsContentListener);
            }


            updateItemCount();

            updateDefaultSelection();

            cellSelectionEnabledProperty().addListener(o -&gt; {
                updateDefaultSelection();
                TableCellBehaviorBase.setAnchor(tableView, getFocusedCell(), true);
            });
        }

        private void dispose() {
            this.tableView.itemsProperty().removeListener(itemsPropertyListener);

            ObservableList&lt;S&gt; items = getTableView().getItems();
            if (items != null) {
                items.removeListener(weakItemsContentListener);
            }
        }

        private final TableView&lt;S&gt; tableView;

        final InvalidationListener itemsPropertyListener;

        final ListChangeListener&lt;S&gt; itemsContentListener = c -&gt; {
            updateItemCount();

            List&lt;S&gt; items1 = getTableModel();
            boolean doSelectionUpdate = true;

            while (c.next()) {
                if (c.wasReplaced() || c.getAddedSize() == getItemCount()) {
                    this.selectedItemChange = c;
                    updateDefaultSelection();
                    this.selectedItemChange = null;
                    return;
                }

                final S selectedItem = getSelectedItem();
                final int selectedIndex = getSelectedIndex();

                if (items1 == null || items1.isEmpty()) {
                    clearSelection();
                } else if (getSelectedIndex() == -1 &amp;&amp; getSelectedItem() != null) {
                    int newIndex = items1.indexOf(getSelectedItem());
                    if (newIndex != -1) {
                        setSelectedIndex(newIndex);
                        doSelectionUpdate = false;
                    }
                } else if (c.wasRemoved() &amp;&amp;
                        c.getRemovedSize() == 1 &amp;&amp;
                        ! c.wasAdded() &amp;&amp;
                        selectedItem != null &amp;&amp;
                        selectedItem.equals(c.getRemoved().get(0))) {
                    // Bug fix for RT-28637
                    if (getSelectedIndex() &lt; getItemCount()) {
                        final int previousRow = selectedIndex == 0 ? 0 : selectedIndex - 1;
                        S newSelectedItem = getModelItem(previousRow);
                        if (! selectedItem.equals(newSelectedItem)) {
                            clearAndSelect(previousRow);
                        }
                    }
                }
            }

            if (doSelectionUpdate) {
                updateSelection(c);
            }
        };

        final WeakListChangeListener&lt;S&gt; weakItemsContentListener
                = new WeakListChangeListener&lt;&gt;(itemsContentListener);



        /***********************************************************************
         *                                                                     *
         * Observable properties (and getters/setters)                         *
         *                                                                     *
         **********************************************************************/

        // the only 'proper' internal data structure, selectedItems and selectedIndices
        // are both 'read-only and unbacked'.
        private final SelectedCellsMap&lt;TablePosition&lt;S,?&gt;&gt; selectedCellsMap;

        // we create a ReadOnlyUnbackedObservableList of selectedCells here so
        // that we can fire custom list change events.
        private final ReadOnlyUnbackedObservableList&lt;TablePosition&lt;S,?&gt;&gt; selectedCellsSeq;
        @Override public ObservableList&lt;TablePosition&gt; getSelectedCells() {
            return (ObservableList&lt;TablePosition&gt;)(Object)selectedCellsSeq;
        }



        /***********************************************************************
         *                                                                     *
         * Internal properties                                                 *
         *                                                                     *
         **********************************************************************/

        private int previousModelSize = 0;

        // Listen to changes in the tableview items list, such that when it
        // changes we can update the selected indices list to refer to the
        // new indices.
        private void updateSelection(ListChangeListener.Change&lt;? extends S&gt; c) {
            c.reset();

            int shift = 0;
            int startRow = -1;
            while (c.next()) {
                if (c.wasReplaced()) {
                    if (c.getList().isEmpty()) {
                        // the entire items list was emptied - clear selection
                        clearSelection();
                    } else {
                        int index = getSelectedIndex();

                        if (previousModelSize == c.getRemovedSize()) {
                            // all items were removed from the model
                            clearSelection();
                        } else if (index &lt; getItemCount() &amp;&amp; index &gt;= 0) {
                            // Fix for RT-18969: the list had setAll called on it
                            // Use of makeAtomic is a fix for RT-20945
                            startAtomic();
                            clearSelection(index);
                            stopAtomic();
                            select(index);
                        } else {
                            // Fix for RT-22079
                            clearSelection();
                        }
                    }
                } else if (c.wasAdded() || c.wasRemoved()) {
                    startRow = c.getFrom();
                    shift += c.wasAdded() ? c.getAddedSize() : -c.getRemovedSize();
                } else if (c.wasPermutated()) {
                    // General approach:
                    //   -- detected a sort has happened
                    //   -- Create a permutation lookup map (1)
                    //   -- dump all the selected indices into a list (2)
                    //   -- create a list containing the new indices (3)
                    //   -- for each previously-selected index (4)
                    //     -- if index is in the permutation lookup map
                    //       -- add the new index to the new indices list
                    //   -- Perform batch selection (5)

                    startAtomic();

                    final int oldSelectedIndex = getSelectedIndex();

                    // (1)
                    int length = c.getTo() - c.getFrom();
                    HashMap&lt;Integer, Integer&gt; pMap = new HashMap&lt;&gt; (length);
                    for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                        pMap.put(i, c.getPermutation(i));
                    }

                    // (2)
                    List&lt;TablePosition&lt;S,?&gt;&gt; selectedIndices = new ArrayList&lt;&gt;((ObservableList&lt;TablePosition&lt;S,?&gt;&gt;)(Object)getSelectedCells());

                    // (3)
                    List&lt;TablePosition&lt;S,?&gt;&gt; newIndices = new ArrayList&lt;&gt;(selectedIndices.size());

                    // (4)
                    boolean selectionIndicesChanged = false;
                    for (int i = 0; i &lt; selectedIndices.size(); i++) {
                        final TablePosition&lt;S,?&gt; oldIndex = selectedIndices.get(i);
                        final int oldRow = oldIndex.getRow();

                        if (pMap.containsKey(oldRow)) {
                            int newIndex = pMap.get(oldRow);

                            selectionIndicesChanged = selectionIndicesChanged || newIndex != oldRow;

                            newIndices.add(new TablePosition&lt;&gt;(oldIndex.getTableView(), newIndex, oldIndex.getTableColumn()));
                        }
                    }

                    if (selectionIndicesChanged) {
                        // (5)
                        quietClearSelection();
                        stopAtomic();

                        selectedCellsMap.setAll(newIndices);

                        if (oldSelectedIndex &gt;= 0 &amp;&amp; oldSelectedIndex &lt; itemCount) {
                            int newIndex = c.getPermutation(oldSelectedIndex);
                            setSelectedIndex(newIndex);
                            focus(newIndex);
                        }
                    } else {
                        stopAtomic();
                    }
                }
            }

            TablePosition&lt;S,?&gt; anchor = TableCellBehavior.getAnchor(tableView, null);
            if (shift != 0 &amp;&amp; startRow &gt;= 0 &amp;&amp; anchor != null &amp;&amp; (c.wasRemoved() || c.wasAdded())) {
                if (isSelected(anchor.getRow(), anchor.getTableColumn())) {
                    TablePosition&lt;S,?&gt; newAnchor = new TablePosition&lt;&gt;(tableView, anchor.getRow() + shift, anchor.getTableColumn());
                    TableCellBehavior.setAnchor(tableView, newAnchor, false);
                }
            }

            shiftSelection(startRow, shift, new Callback&lt;ShiftParams, Void&gt;() {
                @Override public Void call(ShiftParams param) {

                    // we make the shifts atomic, as otherwise listeners to
                    // the items / indices lists get a lot of intermediate
                    // noise. They eventually get the summary event fired
                    // from within shiftSelection, so this is ok.
                    startAtomic();

                    final int clearIndex = param.getClearIndex();
                    final int setIndex = param.getSetIndex();
                    TablePosition&lt;S,?&gt; oldTP = null;
                    if (clearIndex &gt; -1) {
                        for (int i = 0; i &lt; selectedCellsMap.size(); i++) {
                            TablePosition&lt;S,?&gt; tp = selectedCellsMap.get(i);
                            if (tp.getRow() == clearIndex) {
                                oldTP = tp;
                                selectedCellsMap.remove(tp);
                            } else if (tp.getRow() == setIndex &amp;&amp; !param.isSelected()) {
                                selectedCellsMap.remove(tp);
                            }
                        }
                    }

                    if (oldTP != null &amp;&amp; param.isSelected()) {
                        TablePosition&lt;S,?&gt; newTP = new TablePosition&lt;&gt;(
                                tableView, param.getSetIndex(), oldTP.getTableColumn());

                        selectedCellsMap.add(newTP);
                    }

                    stopAtomic();

                    return null;
                }
            });

            previousModelSize = getItemCount();
        }

        /***********************************************************************
         *                                                                     *
         * Public selection API                                                *
         *                                                                     *
         **********************************************************************/

        @Override public void clearAndSelect(int row) {
            clearAndSelect(row, null);
        }

        @Override public void clearAndSelect(int row, TableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) return;

            final TablePosition&lt;S,?&gt; newTablePosition = new TablePosition&lt;&gt;(getTableView(), row, column);
            final boolean isCellSelectionEnabled = isCellSelectionEnabled();

            // replace the anchor
            TableCellBehavior.setAnchor(tableView, newTablePosition, false);

            // firstly we make a copy of the selection, so that we can send out
            // the correct details in the selection change event.
            List&lt;TablePosition&lt;S,?&gt;&gt; previousSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());

            // secondly we check if we can short-circuit out of here because the new selection
            // equals the current selection
            final boolean wasSelected = isSelected(row, column);
            if (wasSelected &amp;&amp; previousSelection.size() == 1) {
                // before we return, we double-check that the selected item
                // is equal to the item in the given index
                TablePosition&lt;S,?&gt; selectedCell = getSelectedCells().get(0);
                if (getSelectedItem() == getModelItem(row)) {
                    if (selectedCell.getRow() == row &amp;&amp; selectedCell.getTableColumn() == column) {
                        return;
                    }
                }
            }

            // RT-32411 We used to call quietClearSelection() here, but this
            // resulted in the selectedItems and selectedIndices lists never
            // reporting that they were empty.
            // makeAtomic toggle added to resolve RT-32618
            startAtomic();

            // then clear the current selection
            clearSelection();

            // and select the new cell
            select(row, column);

            stopAtomic();


            // We remove the new selection from the list seeing as it is not removed.
            if (isCellSelectionEnabled) {
                previousSelection.remove(newTablePosition);
            } else {
                for (TablePosition&lt;S,?&gt; tp : previousSelection) {
                    if (tp.getRow() == row) {
                        previousSelection.remove(tp);
                        break;
                    }
                }
            }

            // fire off a single add/remove/replace notification (rather than
            // individual remove and add notifications) - see RT-33324
            ListChangeListener.Change&lt;TablePosition&lt;S, ?&gt;&gt; change;

            /*
             * getFrom() documentation:
             *   If wasAdded is true, the interval contains all the values that were added.
             *   If wasPermutated is true, the interval marks the values that were permutated.
             *   If wasRemoved is true and wasAdded is false, getFrom() and getTo() should
             *   return the same number - the place where the removed elements were positioned in the list.
             */
            if (wasSelected) {
                change = ControlUtils.buildClearAndSelectChange(selectedCellsSeq, previousSelection, row);
            } else {
                final int changeIndex = isCellSelectionEnabled ? 0 : Math.max(0, selectedCellsSeq.indexOf(newTablePosition));
                final int changeSize = isCellSelectionEnabled ? getSelectedCells().size() : 1;
                change = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(
                        changeIndex, changeIndex + changeSize, previousSelection, selectedCellsSeq);
//                selectedCellsSeq._beginChange();
//                selectedCellsSeq._nextAdd(changeIndex, changeIndex + changeSize);
//                selectedCellsSeq._nextRemove(changeIndex, previousSelection);
//                selectedCellsSeq._endChange();
            }
            fireCustomSelectedCellsListChangeEvent(change);
        }

        @Override public void select(int row) {
            select(row, null);
        }

        @Override
        public void select(int row, TableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) return;

            // if I'm in cell selection mode but the column is null, select each
            // of the contained cells individually
            if (isCellSelectionEnabled() &amp;&amp; column == null) {
                List&lt;TableColumn&lt;S,?&gt;&gt; columns = getTableView().getVisibleLeafColumns();
                for (int i = 0; i &lt; columns.size(); i++) {
                    select(row, columns.get(i));
                }
                return;
            }

            if (TableCellBehavior.hasDefaultAnchor(tableView)) {
                TableCellBehavior.removeAnchor(tableView);
            }

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
            }
            selectedCellsMap.add(new TablePosition&lt;&gt;(getTableView(), row, column));

            updateSelectedIndex(row);
            focus(row, column);
        }

        @Override public void select(S obj) {
            if (obj == null &amp;&amp; getSelectionMode() == SelectionMode.SINGLE) {
                clearSelection();
                return;
            }

            // We have no option but to iterate through the model and select the
            // first occurrence of the given object. Once we find the first one, we
            // don't proceed to select any others.
            S rowObj = null;
            for (int i = 0; i &lt; getItemCount(); i++) {
                rowObj = getModelItem(i);
                if (rowObj == null) continue;

                if (rowObj.equals(obj)) {
                    if (isSelected(i)) {
                        return;
                    }

                    if (getSelectionMode() == SelectionMode.SINGLE) {
                        quietClearSelection();
                    }

                    select(i);
                    return;
                }
            }

            // if we are here, we did not find the item in the entire data model.
            // Even still, we allow for this item to be set to the give object.
            // We expect that in concrete subclasses of this class we observe the
            // data model such that we check to see if the given item exists in it,
            // whilst SelectedIndex == -1 &amp;&amp; SelectedItem != null.
            setSelectedIndex(-1);
            setSelectedItem(obj);
        }

        @Override public void selectIndices(int row, int... rows) {
            if (rows == null) {
                select(row);
                return;
            }

            /*
             * Performance optimisation - if multiple selection is disabled, only
             * process the end-most row index.
             */
            int rowCount = getItemCount();

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();

                for (int i = rows.length - 1; i &gt;= 0; i--) {
                    int index = rows[i];
                    if (index &gt;= 0 &amp;&amp; index &lt; rowCount) {
                        select(index);
                        break;
                    }
                }

                if (selectedCellsMap.isEmpty()) {
                    if (row &gt; 0 &amp;&amp; row &lt; rowCount) {
                        select(row);
                    }
                }
            } else {
                int lastIndex = -1;
                Set&lt;TablePosition&lt;S,?&gt;&gt; positions = new LinkedHashSet&lt;&gt;();

                // --- firstly, we special-case the non-varargs 'row' argument
                if (row &gt;= 0 &amp;&amp; row &lt; rowCount) {
                    // if I'm in cell selection mode, we want to select each
                    // of the contained cells individually
                    if (isCellSelectionEnabled()) {
                        List&lt;TableColumn&lt;S,?&gt;&gt; columns = getTableView().getVisibleLeafColumns();
                        for (int column = 0; column &lt; columns.size(); column++) {
                            if (! selectedCellsMap.isSelected(row, column)) {
                                positions.add(new TablePosition&lt;&gt;(getTableView(), row, columns.get(column)));
                                lastIndex = row;
                            }
                        }
                    } else {
                        boolean match = selectedCellsMap.isSelected(row, -1);
                        if (!match) {
                            positions.add(new TablePosition&lt;&gt;(getTableView(), row, null));
                        }
                    }

                    lastIndex = row;
                }

                // --- now we iterate through all varargs values
                for (int i = 0; i &lt; rows.length; i++) {
                    int index = rows[i];
                    if (index &lt; 0 || index &gt;= rowCount) continue;
                    lastIndex = index;

                    if (isCellSelectionEnabled()) {
                        List&lt;TableColumn&lt;S,?&gt;&gt; columns = getTableView().getVisibleLeafColumns();
                        for (int column = 0; column &lt; columns.size(); column++) {
                            if (! selectedCellsMap.isSelected(index, column)) {
                                positions.add(new TablePosition&lt;&gt;(getTableView(), index, columns.get(column)));
                                lastIndex = index;
                            }
                        }
                    } else {
                        if (! selectedCellsMap.isSelected(index, -1)) {
                            // if we are here then we have successfully gotten through the for-loop above
                            positions.add(new TablePosition&lt;&gt;(getTableView(), index, null));
                        }
                    }
                }

                selectedCellsMap.addAll(positions);

                if (lastIndex != -1) {
                    select(lastIndex);
                }
            }
        }

        @Override public void selectAll() {
            if (getSelectionMode() == SelectionMode.SINGLE) return;

            if (isCellSelectionEnabled()) {
                List&lt;TablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
                TableColumn&lt;S,?&gt; column;
                TablePosition&lt;S,?&gt; tp = null;
                for (int col = 0; col &lt; getTableView().getVisibleLeafColumns().size(); col++) {
                    column = getTableView().getVisibleLeafColumns().get(col);
                    for (int row = 0; row &lt; getItemCount(); row++) {
                        tp = new TablePosition&lt;&gt;(getTableView(), row, column);
                        indices.add(tp);
                    }
                }
                selectedCellsMap.setAll(indices);

                if (tp != null) {
                    select(tp.getRow(), tp.getTableColumn());
                    focus(tp.getRow(), tp.getTableColumn());
                }
            } else {
                List&lt;TablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
                for (int i = 0; i &lt; getItemCount(); i++) {
                    indices.add(new TablePosition&lt;&gt;(getTableView(), i, null));
                }
                selectedCellsMap.setAll(indices);

                int focusedIndex = getFocusedIndex();
                if (focusedIndex == -1) {
                    final int itemCount = getItemCount();
                    if (itemCount &gt; 0) {
                        select(itemCount - 1);
                        focus(indices.get(indices.size() - 1));
                    }
                } else {
                    select(focusedIndex);
                    focus(focusedIndex);
                }
            }
        }

        @Override public void selectRange(int minRow, TableColumnBase&lt;S,?&gt; minColumn,
                                          int maxRow, TableColumnBase&lt;S,?&gt; maxColumn) {
            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
                select(maxRow, maxColumn);
                return;
            }

            startAtomic();

            final int itemCount = getItemCount();
            final boolean isCellSelectionEnabled = isCellSelectionEnabled();

            final int minColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)minColumn);
            final int maxColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)maxColumn);
            final int _minColumnIndex = Math.min(minColumnIndex, maxColumnIndex);
            final int _maxColumnIndex = Math.max(minColumnIndex, maxColumnIndex);

            final int _minRow = Math.min(minRow, maxRow);
            final int _maxRow = Math.max(minRow, maxRow);

            List&lt;TablePosition&lt;S,?&gt;&gt; cellsToSelect = new ArrayList&lt;&gt;();

            for (int _row = _minRow; _row &lt;= _maxRow; _row++) {
                // begin copy/paste of select(int, column) method (with some
                // slight modifications)
                if (_row &lt; 0 || _row &gt;= itemCount) continue;

                if (! isCellSelectionEnabled) {
                    cellsToSelect.add(new TablePosition&lt;&gt;(tableView, _row, (TableColumn&lt;S,?&gt;)minColumn));
                } else {
                    for (int _col = _minColumnIndex; _col &lt;= _maxColumnIndex; _col++) {
                        final TableColumn&lt;S, ?&gt; column = tableView.getVisibleLeafColumn(_col);

                        // if I'm in cell selection mode but the column is null, I don't want
                        // to select the whole row instead...
                        if (column == null &amp;&amp; isCellSelectionEnabled) continue;

                        cellsToSelect.add(new TablePosition&lt;&gt;(tableView, _row, column));
                        // end copy/paste
                    }
                }
            }

            // to prevent duplication we remove all currently selected cells from
            // our list of cells to select.
            cellsToSelect.removeAll(getSelectedCells());

            selectedCellsMap.addAll(cellsToSelect);
            stopAtomic();

            // fire off events.
            // Note that focus and selection always goes to maxRow, not _maxRow.
            updateSelectedIndex(maxRow);
            focus(maxRow, (TableColumn&lt;S,?&gt;)maxColumn);

            final TableColumn&lt;S,?&gt; startColumn = (TableColumn&lt;S,?&gt;)minColumn;
            final TableColumn&lt;S,?&gt; endColumn = isCellSelectionEnabled ? (TableColumn&lt;S,?&gt;)maxColumn : startColumn;
            final int startChangeIndex = selectedCellsMap.indexOf(new TablePosition&lt;&gt;(tableView, minRow, startColumn));
            final int endChangeIndex = selectedCellsMap.indexOf(new TablePosition&lt;&gt;(tableView, maxRow, endColumn));

            if (startChangeIndex &gt; -1 &amp;&amp; endChangeIndex &gt; -1) {
                final int startIndex = Math.min(startChangeIndex, endChangeIndex);
                final int endIndex = Math.max(startChangeIndex, endChangeIndex);

                ListChangeListener.Change c = new NonIterableChange.SimpleAddChange&lt;&gt;(startIndex, endIndex + 1, selectedCellsSeq);
                fireCustomSelectedCellsListChangeEvent(c);
//                selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextAdd(startIndex, endIndex + 1));
            }
        }

        @Override public void clearSelection(int index) {
            clearSelection(index, null);
        }

        @Override
        public void clearSelection(int row, TableColumn&lt;S,?&gt; column) {
            clearSelection(new TablePosition&lt;&gt;(getTableView(), row, column));
        }

        private void clearSelection(TablePosition&lt;S,?&gt; tp) {
            final boolean csMode = isCellSelectionEnabled();
            final int row = tp.getRow();
            final boolean columnIsNull = tp.getTableColumn() == null;

            List&lt;TablePosition&gt; toRemove = new ArrayList&lt;&gt;();
            for (TablePosition pos : getSelectedCells()) {
                if (!csMode) {
<A NAME="26"></A>                    if (pos.getRow() == row) {
                        toRemove.add(pos);
                        break;
                    <FONT color="#95b9c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#26',2,'match51-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
                } else {
                    if (columnIsNull &amp;&amp; pos.getRow() == row) {
                        // if we are in cell selection mode and the column is null,
                        // we remove all items in the row
                        toRemove.add(pos);
                    } else if (pos.equals(tp)) {
                        toRemove.add</B></FONT>(tp);
                        break;
                    }
                }
            }
            toRemove.stream().forEach(selectedCellsMap::remove);

            if (isEmpty() &amp;&amp; ! isAtomic()) {
                updateSelectedIndex(-1);
                selectedCellsMap.clear();
            }
        }

        @Override public void clearSelection() {
            final List&lt;TablePosition&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;((Collection)getSelectedCells());

            quietClearSelection();

            if (! isAtomic()) {
                updateSelectedIndex(-1);
                focus(-1);

                if (!removed.isEmpty()) {
                    ListChangeListener.Change&lt;TablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange&lt;TablePosition&lt;S, ?&gt;&gt;(0, 0, selectedCellsSeq) {
                        @Override public List&lt;TablePosition&lt;S, ?&gt;&gt; getRemoved() {
                            return removed;
                        }
                    };
                    fireCustomSelectedCellsListChangeEvent(c);
//                    selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextRemove(0, removed));
                }
            }
        }

        private void quietClearSelection() {
            startAtomic();
            selectedCellsMap.clear();
            stopAtomic();
        }

        @Override public boolean isSelected(int index) {
            return isSelected(index, null);
        }

        @Override
        public boolean isSelected(int row, TableColumn&lt;S,?&gt; column) {
            // When in cell selection mode, if the column is null, then we interpret
            // the users query to be asking if _all_ of the cells in the row are selected,
            // rather than if _any_ of the cells in the row are selected.
            final boolean isCellSelectionEnabled = isCellSelectionEnabled();
            if (isCellSelectionEnabled &amp;&amp; column == null) {
                int columnCount = tableView.getVisibleLeafColumns().size();
                for (int col = 0; col &lt; columnCount; col++) {
                    if (!selectedCellsMap.isSelected(row, col)) {
                        return false;
                    }
                }
                return true;
            } else {
                int columnIndex = !isCellSelectionEnabled || column == null ? -1 : tableView.getVisibleLeafIndex(column);
                return selectedCellsMap.isSelected(row, columnIndex);
            }
        }

        @Override public boolean isEmpty() {
            return selectedCellsMap.isEmpty();
        }

        @Override public void selectPrevious() {
            if (isCellSelectionEnabled()) {
                // in cell selection mode, we have to wrap around, going from
                // right-to-left, and then wrapping to the end of the previous line
                TablePosition&lt;S,?&gt; pos = getFocusedCell();
                if (pos.getColumn() - 1 &gt;= 0) {
                    // go to previous row
                    select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
                } else if (pos.getRow() &lt; getItemCount() - 1) {
                    // wrap to end of previous row
                    select(pos.getRow() - 1, getTableColumn(getTableView().getVisibleLeafColumns().size() - 1));
                }
            } else {
                int focusIndex = getFocusedIndex();
                if (focusIndex == -1) {
                    select(getItemCount() - 1);
                } else if (focusIndex &gt; 0) {
                    select(focusIndex - 1);
                }
            }
        }

        @Override public void selectNext() {
            if (isCellSelectionEnabled()) {
                // in cell selection mode, we have to wrap around, going from
                // left-to-right, and then wrapping to the start of the next line
                TablePosition&lt;S,?&gt; pos = getFocusedCell();
                if (pos.getColumn() + 1 &lt; getTableView().getVisibleLeafColumns().size()) {
                    // go to next column
                    select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
                } else if (pos.getRow() &lt; getItemCount() - 1) {
                    // wrap to start of next row
                    select(pos.getRow() + 1, getTableColumn(0));
                }
            } else {
                int focusIndex = getFocusedIndex();
                if (focusIndex == -1) {
                    select(0);
                } else if (focusIndex &lt; getItemCount() -1) {
                    select(focusIndex + 1);
                }
            }
        }

        @Override public void selectAboveCell() {
            TablePosition&lt;S,?&gt; pos = getFocusedCell();
            if (pos.getRow() == -1) {
                select(getItemCount() - 1);
            } else if (pos.getRow() &gt; 0) {
                select(pos.getRow() - 1, pos.getTableColumn());
            }
        }

        @Override public void selectBelowCell() {
            TablePosition&lt;S,?&gt; pos = getFocusedCell();

            if (pos.getRow() == -1) {
                select(0);
            } else if (pos.getRow() &lt; getItemCount() -1) {
                select(pos.getRow() + 1, pos.getTableColumn());
            }
        }

        @Override public void selectFirst() {
            TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
            }

            if (getItemCount() &gt; 0) {
                if (isCellSelectionEnabled()) {
                    select(0, focusedCell.getTableColumn());
                } else {
                    select(0);
                }
            }
        }

        @Override public void selectLast() {
            TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
            }

            int numItems = getItemCount();
            if (numItems &gt; 0 &amp;&amp; getSelectedIndex() &lt; numItems - 1) {
                if (isCellSelectionEnabled()) {
                    select(numItems - 1, focusedCell.getTableColumn());
                } else {
                    select(numItems - 1);
                }
            }
        }

        @Override
        public void selectLeftCell() {
            if (! isCellSelectionEnabled()) return;

            TablePosition&lt;S,?&gt; pos = getFocusedCell();
            if (pos.getColumn() - 1 &gt;= 0) {
                select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
            }
        }

        @Override
        public void selectRightCell() {
            if (! isCellSelectionEnabled()) return;

            TablePosition&lt;S,?&gt; pos = getFocusedCell();
            if (pos.getColumn() + 1 &lt; getTableView().getVisibleLeafColumns().size()) {
                select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
            }
        }



        /***********************************************************************
         *                                                                     *
         * Support code                                                        *
         *                                                                     *
         **********************************************************************/

        private void updateItemsObserver(ObservableList&lt;S&gt; oldList, ObservableList&lt;S&gt; newList) {
            // the items list has changed, we need to observe
            // the new list, and remove any observer we had from the old list
            if (oldList != null) {
                oldList.removeListener(weakItemsContentListener);
            }
            if (newList != null) {
                newList.addListener(weakItemsContentListener);
            }

            updateItemCount();
            updateDefaultSelection();
        }

        private void updateDefaultSelection() {
            // when the items list totally changes, we should clear out
            // the selection
            int newSelectionIndex = -1;
            if (tableView.getItems() != null) {
                S selectedItem = getSelectedItem();
                if (selectedItem != null) {
                    newSelectionIndex = tableView.getItems().indexOf(selectedItem);
                }
            }

            clearSelection();
            select(newSelectionIndex, isCellSelectionEnabled() ? getTableColumn(0) : null);
        }

        private TableColumn&lt;S,?&gt; getTableColumn(int pos) {
            return getTableView().getVisibleLeafColumn(pos);
        }

        // Gets a table column to the left or right of the current one, given an offset
        private TableColumn&lt;S,?&gt; getTableColumn(TableColumn&lt;S,?&gt; column, int offset) {
            int columnIndex = getTableView().getVisibleLeafIndex(column);
            int newColumnIndex = columnIndex + offset;
            return getTableView().getVisibleLeafColumn(newColumnIndex);
        }

        private void updateSelectedIndex(int row) {
            setSelectedIndex(row);
            setSelectedItem(getModelItem(row));
        }

        /** {@inheritDoc} */
        @Override protected int getItemCount() {
            return itemCount;
        }

        private void updateItemCount() {
            if (tableView == null) {
                itemCount = -1;
            } else {
                List&lt;S&gt; items = getTableModel();
                itemCount = items == null ? -1 : items.size();
            }
        }

        private void fireCustomSelectedCellsListChangeEvent(ListChangeListener.Change&lt;? extends TablePosition&lt;S,?&gt;&gt; c) {
            ControlUtils.updateSelectedIndices(this, c);

            if (isAtomic()) {
                return;
            }

            selectedCellsSeq.callObservers(new MappingChange&lt;&gt;(c, MappingChange.NOOP_MAP, selectedCellsSeq));
        }
    }




    /**
     * A {@link FocusModel} with additional functionality to support the requirements
     * of a TableView control.
     *
     * @see TableView
     * @since JavaFX 2.0
     */
    public static class TableViewFocusModel&lt;S&gt; extends TableFocusModel&lt;S, TableColumn&lt;S, ?&gt;&gt; {

        private final TableView&lt;S&gt; tableView;

        private final TablePosition&lt;S,?&gt; EMPTY_CELL;

        /**
         * Creates a default TableViewFocusModel instance that will be used to
         * manage focus of the provided TableView control.
         *
         * @param tableView The tableView upon which this focus model operates.
         * @throws NullPointerException The TableView argument can not be null.
         */
        public TableViewFocusModel(final TableView&lt;S&gt; tableView) {
            if (tableView == null) {
                throw new NullPointerException(&quot;TableView can not be null&quot;);
            }

            this.tableView = tableView;
            this.EMPTY_CELL = new TablePosition&lt;&gt;(tableView, -1, null);

            itemsObserver = new InvalidationListener() {
                private WeakReference&lt;ObservableList&lt;S&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());

                @Override public void invalidated(Observable observable) {
                    ObservableList&lt;S&gt; oldItems = weakItemsRef.get();
                    weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());
                    updateItemsObserver(oldItems, tableView.getItems());
                }
            };
            this.tableView.itemsProperty().addListener(new WeakInvalidationListener(itemsObserver));
            if (tableView.getItems() != null) {
                this.tableView.getItems().addListener(weakItemsContentListener);
            }

            updateDefaultFocus();

            focusedCellProperty().addListener(o -&gt; {
                tableView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
            });
        }

        private final InvalidationListener itemsObserver;

        // Listen to changes in the tableview items list, such that when it
        // changes we can update the focused index to refer to the new indices.
        private final ListChangeListener&lt;S&gt; itemsContentListener = c -&gt; {
            c.next();

            if (c.wasReplaced() || c.getAddedSize() == getItemCount()) {
                updateDefaultFocus();
                return;
            }

            TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
            final int focusedIndex = focusedCell.getRow();
            if (focusedIndex == -1 || c.getFrom() &gt; focusedIndex) {
                return;
            }

            c.reset();
            boolean added = false;
            boolean removed = false;
            int addedSize = 0;
            int removedSize = 0;
            while (c.next()) {
                added |= c.wasAdded();
                removed |= c.wasRemoved();
                addedSize += c.getAddedSize();
                removedSize += c.getRemovedSize();
            }

            if (added &amp;&amp; ! removed) {
                if (addedSize &lt; c.getList().size()) {
                    final int newFocusIndex = Math.min(getItemCount() - 1, getFocusedIndex() + addedSize);
                    focus(newFocusIndex, focusedCell.getTableColumn());
                }
            } else if (!added &amp;&amp; removed) {
                final int newFocusIndex = Math.max(0, getFocusedIndex() - removedSize);
                if (newFocusIndex &lt; 0) {
                    focus(0, focusedCell.getTableColumn());
                } else {
                    focus(newFocusIndex, focusedCell.getTableColumn());
                }
            }
        };

        private WeakListChangeListener&lt;S&gt; weakItemsContentListener
                = new WeakListChangeListener&lt;&gt;(itemsContentListener);

        private void updateItemsObserver(ObservableList&lt;S&gt; oldList, ObservableList&lt;S&gt; newList) {
            // the tableview items list has changed, we need to observe
            // the new list, and remove any observer we had from the old list
            if (oldList != null) oldList.removeListener(weakItemsContentListener);
            if (newList != null) newList.addListener(weakItemsContentListener);

            updateDefaultFocus();
        }

        /** {@inheritDoc} */
        @Override protected int getItemCount() {
            if (tableView.getItems() == null) return -1;
            return tableView.getItems().size();
        }

        /** {@inheritDoc} */
        @Override protected S getModelItem(int index) {
            if (tableView.getItems() == null) return null;

            if (index &lt; 0 || index &gt;= getItemCount()) return null;

            return tableView.getItems().get(index);
        }

        /**
         * The position of the current item in the TableView which has the focus.
         */
        private ReadOnlyObjectWrapper&lt;TablePosition&gt; focusedCell;
        public final ReadOnlyObjectProperty&lt;TablePosition&gt; focusedCellProperty() {
            return focusedCellPropertyImpl().getReadOnlyProperty();
        }
        private void setFocusedCell(TablePosition value) { focusedCellPropertyImpl().set(value);  }
        public final TablePosition getFocusedCell() { return focusedCell == null ? EMPTY_CELL : focusedCell.get(); }

        private ReadOnlyObjectWrapper&lt;TablePosition&gt; focusedCellPropertyImpl() {
            if (focusedCell == null) {
                focusedCell = new ReadOnlyObjectWrapper&lt;TablePosition&gt;(EMPTY_CELL) {
                    private TablePosition old;
                    @Override protected void invalidated() {
                        if (get() == null) return;

                        if (old == null || !old.equals(get())) {
                            setFocusedIndex(get().getRow());
                            setFocusedItem(getModelItem(getValue().getRow()));

                            old = get();
                        }
                    }

                    @Override
                    public Object getBean() {
                        return TableViewFocusModel.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;focusedCell&quot;;
                    }
                };
            }
            return focusedCell;
        }


        /**
         * Causes the item at the given index to receive the focus.
         *
         * @param row The row index of the item to give focus to.
         * @param column The column of the item to give focus to. Can be null.
         */
        @Override public void focus(int row, TableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) {
                setFocusedCell(EMPTY_CELL);
            } else {
                TablePosition&lt;S,?&gt; oldFocusCell = getFocusedCell();
                TablePosition&lt;S,?&gt; newFocusCell = new TablePosition&lt;&gt;(tableView, row, column);
                setFocusedCell(newFocusCell);

                if (newFocusCell.equals(oldFocusCell)) {
                    // manually update the focus properties to ensure consistency
                    setFocusedIndex(row);
                    setFocusedItem(getModelItem(row));
                }
            }
        }

        /**
         * Convenience method for setting focus on a particular row or cell
         * using a {@link TablePosition}.
         *
         * @param pos The table position where focus should be set.
         */
        public void focus(TablePosition pos) {
            if (pos == null) return;
            focus(pos.getRow(), pos.getTableColumn());
        }


        /***********************************************************************
         *                                                                     *
         * Public API                                                          *
         *                                                                     *
         **********************************************************************/

        /**
         * Tests whether the row / cell at the given location currently has the
         * focus within the TableView.
         */
        @Override public boolean isFocused(int row, TableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) return false;

            TablePosition cell = getFocusedCell();
            boolean columnMatch = column == null || column.equals(cell.getTableColumn());

            return cell.getRow() == row &amp;&amp; columnMatch;
        }

        /**
         * Causes the item at the given index to receive the focus. This does not
         * cause the current selection to change. Updates the focusedItem and
         * focusedIndex properties such that &lt;code&gt;focusedIndex = -1&lt;/code&gt; unless
         * &lt;pre&gt;&lt;code&gt;0 &amp;lt;= index &amp;lt; model size&lt;/code&gt;&lt;/pre&gt;.
         *
         * @param index The index of the item to get focus.
         */
        @Override public void focus(int index) {
<A NAME="18"></A>            if (index &lt; 0 || index &gt;= getItemCount()) {
                setFocusedCell(EMPTY_CELL);
            } else {
                <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#18',2,'match51-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>setFocusedCell(new TablePosition&lt;&gt;(tableView, index, null));
            }
        }

        /**
         * Attempts to move focus to the cell above the currently focused cell.
         */
        @Override public void focusAboveCell() {</B></FONT>
            TablePosition cell = getFocusedCell();

            if (getFocusedIndex() == -1) {
                focus(getItemCount() - 1, cell.getTableColumn());
            } else if (getFocusedIndex() &gt; 0) {
                focus(getFocusedIndex() - 1, cell.getTableColumn());
            }
        }

        /**
         * Attempts to move focus to the cell below the currently focused cell.
         */
        @Override public void focusBelowCell() {
            TablePosition cell = getFocusedCell();
            if (getFocusedIndex() == -1) {
                focus(0, cell.getTableColumn());
            } else if (getFocusedIndex() != getItemCount() -1) {
                focus(getFocusedIndex() + 1, cell.getTableColumn());
            }
        }

        /**
         * Attempts to move focus to the cell to the left of the currently focused cell.
         */
        @Override public void focusLeftCell() {
            TablePosition cell = getFocusedCell();
            if (cell.getColumn() &lt;= 0) return;
            focus(cell.getRow(), getTableColumn(cell.getTableColumn(), -1));
        }

        /**
         * Attempts to move focus to the cell to the right of the the currently focused cell.
         */
        @Override public void focusRightCell() {
            TablePosition cell = getFocusedCell();
            if (cell.getColumn() == getColumnCount() - 1) return;
            focus(cell.getRow(), getTableColumn(cell.getTableColumn(), 1));
        }

        /** {@inheritDoc} */
        @Override public void focusPrevious() {
            if (getFocusedIndex() == -1) {
                focus(0);
            } else if (getFocusedIndex() &gt; 0) {
                focusAboveCell();
            }
        }

        /** {@inheritDoc} */
        @Override public void focusNext() {
            if (getFocusedIndex() == -1) {
                focus(0);
            } else if (getFocusedIndex() != getItemCount() -1) {
                focusBelowCell();
            }
        }

        /***********************************************************************
         *                                                                     *
         * Private Implementation                                              *
         *                                                                     *
         **********************************************************************/

        private void updateDefaultFocus() {
            // when the items list totally changes, we should clear out
            // the focus
            int newValueIndex = -1;
            if (tableView.getItems() != null) {
                S focusedItem = getFocusedItem();
                if (focusedItem != null) {
                    newValueIndex = tableView.getItems().indexOf(focusedItem);
                }

                // we put focus onto the first item, if there is at least
                // one item in the list
                if (newValueIndex == -1) {
                    newValueIndex = tableView.getItems().size() &gt; 0 ? 0 : -1;
                }
            }

            TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
            TableColumn&lt;S,?&gt; focusColumn = focusedCell != null &amp;&amp; !EMPTY_CELL.equals(focusedCell) ?
               focusedCell.getTableColumn() : tableView.getVisibleLeafColumn(0);

            focus(newValueIndex, focusColumn);
        }

        private int getColumnCount() {
            return tableView.getVisibleLeafColumns().size();
        }

        // Gets a table column to the left or right of the current one, given an offset
        private TableColumn&lt;S,?&gt; getTableColumn(TableColumn&lt;S,?&gt; column, int offset) {
            int columnIndex = tableView.getVisibleLeafIndex(column);
            int newColumnIndex = columnIndex + offset;
            return tableView.getVisibleLeafColumn(newColumnIndex);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/ButtonBarSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javafx.scene.control.skin;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.behavior.BehaviorBase;
import javafx.beans.InvalidationListener;
import javafx.beans.property.ObjectProperty;
import javafx.collections.ListChangeListener;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ButtonBar;
import javafx.scene.control.ButtonBar.ButtonData;
import javafx.scene.control.Control;
import javafx.scene.control.SkinBase;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;

/**
 * Default skin implementation for the {@link ButtonBar} control.
 *
 * @see ButtonBar
 * @since 9
 */
public class ButtonBarSkin extends SkinBase&lt;ButtonBar&gt; {

    /**************************************************************************
     *
     * Static fields
     *
     **************************************************************************/

    private static final double GAP_SIZE = 10;

    private static final String CATEGORIZED_TYPES = &quot;LRHEYNXBIACO&quot;; //$NON-NLS-1$

    // pick an arbitrary number
    private static final double DO_NOT_CHANGE_SIZE = Double.MAX_VALUE - 100;


    /**************************************************************************
     *
     * fields
     *
     **************************************************************************/

    private HBox layout;
    private InvalidationListener buttonDataListener = o -&gt; layoutButtons();



    /**************************************************************************
     *
     * Constructors
     *
     **************************************************************************/

    /**
     * Creates a new ButtonBarSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list.
     *
     * @param control The control that this skin should be installed onto.
     */
    public ButtonBarSkin(final ButtonBar control) {
        super(control);

        this.layout = new HBox(GAP_SIZE) {
            @Override protected void layoutChildren() {
                // has to be called first or layout is not correct sometimes
                resizeButtons();
                super.layoutChildren();
            }
        };
        this.layout.setAlignment(Pos.CENTER);
        this.layout.getStyleClass().add(&quot;container&quot;);
        getChildren().add(layout);

        layoutButtons();

        updateButtonListeners(control.getButtons(), true);
        control.getButtons().addListener((ListChangeListener&lt;Node&gt;) c -&gt; {
            while (c.next()) {
                updateButtonListeners(c.getRemoved(), false);
                updateButtonListeners(c.getAddedSubList(), true);
            }
            layoutButtons();
        });

        registerChangeListener(control.buttonOrderProperty(), e -&gt; layoutButtons());
        registerChangeListener(control.buttonMinWidthProperty(), e -&gt; resizeButtons());
    }



    /**************************************************************************
     *
     * Implementation
     *
     **************************************************************************/

    private void updateButtonListeners(List&lt;? extends Node&gt; list, boolean buttonsAdded) {
        if (list != null) {
            for (Node n : list) {
                final Map&lt;Object, Object&gt; properties = n.getProperties();
                if (properties.containsKey(Properties.BUTTON_DATA_PROPERTY)) {
                    ObjectProperty&lt;ButtonData&gt; property = (ObjectProperty&lt;ButtonData&gt;) properties.get(Properties.BUTTON_DATA_PROPERTY);
                    if (property != null) {
                        if (buttonsAdded) {
                            property.addListener(buttonDataListener);
<A NAME="28"></A>                        } else {
                            property.removeListener(buttonDataListener);
                        }
                    <FONT color="#717d7d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#28',2,'match51-top.html#28',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
                }
            }
        }
    }

    private void layoutButtons() {</B></FONT>
        final ButtonBar buttonBar = getSkinnable();
        final List&lt;? extends Node&gt; buttons = buttonBar.getButtons();
        final double buttonMinWidth = buttonBar.getButtonMinWidth();

        String buttonOrder = getSkinnable().getButtonOrder();

        layout.getChildren().clear();

        // empty is valid, because it is BUTTON_ORDER_NONE
        if (buttonOrder == null) {
            throw new IllegalStateException(&quot;ButtonBar buttonOrder string can not be null&quot;); //$NON-NLS-1$
        }

        if (buttonOrder.equals(ButtonBar.BUTTON_ORDER_NONE)) {
            // when using BUTTON_ORDER_NONE, we just lay out the buttons in the
            // order they are specified, but we do right-align the buttons by
            // inserting a dynamic spacer.
            Spacer.DYNAMIC.add(layout, true);
            for (Node btn: buttons) {
                sizeButton(btn, buttonMinWidth, DO_NOT_CHANGE_SIZE, Double.MAX_VALUE);
                layout.getChildren().add(btn);
                HBox.setHgrow(btn, Priority.NEVER);
            }
        } else {
            doButtonOrderLayout(buttonOrder);
        }
    }

    private void doButtonOrderLayout(String buttonOrder) {
        final ButtonBar buttonBar = getSkinnable();
        final List&lt;? extends Node&gt; buttons = buttonBar.getButtons();
        final double buttonMinWidth = buttonBar.getButtonMinWidth();
        Map&lt;String, List&lt;Node&gt;&gt; buttonMap = buildButtonMap(buttons);

        char[] buttonOrderArr = buttonOrder.toCharArray();

        int buttonIndex = 0; // to determine edge cases
        Spacer spacer = Spacer.NONE;

        for (int i = 0; i &lt; buttonOrderArr.length; i++) {
            char type = buttonOrderArr[i];
            boolean edgeCase = buttonIndex &lt;= 0 &amp;&amp; buttonIndex &gt;= buttons.size()-1;
            boolean hasChildren = ! layout.getChildren().isEmpty();
            if (type == '+') {
                spacer = spacer.replace(Spacer.DYNAMIC);
            } else if (type == '_' &amp;&amp; hasChildren) {
                spacer = spacer.replace(Spacer.FIXED);
            } else {
                List&lt;Node&gt; buttonList = buttonMap.get(String.valueOf(type).toUpperCase());
                if (buttonList != null) {
                    spacer.add(layout,edgeCase);

                    for (Node btn: buttonList) {
                        sizeButton(btn, buttonMinWidth, DO_NOT_CHANGE_SIZE, Double.MAX_VALUE);

                        layout.getChildren().add(btn);
                        HBox.setHgrow(btn, Priority.NEVER);
                        buttonIndex++;
                    }
                    spacer = spacer.replace(Spacer.NONE);
                }
            }
        }

        // now that all buttons have been placed, we need to ensure focus is
        // set on the correct button. Firstly, we check to see if any button
        // is of type Button (which is typically the case), and of these, if
        // any is a default button. If so, we request focus onto this default
        // button.
        // If there is no Button that is a default button, we subsequently look
        // at the ButtonData for each node and request focus on the first one
        // that returns true for isDefaultButton()
        boolean isDefaultSet = false;
        final int childrenCount = buttons.size();
        for (int i = 0; i &lt; childrenCount; i++) {
            Node btn = buttons.get(i);

            if (btn instanceof Button &amp;&amp; ((Button) btn).isDefaultButton()) {
                btn.requestFocus();
                isDefaultSet = true;
                break;
            }
        }
        if (!isDefaultSet) {
            for (int i = 0; i &lt; childrenCount; i++) {
                Node btn = buttons.get(i);
                ButtonData btnData = ButtonBar.getButtonData(btn);

                if (btnData != null &amp;&amp; btnData.isDefaultButton()) {
                    btn.requestFocus();
                    isDefaultSet = true;
                    break;
                }
            }
        }
    }

    private void resizeButtons() {
        final ButtonBar buttonBar = getSkinnable();
        double buttonMinWidth = buttonBar.getButtonMinWidth();
        final List&lt;? extends Node&gt; buttons = buttonBar.getButtons();

        // determine the widest button
        double widest = buttonMinWidth;
        for (Node button : buttons) {
            if (ButtonBar.isButtonUniformSize(button)) {
               widest = Math.max(button.prefWidth(-1), widest);
            }
        }

        // set the width of all buttons
        for (Node button : buttons) {
            if (ButtonBar.isButtonUniformSize(button)) {
                sizeButton(button, DO_NOT_CHANGE_SIZE, widest, DO_NOT_CHANGE_SIZE);
            }
        }
    }

    private void sizeButton(Node btn, double min, double pref, double max) {
        if (btn instanceof Region) {
            Region regionBtn = (Region)btn;

            if (min != DO_NOT_CHANGE_SIZE) {
                regionBtn.setMinWidth(min);
            }
            if (pref != DO_NOT_CHANGE_SIZE) {
                regionBtn.setPrefWidth(pref);
            }
            if (max != DO_NOT_CHANGE_SIZE) {
                regionBtn.setMaxWidth(max);
            }
        }
    }

    private String getButtonType(Node btn) {
        ButtonData buttonType = ButtonBar.getButtonData(btn);

        if (buttonType == null) {
            // just assume it is ButtonType.OTHER
            buttonType = ButtonData.OTHER;
        }

        String typeCode = buttonType.getTypeCode();
        typeCode = typeCode.length() &gt; 0? typeCode.substring(0,1): &quot;&quot;; //$NON-NLS-1$
        return CATEGORIZED_TYPES.contains(typeCode.toUpperCase())? typeCode : ButtonData.OTHER.getTypeCode();
    }

    private Map&lt;String, List&lt;Node&gt;&gt; buildButtonMap( List&lt;? extends Node&gt; buttons ) {
        Map&lt;String, List&lt;Node&gt;&gt; buttonMap = new HashMap&lt;&gt;();
        for (Node btn : buttons) {
            if ( btn == null ) continue;
            String type =  getButtonType(btn);
            List&lt;Node&gt; typedButtons = buttonMap.get(type);
            if ( typedButtons == null ) {
                typedButtons = new ArrayList&lt;Node&gt;();
                buttonMap.put(type, typedButtons);
            }
            typedButtons.add( btn );
        }
        return buttonMap;
    }



    /**************************************************************************
     *
     * Support classes / enums
     *
     **************************************************************************/

    private enum Spacer {
        FIXED {
            @Override protected Node create(boolean edgeCase) {
                if ( edgeCase ) return null;
                Region spacer = new Region();
                ButtonBar.setButtonData(spacer, ButtonData.SMALL_GAP);
                spacer.setMinWidth(GAP_SIZE);
                HBox.setHgrow(spacer, Priority.NEVER);
                return spacer;
            }
        },
        DYNAMIC {
            @Override protected Node create(boolean edgeCase) {
                Region spacer = new Region();
                ButtonBar.setButtonData(spacer, ButtonData.BIG_GAP);
                spacer.setMinWidth(edgeCase ? 0 : GAP_SIZE);
                HBox.setHgrow(spacer, Priority.ALWAYS);
                return spacer;
            }

            @Override public Spacer replace(Spacer spacer) {
                return FIXED == spacer? this: spacer;
            }
        },
        NONE;

        protected Node create(boolean edgeCase) {
            return null;
        }

        public Spacer replace(Spacer spacer) {
            return spacer;
        }

        public void add(Pane pane, boolean edgeCase) {
            Node spacer = create(edgeCase);
            if (spacer != null) {
                pane.getChildren().add(spacer);
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TabPaneSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.TabObservableList;
import com.sun.javafx.util.Utils;
import javafx.animation.Animation;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.animation.Transition;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Point2D;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.geometry.VPos;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Control;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.control.RadioMenuItem;
import javafx.scene.control.SkinBase;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.control.TabPane.TabClosingPolicy;
import javafx.scene.control.TabPane.TabDragPolicy;
import javafx.scene.control.ToggleGroup;
import javafx.scene.control.Tooltip;
import javafx.scene.effect.DropShadow;
import javafx.scene.image.ImageView;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.input.SwipeEvent;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import javafx.css.converter.EnumConverter;
import com.sun.javafx.scene.control.behavior.TabPaneBehavior;

import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;

/**
 * Default skin implementation for the {@link TabPane} control.
 *
 * @see TabPane
 * @since 9
 */
public class TabPaneSkin extends SkinBase&lt;TabPane&gt; {

    /***************************************************************************
     *                                                                         *
     * Enums                                                                   *
     *                                                                         *
     **************************************************************************/

    private enum TabAnimation {
        NONE,
        GROW
        // In future we could add FADE, ...
    }

    private enum TabAnimationState {
        SHOWING, HIDING, NONE;
    }



    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    static int CLOSE_BTN_SIZE = 16;



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private static final double ANIMATION_SPEED = 150;
    private static final int SPACER = 10;

    private TabHeaderArea tabHeaderArea;
    private ObservableList&lt;TabContentRegion&gt; tabContentRegions;
    private Rectangle clipRect;
    private Rectangle tabHeaderAreaClipRect;
    private Tab selectedTab;
    private boolean isSelectingTab;

    private final TabPaneBehavior behavior;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TabPaneSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TabPaneSkin(TabPane control) {
        super(control);

        // install default input map for the TabPane control
        this.behavior = new TabPaneBehavior(control);
//        control.setInputMap(behavior.getInputMap());

        clipRect = new Rectangle(control.getWidth(), control.getHeight());
        getSkinnable().setClip(clipRect);

        tabContentRegions = FXCollections.&lt;TabContentRegion&gt;observableArrayList();

        for (Tab tab : getSkinnable().getTabs()) {
            addTabContent(tab);
        }

        tabHeaderAreaClipRect = new Rectangle();
        tabHeaderArea = new TabHeaderArea();
        tabHeaderArea.setClip(tabHeaderAreaClipRect);
        getChildren().add(tabHeaderArea);
        if (getSkinnable().getTabs().size() == 0) {
            tabHeaderArea.setVisible(false);
        }

        initializeTabListener();

        registerChangeListener(control.getSelectionModel().selectedItemProperty(), e -&gt; {
            isSelectingTab = true;
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
            getSkinnable().requestLayout();
        });
        registerChangeListener(control.sideProperty(), e -&gt; updateTabPosition());
        registerChangeListener(control.widthProperty(), e -&gt; clipRect.setWidth(getSkinnable().getWidth()));
        registerChangeListener(control.heightProperty(), e -&gt; clipRect.setHeight(getSkinnable().getHeight()));

        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        // Could not find the selected tab try and get the selected tab using the selected index
        if (selectedTab == null &amp;&amp; getSkinnable().getSelectionModel().getSelectedIndex() != -1) {
            getSkinnable().getSelectionModel().select(getSkinnable().getSelectionModel().getSelectedIndex());
            selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        }
        if (selectedTab == null) {
            // getSelectedItem and getSelectedIndex failed select the first.
            getSkinnable().getSelectionModel().selectFirst();
        }
        selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
        isSelectingTab = false;

        initializeSwipeHandlers();
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    private ObjectProperty&lt;TabAnimation&gt; openTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.OPEN_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;openTabAnimation&quot;;
        }
    };

    private ObjectProperty&lt;TabAnimation&gt; closeTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
        @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
            return StyleableProperties.CLOSE_TAB_ANIMATION;
        }

        @Override public Object getBean() {
            return TabPaneSkin.this;
        }

        @Override public String getName() {
            return &quot;closeTabAnimation&quot;;
        }
    };



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as wide as it widest content width.
        double maxw = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxw = Math.max(maxw, snapSizeX(contentRegion.prefWidth(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeX(tabHeaderArea.prefWidth(-1))
                : snapSizeY(tabHeaderArea.prefHeight(-1));

        double prefWidth = isHorizontal ?
                Math.max(maxw, tabHeaderAreaSize) : maxw + tabHeaderAreaSize;
        return snapSizeX(prefWidth) + rightInset + leftInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        // The TabPane can only be as high as it highest content height.
        double maxh = 0.0;
        for (TabContentRegion contentRegion: tabContentRegions) {
            maxh = Math.max(maxh, snapSizeY(contentRegion.prefHeight(-1)));
        }

        final boolean isHorizontal = isHorizontal();
        final double tabHeaderAreaSize = isHorizontal
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefWidth(-1));

        double prefHeight = isHorizontal ?
                maxh + snapSizeY(tabHeaderAreaSize) : Math.max(maxh, tabHeaderAreaSize);
        return snapSizeY(prefHeight) + topInset + bottomInset;
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        Side tabPosition = getSkinnable().getSide();
        if (tabPosition == Side.TOP) {
            return tabHeaderArea.getBaselineOffset() + topInset;
        }
        return 0;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        TabPane tabPane = getSkinnable();
        Side tabPosition = tabPane.getSide();

        double headerHeight = tabPosition.isHorizontal()
                ? snapSizeY(tabHeaderArea.prefHeight(-1))
                : snapSizeX(tabHeaderArea.prefHeight(-1));
        double tabsStartX = tabPosition.equals(Side.RIGHT)? x + w - headerHeight : x;
        double tabsStartY = tabPosition.equals(Side.BOTTOM)? y + h - headerHeight : y;

        final double leftInset = snappedLeftInset();
        final double topInset = snappedTopInset();

        if (tabPosition == Side.TOP) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(tabsStartX, tabsStartY);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.TOP)));
        } else if (tabPosition == Side.BOTTOM) {
            tabHeaderArea.resize(w, headerHeight);
            tabHeaderArea.relocate(w + leftInset, tabsStartY - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.BOTTOM), 0, headerHeight));
        } else if (tabPosition == Side.LEFT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX + headerHeight, h - headerHeight + topInset);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.LEFT), 0, headerHeight));
        } else if (tabPosition == Side.RIGHT) {
            tabHeaderArea.resize(h, headerHeight);
            tabHeaderArea.relocate(tabsStartX, y - headerHeight);
            tabHeaderArea.getTransforms().clear();
            tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.RIGHT), 0, headerHeight));
        }

        tabHeaderAreaClipRect.setX(0);
        tabHeaderAreaClipRect.setY(0);
        if (isHorizontal()) {
            tabHeaderAreaClipRect.setWidth(w);
        } else {
            tabHeaderAreaClipRect.setWidth(h);
        }
        tabHeaderAreaClipRect.setHeight(headerHeight);

        // ==================================
        // position the tab content for the selected tab only
        // ==================================
        // if the tabs are on the left, the content needs to be indented
        double contentStartX = 0;
        double contentStartY = 0;

        if (tabPosition == Side.TOP) {
            contentStartX = x;
            contentStartY = y + headerHeight;
            if (isFloatingStyleClass()) {
                // This is to hide the top border content
                contentStartY -= 1;
            }
        } else if (tabPosition == Side.BOTTOM) {
            contentStartX = x;
            contentStartY = y + topInset;
            if (isFloatingStyleClass()) {
                // This is to hide the bottom border content
                contentStartY = 1 + topInset;
            }
        } else if (tabPosition == Side.LEFT) {
            contentStartX = x + headerHeight;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the left border content
                contentStartX -= 1;
            }
        } else if (tabPosition == Side.RIGHT) {
            contentStartX = x + leftInset;
            contentStartY = y;
            if (isFloatingStyleClass()) {
                // This is to hide the right border content
                contentStartX = 1 + leftInset;
            }
        }

        double contentWidth = w - (isHorizontal() ? 0 : headerHeight);
        double contentHeight = h - (isHorizontal() ? headerHeight: 0);

        for (int i = 0, max = tabContentRegions.size(); i &lt; max; i++) {
            TabContentRegion tabContent = tabContentRegions.get(i);

            tabContent.setAlignment(Pos.TOP_LEFT);
            if (tabContent.getClip() != null) {
                ((Rectangle)tabContent.getClip()).setWidth(contentWidth);
                ((Rectangle)tabContent.getClip()).setHeight(contentHeight);
            }

            // we need to size all tabs, even if they aren't visible. For example,
            // see RT-29167
            tabContent.resize(contentWidth, contentHeight);
            tabContent.relocate(contentStartX, contentStartY);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private static int getRotation(Side pos) {
        switch (pos) {
            case TOP:
                return 0;
            case BOTTOM:
                return 180;
            case LEFT:
                return -90;
            case RIGHT:
                return 90;
            default:
                return 0;
        }
    }

    /**
     * VERY HACKY - this lets us 'duplicate' Label and ImageView nodes to be used in a
     * Tab and the tabs menu at the same time.
     */
    private static Node clone(Node n) {
        if (n == null) {
            return null;
        }
        if (n instanceof ImageView) {
            ImageView iv = (ImageView) n;
            ImageView imageview = new ImageView();
            imageview.imageProperty().bind(iv.imageProperty());
            return imageview;
        }
        if (n instanceof Label) {
            Label l = (Label)n;
            Label label = new Label(l.getText(), clone(l.getGraphic()));
            label.textProperty().bind(l.textProperty());
            return label;
        }
        return null;
    }

    private void removeTabs(List&lt;? extends Tab&gt; removedList) {
        for (final Tab tab : removedList) {
            stopCurrentAnimation(tab);
            // Animate the tab removal
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                tabRegion.isClosing = true;

                tabRegion.removeListeners(tab);
                removeTabContent(tab);

                EventHandler&lt;ActionEvent&gt; cleanup = ae -&gt; {
                    tabRegion.animationState = TabAnimationState.NONE;

                    tabHeaderArea.removeTab(tab);
                    tabHeaderArea.requestLayout();
                    if (getSkinnable().getTabs().isEmpty()) {
                        tabHeaderArea.setVisible(false);
                    }
                };

                if (closeTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.HIDING;
                    Timeline closedTabTimeline = tabRegion.currentAnimation =
                            createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 0.0F, cleanup);
                    closedTabTimeline.play();
                } else {
                    cleanup.handle(null);
                }
            }
        }
    }

    private void stopCurrentAnimation(Tab tab) {
        final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
        if (tabRegion != null) {
            // Execute the code immediately, don't wait for the animation to finish.
            Timeline timeline = tabRegion.currentAnimation;
            if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING) {
                timeline.getOnFinished().handle(null);
                timeline.stop();
                tabRegion.currentAnimation = null;
            }
        }
    }

    private void addTabs(List&lt;? extends Tab&gt; addedList, int from) {
        int i = 0;

        // RT-39984: check if any other tabs are animating - they must be completed first.
        List&lt;Node&gt; headers = new ArrayList&lt;&gt;(tabHeaderArea.headersRegion.getChildren());
        for (Node n : headers) {
            TabHeaderSkin header = (TabHeaderSkin) n;
            if (header.animationState == TabAnimationState.HIDING) {
                stopCurrentAnimation(header.tab);
            }
        }
        // end of fix for RT-39984

        for (final Tab tab : addedList) {
            stopCurrentAnimation(tab); // Note that this must happen before addTab() call below
            // A new tab was added - animate it out
            if (!tabHeaderArea.isVisible()) {
                tabHeaderArea.setVisible(true);
            }
            int index = from + i++;
            tabHeaderArea.addTab(tab, index);
            addTabContent(tab);
            final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
            if (tabRegion != null) {
                if (openTabAnimation.get() == TabAnimation.GROW) {
                    tabRegion.animationState = TabAnimationState.SHOWING;
                    tabRegion.animationTransition.setValue(0.0);
                    tabRegion.setVisible(true);
                    tabRegion.currentAnimation = createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 1.0, event -&gt; {
                        tabRegion.animationState = TabAnimationState.NONE;
                        tabRegion.setVisible(true);
                        tabRegion.inner.requestLayout();
                    });
                    tabRegion.currentAnimation.play();
                } else {
                    tabRegion.setVisible(true);
                    tabRegion.inner.requestLayout();
                }
            }
        }
    }

    private void initializeTabListener() {
        getSkinnable().getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; {
            List&lt;Tab&gt; tabsToRemove = new ArrayList&lt;&gt;();
            List&lt;Tab&gt; tabsToAdd = new ArrayList&lt;&gt;();
            int insertPos = -1;

            while (c.next()) {
                if (c.wasPermutated()) {
                    if (dragState != DragState.REORDER) {
                        TabPane tabPane = getSkinnable();
                        List&lt;Tab&gt; tabs = tabPane.getTabs();

                        // tabs sorted : create list of permutated tabs.
                        // clear selection, set tab animation to NONE
                        // remove permutated tabs, add them back in correct order.
<A NAME="19"></A>                        // restore old selection, and old tab animation states.
                        int size = c.getTo() - c.getFrom();
                        Tab selTab = tabPane.getSelectionModel().getSelectedItem();
                        <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#19',2,'match51-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>List&lt;Tab&gt; permutatedTabs = new ArrayList&lt;Tab&gt;(size);
                        getSkinnable().getSelectionModel().clearSelection();

                        // save and set tab animation to none - as it is not a good idea
                        // to animate on the same data for open and close.
                        TabAnimation prevOpenAnimation = openTabAnimation.get();
                        TabAnimation prevCloseAnimation = closeTabAnimation.get();
                        openTabAnimation.set(TabAnimation.NONE);
                        closeTabAnimation.set</B></FONT>(TabAnimation.NONE);
                        for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                            permutatedTabs.add(tabs.get(i));
                        }

                        removeTabs(permutatedTabs);
                        addTabs(permutatedTabs, c.getFrom());
                        openTabAnimation.set(prevOpenAnimation);
                        closeTabAnimation.set(prevCloseAnimation);
                        getSkinnable().getSelectionModel().select(selTab);
                    }
                }

                if (c.wasRemoved()) {
                    tabsToRemove.addAll(c.getRemoved());
                }
                if (c.wasAdded()) {
                    tabsToAdd.addAll(c.getAddedSubList());
                    insertPos = c.getFrom();
                }
            }

            // now only remove the tabs that are not in the tabsToAdd list
            tabsToRemove.removeAll(tabsToAdd);
            removeTabs(tabsToRemove);

            // and add in any new tabs (that we don't already have showing)
            if (!tabsToAdd.isEmpty()) {
                for (TabContentRegion tabContentRegion : tabContentRegions) {
                    Tab tab = tabContentRegion.getTab();
                    TabHeaderSkin tabHeader = tabHeaderArea.getTabHeaderSkin(tab);
                    if (!tabHeader.isClosing &amp;&amp; tabsToAdd.contains(tabContentRegion.getTab())) {
                        tabsToAdd.remove(tabContentRegion.getTab());
                    }
                }

                addTabs(tabsToAdd, insertPos == -1 ? tabContentRegions.size() : insertPos);
            }

            // Fix for RT-34692
            getSkinnable().requestLayout();
        });
    }

    private void addTabContent(Tab tab) {
        TabContentRegion tabContentRegion = new TabContentRegion(tab);
        tabContentRegion.setClip(new Rectangle());
        tabContentRegions.add(tabContentRegion);
        // We want the tab content to always sit below the tab headers
        getChildren().add(0, tabContentRegion);
    }

    private void removeTabContent(Tab tab) {
        for (TabContentRegion contentRegion : tabContentRegions) {
            if (contentRegion.getTab().equals(tab)) {
                contentRegion.removeListeners(tab);
                getChildren().remove(contentRegion);
                tabContentRegions.remove(contentRegion);
                break;
            }
        }
    }

    private void updateTabPosition() {
        tabHeaderArea.setScrollOffset(0.0F);
        getSkinnable().applyCss();
        getSkinnable().requestLayout();
    }

    private Timeline createTimeline(final TabHeaderSkin tabRegion, final Duration duration, final double endValue, final EventHandler&lt;ActionEvent&gt; func) {
        Timeline timeline = new Timeline();
        timeline.setCycleCount(1);

        KeyValue keyValue = new KeyValue(tabRegion.animationTransition, endValue, Interpolator.LINEAR);
        timeline.getKeyFrames().clear();
        timeline.getKeyFrames().add(new KeyFrame(duration, keyValue));

        timeline.setOnFinished(func);
        return timeline;
    }

    private boolean isHorizontal() {
        Side tabPosition = getSkinnable().getSide();
        return Side.TOP.equals(tabPosition) || Side.BOTTOM.equals(tabPosition);
    }

    private void initializeSwipeHandlers() {
        if (Properties.IS_TOUCH_SUPPORTED) {
            getSkinnable().addEventHandler(SwipeEvent.SWIPE_LEFT, t -&gt; {
                behavior.selectNextTab();
            });

            getSkinnable().addEventHandler(SwipeEvent.SWIPE_RIGHT, t -&gt; {
                behavior.selectPreviousTab();
            });
        }
    }

    //TODO need to cache this.
    private boolean isFloatingStyleClass() {
        return getSkinnable().getStyleClass().contains(TabPane.STYLE_CLASS_FLOATING);
    }



    /***************************************************************************
     *                                                                         *
     * CSS                                                                     *
     *                                                                         *
     **************************************************************************/

   /*
    * Super-lazy instantiation pattern from Bill Pugh.
    */
   private static class StyleableProperties {
        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; OPEN_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-open-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.openTabAnimation;
            }
        };

        private final static CssMetaData&lt;TabPane,TabAnimation&gt; CLOSE_TAB_ANIMATION =
                new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-close-tab-animation&quot;,
                    new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {

            @Override public boolean isSettable(TabPane node) {
                return true;
            }

            @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
                TabPaneSkin skin = (TabPaneSkin) node.getSkin();
                return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.closeTabAnimation;
            }
        };

        static {

           final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
               new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
           styleables.add(OPEN_TAB_ANIMATION);
           styleables.add(CLOSE_TAB_ANIMATION);
           STYLEABLES = Collections.unmodifiableList(styleables);

        }
    }

    /**
     * Returns the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    /**************************************************************************
     *
     * TabHeaderArea: Area responsible for painting all tabs
     *
     **************************************************************************/
    class TabHeaderArea extends StackPane {
        private Rectangle headerClip;
        private StackPane headersRegion;
        private StackPane headerBackground;
        private TabControlButtons controlButtons;

        private boolean measureClosingTabs = false;

        private double scrollOffset;

        public TabHeaderArea() {
            getStyleClass().setAll(&quot;tab-header-area&quot;);
            setManaged(false);
            final TabPane tabPane = getSkinnable();

            headerClip = new Rectangle();

            headersRegion = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double width = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        if (tabHeaderSkin.isVisible() &amp;&amp; (measureClosingTabs || ! tabHeaderSkin.isClosing)) {
                            width += tabHeaderSkin.prefWidth(height);
                        }
                    }
                    return snapSize(width) + snappedLeftInset() + snappedRightInset();
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    for (Node child : getChildren()) {
                        TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                        height = Math.max(height, tabHeaderSkin.prefHeight(width));
                    }
                    return snapSize(height) + snappedTopInset() + snappedBottomInset();
                }

                @Override protected void layoutChildren() {
                    if (tabsFit()) {
                        setScrollOffset(0.0);
                    } else {
                        if (isSelectingTab) {
                            ensureSelectedTabIsVisible();
                        } else {
                            validateScrollOffset();
                        }
                    }
                    isSelectingTab = false;

                    Side tabPosition = getSkinnable().getSide();
                    double tabBackgroundHeight = snapSize(prefHeight(-1));
                    double tabX = (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) ?
                        snapSize(getWidth()) - getScrollOffset() : getScrollOffset();

                    updateHeaderClip();
                    for (Node node : getChildren()) {
                        TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                        // size and position the header relative to the other headers
                        double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1) * tabHeader.animationTransition.get());
                        double tabHeaderPrefHeight = snapSize(tabHeader.prefHeight(-1));
                        tabHeader.resize(tabHeaderPrefWidth, tabHeaderPrefHeight);

                        // This ensures that the tabs are located in the correct position
                        // when there are tabs of differing heights.
                        double startY = tabPosition.equals(Side.BOTTOM) ?
                            0 : tabBackgroundHeight - tabHeaderPrefHeight - snappedBottomInset();
                        if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                            // build from the right
                            tabX -= tabHeaderPrefWidth;
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                        } else {
                            // build from the left
                            if (dragState != DragState.REORDER ||
                                    (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
                                tabHeader.relocate(tabX, startY);
                            }
                            tabX += tabHeaderPrefWidth;
                        }
                    }
                }

            };
            headersRegion.getStyleClass().setAll(&quot;headers-region&quot;);
            headersRegion.setClip(headerClip);
            setupReordering(headersRegion);

            headerBackground = new StackPane();
            headerBackground.getStyleClass().setAll(&quot;tab-header-background&quot;);

            int i = 0;
            for (Tab tab: tabPane.getTabs()) {
                addTab(tab, i++);
            }

            controlButtons = new TabControlButtons();
            controlButtons.setVisible(false);
            if (controlButtons.isVisible()) {
                controlButtons.setVisible(true);
            }
            getChildren().addAll(headerBackground, headersRegion, controlButtons);

            // support for mouse scroll of header area (for when the tabs exceed
            // the available space).
            // Scrolling the mouse wheel downwards results in the tabs scrolling left (i.e. exposing the right-most tabs)
            // Scrolling the mouse wheel upwards results in the tabs scrolling right (i.e. exposing th left-most tabs)
            addEventHandler(ScrollEvent.SCROLL, (ScrollEvent e) -&gt; {
                Side side = getSkinnable().getSide();
                side = side == null ? Side.TOP : side;
                switch (side) {
                    default:
                    case TOP:
                    case BOTTOM:
                        setScrollOffset(scrollOffset + e.getDeltaY());
                        break;
                    case LEFT:
                    case RIGHT:
                        setScrollOffset(scrollOffset - e.getDeltaY());
                        break;
                }

            });
        }

        private void updateHeaderClip() {
            Side tabPosition = getSkinnable().getSide();

            double x = 0;
            double y = 0;
            double clipWidth = 0;
            double clipHeight = 0;
            double maxWidth = 0;
            double shadowRadius = 0;
            double clipOffset = firstTabIndent();
            double controlButtonPrefWidth = snapSize(controlButtons.prefWidth(-1));

            measureClosingTabs = true;
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            measureClosingTabs = false;

            double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));

            // Add the spacer if isShowTabsMenu is true.
            if (controlButtonPrefWidth &gt; 0) {
                controlButtonPrefWidth = controlButtonPrefWidth + SPACER;
            }

            if (headersRegion.getEffect() instanceof DropShadow) {
                DropShadow shadow = (DropShadow)headersRegion.getEffect();
                shadowRadius = shadow.getRadius();
            }

            maxWidth = snapSize(getWidth()) - controlButtonPrefWidth - clipOffset;
            if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
                if (headersPrefWidth &lt; maxWidth) {
                    clipWidth = headersPrefWidth + shadowRadius;
                } else {
                    x = headersPrefWidth - maxWidth;
                    clipWidth = maxWidth + shadowRadius;
                }
                clipHeight = headersPrefHeight;
            } else {
                // If x = 0 the header region's drop shadow is clipped.
                x = -shadowRadius;
                clipWidth = (headersPrefWidth &lt; maxWidth ? headersPrefWidth : maxWidth) + shadowRadius;
                clipHeight = headersPrefHeight;
            }

            headerClip.setX(x);
            headerClip.setY(y);
            headerClip.setWidth(clipWidth);
            headerClip.setHeight(clipHeight);
        }

        private void addTab(Tab tab, int addToIndex) {
            TabHeaderSkin tabHeaderSkin = new TabHeaderSkin(tab);
            headersRegion.getChildren().add(addToIndex, tabHeaderSkin);
        }

        private void removeTab(Tab tab) {
            TabHeaderSkin tabHeaderSkin = getTabHeaderSkin(tab);
            if (tabHeaderSkin != null) {
                headersRegion.getChildren().remove(tabHeaderSkin);
            }
        }

        private TabHeaderSkin getTabHeaderSkin(Tab tab) {
            for (Node child: headersRegion.getChildren()) {
                TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
                if (tabHeaderSkin.getTab().equals(tab)) {
                    return tabHeaderSkin;
                }
            }
            return null;
        }

        private boolean tabsFit() {
            double headerPrefWidth = snapSize(headersRegion.prefWidth(-1));
            double controlTabWidth = snapSize(controlButtons.prefWidth(-1));
            double visibleWidth = headerPrefWidth + controlTabWidth + firstTabIndent() + SPACER;
            return visibleWidth &lt; getWidth();
        }

        private void ensureSelectedTabIsVisible() {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // and get where the selected tab is in the header area
            double offset = 0.0;
            double selectedTabOffset = 0.0;
            double selectedTabWidth = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;

                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));

                if (selectedTab != null &amp;&amp; selectedTab.equals(tabHeader.getTab())) {
                    selectedTabOffset = offset;
                    selectedTabWidth = tabHeaderPrefWidth;
                }
                offset += tabHeaderPrefWidth;
            }

            final double scrollOffset = getScrollOffset();
            final double selectedTabStartX = selectedTabOffset;
            final double selectedTabEndX = selectedTabOffset + selectedTabWidth;

            final double visibleAreaEndX = visibleWidth;

            if (selectedTabStartX &lt; -scrollOffset) {
                setScrollOffset(-selectedTabStartX);
            } else if (selectedTabEndX &gt; (visibleAreaEndX - scrollOffset)) {
                setScrollOffset(visibleAreaEndX - selectedTabEndX);
            }
        }

        public double getScrollOffset() {
            return scrollOffset;
        }

        private void validateScrollOffset() {
            setScrollOffset(getScrollOffset());
        }

        private void setScrollOffset(double newScrollOffset) {
            // work out the visible width of the tab header
            double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
            double controlTabWidth = snapSize(controlButtons.getWidth());
            double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;

            // measure the width of all tabs
            double offset = 0.0;
            for (Node node : headersRegion.getChildren()) {
                TabHeaderSkin tabHeader = (TabHeaderSkin)node;
                double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));
                offset += tabHeaderPrefWidth;
            }

            double actualNewScrollOffset;

            if ((visibleWidth - newScrollOffset) &gt; offset &amp;&amp; newScrollOffset &lt; 0) {
                // need to make sure the right-most tab is attached to the
                // right-hand side of the tab header (e.g. if the tab header area width
                // is expanded), and if it isn't modify the scroll offset to bring
                // it into line. See RT-35194 for a test case.
                actualNewScrollOffset = visibleWidth - offset;
            } else if (newScrollOffset &gt; 0) {
                // need to prevent the left-most tab from becoming detached
                // from the left-hand side of the tab header.
                actualNewScrollOffset = 0;
            } else {
                actualNewScrollOffset = newScrollOffset;
            }

            if (Math.abs(actualNewScrollOffset - scrollOffset) &gt; 0.001) {
                scrollOffset = actualNewScrollOffset;
                headersRegion.requestLayout();
            }
        }

        private double firstTabIndent() {
            switch (getSkinnable().getSide()) {
                case TOP:
                case BOTTOM:
                    return snappedLeftInset();
                case RIGHT:
                case LEFT:
                    return snappedTopInset();
                default:
                    return 0;
            }
        }

        @Override protected double computePrefWidth(double height) {
            double padding = isHorizontal() ?
                snappedLeftInset() + snappedRightInset() :
                snappedTopInset() + snappedBottomInset();
            return snapSize(headersRegion.prefWidth(height)) + controlButtons.prefWidth(height) +
                    firstTabIndent() + SPACER + padding;
        }

        @Override protected double computePrefHeight(double width) {
            double padding = isHorizontal() ?
                snappedTopInset() + snappedBottomInset() :
                snappedLeftInset() + snappedRightInset();
            return snapSize(headersRegion.prefHeight(-1)) + padding;
        }

        @Override public double getBaselineOffset() {
            if (getSkinnable().getSide() == Side.TOP) {
                return headersRegion.getBaselineOffset() + snappedTopInset();
            }
            return 0;
        }

        @Override protected void layoutChildren() {
            final double leftInset = snappedLeftInset();
            final double rightInset = snappedRightInset();
            final double topInset = snappedTopInset();
            final double bottomInset = snappedBottomInset();
            double w = snapSize(getWidth()) - (isHorizontal() ?
                    leftInset + rightInset : topInset + bottomInset);
            double h = snapSize(getHeight()) - (isHorizontal() ?
                    topInset + bottomInset : leftInset + rightInset);
            double tabBackgroundHeight = snapSize(prefHeight(-1));
            double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
            double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));

            controlButtons.showTabsMenu(! tabsFit());

            updateHeaderClip();
            headersRegion.requestLayout();

            // RESIZE CONTROL BUTTONS
            double btnWidth = snapSize(controlButtons.prefWidth(-1));
            final double btnHeight = controlButtons.prefHeight(btnWidth);
            controlButtons.resize(btnWidth, btnHeight);

            // POSITION TABS
            headersRegion.resize(headersPrefWidth, headersPrefHeight);

            if (isFloatingStyleClass()) {
                headerBackground.setVisible(false);
            } else {
                headerBackground.resize(snapSize(getWidth()), snapSize(getHeight()));
                headerBackground.setVisible(true);
            }

            double startX = 0;
            double startY = 0;
            double controlStartX = 0;
            double controlStartY = 0;
            Side tabPosition = getSkinnable().getSide();

            if (tabPosition.equals(Side.TOP)) {
                startX = leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - bottomInset;
                controlStartX = w - btnWidth + leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - bottomInset;
            } else if (tabPosition.equals(Side.RIGHT)) {
                startX = topInset;
                startY = tabBackgroundHeight - headersPrefHeight - leftInset;
                controlStartX = w - btnWidth + topInset;
                controlStartY = snapSize(getHeight()) - btnHeight - leftInset;
            } else if (tabPosition.equals(Side.BOTTOM)) {
                startX = snapSize(getWidth()) - headersPrefWidth - leftInset;
                startY = tabBackgroundHeight - headersPrefHeight - topInset;
                controlStartX = rightInset;
                controlStartY = snapSize(getHeight()) - btnHeight - topInset;
            } else if (tabPosition.equals(Side.LEFT)) {
                startX = snapSize(getWidth()) - headersPrefWidth - topInset;
                startY = tabBackgroundHeight - headersPrefHeight - rightInset;
                controlStartX = leftInset;
                controlStartY = snapSize(getHeight()) - btnHeight - rightInset;
            }
            if (headerBackground.isVisible()) {
                positionInArea(headerBackground, 0, 0,
                        snapSize(getWidth()), snapSize(getHeight()), /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
            }
            positionInArea(headersRegion, startX, startY, w, h, /*baseline ignored*/0, HPos.LEFT, VPos.CENTER);
            positionInArea(controlButtons, controlStartX, controlStartY, btnWidth, btnHeight,
                        /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
        }
    } /* End TabHeaderArea */




    /**************************************************************************
     *
     * TabHeaderSkin: skin for each tab
     *
     **************************************************************************/

    class TabHeaderSkin extends StackPane {
        private final Tab tab;
        public Tab getTab() {
            return tab;
        }
        private Label label;
        private StackPane closeBtn;
        private StackPane inner;
        private Tooltip oldTooltip;
        private Tooltip tooltip;
        private Rectangle clip;

        private boolean isClosing = false;

        private LambdaMultiplePropertyChangeListenerHandler listener = new LambdaMultiplePropertyChangeListenerHandler();

        private final ListChangeListener&lt;String&gt; styleClassListener = new ListChangeListener&lt;String&gt;() {
            @Override
            public void onChanged(Change&lt;? extends String&gt; c) {
                getStyleClass().setAll(tab.getStyleClass());
            }
        };

        private final WeakListChangeListener&lt;String&gt; weakStyleClassListener =
                new WeakListChangeListener&lt;&gt;(styleClassListener);

        public TabHeaderSkin(final Tab tab) {
            getStyleClass().setAll(tab.getStyleClass());
            setId(tab.getId());
            setStyle(tab.getStyle());
            setAccessibleRole(AccessibleRole.TAB_ITEM);
            setViewOrder(1);

            this.tab = tab;
            clip = new Rectangle();
            setClip(clip);

            label = new Label(tab.getText(), tab.getGraphic());
            label.getStyleClass().setAll(&quot;tab-label&quot;);

            closeBtn = new StackPane() {
                @Override protected double computePrefWidth(double h) {
                    return CLOSE_BTN_SIZE;
                }
                @Override protected double computePrefHeight(double w) {
                    return CLOSE_BTN_SIZE;
                }
                @Override
                public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
                    switch (action) {
                        case FIRE: {
                            Tab tab = getTab();
                            if (behavior.canCloseTab(tab)) {
                                behavior.closeTab(tab);
                                setOnMousePressed(null);
                            }
                            break;
                        }
                        default: super.executeAccessibleAction(action, parameters);
                    }
                }
            };
            closeBtn.setAccessibleRole(AccessibleRole.BUTTON);
            closeBtn.setAccessibleText(getString(&quot;Accessibility.title.TabPane.CloseButton&quot;));
            closeBtn.getStyleClass().setAll(&quot;tab-close-button&quot;);
            closeBtn.setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override
                public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (me.getButton().equals(MouseButton.PRIMARY) &amp;&amp; behavior.canCloseTab(tab)) {
                        behavior.closeTab(tab);
                        setOnMousePressed(null);
                        me.consume();
                    }
                }
            });

            updateGraphicRotation();

            final Region focusIndicator = new Region();
            focusIndicator.setMouseTransparent(true);
            focusIndicator.getStyleClass().add(&quot;focus-indicator&quot;);

            inner = new StackPane() {
                @Override protected void layoutChildren() {
                    final TabPane skinnable = getSkinnable();

                    final double paddingTop = snappedTopInset();
                    final double paddingRight = snappedRightInset();
                    final double paddingBottom = snappedBottomInset();
                    final double paddingLeft = snappedLeftInset();
                    final double w = getWidth() - (paddingLeft + paddingRight);
                    final double h = getHeight() - (paddingTop + paddingBottom);

                    final double prefLabelWidth = snapSize(label.prefWidth(-1));
                    final double prefLabelHeight = snapSize(label.prefHeight(-1));

                    final double closeBtnWidth = showCloseButton() ? snapSize(closeBtn.prefWidth(-1)) : 0;
                    final double closeBtnHeight = showCloseButton() ? snapSize(closeBtn.prefHeight(-1)) : 0;
                    final double minWidth = snapSize(skinnable.getTabMinWidth());
                    final double maxWidth = snapSize(skinnable.getTabMaxWidth());
                    final double maxHeight = snapSize(skinnable.getTabMaxHeight());

                    double labelAreaWidth = prefLabelWidth;
                    double labelWidth = prefLabelWidth;
                    double labelHeight = prefLabelHeight;

                    final double childrenWidth = labelAreaWidth + closeBtnWidth;
                    final double childrenHeight = Math.max(labelHeight, closeBtnHeight);

                    if (childrenWidth &gt; maxWidth &amp;&amp; maxWidth != Double.MAX_VALUE) {
                        labelAreaWidth = maxWidth - closeBtnWidth;
                        labelWidth = maxWidth - closeBtnWidth;
                    } else if (childrenWidth &lt; minWidth) {
                        labelAreaWidth = minWidth - closeBtnWidth;
                    }

                    if (childrenHeight &gt; maxHeight &amp;&amp; maxHeight != Double.MAX_VALUE) {
                        labelHeight = maxHeight;
                    }

                    if (animationState != TabAnimationState.NONE) {
//                        if (prefWidth.getValue() &lt; labelAreaWidth) {
//                            labelAreaWidth = prefWidth.getValue();
//                        }
                        labelAreaWidth *= animationTransition.get();
                        closeBtn.setVisible(false);
                    } else {
                        closeBtn.setVisible(showCloseButton());
                    }


                    label.resize(labelWidth, labelHeight);


                    double labelStartX = paddingLeft;

                    // If maxWidth is less than Double.MAX_VALUE, the user has
                    // clamped the max width, but we should
                    // position the close button at the end of the tab,
                    // which may not necessarily be the entire width of the
                    // provided max width.
                    double closeBtnStartX = (maxWidth &lt; Double.MAX_VALUE ? Math.min(w, maxWidth) : w) - paddingRight - closeBtnWidth;

                    positionInArea(label, labelStartX, paddingTop, labelAreaWidth, h,
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);

                    if (closeBtn.isVisible()) {
                        closeBtn.resize(closeBtnWidth, closeBtnHeight);
                        positionInArea(closeBtn, closeBtnStartX, paddingTop, closeBtnWidth, h,
                                /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                    }

                    // Magic numbers regretfully introduced for RT-28944 (so that
                    // the focus rect appears as expected on Windows and Mac).
                    // In short we use the vPadding to shift the focus rect down
                    // into the content area (whereas previously it was being clipped
                    // on Windows, whilst it still looked fine on Mac). In the
                    // future we may want to improve this code to remove the
                    // magic number. Similarly, the hPadding differs on Mac.
                    final int vPadding = Utils.isMac() ? 2 : 3;
                    final int hPadding = Utils.isMac() ? 2 : 1;
                    focusIndicator.resizeRelocate(
                            paddingLeft - hPadding,
                            paddingTop + vPadding,
                            w + 2 * hPadding,
                            h - 2 * vPadding);
                }
            };
            inner.getStyleClass().add(&quot;tab-container&quot;);
            inner.setRotate(getSkinnable().getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            inner.getChildren().addAll(label, closeBtn, focusIndicator);

            getChildren().addAll(inner);

            tooltip = tab.getTooltip();
            if (tooltip != null) {
                Tooltip.install(this, tooltip);
                oldTooltip = tooltip;
            }

            listener.registerChangeListener(tab.closableProperty(), e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.selectedProperty(), e -&gt; {
                pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
                // Need to request a layout pass for inner because if the width
                // and height didn't not change the label or close button may have
                // changed.
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(tab.textProperty(),e -&gt; label.setText(getTab().getText()));
            listener.registerChangeListener(tab.graphicProperty(), e -&gt; label.setGraphic(getTab().getGraphic()));
            listener.registerChangeListener(tab.tooltipProperty(), e -&gt; {
                // uninstall the old tooltip
                if (oldTooltip != null) {
                    Tooltip.uninstall(this, oldTooltip);
                }
                tooltip = tab.getTooltip();
                if (tooltip != null) {
                    // install new tooltip and save as old tooltip.
                    Tooltip.install(this, tooltip);
                    oldTooltip = tooltip;
                }
            });
            listener.registerChangeListener(tab.disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.getTabPane().disabledProperty(), e -&gt; {
                updateTabDisabledState();
            });
            listener.registerChangeListener(tab.styleProperty(), e -&gt; setStyle(tab.getStyle()));

            tab.getStyleClass().addListener(weakStyleClassListener);

            listener.registerChangeListener(getSkinnable().tabClosingPolicyProperty(),e -&gt; {
                inner.requestLayout();
                requestLayout();
            });
            listener.registerChangeListener(getSkinnable().sideProperty(),e -&gt; {
                final Side side = getSkinnable().getSide();
                pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
                pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
                pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
                pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
                inner.setRotate(side == Side.BOTTOM ? 180.0F : 0.0F);
                if (getSkinnable().isRotateGraphic()) {
                    updateGraphicRotation();
                }
            });
            listener.registerChangeListener(getSkinnable().rotateGraphicProperty(), e -&gt; updateGraphicRotation());
            listener.registerChangeListener(getSkinnable().tabMinWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMaxWidthProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMinHeightProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });
            listener.registerChangeListener(getSkinnable().tabMaxHeightProperty(), e -&gt; {
                requestLayout();
                getSkinnable().requestLayout();
            });

            getProperties().put(Tab.class, tab);
            getProperties().put(ContextMenu.class, tab.getContextMenu());

            setOnContextMenuRequested((ContextMenuEvent me) -&gt; {
               if (getTab().getContextMenu() != null) {
                    getTab().getContextMenu().show(inner, me.getScreenX(), me.getScreenY());
                    me.consume();
                }
            });
            setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
                @Override public void handle(MouseEvent me) {
                    Tab tab = getTab();
                    if (tab.isDisable()) {
                        return;
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)
                        || me.getButton().equals(MouseButton.PRIMARY)) {

                        if (tab.getContextMenu() != null
                            &amp;&amp; tab.getContextMenu().isShowing()) {
                            tab.getContextMenu().hide();
                        }
                    }
                    if (me.getButton().equals(MouseButton.MIDDLE)) {
                        if (showCloseButton()) {
                            if (behavior.canCloseTab(tab)) {
                                removeListeners(tab);
                                behavior.closeTab(tab);
                            }
                        }
                    } else if (me.getButton().equals(MouseButton.PRIMARY)) {
                        behavior.selectTab(tab);
                    }
                }
            });

            // initialize pseudo-class state
            pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            final Side side = getSkinnable().getSide();
            pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
            pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
            pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
            pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
        }

        private void updateTabDisabledState() {
            pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
            inner.requestLayout();
            requestLayout();
        }

        private void updateGraphicRotation() {
            if (label.getGraphic() != null) {
                label.getGraphic().setRotate(getSkinnable().isRotateGraphic() ? 0.0F :
                    (getSkinnable().getSide().equals(Side.RIGHT) ? -90.0F :
                        (getSkinnable().getSide().equals(Side.LEFT) ? 90.0F : 0.0F)));
            }
        }

        private boolean showCloseButton() {
            return tab.isClosable() &amp;&amp;
                    (getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.ALL_TABS) ||
                    getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.SELECTED_TAB) &amp;&amp; tab.isSelected());
        }

        private final DoubleProperty animationTransition = new SimpleDoubleProperty(this, &quot;animationTransition&quot;, 1.0) {
            @Override protected void invalidated() {
                requestLayout();
            }
        };

        private void removeListeners(Tab tab) {
            listener.dispose();
            inner.getChildren().clear();
            getChildren().clear();
            setOnContextMenuRequested(null);
            setOnMousePressed(null);
        }

        private TabAnimationState animationState = TabAnimationState.NONE;
        private Timeline currentAnimation;

        @Override protected double computePrefWidth(double height) {
//            if (animating) {
//                return prefWidth.getValue();
//            }
            double minWidth = snapSize(getSkinnable().getTabMinWidth());
            double maxWidth = snapSize(getSkinnable().getTabMaxWidth());
            double paddingRight = snappedRightInset();
            double paddingLeft = snappedLeftInset();
            double tmpPrefWidth = snapSize(label.prefWidth(-1));

            // only include the close button width if it is relevant
            if (showCloseButton()) {
                tmpPrefWidth += snapSize(closeBtn.prefWidth(-1));
            }

            if (tmpPrefWidth &gt; maxWidth) {
                tmpPrefWidth = maxWidth;
            } else if (tmpPrefWidth &lt; minWidth) {
                tmpPrefWidth = minWidth;
            }
            tmpPrefWidth += paddingRight + paddingLeft;
//            prefWidth.setValue(tmpPrefWidth);
            return tmpPrefWidth;
        }

        @Override protected double computePrefHeight(double width) {
            double minHeight = snapSize(getSkinnable().getTabMinHeight());
            double maxHeight = snapSize(getSkinnable().getTabMaxHeight());
            double paddingTop = snappedTopInset();
            double paddingBottom = snappedBottomInset();
            double tmpPrefHeight = snapSize(label.prefHeight(width));

            if (tmpPrefHeight &gt; maxHeight) {
                tmpPrefHeight = maxHeight;
            } else if (tmpPrefHeight &lt; minHeight) {
                tmpPrefHeight = minHeight;
            }
            tmpPrefHeight += paddingTop + paddingBottom;
            return tmpPrefHeight;
        }

        @Override protected void layoutChildren() {
            double w = (snapSize(getWidth()) - snappedRightInset() - snappedLeftInset()) * animationTransition.getValue();
            inner.resize(w, snapSize(getHeight()) - snappedTopInset() - snappedBottomInset());
            inner.relocate(snappedLeftInset(), snappedTopInset());
        }

        @Override protected void setWidth(double value) {
            super.setWidth(value);
            clip.setWidth(value);
        }

        @Override protected void setHeight(double value) {
            super.setHeight(value);
            clip.setHeight(value);
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case TEXT: return getTab().getText();
                case SELECTED: return selectedTab == getTab();
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }

        /** {@inheritDoc} */
        @Override
        public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
            switch (action) {
                case REQUEST_FOCUS:
                    getSkinnable().getSelectionModel().select(getTab());
                    break;
                default: super.executeAccessibleAction(action, parameters);
            }
        }

    } /* End TabHeaderSkin */

    private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;selected&quot;);
    private static final PseudoClass TOP_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;top&quot;);
    private static final PseudoClass BOTTOM_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;bottom&quot;);
    private static final PseudoClass LEFT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;left&quot;);
    private static final PseudoClass RIGHT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;right&quot;);
    private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;disabled&quot;);


    /**************************************************************************
     *
     * TabContentRegion: each tab has one to contain the tab's content node
     *
     **************************************************************************/
    static class TabContentRegion extends StackPane {

        private Tab tab;

        private InvalidationListener tabContentListener = valueModel -&gt; {
            updateContent();
        };
        private InvalidationListener tabSelectedListener = new InvalidationListener() {
            @Override public void invalidated(Observable valueModel) {
                setVisible(tab.isSelected());
            }
        };

        private WeakInvalidationListener weakTabContentListener =
                new WeakInvalidationListener(tabContentListener);
        private WeakInvalidationListener weakTabSelectedListener =
                new WeakInvalidationListener(tabSelectedListener);

        public Tab getTab() {
            return tab;
        }

        public TabContentRegion(Tab tab) {
            getStyleClass().setAll(&quot;tab-content-area&quot;);
            setManaged(false);
            this.tab = tab;
            updateContent();
            setVisible(tab.isSelected());

            tab.selectedProperty().addListener(weakTabSelectedListener);
            tab.contentProperty().addListener(weakTabContentListener);
        }

        private void updateContent() {
            Node newContent = getTab().getContent();
            if (newContent == null) {
                getChildren().clear();
            } else {
                getChildren().setAll(newContent);
            }
        }

        private void removeListeners(Tab tab) {
            tab.selectedProperty().removeListener(weakTabSelectedListener);
            tab.contentProperty().removeListener(weakTabContentListener);
        }

    } /* End TabContentRegion */

    /**************************************************************************
     *
     * TabControlButtons: controls to manipulate tab interaction
     *
     **************************************************************************/
    class TabControlButtons extends StackPane {
        private StackPane inner;
        private StackPane downArrow;
        private Pane downArrowBtn;
        private boolean showControlButtons;
        private ContextMenu popup;

        public TabControlButtons() {
            getStyleClass().setAll(&quot;control-buttons-tab&quot;);

            TabPane tabPane = getSkinnable();

            downArrowBtn = new Pane();
            downArrowBtn.getStyleClass().setAll(&quot;tab-down-button&quot;);
            downArrowBtn.setVisible(isShowTabsMenu());
            downArrow = new StackPane();
            downArrow.setManaged(false);
            downArrow.getStyleClass().setAll(&quot;arrow&quot;);
            downArrow.setRotate(tabPane.getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
            downArrowBtn.getChildren().add(downArrow);
            downArrowBtn.setOnMouseClicked(me -&gt; {
                showPopupMenu();
            });

            setupPopupMenu();

            inner = new StackPane() {
                @Override protected double computePrefWidth(double height) {
                    double pw;
                    double maxArrowWidth = ! isShowTabsMenu() ? 0 : snapSize(downArrow.prefWidth(getHeight())) + snapSize(downArrowBtn.prefWidth(getHeight()));
                    pw = 0.0F;
                    if (isShowTabsMenu()) {
                        pw += maxArrowWidth;
                    }
                    if (pw &gt; 0) {
                        pw += snappedLeftInset() + snappedRightInset();
                    }
                    return pw;
                }

                @Override protected double computePrefHeight(double width) {
                    double height = 0.0F;
                    if (isShowTabsMenu()) {
                        height = Math.max(height, snapSize(downArrowBtn.prefHeight(width)));
                    }
                    if (height &gt; 0) {
                        height += snappedTopInset() + snappedBottomInset();
                    }
                    return height;
                }

                @Override protected void layoutChildren() {
                    if (isShowTabsMenu()) {
                        double x = 0;
                        double y = snappedTopInset();
                        double w = snapSize(getWidth()) - x + snappedLeftInset();
                        double h = snapSize(getHeight()) - y + snappedBottomInset();
                        positionArrow(downArrowBtn, downArrow, x, y, w, h);
                    }
                }

                private void positionArrow(Pane btn, StackPane arrow, double x, double y, double width, double height) {
                    btn.resize(width, height);
                    positionInArea(btn, x, y, width, height, /*baseline ignored*/0,
                            HPos.CENTER, VPos.CENTER);
                    // center arrow region within arrow button
                    double arrowWidth = snapSize(arrow.prefWidth(-1));
                    double arrowHeight = snapSize(arrow.prefHeight(-1));
                    arrow.resize(arrowWidth, arrowHeight);
                    positionInArea(arrow, btn.snappedLeftInset(), btn.snappedTopInset(),
                            width - btn.snappedLeftInset() - btn.snappedRightInset(),
                            height - btn.snappedTopInset() - btn.snappedBottomInset(),
                            /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
                }
            };
            inner.getStyleClass().add(&quot;container&quot;);
            inner.getChildren().add(downArrowBtn);

            getChildren().add(inner);

            tabPane.sideProperty().addListener(valueModel -&gt; {
                Side tabPosition = getSkinnable().getSide();
                downArrow.setRotate(tabPosition.equals(Side.BOTTOM)? 180.0F : 0.0F);
            });
            tabPane.getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; setupPopupMenu());
            showControlButtons = false;
            if (isShowTabsMenu()) {
                showControlButtons = true;
                requestLayout();
            }
            getProperties().put(ContextMenu.class, popup);
        }

        private boolean showTabsMenu = false;

        private void showTabsMenu(boolean value) {
            final boolean wasTabsMenuShowing = isShowTabsMenu();
            this.showTabsMenu = value;

            if (showTabsMenu &amp;&amp; !wasTabsMenuShowing) {
                downArrowBtn.setVisible(true);
                showControlButtons = true;
                inner.requestLayout();
                tabHeaderArea.requestLayout();
            } else if (!showTabsMenu &amp;&amp; wasTabsMenuShowing) {
                hideControlButtons();
            }
        }

        private boolean isShowTabsMenu() {
            return showTabsMenu;
        }

        @Override protected double computePrefWidth(double height) {
            double pw = snapSize(inner.prefWidth(height));
            if (pw &gt; 0) {
                pw += snappedLeftInset() + snappedRightInset();
            }
            return pw;
        }

        @Override protected double computePrefHeight(double width) {
            return Math.max(getSkinnable().getTabMinHeight(), snapSize(inner.prefHeight(width))) +
                    snappedTopInset() + snappedBottomInset();
        }

        @Override protected void layoutChildren() {
            double x = snappedLeftInset();
            double y = snappedTopInset();
            double w = snapSize(getWidth()) - x + snappedRightInset();
            double h = snapSize(getHeight()) - y + snappedBottomInset();

            if (showControlButtons) {
                showControlButtons();
                showControlButtons = false;
            }

            inner.resize(w, h);
            positionInArea(inner, x, y, w, h, /*baseline ignored*/0, HPos.CENTER, VPos.BOTTOM);
        }

        private void showControlButtons() {
            setVisible(true);
            if (popup == null) {
                setupPopupMenu();
            }
        }

        private void hideControlButtons() {
            // If the scroll arrows or tab menu is still visible we don't want
            // to hide it animate it back it.
            if (isShowTabsMenu()) {
                showControlButtons = true;
            } else {
                setVisible(false);
                clearPopupMenu();
                popup = null;
            }

            // This needs to be called when we are in the left tabPosition
            // to allow for the clip offset to move properly (otherwise
            // it jumps too early - before the animation is done).
            requestLayout();
        }

        private void setupPopupMenu() {
            if (popup == null) {
                popup = new ContextMenu();
            }
            clearPopupMenu();
            ToggleGroup group = new ToggleGroup();
            ObservableList&lt;RadioMenuItem&gt; menuitems = FXCollections.&lt;RadioMenuItem&gt;observableArrayList();
            for (final Tab tab : getSkinnable().getTabs()) {
                TabMenuItem item = new TabMenuItem(tab);
                item.setToggleGroup(group);
                item.setOnAction(t -&gt; getSkinnable().getSelectionModel().select(tab));
                menuitems.add(item);
            }
            popup.getItems().addAll(menuitems);
        }

        private void clearPopupMenu() {
            for (MenuItem item : popup.getItems()) {
                ((TabMenuItem) item).dispose();
            }
            popup.getItems().clear();
        }

        private void showPopupMenu() {
            for (MenuItem mi: popup.getItems()) {
                TabMenuItem tmi = (TabMenuItem)mi;
                if (selectedTab.equals(tmi.getTab())) {
                    tmi.setSelected(true);
                    break;
                }
            }
            popup.show(downArrowBtn, Side.BOTTOM, 0, 0);
        }
    } /* End TabControlButtons*/

    static class TabMenuItem extends RadioMenuItem {
        Tab tab;

        private InvalidationListener disableListener = new InvalidationListener() {
            @Override public void invalidated(Observable o) {
                setDisable(tab.isDisable());
            }
        };

        private WeakInvalidationListener weakDisableListener =
                new WeakInvalidationListener(disableListener);

        public TabMenuItem(final Tab tab) {
            super(tab.getText(), TabPaneSkin.clone(tab.getGraphic()));
            this.tab = tab;
            setDisable(tab.isDisable());
            tab.disableProperty().addListener(weakDisableListener);
            textProperty().bind(tab.textProperty());
        }

        public Tab getTab() {
            return tab;
        }

        public void dispose() {
            textProperty().unbind();
            tab.disableProperty().removeListener(weakDisableListener);
            tab = null;
        }
    }

    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case FOCUS_ITEM: return tabHeaderArea.getTabHeaderSkin(selectedTab);
            case ITEM_COUNT: return tabHeaderArea.headersRegion.getChildren().size();
            case ITEM_AT_INDEX: {
                Integer index = (Integer)parameters[0];
                if (index == null) return null;
                return tabHeaderArea.headersRegion.getChildren().get(index);
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    // --------------------------
    // Tab Reordering
    // --------------------------
    private enum DragState {
        NONE,
        START,
        REORDER
    }
    private EventHandler&lt;MouseEvent&gt; headerDraggedHandler = this::handleHeaderDragged;
    private EventHandler&lt;MouseEvent&gt; headerMousePressedHandler = this::handleHeaderMousePressed;
    private EventHandler&lt;MouseEvent&gt; headerMouseReleasedHandler = this::handleHeaderMouseReleased;

    private int dragTabHeaderIndex;
    private TabHeaderSkin dragTabHeader;
    private TabHeaderSkin dropTabHeader;
    private StackPane headersRegion;
    private DragState dragState;
    private final int MIN_TO_MAX = 1;
    private final int MAX_TO_MIN = -1;
    private int xLayoutDirection;
    private double dragEventPrevLoc;
    private int prevDragDirection = MIN_TO_MAX;
    private final double DRAG_DIST_THRESHOLD = 0.75;

    // Reordering Animation
    private final double ANIM_DURATION = 120;
    private TabHeaderSkin dropAnimHeader;
    private Tab swapTab;
    private double dropHeaderSourceX;
    private double dropHeaderTransitionX;
    private final Animation dropHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_BOTH);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                completeHeaderReordering();
            });
        }
        protected void interpolate(double frac) {
            dropAnimHeader.setLayoutX(dropHeaderSourceX + dropHeaderTransitionX * frac);
        }
    };
    private double dragHeaderStartX;
    private double dragHeaderDestX;
    private double dragHeaderSourceX;
    private double dragHeaderTransitionX;
    private final Animation dragHeaderAnim = new Transition() {
        {
            setInterpolator(Interpolator.EASE_OUT);
            setCycleDuration(Duration.millis(ANIM_DURATION));
            setOnFinished(event -&gt; {
                resetDrag();
            });
        }
        protected void interpolate(double frac) {
            dragTabHeader.setLayoutX(dragHeaderSourceX + dragHeaderTransitionX * frac);
        }
    };

    // Helper methods for managing the listeners based on TabDragPolicy.
    private void addReorderListeners(Node n) {
        n.addEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.addEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.addEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private void removeReorderListeners(Node n) {
        n.removeEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
        n.removeEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
    }

    private ListChangeListener childListener = new ListChangeListener&lt;Node&gt;() {
        public void onChanged(Change&lt;? extends Node&gt; change) {
            while (change.next()) {
                if (change.wasAdded()) {
                    for(Node n : change.getAddedSubList()) {
                        addReorderListeners(n);
                    }
                }
                if (change.wasRemoved()) {
                    for(Node n : change.getRemoved()) {
                        removeReorderListeners(n);
                    }
                }
            }
        }
    };

    private void updateListeners() {
        if (getSkinnable().getTabDragPolicy() == TabDragPolicy.FIXED ||
                getSkinnable().getTabDragPolicy() == null) {
            for (Node n : headersRegion.getChildren()) {
                removeReorderListeners(n);
            }
            headersRegion.getChildren().removeListener(childListener);
        } else if (getSkinnable().getTabDragPolicy() == TabDragPolicy.REORDER) {
            for (Node n : headersRegion.getChildren()) {
                addReorderListeners(n);
            }
            headersRegion.getChildren().addListener(childListener);
        }
    }

    private void setupReordering(StackPane headersRegion) {
        dragState = DragState.NONE;
        this.headersRegion = headersRegion;
        updateListeners();
        getSkinnable().tabDragPolicyProperty().addListener((observable, oldValue, newValue) -&gt; {
            if (oldValue != newValue) {
                updateListeners();
            }
        });
    }

    private void handleHeaderMousePressed(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(true);
            startDrag(event);
        }
    }

    private void handleHeaderMouseReleased(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            ((StackPane) event.getSource()).setMouseTransparent(false);
            stopDrag();
            event.consume();
        }
    }

    private void handleHeaderDragged(MouseEvent event) {
        if (event.getButton().equals(MouseButton.PRIMARY)) {
            perfromDrag(event);
        }
    }

    private double getDragDelta(double curr, double prev) {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            return curr - prev;
        } else {
            return prev - curr;
        }
    }

    private int deriveTabHeaderLayoutXDirection() {
        if (getSkinnable().getSide().equals(Side.TOP) ||
                getSkinnable().getSide().equals(Side.RIGHT)) {
            // TabHeaderSkin are laid out in left to right direction inside headersRegion
            return MIN_TO_MAX;
        }
        // TabHeaderSkin are laid out in right to left direction inside headersRegion
        return MAX_TO_MIN;
    }

    private void perfromDrag(MouseEvent event) {
        int dragDirection;
        double dragHeaderNewLayoutX;
        Bounds dragHeaderBounds;
        Bounds dropHeaderBounds;
        double draggedDist;
        double mouseCurrentLoc = getHeaderRegionLocalX(event);
        double dragDelta = getDragDelta(mouseCurrentLoc, dragEventPrevLoc);

        if (dragDelta &gt; 0) {
            // Dragging the tab header towards higher indexed tab headers inside headersRegion.
            dragDirection = MIN_TO_MAX;
        } else {
            // Dragging the tab header towards lower indexed tab headers inside headersRegion.
            dragDirection = MAX_TO_MIN;
        }
        // Stop dropHeaderAnim if direction of drag is changed
        if (prevDragDirection != dragDirection) {
            stopAnim(dropHeaderAnim);
            prevDragDirection = dragDirection;
        }

        dragHeaderNewLayoutX = dragTabHeader.getLayoutX() + xLayoutDirection * dragDelta;

        if (dragHeaderNewLayoutX &gt;= 0 &amp;&amp;
                dragHeaderNewLayoutX + dragTabHeader.getWidth() &lt;= headersRegion.getWidth()) {

            dragState = DragState.REORDER;
            dragTabHeader.setLayoutX(dragHeaderNewLayoutX);
            dragHeaderBounds = dragTabHeader.getBoundsInParent();

            if (dragDirection == MIN_TO_MAX) {
                // Dragging the tab header towards higher indexed tab headers
                // Last tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // headers to be reordered.
                for (int i = dragTabHeaderIndex + 1; i &lt; headersRegion.getChildren().size(); i++) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        } else {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab header crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * -dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            } else {
                // dragDirection is MAX_TO_MIN
                // Dragging the tab header towards lower indexed tab headers.
                // First tab header can not be dragged outside headersRegion.

                // When the mouse is moved too fast, sufficient number of events
                // are not generated. Hence it is required to check all possible
                // tab headers to be reordered.
                for (int i = dragTabHeaderIndex - 1; i &gt;= 0; i--) {
                    dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);

                    // dropTabHeader should not be already reordering.
                    if (dropAnimHeader != dropTabHeader) {
                        dropHeaderBounds = dropTabHeader.getBoundsInParent();

                        if (xLayoutDirection == MIN_TO_MAX) {
                            draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
                        } else {
                            draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
                        }

                        // A tab header is reordered when dragged tab crosses DRAG_DIST_THRESHOLD% of next tab header's width.
                        if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
                            stopAnim(dropHeaderAnim);
                            // Distance by which tab header should be animated.
                            dropHeaderTransitionX = xLayoutDirection * dragHeaderBounds.getWidth();
                            if (xLayoutDirection == MIN_TO_MAX) {
                                dragHeaderDestX = dropHeaderBounds.getMinX();
                            } else {
                                dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
                            }
                            startHeaderReorderingAnim();
                        } else {
                            break;
                        }
                    }
                }
            }
        }
        dragEventPrevLoc = mouseCurrentLoc;
        event.consume();
    }

    private void startDrag(MouseEvent event) {
        // Stop the animations if any are running from previous reorder.
        stopAnim(dropHeaderAnim);
        stopAnim(dragHeaderAnim);

        dragTabHeader = (TabHeaderSkin) event.getSource();
        if (dragTabHeader != null) {
            dragState = DragState.START;
            swapTab = null;
            xLayoutDirection = deriveTabHeaderLayoutXDirection();
            dragEventPrevLoc = getHeaderRegionLocalX(event);
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
            dragTabHeader.setViewOrder(0);
            dragHeaderStartX = dragHeaderDestX = dragTabHeader.getLayoutX();
        }
    }

    private double getHeaderRegionLocalX(MouseEvent ev) {
        // The event is converted to tab header's parent i.e. headersRegion's local space.
        // This will provide a value of X co-ordinate with all transformations of TabPane
        // and transformations of all nodes in the TabPane's parent hierarchy.
        Point2D sceneToLocalHR = headersRegion.sceneToLocal(ev.getSceneX(), ev.getSceneY());
        return sceneToLocalHR.getX();
    }

    private void stopDrag() {
        if (dragState == DragState.START) {
            // No drag action was performed.
            resetDrag();
            return;
        }
        // Animate tab header being dragged to its final position.
        dragHeaderSourceX = dragTabHeader.getLayoutX();
        dragHeaderTransitionX = dragHeaderDestX - dragHeaderSourceX;
        dragHeaderAnim.playFromStart();

        // Reorder the tab list.
        if (dragHeaderStartX != dragHeaderDestX) {
            ((TabObservableList&lt;Tab&gt;) getSkinnable().getTabs()).reorder(dragTabHeader.tab, swapTab);
            swapTab = null;
        }
    }

    private void resetDrag() {
        dragState = DragState.NONE;
        dragTabHeader.setViewOrder(1);
        dragTabHeader = null;
        dropTabHeader = null;
        headersRegion.requestLayout();
    }

    // Animate tab header being dropped-on to its new position.
<A NAME="38"></A>    private void startHeaderReorderingAnim() {
        dropAnimHeader = dropTabHeader;
        swapTab = dropAnimHeader.tab;
        dropHeaderSourceX = <FONT color="#348781"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#38',2,'match51-top.html#38',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>dropAnimHeader.getLayoutX();
        dropHeaderAnim.playFromStart();
    }

    // Remove dropAnimHeader and add at the index position of dragTabHeader.
    private void completeHeaderReordering() {
        if (dropAnimHeader != null) {
            headersRegion.getChildren().remove(dropAnimHeader);
            headersRegion.getChildren().add(dragTabHeaderIndex, dropAnimHeader);
            dropAnimHeader = null;
            headersRegion.requestLayout</B></FONT>();
            dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
        }
    }

    // Helper method to stop an animation.
    private void stopAnim(Animation anim) {
        if (anim.getStatus() == Animation.Status.RUNNING) {
            anim.getOnFinished().handle(null);
            anim.stop();
        }
    }

    // For testing purpose.
    ContextMenu test_getTabsMenu() {
        return tabHeaderArea.controlButtons.popup;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.fxml/javafx/fxml/FXMLLoader.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.fxml;

import com.sun.javafx.util.Logging;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.regex.Pattern;

import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.property.Property;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.*;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.util.Builder;
import javafx.util.BuilderFactory;
import javafx.util.Callback;

import javax.script.Bindings;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import javax.script.SimpleBindings;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.util.StreamReaderDelegate;

import com.sun.javafx.beans.IDProperty;
import com.sun.javafx.fxml.BeanAdapter;
import com.sun.javafx.fxml.ParseTraceElement;
import com.sun.javafx.fxml.PropertyNotFoundException;
import com.sun.javafx.fxml.expression.Expression;
import com.sun.javafx.fxml.expression.ExpressionValue;
import com.sun.javafx.fxml.expression.KeyPath;
import static com.sun.javafx.FXPermissions.MODIFY_FXML_CLASS_LOADER_PERMISSION;
import com.sun.javafx.fxml.FXMLLoaderHelper;
import com.sun.javafx.fxml.MethodHelper;
import java.net.MalformedURLException;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.EnumMap;
import java.util.Locale;
import java.util.StringTokenizer;
import com.sun.javafx.reflect.ConstructorUtil;
import com.sun.javafx.reflect.MethodUtil;
import com.sun.javafx.reflect.ReflectUtil;

/**
 * Loads an object hierarchy from an XML document.
 * For more information, see the
 * &lt;a href=&quot;doc-files/introduction_to_fxml.html&quot;&gt;Introduction to FXML&lt;/a&gt;
 * document.
 *
 * @since JavaFX 2.0
 */
public class FXMLLoader {

    // Indicates permission to get the ClassLoader
    private static final RuntimePermission GET_CLASSLOADER_PERMISSION =
        new RuntimePermission(&quot;getClassLoader&quot;);

    // Instance of StackWalker used to get caller class (must be private)
    private static final StackWalker walker =
        AccessController.doPrivileged((PrivilegedAction&lt;StackWalker&gt;) () -&gt;
            StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE));

    // Abstract base class for elements
    private abstract class Element {
        public final Element parent;

        public Object value = null;
        private BeanAdapter valueAdapter = null;

        public final LinkedList&lt;Attribute&gt; eventHandlerAttributes = new LinkedList&lt;Attribute&gt;();
        public final LinkedList&lt;Attribute&gt; instancePropertyAttributes = new LinkedList&lt;Attribute&gt;();
        public final LinkedList&lt;Attribute&gt; staticPropertyAttributes = new LinkedList&lt;Attribute&gt;();
        public final LinkedList&lt;PropertyElement&gt; staticPropertyElements = new LinkedList&lt;PropertyElement&gt;();

        public Element() {
            parent = current;
        }

        public boolean isCollection() {
            // Return true if value is a list, or if the value's type defines
            // a default property that is a list
            boolean collection;
            if (value instanceof List&lt;?&gt;) {
                collection = true;
            } else {
                Class&lt;?&gt; type = value.getClass();
                DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);

                if (defaultProperty != null) {
                    collection = getProperties().get(defaultProperty.value()) instanceof List&lt;?&gt;;
                } else {
                    collection = false;
                }
            }

            return collection;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public void add(Object element) throws LoadException {
            // If value is a list, add element to it; otherwise, get the value
            // of the default property, which is assumed to be a list and add
            // to that (coerce to the appropriate type)
            List&lt;Object&gt; list;
            if (value instanceof List&lt;?&gt;) {
                list = (List&lt;Object&gt;)value;
            } else {
                Class&lt;?&gt; type = value.getClass();
                DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
                String defaultPropertyName = defaultProperty.value();

                // Get the list value
                list = (List&lt;Object&gt;)getProperties().get(defaultPropertyName);

                // Coerce the element to the list item type
                if (!Map.class.isAssignableFrom(type)) {
                    Type listType = getValueAdapter().getGenericType(defaultPropertyName);
                    element = BeanAdapter.coerce(element, BeanAdapter.getListItemType(listType));
                }
            }

            list.add(element);
        }

        public void set(Object value) throws LoadException {
            if (this.value == null) {
                throw constructLoadException(&quot;Cannot set value on this element.&quot;);
            }

            // Apply value to this element's properties
            Class&lt;?&gt; type = this.value.getClass();
            DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
            if (defaultProperty == null) {
                throw constructLoadException(&quot;Element does not define a default property.&quot;);
            }

            getProperties().put(defaultProperty.value(), value);
        }

        public void updateValue(Object value) {
            this.value = value;
            valueAdapter = null;
        }

        public boolean isTyped() {
            return !(value instanceof Map&lt;?, ?&gt;);
        }

        public BeanAdapter getValueAdapter() {
            if (valueAdapter == null) {
                valueAdapter = new BeanAdapter(value);
            }

            return valueAdapter;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public Map&lt;String, Object&gt; getProperties() {
            return (isTyped()) ? getValueAdapter() : (Map&lt;String, Object&gt;)value;
        }

        public void processStartElement() throws IOException {
            for (int i = 0, n = xmlStreamReader.getAttributeCount(); i &lt; n; i++) {
                String prefix = xmlStreamReader.getAttributePrefix(i);
                String localName = xmlStreamReader.getAttributeLocalName(i);
                String value = xmlStreamReader.getAttributeValue(i);

                if (loadListener != null
                    &amp;&amp; prefix != null
                    &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
                    loadListener.readInternalAttribute(prefix + &quot;:&quot; + localName, value);
                }

                processAttribute(prefix, localName, value);
            }
        }

        public void processEndElement() throws IOException {
            // No-op
        }

        public void processCharacters() throws IOException {
            throw constructLoadException(&quot;Unexpected characters in input stream.&quot;);
        }

        public void processInstancePropertyAttributes() throws IOException {
            if (instancePropertyAttributes.size() &gt; 0) {
                for (Attribute attribute : instancePropertyAttributes) {
                    processPropertyAttribute(attribute);
                }
            }
        }

        public void processAttribute(String prefix, String localName, String value)
            throws IOException{
            if (prefix == null) {
                // Add the attribute to the appropriate list
                if (localName.startsWith(EVENT_HANDLER_PREFIX)) {
                    if (loadListener != null) {
                        loadListener.readEventHandlerAttribute(localName, value);
                    }

                    eventHandlerAttributes.add(new Attribute(localName, null, value));
                } else {
                    int i = localName.lastIndexOf('.');

                    if (i == -1) {
                        // The attribute represents an instance property
                        if (loadListener != null) {
                            loadListener.readPropertyAttribute(localName, null, value);
                        }

                        instancePropertyAttributes.add(new Attribute(localName, null, value));
                    } else {
                        // The attribute represents a static property
                        String name = localName.substring(i + 1);
                        Class&lt;?&gt; sourceType = getType(localName.substring(0, i));

                        if (sourceType != null) {
                            if (loadListener != null) {
                                loadListener.readPropertyAttribute(name, sourceType, value);
                            }

                            staticPropertyAttributes.add(new Attribute(name, sourceType, value));
                        } else if (staticLoad) {
                            if (loadListener != null) {
                                loadListener.readUnknownStaticPropertyAttribute(localName, value);
                            }
                        } else {
                            throw constructLoadException(localName + &quot; is not a valid attribute.&quot;);
                        }
                    }

                }
            } else {
                throw constructLoadException(prefix + &quot;:&quot; + localName
                    + &quot; is not a valid attribute.&quot;);
            }
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public void processPropertyAttribute(Attribute attribute) throws IOException {
            String value = attribute.value;
            if (isBindingExpression(value)) {
                // Resolve the expression
                Expression expression;

                if (attribute.sourceType != null) {
                    throw constructLoadException(&quot;Cannot bind to static property.&quot;);
                }

                if (!isTyped()) {
                    throw constructLoadException(&quot;Cannot bind to untyped object.&quot;);
                }

                // TODO We may want to identify binding properties in processAttribute()
                // and apply them after build() has been called
                if (this.value instanceof Builder) {
                    throw constructLoadException(&quot;Cannot bind to builder property.&quot;);
                }

                if (!isStaticLoad()) {
                    value = value.substring(BINDING_EXPRESSION_PREFIX.length(),
                            value.length() - 1);
                    expression = Expression.valueOf(value);

                    // Create the binding
                    BeanAdapter targetAdapter = new BeanAdapter(this.value);
                    ObservableValue&lt;Object&gt; propertyModel = targetAdapter.getPropertyModel(attribute.name);
                    Class&lt;?&gt; type = targetAdapter.getType(attribute.name);

                    if (propertyModel instanceof Property&lt;?&gt;) {
                        ((Property&lt;Object&gt;) propertyModel).bind(new ExpressionValue(namespace, expression, type));
                    }
                }
            } else if (isBidirectionalBindingExpression(value)) {
                throw constructLoadException(new UnsupportedOperationException(&quot;This feature is not currently enabled.&quot;));
            } else {
                processValue(attribute.sourceType, attribute.name, value);
            }
        }

        private boolean isBindingExpression(String aValue) {
            return aValue.startsWith(BINDING_EXPRESSION_PREFIX)
                   &amp;&amp; aValue.endsWith(BINDING_EXPRESSION_SUFFIX);
        }

        private boolean isBidirectionalBindingExpression(String aValue) {
            return aValue.startsWith(BI_DIRECTIONAL_BINDING_PREFIX);
        }

        private boolean processValue(Class sourceType, String propertyName, String aValue)
            throws LoadException {

            boolean processed = false;
                //process list or array first
                if (sourceType == null &amp;&amp; isTyped()) {
                    BeanAdapter valueAdapter = getValueAdapter();
                    Class&lt;?&gt; type = valueAdapter.getType(propertyName);

                    if (type == null) {
                        throw new PropertyNotFoundException(&quot;Property \&quot;&quot; + propertyName
                            + &quot;\&quot; does not exist&quot; + &quot; or is read-only.&quot;);
                    }

                    if (List.class.isAssignableFrom(type)
                        &amp;&amp; valueAdapter.isReadOnly(propertyName)) {
                        populateListFromString(valueAdapter, propertyName, aValue);
                        processed = true;
                    } else if (type.isArray()) {
                        applyProperty(propertyName, sourceType,
                                populateArrayFromString(type, aValue));
                        processed = true;
                    }
                }
                if (!processed) {
                    applyProperty(propertyName, sourceType, resolvePrefixedValue(aValue));
                    processed = true;
                }
                return processed;
        }

        /**
         * Resolves value prefixed with RELATIVE_PATH_PREFIX and RESOURCE_KEY_PREFIX.
         */
        private Object resolvePrefixedValue(String aValue) throws LoadException {
            if (aValue.startsWith(ESCAPE_PREFIX)) {
                aValue = aValue.substring(ESCAPE_PREFIX.length());

                if (aValue.length() == 0
                    || !(aValue.startsWith(ESCAPE_PREFIX)
                        || aValue.startsWith(RELATIVE_PATH_PREFIX)
                        || aValue.startsWith(RESOURCE_KEY_PREFIX)
                        || aValue.startsWith(EXPRESSION_PREFIX)
                        || aValue.startsWith(BI_DIRECTIONAL_BINDING_PREFIX))) {
                    throw constructLoadException(&quot;Invalid escape sequence.&quot;);
                }
                return aValue;
            } else if (aValue.startsWith(RELATIVE_PATH_PREFIX)) {
                aValue = aValue.substring(RELATIVE_PATH_PREFIX.length());
                if (aValue.length() == 0) {
                    throw constructLoadException(&quot;Missing relative path.&quot;);
                }
                if (aValue.startsWith(RELATIVE_PATH_PREFIX)) {
                    // The prefix was escaped
                    warnDeprecatedEscapeSequence(RELATIVE_PATH_PREFIX);
                    return aValue;
                } else {
                        if (aValue.charAt(0) == '/') {
                            // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
                            final URL res = getClassLoader().getResource(aValue.substring(1));
                            if (res == null) {
                                throw constructLoadException(&quot;Invalid resource: &quot; + aValue + &quot; not found on the classpath&quot;);
                            }
                            return res.toString();
                        } else {
                            try {
                                return new URL(FXMLLoader.this.location, aValue).toString();
                            } catch (MalformedURLException e) {
                                System.err.println(FXMLLoader.this.location + &quot;/&quot; + aValue);
                            }
                        }
                }
            } else if (aValue.startsWith(RESOURCE_KEY_PREFIX)) {
                aValue = aValue.substring(RESOURCE_KEY_PREFIX.length());
                if (aValue.length() == 0) {
                    throw constructLoadException(&quot;Missing resource key.&quot;);
                }
                if (aValue.startsWith(RESOURCE_KEY_PREFIX)) {
                    // The prefix was escaped
                    warnDeprecatedEscapeSequence(RESOURCE_KEY_PREFIX);
                    return aValue;
                } else {
                    // Resolve the resource value
                    if (resources == null) {
                        throw constructLoadException(&quot;No resources specified.&quot;);
                    }
                    if (!resources.containsKey(aValue)) {
                        throw constructLoadException(&quot;Resource \&quot;&quot; + aValue + &quot;\&quot; not found.&quot;);
                    }

                    return resources.getString(aValue);
                }
            } else if (aValue.startsWith(EXPRESSION_PREFIX)) {
                aValue = aValue.substring(EXPRESSION_PREFIX.length());
                if (aValue.length() == 0) {
                    throw constructLoadException(&quot;Missing expression.&quot;);
                }
                if (aValue.startsWith(EXPRESSION_PREFIX)) {
                    // The prefix was escaped
                    warnDeprecatedEscapeSequence(EXPRESSION_PREFIX);
                    return aValue;
                } else if (aValue.equals(NULL_KEYWORD)) {
                    // The attribute value is null
                    return null;
                }
                return Expression.get(namespace, KeyPath.parse(aValue));
            }
            return aValue;
        }

        /**
         * Creates an array of given type and populates it with values from
         * a string where tokens are separated by ARRAY_COMPONENT_DELIMITER.
         * If token is prefixed with RELATIVE_PATH_PREFIX a value added to
         * the array becomes relative to document location.
         */
        private Object populateArrayFromString(
                Class&lt;?&gt;type,
                String stringValue) throws LoadException {

            Object propertyValue = null;
            // Split the string and set the values as an array
            Class&lt;?&gt; componentType = type.getComponentType();

            if (stringValue.length() &gt; 0) {
                String[] values = stringValue.split(ARRAY_COMPONENT_DELIMITER);
                propertyValue = Array.newInstance(componentType, values.length);
                for (int i = 0; i &lt; values.length; i++) {
                    Array.set(propertyValue, i,
                            BeanAdapter.coerce(resolvePrefixedValue(values[i].trim()),
                            type.getComponentType()));
                }
            } else {
                propertyValue = Array.newInstance(componentType, 0);
            }
            return propertyValue;
        }

        /**
         * Populates list with values from a string where tokens are separated
         * by ARRAY_COMPONENT_DELIMITER. If token is prefixed with RELATIVE_PATH_PREFIX
         * a value added to the list becomes relative to document location.
         */
        private void populateListFromString(
                BeanAdapter valueAdapter,
                String listPropertyName,
                String stringValue) throws LoadException {
            // Split the string and add the values to the list
            List&lt;Object&gt; list = (List&lt;Object&gt;)valueAdapter.get(listPropertyName);
            Type listType = valueAdapter.getGenericType(listPropertyName);
            Type itemType = (Class&lt;?&gt;)BeanAdapter.getGenericListItemType(listType);

            if (itemType instanceof ParameterizedType) {
                itemType = ((ParameterizedType)itemType).getRawType();
            }

            if (stringValue.length() &gt; 0) {
                String[] values = stringValue.split(ARRAY_COMPONENT_DELIMITER);

                for (String aValue: values) {
                    aValue = aValue.trim();
                    list.add(
                            BeanAdapter.coerce(resolvePrefixedValue(aValue),
                                               (Class&lt;?&gt;)itemType));
                }
            }
        }

        public void warnDeprecatedEscapeSequence(String prefix) {
            System.err.println(prefix + prefix + &quot; is a deprecated escape sequence. &quot;
                + &quot;Please use \\&quot; + prefix + &quot; instead.&quot;);
        }

        public void applyProperty(String name, Class&lt;?&gt; sourceType, Object value) {
            if (sourceType == null) {
                getProperties().put(name, value);
            } else {
                BeanAdapter.put(this.value, sourceType, name, value);
            }
        }

        private Object getExpressionObject(String handlerValue) throws LoadException{
            if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                handlerValue = handlerValue.substring(EXPRESSION_PREFIX.length());

                if (handlerValue.length() == 0) {
                    throw constructLoadException(&quot;Missing expression reference.&quot;);
                }

                Object expression = Expression.get(namespace, KeyPath.parse(handlerValue));
                if (expression == null) {
                    throw constructLoadException(&quot;Unable to resolve expression : $&quot; + handlerValue);
                }
                return expression;
            }
            return null;
        }

        private &lt;T&gt; T getExpressionObjectOfType(String handlerValue, Class&lt;T&gt; type) throws LoadException{
            Object expression = getExpressionObject(handlerValue);
            if (expression != null) {
                if (type.isInstance(expression)) {
                    return (T) expression;
                }
                throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue +&quot;\&quot; expression.&quot;
                        + &quot;Does not point to a &quot; + type.getName());
            }
            return null;
        }

        private MethodHandler getControllerMethodHandle(String handlerName, SupportedType... types) throws LoadException {
            if (handlerName.startsWith(CONTROLLER_METHOD_PREFIX)) {
                handlerName = handlerName.substring(CONTROLLER_METHOD_PREFIX.length());

                if (!handlerName.startsWith(CONTROLLER_METHOD_PREFIX)) {
                    if (handlerName.length() == 0) {
                        throw constructLoadException(&quot;Missing controller method.&quot;);
                    }

                    if (controller == null) {
                        throw constructLoadException(&quot;No controller specified.&quot;);
                    }

                    for (SupportedType t : types) {
                        Method method = controllerAccessor
                                            .getControllerMethods()
                                            .get(t)
                                            .get(handlerName);
                        if (method != null) {
                            return new MethodHandler(controller, method, t);
                        }
                    }
                    Method method = controllerAccessor
                                        .getControllerMethods()
                                        .get(SupportedType.PARAMETERLESS)
                                        .get(handlerName);
                    if (method != null) {
                        return new MethodHandler(controller, method, SupportedType.PARAMETERLESS);
                    }

                    return null;

                }

            }
            return null;
        }

        public void processEventHandlerAttributes() throws LoadException {
            if (eventHandlerAttributes.size() &gt; 0 &amp;&amp; !staticLoad) {
                for (Attribute attribute : eventHandlerAttributes) {
                    String handlerName = attribute.value;
                    if (value instanceof ObservableList &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
                        processObservableListHandler(handlerName);
                    } else if (value instanceof ObservableMap &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
                        processObservableMapHandler(handlerName);
                    } else if (value instanceof ObservableSet &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
                        processObservableSetHandler(handlerName);
                    } else if (attribute.name.endsWith(CHANGE_EVENT_HANDLER_SUFFIX)) {
                        processPropertyHandler(attribute.name, handlerName);
                    } else {
                        EventHandler&lt;? extends Event&gt; eventHandler = null;
                        MethodHandler handler = getControllerMethodHandle(handlerName, SupportedType.EVENT);
                        if (handler != null) {
                            eventHandler = new ControllerMethodEventHandler&lt;&gt;(handler);
                        }

                        if (eventHandler == null) {
                            eventHandler = getExpressionObjectOfType(handlerName, EventHandler.class);
                        }

                        if (eventHandler == null) {
                            if (handlerName.length() == 0 || scriptEngine == null) {
                                throw constructLoadException(&quot;Error resolving &quot; + attribute.name + &quot;='&quot; + attribute.value
                                        + &quot;', either the event handler is not in the Namespace or there is an error in the script.&quot;);
                            }

                            eventHandler = new ScriptEventHandler(handlerName, scriptEngine);
                        }

                        // Add the handler
                        getValueAdapter().put(attribute.name, eventHandler);
                    }
                }
            }
        }

        private void processObservableListHandler(String handlerValue) throws LoadException {
            ObservableList list = (ObservableList)value;
            if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.LIST_CHANGE_LISTENER);
                if (handler != null) {
                    list.addListener(new ObservableListChangeAdapter(handler));
                } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                }
            } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                Object listener = getExpressionObject(handlerValue);
                   if (listener instanceof ListChangeListener) {
                    list.addListener((ListChangeListener) listener);
                } else if (listener instanceof InvalidationListener) {
                    list.addListener((InvalidationListener) listener);
                } else {
                    throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                            + &quot;Must be either ListChangeListener or InvalidationListener&quot;);
                }
            }
        }

        private void processObservableMapHandler(String handlerValue) throws LoadException {
            ObservableMap map = (ObservableMap)value;
            if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.MAP_CHANGE_LISTENER);
                if (handler != null) {
                    map.addListener(new ObservableMapChangeAdapter(handler));
                } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                }
            } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                Object listener = getExpressionObject(handlerValue);
                if (listener instanceof MapChangeListener) {
                    map.addListener((MapChangeListener) listener);
                } else if (listener instanceof InvalidationListener) {
                    map.addListener((InvalidationListener) listener);
                } else {
                    throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                            + &quot;Must be either MapChangeListener or InvalidationListener&quot;);
                }
            }
        }

        private void processObservableSetHandler(String handlerValue) throws LoadException {
            ObservableSet set = (ObservableSet)value;
            if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.SET_CHANGE_LISTENER);
                if (handler != null) {
                    set.addListener(new ObservableSetChangeAdapter(handler));
                } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                }
            } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                Object listener = getExpressionObject(handlerValue);
                if (listener instanceof SetChangeListener) {
                    set.addListener((SetChangeListener) listener);
                } else if (listener instanceof InvalidationListener) {
                    set.addListener((InvalidationListener) listener);
                } else {
                    throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                            + &quot;Must be either SetChangeListener or InvalidationListener&quot;);
                }
            }
        }

        private void processPropertyHandler(String attributeName, String handlerValue) throws LoadException {
            int i = EVENT_HANDLER_PREFIX.length();
            int j = attributeName.length() - CHANGE_EVENT_HANDLER_SUFFIX.length();

            if (i != j) {
                String key = Character.toLowerCase(attributeName.charAt(i))
                        + attributeName.substring(i + 1, j);

                ObservableValue&lt;Object&gt; propertyModel = getValueAdapter().getPropertyModel(key);
                if (propertyModel == null) {
                    throw constructLoadException(value.getClass().getName() + &quot; does not define&quot;
                            + &quot; a property model for \&quot;&quot; + key + &quot;\&quot;.&quot;);
                }

                if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                    final MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.PROPERTY_CHANGE_LISTENER, SupportedType.EVENT);
                    if (handler != null) {
                        if (handler.type == SupportedType.EVENT) {
                            // Note: this part is solely for purpose of 2.2 backward compatibility where an Event object
                            // has been used instead of usual property change parameters
                            propertyModel.addListener(new ChangeListener&lt;Object&gt;() {
                                @Override
                                public void changed(ObservableValue&lt;?&gt; observable, Object oldValue, Object newValue) {
                                    handler.invoke(new Event(value, null, Event.ANY));
                                }
                            });
                        } else {
                            propertyModel.addListener(new PropertyChangeAdapter(handler));
                        }
                    } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                    }
                } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                    Object listener = getExpressionObject(handlerValue);
                    if (listener instanceof ChangeListener) {
                        propertyModel.addListener((ChangeListener) listener);
                    } else if (listener instanceof InvalidationListener) {
                        propertyModel.addListener((InvalidationListener) listener);
                    } else {
                        throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                                + &quot;Must be either ChangeListener or InvalidationListener&quot;);
                    }
                }

            }
        }
    }

    // Element representing a value
    private abstract class ValueElement extends Element {
        public String fx_id = null;

        @Override
        public void processStartElement() throws IOException {
            super.processStartElement();

            updateValue(constructValue());

            if (value instanceof Builder&lt;?&gt;) {
                processInstancePropertyAttributes();
            } else {
                processValue();
            }
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void processEndElement() throws IOException {
            super.processEndElement();

            // Build the value, if necessary
            if (value instanceof Builder&lt;?&gt;) {
                Builder&lt;Object&gt; builder = (Builder&lt;Object&gt;)value;
                updateValue(builder.build());

                processValue();
            } else {
                processInstancePropertyAttributes();
            }

            processEventHandlerAttributes();

            // Process static property attributes
            if (staticPropertyAttributes.size() &gt; 0) {
                for (Attribute attribute : staticPropertyAttributes) {
                    processPropertyAttribute(attribute);
                }
            }

            // Process static property elements
            if (staticPropertyElements.size() &gt; 0) {
                for (PropertyElement element : staticPropertyElements) {
                    BeanAdapter.put(value, element.sourceType, element.name, element.value);
                }
            }

            if (parent != null) {
                if (parent.isCollection()) {
                    parent.add(value);
                } else {
                    parent.set(value);
                }
            }
        }

        private Object getListValue(Element parent, String listPropertyName, Object value) {
            // If possible, coerce the value to the list item type
            if (parent.isTyped()) {
                Type listType = parent.getValueAdapter().getGenericType(listPropertyName);

                if (listType != null) {
                    Type itemType = BeanAdapter.getGenericListItemType(listType);

                    if (itemType instanceof ParameterizedType) {
                        itemType = ((ParameterizedType)itemType).getRawType();
                    }

                    value = BeanAdapter.coerce(value, (Class&lt;?&gt;)itemType);
                }
            }

            return value;
        }

        private void processValue() throws LoadException {
            // If this is the root element, update the value
            if (parent == null) {
                root = value;

                // checking version of fx namespace - throw exception if not supported
                String fxNSURI = xmlStreamReader.getNamespaceContext().getNamespaceURI(&quot;fx&quot;);
                if (fxNSURI != null) {
                    String fxVersion = fxNSURI.substring(fxNSURI.lastIndexOf(&quot;/&quot;) + 1);
                    if (compareJFXVersions(FX_NAMESPACE_VERSION, fxVersion) &lt; 0) {
                        throw constructLoadException(&quot;Loading FXML document of version &quot; +
                                fxVersion + &quot; by JavaFX runtime supporting version &quot; + FX_NAMESPACE_VERSION);
                    }
                }

                // checking the version JavaFX API - print warning if not supported
                String defaultNSURI = xmlStreamReader.getNamespaceContext().getNamespaceURI(&quot;&quot;);
                if (defaultNSURI != null) {
                    String nsVersion = defaultNSURI.substring(defaultNSURI.lastIndexOf(&quot;/&quot;) + 1);
                    if (compareJFXVersions(JAVAFX_VERSION, nsVersion) &lt; 0) {
                        Logging.getJavaFXLogger().warning(&quot;Loading FXML document with JavaFX API of version &quot; +
                                nsVersion + &quot; by JavaFX runtime of version &quot; + JAVAFX_VERSION);
                    }
                }
            }

            // Add the value to the namespace
            if (fx_id != null) {
                namespace.put(fx_id, value);

                // If the value defines an ID property, set it
                IDProperty idProperty = value.getClass().getAnnotation(IDProperty.class);

                if (idProperty != null) {
                    Map&lt;String, Object&gt; properties = getProperties();
                    // set fx:id property value to Node.id only if Node.id was not
                    // already set when processing start element attributes
                    if (properties.get(idProperty.value()) == null) {
                        properties.put(idProperty.value(), fx_id);
                    }
                }

                // Set the controller field value
                injectFields(fx_id, value);
            }
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void processCharacters() throws LoadException {
            Class&lt;?&gt; type = value.getClass();
            DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);

            // If the default property is a read-only list, add the value to it;
            // otherwise, set the value as the default property
            if (defaultProperty != null) {
                String text = xmlStreamReader.getText();
                text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;);

                String defaultPropertyName = defaultProperty.value();
                BeanAdapter valueAdapter = getValueAdapter();

                if (valueAdapter.isReadOnly(defaultPropertyName)
                    &amp;&amp; List.class.isAssignableFrom(valueAdapter.getType(defaultPropertyName))) {
                    List&lt;Object&gt; list = (List&lt;Object&gt;)valueAdapter.get(defaultPropertyName);
                    list.add(getListValue(this, defaultPropertyName, text));
                } else {
                    valueAdapter.put(defaultPropertyName, text.trim());
                }
            } else {
                throw constructLoadException(type.getName() + &quot; does not have a default property.&quot;);
            }
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException{
            if (prefix != null
                &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
                if (localName.equals(FX_ID_ATTRIBUTE)) {
                    // Verify that ID is a valid identifier
                    if (value.equals(NULL_KEYWORD)) {
                        throw constructLoadException(&quot;Invalid identifier.&quot;);
                    }

                    for (int i = 0, n = value.length(); i &lt; n; i++) {
                        if (!Character.isJavaIdentifierPart(value.charAt(i))) {
                            throw constructLoadException(&quot;Invalid identifier.&quot;);
                        }
                    }

                    fx_id = value;

                } else if (localName.equals(FX_CONTROLLER_ATTRIBUTE)) {
                    if (current.parent != null) {
                        throw constructLoadException(FX_NAMESPACE_PREFIX + &quot;:&quot; + FX_CONTROLLER_ATTRIBUTE
                            + &quot; can only be applied to root element.&quot;);
                    }

                    if (controller != null) {
                        throw constructLoadException(&quot;Controller value already specified.&quot;);
                    }

                    if (!staticLoad) {
                        Class&lt;?&gt; type;
                        try {
                            type = getClassLoader().loadClass(value);
                        } catch (ClassNotFoundException exception) {
                            throw constructLoadException(exception);
                        }

                        try {
                            if (controllerFactory == null) {
                                ReflectUtil.checkPackageAccess(type);
                                setController(type.newInstance());
                            } else {
                                setController(controllerFactory.call(type));
                            }
                        } catch (InstantiationException exception) {
                            throw constructLoadException(exception);
                        } catch (IllegalAccessException exception) {
                            throw constructLoadException(exception);
                        }
                    }
                } else {
                    throw constructLoadException(&quot;Invalid attribute.&quot;);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        public abstract Object constructValue() throws IOException;
    }

    // Element representing a class instance
    private class InstanceDeclarationElement extends ValueElement {
        public Class&lt;?&gt; type;

        public String constant = null;
        public String factory = null;

        public InstanceDeclarationElement(Class&lt;?&gt; type) throws LoadException {
            this.type = type;
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix != null
                &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
                if (localName.equals(FX_VALUE_ATTRIBUTE)) {
                    this.value = value;
                } else if (localName.equals(FX_CONSTANT_ATTRIBUTE)) {
                    constant = value;
                } else if (localName.equals(FX_FACTORY_ATTRIBUTE)) {
                    factory = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws IOException {
            Object value;
            if (this.value != null) {
                value = BeanAdapter.coerce(this.value, type);
            } else if (constant != null) {
                value = BeanAdapter.getConstantValue(type, constant);
            } else if (factory != null) {
                Method factoryMethod;
                try {
                    factoryMethod = MethodUtil.getMethod(type, factory, new Class[] {});
                } catch (NoSuchMethodException exception) {
                    throw constructLoadException(exception);
                }

                try {
                    value = MethodHelper.invoke(factoryMethod, null, new Object [] {});
                } catch (IllegalAccessException exception) {
                    throw constructLoadException(exception);
                } catch (InvocationTargetException exception) {
                    throw constructLoadException(exception);
                }
            } else {
                value = (builderFactory == null) ? null : builderFactory.getBuilder(type);

                if (value == null) {
                    value = DEFAULT_BUILDER_FACTORY.getBuilder(type);
                }

                if (value == null) {
                    try {
                        ReflectUtil.checkPackageAccess(type);
                        value = type.newInstance();
                    } catch (InstantiationException exception) {
                        throw constructLoadException(exception);
                    } catch (IllegalAccessException exception) {
                        throw constructLoadException(exception);
                    }
                }
            }

            return value;
        }
    }

    // Element representing an unknown type
    private class UnknownTypeElement extends ValueElement {
        // Map type representing an unknown value
        @DefaultProperty(&quot;items&quot;)
        public class UnknownValueMap extends AbstractMap&lt;String, Object&gt; {
            private ArrayList&lt;?&gt; items = new ArrayList&lt;Object&gt;();
            private HashMap&lt;String, Object&gt; values = new HashMap&lt;String, Object&gt;();

            @Override
            public Object get(Object key) {
                if (key == null) {
                    throw new NullPointerException();
                }

                return (key.equals(getClass().getAnnotation(DefaultProperty.class).value())) ?
                    items : values.get(key);
            }

            @Override
            public Object put(String key, Object value) {
                if (key == null) {
                    throw new NullPointerException();
                }

                if (key.equals(getClass().getAnnotation(DefaultProperty.class).value())) {
                    throw new IllegalArgumentException();
                }

                return values.put(key, value);
            }

            @Override
            public Set&lt;Entry&lt;String, Object&gt;&gt; entrySet() {
                return Collections.emptySet();
            }
        }

        @Override
        public void processEndElement() throws IOException {
            // No-op
        }

        @Override
        public Object constructValue() throws LoadException {
            return new UnknownValueMap();
        }
    }

    // Element representing an include
    private class IncludeElement extends ValueElement {
        public String source = null;
        public ResourceBundle resources = FXMLLoader.this.resources;
        public Charset charset = FXMLLoader.this.charset;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(INCLUDE_SOURCE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    source = value;
                } else if (localName.equals(INCLUDE_RESOURCES_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    resources = ResourceBundle.getBundle(value, Locale.getDefault(),
                            FXMLLoader.this.resources.getClass().getClassLoader());
                } else if (localName.equals(INCLUDE_CHARSET_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    charset = Charset.forName(value);
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws IOException {
            if (source == null) {
                throw constructLoadException(INCLUDE_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
            }

            URL location;
            final ClassLoader cl = getClassLoader();
            if (source.charAt(0) == '/') {
            // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
                location = cl.getResource(source.substring(1));
                if (location == null) {
                    throw constructLoadException(&quot;Cannot resolve path: &quot; + source);
                }
            } else {
                if (FXMLLoader.this.location == null) {
                    throw constructLoadException(&quot;Base location is undefined.&quot;);
                }

                location = new URL(FXMLLoader.this.location, source);
            }

            FXMLLoader fxmlLoader = new FXMLLoader(location, resources,
                builderFactory, controllerFactory, charset,
                loaders);
            fxmlLoader.parentLoader = FXMLLoader.this;

            if (isCyclic(FXMLLoader.this, fxmlLoader)) {
                throw new IOException(
                        String.format(
                        &quot;Including \&quot;%s\&quot; in \&quot;%s\&quot; created cyclic reference.&quot;,
                        fxmlLoader.location.toExternalForm(),
                        FXMLLoader.this.location.toExternalForm()));
            }
            fxmlLoader.setClassLoader(cl);
            fxmlLoader.setStaticLoad(staticLoad);

            Object value = fxmlLoader.loadImpl(callerClass);

            if (fx_id != null) {
                String id = this.fx_id + CONTROLLER_SUFFIX;
                Object controller = fxmlLoader.getController();

                namespace.put(id, controller);
                injectFields(id, controller);
            }

            return value;
        }
    }

    private void injectFields(String fieldName, Object value) throws LoadException {
        if (controller != null &amp;&amp; fieldName != null) {
            List&lt;Field&gt; fields = controllerAccessor.getControllerFields().get(fieldName);
            if (fields != null) {
                try {
                    for (Field f : fields) {
                        f.set(controller, value);
                    }
                } catch (IllegalAccessException exception) {
                    throw constructLoadException(exception);
                }
            }
        }
    }

    // Element representing a reference
    private class ReferenceElement extends ValueElement {
        public String source = null;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(REFERENCE_SOURCE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    source = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws LoadException {
            if (source == null) {
                throw constructLoadException(REFERENCE_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
            }

            KeyPath path = KeyPath.parse(source);
            if (!Expression.isDefined(namespace, path)) {
                throw constructLoadException(&quot;Value \&quot;&quot; + source + &quot;\&quot; does not exist.&quot;);
            }

            return Expression.get(namespace, path);
        }
    }

    // Element representing a copy
    private class CopyElement extends ValueElement {
        public String source = null;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(COPY_SOURCE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    source = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws LoadException {
            if (source == null) {
                throw constructLoadException(COPY_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
            }

            KeyPath path = KeyPath.parse(source);
            if (!Expression.isDefined(namespace, path)) {
                throw constructLoadException(&quot;Value \&quot;&quot; + source + &quot;\&quot; does not exist.&quot;);
            }

            Object sourceValue = Expression.get(namespace, path);
            Class&lt;?&gt; sourceValueType = sourceValue.getClass();

            Constructor&lt;?&gt; constructor = null;
            try {
                constructor = ConstructorUtil.getConstructor(sourceValueType, new Class[] { sourceValueType });
            } catch (NoSuchMethodException exception) {
                // No-op
            }

            Object value;
            if (constructor != null) {
                try {
                    ReflectUtil.checkPackageAccess(sourceValueType);
                    value = constructor.newInstance(sourceValue);
                } catch (InstantiationException exception) {
                    throw constructLoadException(exception);
                } catch (IllegalAccessException exception) {
                    throw constructLoadException(exception);
                } catch (InvocationTargetException exception) {
                    throw constructLoadException(exception);
                }
            } else {
                throw constructLoadException(&quot;Can't copy value &quot; + sourceValue + &quot;.&quot;);
            }

            return value;
        }
    }

    // Element representing a predefined root value
    private class RootElement extends ValueElement {
        public String type = null;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(ROOT_TYPE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    type = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws LoadException {
            if (type == null) {
                throw constructLoadException(ROOT_TYPE_ATTRIBUTE + &quot; is required.&quot;);
            }

            Class&lt;?&gt; type = getType(this.type);

            if (type == null) {
                throw constructLoadException(this.type + &quot; is not a valid type.&quot;);
            }

            Object value;
            if (root == null) {
                if (staticLoad) {
                    value = (builderFactory == null) ? null : builderFactory.getBuilder(type);

                    if (value == null) {
                        value = DEFAULT_BUILDER_FACTORY.getBuilder(type);
                    }

                    if (value == null) {
                        try {
                            ReflectUtil.checkPackageAccess(type);
                            value = type.newInstance();
                        } catch (InstantiationException exception) {
                            throw constructLoadException(exception);
                        } catch (IllegalAccessException exception) {
                            throw constructLoadException(exception);
                        }
                    }
                    root = value;
                } else {
                    throw constructLoadException(&quot;Root hasn't been set. Use method setRoot() before load.&quot;);
                }
            } else {
                if (!type.isAssignableFrom(root.getClass())) {
                    throw constructLoadException(&quot;Root is not an instance of &quot;
                        + type.getName() + &quot;.&quot;);
                }

                value = root;
            }

            return value;
        }
    }

    // Element representing a property
    private class PropertyElement extends Element {
        public final String name;
        public final Class&lt;?&gt; sourceType;
        public final boolean readOnly;

        public PropertyElement(String name, Class&lt;?&gt; sourceType) throws LoadException {
            if (parent == null) {
                throw constructLoadException(&quot;Invalid root element.&quot;);
            }

            if (parent.value == null) {
                throw constructLoadException(&quot;Parent element does not support property elements.&quot;);
            }

            this.name = name;
            this.sourceType = sourceType;

            if (sourceType == null) {
                // The element represents an instance property
                if (name.startsWith(EVENT_HANDLER_PREFIX)) {
                    throw constructLoadException(&quot;\&quot;&quot; + name + &quot;\&quot; is not a valid element name.&quot;);
                }

                Map&lt;String, Object&gt; parentProperties = parent.getProperties();

                if (parent.isTyped()) {
                    readOnly = parent.getValueAdapter().isReadOnly(name);
                } else {
                // If the map already defines a value for the property, assume
                    // that it is read-only
                    readOnly = parentProperties.containsKey(name);
                }

                if (readOnly) {
                    Object value = parentProperties.get(name);
                    if (value == null) {
                        throw constructLoadException(&quot;Invalid property.&quot;);
                    }

                    updateValue(value);
                }
            } else {
                // The element represents a static property
                readOnly = false;
            }
        }

        @Override
        public boolean isCollection() {
            return (readOnly) ? super.isCollection() : false;
        }

        @Override
        public void add(Object element) throws LoadException {
            // Coerce the element to the list item type
            if (parent.isTyped()) {
                Type listType = parent.getValueAdapter().getGenericType(name);
                element = BeanAdapter.coerce(element, BeanAdapter.getListItemType(listType));
            }

            // Add the item to the list
            super.add(element);
        }

        @Override
        public void set(Object value) throws LoadException {
            // Update the value
            updateValue(value);

            if (sourceType == null) {
                // Apply value to parent element's properties
                parent.getProperties().put(name, value);
            } else {
                if (parent.value instanceof Builder) {
                    // Defer evaluation of the property
                    parent.staticPropertyElements.add(this);
                } else {
                    // Apply the static property value
                    BeanAdapter.put(parent.value, sourceType, name, value);
                }
            }
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (!readOnly) {
                throw constructLoadException(&quot;Attributes are not supported for writable property elements.&quot;);
            }

            super.processAttribute(prefix, localName, value);
        }

        @Override
        public void processEndElement() throws IOException {
            super.processEndElement();

            if (readOnly) {
                processInstancePropertyAttributes();
                processEventHandlerAttributes();
            }
        }

        @Override
        public void processCharacters() throws IOException {
            String text = xmlStreamReader.getText();
            text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;).trim();

            if (readOnly) {
                if (isCollection()) {
                    add(text);
                } else {
                    super.processCharacters();
                }
            } else {
                set(text);
            }
        }
    }

    // Element representing an unknown static property
    private class UnknownStaticPropertyElement extends Element {
        public UnknownStaticPropertyElement() throws LoadException {
            if (parent == null) {
                throw constructLoadException(&quot;Invalid root element.&quot;);
            }

            if (parent.value == null) {
                throw constructLoadException(&quot;Parent element does not support property elements.&quot;);
            }
        }

        @Override
        public boolean isCollection() {
            return false;
        }

        @Override
        public void set(Object value) {
            updateValue(value);
        }

        @Override
        public void processCharacters() throws IOException {
            String text = xmlStreamReader.getText();
            text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;);

            updateValue(text.trim());
        }
    }

    // Element representing a script block
    private class ScriptElement extends Element {
        public String source = null;
        public Charset charset = FXMLLoader.this.charset;

        @Override
        public boolean isCollection() {
            return false;
        }

        @Override
        public void processStartElement() throws IOException {
            super.processStartElement();

            if (source != null &amp;&amp; !staticLoad) {
                int i = source.lastIndexOf(&quot;.&quot;);
                if (i == -1) {
                    throw constructLoadException(&quot;Cannot determine type of script \&quot;&quot;
                        + source + &quot;\&quot;.&quot;);
                }

                String extension = source.substring(i + 1);
                ScriptEngine engine;
                final ClassLoader cl = getClassLoader();
                if (scriptEngine != null &amp;&amp; scriptEngine.getFactory().getExtensions().contains(extension)) {
                    // If we have a page language and it's engine supports the extension, use the same engine
                    engine = scriptEngine;
                } else {
                    ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();
                    try {
                        Thread.currentThread().setContextClassLoader(cl);
                        ScriptEngineManager scriptEngineManager = getScriptEngineManager();
                        engine = scriptEngineManager.getEngineByExtension(extension);
                    } finally {
                        Thread.currentThread().setContextClassLoader(oldLoader);
                    }
                }

                if (engine == null) {
                    throw constructLoadException(&quot;Unable to locate scripting engine for&quot;
                        + &quot; extension &quot; + extension + &quot;.&quot;);
                }

                try {
                    URL location;
                    if (source.charAt(0) == '/') {
                        // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
                        location = cl.getResource(source.substring(1));
                    } else {
                        if (FXMLLoader.this.location == null) {
                            throw constructLoadException(&quot;Base location is undefined.&quot;);
                        }

                        location = new URL(FXMLLoader.this.location, source);
                    }

                    InputStreamReader scriptReader = null;
                    try {
                        scriptReader = new InputStreamReader(location.openStream(), charset);
                        engine.eval(scriptReader);
                    } catch(ScriptException exception) {
                        exception.printStackTrace();
                    } finally {
                        if (scriptReader != null) {
                            scriptReader.close();
                        }
                    }
                } catch (IOException exception) {
                    throw constructLoadException(exception);
                }
            }
        }

        @Override
        public void processEndElement() throws IOException {
            super.processEndElement();

            if (value != null &amp;&amp; !staticLoad) {
                // Evaluate the script
                try {
                    scriptEngine.eval((String)value);
                } catch (ScriptException exception) {
                    System.err.println(exception.getMessage());
                }
            }
        }

        @Override
        public void processCharacters() throws LoadException {
            if (source != null) {
                throw constructLoadException(&quot;Script source already specified.&quot;);
            }

            if (scriptEngine == null &amp;&amp; !staticLoad) {
                throw constructLoadException(&quot;Page language not specified.&quot;);
            }

            updateValue(xmlStreamReader.getText());
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null
                &amp;&amp; localName.equals(SCRIPT_SOURCE_ATTRIBUTE)) {
                if (loadListener != null) {
                    loadListener.readInternalAttribute(localName, value);
                }

                source = value;
            } else if (localName.equals(SCRIPT_CHARSET_ATTRIBUTE)) {
                if (loadListener != null) {
                    loadListener.readInternalAttribute(localName, value);
                }

                charset = Charset.forName(value);
            } else {
                throw constructLoadException(prefix == null ? localName : prefix + &quot;:&quot; + localName
                    + &quot; is not a valid attribute.&quot;);
            }
        }
    }

    // Element representing a define block
    private class DefineElement extends Element {
        @Override
        public boolean isCollection() {
            return true;
        }

        @Override
        public void add(Object element) {
            // No-op
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws LoadException{
            throw constructLoadException(&quot;Element does not support attributes.&quot;);
        }
    }

    // Class representing an attribute of an element
    private static class Attribute {
        public final String name;
        public final Class&lt;?&gt; sourceType;
        public final String value;

        public Attribute(String name, Class&lt;?&gt; sourceType, String value) {
            this.name = name;
            this.sourceType = sourceType;
            this.value = value;
        }
    }

    // Event handler that delegates to a method defined by the controller object
    private static class ControllerMethodEventHandler&lt;T extends Event&gt; implements EventHandler&lt;T&gt; {
        private final MethodHandler handler;

        public ControllerMethodEventHandler(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void handle(T event) {
            handler.invoke(event);
        }
    }

    // Event handler implemented in script code
    private static class ScriptEventHandler implements EventHandler&lt;Event&gt; {
        public final String script;
        public final ScriptEngine scriptEngine;

        public ScriptEventHandler(String script, ScriptEngine scriptEngine) {
            this.script = script;
            this.scriptEngine = scriptEngine;
        }

        @Override
        public void handle(Event event) {
            // Don't pollute the page namespace with values defined in the script
            Bindings engineBindings = scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);
            Bindings localBindings = scriptEngine.createBindings();
            localBindings.put(EVENT_KEY, event);
            localBindings.putAll(engineBindings);
            scriptEngine.setBindings(localBindings, ScriptContext.ENGINE_SCOPE);

            // Execute the script
            try {
                scriptEngine.eval(script);
            } catch (ScriptException exception){
                throw new RuntimeException(exception);
            }

            // Restore the original bindings
            scriptEngine.setBindings(engineBindings, ScriptContext.ENGINE_SCOPE);
        }
    }

    // Observable list change listener
    private static class ObservableListChangeAdapter implements ListChangeListener {
        private final MethodHandler handler;

        public ObservableListChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void onChanged(Change change) {
            if (handler != null) {
                handler.invoke(change);
            }
        }
    }

    // Observable map change listener
    private static class ObservableMapChangeAdapter implements MapChangeListener {
        public final MethodHandler handler;

        public ObservableMapChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void onChanged(Change change) {
            if (handler != null) {
                handler.invoke(change);
            }
        }
    }

    // Observable set change listener
    private static class ObservableSetChangeAdapter implements SetChangeListener {
        public final MethodHandler handler;

        public ObservableSetChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void onChanged(Change change) {
            if (handler != null) {
                handler.invoke(change);
            }
        }
    }

    // Property model change listener
    private static class PropertyChangeAdapter implements ChangeListener&lt;Object&gt; {
        public final MethodHandler handler;

        public PropertyChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void changed(ObservableValue&lt;? extends Object&gt; observable, Object oldValue, Object newValue) {
            handler.invoke(observable, oldValue, newValue);
        }
    }

    private static class MethodHandler {
        private final Object controller;
        private final Method method;
        private final SupportedType type;

        private MethodHandler(Object controller, Method method, SupportedType type) {
            this.method = method;
            this.controller = controller;
            this.type = type;
        }

        public void invoke(Object... params) {
            try {
                if (type != SupportedType.PARAMETERLESS) {
                    MethodHelper.invoke(method, controller, params);
                } else {
                    MethodHelper.invoke(method, controller, new Object[] {});
                }
            } catch (InvocationTargetException exception) {
                throw new RuntimeException(exception);
            } catch (IllegalAccessException exception) {
                throw new RuntimeException(exception);
            }
        }
    }

    private URL location;
    private ResourceBundle resources;

    private ObservableMap&lt;String, Object&gt; namespace = FXCollections.observableHashMap();

    private Object root = null;
    private Object controller = null;

    private BuilderFactory builderFactory;
    private Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory;
    private Charset charset;

    private final LinkedList&lt;FXMLLoader&gt; loaders;

    private ClassLoader classLoader = null;
    private boolean staticLoad = false;
    private LoadListener loadListener = null;

    private FXMLLoader parentLoader;

    private XMLStreamReader xmlStreamReader = null;
    private Element current = null;

    private ScriptEngine scriptEngine = null;

    private List&lt;String&gt; packages = new LinkedList&lt;String&gt;();
    private Map&lt;String, Class&lt;?&gt;&gt; classes = new HashMap&lt;String, Class&lt;?&gt;&gt;();

    private ScriptEngineManager scriptEngineManager = null;

    private static ClassLoader defaultClassLoader = null;

    private static final Pattern extraneousWhitespacePattern = Pattern.compile(&quot;\\s+&quot;);

    private static BuilderFactory DEFAULT_BUILDER_FACTORY = new JavaFXBuilderFactory();

    /**
     * The character set used when character set is not explicitly specified.
     */
    public static final String DEFAULT_CHARSET_NAME = &quot;UTF-8&quot;;

    /**
     * The tag name of language processing instruction.
     */
    public static final String LANGUAGE_PROCESSING_INSTRUCTION = &quot;language&quot;;
    /**
     * The tag name of import processing instruction.
     */
    public static final String IMPORT_PROCESSING_INSTRUCTION = &quot;import&quot;;

    /**
     * Prefix of 'fx' namespace.
     */
    public static final String FX_NAMESPACE_PREFIX = &quot;fx&quot;;
    /**
     * The name of fx:controller attribute of a root.
     */
    public static final String FX_CONTROLLER_ATTRIBUTE = &quot;controller&quot;;
    /**
     * The name of fx:id attribute.
     */
    public static final String FX_ID_ATTRIBUTE = &quot;id&quot;;
    /**
     * The name of fx:value attribute.
     */
    public static final String FX_VALUE_ATTRIBUTE = &quot;value&quot;;
    /**
     * The tag name of 'fx:constant'.
     * @since JavaFX 2.2
     */
    public static final String FX_CONSTANT_ATTRIBUTE = &quot;constant&quot;;
    /**
     * The name of 'fx:factory' attribute.
     */
    public static final String FX_FACTORY_ATTRIBUTE = &quot;factory&quot;;

    /**
     * The tag name of {@literal &lt;fx:include&gt;}.
     */
    public static final String INCLUDE_TAG = &quot;include&quot;;
    /**
     * The {@literal &lt;fx:include&gt;} 'source' attribute.
     */
    public static final String INCLUDE_SOURCE_ATTRIBUTE = &quot;source&quot;;
    /**
     * The {@literal &lt;fx:include&gt;} 'resources' attribute.
     */
    public static final String INCLUDE_RESOURCES_ATTRIBUTE = &quot;resources&quot;;
    /**
     * The {@literal &lt;fx:include&gt;} 'charset' attribute.
     */
    public static final String INCLUDE_CHARSET_ATTRIBUTE = &quot;charset&quot;;

    /**
     * The tag name of {@literal &lt;fx:script&gt;}.
     */
    public static final String SCRIPT_TAG = &quot;script&quot;;
    /**
     * The {@literal &lt;fx:script&gt;} 'source' attribute.
     */
    public static final String SCRIPT_SOURCE_ATTRIBUTE = &quot;source&quot;;
    /**
     * The {@literal &lt;fx:script&gt;} 'charset' attribute.
     */
    public static final String SCRIPT_CHARSET_ATTRIBUTE = &quot;charset&quot;;

    /**
     * The tag name of {@literal &lt;fx:define&gt;}.
     */
    public static final String DEFINE_TAG = &quot;define&quot;;

    /**
     * The tag name of {@literal &lt;fx:reference&gt;}.
     */
    public static final String REFERENCE_TAG = &quot;reference&quot;;
    /**
     * The {@literal &lt;fx:reference&gt;} 'source' attribute.
     */
    public static final String REFERENCE_SOURCE_ATTRIBUTE = &quot;source&quot;;

    /**
     * The tag name of {@literal &lt;fx:root&gt;}.
     * @since JavaFX 2.2
     */
    public static final String ROOT_TAG = &quot;root&quot;;
    /**
     * The {@literal &lt;fx:root&gt;} 'type' attribute.
     * @since JavaFX 2.2
     */
    public static final String ROOT_TYPE_ATTRIBUTE = &quot;type&quot;;

    /**
     * The tag name of {@literal &lt;fx:copy&gt;}.
     */
    public static final String COPY_TAG = &quot;copy&quot;;
    /**
     * The {@literal &lt;fx:copy&gt;} 'source' attribute.
     */
    public static final String COPY_SOURCE_ATTRIBUTE = &quot;source&quot;;

    /**
     * The prefix of event handler attributes.
     */
    public static final String EVENT_HANDLER_PREFIX = &quot;on&quot;;
    /**
     * The name of the Event object in event handler scripts.
     */
    public static final String EVENT_KEY = &quot;event&quot;;
    /**
     * Suffix for property change/invalidation handlers.
     */
    public static final String CHANGE_EVENT_HANDLER_SUFFIX = &quot;Change&quot;;
    private static final String COLLECTION_HANDLER_NAME = EVENT_HANDLER_PREFIX + CHANGE_EVENT_HANDLER_SUFFIX;

    /**
     * Value that represents 'null'.
     */
    public static final String NULL_KEYWORD = &quot;null&quot;;

    /**
     * Escape prefix for escaping special characters inside attribute values.
     * Serves as an escape for {@link #ESCAPE_PREFIX}, {@link #RELATIVE_PATH_PREFIX},
     * {@link #RESOURCE_KEY_PREFIX}, {@link #EXPRESSION_PREFIX},
     * {@link #BI_DIRECTIONAL_BINDING_PREFIX}
     * @since JavaFX 2.1
     */
    public static final String ESCAPE_PREFIX = &quot;\\&quot;;
    /**
     * Prefix for relative location resolution.
     */
    public static final String RELATIVE_PATH_PREFIX = &quot;@&quot;;
    /**
     * Prefix for resource resolution.
     */
    public static final String RESOURCE_KEY_PREFIX = &quot;%&quot;;
    /**
     * Prefix for (variable) expression resolution.
     */
    public static final String EXPRESSION_PREFIX = &quot;$&quot;;
    /**
     * Prefix for binding expression resolution.
     */
    public static final String BINDING_EXPRESSION_PREFIX = &quot;${&quot;;
    /**
     * Suffix for binding expression resolution.
     */
    public static final String BINDING_EXPRESSION_SUFFIX = &quot;}&quot;;

    /**
     * Prefix for bidirectional-binding expression resolution.
     * @since JavaFX 2.1
     */
    public static final String BI_DIRECTIONAL_BINDING_PREFIX = &quot;#{&quot;;
    /**
     * Suffix for bidirectional-binding expression resolution.
     * @since JavaFX 2.1
     */
    public static final String BI_DIRECTIONAL_BINDING_SUFFIX = &quot;}&quot;;

    /**
     * Delimiter for arrays as values.
     * @since JavaFX 2.1
     */
    public static final String ARRAY_COMPONENT_DELIMITER = &quot;,&quot;;

    /**
     * A key for location URL in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.2
     */
    public static final String LOCATION_KEY = &quot;location&quot;;
    /**
     * A key for ResourceBundle in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.2
     */
    public static final String RESOURCES_KEY = &quot;resources&quot;;

    /**
     * Prefix for controller method resolution.
     */
    public static final String CONTROLLER_METHOD_PREFIX = &quot;#&quot;;
    /**
     * A key for controller in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.1
     */
    public static final String CONTROLLER_KEYWORD = &quot;controller&quot;;
    /**
     * A suffix for controllers of included fxml files.
     * The full key is stored in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.2
     */
    public static final String CONTROLLER_SUFFIX = &quot;Controller&quot;;

    /**
     * The name of initialize method.
     * @since JavaFX 2.2
     */
    public static final String INITIALIZE_METHOD_NAME = &quot;initialize&quot;;

    /**
     * Contains the current javafx version.
     * @since JavaFX 8.0
     */
    public static final String JAVAFX_VERSION;

    /**
     * Contains the current fx namepsace version.
     * @since JavaFX 8.0
     */
    public static final String FX_NAMESPACE_VERSION = &quot;1&quot;;

    static {
        JAVAFX_VERSION = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
            @Override
            public String run() {
                return System.getProperty(&quot;javafx.version&quot;);
            }
        });

        FXMLLoaderHelper.setFXMLLoaderAccessor(new FXMLLoaderHelper.FXMLLoaderAccessor() {
            @Override
            public void setStaticLoad(FXMLLoader fxmlLoader, boolean staticLoad) {
                fxmlLoader.setStaticLoad(staticLoad);
            }
        });
    }

    /**
     * Creates a new FXMLLoader instance.
     */
    public FXMLLoader() {
        this((URL)null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location) {
        this(location, null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources) {
        this(location, resources, null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory) {
        this(location, resources, builderFactory, null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @param controllerFactory the controller factory used by this loader
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory) {
        this(location, resources, builderFactory, controllerFactory, Charset.forName(DEFAULT_CHARSET_NAME));
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param charset the character set used by this loader
     */
    public FXMLLoader(Charset charset) {
        this(null, null, null, null, charset);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @param controllerFactory the controller factory used by this loader
     * @param charset the character set used by this loader
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory, Charset charset) {
        this(location, resources, builderFactory, controllerFactory, charset,
            new LinkedList&lt;FXMLLoader&gt;());
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @param controllerFactory the controller factory used by this loader
     * @param charset the character set used by this loader
     * @param loaders list of loaders
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory, Charset charset,
        LinkedList&lt;FXMLLoader&gt; loaders) {
        setLocation(location);
        setResources(resources);
        setBuilderFactory(builderFactory);
<A NAME="6"></A>        setControllerFactory(controllerFactory);
        setCharset(charset);

        <FONT color="#50ebec"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#6',2,'match51-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>this.loaders = new LinkedList(loaders);
    }

    /**
     * Returns the location used to resolve relative path attribute values.
     * @return the location used to resolve relative path attribute values
     */
    public URL getLocation() {
        return location;
    }

    /**
     * Sets the location used to resolve relative path attribute values.
     *
     * @param location the location
     */
    public void setLocation(URL location) {
        this.location = location;
    }</B></FONT>

    /**
     * Returns the resources used to resolve resource key attribute values.
     * @return the resources used to resolve resource key attribute values
     */
    public ResourceBundle getResources() {
        return resources;
    }

    /**
     * Sets the resources used to resolve resource key attribute values.
     *
     * @param resources the resources
     */
    public void setResources(ResourceBundle resources) {
        this.resources = resources;
    }

    /**
     * Returns the namespace used by this loader.
     * @return the namespace
     */
    public ObservableMap&lt;String, Object&gt; getNamespace() {
        return namespace;
    }

    /**
     * Returns the root of the object hierarchy.
     * @param &lt;T&gt; the type of the root object
     * @return the root of the object hierarchy
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T getRoot() {
        return (T)root;
    }

    /**
     * Sets the root of the object hierarchy. The value passed to this method
     * is used as the value of the {@code &lt;fx:root&gt;} tag. This method
     * must be called prior to loading the document when using
     * {@code &lt;fx:root&gt;}.
     *
     * @param root the root of the object hierarchy
     *
     * @since JavaFX 2.2
     */
    public void setRoot(Object root) {
        this.root = root;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof FXMLLoader) {
            FXMLLoader loader = (FXMLLoader)obj;
            if (location == null || loader.location == null) {
                return loader.location == location;
            }
            return location.toExternalForm().equals(
                    loader.location.toExternalForm());
        }
        return false;
    }

    private boolean isCyclic(
                            FXMLLoader currentLoader,
                            FXMLLoader node) {
        if (currentLoader == null) {
            return false;
        }
        if (currentLoader.equals(node)) {
            return true;
        }
        return isCyclic(currentLoader.parentLoader, node);
    }

    /**
     * Returns the controller associated with the root object.
     * @param &lt;T&gt; the type of the controller
     * @return the controller associated with the root object
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T getController() {
        return (T)controller;
    }

    /**
     * Sets the controller associated with the root object. The value passed to
     * this method is used as the value of the {@code fx:controller} attribute.
     * This method must be called prior to loading the document when using
     * controller event handlers when an {@code fx:controller} attribute is not
     * specified in the document.
     *
     * @param controller the controller to associate with the root object
     *
     * @since JavaFX 2.2
     */
    public void setController(Object controller) {
        this.controller = controller;

        if (controller == null) {
            namespace.remove(CONTROLLER_KEYWORD);
        } else {
            namespace.put(CONTROLLER_KEYWORD, controller);
        }

        controllerAccessor.setController(controller);
    }

    /**
     * Returns the builder factory used by this loader.
     * @return the builder factory
     */
    public BuilderFactory getBuilderFactory() {
        return builderFactory;
    }

    /**
     * Sets the builder factory used by this loader.
     *
     * @param builderFactory the builder factory
     */
    public void setBuilderFactory(BuilderFactory builderFactory) {
        this.builderFactory = builderFactory;
    }

    /**
     * Returns the controller factory used by this loader.
     * @return the controller factory
     * @since JavaFX 2.1
     */
    public Callback&lt;Class&lt;?&gt;, Object&gt; getControllerFactory() {
        return controllerFactory;
    }

    /**
     * Sets the controller factory used by this loader.
     *
     * @param controllerFactory the controller factory
     * @since JavaFX 2.1
     */
    public void setControllerFactory(Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory) {
        this.controllerFactory = controllerFactory;
    }

    /**
     * Returns the character set used by this loader.
     * @return the character set
     */
    public Charset getCharset() {
        return charset;
    }

    /**
     * Sets the character set used by this loader.
     *
     * @param charset the character set
     * @since JavaFX 2.1
     */
    public void setCharset(Charset charset) {
        if (charset == null) {
            throw new NullPointerException(&quot;charset is null.&quot;);
        }

        this.charset = charset;
    }

    /**
     * Returns the classloader used by this loader.
     * @return the classloader
     * @since JavaFX 2.1
     */
    public ClassLoader getClassLoader() {
        if (classLoader == null) {
            final SecurityManager sm = System.getSecurityManager();
            final Class caller = (sm != null) ?
                    walker.getCallerClass() :
                    null;
            return getDefaultClassLoader(caller);
        }
        return classLoader;
    }

    /**
     * Sets the classloader used by this loader and clears any existing
     * imports.
     *
     * @param classLoader the classloader
     * @since JavaFX 2.1
     */
    public void setClassLoader(ClassLoader classLoader) {
        if (classLoader == null) {
            throw new IllegalArgumentException();
        }

        this.classLoader = classLoader;

        clearImports();
    }

    /*
     * Returns the static load flag.
     */
    boolean isStaticLoad() {
        // SB-dependency: RT-21226 has been filed to track this
        return staticLoad;
    }

    /*
     * Sets the static load flag.
     *
     * @param staticLoad
     */
    void setStaticLoad(boolean staticLoad) {
        // SB-dependency: RT-21226 has been filed to track this
        this.staticLoad = staticLoad;
    }

    /**
     * Returns this loader's load listener.
     *
     * @return the load listener
     *
     * @since 9
     */
    public LoadListener getLoadListener() {
        // SB-dependency: RT-21228 has been filed to track this
        return loadListener;
    }

    /**
     * Sets this loader's load listener.
     *
     * @param loadListener the load listener
     *
     * @since 9
     */
    public final void setLoadListener(LoadListener loadListener) {
        // SB-dependency: RT-21228 has been filed to track this
        this.loadListener = loadListener;
    }

    /**
     * Loads an object hierarchy from a FXML document. The location from which
     * the document will be loaded must have been set by a prior call to
     * {@link #setLocation(URL)}.
     *
     * @param &lt;T&gt; the type of the root object
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     *
     * @since JavaFX 2.1
     */
    public &lt;T&gt; T load() throws IOException {
        return loadImpl((System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param inputStream an input stream containing the FXML data to load
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public &lt;T&gt; T load(InputStream inputStream) throws IOException {
        return loadImpl(inputStream, (System.getSecurityManager() != null)
                                         ? walker.getCallerClass()
                                         : null);
    }

    private Class&lt;?&gt; callerClass;

    private &lt;T&gt; T loadImpl(final Class&lt;?&gt; callerClass) throws IOException {
        if (location == null) {
            throw new IllegalStateException(&quot;Location is not set.&quot;);
        }

        InputStream inputStream = null;
        T value;
        try {
            inputStream = location.openStream();
            value = loadImpl(inputStream, callerClass);
        } finally {
            if (inputStream != null) {
                inputStream.close();
            }
        }

        return value;
    }

    @SuppressWarnings({ &quot;dep-ann&quot;, &quot;unchecked&quot; })
    private &lt;T&gt; T loadImpl(InputStream inputStream,
                           Class&lt;?&gt; callerClass) throws IOException {
        if (inputStream == null) {
            throw new NullPointerException(&quot;inputStream is null.&quot;);
        }

        this.callerClass = callerClass;
        controllerAccessor.setCallerClass(callerClass);
        try {
            clearImports();

            // Initialize the namespace
            namespace.put(LOCATION_KEY, location);
            namespace.put(RESOURCES_KEY, resources);

            // Clear the script engine
            scriptEngine = null;

            // Create the parser
            try {
                XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
                xmlInputFactory.setProperty(&quot;javax.xml.stream.isCoalescing&quot;, true);

                // Some stream readers incorrectly report an empty string as the prefix
                // for the default namespace; correct this as needed
                InputStreamReader inputStreamReader = new InputStreamReader(inputStream, charset);
                xmlStreamReader = new StreamReaderDelegate(xmlInputFactory.createXMLStreamReader(inputStreamReader)) {
                    @Override
                    public String getPrefix() {
                        String prefix = super.getPrefix();

                        if (prefix != null
                            &amp;&amp; prefix.length() == 0) {
                            prefix = null;
                        }

                        return prefix;
                    }

                    @Override
                    public String getAttributePrefix(int index) {
                        String attributePrefix = super.getAttributePrefix(index);

                        if (attributePrefix != null
                            &amp;&amp; attributePrefix.length() == 0) {
                            attributePrefix = null;
                        }

                        return attributePrefix;
                    }
                };
            } catch (XMLStreamException exception) {
                throw constructLoadException(exception);
            }

            // Push this loader onto the stack
            loaders.push(this);

            // Parse the XML stream
            try {
                while (xmlStreamReader.hasNext()) {
                    int event = xmlStreamReader.next();

                    switch (event) {
                        case XMLStreamConstants.PROCESSING_INSTRUCTION: {
                            processProcessingInstruction();
                            break;
                        }

                        case XMLStreamConstants.COMMENT: {
                            processComment();
                            break;
                        }

                        case XMLStreamConstants.START_ELEMENT: {
                            processStartElement();
                            break;
                        }

                        case XMLStreamConstants.END_ELEMENT: {
                            processEndElement();
                            break;
                        }

                        case XMLStreamConstants.CHARACTERS: {
                            processCharacters();
                            break;
                        }
                    }
                }
            } catch (XMLStreamException exception) {
                throw constructLoadException(exception);
            }

            if (controller != null) {
                if (controller instanceof Initializable) {
                    ((Initializable)controller).initialize(location, resources);
                } else {
                    // Inject controller fields
                    Map&lt;String, List&lt;Field&gt;&gt; controllerFields =
                            controllerAccessor.getControllerFields();

                    injectFields(LOCATION_KEY, location);

                    injectFields(RESOURCES_KEY, resources);

                    // Initialize the controller
                    Method initializeMethod = controllerAccessor
                                                  .getControllerMethods()
                                                  .get(SupportedType.PARAMETERLESS)
                                                  .get(INITIALIZE_METHOD_NAME);

                    if (initializeMethod != null) {
                        try {
                            MethodHelper.invoke(initializeMethod, controller, new Object [] {});
                        } catch (IllegalAccessException exception) {
                            throw constructLoadException(exception);
                        } catch (InvocationTargetException exception) {
                            throw constructLoadException(exception);
                        }
                    }
                }
            }
        } catch (final LoadException exception) {
            throw exception;
        } catch (final Exception exception) {
            throw constructLoadException(exception);
        } finally {
            controllerAccessor.setCallerClass(null);
            // Clear controller accessor caches
            controllerAccessor.reset();
            // Clear the parser
            xmlStreamReader = null;
        }

        return (T)root;
    }

    private void clearImports() {
        packages.clear();
        classes.clear();
    }

    private LoadException constructLoadException(String message){
        return new LoadException(message + constructFXMLTrace());
    }

    private LoadException constructLoadException(Throwable cause) {
        return new LoadException(constructFXMLTrace(), cause);
    }

    private LoadException constructLoadException(String message, Throwable cause){
        return new LoadException(message + constructFXMLTrace(), cause);
    }

    private String constructFXMLTrace() {
        StringBuilder messageBuilder = new StringBuilder(&quot;\n&quot;);

        for (FXMLLoader loader : loaders) {
            messageBuilder.append(loader.location != null ? loader.location.getPath() : &quot;unknown path&quot;);

            if (loader.current != null) {
                messageBuilder.append(&quot;:&quot;);
                messageBuilder.append(loader.getLineNumber());
            }

            messageBuilder.append(&quot;\n&quot;);
        }
        return messageBuilder.toString();
    }

    /**
     * Returns the current line number.
     */
    int getLineNumber() {
        return xmlStreamReader.getLocation().getLineNumber();
    }

    /**
     * Returns the current parse trace.
     */
    ParseTraceElement[] getParseTrace() {
        ParseTraceElement[] parseTrace = new ParseTraceElement[loaders.size()];

        int i = 0;
        for (FXMLLoader loader : loaders) {
            parseTrace[i++] = new ParseTraceElement(loader.location, (loader.current != null) ?
                loader.getLineNumber() : -1);
        }

        return parseTrace;
    }

    private void processProcessingInstruction() throws LoadException {
        String piTarget = xmlStreamReader.getPITarget().trim();

        if (piTarget.equals(LANGUAGE_PROCESSING_INSTRUCTION)) {
            processLanguage();
        } else if (piTarget.equals(IMPORT_PROCESSING_INSTRUCTION)) {
            processImport();
        }
    }

    private void processLanguage() throws LoadException {
        if (scriptEngine != null) {
            throw constructLoadException(&quot;Page language already set.&quot;);
        }

        String language = xmlStreamReader.getPIData();

        if (loadListener != null) {
            loadListener.readLanguageProcessingInstruction(language);
        }

        if (!staticLoad) {
            ScriptEngineManager scriptEngineManager = getScriptEngineManager();
            scriptEngine = scriptEngineManager.getEngineByName(language);
        }
    }

    private void processImport() throws LoadException {
        String target = xmlStreamReader.getPIData().trim();

        if (loadListener != null) {
            loadListener.readImportProcessingInstruction(target);
        }

        if (target.endsWith(&quot;.*&quot;)) {
            importPackage(target.substring(0, target.length() - 2));
        } else {
            importClass(target);
        }
    }

    private void processComment() throws LoadException {
        if (loadListener != null) {
            loadListener.readComment(xmlStreamReader.getText());
        }
    }

    private void processStartElement() throws IOException {
        // Create the element
        createElement();

        // Process the start tag
        current.processStartElement();

        // Set the root value
        if (root == null) {
            root = current.value;
        }
    }

    private void createElement() throws IOException {
        String prefix = xmlStreamReader.getPrefix();
        String localName = xmlStreamReader.getLocalName();

        if (prefix == null) {
            int i = localName.lastIndexOf('.');

            if (Character.isLowerCase(localName.charAt(i + 1))) {
                String name = localName.substring(i + 1);

                if (i == -1) {
                    // This is an instance property
                    if (loadListener != null) {
                        loadListener.beginPropertyElement(name, null);
                    }

                    current = new PropertyElement(name, null);
                } else {
                    // This is a static property
                    Class&lt;?&gt; sourceType = getType(localName.substring(0, i));

                    if (sourceType != null) {
                        if (loadListener != null) {
                            loadListener.beginPropertyElement(name, sourceType);
                        }

                        current = new PropertyElement(name, sourceType);
                    } else if (staticLoad) {
                        // The source type was not recognized
                        if (loadListener != null) {
                            loadListener.beginUnknownStaticPropertyElement(localName);
                        }

                        current = new UnknownStaticPropertyElement();
                    } else {
                        throw constructLoadException(localName + &quot; is not a valid property.&quot;);
                    }
                }
            } else {
                if (current == null &amp;&amp; root != null) {
                    throw constructLoadException(&quot;Root value already specified.&quot;);
                }

                Class&lt;?&gt; type = getType(localName);

                if (type != null) {
                    if (loadListener != null) {
                        loadListener.beginInstanceDeclarationElement(type);
                    }

                    current = new InstanceDeclarationElement(type);
                } else if (staticLoad) {
                    // The type was not recognized
                    if (loadListener != null) {
                        loadListener.beginUnknownTypeElement(localName);
                    }

                    current = new UnknownTypeElement();
                } else {
                    throw constructLoadException(localName + &quot; is not a valid type.&quot;);
                }
            }
        } else if (prefix.equals(FX_NAMESPACE_PREFIX)) {
            if (localName.equals(INCLUDE_TAG)) {
                if (loadListener != null) {
                    loadListener.beginIncludeElement();
                }

                current = new IncludeElement();
            } else if (localName.equals(REFERENCE_TAG)) {
                if (loadListener != null) {
                    loadListener.beginReferenceElement();
                }

                current = new ReferenceElement();
            } else if (localName.equals(COPY_TAG)) {
                if (loadListener != null) {
                    loadListener.beginCopyElement();
                }

                current = new CopyElement();
            } else if (localName.equals(ROOT_TAG)) {
                if (loadListener != null) {
                    loadListener.beginRootElement();
                }

                current = new RootElement();
            } else if (localName.equals(SCRIPT_TAG)) {
                if (loadListener != null) {
                    loadListener.beginScriptElement();
                }

                current = new ScriptElement();
            } else if (localName.equals(DEFINE_TAG)) {
                if (loadListener != null) {
                    loadListener.beginDefineElement();
                }

                current = new DefineElement();
            } else {
                throw constructLoadException(prefix + &quot;:&quot; + localName + &quot; is not a valid element.&quot;);
            }
        } else {
            throw constructLoadException(&quot;Unexpected namespace prefix: &quot; + prefix + &quot;.&quot;);
        }
    }

    private void processEndElement() throws IOException {
        current.processEndElement();

        if (loadListener != null) {
            loadListener.endElement(current.value);
        }

        // Move up the stack
        current = current.parent;
    }

    private void processCharacters() throws IOException {
        // Process the characters
        if (!xmlStreamReader.isWhiteSpace()) {
            current.processCharacters();
        }
    }

    private void importPackage(String name) throws LoadException {
        packages.add(name);
    }

    private void importClass(String name) throws LoadException {
        try {
            loadType(name, true);
        } catch (ClassNotFoundException exception) {
            throw constructLoadException(exception);
        }
    }

    private Class&lt;?&gt; getType(String name) throws LoadException {
        Class&lt;?&gt; type = null;

        if (Character.isLowerCase(name.charAt(0))) {
            // This is a fully-qualified class name
            try {
                type = loadType(name, false);
            } catch (ClassNotFoundException exception) {
                // No-op
            }
        } else {
            // This is an unqualified class name
            type = classes.get(name);

            if (type == null) {
                // The class has not been loaded yet; look it up
                for (String packageName : packages) {
                    try {
                        type = loadTypeForPackage(packageName, name);
                    } catch (ClassNotFoundException exception) {
                        // No-op
                    }

                    if (type != null) {
                        break;
                    }
                }

                if (type != null) {
                    classes.put(name, type);
                }
            }
        }

        return type;
    }

    private Class&lt;?&gt; loadType(String name, boolean cache) throws ClassNotFoundException {
        int i = name.indexOf('.');
        int n = name.length();
        while (i != -1
            &amp;&amp; i &lt; n
            &amp;&amp; Character.isLowerCase(name.charAt(i + 1))) {
            i = name.indexOf('.', i + 1);
        }

        if (i == -1 || i == n) {
            throw new ClassNotFoundException();
        }

        String packageName = name.substring(0, i);
        String className = name.substring(i + 1);

        Class&lt;?&gt; type = loadTypeForPackage(packageName, className);

        if (cache) {
            classes.put(className, type);
        }

        return type;
    }

    // TODO Rename to loadType() when deprecated static version is removed
    private Class&lt;?&gt; loadTypeForPackage(String packageName, String className) throws ClassNotFoundException {
        return getClassLoader().loadClass(packageName + &quot;.&quot; + className.replace('.', '$'));
    }

    private static enum SupportedType {
        PARAMETERLESS {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 0;
            }

        },
        EVENT {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        Event.class.isAssignableFrom(m.getParameterTypes()[0]);
            }

        },
        LIST_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        m.getParameterTypes()[0].equals(ListChangeListener.Change.class);
            }

        },
        MAP_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        m.getParameterTypes()[0].equals(MapChangeListener.Change.class);
            }

        },
        SET_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        m.getParameterTypes()[0].equals(SetChangeListener.Change.class);
            }

        },
        PROPERTY_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 3 &amp;&amp;
                        ObservableValue.class.isAssignableFrom(m.getParameterTypes()[0])
                        &amp;&amp; m.getParameterTypes()[1].equals(m.getParameterTypes()[2]);
            }

        };

        protected abstract boolean methodIsOfType(Method m);
    }

    private static SupportedType toSupportedType(Method m) {
        for (SupportedType t : SupportedType.values()) {
            if (t.methodIsOfType(m)) {
                return t;
            }
        }
        return null;
    }

    private ScriptEngineManager getScriptEngineManager() {
        if (scriptEngineManager == null) {
            scriptEngineManager = new javax.script.ScriptEngineManager();
            scriptEngineManager.setBindings(new SimpleBindings(namespace));
        }

        return scriptEngineManager;
    }

    /**
     * Loads a type using the default class loader.
     *
     * @param packageName the package name of the class to load
     * @param className the name of the class to load
     *
     * @throws ClassNotFoundException if the specified class cannot be found
     * @return the class
     *
     * @deprecated
     * This method now delegates to {@link #getDefaultClassLoader()}.
     */
    @Deprecated
    public static Class&lt;?&gt; loadType(String packageName, String className) throws ClassNotFoundException {
        return loadType(packageName + &quot;.&quot; + className.replace('.', '$'));
    }

    /**
     * Loads a type using the default class loader.
     *
     * @param className the name of the class to load
     * @throws ClassNotFoundException if the specified class cannot be found
     * @return the class
     *
     * @deprecated
     * This method now delegates to {@link #getDefaultClassLoader()}.
     */
    @Deprecated
    public static Class&lt;?&gt; loadType(String className) throws ClassNotFoundException {
        ReflectUtil.checkPackageAccess(className);
        return Class.forName(className, true, getDefaultClassLoader());
    }

    private static boolean needsClassLoaderPermissionCheck(Class caller) {
        if (caller == null) {
            return false;
        }
        return !FXMLLoader.class.getModule().equals(caller.getModule());
    }

    private static ClassLoader getDefaultClassLoader(Class caller) {
        if (defaultClassLoader == null) {
            final SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                if (needsClassLoaderPermissionCheck(caller)) {
                    sm.checkPermission(GET_CLASSLOADER_PERMISSION);
                }
            }
            return Thread.currentThread().getContextClassLoader();
        }
        return defaultClassLoader;
    }

    /**
     * Returns the default class loader.
     * @return the default class loader
     * @since JavaFX 2.1
     */
    public static ClassLoader getDefaultClassLoader() {
        final SecurityManager sm = System.getSecurityManager();
        final Class caller = (sm != null) ?
                walker.getCallerClass() :
                null;
        return getDefaultClassLoader(caller);
    }

    /**
     * Sets the default class loader.
     *
     * @param defaultClassLoader
     * The default class loader to use when loading classes.
     * @since JavaFX 2.1
     */
    public static void setDefaultClassLoader(ClassLoader defaultClassLoader) {
        if (defaultClassLoader == null) {
            throw new NullPointerException();
        }
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            sm.checkPermission(MODIFY_FXML_CLASS_LOADER_PERMISSION);
        }

        FXMLLoader.defaultClassLoader = defaultClassLoader;
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public static &lt;T&gt; T load(URL location) throws IOException {
        return loadImpl(location, (System.getSecurityManager() != null)
                                      ? walker.getCallerClass()
                                      : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, Class&lt;?&gt; callerClass)
            throws IOException {
        return loadImpl(location, null, callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources)
                                     throws IOException {
        return loadImpl(location, resources,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  Class&lt;?&gt; callerClass) throws IOException {
        return loadImpl(location, resources,  null,
                        callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used to load the document
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources,
                             BuilderFactory builderFactory)
                                     throws IOException {
        return loadImpl(location, resources, builderFactory,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  BuilderFactory builderFactory,
                                  Class&lt;?&gt; callerClass) throws IOException {
        return loadImpl(location, resources, builderFactory, null, callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used when loading the document
     * @param controllerFactory the controller factory used when loading the document
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     *
     * @since JavaFX 2.1
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources,
                             BuilderFactory builderFactory,
                             Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory)
                                     throws IOException {
        return loadImpl(location, resources, builderFactory, controllerFactory,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  BuilderFactory builderFactory,
                                  Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
                                  Class&lt;?&gt; callerClass) throws IOException {
        return loadImpl(location, resources, builderFactory, controllerFactory,
                        Charset.forName(DEFAULT_CHARSET_NAME), callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used when loading the document
     * @param controllerFactory the controller factory used when loading the document
     * @param charset the character set used when loading the document
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     *
     * @since JavaFX 2.1
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources,
                             BuilderFactory builderFactory,
                             Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
                             Charset charset) throws IOException {
        return loadImpl(location, resources, builderFactory, controllerFactory,
                        charset,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  BuilderFactory builderFactory,
                                  Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
                                  Charset charset, Class&lt;?&gt; callerClass)
                                          throws IOException {
        if (location == null) {
            throw new NullPointerException(&quot;Location is required.&quot;);
        }

        FXMLLoader fxmlLoader =
                new FXMLLoader(location, resources, builderFactory,
                               controllerFactory, charset);

        return fxmlLoader.&lt;T&gt;loadImpl(callerClass);
    }

    /**
     * Utility method for comparing two JavaFX version strings (such as 2.2.5, 8.0.0-ea)
     * @param rtVer String representation of JavaFX runtime version, including - or _ appendix
     * @param nsVer String representation of JavaFX version to compare against runtime version
     * @return number &amp;lt; 0 if runtime version is lower, 0 when both versions are the same,
     *          number &amp;gt; 0 if runtime is higher version
     */
    static int compareJFXVersions(String rtVer, String nsVer) {

        int retVal = 0;

        if (rtVer == null || &quot;&quot;.equals(rtVer) ||
            nsVer == null || &quot;&quot;.equals(nsVer)) {
            return retVal;
        }

        if (rtVer.equals(nsVer)) {
            return retVal;
        }

        // version string can contain '-'
        int dashIndex = rtVer.indexOf(&quot;-&quot;);
        if (dashIndex &gt; 0) {
            rtVer = rtVer.substring(0, dashIndex);
        }

        // or &quot;_&quot;
        int underIndex = rtVer.indexOf(&quot;_&quot;);
        if (underIndex &gt; 0) {
            rtVer = rtVer.substring(0, underIndex);
        }

        // do not try to compare if the string is not valid version format
        if (!Pattern.matches(&quot;^(\\d+)(\\.\\d+)*$&quot;, rtVer) ||
            !Pattern.matches(&quot;^(\\d+)(\\.\\d+)*$&quot;, nsVer)) {
            return retVal;
        }

        StringTokenizer nsVerTokenizer = new StringTokenizer(nsVer, &quot;.&quot;);
        StringTokenizer rtVerTokenizer = new StringTokenizer(rtVer, &quot;.&quot;);
        int nsDigit = 0, rtDigit = 0;
        boolean rtVerEnd = false;

        while (nsVerTokenizer.hasMoreTokens() &amp;&amp; retVal == 0) {
            nsDigit = Integer.parseInt(nsVerTokenizer.nextToken());
            if (rtVerTokenizer.hasMoreTokens()) {
                rtDigit = Integer.parseInt(rtVerTokenizer.nextToken());
                retVal = rtDigit - nsDigit;
            } else {
                rtVerEnd = true;
                break;
            }
        }

        if (rtVerTokenizer.hasMoreTokens() &amp;&amp; retVal == 0) {
            rtDigit = Integer.parseInt(rtVerTokenizer.nextToken());
            if (rtDigit &gt; 0) {
                retVal = 1;
            }
        }

        if (rtVerEnd) {
            if (nsDigit &gt; 0) {
                retVal = -1;
            } else {
                while (nsVerTokenizer.hasMoreTokens()) {
                    nsDigit = Integer.parseInt(nsVerTokenizer.nextToken());
                    if (nsDigit &gt; 0) {
                        retVal = -1;
                        break;
                    }
                }
            }
        }

        return retVal;
    }

    private static void checkClassLoaderPermission() {
        final SecurityManager securityManager = System.getSecurityManager();
        if (securityManager != null) {
            securityManager.checkPermission(MODIFY_FXML_CLASS_LOADER_PERMISSION);
        }
    }

    private final ControllerAccessor controllerAccessor =
            new ControllerAccessor();

    private static final class ControllerAccessor {
        private static final int PUBLIC = 1;
        private static final int PROTECTED = 2;
        private static final int PACKAGE = 4;
        private static final int PRIVATE = 8;
        private static final int INITIAL_CLASS_ACCESS =
                PUBLIC | PROTECTED | PACKAGE | PRIVATE;
        private static final int INITIAL_MEMBER_ACCESS =
                PUBLIC | PROTECTED | PACKAGE | PRIVATE;

        private static final int METHODS = 0;
        private static final int FIELDS = 1;

        private Object controller;
        private ClassLoader callerClassLoader;

        private Map&lt;String, List&lt;Field&gt;&gt; controllerFields;
        private Map&lt;SupportedType, Map&lt;String, Method&gt;&gt; controllerMethods;

        void setController(final Object controller) {
            if (this.controller != controller) {
                this.controller = controller;
                reset();
            }
        }

        void setCallerClass(final Class&lt;?&gt; callerClass) {
            final ClassLoader newCallerClassLoader =
                    (callerClass != null) ? callerClass.getClassLoader()
                                          : null;
            if (callerClassLoader != newCallerClassLoader) {
                callerClassLoader = newCallerClassLoader;
                reset();
            }
        }

        void reset() {
            controllerFields = null;
            controllerMethods = null;
        }

        Map&lt;String, List&lt;Field&gt;&gt; getControllerFields() {
            if (controllerFields == null) {
                controllerFields = new HashMap&lt;&gt;();

                if (callerClassLoader == null) {
                    // allow null class loader only with permission check
                    checkClassLoaderPermission();
                }

                addAccessibleMembers(controller.getClass(),
                                     INITIAL_CLASS_ACCESS,
                                     INITIAL_MEMBER_ACCESS,
                                     FIELDS);
            }

            return controllerFields;
        }

        Map&lt;SupportedType, Map&lt;String, Method&gt;&gt; getControllerMethods() {
            if (controllerMethods == null) {
                controllerMethods = new EnumMap&lt;&gt;(SupportedType.class);
                for (SupportedType t: SupportedType.values()) {
                    controllerMethods.put(t, new HashMap&lt;String, Method&gt;());
                }

                if (callerClassLoader == null) {
                    // allow null class loader only with permission check
                    checkClassLoaderPermission();
                }

                addAccessibleMembers(controller.getClass(),
                                     INITIAL_CLASS_ACCESS,
                                     INITIAL_MEMBER_ACCESS,
                                     METHODS);
            }

            return controllerMethods;
        }

        private void addAccessibleMembers(final Class&lt;?&gt; type,
                                          final int prevAllowedClassAccess,
                                          final int prevAllowedMemberAccess,
                                          final int membersType) {
            if (type == Object.class) {
                return;
            }

            int allowedClassAccess = prevAllowedClassAccess;
            int allowedMemberAccess = prevAllowedMemberAccess;
            if ((callerClassLoader != null)
                    &amp;&amp; (type.getClassLoader() != callerClassLoader)) {
                // restrict further access
                allowedClassAccess &amp;= PUBLIC;
                allowedMemberAccess &amp;= PUBLIC;
            }

            final int classAccess = getAccess(type.getModifiers());
            if ((classAccess &amp; allowedClassAccess) == 0) {
                // we are done
                return;
            }

            ReflectUtil.checkPackageAccess(type);

            addAccessibleMembers(type.getSuperclass(),
                                 allowedClassAccess,
                                 allowedMemberAccess,
                                 membersType);

            final int finalAllowedMemberAccess = allowedMemberAccess;
            AccessController.doPrivileged(
                    new PrivilegedAction&lt;Void&gt;() {
                        @Override
                        public Void run() {
                            if (membersType == FIELDS) {
                                addAccessibleFields(type,
                                                    finalAllowedMemberAccess);
                            } else {
                                addAccessibleMethods(type,
                                                     finalAllowedMemberAccess);
                            }

                            return null;
                        }
                    });
        }

        private void addAccessibleFields(final Class&lt;?&gt; type,
                                         final int allowedMemberAccess) {
            final boolean isPublicType = Modifier.isPublic(type.getModifiers());

            final Field[] fields = type.getDeclaredFields();
            for (int i = 0; i &lt; fields.length; ++i) {
                final Field field = fields[i];
                final int memberModifiers = field.getModifiers();

                if (((memberModifiers &amp; (Modifier.STATIC
                                             | Modifier.FINAL)) != 0)
                        || ((getAccess(memberModifiers) &amp; allowedMemberAccess)
                                == 0)) {
                    continue;
                }

                if (!isPublicType || !Modifier.isPublic(memberModifiers)) {
                    if (field.getAnnotation(FXML.class) == null) {
                        // no fxml annotation on a non-public field
                        continue;
                    }

                    // Ensure that the field is accessible
                    field.setAccessible(true);
                }

                List&lt;Field&gt; list = controllerFields.get(field.getName());
                if (list == null) {
                    list = new ArrayList&lt;&gt;(1);
                    controllerFields.put(field.getName(), list);
                }
                list.add(field);

            }
        }

        private void addAccessibleMethods(final Class&lt;?&gt; type,
                                          final int allowedMemberAccess) {
            final boolean isPublicType = Modifier.isPublic(type.getModifiers());

            final Method[] methods = type.getDeclaredMethods();
            for (int i = 0; i &lt; methods.length; ++i) {
                final Method method = methods[i];
                final int memberModifiers = method.getModifiers();

                if (((memberModifiers &amp; (Modifier.STATIC
                                             | Modifier.NATIVE)) != 0)
                        || ((getAccess(memberModifiers) &amp; allowedMemberAccess)
                                == 0)) {
                    continue;
                }

                if (!isPublicType || !Modifier.isPublic(memberModifiers)) {
                    if (method.getAnnotation(FXML.class) == null) {
                        // no fxml annotation on a non-public method
                        continue;
                    }

                    // Ensure that the method is accessible
                    method.setAccessible(true);
                }

                // Add this method to the map if:
                // a) it is the initialize() method, or
                // b) it takes a single event argument, or
                // c) it takes no arguments and a handler with this
                //    name has not already been defined
                final String methodName = method.getName();
                final SupportedType convertedType;

                if ((convertedType = toSupportedType(method)) != null) {
                    controllerMethods.get(convertedType)
                                     .put(methodName, method);
                }
            }
        }

        private static int getAccess(final int fullModifiers) {
            final int untransformedAccess =
                    fullModifiers &amp; (Modifier.PRIVATE | Modifier.PROTECTED
                                                      | Modifier.PUBLIC);

            switch (untransformedAccess) {
                case Modifier.PUBLIC:
                    return PUBLIC;

                case Modifier.PROTECTED:
                    return PROTECTED;

                case Modifier.PRIVATE:
                    return PRIVATE;

                default:
                    return PACKAGE;
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/events/WindowEvent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.events;

import java.lang.annotation.Native;

public class WindowEvent {
    @Native final static public int RESIZE                = 511;
    @Native final static public int MOVE                  = 512;
    @Native final static public int RESCALE               = 513;

    @Native final static public int CLOSE                 = 521;
    @Native final static public int DESTROY               = 522;

    @Native final static public int MINIMIZE              = 531;
<A NAME="15"></A>    @Native final static public int MAXIMIZE              = 532;
    @Native final static public int RESTORE               = 533;

    <FONT color="#3bb9ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#15',2,'match51-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>@Native final static public int _FOCUS_MIN            = 541;
    @Native final static public int FOCUS_LOST            = 541;
    @Native final static public int FOCUS_GAINED          = 542;
    @Native final static public int FOCUS_GAINED_FORWARD  = 543;
    @Native final static public int FOCUS_GAINED_BACKWARD = 544;
    @Native final static public int _FOCUS_MAX            = 544;

    @Native final static public int FOCUS_DISABLED        = 545;
    @Native final static public int FOCUS_UNGRAB          = 546;

    public stati</B></FONT>c String getEventName(final int eventType) {
        switch(eventType) {
            case WindowEvent.RESIZE:
                return &quot;RESIZE&quot;;
            case WindowEvent.MOVE:
                return &quot;MOVE&quot;;
            case WindowEvent.RESCALE:
                return &quot;RESCALE&quot;;
            case WindowEvent.CLOSE:
                return &quot;CLOSE&quot;;
            case WindowEvent.DESTROY:
                return &quot;DESTROY&quot;;
            case WindowEvent.MINIMIZE:
                return &quot;MINIMIZE&quot;;
            case WindowEvent.MAXIMIZE:
                return &quot;MAXIMIZE&quot;;
            case WindowEvent.RESTORE:
                return &quot;RESTORE&quot;;
            case WindowEvent.FOCUS_LOST:
                return &quot;FOCUS_LOST&quot;;
            case WindowEvent.FOCUS_GAINED:
                return &quot;FOCUS_GAINED&quot;;
            case WindowEvent.FOCUS_GAINED_FORWARD:
                return &quot;FOCUS_GAINED_FORWARD&quot;;
            case WindowEvent.FOCUS_GAINED_BACKWARD:
                return &quot;FOCUS_GAINED_BACKWARD&quot;;
            case WindowEvent.FOCUS_DISABLED:
                return &quot;FOCUS_DISABLED&quot;;
            case WindowEvent.FOCUS_UNGRAB:
                return &quot;FOCUS_UNGRAB&quot;;
            default:
                return &quot;UNKNOWN&quot;;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/GetEvent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="2"></A> * questions.
 */

<FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#2',2,'match51-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.glass.ui.monocle;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/** A test entry point for Monacle to show what events are read from input
 * devices.
 */
class GetEvent {

    private static Set&lt;File&gt; devices = new HashSet&lt;&gt;();

    private static UdevListener udevListener = (action, event) -&gt; {</B></FONT>
        String subsystem = event.get(&quot;SUBSYSTEM&quot;);
        String devPath = event.get(&quot;DEVPATH&quot;);
        if (subsystem != null &amp;&amp; subsystem.equals(&quot;input&quot;)
                &amp;&amp; devPath != null) {

            // show the udev event properties
            System.out.format(&quot;%1$ts.%1$tL Received UEVENT:\n&quot;,
                    new Date());
            List&lt;String&gt; keys = new ArrayList&lt;&gt;(event.keySet());
            Collections.sort(keys);
            for (String key: keys) {
                System.out.format(&quot;  %s='%s'\n&quot;, key, event.get(key));
            }

            // process the event
            try {
                File sysPath = new File(&quot;/sys&quot;, devPath);
                String devNode = event.get(&quot;DEVNAME&quot;);
                if (devNode == null) {
                    return;
                }
                if (action.equals(&quot;add&quot;)
                        || (action.equals(&quot;change&quot;)
                            &amp;&amp; !devices.contains(sysPath))) {
                    LinuxInputDevice device = new LinuxInputDevice(
                            new File(devNode), sysPath, event);
                    device.setInputProcessor(new LinuxInputProcessor.Logger());
                    Thread thread = new Thread(device);
                    thread.setName(devNode.toString());
                    thread.setDaemon(true);
                    thread.start();
                    System.out.println(&quot;Added device &quot; + devNode);
                    System.out.println(&quot;  touch=&quot; + device.isTouch());
                    System.out.println(&quot;  multiTouch=&quot; + device.isMultiTouch());
                    System.out.println(&quot;  relative=&quot; + device.isRelative());
                    System.out.println(&quot;  5-way=&quot; + device.is5Way());
                    System.out.println(&quot;  fullKeyboard=&quot; + device.isFullKeyboard());
                    System.out.println(&quot;  PRODUCT=&quot; + device.getProduct());
                    for (short axis = 0; axis &lt; LinuxInput.ABS_MAX; axis++) {
                        LinuxAbsoluteInputCapabilities caps =
                                device.getAbsoluteInputCapabilities(axis);
                        if (caps != null) {
                            String axisName = LinuxInput.codeToString(&quot;EV_ABS&quot;, axis);
                            System.out.format(&quot;  ABSVAL %s %d\n&quot;,
                                              axisName, caps.getValue());
                            System.out.format(&quot;  ABSMIN %s %d\n&quot;,
                                              axisName, caps.getMinimum());
                            System.out.format(&quot;  ABSMAX %s %d\n&quot;,
                                              axisName, caps.getMaximum());
                            System.out.format(&quot;  ABSFUZZ %s %d\n&quot;,
                                              axisName, caps.getFuzz());
                            System.out.format(&quot;  ABSFLAT %s %d\n&quot;,
                                              axisName, caps.getFlat());
                            System.out.format(&quot;  ABSRES %s %d\n&quot;,
                                              axisName, caps.getResolution());
                        }
                    }
                    devices.add(sysPath);
                } else if (action.equals(&quot;remove&quot;)) {
                    devices.remove(devPath);
                }
            } catch (IOException | RuntimeException e) {
                e.printStackTrace();
            }
        }
    };

    public static void main(String[] argv) throws Exception {
        NativePlatform platform = NativePlatformFactory.getNativePlatform();
        Udev.getInstance().addListener(udevListener);
        // Request updates for existing devices
        SysFS.triggerUdevNotification(&quot;input&quot;);
        new Thread(platform.getRunnableProcessor()).start();
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/MonocleWindowManager.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="10"></A> * questions.
 */

<FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#10',2,'match51-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.glass.ui.monocle;

import com.sun.glass.events.WindowEvent;
import com.sun.glass.ui.Screen;
import com.sun.javafx.tk.Toolkit;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javafx.application.Platform;

final class MonocleWindowManager {

    private static MonocleWindowManager instance = new MonocleWindowManager();

    /** The window stack. Windows are in Z-order, from back to front. */
    private MonocleWindow[] windows = new MonocleWindow[0]</B></FONT>;
    private int nextID = 1;

    private MonocleWindow focusedWindow = null;

    private MonocleWindowManager() {
        //singleton
    }

    static MonocleWindowManager getInstance() {
        return instance;
    }

    private int getWindowIndex(MonocleWindow window) {
        for (int i = 0; i &lt; windows.length; i++) {
            // Any two MonocleWindow objects represent different windows, so
            // equality can be determined by reference comparison.
            if (windows[i] == window) {
                return i;
            }
        }
        return -1;
    }
    void toBack(MonocleWindow window) {
        int index = getWindowIndex(window);
        if (index != 0 &amp;&amp; index != -1) {
            System.arraycopy(windows, 0, windows, 1, index);
            windows[0] = window;
        }
    }

    void toFront(MonocleWindow window) {
        int index = getWindowIndex(window);
        if (index != windows.length - 1 &amp;&amp; index != -1) {
            System.arraycopy(windows, index + 1, windows, index,
                             windows.length - index - 1);
            windows[windows.length - 1] = window;
        }
    }

    int addWindow(MonocleWindow window) {
        int index = getWindowIndex(window);
        if (index == -1) {
            windows = Arrays.copyOf(windows, windows.length + 1);
            windows[windows.length - 1] = window;
        }
        return nextID++;

    }

    boolean closeWindow(MonocleWindow window) {
        int index = getWindowIndex(window);
        if (index != -1) {
            System.arraycopy(windows, index + 1, windows, index,
                             windows.length - index - 1);
            windows = Arrays.copyOf(windows, windows.length - 1);
        }
        List&lt;MonocleWindow&gt; windowsToNotify = new ArrayList&lt;MonocleWindow&gt;();
        for (MonocleWindow otherWindow : windows) {
            if (otherWindow.getOwner() == window) {
                windowsToNotify.add(otherWindow);
            }
        }
        for (int i = 0; i &lt; windowsToNotify.size(); i++) {
            windowsToNotify.get(i).notifyClose();
        }
        window.notifyDestroy();
        return true;

    }

    boolean minimizeWindow(MonocleWindow window) {
        return true;
    }

    boolean maximizeWindow(MonocleWindow window) {
        return true;
    }

    boolean requestFocus(MonocleWindow window) {
        int index = getWindowIndex(window);
        if (index != -1) {
            focusedWindow = window;
            window.notifyFocus(WindowEvent.FOCUS_GAINED);
            return true;
        } else {
            return false;
        }
    }

    boolean grabFocus(MonocleWindow window) {
        return true;
    }

    void ungrabFocus(MonocleWindow window) {

    }

    MonocleWindow getWindowForLocation(int x, int y) {
        for (int i = windows.length - 1; i &gt;=0 ; i--) {
            MonocleWindow w = windows[i];
            if (x &gt;= w.getX() &amp;&amp; y &gt;= w.getY()
                   &amp;&amp; x &lt; w.getX() + w.getWidth()
                   &amp;&amp; y &lt; w.getY() + w.getHeight()
                   &amp;&amp; w.isEnabled()) {
                return w;
            }
        }
        return null;
    }

    void notifyFocusDisabled(MonocleWindow window) {
        if (window != null) {
            window._notifyFocusDisabled();
        }
    }

    MonocleWindow getFocusedWindow() {
        return focusedWindow;
    }

    void repaintAll() {
        for (int i = 0; i &lt; windows.length; i++) {
            MonocleView view = (MonocleView) windows[i].getView();
            if (view != null) {
                view.notifyRepaint();
            }
        }
    }

    static void repaintFromNative () {
        Platform.runLater(new Runnable () {

            @Override
            public void run() {
                Screen.notifySettingsChanged();
                instance.getFocusedWindow().setFullScreen(true);
                instance.repaintAll();
                Toolkit.getToolkit().requestNextPulse();
            }
        });
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/OMAPCursor.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.glass.ui.monocle;

import com.sun.glass.ui.Size;

import java.io.IOException;
import java.nio.Buffer;
import java.nio.ByteBuffer;

/** Cursor using a framebuffer overlay on OMAP3.
 * TODO: Can we mmap the image and location files?
 */
class OMAPCursor extends NativeCursor {

    private int hotspotX;
    private int hotspotY;
    private int offsetX;
    private int offsetY;
    private int cursorX;
    private int cursorY;
    private static final int INT_KEY = 0x12121212;
    private static final int SHORT_KEY = 0xABAB;
    private static final int CURSOR_WIDTH = 16;
    private static final int CURSOR_HEIGHT = 16;
    private Buffer cursorBuffer;
    private Buffer offsetCursorBuffer;
    private byte[] offsetCursor;
    private int screenWidth;
    private int screenHeight;
    private int cursorDepth;
    private int transparentPixel;

    OMAPCursor() {
        try {
            SysFS.write(&quot;/sys/class/graphics/fb1/virtual_size&quot;, &quot;16,16&quot;);
            SysFS.write(&quot;/sys/devices/platform/omapdss/overlay1/output_size&quot;, &quot;16,16&quot;);
            SysFS.write(&quot;/sys/devices/platform/omapdss/manager0/trans_key_enabled&quot;,
                        &quot;1&quot;);
            SysFS.write(&quot;/sys/devices/platform/omapdss/manager0/trans_key_type&quot;,
                        &quot;video-source&quot;);
            cursorDepth = SysFS.readInt(&quot;/sys/class/graphics/fb1/bits_per_pixel&quot;);
            switch (cursorDepth) {
                case 16:
                    transparentPixel = SHORT_KEY;
                    break;
                case 32:
                    transparentPixel = INT_KEY;
                    break;
                default:
                    throw new IOException(
                            &quot;Cannot use an OMAP cursor with a bit depth of &quot;
                            + cursorDepth);
            }
            SysFS.write(&quot;/sys/devices/platform/omapdss/manager0/trans_key_value&quot;,
                        Long.toString(transparentPixel));
        } catch (IOException e) {
            e.printStackTrace();
            System.err.println(&quot;Failed to initialize OMAP cursor&quot;);
        }
        NativeScreen screen = NativePlatformFactory.getNativePlatform().getScreen();
        screenWidth = screen.getWidth();
        screenHeight = screen.getHeight();
    }

    @Override
    Size getBestSize() {
        return new Size(CURSOR_WIDTH, CURSOR_HEIGHT);
    }

    @Override
    void setVisibility(boolean visibility) {
        try {
            SysFS.write(&quot;/sys/devices/platform/omapdss/overlay1/enabled&quot;,
                        visibility ? &quot;1&quot; : &quot;0&quot;);
        } catch (IOException e) {
            System.err.format(&quot;Failed to %s OMAP cursor\n&quot;,
                              (visibility ? &quot;enable&quot; : &quot;disable&quot;));
        }
        isVisible = visibility;
    }

    private void updateImage(boolean always) {
        int newOffsetX, newOffsetY;
        newOffsetX = Math.max(0, CURSOR_WIDTH + cursorX - screenWidth);
        newOffsetY = Math.max(0, CURSOR_HEIGHT + cursorY - screenHeight);
        if (newOffsetX != offsetX || newOffsetY != offsetY || always) {
            NativeCursors.offsetCursor(cursorBuffer, offsetCursorBuffer,
                                       newOffsetX, newOffsetY,
                                       CURSOR_WIDTH, CURSOR_HEIGHT,
                                       cursorDepth, transparentPixel);
            offsetX = newOffsetX;
            offsetY = newOffsetY;
            try {
                SysFS.write(&quot;/dev/fb1&quot;, offsetCursor);
            } catch (IOException e) {
                System.err.println(&quot;Failed to write OMAP cursor image&quot;);
            }
        }
    }

    @Override
    void setImage(byte[] cursorImage) {
        // Convert the cursor to the color-keyed format
        ByteBuffer bb = ByteBuffer.allocate(cursorImage.length);
        cursorBuffer = cursorDepth == 32 ? bb.asIntBuffer() : bb.asShortBuffer();
        NativeCursors.colorKeyCursor(cursorImage, cursorBuffer,
                                     cursorDepth, transparentPixel);
        // Create an offset version of the cursor for rendering
        offsetCursor = new byte[cursorImage.length];
        bb = ByteBuffer.wrap(offsetCursor);
        offsetCursorBuffer = cursorDepth == 32 ? bb.asIntBuffer() : bb.asShortBuffer();
        updateImage(true);
    }

    @Override
<A NAME="20"></A>    void setLocation(int x, int y) {
        cursorX = x;
        cursorY = y;
        <FONT color="#d4a017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#20',2,'match51-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>updateImage(false);
        try {
            SysFS.write(&quot;/sys/devices/platform/omapdss/overlay1/position&quot;,
                        (cursorX - hotspotX - offsetX)
                        + &quot;,&quot; + (cursorY - hotspotY - offsetY));
        } catch (IOException e) {
            System.err.println(&quot;Failed to set OMAP cursor position&quot;);
        }
    }

    @Override</B></FONT>
    void setHotSpot(int hotspotX, int hotspotY) {
        this.hotspotX = hotspotX;
        this.hotspotY = hotspotY;
    }

    @Override
    void shutdown() {
        try {
            SysFS.write(&quot;/sys/devices/platform/omapdss/overlay1/enabled&quot;, &quot;0&quot;);
        } catch (IOException e) {
            System.err.println(&quot;Failed to shut down OMAP cursor&quot;);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/geom/DirtyRegionContainer.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.geom;

import java.util.Arrays;

/**
 * Container for array of dirty regions. This container internally holds
 * pointer to the first empty dirty region in the array and index of last
 * modified dirty region. It also introduces convenient methods to modify
 * the array of dirty regions.
 */
public final class DirtyRegionContainer {

    public static final int DTR_OK = 1;
    public static final int DTR_CONTAINS_CLIP = 0;

    private RectBounds[] dirtyRegions;
    private int emptyIndex;

    public DirtyRegionContainer(int count) {
        initDirtyRegions(count);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof DirtyRegionContainer) {
            DirtyRegionContainer drc = (DirtyRegionContainer)obj;
            if (size() != drc.size()) return false;
            for(int i = 0; i &lt; emptyIndex; i++) {
                if (!getDirtyRegion(i).equals(drc.getDirtyRegion(i))) return false;
            }
            return true;
        }
        return false;
    }

    @Override
    public int hashCode() {
        int hash = 5;
        hash = 97 * hash + Arrays.deepHashCode(this.dirtyRegions);
        hash = 97 * hash + this.emptyIndex;
        return hash;
    }

    public DirtyRegionContainer deriveWithNewRegion(RectBounds region) {
        if (region == null) {
            return this;
        }
        dirtyRegions[0].deriveWithNewBounds(region);
        emptyIndex = 1;
        return this;
    }

    public DirtyRegionContainer deriveWithNewRegions(RectBounds[] regions) {
        if (regions == null ||
            regions.length == 0) {

            return this;
        }
        if (regions.length &gt; maxSpace()) {
            initDirtyRegions(regions.length);
        }

        regioncopy(regions, 0, dirtyRegions, 0, regions.length);
        emptyIndex = regions.length;
        return this;
    }

    public DirtyRegionContainer deriveWithNewContainer(DirtyRegionContainer other) {
        if (other == null ||
            other.maxSpace() == 0) {

            return this;
        }

        if (other.maxSpace() &gt; maxSpace()) {
            initDirtyRegions(other.maxSpace());
        }

        regioncopy(other.dirtyRegions, 0, dirtyRegions, 0, other.emptyIndex);
        emptyIndex = other.emptyIndex;
        return this;
    }

    private void initDirtyRegions(int count) {
        dirtyRegions = new RectBounds[count];
        for (int i = 0; i &lt; count; i++) {
            dirtyRegions[i] = new RectBounds();
        }
        emptyIndex = 0;
    }

    public DirtyRegionContainer copy() {
        DirtyRegionContainer drc = new DirtyRegionContainer(maxSpace());
        regioncopy(dirtyRegions, 0, drc.dirtyRegions, 0, emptyIndex);
        drc.emptyIndex = emptyIndex;
        return drc;
    }

    public int maxSpace() {
        return dirtyRegions.length;
    }

    /**
     * Gets the dirty region at given index.
     * @param index the index of requested dirty region
     * @return dirty region at given index
     */
    public RectBounds getDirtyRegion(int index) {
        return dirtyRegions[index];
    }

    public void setDirtyRegion(int index, RectBounds region) {
        dirtyRegions[index] = region;
    }

    /**
     * Adds new dirty region to the array.
     * @param region the dirty region.
     */
    public void addDirtyRegion(final RectBounds region) {
            if (region.isEmpty())
                return;

            RectBounds dr, tmp;
            int tempIndex = 0;
            int regionCount = emptyIndex;

            for(int i = 0; i &lt; regionCount; i++) {
                //can't have overlapping regions
                dr = dirtyRegions[tempIndex];
                if (region.intersects(dr)) {
                    region.unionWith(dr);
                    tmp = dirtyRegions[tempIndex];
                    dirtyRegions[tempIndex] = dirtyRegions[emptyIndex - 1];
                    dirtyRegions[emptyIndex - 1] = tmp;
                    emptyIndex--;
                } else {
                    tempIndex++;
                }
            }//for
            if (hasSpace()) {
                dr = dirtyRegions[emptyIndex];
                dr.deriveWithNewBounds(region);
                emptyIndex++;
                return;
            }
            //match region into existing dirty regions
            if (dirtyRegions.length == 1)
                dirtyRegions[0].deriveWithUnion(region);
            else
                compress(region);
    }

    public void merge(DirtyRegionContainer other) {
        int otherSize = other.size();
        for(int i = 0; i &lt; otherSize; i++) {
            addDirtyRegion(other.getDirtyRegion(i));
        }
    }

    public int size() {
        return emptyIndex;
    }

    public void reset() {
        emptyIndex = 0;
    }

    private RectBounds compress(final RectBounds region) {
        compress_heap();
        addDirtyRegion(region);
        return region;
    }

    /**
     * If there are empty regions in the dirty regions array.
     * @return true if there is empty region in the array; false otherwise
     */
    private boolean hasSpace() {
        return emptyIndex &lt; dirtyRegions.length;
    }

    private void regioncopy(RectBounds[] src, int from, RectBounds[] dest, int to, int length) {
        RectBounds rb;
        for (int i = 0; i &lt; length; i++) {
            rb = src[from++];
            if (rb == null) {
                dest[to++].makeEmpty();
            } else {
                dest[to++].deriveWithNewBounds(rb);
            }
        }
    }

    public boolean checkAndClearRegion(int index) {
        boolean removed = false;
        if (dirtyRegions[index].isEmpty()) {
            System.arraycopy(dirtyRegions, index + 1, dirtyRegions, index, emptyIndex - index - 1);
            --emptyIndex;
            removed = true;
        }

        return removed;
    }

    public void grow(int horizontal, int vertical) {
        if (horizontal != 0 || vertical != 0) {
            for (int i = 0; i &lt; emptyIndex; i++) {
                getDirtyRegion(i).grow(horizontal, vertical);
            }
        }
    }

    public void roundOut() {
        for (int i = 0; i &lt; emptyIndex; ++i) {
            dirtyRegions[i].roundOut();
        }
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; emptyIndex; i++) {
            sb.append(dirtyRegions[i]);
            sb.append('\n');
        }
        return sb.toString();
    }

    /***************************************************************************
     * Shared for all compressing algorithms
     ***************************************************************************/
    private int[][] heap; // heap used for compressing dirty regions
    private int heapSize;
    private long invalidMask;

    private void heapCompress() {
        invalidMask = 0;
        int[] map = new int[dirtyRegions.length];
        for (int i = 0; i &lt; map.length; ++i) {
            map[i] = i;
        }

        int[] min;
        for (int i = 0; i &lt; dirtyRegions.length / 2; ++i) { //compress to 1/2
            min = takeMinWithMap(map);
            int idx0 = resolveMap(map, min[1]);
            int idx1 = resolveMap(map, min[2]);
            if (idx0 != idx1) {
                dirtyRegions[idx0].deriveWithUnion(dirtyRegions[idx1]);
                map[idx1] = idx0;
                invalidMask |= 1 &lt;&lt; idx0;
                invalidMask |= 1 &lt;&lt; idx1;
            }
        }

        // move the unused regions to the end
        RectBounds tmp;
        for (int i = 0; i &lt; emptyIndex; ++i) {
            if (map[i] != i) {
                while(map[emptyIndex - 1] != emptyIndex - 1 ) --emptyIndex;
                if (i &lt; emptyIndex - 1) {
                    tmp = dirtyRegions[emptyIndex - 1];
                    dirtyRegions[emptyIndex - 1] = dirtyRegions[i];
                    dirtyRegions[i] = tmp;
                    map[i] = i; // indicate that this element is OK
                    --emptyIndex;
<A NAME="31"></A>                }
            }
        }
    <FONT color="#3ea99f"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#31',2,'match51-top.html#31',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    private void heapify() {
        for (int i = heapSize / 2; i &gt;= 0; --i) {
            siftDown(i);
        }
    }

    private void siftDown(int i) {
        int end = heapSize &gt;&gt; 1</B></FONT>;
        int[] temp;
        while (i &lt; end) {
            int child = (i &lt;&lt; 1) + 1;
            int[] left = heap[child];
            if (child + 1 &lt; heapSize &amp;&amp; heap[child + 1][0] &lt; left[0]) {
                child = child + 1;
            }
            if (heap[child][0] &gt;= heap[i][0]) {
                break;
            }
            temp = heap[child];
            heap[child] = heap[i];
            heap[i] = temp;
            i = child;
        }
    }

    private int[] takeMinWithMap(int[] map) {
        int[] temp = heap[0];

        // Check if the minimum element wasn't computed with some already merged region
        // If so, we can recompute it and push it down (as the new merged region can be
        // only greater than the original region)
        while (((1 &lt;&lt; temp[1] | 1 &lt;&lt; temp[2]) &amp; invalidMask) &gt; 0) {
            temp[0] = unifiedRegionArea(resolveMap(map, temp[1]), resolveMap(map, temp[2]));
            siftDown(0);
            if (heap[0] == temp) {
                break;
            }
            temp = heap[0];
        }

        heap[heapSize - 1] = temp;
        siftDown(0);
        heapSize--;
        return temp;
    }

    private int[] takeMin() {
        int[] temp = heap[0];
        heap[0] = heap[heapSize - 1];
        heap[heapSize - 1] = temp;
        siftDown(0);
        heapSize--;
        return temp;
    }

    private int resolveMap(int[] map, int idx) {
        while(map[idx] != idx) idx = map[idx];
        return idx;
    }

    private int unifiedRegionArea(int i0, int i1) {
        RectBounds r0 = dirtyRegions[i0];
        RectBounds r1 = dirtyRegions[i1];
        float minX, minY, maxX, maxY;
        minX = r0.getMinX() &lt; r1.getMinX() ? r0.getMinX() : r1.getMinX();
        minY = r0.getMinY() &lt; r1.getMinY() ? r0.getMinY() : r1.getMinY();
        maxX = r0.getMaxX() &gt; r1.getMaxX() ? r0.getMaxX() : r1.getMaxX();
        maxY = r0.getMaxY() &gt; r1.getMaxY() ? r0.getMaxY() : r1.getMaxY();

        return (int) ((maxX - minX) * (maxY - minY));
    }
    /***************************************************************************
     * Heap-based compressing algorithm
     ***************************************************************************/

    private void compress_heap() {
        assert dirtyRegions.length == emptyIndex; // call only when there is no space left
        if (heap == null) {
            int n = dirtyRegions.length;
            heap = new int[n * (n-1) / 2][3];
        }
        heapSize = heap.length;
        int k = 0;
        for (int i = 0; i &lt; dirtyRegions.length - 1; ++i) {
            for (int j = i + 1; j &lt; dirtyRegions.length; ++j) {
                heap[k][0] = unifiedRegionArea(i, j);
                heap[k][1] = i;
                heap[k++][2] = j;
            }
        }
        heapify();
        heapCompress();
    }

    /***************************************************************************
     * Simple Monte-Carlo variant of compressing algorithm
     ***************************************************************************/

//    private void compress_mc() {
//        assert dirtyRegions.length == emptyIndex; // call only when there is no space left
//        heapSize = dirtyRegions.length;
//        if (heap == null) {
//            heap = new int[heapSize][3];
//        }
//        for (int i = 0; i &lt; heapSize; ++i) { //number of tries
//            int i0 = random(dirtyRegions.length);
//            int i1 = random(dirtyRegions.length);
//            if (i1 == i0) i1 = (i0 + random(dirtyRegions.length / 2) + 1) % dirtyRegions.length;
//            heap[i][0] = unifiedRegionArea(i0, i1);
//            heap[i][1] = i0;
//            heap[i][2] = i1;
//        }
//        heapify();
//        heapCompress();
//    }
//
//    private static long rnd = System.currentTimeMillis();
//    // XOR Random generator by George Marsaglia http://www.jstatsoft.org/v08/i14/
//    // The LCG algorithm of Random() has an upleasant trait that the numbers generated in
//    // pairs always have some (tight) mathematical relationship
//    private int random(int n) {
//        rnd ^= (rnd &lt;&lt; 21);
//        rnd ^= (rnd &gt;&gt;&gt; 35);
//        rnd ^= (rnd &lt;&lt; 4);
//        return (int) ((rnd) % n + n) % n;     // the problem with this algorithm is that 0 is never produced.
//                                              // Given it's independed probability for every bit, we can safely do % n here
//    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/sg/prism/NodeEffectInput.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.sg.prism;

import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.DirtyRegionContainer;
import com.sun.javafx.geom.DirtyRegionPool;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.prism.Graphics;
import com.sun.scenario.effect.Effect;
import com.sun.scenario.effect.FilterContext;
import com.sun.scenario.effect.ImageData;
import com.sun.scenario.effect.impl.prism.PrDrawable;
import com.sun.scenario.effect.impl.prism.PrRenderInfo;

/**
 */
public final class NodeEffectInput extends Effect {
    public static enum RenderType {
        EFFECT_CONTENT,
        CLIPPED_CONTENT,
        FULL_CONTENT,
    };

    private NGNode node;
    private RenderType renderType;
    private BaseBounds tempBounds = new RectBounds();

    private ImageData cachedIdentityImageData;
    private ImageData cachedTransformedImageData;
    private BaseTransform cachedTransform;

    public NodeEffectInput(NGNode node) {
        this(node, RenderType.EFFECT_CONTENT);
    }

    public NodeEffectInput(NGNode node, RenderType renderType) {
        this.node = node;
        this.renderType = renderType;
    }

    public NGNode getNode() {
        return node;
    }

    public void setNode(NGNode node) {
        if (this.node != node) {
            this.node = node;
            flush();
        }
    }

    static boolean contains(ImageData cachedImage, Rectangle imgbounds) {
        // We only cache ImageData objects with Identity transforms installed...
        Rectangle cachedBounds = cachedImage.getUntransformedBounds();
        return cachedBounds.contains(imgbounds);
    }

    @Override
    public BaseBounds getBounds(BaseTransform transform,
                              Effect defaultInput)
    {
        // TODO: update Effect.getBounds() to take Rectangle2D param so
        // that we can avoid creating garbage here? (RT-23958)
        BaseTransform t = transform == null ?
                BaseTransform.IDENTITY_TRANSFORM : transform;
        tempBounds = node.getContentBounds(tempBounds, t);
        return tempBounds.copy();
    }

    @Override
    public ImageData filter(FilterContext fctx,
                            BaseTransform transform,
                            Rectangle outputClip,
                            Object renderHelper,
                            Effect defaultInput)
    {
        if (renderHelper instanceof PrRenderInfo) {
            Graphics g = ((PrRenderInfo) renderHelper).getGraphics();
            if (g != null) {
                render(g, transform);
                return null;
            }
        }
        Rectangle bounds =
            getImageBoundsForNode(node, renderType, transform, outputClip);
        if (transform.isIdentity()) {
            if (cachedIdentityImageData != null &amp;&amp;
                contains(cachedIdentityImageData, bounds) &amp;&amp;
                cachedIdentityImageData.validate(fctx))
            {
                cachedIdentityImageData.addref();
                return cachedIdentityImageData;
            }
        } else if (cachedTransformedImageData != null &amp;&amp;
                   contains(cachedTransformedImageData, bounds) &amp;&amp;
                   cachedTransformedImageData.validate(fctx) &amp;&amp;
                   cachedTransform.equals(transform))
        {
            cachedTransformedImageData.addref();
            return cachedTransformedImageData;
        }
        // this ImageData will be validated by whoever uses the result of this
        // filter operation
        ImageData retData =
            getImageDataForBoundedNode(fctx, node, renderType, transform, bounds);
        if (transform.isIdentity()) {
            flushIdentityImage();
            cachedIdentityImageData = retData;
            cachedIdentityImageData.addref();
        } else {
            flushTransformedImage();
            cachedTransform = transform.copy();
            cachedTransformedImageData = retData;
            cachedTransformedImageData.addref();
        }
        return retData;
    }

    @Override
    public AccelType getAccelType(FilterContext fctx) {
        return AccelType.INTRINSIC;
    }

    public void flushIdentityImage() {
        if (cachedIdentityImageData != null) {
            cachedIdentityImageData.unref();
            cachedIdentityImageData = null;
        }
    }

    public void flushTransformedImage() {
        if (cachedTransformedImageData != null) {
            cachedTransformedImageData.unref();
            cachedTransformedImageData = null;
        }
        cachedTransform = null;
    }

    public void flush() {
        flushIdentityImage();
        flushTransformedImage();
    }

    public void render(Graphics g, BaseTransform transform) {
        BaseTransform savetx = null;
        if (!transform.isIdentity()) {
            savetx = g.getTransformNoClone().copy();
            g.transform(transform);
        }
        node.renderContent(g);
        if (savetx != null) {
            g.setTransform(savetx);
        }
    }

    static ImageData getImageDataForNode(FilterContext fctx,
                                         NGNode node, boolean contentOnly,
                                         BaseTransform transform,
                                         Rectangle clip)
    {
        RenderType rendertype = contentOnly
                ? RenderType.EFFECT_CONTENT
                : RenderType.FULL_CONTENT;
        Rectangle r = getImageBoundsForNode(node, rendertype, transform, clip);
        return getImageDataForBoundedNode(fctx, node, rendertype, transform, r);
    }

    static Rectangle getImageBoundsForNode(NGNode node, RenderType type,
                                           BaseTransform transform,
                                           Rectangle clip)
<A NAME="24"></A>    {
        BaseBounds bounds = new RectBounds();
        switch (type) {
            <FONT color="#ada96e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#24',2,'match51-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>case EFFECT_CONTENT:
                bounds = node.getContentBounds(bounds, transform);
                break;
            case FULL_CONTENT:
                bounds = node.getCompleteBounds(bounds, transform);
                break;
            case CLIPPED_CONTENT:
                bounds = node.getClippedBounds(bounds, transform);
                break;
        }</B></FONT>
        Rectangle r = new Rectangle(bounds);
        if (clip != null) {
            r.intersectWith(clip);
        }
        return r;
    }

    /**
     * bounds parameter must be a non-static unshared object which can be
     * saved in the returned ImageData object.
     */
    private static ImageData
        getImageDataForBoundedNode(FilterContext fctx,
                                   NGNode node, RenderType renderType,
                                   BaseTransform transform,
                                   Rectangle bounds)
    {
        PrDrawable ret = (PrDrawable)
            Effect.getCompatibleImage(fctx, bounds.width, bounds.height);
        if (ret != null) {
            Graphics g = ret.createGraphics();
            g.translate(-bounds.x, -bounds.y);
            if (transform != null) {
                g.transform(transform);
            }
            switch (renderType) {
                case EFFECT_CONTENT:
                    node.renderContent(g);
                    break;
                case FULL_CONTENT:
                    node.render(g);
                    break;
                case CLIPPED_CONTENT:
                    node.renderForClip(g);
                    break;
            }
        }
        return new ImageData(fctx, ret, bounds);
    }

    @Override
    public boolean reducesOpaquePixels() {
        return false;
    }

    @Override
    public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
        return null; // Never called
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/es2/X11GLDrawable.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.es2;


class X11GLDrawable extends GLDrawable {

    private static native long nCreateDrawable(long nativeWindow, long nativeCtxInfo);
    private static native long nGetDummyDrawable(long nativeCtxInfo);
    private static native boolean nSwapBuffers(long nativeDInfo);

    X11GLDrawable(GLPixelFormat pixelFormat) {
<A NAME="30"></A>
        super(0L, pixelFormat);
        long nDInfo = nGetDummyDrawable(pixelFormat.getNativePFInfo());
        <FONT color="#f9966b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#30',2,'match51-top.html#30',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>setNativeDrawableInfo(nDInfo);
    }

    X11GLDrawable(long nativeWindow, GLPixelFormat pixelFormat) {
        super(nativeWindow, pixelFormat);
        long nDInfo = nCreateDrawable(nativeWindow, pixelFormat.getNativePFInfo</B></FONT>());
        setNativeDrawableInfo(nDInfo);
    }

    @Override
    boolean swapBuffers(GLContext glCtx) {
        return nSwapBuffers(getNativeDrawableInfo());
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/impl/ps/CachingShapeRep.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.impl.ps;

import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.prism.BasicStroke;
import com.sun.prism.Graphics;
import com.sun.prism.Texture;
import com.sun.prism.Texture.WrapMode;
import com.sun.prism.paint.Paint;
import com.sun.prism.shape.ShapeRep;
import com.sun.prism.impl.Disposer;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.impl.VertexBuffer;
import com.sun.prism.impl.ps.BaseShaderContext.MaskType;
import com.sun.prism.impl.shape.ShapeUtil;
import com.sun.prism.impl.shape.MaskData;
import com.sun.prism.ps.Shader;
import java.util.Arrays;
import java.util.Comparator;

/**
 * An implementation of ShapeRep that attempts to cache and reuse the
 * mask texture that is used to render the filled/stroked geometry.
 * There is an artificial cap on the size of shapes that are considered
 * for caching, so that we do not fill up VRAM with lots of large shape
 * masks.  The shape is considered for caching only when it is rendered
 * a certain number of times with unchanging transform (ignoring the
 * translation components) and geometry.  This means that this class is
 * good for caching static shapes that are either completely stationary
 * or being translated.  This class will also attempt to reuse a mask
 * that corresponds to a completely different shape instance as long as
 * the two shapes are equal and the transforms only differ by their
 * translation components.  This means that if you have 1000 Path nodes
 * all with exactly the same geometry but with different translation factors,
 * then we will only rasterize and cache a single mask texture and reuse
 * it among all the Path nodes.
 *
 * (Of course, the fact that we reuse the same mask texture for different
 * sub-pixel translation factors means we're knowingly being a bit sloppy,
 * so when caching is enabled you may see some dancing at the shape edges
 * for slowly animating translations, but otherwise will hopefully not be
 * too noticeable.)
 *
 * The current implementation limits the size of the cache (512 pixels in
 * each dimension, and 4 MB in total) so that it doesn't grow without bound.
 * Space is granted on a first come first served basis.
 */
public class CachingShapeRep implements ShapeRep {

    private CachingShapeRepState fillState;
    private CachingShapeRepState drawState;

    public CachingShapeRep() {
    }

    CachingShapeRepState createState() {
        return new CachingShapeRepState();
    }

    public boolean is3DCapable() {
        return false;
    }

    public void invalidate(InvalidationType type) {
        // NOTE: for now we invalidate for any location or geometry change;
        // should consider allowing certain location changes...
        if (fillState != null) {
            fillState.invalidate();
        }
        if (drawState != null) {
            drawState.invalidate();
        }
    }

    public void fill(Graphics g, Shape shape, BaseBounds bounds) {
        if (fillState == null) {
            fillState = createState();
        }
        fillState.render(g, shape, (RectBounds) bounds, null);
    }

    public void draw(Graphics g, Shape shape, BaseBounds bounds) {
        if (drawState == null) {
            drawState = createState();
        }
        drawState.render(g, shape,(RectBounds) bounds, g.getStroke());
    }

    public void dispose() {
        if (fillState != null) {
            fillState.dispose();
            fillState = null;
        }
        if (drawState != null) {
            drawState.dispose();
            drawState = null;
        }
    }
}

class CachingShapeRepState {

    private static class MaskTexData {
        private CacheEntry cacheEntry;
        private Texture maskTex;
        private float maskX;
        private float maskY;
        private int maskW;
        private int maskH;

        void adjustOrigin(BaseTransform xform) {
            float dx = (float)(xform.getMxt()-cacheEntry.xform.getMxt());
            float dy = (float)(xform.getMyt()-cacheEntry.xform.getMyt());
            this.maskX = cacheEntry.texData.maskX + dx;
            this.maskY = cacheEntry.texData.maskY + dy;
        }

        MaskTexData copy() {
            MaskTexData data = new MaskTexData();
            data.cacheEntry = this.cacheEntry;
            data.maskTex = this.maskTex;
            data.maskX = this.maskX;
            data.maskY = this.maskY;
            data.maskW = this.maskW;
            data.maskH = this.maskH;
            return data;
        }

        void copyInto(MaskTexData other) {
            if (other == null) {
                throw new InternalError(&quot;MaskTexData must be non-null&quot;);
            }
            other.cacheEntry = this.cacheEntry;
            other.maskTex = this.maskTex;
            other.maskX = this.maskX;
            other.maskY = this.maskY;
            other.maskW = this.maskW;
            other.maskH = this.maskH;
        }
    }

    private static class CacheEntry {
        Shape shape;
        BasicStroke stroke;
        BaseTransform xform;
        RectBounds xformBounds;
        MaskTexData texData;
        boolean antialiasedShape;
        int refCount;
    }

    private static class MaskCache {
        private static final int MAX_MASK_DIM = 512;
        private static final int MAX_SIZE_IN_PIXELS = 4194304; // 4 MB
        private static Comparator&lt;CacheEntry&gt; comparator = (o1, o2) -&gt; {
            int widthCompare = Float.compare(o1.xformBounds.getWidth(), o2.xformBounds.getWidth());
            if (widthCompare != 0) {
                return widthCompare;
            }
            return Float.compare(o1.xformBounds.getHeight(), o2.xformBounds.getHeight());
        };

        private CacheEntry[] entries = new CacheEntry[8];
        private int entriesSize = 0;
        private int totalPixels;

        private CacheEntry tmpKey = new CacheEntry();
        {
            tmpKey.xformBounds = new RectBounds();
        }

        private void ensureSize(int size) {
            if (entries.length &lt; size) {
                CacheEntry[] newEntries = new CacheEntry[size * 3 / 2];
                System.arraycopy(entries, 0, newEntries, 0, entries.length);
                entries = newEntries;
            }
        }

        private void addEntry(CacheEntry entry) {
            ensureSize(entriesSize + 1);
            int pos = Arrays.binarySearch(entries, 0, entriesSize, entry, comparator);
            if (pos &lt; 0) {
                pos = ~pos;
            }
            System.arraycopy(entries, pos, entries, pos + 1, entriesSize - pos);
            entries[pos] = entry;
            ++entriesSize;
        }

        private void removeEntry(CacheEntry entry) {
            int pos = Arrays.binarySearch(entries, 0, entriesSize, entry, comparator);
            if (pos &lt; 0) {
                throw new IllegalStateException(&quot;Trying to remove a cached item that's not in the cache&quot;);
<A NAME="21"></A>            }
            if (entries[pos] != entry) {
                tmpKey.xformBounds.deriveWithNewBounds(0, 0, 0, entry.xformBounds.getWidth(), Math.nextAfter(entry.xformBounds.getHeight(), Float.NEGATIVE_INFINITY), 0);
                <FONT color="#00ff00"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#21',2,'match51-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>pos = Arrays.binarySearch(entries, 0, entriesSize, tmpKey, comparator);
                if (pos &lt; 0) {
                    pos = ~pos;
                }
                tmpKey.xformBounds.deriveWithNewBounds(0, 0, 0, entry.xformBounds.getWidth(), Math.nextAfter(entry.xformBounds.getHeight</B></FONT>(), Float.POSITIVE_INFINITY), 0);
                int toPos = Arrays.binarySearch(entries, 0, entriesSize, tmpKey, comparator);
                if (toPos &lt; 0) {
                    toPos = ~toPos;
                }
                while (entries[pos] != entry &amp;&amp; pos &lt; toPos) { ++pos; };
                if (pos &gt;= toPos) {
                    throw new IllegalStateException(&quot;Trying to remove a cached item that's not in the cache&quot;);
                }
            }
            System.arraycopy(entries, pos + 1, entries, pos, entriesSize - pos - 1);
            --entriesSize;
        }

        boolean hasRoom(RectBounds xformBounds) {
            int w = (int)(xformBounds.getWidth() + 0.5f);
            int h = (int)(xformBounds.getHeight() + 0.5f);
            int size = w*h;
            return
                w &lt;= MAX_MASK_DIM &amp;&amp;
                h &lt;= MAX_MASK_DIM &amp;&amp;
                totalPixels + size &lt;= MAX_SIZE_IN_PIXELS;
        }

        boolean entryMatches(CacheEntry entry, Shape shape, BasicStroke stroke, BaseTransform xform, boolean antialiasedShape) {
            return (entry.antialiasedShape == antialiasedShape) &amp;&amp; equalsIgnoreTranslation(xform, entry.xform) &amp;&amp; entry.shape.equals(shape) &amp;&amp;
                   (stroke == null ? entry.stroke == null : stroke.equals(entry.stroke));

        }

        void get(BaseShaderContext context,
                 MaskTexData texData,
                 Shape shape, BasicStroke stroke, BaseTransform xform,
                 RectBounds xformBounds,
                 boolean xformBoundsIsACopy, boolean antialiasedShape)
        {
            if (texData == null) {
                throw new InternalError(&quot;MaskTexData must be non-null&quot;);
            }
            if (texData.cacheEntry != null) {
                throw new InternalError(&quot;CacheEntry should already be null&quot;);
            }

            tmpKey.xformBounds.deriveWithNewBounds(0, 0, 0, xformBounds.getWidth(), Math.nextAfter(xformBounds.getHeight(), Float.NEGATIVE_INFINITY), 0);
            int i = Arrays.binarySearch(entries, 0, entriesSize, tmpKey, comparator);
            if (i &lt; 0) {
                i = ~i;
            }

            tmpKey.xformBounds.deriveWithNewBounds(0, 0, 0, xformBounds.getWidth(), Math.nextAfter(xformBounds.getHeight(), Float.POSITIVE_INFINITY), 0);
            int toPos = Arrays.binarySearch(entries, 0, entriesSize, tmpKey, comparator);
            if (toPos &lt; 0) {
                toPos = ~toPos;
            }
            for (;i &lt; toPos; i++) {
                CacheEntry entry = entries[i];

                if (entryMatches(entry, shape, stroke, xform, antialiasedShape))
                {
                    entry.texData.maskTex.lock();
                    if (entry.texData.maskTex.isSurfaceLost()) {
                        // Eventually refcount will go to zero and entry will be freed
                        entry.texData.maskTex.unlock();
                        continue;
                    }
                    // increment ref count for the chosen entry and
                    // link the given texData to it
                    entry.refCount++;
                    entry.texData.copyInto(texData);
                    texData.cacheEntry = entry;
                    // adjust the maskX/maskY by the delta between the
                    // cached transform and the current transform
                    texData.adjustOrigin(xform);
                    return;
                }
            }

            // did not find an existing mask; create a new one here
            MaskData maskData =
                ShapeUtil.rasterizeShape(shape, stroke, xformBounds, xform, true, antialiasedShape);
            int mw = maskData.getWidth();
            int mh = maskData.getHeight();
            texData.maskX = maskData.getOriginX();
            texData.maskY = maskData.getOriginY();
            texData.maskW = mw;
            texData.maskH = mh;
            texData.maskTex =
                context.getResourceFactory().createMaskTexture(mw, mh, WrapMode.CLAMP_TO_ZERO);
            maskData.uploadToTexture(texData.maskTex, 0, 0, false);
            texData.maskTex.contentsUseful();

            // add the new mask texture to the cache; note that we copy the
            // shape and transform so that dependents are not affected
            // if the original geometry is mutated (since NGPath will reuse
            // and mutate a single Path2D instance, for example)
            CacheEntry entry = new CacheEntry();
            entry.shape = shape.copy();
            if (stroke != null) entry.stroke = stroke.copy();
            entry.xform = xform.copy();
            entry.xformBounds = xformBoundsIsACopy ? xformBounds : (RectBounds)xformBounds.copy();
            entry.texData = texData.copy();
            entry.antialiasedShape = antialiasedShape;
            entry.refCount = 1;
            texData.cacheEntry = entry;
            addEntry(entry);
            totalPixels += mw*mh;
        }

        void unref(MaskTexData texData) {
            if (texData == null) {
                throw new InternalError(&quot;MaskTexData must be non-null&quot;);
            }
            CacheEntry entry = texData.cacheEntry;
            if (entry == null) {
                return;
            }
            texData.cacheEntry = null;
            texData.maskTex = null;
            entry.refCount--;
            if (entry.refCount &lt;= 0) {
                removeEntry(entry);
                entry.shape = null;
                entry.stroke = null;
                entry.xform = null;
                entry.xformBounds = null;
                entry.texData.maskTex.dispose();
                entry.antialiasedShape = false;
                entry.texData = null;
                totalPixels -= (texData.maskW * texData.maskH);
            }
        }
    }

    /**
     * Returns true if the two transforms are equal or if they differ only
     * in their translation components; otherwise returns false.
     */
    private static boolean equalsIgnoreTranslation(BaseTransform a,
                                                   BaseTransform b)
    {
        if (a == b) {
            return true;
        }

        return
            a.getMxx() == b.getMxx() &amp;&amp;
            a.getMxy() == b.getMxy() &amp;&amp;
            a.getMyx() == b.getMyx() &amp;&amp;
            a.getMyy() == b.getMyy();
    }

    private static final BaseTransform IDENT = BaseTransform.IDENTITY_TRANSFORM;
    // NOTE: need separate MaskCache per context?
    private static final MaskCache maskCache = new MaskCache();
    // Number of back to back similar renderings before we cache the mask
    private static final int CACHE_THRESHOLD = 2;

    private int renderCount;
    private Boolean tryCache;
    private BaseTransform lastXform;
    private final MaskTexData texData;
    private float[] bbox;

    private final Object disposerReferent = new Object();
    private final Disposer.Record disposerRecord;

    CachingShapeRepState() {
        this.texData = new MaskTexData();
        this.disposerRecord = new CSRDisposerRecord(texData);
        Disposer.addRecord(disposerReferent, disposerRecord);
    }

    // Note: Subclasses may override this method to use a more direct op.
    void fillNoCache(Graphics g, Shape shape) {
        g.fill(shape);
    }

    // Note: Subclasses may override this method to use a more direct op.
    void drawNoCache(Graphics g, Shape shape) {
        g.draw(shape);
    }

    void invalidate() {
        // Note: this method will be called from the FX thread, so just mark
        // the state as invalid and then the next render() call will take
        // care of unref'ing the cache entry (on the render thread).
        renderCount = 0;
        tryCache = null;
        lastXform = null;
        bbox = null;
    }

    private void invalidateMaskTexData() {
        // Note: this method should only be called from the render thread
        // (since calling unref() may cause textures to be disposed).
        tryCache = null;
        lastXform = null;
        maskCache.unref(texData);
    }

    void render(Graphics g, Shape shape, RectBounds shapeBounds, BasicStroke stroke) {
        // The following is safe; this method does not mutate xform
        BaseTransform xform = g.getTransformNoClone();

        boolean doResetMask;
        boolean doUpdateMask;

        if (lastXform == null) {
            doResetMask = doUpdateMask = true;
        } else if (equalsIgnoreTranslation(xform, lastXform)) {
            doResetMask = false;
            doUpdateMask = (xform.getMxt() != lastXform.getMxt() ||
                            xform.getMyt() != lastXform.getMyt());
        } else {
            doResetMask = doUpdateMask = true;
        }

        // we need to invalidate our cached MaskTexData if:
        //   - lastXform is null, indicating that we were marked invalid
        //     (due to a geometry or location change), or
        //   - the current transform is significantly different than the last
        if (doResetMask) {
            invalidateMaskTexData();

            renderCount = 0;
        }
        if (doResetMask || doUpdateMask) {
            if (lastXform == null) {
                lastXform = xform.copy();
            } else {
                lastXform.setTransform(xform);
            }
        }

        if (texData.cacheEntry != null) {
            texData.maskTex.lock();
            if (texData.maskTex.isSurfaceLost()) {
                texData.maskTex.unlock();
                invalidateMaskTexData();
            }
        }

        RectBounds xformBounds = null;
        boolean boundsCopy = false;

        if (tryCache == null) {
            // determine whether the shape size is within the limits
            if (xform.isIdentity()) {
                xformBounds = shapeBounds;
            } else {
                xformBounds = new RectBounds();
                boundsCopy = true;
                //this is a safe cast as this ShapeRep is not 3d capable.
                // all 3d transformed shapes are thus rendered by different ShapeRep
                xformBounds = (RectBounds) xform.transform(shapeBounds, xformBounds);
            }
            tryCache = !xformBounds.isEmpty() &amp;&amp; maskCache.hasRoom(xformBounds);
        }

        renderCount++;
        if (tryCache == Boolean.FALSE ||
            renderCount &lt; CACHE_THRESHOLD ||
            (!(g instanceof BaseShaderGraphics)) ||
            ((BaseShaderGraphics)g).isComplexPaint())
        {
            // render the slow way if:
            //   - the shape size exceeds the threshold, or
            //   - we haven't rendered enough times to get an idea of
            //     whether it is worth caching the mask, or
            //   - there is a complex paint set (note that we could
            //     potentially use the cached mask in this case, but the
            //     complex paint case is not common enough to warrant
            //     further optimization at this time)
            if (stroke == null) {
                fillNoCache(g, shape);
            } else {
                drawNoCache(g, shape);
            }
            return;
        }

        BaseShaderGraphics bsg = (BaseShaderGraphics)g;
        BaseShaderContext context = bsg.getContext();
        if (doUpdateMask || texData.cacheEntry == null) {
            // need to create a new mask texture, or reuse an existing one
            if (xformBounds == null) {
                if (xform.isIdentity()) {
                    xformBounds = shapeBounds;
                } else {
                    xformBounds = new RectBounds();
                    boundsCopy = true;
                    xformBounds = (RectBounds) xform.transform(shapeBounds, xformBounds);
                }
            }

            if (texData.cacheEntry != null) {
                // in this case, we already have a valid mask texture, but
                // the transform (translation) has changed since we last used
                // it, so we just need to update the maskX/maskY variables
                texData.adjustOrigin(xform);
            } else {
                // the following will locate an existing cached mask that
                // matches the given parameters, or failing that, will create
                // a new mask and put it in the cache
                maskCache.get(context, texData, shape, stroke, xform, xformBounds, boundsCopy, g.isAntialiasedShape());
            }
        }

        Paint paint = bsg.getPaint();
        float bx = 0f, by = 0f, bw = 0f, bh = 0f;
        if (paint.isProportional()) {
            if (bbox == null) {
                bbox = new float[] {
                    Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY,
                    Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY,
                };
                Shape.accumulate(bbox, shape, BaseTransform.IDENTITY_TRANSFORM);
            }
            bx = bbox[0];
            by = bbox[1];
            bw = bbox[2] - bx;
            bh = bbox[3] - by;
        }

        int mw = texData.maskW;
        int mh = texData.maskH;
        Texture maskTex = texData.maskTex;
        float tw = maskTex.getPhysicalWidth();
        float th = maskTex.getPhysicalHeight();
        float dx1 = texData.maskX;
        float dy1 = texData.maskY;
        float dx2 = dx1 + mw;
        float dy2 = dy1 + mh;
        float tx1 = maskTex.getContentX() / tw;
        float ty1 = maskTex.getContentY() / th;
        float tx2 = tx1 + mw / tw;
        float ty2 = ty1 + mh / th;

        if (PrismSettings.primTextureSize != 0) {
            // the mask has been generated in device space, so we use
            // identity transform here
            Shader shader =
                context.validatePaintOp(bsg, IDENT,
                                        MaskType.ALPHA_TEXTURE, texData.maskTex,
                                        bx, by, bw, bh);

            VertexBuffer vb = context.getVertexBuffer();
            vb.addQuad(dx1, dy1, dx2, dy2, tx1, ty1, tx2, ty2,
                       bsg.getPaintTextureTx(xform, shader, bx, by, bw, bh));
        } else {
            // the mask has been generated in device space, so we use
            // identity transform here
            context.validatePaintOp(bsg, IDENT, texData.maskTex, bx, by, bw, bh);

            VertexBuffer vb = context.getVertexBuffer();
            vb.addQuad(dx1, dy1, dx2, dy2, tx1, ty1, tx2, ty2);
        }
        maskTex.unlock();
    }

    void dispose() {
        // Note: this method will be called from the FX thread; just
        // invalidate and let the DisposerRecord take care of cutting
        // the ties with the mask cache and disposing textures if necessary
        // (on the render thread).
        invalidate();
    }

    private static class CSRDisposerRecord implements Disposer.Record {
        private MaskTexData texData;

        private CSRDisposerRecord(MaskTexData texData) {
            this.texData = texData;
        }

        public void dispose() {
            // Note: this method should only be called from the rendering thread
            if (texData != null) {
                maskCache.unref(texData);
                texData = null;
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/sw/SWContext.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.sw;

import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.marlin.DMarlinRenderer;
import com.sun.marlin.DMarlinRenderingEngine;
import com.sun.marlin.DRendererContext;
import com.sun.marlin.IntArrayCache;
import com.sun.marlin.MarlinAlphaConsumer;
import com.sun.marlin.MarlinConst;
import com.sun.marlin.MarlinRenderer;
import com.sun.marlin.MarlinRenderingEngine;
import com.sun.marlin.RendererContext;
import com.sun.openpisces.Renderer;
import com.sun.pisces.PiscesRenderer;
import com.sun.prism.BasicStroke;
import com.sun.prism.PixelFormat;
import com.sun.prism.ResourceFactory;
import com.sun.prism.Texture;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.impl.shape.DMarlinPrismUtils;
import com.sun.prism.impl.shape.MarlinPrismUtils;
import com.sun.prism.impl.shape.MaskData;
import com.sun.prism.impl.shape.OpenPiscesPrismUtils;
import com.sun.prism.impl.shape.ShapeUtil;

import java.lang.ref.SoftReference;

final class SWContext {

    private final ResourceFactory factory;
    private final ShapeRenderer shapeRenderer;
    private SoftReference&lt;SWRTTexture&gt; readBackBufferRef;
    private SoftReference&lt;SWArgbPreTexture&gt; imagePaintTextureRef;

    interface ShapeRenderer {
        void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape);
        void dispose();
    }

    class NativeShapeRenderer implements ShapeRenderer {
        private SoftReference&lt;SWMaskTexture&gt; maskTextureRef;

        public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
            final MaskData mask = ShapeUtil.rasterizeShape(shape, stroke, clip.toRectBounds(), tr, true, antialiasedShape);
            final SWMaskTexture tex = this.validateMaskTexture(mask.getWidth(), mask.getHeight());
            mask.uploadToTexture(tex, 0, 0, false);
            pr.fillAlphaMask(tex.getDataNoClone(), mask.getOriginX(), mask.getOriginY(),
                             mask.getWidth(), mask.getHeight(), 0, tex.getPhysicalWidth());
        }

        private SWMaskTexture initMaskTexture(int width, int height) {
            final SWMaskTexture tex = (SWMaskTexture)factory.createMaskTexture(width, height, Texture.WrapMode.CLAMP_NOT_NEEDED);
            maskTextureRef = new SoftReference&lt;SWMaskTexture&gt;(tex);
            return tex;
        }

        private void disposeMaskTexture() {
            if (maskTextureRef != null){
                maskTextureRef.clear();
                maskTextureRef = null;
            }
        }

        private SWMaskTexture validateMaskTexture(int width, int height) {
            SWMaskTexture tex;
            if (maskTextureRef == null) {
                tex = this.initMaskTexture(width, height);
            } else {
                tex = maskTextureRef.get();
                if (tex == null ||
                    tex.getPhysicalWidth() &lt; width ||
                    tex.getPhysicalHeight() &lt; height)
                {
<A NAME="37"></A>                    this.disposeMaskTexture();
                    tex = this.initMaskTexture(width, height);
                }
            <FONT color="#810541"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#37',2,'match51-top.html#37',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
            return tex;
        }

        public void dispose() {
            this.disposeMaskTexture();
        }
    }</B></FONT>

    static final class JavaShapeRenderer implements ShapeRenderer {
        private final DirectRTPiscesAlphaConsumer alphaConsumer = new DirectRTPiscesAlphaConsumer();

        public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
            if (stroke != null &amp;&amp; stroke.getType() != BasicStroke.TYPE_CENTERED) {
                // RT-27427
                // TODO: Optimize the combinatorial strokes for simple
                // shapes and/or teach the rasterizer to be able to
                // do a &quot;differential fill&quot; between two shapes.
                // Note that most simple shapes will use a more optimized path
                // than this method for the INNER/OUTER strokes anyway.
                shape = stroke.createStrokedShape(shape);
                stroke = null;
            }
            final Renderer r = OpenPiscesPrismUtils.setupRenderer(shape, stroke, tr, clip, antialiasedShape);
            alphaConsumer.initConsumer(r, pr);
            r.produceAlphas(alphaConsumer);
        }

        public void dispose() { }
    }

    static final class MarlinShapeRenderer implements ShapeRenderer {
        private final DirectRTMarlinAlphaConsumer alphaConsumer = new DirectRTMarlinAlphaConsumer();

        @Override
        public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
            if (stroke != null &amp;&amp; stroke.getType() != BasicStroke.TYPE_CENTERED) {
                // RT-27427
                // TODO: Optimize the combinatorial strokes for simple
                // shapes and/or teach the rasterizer to be able to
                // do a &quot;differential fill&quot; between two shapes.
                // Note that most simple shapes will use a more optimized path
                // than this method for the INNER/OUTER strokes anyway.
                shape = stroke.createStrokedShape(shape);
                stroke = null;
            }
            final RendererContext rdrCtx = MarlinRenderingEngine.getRendererContext();
            MarlinRenderer renderer = null;
            try {
                if (shape instanceof Path2D) {
                    renderer = MarlinPrismUtils.setupRenderer(rdrCtx, (Path2D) shape, stroke, tr, clip,
                            antialiasedShape);
                }
                if (renderer == null) {
                    renderer = MarlinPrismUtils.setupRenderer(rdrCtx, shape, stroke, tr, clip,
                            antialiasedShape);
                }
                final int outpix_xmin = renderer.getOutpixMinX();
                final int outpix_xmax = renderer.getOutpixMaxX();
                final int outpix_ymin = renderer.getOutpixMinY();
                final int outpix_ymax = renderer.getOutpixMaxY();
                final int w = outpix_xmax - outpix_xmin;
                final int h = outpix_ymax - outpix_ymin;
                if ((w &lt;= 0) || (h &lt;= 0)) {
                    return;
                }
                alphaConsumer.initConsumer(outpix_xmin, outpix_ymin, w, h, pr);
                renderer.produceAlphas(alphaConsumer);
            } finally {
                if (renderer != null) {
                    renderer.dispose();
                }
                // recycle the RendererContext instance
                MarlinRenderingEngine.returnRendererContext(rdrCtx);
            }
        }

        @Override
        public void dispose() { }
    }

    static final class DirectRTMarlinAlphaConsumer implements MarlinAlphaConsumer {
        private byte alpha_map[];
        private int x;
        private int y;
        private int w;
        private int h;
        private int rowNum;

        private PiscesRenderer pr;

        public void initConsumer(int x, int y, int w, int h, PiscesRenderer pr) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
            rowNum = 0;
            this.pr = pr;
        }

        @Override
        public int getOriginX() {
            return x;
        }

        @Override
        public int getOriginY() {
            return y;
        }

        @Override
        public int getWidth() {
            return w;
        }

        @Override
        public int getHeight() {
            return h;
        }

        @Override
        public void setMaxAlpha(int maxalpha) {
            if ((alpha_map == null) || (alpha_map.length != maxalpha+1)) {
                alpha_map = new byte[maxalpha+1];
                for (int i = 0; i &lt;= maxalpha; i++) {
                    alpha_map[i] = (byte) ((i*255 + maxalpha/2)/maxalpha);
                }
            }
        }

        @Override
        public boolean supportBlockFlags() {
            return false;
        }

        @Override
        public void clearAlphas(final int pix_y) {
            // noop
        }

        @Override
        public void setAndClearRelativeAlphas(final int[] alphaDeltas, final int pix_y,
                                              final int pix_from, final int pix_to)
        {
            // pix_from indicates the first alpha coverage != 0 within [x; pix_to[
            pr.emitAndClearAlphaRow(alpha_map, alphaDeltas, pix_y, pix_from, pix_to, (pix_from - x), rowNum);
            rowNum++;

            // clear properly the end of the alphaDeltas:
            final int to = pix_to - x;
            if (to &lt;= w) {
                alphaDeltas[to] = 0;
            } else {
                alphaDeltas[w]  = 0;
            }

            if (MarlinConst.DO_CHECKS) {
                IntArrayCache.check(alphaDeltas, pix_from - x, to + 1, 0);
            }
        }

        @Override
        public void setAndClearRelativeAlphas(final int[] blkFlags, final int[] alphaDeltas, final int pix_y,
                                              final int pix_from, final int pix_to)
        {
            throw new UnsupportedOperationException();
        }
    }

    static final class DMarlinShapeRenderer implements ShapeRenderer {
        private final DirectRTMarlinAlphaConsumer alphaConsumer = new DirectRTMarlinAlphaConsumer();

        @Override
        public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
            if (stroke != null &amp;&amp; stroke.getType() != BasicStroke.TYPE_CENTERED) {
                // RT-27427
                // TODO: Optimize the combinatorial strokes for simple
                // shapes and/or teach the rasterizer to be able to
                // do a &quot;differential fill&quot; between two shapes.
                // Note that most simple shapes will use a more optimized path
                // than this method for the INNER/OUTER strokes anyway.
                shape = stroke.createStrokedShape(shape);
                stroke = null;
            }
            final DRendererContext rdrCtx = DMarlinRenderingEngine.getRendererContext();
            DMarlinRenderer renderer = null;
            try {
                if (shape instanceof Path2D) {
                    renderer = DMarlinPrismUtils.setupRenderer(rdrCtx, (Path2D) shape, stroke, tr, clip,
                            antialiasedShape);
                }
                if (renderer == null) {
                    renderer = DMarlinPrismUtils.setupRenderer(rdrCtx, shape, stroke, tr, clip,
                            antialiasedShape);
                }
                final int outpix_xmin = renderer.getOutpixMinX();
                final int outpix_xmax = renderer.getOutpixMaxX();
                final int outpix_ymin = renderer.getOutpixMinY();
                final int outpix_ymax = renderer.getOutpixMaxY();
                final int w = outpix_xmax - outpix_xmin;
                final int h = outpix_ymax - outpix_ymin;
                if ((w &lt;= 0) || (h &lt;= 0)) {
                    return;
                }
                alphaConsumer.initConsumer(outpix_xmin, outpix_ymin, w, h, pr);
                renderer.produceAlphas(alphaConsumer);
            } finally {
                if (renderer != null) {
                    renderer.dispose();
                }
                // recycle the RendererContext instance
                DMarlinRenderingEngine.returnRendererContext(rdrCtx);
            }
        }

        @Override
        public void dispose() { }
    }

    SWContext(ResourceFactory factory) {
        this.factory = factory;
        switch (PrismSettings.rasterizerSpec) {
            case JavaPisces:
                this.shapeRenderer = new JavaShapeRenderer();
                break;
            case NativePisces:
                this.shapeRenderer = new NativeShapeRenderer();
                break;
            case FloatMarlin:
                this.shapeRenderer = new MarlinShapeRenderer();
                break;
            default:
            case DoubleMarlin:
                this.shapeRenderer = new DMarlinShapeRenderer();
                break;
        }
    }

    void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
        this.shapeRenderer.renderShape(pr, shape, stroke, tr, clip, antialiasedShape);
    }

    private SWRTTexture initRBBuffer(int width, int height) {
        final SWRTTexture tex = (SWRTTexture)factory.createRTTexture(width, height, Texture.WrapMode.CLAMP_NOT_NEEDED);
        readBackBufferRef = new SoftReference&lt;SWRTTexture&gt;(tex);
        return tex;
    }

    private void disposeRBBuffer() {
        if (readBackBufferRef != null) {
            readBackBufferRef.clear();
            readBackBufferRef = null;
        }
    }

    SWRTTexture validateRBBuffer(int width, int height) {
        SWRTTexture tex;
        if (readBackBufferRef == null) {
            tex = this.initRBBuffer(width, height);
        } else {
            tex = readBackBufferRef.get();
            if (tex == null ||
                tex.getPhysicalWidth() &lt; width ||
                tex.getPhysicalHeight() &lt; height)
            {
                this.disposeRBBuffer();
                tex = this.initRBBuffer(width, height);
            }
            tex.setContentWidth(width);
            tex.setContentHeight(height);
        }
        return tex;
    }

    private SWArgbPreTexture initImagePaintTexture(int width, int height) {
        final SWArgbPreTexture tex = (SWArgbPreTexture)factory.createTexture(PixelFormat.INT_ARGB_PRE,
                Texture.Usage.DEFAULT, Texture.WrapMode.REPEAT, width, height);
        imagePaintTextureRef = new SoftReference&lt;SWArgbPreTexture&gt;(tex);
        return tex;
    }

    private void disposeImagePaintTexture() {
        if (imagePaintTextureRef != null) {
            imagePaintTextureRef.clear();
            imagePaintTextureRef = null;
        }
    }

    SWArgbPreTexture validateImagePaintTexture(int width, int height) {
        SWArgbPreTexture tex;
        if (imagePaintTextureRef == null) {
            tex = this.initImagePaintTexture(width, height);
        } else {
            tex = imagePaintTextureRef.get();
            if (tex == null ||
                tex.getPhysicalWidth() &lt; width ||
                tex.getPhysicalHeight() &lt; height)
            {
                this.disposeImagePaintTexture();
                tex = this.initImagePaintTexture(width, height);
            }
            tex.setContentWidth(width);
            tex.setContentHeight(height);
        }
        return tex;
    }


    void dispose() {
        this.disposeRBBuffer();
        this.disposeImagePaintTexture();
        this.shapeRenderer.dispose();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/sw/SWGraphics.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.sw;

import com.sun.glass.ui.Screen;
import com.sun.javafx.font.FontResource;
import com.sun.javafx.font.FontStrike;
import com.sun.javafx.font.Glyph;
import com.sun.javafx.font.Metrics;
import com.sun.javafx.font.PrismFontFactory;
import com.sun.javafx.geom.Ellipse2D;
import com.sun.javafx.geom.Line2D;
import com.sun.javafx.geom.Point2D;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.RoundRectangle2D;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.javafx.scene.text.GlyphList;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGLightBase;
import com.sun.javafx.sg.prism.NodePath;
import com.sun.pisces.GradientColorMap;
import com.sun.pisces.PiscesRenderer;
import com.sun.pisces.RendererBase;
import com.sun.pisces.Transform6;
import com.sun.prism.BasicStroke;
import com.sun.prism.CompositeMode;
import com.sun.prism.Graphics;
import com.sun.prism.PixelFormat;
import com.sun.prism.RTTexture;
import com.sun.prism.ReadbackGraphics;
import com.sun.prism.RenderTarget;
import com.sun.prism.Texture;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.ImagePattern;
import com.sun.prism.paint.Paint;

final class SWGraphics implements ReadbackGraphics {

    private static final BasicStroke DEFAULT_STROKE =
        new BasicStroke(1.0f, BasicStroke.CAP_SQUARE, BasicStroke.JOIN_MITER, 10.0f);
    private static final Paint DEFAULT_PAINT = Color.WHITE;

    private final PiscesRenderer pr;
    private final SWContext context;
<A NAME="14"></A>    private final SWRTTexture target;
    private final SWPaint swPaint;

    <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#14',2,'match51-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private final BaseTransform tx = new Affine2D();

    private CompositeMode compositeMode = CompositeMode.SRC_OVER;

    private Rectangle clip;
    private final Rectangle finalClip = new Rectangle();
    private RectBounds nodeBounds;

    private int clipRectIndex;

    private Paint paint = DEFAULT_PAINT;
    private BasicStroke stroke = DEFAULT_STROKE;

    private Ellipse2D ellipse2d;
    private Line2D line2d;
    private RoundRectangle2D rect2d</B></FONT>;

    private boolean antialiasedShape = true;
    private boolean hasPreCullingBits = false;
    private float pixelScaleX = 1.0f;
    private float pixelScaleY = 1.0f;

    private NodePath renderRoot;
    @Override
    public void setRenderRoot(NodePath root) {
        this.renderRoot = root;
    }

    @Override
    public NodePath getRenderRoot() {
        return renderRoot;
    }

    public SWGraphics(SWRTTexture target, SWContext context, PiscesRenderer pr) {
        this.target = target;
        this.context = context;
        this.pr = pr;
        this.swPaint = new SWPaint(context, pr);

        this.setClipRect(null);
    }

    public RenderTarget getRenderTarget() {
        return target;
    }

    public SWResourceFactory getResourceFactory() {
        return target.getResourceFactory();
    }

    public Screen getAssociatedScreen() {
        return target.getAssociatedScreen();
    }

    public void sync() {
    }

    public BaseTransform getTransformNoClone() {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ getTransformNoClone &quot; + this + &quot;; tr: &quot; + tx);
        }
        return tx;
    }

    public void setTransform(BaseTransform xform) {
        if (xform == null) {
            xform = BaseTransform.IDENTITY_TRANSFORM;
        }
        if (PrismSettings.debug) {
            System.out.println(&quot;+ setTransform &quot; + this + &quot;; tr: &quot; + xform);
        }
        tx.setTransform(xform);
    }

    public void setTransform(double m00, double m10,
                             double m01, double m11,
                             double m02, double m12) {
        tx.restoreTransform(m00, m10, m01, m11, m02, m12);
        if (PrismSettings.debug) {
            System.out.println(&quot;+ restoreTransform &quot; + this + &quot;; tr: &quot; + tx);
        }
    }

    public void setTransform3D(double mxx, double mxy, double mxz, double mxt,
                               double myx, double myy, double myz, double myt,
                               double mzx, double mzy, double mzz, double mzt) {
        if (mxz != 0.0 || myz != 0.0 ||
            mzx != 0.0 || mzy != 0.0 || mzz != 1.0 || mzt != 0.0)
        {
            throw new UnsupportedOperationException(&quot;3D transforms not supported.&quot;);
        }
        setTransform(mxx, myx, mxy, myy, mxt, myt);
    }

    public void transform(BaseTransform xform) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ concatTransform &quot; + this + &quot;; tr: &quot; + xform);
        }
        tx.deriveWithConcatenation(xform);
    }

    public void translate(float tx, float ty) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ concat translate &quot; + this + &quot;; tx: &quot; + tx + &quot;; ty: &quot; + ty);
        }
        this.tx.deriveWithTranslation(tx, ty);
    }

    public void translate(float tx, float ty, float tz) {
        throw new UnsupportedOperationException(&quot;translate3D: unimp&quot;);
    }

    public void scale(float sx, float sy) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ concat scale &quot; + this + &quot;; sx: &quot; + sx + &quot;; sy: &quot; + sy);
        }
        tx.deriveWithConcatenation(sx, 0, 0, sy, 0, 0);
    }

    public void scale(float sx, float sy, float sz) {
        throw new UnsupportedOperationException(&quot;scale3D: unimp&quot;);
    }

    public void setCamera(NGCamera camera) {
    }

    public void setPerspectiveTransform(GeneralTransform3D transform) {
    }

    public NGCamera getCameraNoClone() {
        throw new UnsupportedOperationException(&quot;getCameraNoClone: unimp&quot;);
    }

    public void setDepthTest(boolean depthTest) { }

    public boolean isDepthTest() {
        return false;
    }

    public void setDepthBuffer(boolean depthBuffer) { }

    public boolean isDepthBuffer() {
        return false;
    }

    public boolean isAlphaTestShader() {
        if (PrismSettings.verbose &amp;&amp; PrismSettings.forceAlphaTestShader) {
            System.out.println(&quot;SW pipe doesn't support shader with alpha testing&quot;);
        }
        return false;
    }

    public void setAntialiasedShape(boolean aa) {
        antialiasedShape = aa;
    }

    public boolean isAntialiasedShape() {
        return antialiasedShape;
    }

    public Rectangle getClipRect() {
        return (clip == null) ? null : new Rectangle(clip);
    }

    public Rectangle getClipRectNoClone() {
        return clip;
    }

    public RectBounds getFinalClipNoClone() {
        return finalClip.toRectBounds();
    }

    public void setClipRect(Rectangle clipRect) {
        finalClip.setBounds(target.getDimensions());
        if (clipRect == null) {
            if (PrismSettings.debug) {
                System.out.println(&quot;+ PR.resetClip&quot;);
            }
            clip = null;
        } else {
            if (PrismSettings.debug) {
                System.out.println(&quot;+ PR.setClip: &quot; + clipRect);
            }
            finalClip.intersectWith(clipRect);
            clip = new Rectangle(clipRect);
        }
        pr.setClip(finalClip.x, finalClip.y, finalClip.width, finalClip.height);
    }

    public void setHasPreCullingBits(boolean hasBits) {
        this.hasPreCullingBits = hasBits;
    }

    public boolean hasPreCullingBits() {
        return this.hasPreCullingBits;
    }

    public int getClipRectIndex() {
        return clipRectIndex;
    }

    public void setClipRectIndex(int index) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ PR.setClipRectIndex: &quot; + index);
        }
        clipRectIndex = index;
    }

    public float getExtraAlpha() {
        return swPaint.getCompositeAlpha();
    }

    public void setExtraAlpha(float extraAlpha) {
        if (PrismSettings.debug) {
            System.out.println(&quot;PR.setCompositeAlpha, value: &quot; + extraAlpha);
        }
        swPaint.setCompositeAlpha(extraAlpha);
    }

    public Paint getPaint() {
        return paint;
    }

    public void setPaint(Paint paint) {
        this.paint = paint;
    }



    public BasicStroke getStroke() {
        return stroke;
    }

    public void setStroke(BasicStroke stroke) {
        this.stroke = stroke;
    }

    public CompositeMode getCompositeMode() {
        return compositeMode;
    }

    public void setCompositeMode(CompositeMode mode) {
        this.compositeMode = mode;

        int piscesComp;
        switch (mode) {
            case CLEAR:
                piscesComp = RendererBase.COMPOSITE_CLEAR;
                if (PrismSettings.debug) {
                    System.out.println(&quot;PR.setCompositeRule - CLEAR&quot;);
                }
                break;
            case SRC:
                piscesComp = RendererBase.COMPOSITE_SRC;
                if (PrismSettings.debug) {
                    System.out.println(&quot;PR.setCompositeRule - SRC&quot;);
                }
                break;
            case SRC_OVER:
                piscesComp = RendererBase.COMPOSITE_SRC_OVER;
                if (PrismSettings.debug) {
                    System.out.println(&quot;PR.setCompositeRule - SRC_OVER&quot;);
                }
                break;
            default:
                throw new InternalError(&quot;Unrecognized composite mode: &quot;+mode);
        }
        this.pr.setCompositeRule(piscesComp);
    }

    public void setNodeBounds(RectBounds bounds) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ SWG.setNodeBounds: &quot; + bounds);
        }
        nodeBounds = bounds;
    }

    public void clear() {
        this.clear(Color.TRANSPARENT);
    }

    /**
     * Clears the current {@code RenderTarget} with the given {@code Color}.
     * Note that this operation is affected by the current clip rectangle,
     * if set.  To clear the entire surface, call {@code setClipRect(null)}
     * prior to calling {@code clear()}.
     */
    public void clear(Color color) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ PR.clear: &quot; + color);
        }
        this.swPaint.setColor(color, 1f);
        pr.clearRect(0, 0, target.getPhysicalWidth(), target.getPhysicalHeight());
        getRenderTarget().setOpaque(color.isOpaque());
    }

    /**
     * Clears the region represented by the given quad with transparent pixels.
     * Note that this operation is affected by the current clip rectangle,
     * if set, as well as the current transform (the quad is specified in
     * user space).  Also note that unlike the {@code clear()} methods, this
     * method does not attempt to clear the depth buffer.
     */
    public void clearQuad(float x1, float y1, float x2, float y2) {
        final CompositeMode cm = this.compositeMode;
        final Paint p = this.paint;
        this.setCompositeMode(CompositeMode.SRC);
        this.setPaint(Color.TRANSPARENT);
        this.fillQuad(x1, y1, x2, y2);
        this.setCompositeMode(cm);
        this.setPaint(p);
    }

    public void fill(Shape shape) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ fill(Shape)&quot;);
        }
        paintShape(shape, null, this.tx);
    }

    public void fillQuad(float x1, float y1, float x2, float y2) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ SWG.fillQuad&quot;);
        }
        this.fillRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));
    }

    public void fillRect(float x, float y, float width, float height) {
        if (PrismSettings.debug) {
            System.out.printf(&quot;+ SWG.fillRect, x: %f, y: %f, w: %f, h: %f\n&quot;, x, y, width, height);
        }
        if (tx.getMxy() == 0 &amp;&amp; tx.getMyx() == 0) {
            if (PrismSettings.debug) {
                System.out.println(&quot;GR: &quot; + this);
                System.out.println(&quot;target: &quot; + target + &quot; t.w: &quot; + target.getPhysicalWidth() + &quot;, t.h: &quot; + target.getPhysicalHeight() +
                        &quot;, t.dims: &quot; + target.getDimensions());
                System.out.println(&quot;Tx: &quot; + tx);
                System.out.println(&quot;Clip: &quot; + finalClip);
                System.out.println(&quot;Composite rule: &quot; + compositeMode);
            }

            final Point2D p1 = new Point2D(x, y);
            final Point2D p2 = new Point2D(x + width, y + height);
            tx.transform(p1, p1);
            tx.transform(p2, p2);

            if (this.paint.getType() == Paint.Type.IMAGE_PATTERN) {
                // we can call pr.drawImage(...) directly
                final ImagePattern ip = (ImagePattern)this.paint;
                if (ip.getImage().getPixelFormat() == PixelFormat.BYTE_ALPHA) {
                    throw new UnsupportedOperationException(&quot;Alpha image is not supported as an image pattern.&quot;);
                } else {
                    final Transform6 piscesTx = swPaint.computeSetTexturePaintTransform(this.paint, this.tx, this.nodeBounds, x, y, width, height);
                    final SWArgbPreTexture tex = context.validateImagePaintTexture(ip.getImage().getWidth(), ip.getImage().getHeight());
                    tex.update(ip.getImage());

                    final float compositeAlpha = swPaint.getCompositeAlpha();
                    final int imageMode;
                    if (compositeAlpha == 1f) {
                        imageMode = RendererBase.IMAGE_MODE_NORMAL;
                    } else {
                        imageMode = RendererBase.IMAGE_MODE_MULTIPLY;
                        this.pr.setColor(255, 255, 255, (int)(255 * compositeAlpha));
                    }

                    this.pr.drawImage(RendererBase.TYPE_INT_ARGB_PRE, imageMode,
                            tex.getDataNoClone(), tex.getContentWidth(), tex.getContentHeight(),
                            tex.getOffset(), tex.getPhysicalWidth(),
                            piscesTx,
                            tex.getWrapMode() == Texture.WrapMode.REPEAT,
                            (int)(Math.min(p1.x, p2.x) * SWUtils.TO_PISCES), (int)(Math.min(p1.y, p2.y) * SWUtils.TO_PISCES),
                            (int)(Math.abs(p2.x - p1.x) * SWUtils.TO_PISCES), (int)(Math.abs(p2.y - p1.y) * SWUtils.TO_PISCES),
                            RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_KEEP,
                            RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_KEEP,
                            0, 0, tex.getContentWidth()-1, tex.getContentHeight()-1,
                            tex.hasAlpha());
                }
            } else {
                swPaint.setPaintFromShape(this.paint, this.tx, null, this.nodeBounds, x, y, width, height);
                this.pr.fillRect((int)(Math.min(p1.x, p2.x) * SWUtils.TO_PISCES), (int)(Math.min(p1.y, p2.y) * SWUtils.TO_PISCES),
                        (int)(Math.abs(p2.x - p1.x) * SWUtils.TO_PISCES), (int)(Math.abs(p2.y - p1.y) * SWUtils.TO_PISCES));
            }
        } else {
            this.fillRoundRect(x, y, width, height, 0, 0);
        }
    }

    public void fillRoundRect(float x, float y, float width, float height,
                              float arcw, float arch) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ SWG.fillRoundRect&quot;);
        }
        this.paintRoundRect(x, y, width, height, arcw, arch, null);
    }

    public void fillEllipse(float x, float y, float width, float height) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ SWG.fillEllipse&quot;);
        }
        this.paintEllipse(x, y, width, height, null);
    }

    public void draw(Shape shape) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ draw(Shape)&quot;);
        }
        paintShape(shape, this.stroke, this.tx);
    }

    private void paintShape(Shape shape, BasicStroke st, BaseTransform tr) {
        if (this.finalClip.isEmpty()) {
            if (PrismSettings.debug) {
                System.out.println(&quot;Final clip is empty: not rendering the shape: &quot; + shape);
            }
            return;
        }
        swPaint.setPaintFromShape(this.paint, this.tx, shape, this.nodeBounds, 0,0,0,0);
        this.paintShapePaintAlreadySet(shape, st, tr);
    }

    private void paintShapePaintAlreadySet(Shape shape, BasicStroke st, BaseTransform tr) {
        if (this.finalClip.isEmpty()) {
            if (PrismSettings.debug) {
                System.out.println(&quot;Final clip is empty: not rendering the shape: &quot; + shape);
            }
            return;
        }

        if (PrismSettings.debug) {
            System.out.println(&quot;GR: &quot; + this);
            System.out.println(&quot;target: &quot; + target + &quot; t.w: &quot; + target.getPhysicalWidth() + &quot;, t.h: &quot; + target.getPhysicalHeight() +
                    &quot;, t.dims: &quot; + target.getDimensions());
            System.out.println(&quot;Shape: &quot; + shape);
            System.out.println(&quot;Stroke: &quot; + st);
            System.out.println(&quot;Tx: &quot; + tr);
            System.out.println(&quot;Clip: &quot; + finalClip);
            System.out.println(&quot;Composite rule: &quot; + compositeMode);
        }
        context.renderShape(this.pr, shape, st, tr, this.finalClip, isAntialiasedShape());
    }

    private void paintRoundRect(float x, float y, float width, float height, float arcw, float arch, BasicStroke st) {
        if (rect2d == null) {
            rect2d = new RoundRectangle2D(x, y, width, height, arcw, arch);
        } else {
            rect2d.setRoundRect(x, y, width, height, arcw, arch);
        }
        paintShape(this.rect2d, st, this.tx);
    }

    private void paintEllipse(float x, float y, float width, float height, BasicStroke st) {
        if (ellipse2d == null) {
            ellipse2d = new Ellipse2D(x, y, width, height);
        } else {
            ellipse2d.setFrame(x, y, width, height);
        }
        paintShape(this.ellipse2d, st, this.tx);
    }

    public void drawLine(float x1, float y1, float x2, float y2) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ drawLine&quot;);
        }
        if (line2d == null) {
            line2d = new Line2D(x1, y1, x2, y2);
        } else {
            line2d.setLine(x1, y1, x2, y2);
        }
        paintShape(this.line2d, this.stroke, this.tx);
    }

    public void drawRect(float x, float y, float width, float height) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ SWG.drawRect&quot;);
        }
        this.drawRoundRect(x, y, width, height, 0, 0);
    }

    public void drawRoundRect(float x, float y, float width, float height,
                              float arcw, float arch) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ SWG.drawRoundRect&quot;);
        }
        this.paintRoundRect(x, y, width, height, arcw, arch, stroke);
    }

    public void drawEllipse(float x, float y, float width, float height) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ SWG.drawEllipse&quot;);
        }
        this.paintEllipse(x, y, width, height, stroke);
    }

    public void drawString(GlyphList gl, FontStrike strike, float x, float y,
                           Color selectColor, int selectStart, int selectEnd) {

        if (PrismSettings.debug) {
            System.out.println(&quot;+ SWG.drawGlyphList, gl.Count: &quot; + gl.getGlyphCount() +
                    &quot;, x: &quot; + x + &quot;, y: &quot; + y +
                    &quot;, selectStart: &quot; + selectStart + &quot;, selectEnd: &quot; + selectEnd);
        }

        final float bx, by, bw, bh;
        if (paint.isProportional()) {
            if (nodeBounds != null) {
                bx = nodeBounds.getMinX();
                by = nodeBounds.getMinY();
                bw = nodeBounds.getWidth();
                bh = nodeBounds.getHeight();
            } else {
                Metrics m = strike.getMetrics();
                bx = 0;
                by = m.getAscent();
                bw = gl.getWidth();
                bh = m.getLineHeight();
            }
        } else {
            bx = by = bw = bh = 0;
        }

        final boolean drawAsMasks = tx.isTranslateOrIdentity() &amp;&amp; (!strike.drawAsShapes());
        final boolean doLCDText = drawAsMasks &amp;&amp;
                (strike.getAAMode() == FontResource.AA_LCD) &amp;&amp;
                getRenderTarget().isOpaque() &amp;&amp;
                (this.paint.getType() == Paint.Type.COLOR) &amp;&amp;
                tx.is2D();
        BaseTransform glyphTx = null;

        if (doLCDText) {
            this.pr.setLCDGammaCorrection(1f / PrismFontFactory.getLCDContrast());
        } else if (drawAsMasks) {
            final FontResource fr = strike.getFontResource();
            final float origSize = strike.getSize();
            final BaseTransform origTx = strike.getTransform();
            strike = fr.getStrike(origSize, origTx, FontResource.AA_GREYSCALE);
        } else {
            glyphTx = new Affine2D();
        }

        if (selectColor == null) {
            swPaint.setPaintBeforeDraw(this.paint, this.tx, bx, by, bw, bh);
            for (int i = 0; i &lt; gl.getGlyphCount(); i++) {
                this.drawGlyph(strike, gl, i, glyphTx, drawAsMasks, x, y);
            }
        } else {
            for (int i = 0; i &lt; gl.getGlyphCount(); i++) {
                final int offset = gl.getCharOffset(i);
                final boolean selected = selectStart &lt;= offset &amp;&amp; offset &lt; selectEnd;
                swPaint.setPaintBeforeDraw(selected ? selectColor : this.paint, this.tx, bx, by, bw, bh);
                this.drawGlyph(strike, gl, i, glyphTx, drawAsMasks, x, y);
            }
        }
    }

    private void drawGlyph(FontStrike strike, GlyphList gl, int idx, BaseTransform glyphTx,
                           boolean drawAsMasks, float x, float y)
    {

        final Glyph g = strike.getGlyph(gl.getGlyphCode(idx));
        if (drawAsMasks) {
            final Point2D pt = new Point2D((float)(x + tx.getMxt() + gl.getPosX(idx)),
                                           (float)(y + tx.getMyt() + gl.getPosY(idx)));
            int subPixel = strike.getQuantizedPosition(pt);
            final byte pixelData[] = g.getPixelData(subPixel);
            if (pixelData != null) {
                final int intPosX = g.getOriginX() + (int)pt.x;
                final int intPosY = g.getOriginY() + (int)pt.y;
                if (g.isLCDGlyph()) {
                    this.pr.fillLCDAlphaMask(pixelData, intPosX, intPosY,
                            g.getWidth(), g.getHeight(),
                            0, g.getWidth());
                } else {
                    this.pr.fillAlphaMask(pixelData, intPosX, intPosY,
                            g.getWidth(), g.getHeight(),
                            0, g.getWidth());
                }
            }
        } else {
            Shape shape = g.getShape();
            if (shape != null) {
                glyphTx.setTransform(tx);
                glyphTx.deriveWithTranslation(x + gl.getPosX(idx), y + gl.getPosY(idx));
                this.paintShapePaintAlreadySet(shape, null, glyphTx);
            }
        }
    }

    public void drawTexture(Texture tex, float x, float y, float w, float h) {
        if (PrismSettings.debug) {
            System.out.printf(&quot;+ drawTexture1, x: %f, y: %f, w: %f, h: %f\n&quot;, x, y, w, h);
        }
        this.drawTexture(tex, x, y, x + w, y + h, 0, 0, w, h);
    }

    public void drawTexture(Texture tex,
                            float dx1, float dy1, float dx2, float dy2,
                            float sx1, float sy1, float sx2, float sy2)
    {
        this.drawTexture(tex, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_KEEP,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_KEEP);
    }

    private void drawTexture(Texture tex,
                             float dx1, float dy1, float dx2, float dy2,
                             float sx1, float sy1, float sx2, float sy2,
                             int lEdge, int rEdge, int tEdge, int bEdge) {
        final int imageMode;
        final float compositeAlpha = swPaint.getCompositeAlpha();
        if (compositeAlpha == 1f) {
            imageMode = RendererBase.IMAGE_MODE_NORMAL;
        } else {
            imageMode = RendererBase.IMAGE_MODE_MULTIPLY;
            this.pr.setColor(255, 255, 255, (int)(255 * compositeAlpha));
        }
        this.drawTexture(tex, imageMode, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, lEdge, rEdge, tEdge, bEdge);
    }

    private void drawTexture(Texture tex, int imageMode,
                            float dx1, float dy1, float dx2, float dy2,
                            float sx1, float sy1, float sx2, float sy2,
                            int lEdge, int rEdge, int tEdge, int bEdge) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ drawTexture: &quot; + tex + &quot;, imageMode: &quot; + imageMode +
                    &quot;, tex.w: &quot; + tex.getPhysicalWidth() + &quot;, tex.h: &quot; + tex.getPhysicalHeight() +
                    &quot;, tex.cw: &quot; + tex.getContentWidth() + &quot;, tex.ch: &quot; + tex.getContentHeight());
            System.out.println(&quot;target: &quot; + target + &quot; t.w: &quot; + target.getPhysicalWidth() + &quot;, t.h: &quot; + target.getPhysicalHeight() +
                    &quot;, t.dims: &quot; + target.getDimensions());
            System.out.println(&quot;GR: &quot; + this);
            System.out.println(&quot;dx1:&quot; + dx1 + &quot; dy1:&quot; + dy1 + &quot; dx2:&quot; + dx2 + &quot; dy2:&quot; + dy2);
            System.out.println(&quot;sx1:&quot; + sx1 + &quot; sy1:&quot; + sy1 + &quot; sx2:&quot; + sx2 + &quot; sy2:&quot; + sy2);
            System.out.println(&quot;Clip: &quot; + finalClip);
            System.out.println(&quot;Composite rule: &quot; + compositeMode);
        }

        final SWArgbPreTexture swTex = (SWArgbPreTexture) tex;
        int data[] = swTex.getDataNoClone();

        final RectBounds srcBBox = new RectBounds(Math.min(dx1, dx2), Math.min(dy1, dy2),
                Math.max(dx1, dx2), Math.max(dy1, dy2));
        final RectBounds dstBBox = new RectBounds();
        tx.transform(srcBBox, dstBBox);

        final Transform6 piscesTx = swPaint.computeDrawTexturePaintTransform(this.tx,
                dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2);

        if (PrismSettings.debug) {
            System.out.println(&quot;tx: &quot; + tx);
            System.out.println(&quot;piscesTx: &quot; + piscesTx);

            System.out.println(&quot;srcBBox: &quot; + srcBBox);
            System.out.println(&quot;dstBBox: &quot; + dstBBox);
        }

        // texture coordinates range
        final int txMin = Math.max(0, SWUtils.fastFloor(Math.min(sx1, sx2)));
        final int tyMin = Math.max(0, SWUtils.fastFloor(Math.min(sy1, sy2)));
        final int txMax = Math.min(tex.getContentWidth() - 1, SWUtils.fastCeil(Math.max(sx1, sx2)) - 1);
        final int tyMax = Math.min(tex.getContentHeight() - 1, SWUtils.fastCeil(Math.max(sy1, sy2)) - 1);

        this.pr.drawImage(RendererBase.TYPE_INT_ARGB_PRE, imageMode,
                data, tex.getContentWidth(), tex.getContentHeight(),
                swTex.getOffset(), tex.getPhysicalWidth(),
                piscesTx,
                tex.getWrapMode() == Texture.WrapMode.REPEAT,
                (int)(SWUtils.TO_PISCES * dstBBox.getMinX()), (int)(SWUtils.TO_PISCES * dstBBox.getMinY()),
                (int)(SWUtils.TO_PISCES * dstBBox.getWidth()), (int)(SWUtils.TO_PISCES * dstBBox.getHeight()),
                lEdge, rEdge, tEdge, bEdge,
                txMin, tyMin, txMax, tyMax,
                swTex.hasAlpha());

        if (PrismSettings.debug) {
            System.out.println(&quot;* drawTexture, DONE&quot;);
        }
    }

    @Override
    public void drawTexture3SliceH(Texture tex,
                                   float dx1, float dy1, float dx2, float dy2,
                                   float sx1, float sy1, float sx2, float sy2,
                                   float dh1, float dh2, float sh1, float sh2)
    {
        drawTexture(tex, dx1, dy1, dh1, dy2, sx1, sy1, sh1, sy2,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_PAD,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_KEEP);
        drawTexture(tex, dh1, dy1, dh2, dy2, sh1, sy1, sh2, sy2,
                RendererBase.IMAGE_FRAC_EDGE_TRIM, RendererBase.IMAGE_FRAC_EDGE_PAD,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_KEEP);
        drawTexture(tex, dh2, dy1, dx2, dy2, sh2, sy1, sx2, sy2,
                RendererBase.IMAGE_FRAC_EDGE_TRIM, RendererBase.IMAGE_FRAC_EDGE_KEEP,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_KEEP);
    }

    @Override
    public void drawTexture3SliceV(Texture tex,
                                   float dx1, float dy1, float dx2, float dy2,
                                   float sx1, float sy1, float sx2, float sy2,
                                   float dv1, float dv2, float sv1, float sv2)
    {
        drawTexture(tex, dx1, dy1, dx2, dv1, sx1, sy1, sx2, sv1,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_KEEP,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_PAD);
        drawTexture(tex, dx1, dv1, dx2, dv2, sx1, sv1, sx2, sv2,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_KEEP,
                RendererBase.IMAGE_FRAC_EDGE_TRIM, RendererBase.IMAGE_FRAC_EDGE_PAD);
        drawTexture(tex, dx1, dv2, dx2, dy2, sx1, sv2, sx2, sy2,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_KEEP,
                RendererBase.IMAGE_FRAC_EDGE_TRIM, RendererBase.IMAGE_FRAC_EDGE_KEEP);
    }

    @Override
    public void drawTexture9Slice(Texture tex,
                                  float dx1, float dy1, float dx2, float dy2,
                                  float sx1, float sy1, float sx2, float sy2,
                                  float dh1, float dv1, float dh2, float dv2,
                                  float sh1, float sv1, float sh2, float sv2)
    {
        drawTexture(tex, dx1, dy1, dh1, dv1, sx1, sy1, sh1, sv1,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_PAD,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_PAD);
        drawTexture(tex, dh1, dy1, dh2, dv1, sh1, sy1, sh2, sv1,
                RendererBase.IMAGE_FRAC_EDGE_TRIM, RendererBase.IMAGE_FRAC_EDGE_PAD,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_PAD);
        drawTexture(tex, dh2, dy1, dx2, dv1, sh2, sy1, sx2, sv1,
                RendererBase.IMAGE_FRAC_EDGE_TRIM, RendererBase.IMAGE_FRAC_EDGE_KEEP,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_PAD);

        drawTexture(tex, dx1, dv1, dh1, dv2, sx1, sv1, sh1, sv2,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_PAD,
                RendererBase.IMAGE_FRAC_EDGE_TRIM, RendererBase.IMAGE_FRAC_EDGE_PAD);
        drawTexture(tex, dh1, dv1, dh2, dv2, sh1, sv1, sh2, sv2,
                RendererBase.IMAGE_FRAC_EDGE_TRIM, RendererBase.IMAGE_FRAC_EDGE_PAD,
                RendererBase.IMAGE_FRAC_EDGE_TRIM, RendererBase.IMAGE_FRAC_EDGE_PAD);
        drawTexture(tex, dh2, dv1, dx2, dv2, sh2, sv1, sx2, sv2,
                RendererBase.IMAGE_FRAC_EDGE_TRIM, RendererBase.IMAGE_FRAC_EDGE_KEEP,
                RendererBase.IMAGE_FRAC_EDGE_TRIM, RendererBase.IMAGE_FRAC_EDGE_PAD);

        drawTexture(tex, dx1, dv2, dh1, dy2, sx1, sv2, sh1, sy2,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_PAD,
                RendererBase.IMAGE_FRAC_EDGE_TRIM, RendererBase.IMAGE_FRAC_EDGE_KEEP);
        drawTexture(tex, dh1, dv2, dh2, dy2, sh1, sv2, sh2, sy2,
                RendererBase.IMAGE_FRAC_EDGE_TRIM, RendererBase.IMAGE_FRAC_EDGE_PAD,
                RendererBase.IMAGE_FRAC_EDGE_TRIM, RendererBase.IMAGE_FRAC_EDGE_KEEP);
        drawTexture(tex, dh2, dv2, dx2, dy2, sh2, sv2, sx2, sy2,
                RendererBase.IMAGE_FRAC_EDGE_TRIM, RendererBase.IMAGE_FRAC_EDGE_KEEP,
                RendererBase.IMAGE_FRAC_EDGE_TRIM, RendererBase.IMAGE_FRAC_EDGE_KEEP);
    }

    public void drawTextureVO(Texture tex,
                              float topopacity, float botopacity,
                              float dx1, float dy1, float dx2, float dy2,
                              float sx1, float sy1, float sx2, float sy2)
    {
        if (PrismSettings.debug) {
            System.out.println(&quot;* drawTextureVO&quot;);
        }
        final int[] fractions = { 0x0000, 0x10000 };
        final int[] argb = { 0xffffff | (((int)(topopacity * 255)) &lt;&lt; 24),
                             0xffffff | (((int)(botopacity * 255)) &lt;&lt; 24) };
        final Transform6 t6 = new Transform6();
        SWUtils.convertToPiscesTransform(this.tx, t6);
        this.pr.setLinearGradient(0, (int)(SWUtils.TO_PISCES * dy1), 0, (int)(SWUtils.TO_PISCES * dy2), fractions, argb,
                                  GradientColorMap.CYCLE_NONE, t6);
        this.drawTexture(tex, RendererBase.IMAGE_MODE_MULTIPLY, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_KEEP,
                RendererBase.IMAGE_FRAC_EDGE_KEEP, RendererBase.IMAGE_FRAC_EDGE_KEEP);
    }

    public void drawTextureRaw(Texture tex,
                               float dx1, float dy1, float dx2, float dy2,
                               float tx1, float ty1, float tx2, float ty2)
    {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ drawTextureRaw&quot;);
        }

        int w = tex.getContentWidth();
        int h = tex.getContentHeight();
        tx1 *= w;
        ty1 *= h;
        tx2 *= w;
        ty2 *= h;
        drawTexture(tex, dx1, dy1, dx2, dy2, tx1, ty1, tx2, ty2);
    }

    public void drawMappedTextureRaw(Texture tex,
                                     float dx1, float dy1, float dx2, float dy2,
                                     float tx11, float ty11, float tx21, float ty21,
                                     float tx12, float ty12, float tx22, float ty22)
    {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ drawMappedTextureRaw&quot;);
        }

        final double _mxx, _myx, _mxy, _myy, _mxt, _myt;
        _mxx = tx.getMxx();
        _myx = tx.getMyx();
        _mxy = tx.getMxy();
        _myy = tx.getMyy();
        _mxt = tx.getMxt();
        _myt = tx.getMyt();

        try {
            final float mxx = tx21-tx11;
            final float myx = ty21-ty11;
            final float mxy = tx12-tx11;
            final float myy = ty12-ty11;

            final BaseTransform tmpTx = new Affine2D(mxx, myx, mxy, myy, tx11, ty11);
            tmpTx.invert();

            tx.setToIdentity();
            tx.deriveWithTranslation(dx1, dy1);
            tx.deriveWithConcatenation(dx2 - dx1, 0, 0, dy2 - dy2, 0, 0);
            tx.deriveWithConcatenation(tmpTx);
            this.drawTexture(tex, 0, 0, 1, 1, 0, 0, tex.getContentWidth(), tex.getContentHeight());
        } catch (NoninvertibleTransformException e) { }

        tx.restoreTransform(_mxx, _myx, _mxy, _myy, _mxt, _myt);
    }

    public boolean canReadBack() {
        return true;
    }

    public RTTexture readBack(Rectangle view) {
        if (PrismSettings.debug) {
            System.out.println(&quot;+ readBack, rect: &quot; + view + &quot;, target.dims: &quot; + target.getDimensions());
        }

        final int w = Math.max(1, view.width);
        final int h = Math.max(1, view.height);
        final SWRTTexture rbb = context.validateRBBuffer(w, h);

        if (view.isEmpty()) {
            return rbb;
        }

        final int pixels[] = rbb.getDataNoClone();
        this.target.getSurface().getRGB(pixels, 0, rbb.getPhysicalWidth(), view.x, view.y, w, h);
        return rbb;
    }

    public void releaseReadBackBuffer(RTTexture view) {
    }

    public void setState3D(boolean flag) {
    }

    public boolean isState3D() {
        return false;
    }

    public void setup3DRendering() {
    }

    @Override
    public void setPixelScaleFactors(float pixelScaleX, float pixelScaleY) {
        this.pixelScaleX = pixelScaleX;
    }

    @Override
    public float getPixelScaleFactorX() {
        return pixelScaleX;
    }

    @Override
    public float getPixelScaleFactorY() {
        return pixelScaleY;
    }

    @Override
    public void setLights(NGLightBase[] lights) {
        // Light are not supported by SW pipeline
    }

    @Override
    public NGLightBase[] getLights() {
        // Light are not supported by SW pipeline
        return null;
    }

    @Override
    public void blit(RTTexture srcTex, RTTexture dstTex,
                    int srcX0, int srcY0, int srcX1, int srcY1,
                    int dstX0, int dstY0, int dstX1, int dstY1) {
        Graphics g = dstTex.createGraphics();
        g.drawTexture(srcTex,
                      dstX0, dstY0, dstX1, dstY1,
                      srcX0, srcY0, srcX1, srcY1);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/css/CompoundSelector.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2008, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.css;

import com.sun.javafx.css.Combinator;
import com.sun.javafx.css.PseudoClassState;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;


/**
 * A compound selector which behaves according to the CSS standard. The selector is
 * composed of one or more &lt;code&gt;Selectors&lt;/code&gt;, along with an array of
 * &lt;code&gt;CompoundSelectorRelationships&lt;/code&gt; indicating the required relationship at each
 * stage.  There must be exactly one less &lt;code&gt;Combinator&lt;/code&gt; than
 * there are selectors.
 * &lt;p&gt;
 * For example, the parameters &lt;code&gt;[selector1, selector2, selector3]&lt;/code&gt;
 * and &lt;code&gt;[Combinator.CHILD, Combinator.DESCENDANT]&lt;/code&gt; will match
 * a component when all of the following conditions hold:
 * &lt;ol&gt;
 * &lt;li&gt;The component itself is matched by selector3
 * &lt;li&gt;The component has an ancestor which is matched by selector2
 * &lt;li&gt;The ancestor matched in step 2 is a direct CHILD of a component
 * matched by selector1
 * &lt;/ol&gt;
 * In other words, the compound selector specified above is (in CSS syntax)
 * &lt;code&gt;selector1 &amp;gt; selector2 selector3&lt;/code&gt;.  The greater-than (&amp;gt;)
 * between selector1 and selector2 specifies a direct CHILD, whereas the
 * whitespace between selector2 and selector3 corresponds to
 * &lt;code&gt;Combinator.DESCENDANT&lt;/code&gt;.
 *
 * @since 9
 */
final public class CompoundSelector extends Selector {

    private final List&lt;SimpleSelector&gt; selectors;
    /**
     * The selectors that make up this compound selector
     * @return Immutable List&amp;lt;SimpleSelector&amp;gt;
     */
    public List&lt;SimpleSelector&gt; getSelectors() {
        return selectors;
    }

    private final List&lt;Combinator&gt; relationships;
    // /**
    //  * The relationships between the selectors
    //  * @return Immutable List&amp;lt;Combinator&amp;gt;
    //  */
    // public List&lt;Combinator&gt; getRelationships() {
    //     return relationships;
    // }

    /**
     * Creates a &lt;code&gt;CompoundSelector&lt;/code&gt; from a list of selectors and a
     * list of &lt;code&gt;Combinator&lt;/code&gt; relationships.  There must be exactly one
     * less &lt;code&gt;Combinator&lt;/code&gt; than there are selectors.
     */
    CompoundSelector(List&lt;SimpleSelector&gt; selectors, List&lt;Combinator&gt; relationships) {
        this.selectors =
            (selectors != null)
                ? Collections.unmodifiableList(selectors)
                : Collections.EMPTY_LIST;
        this.relationships =
            (relationships != null)
                ? Collections.unmodifiableList(relationships)
                : Collections.EMPTY_LIST;
    }

    private CompoundSelector() {
        this(null, null);
    }


    @Override public Match createMatch() {
        final PseudoClassState allPseudoClasses = new PseudoClassState();
        int idCount = 0;
        int styleClassCount = 0;

        for(int n=0, nMax=selectors.size(); n&lt;nMax; n++) {
            Selector sel = selectors.get(n);
            Match match = sel.createMatch();
            allPseudoClasses.addAll(match.pseudoClasses);
            idCount += match.idCount;
            styleClassCount += match.styleClassCount;
        }

        return new Match(this, allPseudoClasses, idCount, styleClassCount);
    }

    @Override public boolean applies(final Styleable styleable) {
        return applies(styleable, selectors.size()-1, null, 0);
    }

    @Override public boolean applies(final Styleable styleable, Set&lt;PseudoClass&gt;[] triggerStates, int depth) {

        assert (triggerStates == null || depth &lt; triggerStates.length);
        if (triggerStates != null &amp;&amp; triggerStates.length &lt;= depth) {
            return false;
        }

        //
        // We only care about pseudo-class if the selector applies. But in
        // the case of a compound selector, we don't know whether it applies
        // until all the selectors have been checked (in the worse case). So
        // the setting of pseudo-class has to be deferred until we know
        // that this compound selector applies. So we'll send a new
        // PseudoClassSet[] and if the compound selector applies,
        // just copy the state back.
        //
        final Set&lt;PseudoClass&gt;[] tempStates = triggerStates != null
                ? new PseudoClassState[triggerStates.length] : null;

        final boolean applies = applies(styleable, selectors.size()-1, tempStates, depth);

        if (applies &amp;&amp; tempStates != null) {

            for(int n=0; n&lt;triggerStates.length; n++) {

                final Set&lt;PseudoClass&gt; pseudoClassOut = triggerStates[n];
                final Set&lt;PseudoClass&gt; pseudoClassIn = tempStates[n];

                if (pseudoClassOut != null) {
                    pseudoClassOut.addAll(pseudoClassIn);
                } else {
                    triggerStates[n] = pseudoClassIn;
                }

            }
        }
        return applies;
    }

    private boolean applies(final Styleable styleable, final int index, Set&lt;PseudoClass&gt;[] triggerStates, int depth) {
        // If the index is &lt; 0 then we know we don't apply
        if (index &lt; 0) return false;

        // Simply check the selector associated with this index and see if it
        // applies to the Node
        if (! selectors.get(index).applies(styleable, triggerStates, depth)) return false;

        // If there are no more selectors to check (ie: index == 0) then we
        // know we know we apply
        if (index == 0) return true;

        // We have not yet checked all the selectors in this CompoundSelector,
        // so now we need to find the next parent and try again. If the
        // relationship between this selector and its ancestor selector is
        // &quot;CHILD&quot; then it is required that the parent scenegraph node match
        // the ancestor selector. Otherwise, we just walk up the scenegraph
        // until we find an ancestor node that matches the selector. If we
        // manage to walk all the way to the top without having satisfied all
        // of the selectors, then we know it doesn't apply.
        final Combinator relationship = relationships.get(index-1);
        if (relationship == Combinator.CHILD) {
            final Styleable parent = styleable.getStyleableParent();
            if (parent == null) return false;
            // If this call succeeds, then all preceding selectors will have
            // matched due to the recursive nature of the call
            return applies(parent, index - 1, triggerStates, ++depth);
        } else {
             Styleable parent = styleable.getStyleableParent();
            while (parent != null) {
                boolean answer = applies(parent, index - 1, triggerStates, ++depth);
                // If a call to stateMatches succeeded, then we know that
                // all preceding selectors will have also matched.
                if (answer) return true;
                // Otherwise we need to get the next parent and try again
                parent = parent.getStyleableParent();
            }
        }
        return false;
    }

    @Override public boolean stateMatches(final Styleable styleable, Set&lt;PseudoClass&gt; states) {
        return stateMatches(styleable, states, selectors.size()-1);
    }

    private boolean stateMatches(Styleable styleable, Set&lt;PseudoClass&gt; states, int index) {
        // If the index is &lt; 0 then we know we don't match
        if (index &lt; 0) return false;

        // Simply check the selector associated with this index and see if it
        // matches the Node and states provided.
        if (! selectors.get(index).stateMatches(styleable, states)) return false;

        // If there are no more selectors to match (ie: index == 0) then we
        // know we have successfully matched
        if (index == 0) return true;

        // We have not yet checked all the selectors in this CompoundSelector,
        // so now we need to find the next parent and try again. If the
        // relationship between this selector and its ancestor selector is
        // &quot;CHILD&quot; then it is required that the parent scenegraph node match
        // the ancestor selector. Otherwise, we just walk up the scenegraph
        // until we find an ancestor node that matches the selector. If we
        // manage to walk all the way to the top without having satisfied all
        // of the selectors, then we know it doesn't match.
        final Combinator relationship = relationships.get(index - 1);
        if (relationship == Combinator.CHILD) {
            final Styleable parent = styleable.getStyleableParent();
            if (parent == null) return false;
            if (selectors.get(index-1).applies(parent)) {
                // If this call succeeds, then all preceding selectors will have
                // matched due to the recursive nature of the call
                Set&lt;PseudoClass&gt; parentStates = parent.getPseudoClassStates();
                return stateMatches(parent, parentStates, index - 1);
            }
        } else {
            Styleable parent = styleable.getStyleableParent();
            while (parent != null) {
                if (selectors.get(index-1).applies(parent)) {
                    Set&lt;PseudoClass&gt; parentStates = parent.getPseudoClassStates();
                    return stateMatches(parent, parentStates, index - 1);
                }
                // Otherwise we need to get the next parent and try again
                parent = parent.getStyleableParent();
            }
        }

        return false;
    }

    private  int hash = -1;

    /* Hash code is used in Style's hash code and Style's hash
       code is used by StyleHelper */
    @Override public int hashCode() {
        if (hash == -1) {
            for (int i = 0, max=selectors.size(); i&lt;max; i++)
                hash = 31 * (hash + selectors.get(i).hashCode());
            for (int i = 0, max=relationships.size(); i&lt;max; i++)
                hash = 31 * (hash + relationships.get(i).hashCode());
        }
        return hash;
    }

    @Override public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final CompoundSelector other = (CompoundSelector) obj;
        if (other.selectors.size() != selectors.size()) return false;
        // Avoid ArrayList equals since it uses enhanced for loop
        for (int i = 0, max=selectors.size(); i&lt;max; i++) {
            if (!other.selectors.get(i).equals(selectors.get(i))) return false;
        }
<A NAME="29"></A>        // Avoid ArrayList equals since it uses enhanced for loop
        if (other.relationships.size() != relationships.size()) return false;
        for (int i = 0, max=relationships.size(); i&lt;max; i++) {
            if (!<FONT color="#faafba"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#29',2,'match51-top.html#29',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>other.relationships.get(i).equals(relationships.get(i))) return false;
        }
        return true;
    }

    @Overrid</B></FONT>e public String toString() {
        StringBuilder sbuf = new StringBuilder();
        sbuf.append(selectors.get(0));
        for(int n=1; n&lt;selectors.size(); n++) {
            sbuf.append(relationships.get(n-1));
            sbuf.append(selectors.get(n));
        }
        return sbuf.toString();
    }

    @Override protected final void writeBinary(final DataOutputStream os, final StyleConverter.StringStore stringStore)
            throws IOException
    {
        super.writeBinary(os, stringStore);
        os.writeShort(selectors.size());
        for (int n=0; n&lt; selectors.size(); n++) selectors.get(n).writeBinary(os,stringStore);
        os.writeShort(relationships.size());
        for (int n=0; n&lt; relationships.size(); n++) os.writeByte(relationships.get(n).ordinal());
    }

    static CompoundSelector readBinary(int bssVersion, final DataInputStream is, final String[] strings)
            throws IOException
    {

        final int nSelectors = is.readShort();
        final List&lt;SimpleSelector&gt; selectors = new ArrayList&lt;SimpleSelector&gt;();
        for (int n=0; n&lt;nSelectors; n++) {
            selectors.add((SimpleSelector)Selector.readBinary(bssVersion, is,strings));
        }

        final int nRelationships = is.readShort();

        final List&lt;Combinator&gt; relationships = new ArrayList&lt;Combinator&gt;();
        for (int n=0; n&lt;nRelationships; n++) {
            final int ordinal = is.readByte();
            if (ordinal == Combinator.CHILD.ordinal())
                relationships.add(Combinator.CHILD);
            else if (ordinal == Combinator.DESCENDANT.ordinal())
                relationships.add(Combinator.DESCENDANT);
            else {
                assert false : &quot;error deserializing CompoundSelector: Combinator = &quot; + ordinal;
                relationships.add(Combinator.DESCENDANT);
            }
        }
        return new CompoundSelector(selectors, relationships);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/effect/Lighting.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.effect;

import javafx.beans.Observable;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.scene.Node;

import com.sun.javafx.util.Utils;
import com.sun.javafx.effect.EffectDirtyBits;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.BoundsAccessor;
import com.sun.scenario.effect.PhongLighting;

/**
 * An effect that simulates a light source shining on the given content,
 * which can be used to give flat objects a more realistic, three-dimensional
 * appearance.
 *
 * &lt;p&gt;
 * Example:
 * &lt;pre&gt;{@code
 * Light.Distant light = new Light.Distant();
 * light.setAzimuth(-135.0);
 *
 * Lighting lighting = new Lighting();
 * lighting.setLight(light);
 * lighting.setSurfaceScale(5.0);
 *
 * Text text = new Text();
 * text.setText(&quot;JavaFX!&quot;);
 * text.setFill(Color.STEELBLUE);
 * text.setFont(Font.font(null, FontWeight.BOLD, 60));
 * text.setX(10.0);
 * text.setY(10.0);
 * text.setTextOrigin(VPos.TOP);
 *
 * text.setEffect(lighting);
 * }&lt;/pre&gt;
 * &lt;p&gt; The code above produces the following: &lt;/p&gt;
 * &lt;p&gt;
 * &lt;img src=&quot;doc-files/lighting.png&quot; alt=&quot;The visual effect of Lighting on text&quot;&gt;
 * &lt;/p&gt;
 * @since JavaFX 2.0
 */
<A NAME="3"></A>public class Lighting extends Effect {
    @Override
    com.sun.scenario.effect.PhongLighting createPeer() {
        return <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#3',2,'match51-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new PhongLighting(getLightInternal().getPeer());
    };

    /**
     * Creates a new instance of Lighting with default parameters.
     */
    public Lighting() {
        Shadow shadow = new</B></FONT> Shadow();
        shadow.setRadius(10.0f);
        setBumpInput(shadow);
    }

    /**
     * Creates a new instance of Lighting with the specified light.
     * @param light the light source for this {@code Lighting} effect
     * @since JavaFX 2.1
     */
    public Lighting(Light light) {
        Shadow shadow = new Shadow();
        shadow.setRadius(10.0f);
        setBumpInput(shadow);
        setLight(light);
    }

    private final Light defaultLight = new Light.Distant();

    /**
     * The light source for this {@code Lighting} effect.
     */
    private ObjectProperty&lt;Light&gt; light = new ObjectPropertyBase&lt;Light&gt;(new Light.Distant()) {
        @Override
        public void invalidated() {
            markDirty(EffectDirtyBits.EFFECT_DIRTY);
            effectBoundsChanged();
        }

        @Override
        public Object getBean() {
            return Lighting.this;
        }

        @Override
        public String getName() {
            return &quot;light&quot;;
        }
    };


    public final void setLight(Light value) {
        lightProperty().set(value);
    }

    public final Light getLight() {
        return light.get();
    }

    public final ObjectProperty&lt;Light&gt; lightProperty() {
        return light;
    }

    private final LightChangeListener lightChangeListener = new LightChangeListener();

    @Override
    Effect copy() {
        Lighting lighting = new Lighting(this.getLight());
        lighting.setBumpInput(this.getBumpInput());
        lighting.setContentInput(this.getContentInput());
        lighting.setDiffuseConstant(this.getDiffuseConstant());
        lighting.setSpecularConstant(this.getSpecularConstant());
        lighting.setSpecularExponent(this.getSpecularExponent());
        lighting.setSurfaceScale(this.getSurfaceScale());
        return lighting;
    }
    private class LightChangeListener extends EffectChangeListener {
        Light light;

        public void register(Light value) {
            light = value;
            super.register(light == null ? null : light.effectDirtyProperty());
        }

        @Override
        public void invalidated(Observable valueModel) {
            if (light.isEffectDirty()) {
                markDirty(EffectDirtyBits.EFFECT_DIRTY);
                effectBoundsChanged();
            }
        }
    };
    /**
     * The optional bump map input.
     * If not specified, a bump map will be automatically generated
     * from the default input.
     * If set to {@code null}, or left unspecified, a graphical image of
     * the {@code Node} to which the {@code Effect} is attached will be
     * used to generate a default bump map.
     * @defaultValue a Shadow effect with a radius of 10
     */
    private ObjectProperty&lt;Effect&gt; bumpInput;


    public final void setBumpInput(Effect value) {
        bumpInputProperty().set(value);
    }

    public final Effect getBumpInput() {
        return bumpInput == null ? null : bumpInput.get();
    }

    public final ObjectProperty&lt;Effect&gt; bumpInputProperty() {
        if (bumpInput == null) {
            bumpInput = new EffectInputProperty(&quot;bumpInput&quot;);
        }
        return bumpInput;
    }

    /**
     * The content input for this {@code Effect}.
     * If set to {@code null}, or left unspecified, a graphical image of
     * the {@code Node} to which the {@code Effect} is attached will be
     * used as the input.
     * @defaultValue null
     */
    private ObjectProperty&lt;Effect&gt; contentInput;


    public final void setContentInput(Effect value) {
        contentInputProperty().set(value);
    }

    public final Effect getContentInput() {
        return contentInput == null ? null : contentInput.get();
    }

    public final ObjectProperty&lt;Effect&gt; contentInputProperty() {
        if (contentInput == null) {
            contentInput = new EffectInputProperty(&quot;contentInput&quot;);
        }
        return contentInput;
    }

    @Override
    boolean checkChainContains(Effect e) {
        Effect localBumpInput = getBumpInput();
        Effect localContentInput = getContentInput();
        if (localContentInput == e || localBumpInput == e)
            return true;
        if (localContentInput != null &amp;&amp; localContentInput.checkChainContains(e))
            return true;
        if (localBumpInput != null &amp;&amp; localBumpInput.checkChainContains(e))
            return true;

        return false;
    }

    /**
     * The diffuse constant.
     * &lt;pre&gt;
     *       Min: 0.0
     *       Max: 2.0
     *   Default: 1.0
     *  Identity: n/a
     * &lt;/pre&gt;
     * @defaultValue 1.0
     */
    private DoubleProperty diffuseConstant;


    public final void setDiffuseConstant(double value) {
        diffuseConstantProperty().set(value);
    }

    public final double getDiffuseConstant() {
        return diffuseConstant == null ? 1 : diffuseConstant.get();
    }

    public final DoubleProperty diffuseConstantProperty() {
        if (diffuseConstant == null) {
            diffuseConstant = new DoublePropertyBase(1) {

                @Override
                public void invalidated() {
                    markDirty(EffectDirtyBits.EFFECT_DIRTY);
                }

                @Override
                public Object getBean() {
                    return Lighting.this;
                }

                @Override
                public String getName() {
                    return &quot;diffuseConstant&quot;;
                }
            };
        }
        return diffuseConstant;
    }

    /**
     * The specular constant.
     * &lt;pre&gt;
     *       Min: 0.0
     *       Max: 2.0
     *   Default: 0.3
     *  Identity: n/a
     * &lt;/pre&gt;
     * @defaultValue 0.3
     */
    private DoubleProperty specularConstant;


    public final void setSpecularConstant(double value) {
        specularConstantProperty().set(value);
    }

    public final double getSpecularConstant() {
        return specularConstant == null ? 0.3 : specularConstant.get();
    }

    public final DoubleProperty specularConstantProperty() {
        if (specularConstant == null) {
            specularConstant = new DoublePropertyBase(0.3) {

                @Override
                public void invalidated() {
                    markDirty(EffectDirtyBits.EFFECT_DIRTY);
                }

                @Override
                public Object getBean() {
                    return Lighting.this;
                }

                @Override
                public String getName() {
                    return &quot;specularConstant&quot;;
                }
            };
        }
        return specularConstant;
    }

    /**
     * The specular exponent.
     * &lt;pre&gt;
     *       Min:  0.0
     *       Max: 40.0
     *   Default: 20.0
     *  Identity:  n/a
     * &lt;/pre&gt;
     * @defaultValue 20.0
     */
    private DoubleProperty specularExponent;


    public final void setSpecularExponent(double value) {
        specularExponentProperty().set(value);
    }

    public final double getSpecularExponent() {
        return specularExponent == null ? 20 : specularExponent.get();
    }

    public final DoubleProperty specularExponentProperty() {
        if (specularExponent == null) {
            specularExponent = new DoublePropertyBase(20) {

                @Override
                public void invalidated() {
                    markDirty(EffectDirtyBits.EFFECT_DIRTY);
                }

                @Override
                public Object getBean() {
                    return Lighting.this;
                }

                @Override
                public String getName() {
                    return &quot;specularExponent&quot;;
                }
            };
        }
        return specularExponent;
    }

    /**
     * The surface scale factor.
     * &lt;pre&gt;
     *       Min:  0.0
     *       Max: 10.0
     *   Default:  1.5
     *  Identity:  n/a
     * &lt;/pre&gt;
     * @defaultValue 1.5
     */
    private DoubleProperty surfaceScale;


    public final void setSurfaceScale(double value) {
        surfaceScaleProperty().set(value);
    }

    public final double getSurfaceScale() {
        return surfaceScale == null ? 1.5 : surfaceScale.get();
    }

    public final DoubleProperty surfaceScaleProperty() {
        if (surfaceScale == null) {
            surfaceScale = new DoublePropertyBase(1.5) {

                @Override
                public void invalidated() {
                    markDirty(EffectDirtyBits.EFFECT_DIRTY);
                }

                @Override
                public Object getBean() {
                    return Lighting.this;
                }

                @Override
                public String getName() {
                    return &quot;surfaceScale&quot;;
                }
            };
        }
        return surfaceScale;
    }

    private Light getLightInternal() {
        Light localLight = getLight();
        return localLight == null ? defaultLight : localLight;
    }

    @Override
    void update() {
        Effect localBumpInput = getBumpInput();

        if (localBumpInput != null) {
            localBumpInput.sync();
        }

        Effect localContentInput = getContentInput();
        if (localContentInput != null) {
            localContentInput.sync();
        }

        PhongLighting peer = (PhongLighting) getPeer();
        peer.setBumpInput(localBumpInput == null ? null : localBumpInput.getPeer());
        peer.setContentInput(localContentInput == null ? null : localContentInput.getPeer());
        peer.setDiffuseConstant((float)Utils.clamp(0, getDiffuseConstant(), 2));
        peer.setSpecularConstant((float)Utils.clamp(0, getSpecularConstant(), 2));
        peer.setSpecularExponent((float)Utils.clamp(0, getSpecularExponent(), 40));
        peer.setSurfaceScale((float)Utils.clamp(0, getSurfaceScale(), 10));
        // we don't need to register on default light in case the light is null
        // because default light never changes
        lightChangeListener.register(getLight());

        getLightInternal().sync();
        peer.setLight(getLightInternal().getPeer());
    }

    @Override
    BaseBounds getBounds(BaseBounds bounds,
                         BaseTransform tx,
                         Node node,
                         BoundsAccessor boundsAccessor) {
        return getInputBounds(bounds, tx, node, boundsAccessor, getContentInput());
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/shape/Sphere.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.shape;

import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.input.PickResultChooser;
import com.sun.javafx.scene.shape.MeshHelper;
import com.sun.javafx.scene.shape.SphereHelper;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.sg.prism.NGSphere;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.geometry.Point2D;
import javafx.geometry.Point3D;
import javafx.scene.Node;
import javafx.scene.input.PickResult;
import javafx.scene.transform.Rotate;

/**
 * The {@code Sphere} class defines a 3 dimensional sphere with the specified size.
 * A {@code Sphere} is a 3D geometry primitive created with a given radius.
 * It is centered at the origin.
 *
 * @since JavaFX 8.0
 */
public class Sphere extends Shape3D {
    static {
         // This is used by classes in different packages to get access to
         // private and package private methods.
        SphereHelper.setSphereAccessor(new SphereHelper.SphereAccessor() {
            @Override
            public NGNode doCreatePeer(Node node) {
                return ((Sphere) node).doCreatePeer();
            }

            @Override
            public void doUpdatePeer(Node node) {
                ((Sphere) node).doUpdatePeer();
            }

            @Override
            public BaseBounds doComputeGeomBounds(Node node,
                    BaseBounds bounds, BaseTransform tx) {
                return ((Sphere) node).doComputeGeomBounds(bounds, tx);
            }

            @Override
            public boolean doComputeContains(Node node, double localX, double localY) {
                return ((Sphere) node).doComputeContains(localX, localY);
            }

            @Override
            public boolean doComputeIntersects(Node node, PickRay pickRay,
                    PickResultChooser pickResult) {
                return ((Sphere) node).doComputeIntersects(pickRay, pickResult);
            }
        });
    }

    static final int DEFAULT_DIVISIONS = 64;
    static final double DEFAULT_RADIUS = 1;
    private int divisions = DEFAULT_DIVISIONS;
    private TriangleMesh mesh;

    /**
     * Creates a new instance of {@code Sphere} with radius of 1.0.
     * The resolution defaults to 64 divisions along the sphere's axes.
     */
    public Sphere() {
        this(DEFAULT_RADIUS, DEFAULT_DIVISIONS);
    }

    /**
     * Creates a new instance of {@code Sphere} with the given radius.
     * The resolution defaults to 64 divisions along the sphere's axes.
     *
     * @param radius Radius
     */
    public Sphere(double radius) {
        this(radius, DEFAULT_DIVISIONS);
    }

    /**
     * Creates a new instance of {@code Sphere} with the given radius and number
     * of divisions.
     * The resolution is defined in terms of number of subdivisions along the
     * sphere's axes. More divisions lead to more finely tesselated objects.
     *
     * Note that divisions should be at least 1. Any value less than that will be
     * clamped to 1.
     *
     * @param radius Radius
     * @param divisions Divisions
     */
    public Sphere(double radius, int divisions) {
        SphereHelper.initHelper(this);
        this.divisions = divisions &lt; 1 ? 1: divisions;
        setRadius(radius);
    }

    /**
     * Defines the radius of the Sphere.
     *
     * @defaultValue 1.0
     */
    private DoubleProperty radius;

    public final void setRadius(double value) {
        radiusProperty().set(value);
    }

    public final double getRadius() {
        return radius == null ? 1 : radius.get();
    }

    public final DoubleProperty radiusProperty() {
        if (radius == null) {
            radius = new SimpleDoubleProperty(Sphere.this, &quot;radius&quot;, DEFAULT_RADIUS) {
                @Override
                public void invalidated() {
                    NodeHelper.markDirty(Sphere.this, DirtyBits.MESH_GEOM);
                    manager.invalidateSphereMesh(key);
                    key = null;
                    NodeHelper.geomChanged(Sphere.this);
                }
            };
        }
        return radius;
    }

    /**
     * Retrieves the divisions attribute use to generate this sphere.
     *
     * @return the divisions attribute.
     */
    public int getDivisions() {
        return divisions;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private NGNode doCreatePeer() {
        return new NGSphere();
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        if (NodeHelper.isDirty(this, DirtyBits.MESH_GEOM)) {
            final NGSphere pgSphere = NodeHelper.getPeer(this);
            final float r = (float) getRadius();
            if (r &lt; 0) {
                pgSphere.updateMesh(null);
            } else {
                if (key == null) {
                    key = new SphereKey(r, divisions);
                }
                mesh = manager.getSphereMesh(r, divisions, key);
                mesh.updatePG();
                pgSphere.updateMesh(mesh.getPGTriangleMesh());
            }
        }
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {
        final float r = (float) getRadius();

        if (r &lt; 0) {
            return bounds.makeEmpty();
        }

        bounds = bounds.deriveWithNewBounds(-r, -r, -r, r, r ,r);
        bounds = tx.transform(bounds, bounds);
        return bounds;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeContains(double localX, double localY) {
        double r = getRadius();
        double n2 = localX * localX + localY * localY;
        return n2 &lt;= r * r;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeIntersects(PickRay pickRay, PickResultChooser pickResult) {

        final boolean exactPicking = divisions &lt; DEFAULT_DIVISIONS &amp;&amp; mesh != null;

        final double r = getRadius();
        final Vec3d dir = pickRay.getDirectionNoClone();
        final double dirX = dir.x;
        final double dirY = dir.y;
        final double dirZ = dir.z;
        final Vec3d origin = pickRay.getOriginNoClone();
        final double originX = origin.x;
        final double originY = origin.y;
        final double originZ = origin.z;

        // Coeficients of a quadratic equation desribing intersection with sphere
        final double a = dirX * dirX + dirY * dirY + dirZ * dirZ;
        final double b = 2 * (dirX * originX + dirY * originY + dirZ * originZ);
        final double c = originX * originX + originY * originY + originZ * originZ - r * r;

        final double discriminant = b * b - 4 * a * c;
        if (discriminant &lt; 0) {
            // No real roots of the equation, missed the shape
            return false;
        }

        final double distSqrt = Math.sqrt(discriminant);
        final double q = (b &lt; 0) ? (-b - distSqrt) / 2.0 : (-b + distSqrt) / 2.0;

        double t0 = q / a;
        double t1 = c / q;

        if (t0 &gt; t1) {
            final double temp = t0;
            t0 = t1;
            t1 = temp;
        }

        final double minDistance = pickRay.getNearClip();
        final double maxDistance = pickRay.getFarClip();

        if (t1 &lt; minDistance || t0 &gt; maxDistance) {
            // the sphere is out of clipping planes
            return false;
        }

        double t = t0;
        final CullFace cullFace = getCullFace();
        if (t0 &lt; minDistance || cullFace == CullFace.FRONT) {
            if (t1 &lt;= maxDistance &amp;&amp; getCullFace() != CullFace.BACK) {
                // picking the back wall
                t = t1;
            } else {
                // we are inside the sphere with the back wall culled, but the
                // exact picking still needs to be done because the front faced
                // triangles may still be in front of us
                if (!exactPicking) {
                    return false;
                }
            }
        }

        if (Double.isInfinite(t) || Double.isNaN(t)) {
            // We've got a nonsense pick ray or sphere size.
            return false;
        }

        if (exactPicking) {
            return MeshHelper.computeIntersects(mesh, pickRay, pickResult, this, cullFace, false);
        }

        if (pickResult != null &amp;&amp; pickResult.isCloser(t)) {
            final Point3D point = PickResultChooser.computePoint(pickRay, t);

            // computing texture coords
            final Point3D proj = new Point3D(point.getX(), 0, point.getZ());
            final Point3D cross = proj.crossProduct(Rotate.Z_AXIS);
            double angle = proj.angle(Rotate.Z_AXIS);
            if (cross.getY() &gt; 0) {
                angle = 360 - angle;
            }
            Point2D txtCoords = new Point2D(1 - angle / 360, 0.5 + point.getY() / (2 * r));

            pickResult.offer(this, t, PickResult.FACE_UNDEFINED, point, txtCoords);
        }
        return true;
    }

    private static int correctDivisions(int div) {
        return ((div + 3) / 4) * 4;
    }

    static TriangleMesh createMesh(int div, float r) {
        div = correctDivisions(div);

        // NOTE: still create mesh for degenerated sphere
        final int div2 = div / 2;

        final int nPoints = div * (div2 - 1) + 2;
        final int nTPoints = (div + 1) * (div2 - 1) + div * 2;
        final int nFaces = div * (div2 - 2) * 2 + div * 2;

        final float rDiv = 1.f / div;

        float points[] = new float[nPoints * 3];
        float tPoints[] = new float[nTPoints * 2];
        int faces[] = new int[nFaces * 6];

        int pPos = 0, tPos = 0;

        for (int y = 0; y &lt; div2 - 1; ++y) {
            float va = rDiv * (y + 1 - div2 / 2) * 2 * (float) Math.PI;
            float sin_va = (float) Math.sin(va);
            float cos_va = (float) Math.cos(va);

            float ty = 0.5f + sin_va * 0.5f;
            for (int i = 0; i &lt; div; ++i) {
                double a = rDiv * i * 2 * (float) Math.PI;
                float hSin = (float) Math.sin(a);
                float hCos = (float) Math.cos(a);
                points[pPos + 0] = hSin * cos_va * r;
                points[pPos + 2] = hCos * cos_va * r;
                points[pPos + 1] = sin_va * r;
                tPoints[tPos + 0] = 1 - rDiv * i;
                tPoints[tPos + 1] = ty;
                pPos += 3;
                tPos += 2;
            }
            tPoints[tPos + 0] = 0;
            tPoints[tPos + 1] = ty;
            tPos += 2;
        }

        points[pPos + 0] = 0;
        points[pPos + 1] = -r;
        points[pPos + 2] = 0;
        points[pPos + 3] = 0;
        points[pPos + 4] = r;
        points[pPos + 5] = 0;
        pPos += 6;

        int pS = (div2 - 1) * div;

        float textureDelta = 1.f / 256;
        for (int i = 0; i &lt; div; ++i) {
            tPoints[tPos + 0] = 1.0f - rDiv * (0.5f + i);
            tPoints[tPos + 1] = textureDelta;
            tPos += 2;
        }

        for (int i = 0; i &lt; div; ++i) {
            tPoints[tPos + 0] = 1.0f - rDiv * (0.5f + i);
            tPoints[tPos + 1] = 1 - textureDelta;
            tPos += 2;
        }

        int fIndex = 0;
        for (int y = 0; y &lt; div2 - 2; ++y) {
            for (int x = 0; x &lt; div; ++x) {
                int p0 = y * div + x;
                int p1 = p0 + 1;
                int p2 = p0 + div;
                int p3 = p1 + div;

                int t0 = p0 + y;
                int t1 = t0 + 1;
                int t2 = t0 + (div + 1);
                int t3 = t1 + (div + 1);

                // add p0, p1, p2
                faces[fIndex + 0] = p0;
                faces[fIndex + 1] = t0;
                faces[fIndex + 2] = p1 % div == 0 ? p1 - div : p1;
                faces[fIndex + 3] = t1;
                faces[fIndex + 4] = p2;
                faces[fIndex + 5] = t2;
                fIndex += 6;

                // add p3, p2, p1
                faces[fIndex + 0] = p3 % div == 0 ? p3 - div : p3;
                faces[fIndex + 1] = t3;
                faces[fIndex + 2] = p2;
                faces[fIndex + 3] = t2;
                faces[fIndex + 4] = p1 % div == 0 ? p1 - div : p1;
                faces[fIndex + 5] = t1;
                fIndex += 6;
            }
        }

        int p0 = pS;
        int tB = (div2 - 1) * (div + 1);
        for (int x = 0; x &lt; div; ++x) {
            int p2 = x, p1 = x + 1, t0 = tB + x;
            faces[fIndex + 0] = p0;
            faces[fIndex + 1] = t0;
            faces[fIndex + 2] = p1 == div ? 0 : p1;
            faces[fIndex + 3] = p1;
            faces[fIndex + 4] = p2;
            faces[fIndex + 5] = p2;
            fIndex += 6;
        }

        p0 = p0 + 1;
        tB = tB + div;
        int pB = (div2 - 2) * div;

        for (int x = 0; x &lt; div; ++x) {
            int p1 = pB + x, p2 = pB + x + 1, t0 = tB + x;
            int t1 = (div2 - 2) * (div + 1) + x, t2 = t1 + 1;
            faces[fIndex + 0] = p0;
            faces[fIndex + 1] = t0;
            faces[fIndex + 2] = p1;
            faces[fIndex + 3] = t1;
            faces[fIndex + 4] = p2 % div == 0 ? p2 - div : p2;
            faces[fIndex + 5] = t2;
            fIndex += 6;
        }
<A NAME="33"></A>
        TriangleMesh m = new TriangleMesh(true);
        m.getPoints().setAll(points);
        <FONT color="#736aff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#33',2,'match51-top.html#33',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>m.getTexCoords().setAll(tPoints);
        m.getFaces().setAll(faces);
        return m;
    }

    private static class SphereKey extends Key {

        final double radius;
        final int divisions</B></FONT>;

        private SphereKey(double radius, int divisions) {
            this.radius = radius;
            this.divisions = divisions;
        }

        @Override
        public int hashCode() {
            long bits = 7L;
            bits = 31L * bits + Double.doubleToLongBits(radius);
            bits = 31L * bits + divisions;
            return Long.hashCode(bits);
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            if (!(obj instanceof SphereKey)) {
                return false;
            }
            SphereKey other = (SphereKey) obj;
            if (divisions != other.divisions) {
                return false;
            }
            if (Double.compare(radius, other.radius) != 0) {
                return false;
            }
            return true;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/transform/Transform.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.transform;

import java.util.Iterator;

import com.sun.javafx.geometry.BoundsUtils;
import javafx.event.EventDispatchChain;

import javafx.scene.Node;

import com.sun.javafx.util.WeakReferenceQueue;
import com.sun.javafx.binding.ExpressionHelper;
import com.sun.javafx.event.EventHandlerManager;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.transform.TransformHelper;
import com.sun.javafx.scene.transform.TransformUtils;
import java.lang.ref.SoftReference;
import javafx.beans.InvalidationListener;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ChangeListener;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.event.EventType;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.geometry.Point3D;

// PENDING_DOC_REVIEW of this whole class
/**
 * This class is a base class for different affine transformations.
 * It provides factory methods for the simple transformations - rotating,
 * scaling, shearing, and translation. It allows to get the transformation
 * matrix elements for any transform.
 *
 * &lt;p&gt;Example:&lt;/p&gt;
 *
 * &lt;pre&gt;{@code
 *  Rectangle rect = new Rectangle(50,50, Color.RED);
 *  rect.getTransforms().add(new Rotate(45,0,0)); //rotate by 45 degrees
 * }&lt;/pre&gt;
 * @since JavaFX 2.0
 */
public abstract class Transform implements Cloneable, EventTarget {

    static {
        // This is used by classes in different packages to get access to
        // private and package private methods.
        TransformHelper.setTransformAccessor(new TransformHelper.TransformAccessor() {

            @Override
            public void add(Transform transform, Node node) {
                transform.add(node);
            }

            @Override
            public void remove(Transform transform, Node node) {
                transform.remove(node);
            }

            @Override
            public void apply(Transform transform, Affine3D affine3D) {
                transform.apply(affine3D);
            }

            @Override
            public BaseTransform derive(Transform transform, BaseTransform baseTransform) {
                return transform.derive(baseTransform);
            }

            @Override
            public Transform createImmutableTransform() {
                return Transform.createImmutableTransform();
            }

            @Override
            public Transform createImmutableTransform(
                    double mxx, double mxy, double mxz, double tx,
                    double myx, double myy, double myz, double ty,
                    double mzx, double mzy, double mzz, double tz) {
                return Transform.createImmutableTransform(mxx, mxy, mxz, tx,
                        myx, myy, myz, ty, mzx, mzy, mzz, tz);
            }

            @Override
            public Transform createImmutableTransform(Transform transform,
                    double mxx, double mxy, double mxz, double tx,
                    double myx, double myy, double myz, double ty,
                    double mzx, double mzy, double mzz, double tz) {
                return Transform.createImmutableTransform(transform,
                        mxx, mxy, mxz, tx, myx, myy, myz, ty, mzx, mzy, mzz, tz);
            }

            @Override
            public Transform createImmutableTransform(Transform transform,
                    Transform left, Transform right) {
                return Transform.createImmutableTransform(transform, left, right);
            }
        });
    }

    /* *************************************************************************
     *                                                                         *
     *                            Factories                                    *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns a new {@code Affine} object from 12 number
     * values representing the 6 specifiable entries of the 3x4
     * Affine transformation matrix.
     *
     * @param mxx the X coordinate scaling element of the 3x4 matrix
     * @param myx the Y coordinate shearing element of the 3x4 matrix
     * @param mxy the X coordinate shearing element of the 3x4 matrix
     * @param myy the Y coordinate scaling element of the 3x4 matrix
     * @param tx the X coordinate translation element of the 3x4 matrix
     * @param ty the Y coordinate translation element of the 3x4 matrix
     * @return a new {@code Affine} object derived from specified parameters
     */
    public static Affine affine(
        double mxx, double myx, double mxy, double myy, double tx, double ty) {
        final Affine affine = new Affine();
        affine.setMxx(mxx);
        affine.setMxy(mxy);
        affine.setTx(tx);
        affine.setMyx(myx);
        affine.setMyy(myy);
        affine.setTy(ty);
        return affine;
    }


    /**
     * Returns a new {@code Affine} object from 12 number
     * values representing the 12 specifiable entries of the 3x4
     * Affine transformation matrix.
     *
     * @param mxx the X coordinate scaling element of the 3x4 matrix
     * @param mxy the XY element of the 3x4 matrix
     * @param mxz the XZ element of the 3x4 matrix
     * @param tx the X coordinate translation element of the 3x4 matrix
     * @param myx the YX element of the 3x4 matrix
     * @param myy the Y coordinate scaling element of the 3x4 matrix
     * @param myz the YZ element of the 3x4 matrix
     * @param ty the Y coordinate translation element of the 3x4 matrix
     * @param mzx the ZX element of the 3x4 matrix
     * @param mzy the ZY element of the 3x4 matrix
     * @param mzz the Z coordinate scaling element of the 3x4 matrix
     * @param tz the Z coordinate translation element of the 3x4 matrix
     * @return a new {@code Affine} object derived from specified parameters
     */
    public static Affine affine(
        double mxx, double mxy, double mxz, double tx,
        double myx, double myy, double myz, double ty,
        double mzx, double mzy, double mzz, double tz) {
        final Affine affine = new Affine();
        affine.setMxx(mxx);
        affine.setMxy(mxy);
        affine.setMxz(mxz);
        affine.setTx(tx);
<A NAME="32"></A>        affine.setMyx(myx);
        affine.setMyy(myy);
        affine.setMyz(myz);
        <FONT color="#82cafa"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#32',2,'match51-top.html#32',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>affine.setTy(ty);
        affine.setMzx(mzx);
        affine.setMzy(mzy);
        affine.setMzz(mzz);
        affine.setTz(tz);
        return affine;
    }


    /**
     * Returns a {@code Translate} object representing a translation transformation.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Translate(x, y);
     * &lt;/pre&gt;
     * @param x the translate x value
     * @param y the translate y value
     * @return the Translate object representing a translation transformation
     */
    public static Translate translate(double x, double y) {
        final Translate translate = new Translate();
        translate.setX(x);
        translate.setY</B></FONT>(y);
        return translate;
    }


    /**
     * Returns a {@code Rotate} object that rotates coordinates around a pivot
     * point.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Rotate(angle, pivotX, pivotY);
     * &lt;/pre&gt;
     * @param angle the rotation angle
     * @param pivotX the pivot x value
     * @param pivotY the pivot y value
     * @return the Rotate object that rotates coordinates around a pivot point
     */
    public static Rotate rotate(double angle, double pivotX, double pivotY) {
        final Rotate rotate = new Rotate();
        rotate.setAngle(angle);
        rotate.setPivotX(pivotX);
        rotate.setPivotY(pivotY);
        return rotate;
    }


    /**
     * Returns a {@code Scale} object representing a scaling transformation.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Scale(x, y);
     * &lt;/pre&gt;
     * @param x the scale x value
     * @param y the scale y value
     * @return the Scale object representing a scaling transformation
     */
    public static Scale scale(double x, double y) {
        final Scale scale = new Scale();
        scale.setX(x);
        scale.setY(y);
        return scale;
    }


    /**
     * Returns a {@code Scale} object representing a scaling transformation.
     * The returned scale operation will be about the given pivot point.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Scale(x, y, pivotX, pivotY);
     * &lt;/pre&gt;
     * @param x the scale x value
     * @param y the scale y value
     * @param pivotX the pivot x value
     * @param pivotY the pivot y value
     * @return the Scale object representing a scaling transformation
     */
    public static Scale scale(double x, double y, double pivotX, double pivotY) {
        final Scale scale = new Scale();
        scale.setX(x);
        scale.setY(y);
        scale.setPivotX(pivotX);
        scale.setPivotY(pivotY);
        return scale;
    }


    /**
     * Returns a {@code Shear} object representing a shearing transformation.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Shear(x, y);
     * &lt;/pre&gt;
     * @param x the shear x value
     * @param y the shear y value
     * @return the Shear object representing a shearing transformation
     */
    public static Shear shear(double x, double y) {
        final Shear shear = new Shear();
        shear.setX(x);
        shear.setY(y);
        return shear;
    }

    /**
     * Returns a {@code Shear} object representing a shearing transformation.
     * &lt;p&gt;
     * This is equivalent to:
     * &lt;pre&gt;
     *    new Shear(x, y, pivotX, pivotY);
     * &lt;/pre&gt;
     * @param x the shear x value
     * @param y the shear y value
     * @param pivotX the pivot x value
     * @param pivotY the pivot y value
     * @return the Shear object representing a shearing transformation
     */
    public static Shear shear(double x, double y, double pivotX, double pivotY) {
        final Shear shear = new Shear();
        shear.setX(x);
        shear.setY(y);
        shear.setPivotX(pivotX);
        shear.setPivotY(pivotY);
        return shear;
    }

    /**
     * For transforms with expensive inversion we cache the inverted matrix
     * once it is needed and computed for some operation.
     */
    private SoftReference&lt;Transform&gt; inverseCache = null;

    private WeakReferenceQueue nodes = new WeakReferenceQueue();

    /* *************************************************************************
     *                                                                         *
     *                         Element getters                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Gets the X coordinate scaling element of the 3x4 matrix.
     *
     * @return the X coordinate scaling element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMxx() {
        return 1.0;
    }

    /**
     * Gets the XY coordinate element of the 3x4 matrix.
     *
     * @return the XY coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMxy() {
        return 0.0;
    }

    /**
     * Gets the XZ coordinate element of the 3x4 matrix.
     *
     * @return the XZ coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMxz() {
        return 0.0;
    }

    /**
     * Gets the X coordinate translation element of the 3x4 matrix.
     *
     * @return the X coordinate translation element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getTx() {
        return 0.0;
    }

    /**
     * Gets the YX coordinate element of the 3x4 matrix.
     *
     * @return the YX coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMyx() {
        return 0.0;
    }

    /**
     * Gets the Y coordinate scaling element of the 3x4 matrix.
     *
     * @return the Y coordinate scaling element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMyy() {
        return 1.0;
    }

    /**
     * Gets the YZ coordinate element of the 3x4 matrix.
     *
     * @return the YZ coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMyz() {
        return 0.0;
    }

    /**
     * Gets the Y coordinate translation element of the 3x4 matrix.
     *
     * @return the Y coordinate translation element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getTy() {
        return 0.0;
    }

    /**
     * Gets the ZX coordinate element of the 3x4 matrix.
     *
     * @return the ZX coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMzx() {
        return 0.0;
    }

    /**
     * Gets the ZY coordinate element of the 3x4 matrix.
     *
     * @return the ZY coordinate element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMzy() {
        return 0.0;
    }

    /**
     * Gets the Z coordinate scaling element of the 3x4 matrix.
     *
     * @return the Z coordinate scaling element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getMzz() {
        return 1.0;
    }

    /**
     * Gets the Z coordinate translation element of the 3x4 matrix.
     *
     * @return the Z coordinate translation element of the 3x4 matrix
     * @since JavaFX 2.2
     */
    public  double getTz() {
        return 0.0;
    }

    /**
     * Gets the specified element of the transformation matrix.
     * @param type type of matrix to get the value from
     * @param row zero-based row number
     * @param column zero-based column number
     * @return value of the specified transformation matrix element
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws IndexOutOfBoundsException if the indices are not within
     *         the specified matrix type
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double getElement(MatrixType type, int row, int column) {
        if (row &lt; 0 || row &gt;= type.rows() || column &lt; 0 || column &gt;= type.columns()) {
            throw new IndexOutOfBoundsException(&quot;Index outside of affine &quot;
                    + &quot;matrix &quot; + type + &quot;: [&quot; + row + &quot;, &quot; + column + &quot;]&quot;);
        }
        switch(type) {
            case MT_2D_2x3:
                // fall-through
            case MT_2D_3x3:
                if (!isType2D()) {
                    throw new IllegalArgumentException(&quot;Cannot access 2D matrix &quot;
                            + &quot;of a 3D transform&quot;);
                }
                switch(row) {
                    case 0:
                        switch(column) {
                            case 0: return getMxx();
                            case 1: return getMxy();
                            case 2: return getTx();
                        }
                    case 1:
                        switch(column) {
                            case 0: return getMyx();
                            case 1: return getMyy();
                            case 2: return getTy();
                        }
                    case 2:
                        switch(column) {
                            case 0: return 0.0;
                            case 1: return 0.0;
                            case 2: return 1.0;
                        }
                }
                break;
            case MT_3D_3x4:
                // fall-through
            case MT_3D_4x4:
                switch(row) {
                    case 0:
                        switch(column) {
                            case 0: return getMxx();
                            case 1: return getMxy();
                            case 2: return getMxz();
                            case 3: return getTx();
                        }
                    case 1:
                        switch(column) {
                            case 0: return getMyx();
                            case 1: return getMyy();
                            case 2: return getMyz();
                            case 3: return getTy();
                        }
                    case 2:
                        switch(column) {
                            case 0: return getMzx();
                            case 1: return getMzy();
                            case 2: return getMzz();
                            case 3: return getTz();
                        }
                    case 3:
                        switch(column) {
                            case 0: return 0.0;
                            case 1: return 0.0;
                            case 2: return 0.0;
                            case 3: return 1.0;
                        }
                }
                break;
        }
        // cannot reach here
        throw new InternalError(&quot;Unsupported matrix type &quot; + type);
    }

    /* *************************************************************************
     *                                                                         *
     *                           State getters                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Computes if this transform is currently a 2D transform (has no effect
     * in the direction of Z axis).
     * Used by the subclasses to effectively provide value of the type2D
     * property.
     * @return true if this transform is currently 2D-only
     */
    boolean computeIs2D() {
        return getMxz() == 0.0 &amp;&amp; getMzx() == 0.0 &amp;&amp; getMzy() == 0.0 &amp;&amp;
                    getMzz() == 1.0 &amp;&amp; getTz() == 0.0;
    }

    /**
     * Computes if this transform is currently an identity (has
     * no effect in any direction).
     * Used by the subclasses to effectively provide value of the identity
     * property.
     * @return true if this transform is currently an identity transform
     */
    boolean computeIsIdentity() {
        return
            getMxx() == 1.0 &amp;&amp; getMxy() == 0.0 &amp;&amp; getMxz() == 0.0 &amp;&amp; getTx() == 0.0 &amp;&amp;
            getMyx() == 0.0 &amp;&amp; getMyy() == 1.0 &amp;&amp; getMyz() == 0.0 &amp;&amp; getTy() == 0.0 &amp;&amp;
            getMzx() == 0.0 &amp;&amp; getMzy() == 0.0 &amp;&amp; getMzz() == 1.0 &amp;&amp; getTz() == 0.0;
    }

    /**
     * Computes determinant of the transformation matrix.
     * Among other things, determinant can be used for testing this transform's
     * invertibility - it is invertible if determinant is not equal to zero.
     * @return Determinant of the transformation matrix
     * @since JavaFX 8.0
     */
    public double determinant() {
        final double myx = getMyx();
        final double myy = getMyy();
        final double myz = getMyz();
        final double mzx = getMzx();
        final double mzy = getMzy();
        final double mzz = getMzz();

        return (getMxx() * (myy * mzz - mzy * myz) +
                getMxy() * (myz * mzx - mzz * myx) +
                getMxz() * (myx * mzy - mzx * myy));
    }

    /**
     * Determines if this is currently a 2D transform.
     * Transform is 2D if it has no effect along the Z axis.
     * @since JavaFX 8.0
     */
    private LazyBooleanProperty type2D;

    public final boolean isType2D() {
        return type2D == null ? computeIs2D() : type2D.get();
    }

    public final ReadOnlyBooleanProperty type2DProperty() {
        if (type2D == null) {
            type2D = new LazyBooleanProperty() {

                @Override
                protected boolean computeValue() {
                    return computeIs2D();
                }

                @Override
                public Object getBean() {
                    return Transform.this;
                }

                @Override
                public String getName() {
                    return &quot;type2D&quot;;
                }
            };
        }
        return type2D;
    }

    /**
     * Determines if this is currently an identity transform.
     * Identity transform has no effect on the transformed nodes.
     * @since JavaFX 8.0
     */
    private LazyBooleanProperty identity;

    public final boolean isIdentity() {
        return identity == null ? computeIsIdentity() : identity.get();
    }

    public final ReadOnlyBooleanProperty identityProperty() {
        if (identity == null) {
            identity = new LazyBooleanProperty() {

                @Override
                protected boolean computeValue() {
                    return computeIsIdentity();
                }

                @Override
                public Object getBean() {
                    return Transform.this;
                }

                @Override
                public String getName() {
                    return &quot;identity&quot;;
                }
            };
        }
        return identity;
    }

    /**
     * Lazily computed read-only boolean property implementation.
     * Used for type2D and identity properties.
     */
    private static abstract class LazyBooleanProperty
            extends ReadOnlyBooleanProperty {

        private ExpressionHelper&lt;Boolean&gt; helper;
        private boolean valid;
        private boolean value;

        @Override
        public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public void addListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(ChangeListener&lt;? super Boolean&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public boolean get() {
            if (!valid) {
                value = computeValue();
                valid = true;
            }

            return value;
        }

        public void invalidate() {
            if (valid) {
                valid = false;
                ExpressionHelper.fireValueChangedEvent(helper);
            }
        }

        protected abstract boolean computeValue();
    }

    /**
     * Transforms the specified point by this transform and by the specified
     * transform and returns distance of the result points. Used for similarTo
     * method. Has to be used only for 2D transforms (otherwise throws an
     * exception).
     * @param t the other transform
     * @param x point's X coordinate
     * @param y point's Y coordinate
     * @return distance of the transformed points
     */
    private double transformDiff(Transform t, double x, double y) {
        final Point2D byThis = transform(x, y);
        final Point2D byOther = t.transform(x, y);
        return byThis.distance(byOther);
    }

    /**
     * Transforms the specified point by this transform and by the specified
     * transform and returns distance of the result points. Used for similarTo
     * method.
     * @param t the other transform
     * @param x point's X coordinate
     * @param y point's Y coordinate
     * @param z point's Z coordinate
     * @return distance of the transformed points
     */
    private double transformDiff(Transform t, double x, double y, double z) {
        final Point3D byThis = transform(x, y, z);
        final Point3D byOther = t.transform(x, y, z);
        return byThis.distance(byOther);
    }

    /**
     * Checks if this transform is similar to the specified transform.
     * The two transforms are considered similar if any point from
     * {@code range} is transformed by them to points that are no farther
     * than {@code maxDelta} from each other.
     * @param transform transform to be compared to this transform
     * @param range region of interest on which the two transforms are compared
     * @param maxDelta maximum allowed distance for the results of transforming
     *                 any single point from {@code range} by the two transforms
     * @return true if the transforms are similar according to the specified
     *              criteria
     * @throws NullPointerException if the specified {@code transform}
     *         or {@code range} is null
     * @since JavaFX 8.0
     */
    public boolean similarTo(Transform transform, Bounds range, double maxDelta) {

        double cornerX, cornerY, cornerZ;

        if (isType2D() &amp;&amp; transform.isType2D()) {
            cornerX = range.getMinX();
            cornerY = range.getMinY();

            if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
                return false;
            }

            cornerY = range.getMaxY();
            if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
                return false;
            }

            cornerX = range.getMaxX();
            cornerY = range.getMinY();
            if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
                return false;
            }

            cornerY = range.getMaxY();
            if (transformDiff(transform, cornerX, cornerY) &gt; maxDelta) {
                return false;
            }

            return true;
        }

        cornerX = range.getMinX();
        cornerY = range.getMinY();
        cornerZ = range.getMinZ();
        if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
            return false;
        }

        cornerY = range.getMaxY();
        if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
            return false;
        }

        cornerX = range.getMaxX();
        cornerY = range.getMinY();
        if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
            return false;
        }

        cornerY = range.getMaxY();
        if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
            return false;
        }

        if (range.getDepth() != 0.0) {
            cornerX = range.getMinX();
            cornerY = range.getMinY();
            cornerZ = range.getMaxZ();
            if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
                return false;
            }

            cornerY = range.getMaxY();
            if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
                return false;
            }

            cornerX = range.getMaxX();
            cornerY = range.getMinY();
            if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
                return false;
            }

            cornerY = range.getMaxY();
            if (transformDiff(transform, cornerX, cornerY, cornerZ) &gt; maxDelta) {
                return false;
            }
        }

        return true;
    }

    /* *************************************************************************
     *                                                                         *
     *                           Array getters                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Core of the toArray implementation for the 2D case.
     * All of the checks has been made by the enclosing method as well as
     * the constant elements filled, this method only fills the varying
     * elements to the array. Used by subclasses to fill
     * the elements efficiently.
     * @param array array to be filled with the 6 2D elements
     */
    void fill2DArray(double[] array) {
        array[0] = getMxx();
        array[1] = getMxy();
        array[2] = getTx();
        array[3] = getMyx();
        array[4] = getMyy();
        array[5] = getTy();
    }

    /**
     * Core of the toArray implementation for the 3D case.
     * All of the checks has been made by the enclosing method as well as
     * the constant elements filled, this method only fills the varying
     * elements to the array. Used by subclasses to fill
     * the elements efficiently.
     * @param array array to be filled with the 12 3D elements
     */
    void fill3DArray(double[] array) {
        array[0] = getMxx();
        array[1] = getMxy();
        array[2] = getMxz();
        array[3] = getTx();
        array[4] = getMyx();
        array[5] = getMyy();
        array[6] = getMyz();
        array[7] = getTy();
        array[8] = getMzx();
        array[9] = getMzy();
        array[10] = getMzz();
        array[11] = getTz();
    }

    /**
     * Returns an array containing the flattened transformation matrix.
     * If the requested matrix type fits in the specified array, it is returned
     * therein. Otherwise, a new array is created.
     * @param type matrix type to be filled in the array
     * @param array array into which the elements of the matrix are to be
     *              stored, if it is non-null and big enough; otherwise,
     *              a new array is created for this purpose.
     * @return an array containing the elements of the requested matrix type
     *         representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] toArray(MatrixType type, double[] array) {
        checkRequestedMAT(type);

        if (array == null || array.length &lt; type.elements()) {
            array = new double[type.elements()];
        }

        switch (type) {
            case MT_2D_3x3:
                array[6] = 0.0;
                array[7] = 0.0;
                array[8] = 1.0;
                // fall-through
            case MT_2D_2x3:
                fill2DArray(array);
                break;
            case MT_3D_4x4:
                array[12] = 0.0;
                array[13] = 0.0;
                array[14] = 0.0;
                array[15] = 1.0;
                // fall-through
            case MT_3D_3x4:
                fill3DArray(array);
                break;
            default:
                throw new InternalError(&quot;Unsupported matrix type &quot; + type);
        }

        return array;
    }

    /**
     * Returns an array containing the flattened transformation matrix.
     * @param type matrix type to be filled in the array
     * @return an array containing the elements of the requested matrix type
     *         representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] toArray(MatrixType type) {
        return toArray(type, null);
    }

    /**
     * Returns an array containing a row of the transformation matrix.
     * If the row of the requested matrix type fits in the specified array,
     * it is returned therein. Otherwise, a new array is created.
     * @param type matrix type whose row is to be filled in the array
     * @param row zero-based index of the row
     * @param array array into which the elements of the row are to be
     *              stored, if it is non-null and big enough; otherwise,
     *              a new array is created for this purpose.
     * @return an array containing the requested row of the requested matrix
     *         type representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws IndexOutOfBoundsException if the {@code row} index is not within
     *         the number of rows of the specified matrix type
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] row(MatrixType type, int row, double[] array) {

        checkRequestedMAT(type);

        if (row &lt; 0 || row &gt;= type.rows()) {
            throw new IndexOutOfBoundsException(
                    &quot;Cannot get row &quot; + row + &quot; from &quot; + type);
        }

        if (array == null || array.length &lt; type.columns()) {
            array = new double[type.columns()];
        }

        switch(type) {
            case MT_2D_2x3:
            case MT_2D_3x3:
                switch (row) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMxy();
                        array[2] = getTx();
                        break;
                    case 1:
                        array[0] = getMyx();
                        array[1] = getMyy();
                        array[2] = getTy();
                        break;
                    case 2:
                        array[0] = 0.0;
                        array[1] = 0.0;
                        array[2] = 1.0;
                        break;
                }
                break;
            case MT_3D_3x4:
            case MT_3D_4x4:
                switch (row) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMxy();
                        array[2] = getMxz();
                        array[3] = getTx();
                        break;
                    case 1:
                        array[0] = getMyx();
                        array[1] = getMyy();
                        array[2] = getMyz();
                        array[3] = getTy();
                        break;
                    case 2:
                        array[0] = getMzx();
                        array[1] = getMzy();
                        array[2] = getMzz();
                        array[3] = getTz();
                        break;
                    case 3:
                        array[0] = 0.0;
                        array[1] = 0.0;
                        array[2] = 0.0;
                        array[3] = 1.0;
                        break;
                }
                break;
            default:
                throw new InternalError(&quot;Unsupported row &quot; + row + &quot; of &quot; + type);
        }
        return array;
    }

    /**
     * Returns an array containing a row of the transformation matrix.
     * @param type matrix type whose row is to be filled in the array
     * @param row zero-based index of the row
     * @return an array containing the requested row of the requested matrix
     *         type representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws IndexOutOfBoundsException if the {@code row} index is not within
     *         the number of rows of the specified matrix type
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] row(MatrixType type, int row) {
        return row(type, row, null);
    }

    /**
     * Returns an array containing a column of the transformation matrix.
     * If the column of the requested matrix type fits in the specified array,
     * it is returned therein. Otherwise, a new array is created.
     * @param type matrix type whose column is to be filled in the array
     * @param column zero-based index of the column
     * @param array array into which the elements of the column are to be
     *              stored, if it is non-null and big enough; otherwise,
     *              a new array is created for this purpose.
     * @return an array containing the requested column of the requested matrix
     *         type representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws IndexOutOfBoundsException if the {@code column} index
     *         is not within the number of columns of the specified matrix type
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] column(MatrixType type, int column, double[] array) {

        checkRequestedMAT(type);

        if (column &lt; 0 || column &gt;= type.columns()) {
            throw new IndexOutOfBoundsException(
                    &quot;Cannot get row &quot; + column + &quot; from &quot; + type);
        }

        if (array == null || array.length &lt; type.rows()) {
            array = new double[type.rows()];
        }

        switch(type) {
            case MT_2D_2x3:
                switch (column) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMyx();
                        break;
                    case 1:
                        array[0] = getMxy();
                        array[1] = getMyy();
                        break;
                    case 2:
                        array[0] = getTx();
                        array[1] = getTy();
                        break;
                }
                break;
            case MT_2D_3x3:
                switch (column) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMyx();
                        array[2] = 0.0;
                        break;
                    case 1:
                        array[0] = getMxy();
                        array[1] = getMyy();
                        array[2] = 0.0;
                        break;
                    case 2:
                        array[0] = getTx();
                        array[1] = getTy();
                        array[2] = 1.0;
                        break;
                }
                break;
            case MT_3D_3x4:
                switch (column) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMyx();
                        array[2] = getMzx();
                        break;
                    case 1:
                        array[0] = getMxy();
                        array[1] = getMyy();
                        array[2] = getMzy();
                        break;
                    case 2:
                        array[0] = getMxz();
                        array[1] = getMyz();
                        array[2] = getMzz();
                        break;
                    case 3:
                        array[0] = getTx();
                        array[1] = getTy();
                        array[2] = getTz();
                        break;
                }
                break;
            case MT_3D_4x4:
                switch (column) {
                    case 0:
                        array[0] = getMxx();
                        array[1] = getMyx();
                        array[2] = getMzx();
                        array[3] = 0.0;
                        break;
                    case 1:
                        array[0] = getMxy();
                        array[1] = getMyy();
                        array[2] = getMzy();
                        array[3] = 0.0;
                        break;
                    case 2:
                        array[0] = getMxz();
                        array[1] = getMyz();
                        array[2] = getMzz();
                        array[3] = 0.0;
                        break;
                    case 3:
                        array[0] = getTx();
                        array[1] = getTy();
                        array[2] = getTz();
                        array[3] = 1.0;
                        break;
                }
                break;
            default:
                throw new InternalError(&quot;Unsupported column &quot; + column + &quot; of &quot;
                        + type);
        }
        return array;
    }

    /**
     * Returns an array containing a column of the transformation matrix.
     * @param type matrix type whose column is to be filled in the array
     * @param column zero-based index of the column
     * @return an array containing the requested column of the requested matrix
     *         type representing this transform
     * @throws IllegalArgumentException if a 2D matrix type is requested for
     *         a 3D transform
     * @throws IndexOutOfBoundsException if the {@code column} index
     *         is not within the number of columns of the specified matrix type
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public double[] column(MatrixType type, int column) {
        return column(type, column, null);
    }

    /* *************************************************************************
     *                                                                         *
     *                         Transform creators                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns the concatenation of this transform and the specified transform.
     * Applying the resulting transform to a node has the same effect as
     * adding the two transforms to its {@code getTransforms()} list,
     * {@code this} transform first and the specified {@code transform} second.
     * @param transform transform to be concatenated with this transform
     * @return The concatenated transform
     * @throws NullPointerException if the specified {@code transform} is null
     * @since JavaFX 8.0
     */
    public Transform createConcatenation(Transform transform) {
        final double txx = transform.getMxx();
        final double txy = transform.getMxy();
        final double txz = transform.getMxz();
        final double ttx = transform.getTx();
        final double tyx = transform.getMyx();
        final double tyy = transform.getMyy();
        final double tyz = transform.getMyz();
        final double tty = transform.getTy();
        final double tzx = transform.getMzx();
        final double tzy = transform.getMzy();
        final double tzz = transform.getMzz();
        final double ttz = transform.getTz();
        return new Affine(
            (getMxx() * txx + getMxy() * tyx + getMxz() * tzx),
            (getMxx() * txy + getMxy() * tyy + getMxz() * tzy),
            (getMxx() * txz + getMxy() * tyz + getMxz() * tzz),
            (getMxx() * ttx + getMxy() * tty + getMxz() * ttz + getTx()),
            (getMyx() * txx + getMyy() * tyx + getMyz() * tzx),
            (getMyx() * txy + getMyy() * tyy + getMyz() * tzy),
            (getMyx() * txz + getMyy() * tyz + getMyz() * tzz),
            (getMyx() * ttx + getMyy() * tty + getMyz() * ttz + getTy()),
            (getMzx() * txx + getMzy() * tyx + getMzz() * tzx),
            (getMzx() * txy + getMzy() * tyy + getMzz() * tzy),
            (getMzx() * txz + getMzy() * tyz + getMzz() * tzz),
            (getMzx() * ttx + getMzy() * tty + getMzz() * ttz + getTz()));
    }

    /**
     * Returns the inverse transform of this transform.
     * @return the inverse transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @since JavaFX 8.0
     */
    public Transform createInverse() throws NonInvertibleTransformException {
        return getInverseCache().clone();
    }

    /**
     * Returns a deep copy of this transform.
     * @return a copy of this transform
     * @since JavaFX 8.0
     */
    @Override
    public Transform clone() {
        return TransformUtils.immutableTransform(this);
    }

    /* *************************************************************************
     *                                                                         *
     *                     Transform, Inverse Transform                        *
     *                                                                         *
     **************************************************************************/

    /**
     * Transforms the specified point by this transform.
     * This method can be used only for 2D transforms.
     * @param x the X coordinate of the point
     * @param y the Y coordinate of the point
     * @return the transformed point
     * @throws IllegalStateException if this is a 3D transform
     * @since JavaFX 8.0
     */
    public Point2D transform(double x, double y) {
        ensureCanTransform2DPoint();

        return new Point2D(
            getMxx() * x + getMxy() * y + getTx(),
            getMyx() * x + getMyy() * y + getTy());
    }

    /**
     * Transforms the specified point by this transform.
     * This method can be used only for 2D transforms.
     * @param point the point to be transformed
     * @return the transformed point
     * @throws IllegalStateException if this is a 3D transform
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point2D transform(Point2D point) {
        return transform(point.getX(), point.getY());
    }

    /**
     * Transforms the specified point by this transform.
     * @param x the X coordinate of the point
     * @param y the Y coordinate of the point
     * @param z the Z coordinate of the point
     * @return the transformed point
     * @since JavaFX 8.0
     */
    public Point3D transform(double x, double y, double z) {
        return new Point3D(
            getMxx() * x + getMxy() * y + getMxz() * z + getTx(),
            getMyx() * x + getMyy() * y + getMyz() * z + getTy(),
            getMzx() * x + getMzy() * y + getMzz() * z + getTz());
    }

    /**
     * Transforms the specified point by this transform.
     * @param point the point to be transformed
     * @return the transformed point
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point3D transform(Point3D point) {
        return transform(point.getX(), point.getY(), point.getZ());
    }

    /**
     * Transforms the specified bounds by this transform.
     * @param bounds the bounds to be transformed
     * @return the transformed bounds
     * @since JavaFX 8.0
     */
    public Bounds transform(Bounds bounds) {
        if (isType2D() &amp;&amp; (bounds.getMinZ() == 0) &amp;&amp; (bounds.getMaxZ() == 0)) {
            Point2D p1 = transform(bounds.getMinX(), bounds.getMinY());
            Point2D p2 = transform(bounds.getMaxX(), bounds.getMinY());
            Point2D p3 = transform(bounds.getMaxX(), bounds.getMaxY());
            Point2D p4 = transform(bounds.getMinX(), bounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        Point3D p1 = transform(bounds.getMinX(), bounds.getMinY(), bounds.getMinZ());
        Point3D p2 = transform(bounds.getMinX(), bounds.getMinY(), bounds.getMaxZ());
        Point3D p3 = transform(bounds.getMinX(), bounds.getMaxY(), bounds.getMinZ());
        Point3D p4 = transform(bounds.getMinX(), bounds.getMaxY(), bounds.getMaxZ());
        Point3D p5 = transform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMinZ());
        Point3D p6 = transform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMaxZ());
        Point3D p7 = transform(bounds.getMaxX(), bounds.getMinY(), bounds.getMinZ());
        Point3D p8 = transform(bounds.getMaxX(), bounds.getMinY(), bounds.getMaxZ());

        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);
    }

    /**
     * Core of the transform2DPoints method.
     * All the checks has been performed and the care of the overlaps has been
     * taken by the enclosing method, this method only transforms the points
     * and fills them to the array. Used by the subclasses to perform
     * the transform efficiently.
     */
    void transform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {
        final double xx = getMxx();
        final double xy = getMxy();
        final double tx = getTx();
        final double yx = getMyx();
        final double yy = getMyy();
        final double ty = getTy();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];

            dstPts[dstOff++] = xx * x + xy * y + tx;
            dstPts[dstOff++] = yx * x + yy * y + ty;
        }
    }

    /**
     * Core of the transform3DPoints method.
     * All the checks has been performed and the care of the overlaps has been
     * taken by the enclosing method, this method only transforms the points
     * and fills them to the array. Used by the subclasses to perform
     * the transform efficiently.
     */
    void transform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {

        final double xx = getMxx();
        final double xy = getMxy();
        final double xz = getMxz();
        final double tx = getTx();
        final double yx = getMyx();
        final double yy = getMyy();
        final double yz = getMyz();
        final double ty = getTy();
        final double zx = getMzx();
        final double zy = getMzy();
        final double zz = getMzz();
        final double tz = getTz();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];
            final double z = srcPts[srcOff++];

            dstPts[dstOff++] = xx * x + xy * y + xz * z + tx;
            dstPts[dstOff++] = yx * x + yy * y + yz * z + ty;
            dstPts[dstOff++] = zx * x + zy * y + zz * z + tz;
        }
    }

    /**
     * Transforms an array of coordinates by this transform.
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are overwritten by a
     * previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.
     * This method can be used only for 2D transforms.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&amp;nbsp;y coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a pair of x,&amp;nbsp;y
     * coordinates.
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of points to be transformed
     * @throws IllegalStateException if this is a 3D transform
     * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
     * @since JavaFX 8.0
     */
    public void transform2DPoints(double[] srcPts, int srcOff,
                          double[] dstPts, int dstOff,
                          int numPts) {

        if (srcPts == null || dstPts == null) {
            throw new NullPointerException();
        }

        if (!isType2D()) {
            throw new IllegalStateException(&quot;Cannot transform 2D points &quot;
                    + &quot;with a 3D transform&quot;);
        }

        // deal with overlapping arrays
        srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 2);

        // do the transformations
        transform2DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
    }

    /**
     * Transforms an array of floating point coordinates by this transform.
     * The three coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are overwritten by a
     * previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order &lt;code&gt;[x0, y0, z0, x1, y1, z1, ..., xn, yn, zn]&lt;/code&gt;.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a tiplet of x,&amp;nbsp;y,&amp;nbsp;z coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a triplet of x,&amp;nbsp;y,&amp;nbsp;z
     * coordinates.
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of points to be transformed
     * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
     * @since JavaFX 8.0
     */
    public void transform3DPoints(double[] srcPts, int srcOff,
                          double[] dstPts, int dstOff,
                          int numPts) {

        if (srcPts == null || dstPts == null) {
            throw new NullPointerException();
        }

        // deal with overlapping arrays
        srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 3);

        // do the transformations
        transform3DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
    }

    /**
     * Transforms the relative magnitude vector by this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * This method can be used only for a 2D transform.
     * @param x vector magnitude in the direction of the X axis
     * @param y vector magnitude in the direction of the Y axis
     * @return the transformed relative magnitude vector represented
     *         by a {@code Point2D} instance
     * @throws IllegalStateException if this is a 3D transform
     * @since JavaFX 8.0
     */
    public Point2D deltaTransform(double x, double y) {
        ensureCanTransform2DPoint();

        return new Point2D(
            getMxx() * x + getMxy() * y,
            getMyx() * x + getMyy() * y);
    }

    /**
     * Transforms the relative magnitude vector represented by the specified
     * {@code Point2D} instance by this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * This method can be used only for a 2D transform.
     * @param point the relative magnitude vector
     * @return the transformed relative magnitude vector represented
     *         by a {@code Point2D} instance
     * @throws IllegalStateException if this is a 3D transform
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point2D deltaTransform(Point2D point) {
        return deltaTransform(point.getX(), point.getY());
    }

    /**
     * Transforms the relative magnitude vector by this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * @param x vector magnitude in the direction of the X axis
     * @param y vector magnitude in the direction of the Y axis
     * @param z vector magnitude in the direction of the Z axis
     * @return the transformed relative magnitude vector represented
     *         by a {@code Point3D} instance
     * @since JavaFX 8.0
     */
    public Point3D deltaTransform(double x, double y, double z) {
        return new Point3D(
            getMxx() * x + getMxy() * y + getMxz() * z,
            getMyx() * x + getMyy() * y + getMyz() * z,
            getMzx() * x + getMzy() * y + getMzz() * z);
    }

    /**
     * Transforms the relative magnitude vector represented by the specified
     * {@code Point3D} instance by this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * @param point the relative magnitude vector
     * @return the transformed relative magnitude vector represented
     *         by a {@code Point3D} instance
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point3D deltaTransform(Point3D point) {
        return deltaTransform(point.getX(), point.getY(), point.getZ());
    }

    /**
     * Transforms the specified point by the inverse of this transform.
     * This method can be used only for 2D transforms.
     * @param x the X coordinate of the point
     * @param y the Y coordinate of the point
     * @return the inversely transformed point
     * @throws IllegalStateException if this is a 3D transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @since JavaFX 8.0
     */
    public Point2D inverseTransform(double x, double y)
            throws NonInvertibleTransformException {

        ensureCanTransform2DPoint();

        return getInverseCache().transform(x, y);
    }

    /**
     * Transforms the specified point by the inverse of this transform.
     * This method can be used only for 2D transforms.
     * @param point the point to be transformed
     * @return the inversely transformed point
     * @throws IllegalStateException if this is a 3D transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point2D inverseTransform(Point2D point)
            throws NonInvertibleTransformException {
        return inverseTransform(point.getX(), point.getY());
    }

    /**
     * Transforms the specified point by the inverse of this transform.
     * @param x the X coordinate of the point
     * @param y the Y coordinate of the point
     * @param z the Z coordinate of the point
     * @return the inversely transformed point
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @since JavaFX 8.0
     */
    public Point3D inverseTransform(double x, double y, double z)
            throws NonInvertibleTransformException {

        return getInverseCache().transform(x, y, z);
    }

    /**
     * Transforms the specified point by the inverse of this transform.
     * @param point the point to be transformed
     * @return the inversely transformed point
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point3D inverseTransform(Point3D point)
            throws NonInvertibleTransformException {
        return inverseTransform(point.getX(), point.getY(), point.getZ());
    }

    /**
     * Transforms the specified bounds by the inverse of this transform.
     * @param bounds the bounds to be transformed
     * @return the inversely transformed bounds
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if the specified {@code bounds} is null
     * @since JavaFX 8.0
     */
    public Bounds inverseTransform(Bounds bounds)
            throws NonInvertibleTransformException {
        if (isType2D() &amp;&amp; (bounds.getMinZ() == 0) &amp;&amp; (bounds.getMaxZ() == 0)) {
            Point2D p1 = inverseTransform(bounds.getMinX(), bounds.getMinY());
            Point2D p2 = inverseTransform(bounds.getMaxX(), bounds.getMinY());
            Point2D p3 = inverseTransform(bounds.getMaxX(), bounds.getMaxY());
            Point2D p4 = inverseTransform(bounds.getMinX(), bounds.getMaxY());

            return BoundsUtils.createBoundingBox(p1, p2, p3, p4);
        }
        Point3D p1 = inverseTransform(bounds.getMinX(), bounds.getMinY(), bounds.getMinZ());
        Point3D p2 = inverseTransform(bounds.getMinX(), bounds.getMinY(), bounds.getMaxZ());
        Point3D p3 = inverseTransform(bounds.getMinX(), bounds.getMaxY(), bounds.getMinZ());
        Point3D p4 = inverseTransform(bounds.getMinX(), bounds.getMaxY(), bounds.getMaxZ());
        Point3D p5 = inverseTransform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMinZ());
        Point3D p6 = inverseTransform(bounds.getMaxX(), bounds.getMaxY(), bounds.getMaxZ());
        Point3D p7 = inverseTransform(bounds.getMaxX(), bounds.getMinY(), bounds.getMinZ());
        Point3D p8 = inverseTransform(bounds.getMaxX(), bounds.getMinY(), bounds.getMaxZ());

        return BoundsUtils.createBoundingBox(p1, p2, p3, p4, p5, p6, p7, p8);

    }

    /**
     * Core of the inverseTransform2DPoints method.
     * All the checks has been performed and the care of the overlaps has been
     * taken by the enclosing method, this method only transforms the points
     * and fills them to the array. Used by the subclasses to perform
     * the transform efficiently.
     */
    void inverseTransform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts)
            throws NonInvertibleTransformException {

        getInverseCache().transform2DPointsImpl(srcPts, srcOff,
                dstPts, dstOff, numPts);
    }

    /**
     * Core of the inverseTransform3DPoints method.
     * All the checks has been performed and the care of the overlaps has been
     * taken by the enclosing method, this method only transforms the points
     * and fills them to the array. Used by the subclasses to perform
     * the transform efficiently.
     */
    void inverseTransform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts)
            throws NonInvertibleTransformException {

        getInverseCache().transform3DPointsImpl(srcPts, srcOff,
                dstPts, dstOff, numPts);
    }

    /**
     * Transforms an array of coordinates by the inverse of this transform.
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are overwritten by a
     * previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.
     * This method can be used only for 2D transforms.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&amp;nbsp;y coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a pair of x,&amp;nbsp;y
     * coordinates.
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of points to be transformed
     * @throws IllegalStateException if this is a 3D transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
     * @since JavaFX 8.0
     */
    public void inverseTransform2DPoints(double[] srcPts, int srcOff,
                          double[] dstPts, int dstOff,
                          int numPts) throws NonInvertibleTransformException{

        if (srcPts == null || dstPts == null) {
            throw new NullPointerException();
        }

        if (!isType2D()) {
            throw new IllegalStateException(&quot;Cannot transform 2D points &quot;
                    + &quot;with a 3D transform&quot;);
        }

        // deal with overlapping arrays
        srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 2);

        // do the transformations
        inverseTransform2DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
    }

    /**
     * Transforms an array of floating point coordinates by the inverse
     * of this transform.
     * The three coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are overwritten by a
     * previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order &lt;code&gt;[x0, y0, z0, x1, y1, z1, ..., xn, yn, zn]&lt;/code&gt;.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a triplet of x,&amp;nbsp;y,&amp;nbsp;z coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a triplet of x,&amp;nbsp;y,&amp;nbsp;z
     * coordinates.
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of points to be transformed
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null
     * @since JavaFX 8.0
     */
    public void inverseTransform3DPoints(double[] srcPts, int srcOff,
                          double[] dstPts, int dstOff,
                          int numPts) throws NonInvertibleTransformException {

        if (srcPts == null || dstPts == null) {
            throw new NullPointerException();
        }

        // deal with overlapping arrays
        srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 3);

        // do the transformations
        inverseTransform3DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);
    }

    /**
     * Transforms the relative magnitude vector by the inverse of this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * This method can be used only for a 2D transform.
     * @param x vector magnitude in the direction of the X axis
     * @param y vector magnitude in the direction of the Y axis
     * @return the inversely transformed relative magnitude vector represented
     *         by a {@code Point2D} instance
     * @throws IllegalStateException if this is a 3D transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @since JavaFX 8.0
     */
    public Point2D inverseDeltaTransform(double x, double y)
            throws NonInvertibleTransformException {

        ensureCanTransform2DPoint();

        return getInverseCache().deltaTransform(x, y);
    }

    /**
     * Transforms the relative magnitude vector represented by the specified
     * {@code Point2D} instance by the inverse of this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * This method can be used only for a 2D transform.
     * @param point the relative magnitude vector
     * @return the inversely transformed relative magnitude vector represented
     *         by a {@code Point2D} instance
     * @throws IllegalStateException if this is a 3D transform
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point2D inverseDeltaTransform(Point2D point)
            throws NonInvertibleTransformException {
        return inverseDeltaTransform(point.getX(), point.getY());
    }

    /**
     * Transforms the relative magnitude vector by the inverse of this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * @param x vector magnitude in the direction of the X axis
     * @param y vector magnitude in the direction of the Y axis
     * @param z vector magnitude in the direction of the Z axis
     * @return the inversely transformed relative magnitude vector represented
     *         by a {@code Point3D} instance
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @since JavaFX 8.0
     */
    public Point3D inverseDeltaTransform(double x, double y, double z)
            throws NonInvertibleTransformException {

        return getInverseCache().deltaTransform(x, y, z);
    }

    /**
     * Transforms the relative magnitude vector represented by the specified
     * {@code Point3D} instance by the inverse of this transform.
     * The vector is transformed without applying the translation components
     * of the affine transformation matrix.
     * @param point the relative magnitude vector
     * @return the inversely transformed relative magnitude vector represented
     *         by a {@code Point3D} instance
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @throws NullPointerException if the specified {@code point} is null
     * @since JavaFX 8.0
     */
    public Point3D inverseDeltaTransform(Point3D point)
            throws NonInvertibleTransformException {
        return inverseDeltaTransform(point.getX(), point.getY(), point.getZ());
    }

    /**
     * Helper method for transforming arrays of points that deals with
     * overlapping arrays.
     * @return the (if necessary fixed) srcOff
     */
    private int getFixedSrcOffset(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff,
            int numPts, int dimensions) {

        if (dstPts == srcPts &amp;&amp;
            dstOff &gt; srcOff &amp;&amp; dstOff &lt; srcOff + numPts * dimensions)
        {
            // If the arrays overlap partially with the destination higher
            // than the source and we transform the coordinates normally
            // we would overwrite some of the later source coordinates
            // with results of previous transformations.
            // To get around this we use arraycopy to copy the points
            // to their final destination with correct overwrite
            // handling and then transform them in place in the new
            // safer location.
            System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * dimensions);
            return dstOff;
        }

        return srcOff;
    }

    /* *************************************************************************
     *                                                                         *
     *                         Event Dispatch                                  *
     *                                                                         *
     **************************************************************************/

    private EventHandlerManager internalEventDispatcher;
    private EventHandlerManager getInternalEventDispatcher() {
        if (internalEventDispatcher == null) {
            internalEventDispatcher = new EventHandlerManager(this);
        }
        return internalEventDispatcher;
    }
    private ObjectProperty&lt;EventHandler&lt;? super TransformChangedEvent&gt;&gt;
            onTransformChanged;

    @Override
    public EventDispatchChain buildEventDispatchChain(EventDispatchChain tail) {
        return internalEventDispatcher == null
                ? tail : tail.append(getInternalEventDispatcher());
    }

    /**
     * &lt;p&gt;
     * Registers an event handler to this transform. Any event filters are first
     * processed, then the specified onFoo event handlers, and finally any
     * event handlers registered by this method.
     * &lt;/p&gt;&lt;p&gt;
     * Currently the only event delivered to a {@code Transform} is the
     * {@code TransformChangedEvent} with it's single type
     * {@code TRANSFORM_CHANGED}.
     * &lt;/p&gt;
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the type of the events to receive by the handler
     * @param eventHandler the handler to register
     * @throws NullPointerException if the event type or handler is null
     * @since JavaFX 8.0
     */
    public final &lt;T extends Event&gt; void addEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher()
                .addEventHandler(eventType, eventHandler);
        // need to validate all properties to get the change events
        validate();
    }

    /**
     * Unregisters a previously registered event handler from this transform.
     * One handler might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the handler.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type from which to unregister
     * @param eventHandler the handler to unregister
     * @throws NullPointerException if the event type or handler is null
     * @since JavaFX 8.0
     */
    public final &lt;T extends Event&gt; void removeEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        getInternalEventDispatcher()
                .removeEventHandler(eventType, eventHandler);
    }

    /**
     * &lt;p&gt;
     * Registers an event filter to this transform. Registered event filters get
     * an event before any associated event handlers.
     * &lt;/p&gt;&lt;p&gt;
     * Currently the only event delivered to a {@code Transform} is the
     * {@code TransformChangedEvent} with it's single type
     * {@code TRANSFORM_CHANGED}.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the type of the events to receive by the filter
     * @param eventFilter the filter to register
     * @throws NullPointerException if the event type or filter is null
     * @since JavaFX 8.0
     */
    public final &lt;T extends Event&gt; void addEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher()
                .addEventFilter(eventType, eventFilter);
        // need to validate all properties to get the change events
        validate();
    }

    /**
     * Unregisters a previously registered event filter from this transform. One
     * filter might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the filter.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the event type from which to unregister
     * @param eventFilter the filter to unregister
     * @throws NullPointerException if the event type or filter is null
     * @since JavaFX 8.0
     */
    public final &lt;T extends Event&gt; void removeEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        getInternalEventDispatcher()
                .removeEventFilter(eventType, eventFilter);
    }

    /**
     * Sets the onTransformChanged event handler which is called whenever
     * the transform changes any of its parameters.
     *
     * @param value the event handler, can be null to clear it
     * @since JavaFX 8.0
     */
    public final void setOnTransformChanged(
            EventHandler&lt;? super TransformChangedEvent&gt; value) {
        onTransformChangedProperty().set(value);
        // need to validate all properties to get the change events
        validate();
    }

    /**
     * Gets the onTransformChanged event handler.
     * @return the event handler previously set by {@code setOnTransformChanged}
     * method, null if the handler is not set.
     * @since JavaFX 8.0
     */
    public final EventHandler&lt;? super TransformChangedEvent&gt; getOnTransformChanged() {
        return (onTransformChanged == null) ? null : onTransformChanged.get();
    }

    /**
     * The onTransformChanged event handler is called whenever the transform
     * changes any of its parameters.
     * @return the onTransformChanged event handler
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;EventHandler&lt;? super TransformChangedEvent&gt;&gt;
            onTransformChangedProperty() {
        if (onTransformChanged == null) {

            onTransformChanged = new SimpleObjectProperty&lt;EventHandler
                    &lt;? super TransformChangedEvent&gt;&gt;(this, &quot;onTransformChanged&quot;) {

                @Override protected void invalidated() {
                    getInternalEventDispatcher().setEventHandler(
                            TransformChangedEvent.TRANSFORM_CHANGED, get());
                }
            };
        }

        return onTransformChanged;
    }

    /* *************************************************************************
     *                                                                         *
     *                    Internal implementation stuff                        *
     *                                                                         *
     **************************************************************************/

    /**
     * Makes sure the specified matrix type can be requested from this transform.
     * Is used for convenience in various methods that accept
     * the MatrixType argument.
     * @param type matrix type to check
     * @throws IllegalArgumentException if this is a 3D transform and
     *                                  a 2D type is requested
     */
    void checkRequestedMAT(MatrixType type) throws IllegalArgumentException{
        if (type.is2D() &amp;&amp; !isType2D()) {
            throw new IllegalArgumentException(&quot;Cannot access 2D matrix &quot;
                    + &quot;for a 3D transform&quot;);
        }
    }

    /**
     * Makes sure this is a 2D transform.
     * Is used for convenience in various 2D point transformation methods.
     * @throws IllegalStateException if this is a 2D transform
     */
    void ensureCanTransform2DPoint() throws IllegalStateException {
        if (!isType2D()) {
            throw new IllegalStateException(&quot;Cannot transform 2D point &quot;
                    + &quot;with a 3D transform&quot;);
        }
    }

    /**
     * Needed for the proper delivery of the TransformChangedEvent.
     * If the members are invalid, the transformChanged() notification
     * is not called and the event is not delivered. To avoid that
     * we need to manually validate all properties. Subclasses validate
     * their specific properties.
     */
    void validate() {
        getMxx(); getMxy(); getMxz(); getTx();
        getMyx(); getMyy(); getMyz(); getTy();
        getMzx(); getMzy(); getMzz(); getTz();
    }

    abstract void apply(Affine3D t);

    abstract BaseTransform derive(BaseTransform t);

    void add(final Node node) {
        nodes.add(node);
    }

    void remove(final Node node) {
        nodes.remove(node);
    }

    /**
     * This method must be called by all transforms whenever any of their
     * parameters changes. It is typically called when any of the transform's
     * properties is invalidated (it is OK to skip the call if an invalid
     * property is set).
     * @since JavaFX 8.0
     */
    protected void transformChanged() {
        inverseCache = null;
        final Iterator iterator = nodes.iterator();
        while (iterator.hasNext()) {
            NodeHelper.transformsChanged(((Node) iterator.next()));
        }

        if (type2D != null) {
            type2D.invalidate();
        }

        if (identity != null) {
            identity.invalidate();
        }

        if (internalEventDispatcher != null) {
            // need to validate all properties for the event to be fired next time
            validate();
            Event.fireEvent(this, new TransformChangedEvent(this, this));
        }
    }

    /**
     * Visitor from {@code Affine} class which provides an efficient
     * {@code append} operation for the subclasses.
     * @param a {@code Affine} instance to append to
     */
    void appendTo(Affine a) {
        a.append(getMxx(), getMxy(), getMxz(), getTx(),
                 getMyx(), getMyy(), getMyz(), getTy(),
                 getMzx(), getMzy(), getMzz(), getTz());
    }

    /**
     * Visitor from {@code Affine} class which provides an efficient
     * {@code prepend} operation for the subclasses.
     * @param a {@code Affine} instance to prepend to
     */
    void prependTo(Affine a) {
        a.prepend(getMxx(), getMxy(), getMxz(), getTx(),
                  getMyx(), getMyy(), getMyz(), getTy(),
                  getMzx(), getMzy(), getMzz(), getTz());
    }

    /**
     * &lt;p&gt;
     * Gets the inverse transform cache.
     * &lt;/p&gt;&lt;p&gt;
     * Computing the inverse transform is generally an expensive operation,
     * so once it is needed we cache the result (throwing it away when the
     * transform changes). The subclasses may avoid using the cache if their
     * inverse can be computed quickly on the fly.
     * &lt;/p&gt;&lt;p&gt;
     * This method computes the inverse if the cache is not valid.
     * &lt;/p&gt;
     * @return the cached inverse transformation
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     */
    private Transform getInverseCache() throws NonInvertibleTransformException {
        if (inverseCache == null || inverseCache.get() == null) {
            Affine inv = new Affine(
                    getMxx(), getMxy(), getMxz(), getTx(),
                    getMyx(), getMyy(), getMyz(), getTy(),
                    getMzx(), getMzy(), getMzz(), getTz());
            inv.invert();
            inverseCache = new SoftReference&lt;Transform&gt;(inv);
            return inv;
        }

        return inverseCache.get();
    }

    /**
     * Used only by tests to emulate garbage collecting the soft references
     */
    void clearInverseCache() {
        if (inverseCache != null) {
            inverseCache.clear();
        }
    }

    /**************************************************************************
     *  ImmutableTransform Class and supporting methods
     **************************************************************************/

    static Transform createImmutableTransform() {
        return new ImmutableTransform();
    }

    static Transform createImmutableTransform(
            double mxx, double mxy, double mxz, double tx,
            double myx, double myy, double myz, double ty,
            double mzx, double mzy, double mzz, double tz) {
        return new ImmutableTransform(
                mxx, mxy, mxz, tx,
                myx, myy, myz, ty,
                mzx, mzy, mzz, tz);
    }

    static Transform createImmutableTransform(Transform transform,
            double mxx, double mxy, double mxz, double tx,
            double myx, double myy, double myz, double ty,
            double mzx, double mzy, double mzz, double tz) {
        if (transform == null) {
            return new ImmutableTransform(
                    mxx, mxy, mxz, tx,
                    myx, myy, myz, ty,
                    mzx, mzy, mzz, tz);
        }
        ((Transform.ImmutableTransform) transform).setToTransform(
                mxx, mxy, mxz, tx,
                myx, myy, myz, ty,
                mzx, mzy, mzz, tz);
        return transform;
    }

    static Transform createImmutableTransform(Transform transform,
            Transform left, Transform right) {
        if (transform == null) {
            transform = new ImmutableTransform();
        }
        ((Transform.ImmutableTransform) transform).setToConcatenation(
                (ImmutableTransform) left, (ImmutableTransform) right);
        return transform;
    }

    /**
     * Immutable transformation with performance optimizations based on Affine.
     *
     * From user's perspective, this transform is immutable. However, we can
     * modify it internally. This allows for reusing instances that were
     * not handed to users. The caller is responsible for not modifying
     * user-visible instances.
     *
     * Note: can't override Transform's package private methods so they cannot
     * be optimized. Currently not a big deal.
     */
    static class ImmutableTransform extends Transform {

        private static final int APPLY_IDENTITY = 0;
        private static final int APPLY_TRANSLATE = 1;
        private static final int APPLY_SCALE = 2;
        private static final int APPLY_SHEAR = 4;
        private static final int APPLY_NON_3D = 0;
        private static final int APPLY_3D_COMPLEX = 4;
        private transient int state2d;
        private transient int state3d;

        private double xx;
        private double xy;
        private double xz;
        private double yx;
        private double yy;
        private double yz;
        private double zx;
        private double zy;
        private double zz;
        private double xt;
        private double yt;
        private double zt;

        ImmutableTransform() {
            xx = yy = zz = 1.0;
        }

        ImmutableTransform(Transform transform) {
            this(transform.getMxx(), transform.getMxy(), transform.getMxz(),
                                                                 transform.getTx(),
                 transform.getMyx(), transform.getMyy(), transform.getMyz(),
                                                                 transform.getTy(),
                 transform.getMzx(), transform.getMzy(), transform.getMzz(),
                                                                 transform.getTz());
        }

        ImmutableTransform(double mxx, double mxy, double mxz, double tx,
                      double myx, double myy, double myz, double ty,
                      double mzx, double mzy, double mzz, double tz) {
            xx = mxx;
            xy = mxy;
            xz = mxz;
            xt = tx;

            yx = myx;
            yy = myy;
            yz = myz;
            yt = ty;

            zx = mzx;
            zy = mzy;
            zz = mzz;
            zt = tz;

            updateState();
        }

        // Beware: this is modifying immutable transform!
        // It is private and it is there just for the purpose of reusing
        // instances not given to users
        private void setToTransform(double mxx, double mxy, double mxz, double tx,
                                    double myx, double myy, double myz, double ty,
                                    double mzx, double mzy, double mzz, double tz)
        {
            xx = mxx;
            xy = mxy;
            xz = mxz;
            xt = tx;
            yx = myx;
            yy = myy;
            yz = myz;
            yt = ty;
            zx = mzx;
            zy = mzy;
            zz = mzz;
            zt = tz;
            updateState();
        }

        // Beware: this is modifying immutable transform!
        // It is private and it is there just for the purpose of reusing
        // instances not given to users
        private void setToConcatenation(ImmutableTransform left, ImmutableTransform right) {
            if (left.state3d == APPLY_NON_3D &amp;&amp; right.state3d == APPLY_NON_3D) {
                xx = left.xx * right.xx + left.xy * right.yx;
                xy = left.xx * right.xy + left.xy * right.yy;
                xt = left.xx * right.xt + left.xy * right.yt + left.xt;
                yx = left.yx * right.xx + left.yy * right.yx;
                yy = left.yx * right.xy + left.yy * right.yy;
                yt = left.yx * right.xt + left.yy * right.yt + left.yt;
                if (state3d != APPLY_NON_3D) {
                    xz = yz = zx = zy = zt = 0.0;
                    zz = 1.0;
                    state3d = APPLY_NON_3D;
                }
                updateState2D();
            } else {
                xx = left.xx * right.xx + left.xy * right.yx + left.xz * right.zx;
                xy = left.xx * right.xy + left.xy * right.yy + left.xz * right.zy;
                xz = left.xx * right.xz + left.xy * right.yz + left.xz * right.zz;
                xt = left.xx * right.xt + left.xy * right.yt + left.xz * right.zt + left.xt;
                yx = left.yx * right.xx + left.yy * right.yx + left.yz * right.zx;
                yy = left.yx * right.xy + left.yy * right.yy + left.yz * right.zy;
                yz = left.yx * right.xz + left.yy * right.yz + left.yz * right.zz;
                yt = left.yx * right.xt + left.yy * right.yt + left.yz * right.zt + left.yt;
                zx = left.zx * right.xx + left.zy * right.yx + left.zz * right.zx;
                zy = left.zx * right.xy + left.zy * right.yy + left.zz * right.zy;
                zz = left.zx * right.xz + left.zy * right.yz + left.zz * right.zz;
                zt = left.zx * right.xt + left.zy * right.yt + left.zz * right.zt + left.zt;
                updateState();
            }
            // could be further optimized using the states, but that would
            // require a lot of code (see Affine and all its append* methods)
        }

        @Override
        public double getMxx() {
            return xx;
        }

        @Override
        public double getMxy() {
            return xy;
        }

        @Override
        public double getMxz() {
            return xz;
        }

        @Override
        public double getTx() {
            return xt;
        }

        @Override
        public double getMyx() {
            return yx;
        }

        @Override
        public double getMyy() {
            return yy;
        }

        @Override
        public double getMyz() {
            return yz;
        }

        @Override
        public double getTy() {
            return yt;
        }

        @Override
        public double getMzx() {
            return zx;
        }

        @Override
        public double getMzy() {
            return zy;
        }

        @Override
        public double getMzz() {
            return zz;
        }

        @Override
        public double getTz() {
            return zt;
        }

    /* *************************************************************************
     *                                                                         *
     *                           State getters                                 *
     *                                                                         *
     **************************************************************************/

        @Override
        public double determinant() {
            switch(state3d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_NON_3D:
                    switch (state2d) {
                        default:
                            stateError();
                            // cannot reach
                        case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                        case APPLY_SHEAR | APPLY_SCALE:
                            return xx * yy - xy * yx;
                        case APPLY_SHEAR | APPLY_TRANSLATE:
                        case APPLY_SHEAR:
                            return -(xy* yx);
                        case APPLY_SCALE | APPLY_TRANSLATE:
                        case APPLY_SCALE:
                            return xx * yy;
                        case APPLY_TRANSLATE:
                        case APPLY_IDENTITY:
                            return 1.0;
                    }
                case APPLY_TRANSLATE:
                    return 1.0;
                case APPLY_SCALE:
                case APPLY_SCALE | APPLY_TRANSLATE:
                    return xx * yy * zz;
                case APPLY_3D_COMPLEX:
                    return (xx* (yy * zz - zy * yz) +
                            xy* (yz * zx - zz * yx) +
                            xz* (yx * zy - zx * yy));
            }
        }

        @Override
        public Transform createConcatenation(Transform transform) {
            javafx.scene.transform.Affine a = new Affine(this);
            a.append(transform);
            return a;
        }

        @Override
        public javafx.scene.transform.Affine createInverse() throws NonInvertibleTransformException {
            javafx.scene.transform.Affine t = new Affine(this);
            t.invert();
            return t;
        }

        @Override
        public Transform clone() {
            return new ImmutableTransform(this);
        }

        /* *************************************************************************
         *                                                                         *
         *                     Transform, Inverse Transform                        *
         *                                                                         *
         **************************************************************************/

        @Override
        public Point2D transform(double x, double y) {
            ensureCanTransform2DPoint();

            switch (state2d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                    return new Point2D(
                        xx * x + xy * y + xt,
                        yx * x + yy * y + yt);
                case APPLY_SHEAR | APPLY_SCALE:
                    return new Point2D(
                        xx * x + xy * y,
                        yx * x + yy * y);
                case APPLY_SHEAR | APPLY_TRANSLATE:
                    return new Point2D(
                            xy * y + xt,
                            yx * x + yt);
                case APPLY_SHEAR:
                    return new Point2D(xy * y, yx * x);
                case APPLY_SCALE | APPLY_TRANSLATE:
                    return new Point2D(
                            xx * x + xt,
                            yy * y + yt);
                case APPLY_SCALE:
                    return new Point2D(xx * x, yy * y);
                case APPLY_TRANSLATE:
                    return new Point2D(x + xt, y + yt);
                case APPLY_IDENTITY:
                    return new Point2D(x, y);
            }
        }

        @Override
        public Point3D transform(double x, double y, double z) {
            switch (state3d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_NON_3D:
                    switch (state2d) {
                        default:
                            stateError();
                            // cannot reach
                        case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                            return new Point3D(
                                xx * x + xy * y + xt,
                                yx * x + yy * y + yt, z);
                        case APPLY_SHEAR | APPLY_SCALE:
                            return new Point3D(
                                xx * x + xy * y,
                                yx * x + yy * y, z);
                        case APPLY_SHEAR | APPLY_TRANSLATE:
                            return new Point3D(
                                    xy * y + xt, yx * x + yt,
                                    z);
                        case APPLY_SHEAR:
                            return new Point3D(xy * y, yx * x, z);
                        case APPLY_SCALE | APPLY_TRANSLATE:
                            return new Point3D(
                                    xx * x + xt, yy * y + yt,
                                    z);
                        case APPLY_SCALE:
                            return new Point3D(xx * x, yy * y, z);
                        case APPLY_TRANSLATE:
                            return new Point3D(x + xt, y + yt, z);
                        case APPLY_IDENTITY:
                            return new Point3D(x, y, z);
                    }
                case APPLY_TRANSLATE:
                    return new Point3D(x + xt, y + yt, z + zt);
                case APPLY_SCALE:
                    return new Point3D(xx * x, yy * y, zz * z);
                case APPLY_SCALE | APPLY_TRANSLATE:
                    return new Point3D(
                            xx * x + xt,
                            yy * y + yt,
                            zz * z + zt);
                case APPLY_3D_COMPLEX:
                    return new Point3D(
                        xx * x + xy * y + xz * z + xt,
                        yx * x + yy * y + yz * z + yt,
                        zx * x + zy * y + zz * z + zt);
            }
        }

        @Override
        public Point2D deltaTransform(double x, double y) {
            ensureCanTransform2DPoint();

            switch (state2d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                case APPLY_SHEAR | APPLY_SCALE:
                    return new Point2D(
                        xx * x + xy * y,
                        yx * x + yy * y);
                case APPLY_SHEAR | APPLY_TRANSLATE:
                case APPLY_SHEAR:
                    return new Point2D(xy * y, yx * x);
                case APPLY_SCALE | APPLY_TRANSLATE:
                case APPLY_SCALE:
                    return new Point2D(xx * x, yy * y);
                case APPLY_TRANSLATE:
                case APPLY_IDENTITY:
                    return new Point2D(x, y);
            }
        }

        @Override
        public Point3D deltaTransform(double x, double y, double z) {
            switch (state3d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_NON_3D:
                    switch (state2d) {
                        default:
                            stateError();
                            // cannot reach
                        case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                        case APPLY_SHEAR | APPLY_SCALE:
                            return new Point3D(
                                xx * x + xy * y,
                                yx * x + yy * y, z);
                        case APPLY_SHEAR | APPLY_TRANSLATE:
                        case APPLY_SHEAR:
                            return new Point3D(xy * y, yx * x, z);
                        case APPLY_SCALE | APPLY_TRANSLATE:
                        case APPLY_SCALE:
                            return new Point3D(xx * x, yy * y, z);
                        case APPLY_TRANSLATE:
                        case APPLY_IDENTITY:
                            return new Point3D(x, y, z);
                    }
                case APPLY_TRANSLATE:
                    return new Point3D(x, y, z);
                case APPLY_SCALE:
                case APPLY_SCALE | APPLY_TRANSLATE:
                    return new Point3D(xx * x, yy * y, zz * z);
                case APPLY_3D_COMPLEX:
                    return new Point3D(
                        xx * x + xy * y + xz * z,
                        yx * x + yy * y + yz * z,
                        zx * x + zy * y + zz * z);
            }
        }

        @Override
        public Point2D inverseTransform(double x, double y)
                throws NonInvertibleTransformException {
            ensureCanTransform2DPoint();

            switch (state2d) {
                default:
                    return super.inverseTransform(x, y);
                case APPLY_SHEAR | APPLY_TRANSLATE:
                    if (xy == 0.0 || yx == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D(
                            (1.0 / yx) * y - yt / yx,
                            (1.0 / xy) * x - xt / xy);
                case APPLY_SHEAR:
                    if (xy == 0.0 || yx == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D((1.0 / yx) * y, (1.0 / xy) * x);
                case APPLY_SCALE | APPLY_TRANSLATE:
                    if (xx == 0.0 || yy == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D(
                            (1.0 / xx) * x - xt / xx,
                            (1.0 / yy) * y - yt / yy);
                case APPLY_SCALE:
                    if (xx == 0.0 || yy == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D((1.0 / xx) * x, (1.0 / yy) * y);
                case APPLY_TRANSLATE:
                    return new Point2D(x - xt, y - yt);
                case APPLY_IDENTITY:
                    return new Point2D(x, y);
            }
        }

        @Override
        public Point3D inverseTransform(double x, double y, double z)
                throws NonInvertibleTransformException {
            switch(state3d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_NON_3D:
                    switch (state2d) {
                        default:
                            return super.inverseTransform(x, y, z);
                        case APPLY_SHEAR | APPLY_TRANSLATE:
                            if (xy == 0.0 || yx == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D(
                                    (1.0 / yx) * y - yt / yx,
                                    (1.0 / xy) * x - xt / xy, z);
                        case APPLY_SHEAR:
                            if (xy == 0.0 || yx == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D(
                                    (1.0 / yx) * y,
                                    (1.0 / xy) * x, z);
                        case APPLY_SCALE | APPLY_TRANSLATE:
                            if (xx == 0.0 || yy == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D(
                                    (1.0 / xx) * x - xt / xx,
                                    (1.0 / yy) * y - yt / yy, z);
                        case APPLY_SCALE:
                            if (xx == 0.0 || yy == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D((1.0 / xx) * x, (1.0 / yy) * y, z);
                        case APPLY_TRANSLATE:
                            return new Point3D(x - xt, y - yt, z);
                        case APPLY_IDENTITY:
                            return new Point3D(x, y, z);
                    }
                case APPLY_TRANSLATE:
                    return new Point3D(x - xt, y - yt, z - zt);
                case APPLY_SCALE:
                    if (xx == 0.0 || yy == 0.0 || zz == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point3D(
                            (1.0 / xx) * x,
                            (1.0 / yy) * y,
                            (1.0 / zz) * z);
                case APPLY_SCALE | APPLY_TRANSLATE:
                    if (xx == 0.0 || yy == 0.0 || zz == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point3D(
                            (1.0 / xx) * x - xt / xx,
                            (1.0 / yy) * y - yt / yy,
                            (1.0 / zz) * z - zt / zz);
                case APPLY_3D_COMPLEX:
                    return super.inverseTransform(x, y, z);
            }
        }

        @Override
        public Point2D inverseDeltaTransform(double x, double y)
                throws NonInvertibleTransformException {
            ensureCanTransform2DPoint();

            switch (state2d) {
                default:
                    return super.inverseDeltaTransform(x, y);
                case APPLY_SHEAR | APPLY_TRANSLATE:
                case APPLY_SHEAR:
                    if (xy == 0.0 || yx == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D((1.0 / yx) * y, (1.0 / xy) * x);
                case APPLY_SCALE | APPLY_TRANSLATE:
                case APPLY_SCALE:
                    if (xx == 0.0 || yy == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point2D((1.0 / xx) * x, (1.0 / yy) * y);
                case APPLY_TRANSLATE:
                case APPLY_IDENTITY:
                    return new Point2D(x, y);
            }
        }

        @Override
        public Point3D inverseDeltaTransform(double x, double y, double z)
                throws NonInvertibleTransformException {
            switch(state3d) {
                default:
                    stateError();
                    // cannot reach
                case APPLY_NON_3D:
                    switch (state2d) {
                        default:
                            return super.inverseDeltaTransform(x, y, z);
                        case APPLY_SHEAR | APPLY_TRANSLATE:
                        case APPLY_SHEAR:
                            if (xy == 0.0 || yx == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D(
                                    (1.0 / yx) * y,
                                    (1.0 / xy) * x, z);
                        case APPLY_SCALE | APPLY_TRANSLATE:
                        case APPLY_SCALE:
                            if (xx == 0.0 || yy == 0.0) {
                                throw new NonInvertibleTransformException(
                                        &quot;Determinant is 0&quot;);
                            }
                            return new Point3D(
                                    (1.0 / xx) * x,
                                    (1.0 / yy) * y, z);
                        case APPLY_TRANSLATE:
                        case APPLY_IDENTITY:
                            return new Point3D(x, y, z);
                    }

                case APPLY_TRANSLATE:
                    return new Point3D(x, y, z);
                case APPLY_SCALE | APPLY_TRANSLATE:
                case APPLY_SCALE:
                    if (xx == 0.0 || yy == 0.0 || zz == 0.0) {
                        throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                    }
                    return new Point3D(
                            (1.0 / xx) * x,
                            (1.0 / yy) * y,
                            (1.0 / zz) * z);
                case APPLY_3D_COMPLEX:
                    return super.inverseDeltaTransform(x, y, z);
            }
        }

        /* *************************************************************************
         *                                                                         *
         *                               Other API                                 *
         *                                                                         *
         **************************************************************************/

        @Override
        public String toString() {
           final StringBuilder sb = new StringBuilder(&quot;Transform [\n&quot;);

            sb.append(&quot;\t&quot;).append(xx);
            sb.append(&quot;, &quot;).append(xy);
            sb.append(&quot;, &quot;).append(xz);
            sb.append(&quot;, &quot;).append(xt);
            sb.append('\n');
            sb.append(&quot;\t&quot;).append(yx);
            sb.append(&quot;, &quot;).append(yy);
            sb.append(&quot;, &quot;).append(yz);
            sb.append(&quot;, &quot;).append(yt);
            sb.append('\n');
            sb.append(&quot;\t&quot;).append(zx);
            sb.append(&quot;, &quot;).append(zy);
            sb.append(&quot;, &quot;).append(zz);
            sb.append(&quot;, &quot;).append(zt);

            return sb.append(&quot;\n]&quot;).toString();
        }

        /* *************************************************************************
         *                                                                         *
         *                    Internal implementation stuff                        *
         *                                                                         *
         **************************************************************************/

        private void updateState() {
            updateState2D();

            state3d = APPLY_NON_3D;

            if (xz != 0.0 ||
                yz != 0.0 ||
                zx != 0.0 ||
                zy != 0.0)
            {
                state3d = APPLY_3D_COMPLEX;
            } else {
                if ((state2d &amp; APPLY_SHEAR) == 0) {
                    if (zt != 0.0) {
                        state3d |= APPLY_TRANSLATE;
                    }
                    if (zz != 1.0) {
                        state3d |= APPLY_SCALE;
                    }
                    if (state3d != APPLY_NON_3D) {
                        state3d |= (state2d &amp; (APPLY_SCALE | APPLY_TRANSLATE));
                    }
                } else {
                    if (zz != 1.0 || zt != 0.0) {
                        state3d = APPLY_3D_COMPLEX;
                    }
                }
            }
        }

        private void updateState2D() {
            if (xy == 0.0 &amp;&amp; yx == 0.0) {
                if (xx == 1.0 &amp;&amp; yy == 1.0) {
                    if (xt == 0.0 &amp;&amp; yt == 0.0) {
                        state2d = APPLY_IDENTITY;
                    } else {
                        state2d = APPLY_TRANSLATE;
                    }
                } else {
                    if (xt == 0.0 &amp;&amp; yt == 0.0) {
                        state2d = APPLY_SCALE;
                    } else {
                        state2d = (APPLY_SCALE | APPLY_TRANSLATE);
                    }
                }
            } else {
                if (xx == 0.0 &amp;&amp; yy == 0.0) {
                    if (xt == 0.0 &amp;&amp; yt == 0.0) {
                        state2d = APPLY_SHEAR;
                    } else {
                        state2d = (APPLY_SHEAR | APPLY_TRANSLATE);
                    }
                } else {
                    if (xt == 0.0 &amp;&amp; yt == 0.0) {
                        state2d = (APPLY_SHEAR | APPLY_SCALE);
                    } else {
                        state2d = (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE);
                    }
                }
            }
        }

        void ensureCanTransform2DPoint() throws IllegalStateException {
            if (state3d != APPLY_NON_3D) {
                throw new IllegalStateException(&quot;Cannot transform 2D point &quot;
                        + &quot;with a 3D transform&quot;);
            }
        }

        private static void stateError() {
            throw new InternalError(&quot;missing case in a switch&quot;);
        }


        @Override
        void apply(final Affine3D trans) {
            trans.concatenate(xx, xy, xz, xt,
                              yx, yy, yz, yt,
                              zx, zy, zz, zt);
        }

        @Override
        BaseTransform derive(final BaseTransform trans) {
            return trans.deriveWithConcatenation(xx, xy, xz, xt,
                                                 yx, yy, yz, yt,
                                                 zx, zy, zz, zt);
        }

        /**
         * Used only by tests to check the 2d matrix state
         */
        int getState2d() {
            return state2d;
        }

        /**
         * Used only by tests to check the 3d matrix state
         */
        int getState3d() {
            return state3d;
        }

    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.media/com/sun/media/jfxmedia/locator/ConnectionHolder.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.jfxmedia.locator;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.net.HttpURLConnection;
import java.net.JarURLConnection;
import java.net.URI;
import java.net.URLConnection;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.FileChannel;
import java.nio.channels.ReadableByteChannel;
import java.util.Map;

/**
 * Connection holders hold and maintain connection do different kinds of sources
 *
 */
public abstract class ConnectionHolder {
    private static int DEFAULT_BUFFER_SIZE = 4096;

    ReadableByteChannel channel;
    ByteBuffer          buffer = ByteBuffer.allocateDirect(DEFAULT_BUFFER_SIZE);

    static ConnectionHolder createMemoryConnectionHolder(ByteBuffer buffer) {
        return new MemoryConnectionHolder(buffer);
    }

    static ConnectionHolder createURIConnectionHolder(URI uri, Map&lt;String,Object&gt; connectionProperties) throws IOException {
        return new URIConnectionHolder(uri, connectionProperties);
    }

    static ConnectionHolder createFileConnectionHolder(URI uri) throws IOException {
        return new FileConnectionHolder(uri);
    }

    static ConnectionHolder createHLSConnectionHolder(URI uri) throws IOException {
        return new HLSConnectionHolder(uri);
    }

    /**
     * Reads a block of data from the current position of the opened stream.
     *
     * @return The number of bytes read, possibly zero, or -1 if the channel
     * has reached end-of-stream.
     *
     * @throws ClosedChannelException if an attempt is made to read after
     * closeConnection has been called
     */
    public int readNextBlock() throws IOException {
        buffer.rewind();
        if (buffer.limit() &lt; buffer.capacity()) {
            buffer.limit(buffer.capacity());
        }
        // avoid NPE if channel does not exist or has been closed
        if (null == channel) {
            throw new ClosedChannelException();
        }
        return channel.read(buffer);
    }

    public ByteBuffer getBuffer() {
        return buffer;
    }

    /**
     * Reads a block of data from the arbitrary position of the opened stream.
     *
     * @return The number of bytes read, possibly zero, or -1 if the given position
     * is greater than or equal to the file's current size.
     *
     * @throws ClosedChannelException if an attempt is made to read after
     * closeConnection has been called
     */
    abstract int readBlock(long position, int size) throws IOException;

    /**
     * Detects whether this source needs buffering at the pipeline level.
     * When true the pipeline contains progressbuffer after the source.
     *
     * @return true if the source needs a buffer, false otherwise.
     */
    abstract boolean needBuffer();

    /**
     * Detects whether the source is seekable.
     * @return true if the source is seekable, false otherwise.
     */
    abstract boolean isSeekable();

    /**
     * Detects whether the source is a random access source. If the method returns
     * true then the source is capable of working in pull mode. To be able to work
     * in pull mode holder must provide implementation.
     * @return true is the source is random access, false otherwise.
     */
    abstract boolean isRandomAccess();

    /**
     * Performs a seek request to the desired position.
     *
     * @return -1 if the seek request failed or new stream position
     */
    public abstract long seek(long position);

    /**
     * Closes connection when done.
     * Overriding methods should call this method in the beginning of their implementation.
     */
    public void closeConnection() {
        try {
            if (channel != null) {
                channel.close();
            }
        } catch (IOException ioex) {}
        finally {
            channel = null;
        }
    }

    /**
     * Get or set properties.
     *
     * @param prop - Property ID.
     * @param value - Depends on property ID.
     * @return - Depends on property ID.
     */
    int property(int prop, int value) {
        return 0;
    }

    /**
     * Get stream size.
     * Behavior can vary based on subclass implementation.
     * For example HLS will load next segment and return segment size.
     *
     * @return - Stream size.
     */
    int getStreamSize() {
        return -1;
<A NAME="5"></A>    }

    private static class FileConnectionHolder extends ConnectionHolder {
        <FONT color="#c8c2a7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#5',2,'match51-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private RandomAccessFile file = null;

        FileConnectionHolder(URI uri) throws IOException {
            channel = openFile(uri);
        }

        boolean needBuffer() {
            return false;
        }

        boolean isRandomAccess() {
            return true;
        }

        boolean isSeekable() {</B></FONT>
            return true;
        }

        public long seek(long position) {
            try {
                ((FileChannel)channel).position(position);
                return position;
            } catch(IOException ioex) {
                return -1;
            }
        }

        int readBlock(long position, int size) throws IOException {
            if (null == channel) {
                throw new ClosedChannelException();
            }

            if (buffer.capacity() &lt; size) {
                buffer = ByteBuffer.allocateDirect(size);
            }
            buffer.rewind().limit(size);
            return ((FileChannel)channel).read(buffer, position);
        }

        private ReadableByteChannel openFile(final URI uri) throws IOException {
            if (file != null) {
                file.close();
            }

            file = new RandomAccessFile(new File(uri), &quot;r&quot;);
            return file.getChannel();
        }

        @Override
        public void closeConnection() {
            super.closeConnection();

            if (file != null) {
                try {
                    file.close();
                } catch (IOException ex) {
                } finally {
                    file = null;
                }
            }
        }
    }

    private static class URIConnectionHolder extends ConnectionHolder {
        private URI                 uri;
        private URLConnection       urlConnection;

        URIConnectionHolder(URI uri, Map&lt;String,Object&gt; connectionProperties) throws IOException {
            this.uri = uri;
            urlConnection = uri.toURL().openConnection();
            if (connectionProperties != null) {
                for(Map.Entry&lt;String,Object&gt; entry : connectionProperties.entrySet()) {
                    Object value = entry.getValue();
                    if (value instanceof String) {
                        urlConnection.setRequestProperty(entry.getKey(), (String)value);
                    }
                }
            }
            channel = openChannel(null);
        }

        boolean needBuffer() {
            String scheme = uri.getScheme().toLowerCase();
            return (&quot;http&quot;.equals(scheme) || &quot;https&quot;.equals(scheme));
        }

        boolean isSeekable() {
            return (urlConnection instanceof HttpURLConnection) || (urlConnection instanceof JarURLConnection);
        }

        boolean isRandomAccess() {
            return false;
        }

        int readBlock(long position, int size) throws IOException {
            throw new IOException();
        }

        public long seek(long position) {
            if (urlConnection instanceof HttpURLConnection) {
                URLConnection tmpURLConnection = null;

                //closeConnection();
                try{
                    tmpURLConnection = uri.toURL().openConnection();

                    HttpURLConnection httpConnection = (HttpURLConnection)tmpURLConnection;
                    httpConnection.setRequestMethod(&quot;GET&quot;);
                    httpConnection.setUseCaches(false);
                    httpConnection.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + position + &quot;-&quot;);
                    // If range request worked properly we should get responce code 206 (HTTP_PARTIAL)
                    // Else fail seek and let progressbuffer to download all data. It is pointless for us to download it and throw away.
                    if (httpConnection.getResponseCode() == HttpURLConnection.HTTP_PARTIAL) {
                        closeConnection();
                        urlConnection = tmpURLConnection;
                        tmpURLConnection = null;
                        channel = openChannel(null);
                        return position;
                    } else {
                        return -1;
                    }
                } catch (IOException ioex) {
                    return -1;
                } finally {
                    if (tmpURLConnection != null) {
                        Locator.closeConnection(tmpURLConnection);
                    }
                }
            } else if (urlConnection instanceof JarURLConnection) {
                try {
                    closeConnection();

                    urlConnection = uri.toURL().openConnection();

                    // Skip data that we do not need
                    long skip_left = position;
                    InputStream inputStream = urlConnection.getInputStream();
                    do {
                        long skip = inputStream.skip(skip_left);
                        skip_left -= skip;
                    } while (skip_left &gt; 0);

                    channel = openChannel(inputStream);

                    return position;
                } catch (IOException ioex) {
                    return -1;
                }
            }

            return -1;
        }

        @Override
        public void closeConnection() {
            super.closeConnection();

            Locator.closeConnection(urlConnection);
            urlConnection = null;
        }

        private ReadableByteChannel openChannel(InputStream inputStream) throws IOException {
            return (inputStream == null) ?
                    Channels.newChannel(urlConnection.getInputStream()) :
                    Channels.newChannel(inputStream);
        }
    }

    // A &quot;ConnectionHolder&quot; that &quot;reads&quot; from a ByteBuffer, generally loaded from
    // some unsupported or buggy source
    private static class MemoryConnectionHolder extends ConnectionHolder {
        private final ByteBuffer backingBuffer;

        public MemoryConnectionHolder(ByteBuffer buf) {
            if (null == buf) {
                throw new IllegalArgumentException(&quot;Can't connect to null buffer...&quot;);
            }

            if (buf.isDirect()) {
                // we can use it, or rather a duplicate directly
                backingBuffer = buf.duplicate();
            } else {
                // operate on a copy of the buffer
                backingBuffer = ByteBuffer.allocateDirect(buf.capacity());
                backingBuffer.put(buf);
            }

            // rewind since the default position is expected to be at zero
            backingBuffer.rewind();

            // readNextBlock should never be called since we're random access
            // but just to be safe (and for unit tests...)
            channel = new ReadableByteChannel() {
                public int read(ByteBuffer bb) throws IOException {
                    if (backingBuffer.remaining() &lt;= 0) {
                        return -1; // EOS
                    }

                    int actual;
                    if (bb.equals(buffer)) {
                        // we'll cheat here as we know that bb is buffer and rather
                        // than copy the data, just slice it like for readBlock
                        actual = Math.min(DEFAULT_BUFFER_SIZE, backingBuffer.remaining());
                        if (actual &gt; 0) {
                            buffer = backingBuffer.slice();
                            buffer.limit(actual);
                        }
                    } else {
                        actual = Math.min(bb.remaining(), backingBuffer.remaining());
                        if (actual &gt; 0) {
                            backingBuffer.limit(backingBuffer.position() + actual);
                            bb.put(backingBuffer);
                            backingBuffer.limit(backingBuffer.capacity());
                        }
                    }
                    return actual;
                }

                public boolean isOpen() {
                    return true; // open 24/7/365
                }

                public void close() throws IOException {
                    // never closed...
                }
            };
        }

        @Override
        int readBlock(long position, int size) throws IOException {
            // mimic stream behavior
            if (null == channel) {
                throw new ClosedChannelException();
            }

            if ((int)position &gt; backingBuffer.capacity()) {
                return -1; //EOS
            }
            backingBuffer.position((int)position);

            buffer = backingBuffer.slice();

            int actual = Math.min(backingBuffer.remaining(), size);
            buffer.limit(actual); // only give as much as asked
            backingBuffer.position(backingBuffer.position() + actual);

            return actual;
        }

        @Override
        boolean needBuffer() {
            return false;
        }

        @Override
        boolean isSeekable() {
            return true;
        }

        @Override
        boolean isRandomAccess() {
            return true;
        }

        @Override
        public long seek(long position) {
            if ((int)position &lt; backingBuffer.capacity()) {
                backingBuffer.limit(backingBuffer.capacity());
                backingBuffer.position((int)position);
                return position;
            }
            return -1;
        }

        @Override
        public void closeConnection() {
            // more stream behavior mimicry
            channel = null;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/javafx/webkit/prism/WCGraphicsPrismContext.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.webkit.prism;

import com.sun.glass.ui.Screen;
import com.sun.javafx.font.FontStrike;
import com.sun.javafx.font.Metrics;
import com.sun.javafx.font.PGFont;
import com.sun.javafx.geom.*;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;
import com.sun.javafx.scene.text.GlyphList;
import com.sun.javafx.scene.text.TextLayout;
import com.sun.javafx.sg.prism.*;
import com.sun.javafx.text.TextRun;
import com.sun.prism.*;
import com.sun.prism.paint.Color;
import com.sun.prism.paint.Gradient;
import com.sun.prism.paint.ImagePattern;
import com.sun.prism.paint.Paint;
import com.sun.scenario.effect.*;
import com.sun.scenario.effect.impl.prism.PrDrawable;
import com.sun.scenario.effect.impl.prism.PrEffectHelper;
import com.sun.scenario.effect.impl.prism.PrFilterContext;
import com.sun.webkit.graphics.*;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.List;

import static com.sun.scenario.effect.Blend.Mode.*;
import com.sun.scenario.effect.impl.Renderer;
import com.sun.scenario.effect.impl.prism.PrRenderer;

class WCGraphicsPrismContext extends WCGraphicsContext {

    public enum Type {
        /**
         * Base context associated with the topmost page buffer.
         * Created and disposed during a single render pass.
         */
        PRIMARY,

        /**
         * A context associated with a dedicated buffer representing
         * a separate render target like canvas, buffered image etc.
         * Its life cycle is not limited to a single render pass.
         */
        DEDICATED
    }

    private final static PlatformLogger log =
            PlatformLogger.getLogger(WCGraphicsPrismContext.class.getName());
    private final static boolean DEBUG_DRAW_CLIP_SHAPE = Boolean.valueOf(
            AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt;
            System.getProperty(&quot;com.sun.webkit.debugDrawClipShape&quot;, &quot;false&quot;)));

    Graphics baseGraphics;
    private BaseTransform baseTransform;

    private final List&lt;ContextState&gt; states = new ArrayList&lt;ContextState&gt;();

    private ContextState state = new ContextState();

    // Cache for getPlatformGraphics
    private Graphics cachedGraphics = null;

    private int fontSmoothingType;
    private boolean isRootLayerValid = false;

    WCGraphicsPrismContext(Graphics g) {
        state.setClip(g.getClipRect());
        state.setAlpha(g.getExtraAlpha());
        baseGraphics = g;
        initBaseTransform(g.getTransformNoClone());
    }

    WCGraphicsPrismContext() {
    }

    public Type type() {
        return Type.PRIMARY;
    }

    final void initBaseTransform(BaseTransform t) {
        baseTransform = new Affine3D(t);
        state.setTransform((Affine3D)baseTransform);
    }

    private void resetCachedGraphics() {
        cachedGraphics = null;
    }

    @Override
    public Object getPlatformGraphics() {
        return getGraphics(false);
    }

    Graphics getGraphics(boolean checkClip) {
        if (cachedGraphics == null) {
            Layer l = state.getLayerNoClone();
            cachedGraphics = (l != null)
                    ? l.getGraphics()
                    : baseGraphics;

            state.apply(cachedGraphics);

            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;getPlatformGraphics for &quot; + this + &quot; : &quot; +
                         cachedGraphics);
            }
        }

        Rectangle clip = cachedGraphics.getClipRectNoClone();
        return (checkClip &amp;&amp; clip!=null &amp;&amp; clip.isEmpty())
            ? null
            : cachedGraphics;
    }

    public void saveState()
    {
        state.markAsRestorePoint();
        saveStateInternal();
    }

    private void saveStateInternal()
    {
        states.add(state);
        state = state.clone();
    }

    private void startNewLayer(Layer layer) {
        saveStateInternal();

        // layer has the same bounds as clip, so we have to translate
        Rectangle clip = state.getClipNoClone();

        //left-side (post-) translate.
        //NB! an order of transforms is essential!
        Affine3D newTr = new Affine3D(BaseTransform.getTranslateInstance(
                -clip.x,
                -clip.y));
        newTr.concatenate(state.getTransformNoClone());

        //move clip to (0, 0) - start of texture
        clip.x = 0;
        clip.y = 0;
        //no-clone - no-set!

        Graphics g = getGraphics(true);
        if (g != null &amp;&amp; g != baseGraphics) {
            layer.init(g);
        }

        state.setTransform(newTr);
        state.setLayer(layer);

        resetCachedGraphics();
    }

    private void renderLayer(final Layer layer) {
        WCTransform cur = getTransform();

        //translate to (layer.getX(), layer.getY())
        setTransform(new WCTransform(
            1.0, 0.0,
            0.0, 1.0,
            layer.getX(), layer.getY()));

        // composite drawing delegated to the layer rendering
        Graphics g = getGraphics(true);
        if (g != null) {
            layer.render(g);
        }

        //restore transform
        setTransform(cur);
    }

    private void restoreStateInternal() {
        int size = states.size();
        if (size == 0) {
            assert false: &quot;Unbalanced restoreState&quot;;
            return;
        }

        Layer layer = state.getLayerNoClone();
        state = states.remove(size - 1);
        if (layer != state.getLayerNoClone()) {
            renderLayer(layer);
            layer.dispose();
            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;Popped layer &quot; + layer);
            }
        } else {
            resetCachedGraphics();
        }
    }

    public void restoreState()
    {
        log.fine(&quot;restoring state&quot;);
        do {
            restoreStateInternal();
        } while ( !state.isRestorePoint() );
    }

    /**
     *  Renders all layers to the underlaying Graphics, but preserves the
     *  current state and the states stack
     */
    private void flushAllLayers() {
        if (state == null) {
            // context disposed
            return;
        }

        if (isRootLayerValid) {
            log.fine(&quot;FlushAllLayers: root layer is valid, skipping&quot;);
            return;
        }

        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;FlushAllLayers&quot;);
        }

        ContextState currentState = state;

        for (int i = states.size() - 1; i &gt;=0; i--) {
            Layer layer = state.getLayerNoClone();
            state = states.get(i);
            if (layer != state.getLayerNoClone()) {
                renderLayer(layer);
            } else {
                resetCachedGraphics();
            }
        }

        Layer layer = state.getLayerNoClone();
        if (layer != null) {
            renderLayer(layer);
        }
<A NAME="8"></A>
        state = currentState;
        isRootLayerValid = true;
    <FONT color="#bce954"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#8',2,'match51-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}


    public void dispose() {
        if (!states.isEmpty()) {
            log.fine(&quot;Unbalanced saveState/restoreState&quot;);
        }
        for (ContextState state: states) {</B></FONT>
            if (state.getLayerNoClone() != null) {
                state.getLayerNoClone().dispose();
            }
        }
        states.clear();

        if (state != null &amp;&amp; state.getLayerNoClone() != null) {
            state.getLayerNoClone().dispose();
        }
        state = null;
    }


    public void setClip(WCPath path, boolean isOut) {
        Affine3D tr = new Affine3D(state.getTransformNoClone());
        path.transform(
                tr.getMxx(), tr.getMyx(),
                tr.getMxy(), tr.getMyy(),
                tr.getMxt(), tr.getMyt());
        //path now is in node coordinates, as well as clip

        if (!isOut) {
            WCRectangle pathBounds = path.getBounds();

            // path bounds could be fractional so 'inclusive' rounding
            // is used for determining clip rectangle
            int pixelX = (int) Math.floor(pathBounds.getX());
            int pixelY = (int) Math.floor(pathBounds.getY());
            int pixelW = (int) Math.ceil(pathBounds.getMaxX()) - pixelX;
            int pixelH = (int) Math.ceil(pathBounds.getMaxY()) - pixelY;

            state.clip(new Rectangle(pixelX, pixelY, pixelW, pixelH));
        }

        Rectangle clip = state.getClipNoClone();

        if (isOut) {
            path.addRect(clip.x, clip.y, clip.width, clip.height);
            //Out clip path is always EVENODD.
        }

        path.translate(-clip.x, -clip.y);

        Layer layer = new ClipLayer(
            getGraphics(false), clip, path, type() == Type.DEDICATED);

        startNewLayer(layer);

        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setClip(WCPath &quot; + path.getID() + &quot;)&quot;);
            log.fine(&quot;Pushed layer &quot; + layer);
        }
    }

    private Rectangle transformClip(Rectangle localClip) {
        if (localClip==null) {
            return null;
        }

        float[] points = new float[] {
            localClip.x, localClip.y,
            localClip.x + localClip.width, localClip.y,
            localClip.x, localClip.y + localClip.height,
            localClip.x  + localClip.width, localClip.y + localClip.height};
        state.getTransformNoClone().transform(points, 0, points, 0, 4);
        float minX = Math.min(
               points[0], Math.min(
               points[2], Math.min(
               points[4], points[6])));
        float maxX = Math.max(
               points[0], Math.max(
               points[2], Math.max(
               points[4], points[6])));
        float minY = Math.min(
               points[1], Math.min(
               points[3], Math.min(
               points[5], points[7])));
        float maxY = Math.max(
               points[1], Math.max(
               points[3], Math.max(
               points[5], points[7])));
        return new Rectangle(new RectBounds(minX, minY, maxX, maxY));

/* #1 loose rotate
        state.getTransformNoClone().transform(localClip, localClip);
*/
/* #2 problem with negative coordinates
        RectBounds rb = TransformedShape.transformedShape(
            new RoundRectangle2D(localClip.x, localClip.y, localClip.width, localClip.height, 0, 0),
            state.getTransformNoClone()).getBounds();
        return rb.isEmpty()
            ? null
            : new Rectangle(rb);
 */
    }

    private void setClip(Rectangle shape) {
        Affine3D tr = state.getTransformNoClone();
        if (tr.getMxy() == 0 &amp;&amp; tr.getMxz() == 0
         &amp;&amp; tr.getMyx() == 0 &amp;&amp; tr.getMyz() == 0
         &amp;&amp; tr.getMzx() == 0 &amp;&amp; tr.getMzy() == 0) {
            //There is no rotation here: scale + translation.
            //Fast &amp; easy!
            state.clip(transformClip(shape));
            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;setClip({0})&quot;, shape);
            }
            if (DEBUG_DRAW_CLIP_SHAPE) {
                //Draw clip shape
                Rectangle rc = state.getClipNoClone();
                if (rc != null &amp;&amp; rc.width &gt;= 2 &amp;&amp; rc.height &gt;= 2) {
                    WCTransform cur = getTransform();
                    //translate to (layer.getX(), layer.getY())
                    setTransform(new WCTransform(
                        1.0, 0.0,
                        0.0, 1.0,
                        0.0, 0.0));

                    Graphics g2d = getGraphics(true);
                    if (g2d != null) {
                        float fbase = (float)Math.random();
                        g2d.setPaint(new Color(
                                fbase,
                                1f - fbase,
                                0.5f,
                                0.1f));
                        g2d.setStroke(new BasicStroke());
                        g2d.fillRect(rc.x, rc.y, rc.width, rc.height);

                        g2d.setPaint(new Color(
                                1f - fbase,
                                fbase,
                                0.5f,
                                1f));
                        g2d.drawRect(rc.x, rc.y, rc.width, rc.height);
                    }
                    //restore transform
                    setTransform(cur);
                    state.clip(new Rectangle(rc.x+1, rc.y+1, rc.width-2, rc.height-2));
                }
            }
            if (cachedGraphics != null) {
                cachedGraphics.setClipRect(state.getClipNoClone());
            }
        } else {
            //twisted axis set
            WCPath path = new WCPathImpl();
            path.addRect(shape.x, shape.y, shape.width, shape.height);
            setClip(path, false);
        }
    }

    public void setClip(int cx, int cy, int cw, int ch) {
        setClip(new Rectangle(cx, cy, cw, ch));
    }

    public void setClip(WCRectangle c) {
        setClip(new Rectangle((int)c.getX(), (int)c.getY(),
                              (int)c.getWidth(), (int)c.getHeight()));
    }

    public WCRectangle getClip() {
        Rectangle r = state.getClipNoClone();
        return r == null ? null : new WCRectangle(r.x, r.y, r.width, r.height);
    }

    protected Rectangle getClipRectNoClone() {
        return state.getClipNoClone();
    }

    protected Affine3D getTransformNoClone() {
        return state.getTransformNoClone();
    }

    public void translate(float x, float y) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;translate({0},{1})&quot;, new Object[] {x, y});
        }
        state.translate(x, y);
        if (cachedGraphics != null) {
            cachedGraphics.translate(x, y);
        }
    }

    public void scale(float sx, float sy) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;scale(&quot; + sx + &quot; &quot; + sy + &quot;)&quot;);
        }
        state.scale(sx, sy);
        if (cachedGraphics != null) {
            cachedGraphics.scale(sx, sy);
        }
    }

    public void rotate(float radians) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;rotate(&quot; + radians + &quot;)&quot;);
        }
        state.rotate(radians);
        if (cachedGraphics != null) {
            cachedGraphics.setTransform(state.getTransformNoClone());
        }
    }

    // overriden in WCBufferedContext
    protected boolean shouldRenderRect(float x, float y, float w, float h,
                                       DropShadow shadow, BasicStroke stroke)
    {
        return true;
    }

    // overriden in WCBufferedContext
    protected boolean shouldRenderShape(Shape shape, DropShadow shadow, BasicStroke stroke) {
        return true;
    }

    // overriden in WCBufferedContext
    protected boolean shouldCalculateIntersection() {
        return false;
    }

    @Override
    public void fillRect(final float x, final float y, final float w, final float h, final Integer rgba) {
        if (log.isLoggable(Level.FINE)) {
            String format = (rgba != null)
                    ? &quot;fillRect(%f, %f, %f, %f, 0x%x)&quot;
                    : &quot;fillRect(%f, %f, %f, %f, null)&quot;;
            log.fine(String.format(format, x, y, w, h, rgba));
        }
        if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                Paint paint = (rgba != null) ? createColor(rgba) : state.getPaintNoClone();
                DropShadow shadow = state.getShadowNoClone();
                // TextureMapperJava::drawSolidColor calls fillRect with perspective
                // projection.
                if (shadow != null || !state.getPerspectiveTransformNoClone().isIdentity()) {
                    final NGRectangle node = new NGRectangle();
                    node.updateRectangle(x, y, w, h, 0, 0);
                    render(g, shadow, paint, null, node);
                } else {
                    g.setPaint(paint);
                    g.fillRect(x, y, w, h);
                }
            }
        }.paint();
    }

    @Override
    public void fillRoundedRect(final float x, final float y, final float w, final float h,
        final float topLeftW, final float topLeftH, final float topRightW, final float topRightH,
        final float bottomLeftW, final float bottomLeftH, final float bottomRightW, final float bottomRightH,
        final int rgba)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;fillRoundedRect(%f, %f, %f, %f, &quot;
                    + &quot;%f, %f, %f, %f, %f, %f, %f, %f, 0x%x)&quot;,
                    x, y, w, h, topLeftW, topLeftH, topRightW, topRightH,
                    bottomLeftW, bottomLeftH, bottomRightW, bottomRightH, rgba));
        }
        if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                // Prism only supports single arcWidth/Height.
                // We work around by calculating average width and height here

                float arcW = (topLeftW + topRightW + bottomLeftW + bottomRightW) / 2;
                float arcH = (topLeftH + topRightH + bottomLeftH + bottomRightH) / 2;

                Paint paint = createColor(rgba);
                DropShadow shadow = state.getShadowNoClone();
                if (shadow != null) {
                    final NGRectangle node = new NGRectangle();
                    node.updateRectangle(x, y, w, h, arcW, arcH);
                    render(g, shadow, paint, null, node);
                } else {
                    g.setPaint(paint);
                    g.fillRoundRect(x, y, w, h, arcW, arcH);
                }
            }
        }.paint();
    }

    @Override
    public void clearRect(final float x, final float y, final float w, final float h) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;clearRect(%f, %f, %f, %f)&quot;, x, y, w, h));
        }
        if (shouldCalculateIntersection()) {
            // No intersection is applicable for clearRect.
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                g.clearQuad(x, y, x + w, y + h);
            }
        }.paint();
    }

    @Override
    public void setFillColor(int rgba) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;setFillColor(0x%x)&quot;, rgba));
        }
        state.setPaint(createColor(rgba));
    }

    @Override
    public void setFillGradient(WCGradient gradient) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setFillGradient(&quot; + gradient + &quot;)&quot;);
        }
        state.setPaint((Gradient) gradient.getPlatformGradient());
    }

    @Override
    public void setTextMode(boolean fill, boolean stroke, boolean clip) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setTextMode(fill:&quot; + fill + &quot;,stroke:&quot; + stroke + &quot;,clip:&quot; + clip + &quot;)&quot;);
        }
        state.setTextMode(fill, stroke, clip);
    }

    @Override
    public void setFontSmoothingType(int fontSmoothingType) {
        this.fontSmoothingType = fontSmoothingType;
    }

    @Override
    public int getFontSmoothingType() {
        return fontSmoothingType;
    }

    @Override
    public void setStrokeStyle(int style) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setStrokeStyle({0})&quot;, style);
        }
        state.getStrokeNoClone().setStyle(style);
    }

    @Override
    public void setStrokeColor(int rgba) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;setStrokeColor(0x%x)&quot;, rgba));
        }
        state.getStrokeNoClone().setPaint(createColor(rgba));
    }

    @Override
    public void setStrokeWidth(float width) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setStrokeWidth({0})&quot;, new Object[] { width });
        }
        state.getStrokeNoClone().setThickness(width);
    }

    @Override
    public void setStrokeGradient(WCGradient gradient) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setStrokeGradient(&quot; + gradient + &quot;)&quot;);
        }
        state.getStrokeNoClone().setPaint((Gradient) gradient.getPlatformGradient());
    }

    @Override
    public void setLineDash(float offset, float... sizes) {
        if (log.isLoggable(Level.FINE)) {
            StringBuilder s = new StringBuilder(&quot;[&quot;);
            for (int i=0; i &lt; sizes.length; i++) {
                s.append(sizes[i]).append(',');
            }
            s.append(']');
            log.fine(&quot;setLineDash({0},{1}&quot;, new Object[] {offset, s});
        }
        state.getStrokeNoClone().setDashOffset(offset);
        if (sizes != null) {
            boolean allZero = true;
            for (int i = 0; i &lt; sizes.length; i++) {
                if (sizes[i] != 0) {
                    allZero = false;
                    break;
                }
            }
            if (allZero) {
                sizes = null;
            }
        }
        state.getStrokeNoClone().setDashSizes(sizes);
    }

    @Override
    public void setLineCap(int lineCap) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setLineCap(&quot; + lineCap + &quot;)&quot;);
        }
        state.getStrokeNoClone().setLineCap(lineCap);
    }

    @Override
    public void setLineJoin(int lineJoin) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setLineJoin(&quot; + lineJoin + &quot;)&quot;);
        }
        state.getStrokeNoClone().setLineJoin(lineJoin);
    }

    @Override
    public void setMiterLimit(float miterLimit) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;setMiterLimit(&quot; + miterLimit + &quot;)&quot;);
        }
        state.getStrokeNoClone().setMiterLimit(miterLimit);
    }

    @Override
    public void setShadow(float dx, float dy, float blur, int rgba) {
        if (log.isLoggable(Level.FINE)) {
            String format = &quot;setShadow(%f, %f, %f, 0x%x)&quot;;
            log.fine(String.format(format, dx, dy, blur, rgba));
        }
        state.setShadow(createShadow(dx, dy, blur, rgba));
    }

    @Override
    public void drawPolygon(final WCPath path, final boolean shouldAntialias) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawPolygon({0})&quot;,
                    new Object[] {shouldAntialias});
        }
        if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(), null,
                                state.getStrokeNoClone().getPlatformStroke()))
        {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                Path2D p2d = (Path2D) path.getPlatformPath();
                g.setPaint(state.getPaintNoClone());
                g.fill(p2d);
                if (state.getStrokeNoClone().apply(g)) {
                    g.draw(p2d);
                }
            }
        }.paint();
    }

    @Override
    public void drawLine(final int x0, final int y0, final int x1, final int y1) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawLine({0}, {1}, {2}, {3})&quot;,
                    new Object[] {x0, y0, x1, y1});
        }
        Line2D line = new Line2D(x0, y0, x1, y1);
        if (!shouldRenderShape(line, null, state.getStrokeNoClone().getPlatformStroke())) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                if (state.getStrokeNoClone().apply(g)) {
                    g.drawLine(x0, y0, x1, y1);
                }
            }
        }.paint();
    }

    @Override
    public void drawPattern(
        final WCImage texture,
        final WCRectangle srcRect,
        final WCTransform patternTransform,
        final WCPoint phase,
        final WCRectangle destRect)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawPattern({0}, {1}, {2}, {3})&quot;,
                    new Object[] {destRect.getIntX(), destRect.getIntY(),
                                  destRect.getIntWidth(),
                                  destRect.getIntHeight()});
        }
        if (!shouldRenderRect(destRect.getX(), destRect.getY(),
                              destRect.getWidth(), destRect.getHeight(), null, null))
        {
            return;
        }
        if (texture != null) {
            new Composite() {
                @Override void doPaint(Graphics g) {
                    // The handling of pattern transform is modeled after the WebKit
                    // ImageCG.cpp's Image::drawPattern()
                    float adjustedX = phase.getX()
                            + srcRect.getX() * (float) patternTransform.getMatrix()[0];
                    float adjustedY = phase.getY()
                            + srcRect.getY() * (float) patternTransform.getMatrix()[3];
                    float scaledTileWidth =
                            srcRect.getWidth() * (float) patternTransform.getMatrix()[0];
                    float scaledTileHeight =
                            srcRect.getHeight() * (float) patternTransform.getMatrix()[3];

                    Image img = ((PrismImage)texture).getImage();

                    // Create subImage only if srcRect doesn't fit the texture bounds. See RT-20193.
                    if (!srcRect.contains(new WCRectangle(0, 0, texture.getWidth(), texture.getHeight()))) {

                        img = img.createSubImage(srcRect.getIntX(),
                                                 srcRect.getIntY(),
                                                 (int)Math.ceil(srcRect.getWidth()),
                                                 (int)Math.ceil(srcRect.getHeight()));
                    }
                    g.setPaint(new ImagePattern(
                               img,
                               adjustedX, adjustedY,
                               scaledTileWidth, scaledTileHeight,
                               false, false));

                    g.fillRect(destRect.getX(), destRect.getY(),
                               destRect.getWidth(), destRect.getHeight());
                }
            }.paint();
        }
    }

    @Override
    public void drawImage(final WCImage img,
                          final float dstx, final float dsty, final float dstw, final float dsth,
                          final float srcx, final float srcy, final float srcw, final float srch)
    {
        if (log.isLoggable(Level.FINE)){
            log.fine(&quot;drawImage(img, dst({0},{1},{2},{3}), &quot; +
                    &quot;src({4},{5},{6},{7}))&quot;,
                    new Object[] {dstx, dsty, dstw, dsth,
                                  srcx, srcy, srcw, srch});
        }
        if (!shouldRenderRect(dstx, dsty, dstw, dsth, state.getShadowNoClone(), null)) {
            return;
        }
        if (img instanceof PrismImage) {
            new Composite() {
                @Override void doPaint(Graphics g) {
                    PrismImage pi = (PrismImage) img;
                    DropShadow shadow = state.getShadowNoClone();
                    if (shadow != null) {
                        NGImageView node = new NGImageView();
                        node.setImage(pi.getImage());
                        node.setX(dstx);
                        node.setY(dsty);
                        node.setViewport(srcx, srcy, srcw, srch, dstw, dsth);
                        node.setContentBounds(new RectBounds(dstx, dsty, dstx + dstw, dsty + dsth));
                        render(g, shadow, null, null, node);
                    } else {
                        pi.draw(g,
                                (int) dstx, (int) dsty,
                                (int) (dstx + dstw), (int) (dsty + dsth),
                                (int) srcx, (int) srcy,
                                (int) (srcx + srcw), (int) (srcy + srch));
                    }
                }
            }.paint();
        }
    }

    @Override
    public void drawBitmapImage(final ByteBuffer image, final int x, final int y, final int w, final int h) {
        if (!shouldRenderRect(x, y, w, h, null, null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                image.order(ByteOrder.nativeOrder());
                Image img = Image.fromByteBgraPreData(image, w, h);
                ResourceFactory rf = g.getResourceFactory();
                Texture txt = rf.createTexture(img, Texture.Usage.STATIC, Texture.WrapMode.REPEAT);
                g.drawTexture(txt, x, y, x + w, y + h, 0, 0, w, h);
                txt.dispose();
            }
        }.paint();
    }

    @Override
    public void drawIcon(WCIcon icon, int x, int y) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;UNIMPLEMENTED drawIcon ({0}, {1})&quot;,
                    new Object[] {x, y});
        }
    }

    @Override
    public void drawRect(final int x, final int y, final int w, final int h) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawRect({0}, {1}, {2}, {3})&quot;,
                    new Object[]{x, y, w, h});
        }
        if (!shouldRenderRect(x, y, w, h,
                              null, state.getStrokeNoClone().getPlatformStroke()))
        {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                Paint c = state.getPaintNoClone();
                if (c != null &amp;&amp; c.isOpaque()) {
                    g.setPaint(c);
                    g.fillRect(x, y, w, h);
                }

                if (state.getStrokeNoClone().apply(g)) {
                    g.drawRect(x, y, w, h);
                }
            }
        }.paint();
    }

    @Override
    public void drawString(final WCFont f, final int[] glyphs,
                           final float[] advances, final float x, final float y)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(
                    &quot;Drawing %d glyphs @(%.1f, %.1f)&quot;,
                    glyphs.length, x, y));
        }
        PGFont font = (PGFont)f.getPlatformFont();
        TextRun gl = TextUtilities.createGlyphList(glyphs, advances, x, y);

        DropShadow shadow = state.getShadowNoClone();
        BasicStroke stroke = state.isTextStroke()
                ? state.getStrokeNoClone().getPlatformStroke()
                : null;

        final FontStrike strike = font.getStrike(getTransformNoClone(), getFontSmoothingType());
        if (shouldCalculateIntersection()) {
            Metrics m = strike.getMetrics();
            gl.setMetrics(m.getAscent(), m.getDescent(), m.getLineGap());
            if (!shouldRenderRect(x, y, gl.getWidth(), gl.getHeight(), shadow, stroke)) {
                return;
            }
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                Paint paint = state.isTextFill()
                        ? state.getPaintNoClone()
                        : null;
                if (shadow != null) {
                    final NGText span = new NGText();
                    span.setGlyphs(new GlyphList[] {gl});
                    span.setFont(font);
                    span.setFontSmoothingType(fontSmoothingType);
                    render(g, shadow, paint, stroke, span);
                } else {
                    if (paint != null) {
                        g.setPaint(paint);
                        g.drawString(gl, strike, x, y, null, 0, 0);
                    }
                    if (stroke != null) {
                        paint = state.getStrokeNoClone().getPaint();
                        if (paint != null) {
                            g.setPaint(paint);
                            g.setStroke(stroke);
                            g.draw(strike.getOutline(gl, BaseTransform.getTranslateInstance(x, y)));
                        }
                    }
                }
            }
        }.paint();
    }

    @Override public void drawString(WCFont f, String str, boolean rtl,
            int from, int to, float x, float y)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(
                    &quot;str='%s' (length=%d), from=%d, to=%d, rtl=%b, @(%.1f, %.1f)&quot;,
                    str, str.length(), from, to, rtl, x, y));
        }
        TextLayout layout = TextUtilities.createLayout(
                str.substring(from, to), f.getPlatformFont());
        int count = 0;
        GlyphList[] runs = layout.getRuns();
        for (GlyphList run: runs) {
            count += run.getGlyphCount();
        }

        int[] glyphs = new int[count];
        float[] adv = new float[count];
        count = 0;
        for (GlyphList run: layout.getRuns()) {
            int gc = run.getGlyphCount();
            for (int i = 0; i &lt; gc; i++) {
                glyphs[count] = run.getGlyphCode(i);
                adv[count] = run.getPosX(i + 1) - run.getPosX(i);
                count++;
            }
        }

        // adjust x coordinate (see RT-29908)
        if (rtl) {
            x += (TextUtilities.getLayoutWidth(str.substring(from), f.getPlatformFont()) -
                  layout.getBounds().getWidth());
        } else {
            x += TextUtilities.getLayoutWidth(str.substring(0, from), f.getPlatformFont());
        }
        drawString(f, glyphs, adv, x, y);
    }

    @Override
    public void setComposite(int composite) {
        log.fine(&quot;setComposite({0})&quot;, composite);
        state.setCompositeOperation(composite);
    }

    @Override
    public void drawEllipse(final int x, final int y, final int w, final int h) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(&quot;drawEllipse({0}, {1}, {2}, {3})&quot;,
                    new Object[] { x, y, w, h});
        }
        if (!shouldRenderRect(x, y, w, h,
                              null, state.getStrokeNoClone().getPlatformStroke()))
        {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                g.setPaint(state.getPaintNoClone());
                g.fillEllipse(x, y, w, h);
                if (state.getStrokeNoClone().apply(g)) {
                    g.drawEllipse(x, y, w, h);
                }
            }
        }.paint();
    }

    private final static BasicStroke focusRingStroke =
        new BasicStroke(1.1f, BasicStroke.CAP_BUTT,
                         BasicStroke.JOIN_ROUND, 0.0f,
                         new float[] {1.0f}, 0.0f);

    @Override
    public void drawFocusRing(final int x, final int y, final int w, final int h, final int rgba) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;drawFocusRing: %d, %d, %d, %d, 0x%x&quot;, x, y, w, h, rgba));
        }
        if (!shouldRenderRect(x, y, w, h, null, focusRingStroke)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                g.setPaint(createColor(rgba));
                BasicStroke stroke = g.getStroke();
                g.setStroke(focusRingStroke);
                g.drawRoundRect(x, y, w, h, 4, 4);
                g.setStroke(stroke);
            }
        }.paint();
    }

    public void setAlpha(float alpha) {
        log.fine(&quot;setAlpha({0})&quot;, alpha);

        state.setAlpha(alpha);

        if (null != cachedGraphics) {
            cachedGraphics.setExtraAlpha(state.getAlpha());
        }
    }

    public float getAlpha() {
        return state.getAlpha();
    }

    @Override public void beginTransparencyLayer(float opacity) {
        TransparencyLayer layer = new TransparencyLayer(
                getGraphics(false), state.getClipNoClone(), opacity);

        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;beginTransparencyLayer(%s)&quot;, layer));
        }

        //[saveStateIntertal] will work as [saveState]
        state.markAsRestorePoint();

        startNewLayer(layer);
    }

    @Override public void endTransparencyLayer() {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;endTransparencyLayer(%s)&quot;, state.getLayerNoClone()));
        }

        //pair to [startNewLayer] that works as [saveState] call
        restoreState();
    }

    @Override
    public void drawWidget(final RenderTheme theme, final Ref widget, final int x, final int y) {
        WCSize s = theme.getWidgetSize(widget);
        if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                theme.drawWidget(WCGraphicsPrismContext.this, widget, x, y);
            }
        }.paint();
    }

    @Override
    public void drawScrollbar(final ScrollBarTheme theme, final Ref widget, int x, int y,
                              int pressedPart, int hoveredPart)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;drawScrollbar(%s, %s, x = %d, y = %d)&quot;, theme, widget, x, y));
        }

        WCSize s = theme.getWidgetSize(widget);
        if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                theme.paint(WCGraphicsPrismContext.this, widget, x, y, pressedPart, hoveredPart);
            }
        }.paint();
    }

    private static Rectangle intersect(Rectangle what, Rectangle with) {
        if (what == null) {
            return with;
        }
        RectBounds b = what.toRectBounds();
        b.intersectWith(with);
        what.setBounds(b);
        return what;
    }

    static Color createColor(int rgba) {
        float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
        float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
        float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
        float b = (0xFF &amp; (rgba)) / 255.0f;
        return new Color(r, g, b, a);
    }

    private static Color4f createColor4f(int rgba) {
        float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
        float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
        float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
        float b = (0xFF &amp; (rgba)) / 255.0f;
        return new Color4f(r, g, b, a);
    }

    private DropShadow createShadow(float dx, float dy, float blur, int rgba) {
        if (dx == 0f &amp;&amp; dy == 0f &amp;&amp; blur == 0f) {
            return null;
        }
        DropShadow shadow = new DropShadow();
        shadow.setOffsetX((int) dx);
        shadow.setOffsetY((int) dy);
        shadow.setRadius((blur &lt; 0f) ? 0f : (blur &gt; 127f) ? 127f : blur);
        shadow.setColor(createColor4f(rgba));
        return shadow;
    }

    private void render(Graphics g, Effect effect, Paint paint, BasicStroke stroke, NGNode node) {
        if (node instanceof NGShape) {
            NGShape shape = (NGShape) node;
            Shape realShape = shape.getShape();
            Paint strokePaint = state.getStrokeNoClone().getPaint();
            if ((stroke != null) &amp;&amp; (strokePaint != null)) {
                realShape = stroke.createStrokedShape(realShape);
                shape.setDrawStroke(stroke);
                shape.setDrawPaint(strokePaint);
                shape.setMode((paint == null) ? NGShape.Mode.STROKE : NGShape.Mode.STROKE_FILL);
            } else {
                shape.setMode((paint == null) ? NGShape.Mode.EMPTY : NGShape.Mode.FILL);
            }
            shape.setFillPaint(paint);
            shape.setContentBounds(realShape.getBounds());
        }
        boolean culling = g.hasPreCullingBits();
        g.setHasPreCullingBits(false);
        node.setEffect(effect);
        node.render(g);
        g.setHasPreCullingBits(culling);
    }

    private static final class ContextState {
        private final WCStrokeImpl stroke = new WCStrokeImpl();
        private Rectangle clip;
        private Paint paint;
        private float alpha;

        private boolean textFill = true;
        private boolean textStroke = false;
        private boolean textClip = false;
        private boolean restorePoint = false;

        private DropShadow shadow;
        private Affine3D xform;
        private GeneralTransform3D perspectiveTransform;
        private Layer layer;
        private int compositeOperation;

        private ContextState() {
            clip = null;
            paint = Color.BLACK;
            stroke.setPaint(Color.BLACK);
            alpha = 1.0f;
            xform = new Affine3D();
            perspectiveTransform = new GeneralTransform3D();
            compositeOperation = COMPOSITE_SOURCE_OVER;
        }

        private ContextState(ContextState state) {
            stroke.copyFrom(state.getStrokeNoClone());
            setPaint(state.getPaintNoClone());
            clip = state.getClipNoClone();
            if (clip != null) {
                clip = new Rectangle(clip);
            }
            xform = new Affine3D(state.getTransformNoClone());
            perspectiveTransform = new GeneralTransform3D().set(state.getPerspectiveTransformNoClone());
            setShadow(state.getShadowNoClone());
            setLayer(state.getLayerNoClone());
            setAlpha(state.getAlpha());
            setTextMode(state.isTextFill(), state.isTextStroke(), state.isTextClip());
            setCompositeOperation(state.getCompositeOperation());
        }

        @Override
        protected ContextState clone() {
            return new ContextState(this);
        }

        private void apply(Graphics g) {
            g.setTransform(getTransformNoClone());
            g.setPerspectiveTransform(getPerspectiveTransformNoClone());
            g.setClipRect(getClipNoClone());
            g.setExtraAlpha(getAlpha());
        }

        private int getCompositeOperation() {
            return compositeOperation;
        }

        private void setCompositeOperation(int compositeOperation) {
            this.compositeOperation = compositeOperation;
        }

        private WCStrokeImpl getStrokeNoClone() {
            return stroke;
        }

        private Paint getPaintNoClone() {
            return paint;
        }

        private void setPaint(Paint paint) {
            this.paint = paint;
        }

        private Rectangle getClipNoClone() {
            return clip;
        }

        private Layer getLayerNoClone() {
            return layer;
        }

        private void setLayer(Layer layer) {
            this.layer = layer;
        }

        private void setClip(Rectangle area) {
            clip = area;
        }

        private void clip(Rectangle area) {
            if (null == clip) {
                clip = area;
            } else {
                clip.intersectWith(area);
            }
        }

        private void setAlpha(float alpha) {
            this.alpha = alpha;
        }

        private float getAlpha() {
            return alpha;
        }

        private void setTextMode(boolean fill, boolean stroke, boolean clip) {
            textFill = fill;
            textStroke = stroke;
            textClip = clip;
        }

        private boolean isTextFill() {
            return textFill;
        }

        private boolean isTextStroke() {
            return textStroke;
        }

        private boolean isTextClip() {
            return textClip;
        }

        private void markAsRestorePoint() {
            restorePoint = true;
        }

        private boolean isRestorePoint() {
            return restorePoint;
        }

        private void setShadow(DropShadow shadow) {
            this.shadow = shadow;
        }

        private DropShadow getShadowNoClone() {
            return shadow;
        }

        private Affine3D getTransformNoClone() {
            return xform;
        }

        private GeneralTransform3D getPerspectiveTransformNoClone() {
            return perspectiveTransform;
        }

        private void setTransform(final Affine3D at) {
            this.xform.setTransform(at);
        }

        private void setPerspectiveTransform(final GeneralTransform3D gt) {
            this.perspectiveTransform.set(gt);
        }

        private void concatTransform(Affine3D at) {
            xform.concatenate(at);
        }

        private void translate(double dx, double dy) {
            xform.translate(dx, dy);
        }

        private void scale(double sx, double sy) {
            xform.scale(sx,sy);
        }

        private void rotate(double radians) {
            xform.rotate(radians);
        }
    }

    private abstract static class Layer {
        FilterContext fctx;
        PrDrawable buffer;
        Graphics graphics;
        final Rectangle bounds;
        boolean permanent;

        Layer(Graphics g, Rectangle bounds, boolean permanent) {
            this.bounds = new Rectangle(bounds);
            this.permanent = permanent;

            // avoid creating zero-size drawable, see also RT-21410
            int w = Math.max(bounds.width, 1);
            int h = Math.max(bounds.height, 1);
            fctx = getFilterContext(g);
            if (permanent) {
                ResourceFactory f = GraphicsPipeline.getDefaultResourceFactory();
                RTTexture rtt = f.createRTTexture(w, h, Texture.WrapMode.CLAMP_NOT_NEEDED);
                rtt.makePermanent();
                buffer = ((PrRenderer)Renderer.getRenderer(fctx)).createDrawable(rtt);
            } else {
                buffer = (PrDrawable) Effect.getCompatibleImage(fctx, w, h);
            }
        }

        Graphics getGraphics() {
            if (graphics == null) {
                graphics = buffer.createGraphics();
            }
            return graphics;
        }

        abstract void init(Graphics g);

        abstract void render(Graphics g);

        private void dispose() {
            if (buffer != null) {
                if (permanent) {
                    buffer.flush(); // releases the resource
                } else {
                    Effect.releaseCompatibleImage(fctx, buffer);
                }
                fctx = null;
                buffer = null;
            }
        }

        private double getX() { return (double) bounds.x; }
        private double getY() { return (double) bounds.y; }
    }

    private final class TransparencyLayer extends Layer {
        private final float opacity;

        private TransparencyLayer(Graphics g, Rectangle bounds, float opacity) {
            super(g, bounds, false);
            this.opacity = opacity;
        }

        @Override void init(Graphics g) {
            state.setCompositeOperation(COMPOSITE_SOURCE_OVER);
        }

        @Override void render(Graphics g) {
            new Composite() {
                @Override void doPaint(Graphics g) {
                    float op = g.getExtraAlpha();
                    g.setExtraAlpha(opacity);
                    Affine3D tx = new Affine3D(g.getTransformNoClone());
                    g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
                    g.drawTexture(buffer.getTextureObject(),
                            bounds.x, bounds.y, bounds.width, bounds.height);
                    g.setTransform(tx);
                    g.setExtraAlpha(op);
                }
            }.paint(g);
        }

        @Override public String toString() {
            return String.format(&quot;TransparencyLayer[%d,%d + %dx%d, opacity %.2f]&quot;,
                bounds.x, bounds.y, bounds.width, bounds.height, opacity);
        }
    }

    private static final class ClipLayer extends Layer {
        private final WCPath normalizedToClipPath;
        private boolean srcover;

        private ClipLayer(Graphics g, Rectangle bounds, WCPath normalizedToClipPath,
                          boolean permanent)
        {
            super(g, bounds, permanent);
            this.normalizedToClipPath = normalizedToClipPath;
            srcover = true;
        }

        @Override void init(Graphics g) {
            RTTexture texture = null;
            ReadbackGraphics readbackGraphics = null;
            try {
                readbackGraphics = (ReadbackGraphics) g;
                texture = readbackGraphics.readBack(bounds);
                getGraphics().drawTexture(texture, 0, 0, bounds.width, bounds.height);
            } finally {
                if (readbackGraphics != null &amp;&amp; texture != null) {
                    readbackGraphics.releaseReadBackBuffer(texture);
                }
            }
            srcover = false;
        }

        @Override void render(Graphics g) {
            Path2D p2d = ((WCPathImpl)normalizedToClipPath).getPlatformPath();

            // render normalizedToClipPath to a drawable
            PrDrawable bufferImg = (PrDrawable) Effect.getCompatibleImage(
                    fctx, bounds.width, bounds.height);
            Graphics bufferGraphics = bufferImg.createGraphics();

            bufferGraphics.setPaint(Color.BLACK);
            bufferGraphics.fill(p2d);

            // blend buffer and clipImg onto |g|
            if (g instanceof MaskTextureGraphics &amp;&amp; ! (g instanceof PrinterGraphics)) {
                MaskTextureGraphics mg = (MaskTextureGraphics) g;
                if (srcover) {
                    mg.drawPixelsMasked(buffer.getTextureObject(),
                                        bufferImg.getTextureObject(),
                                        bounds.x, bounds.y, bounds.width, bounds.height,
                                        0, 0, 0, 0);
                } else {
                    mg.maskInterpolatePixels(buffer.getTextureObject(),
                                             bufferImg.getTextureObject(),
                                             bounds.x, bounds.y, bounds.width, bounds.height,
                                             0, 0, 0, 0);
                }
            } else {
                Blend blend = new Blend(Blend.Mode.SRC_IN,
                        new PassThrough(bufferImg, bounds.width, bounds.height),
                        new PassThrough(buffer, bounds.width, bounds.height));
                Affine3D tx = new Affine3D(g.getTransformNoClone());
                g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
                PrEffectHelper.render(blend, g, bounds.x, bounds.y, null);
                g.setTransform(tx);
            }

            Effect.releaseCompatibleImage(fctx, bufferImg);
        }

        @Override public String toString() {
            return String.format(&quot;ClipLayer[%d,%d + %dx%d, path %s]&quot;,
                    bounds.x, bounds.y, bounds.width, bounds.height,
                    normalizedToClipPath);
        }
    }

    private abstract class Composite {
        abstract void doPaint(Graphics g);

        void paint() {
            paint(getGraphics(true));
        }

        void paint(Graphics g) {
            if (g != null) {
                CompositeMode oldCompositeMode = g.getCompositeMode();
                switch (state.getCompositeOperation()) {
                    // decode operations that don't require Blend first
                    case COMPOSITE_COPY:
                        g.setCompositeMode(CompositeMode.SRC);
                        doPaint(g);
                        g.setCompositeMode(oldCompositeMode);
                        break;
                    case COMPOSITE_SOURCE_OVER:
                        g.setCompositeMode(CompositeMode.SRC_OVER);
                        doPaint(g);
                        g.setCompositeMode(oldCompositeMode);
                        break;
                    default:
                        // other operations require usage of Blend
                        blend(g);
                        break;
                }
                isRootLayerValid = false;
            }
        }

        private void blend(Graphics g) {
            FilterContext fctx = getFilterContext(g);
            PrDrawable dstImg = null;
            PrDrawable srcImg = null;
            ReadbackGraphics readBackGraphics = null;
            RTTexture texture = null;
            Rectangle clip = state.getClipNoClone();
            WCImage image = getImage();
            try {
                if (image != null &amp;&amp; image instanceof PrismImage) {
                    // blending on canvas
                    dstImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
                    Graphics dstG = dstImg.createGraphics();
                    ((PrismImage) image).draw(dstG,
                            0, 0, clip.width, clip.height,
                            clip.x, clip.y, clip.width, clip.height);
                } else {
                    // blending on page
                    readBackGraphics = (ReadbackGraphics) g;
                    texture = readBackGraphics.readBack(clip);
                    dstImg = PrDrawable.create(fctx, texture);
                }

                srcImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
                Graphics srcG = srcImg.createGraphics();
                state.apply(srcG);
                doPaint(srcG);

                g.clear();
                PrEffectHelper.render(createEffect(dstImg, srcImg, clip.width, clip.height), g, 0, 0, null);

            } finally {
                if (srcImg != null) {
                    Effect.releaseCompatibleImage(fctx, srcImg);
                }
                if (dstImg != null) {
                    if (readBackGraphics != null &amp;&amp; texture != null) {
                        readBackGraphics.releaseReadBackBuffer(texture);
                    } else {
                        Effect.releaseCompatibleImage(fctx, dstImg);
                    }
                }
            }
        }

        // provides some syntax sugar for createEffect()
        private Effect createBlend(Blend.Mode mode,
                                   PrDrawable dstImg,
                                   PrDrawable srcImg,
                                   int width,
                                   int height)
        {
            return new Blend(
                    mode,
                    new PassThrough(dstImg, width, height),
                    new PassThrough(srcImg, width, height));
        }

        private Effect createEffect(PrDrawable dstImg,
                                    PrDrawable srcImg,
                                    int width,
                                    int height)
        {
            switch (state.getCompositeOperation()) {
                case COMPOSITE_CLEAR: // same as xor
                case COMPOSITE_XOR:
                    return new Blend(
                            SRC_OVER,
                            createBlend(SRC_OUT, dstImg, srcImg, width, height),
                            createBlend(SRC_OUT, srcImg, dstImg, width, height)
                    );
                case COMPOSITE_SOURCE_IN:
                    return createBlend(SRC_IN, dstImg, srcImg, width, height);
                case COMPOSITE_SOURCE_OUT:
                    return createBlend(SRC_OUT, dstImg, srcImg, width, height);
                case COMPOSITE_SOURCE_ATOP:
                    return createBlend(SRC_ATOP, dstImg, srcImg, width, height);
                case COMPOSITE_DESTINATION_OVER:
                    return createBlend(SRC_OVER, srcImg, dstImg, width, height);
                case COMPOSITE_DESTINATION_IN:
                    return createBlend(SRC_IN, srcImg, dstImg, width, height);
                case COMPOSITE_DESTINATION_OUT:
                    return createBlend(SRC_OUT, srcImg, dstImg, width, height);
                case COMPOSITE_DESTINATION_ATOP:
                    return createBlend(SRC_ATOP, srcImg, dstImg, width, height);
                case COMPOSITE_HIGHLIGHT:
                    return createBlend(ADD, dstImg, srcImg, width, height);
                default:
                    return createBlend(SRC_OVER, dstImg, srcImg, width, height);
            }
        }
    }

    private static final class PassThrough extends Effect {
        private final PrDrawable img;
        private final int width;
        private final int height;

        private PassThrough(PrDrawable img, int width, int height) {
            this.img = img;
            this.width = width;
            this.height = height;
        }

        @Override public ImageData filter(
                FilterContext fctx,
                BaseTransform transform,
                Rectangle outputClip,
                Object renderHelper,
                Effect defaultInput) {
            // We have an unpaired lock() here, because unlocking is done
            // internally by ImageData. See RT-33625 for details.
            img.lock();
            ImageData imgData = new ImageData(fctx, img, new Rectangle(
                                              (int) transform.getMxt(),
                                              (int) transform.getMyt(),
                                              width, height));
            imgData.setReusable(true);
            return imgData;
        }

        @Override public RectBounds getBounds(
                BaseTransform transform,
                Effect defaultInput) {
            return null;
        }

        @Override public AccelType getAccelType(FilterContext fctx) {
            return AccelType.INTRINSIC;
        }

        @Override
        public boolean reducesOpaquePixels() {
            return false;
        }

        @Override
        public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
            return null;
        }
    }

    private static FilterContext getFilterContext(Graphics g) {
        Screen screen = g.getAssociatedScreen();
        if (screen == null) {
            ResourceFactory factory = g.getResourceFactory();
            return PrFilterContext.getPrinterContext(factory);
        } else {
            return PrFilterContext.getInstance(screen);
        }
    }

    @Override
    public void strokeArc(final int x, final int y, final int w, final int h,
                          final int startAngle, final int angleSpan)
    {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;strokeArc(%d, %d, %d, %d, %d, %d)&quot;,
                                   x, y, w, h, startAngle, angleSpan));
        }
        Arc2D arc = new Arc2D(x, y, w, h, startAngle, angleSpan, Arc2D.OPEN);
        if (state.getStrokeNoClone().isApplicable() &amp;&amp;
            !shouldRenderShape(arc, null, state.getStrokeNoClone().getPlatformStroke()))
        {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                if (state.getStrokeNoClone().apply(g)) {
                    g.draw(arc);
                }
            }
        }.paint();
    }

    @Override
    public WCImage getImage() {
        return null;
    }

    @Override
    public void strokeRect(final float x, final float y, final float w, final float h,
                           final float lineWidth) {
        if (log.isLoggable(Level.FINE)) {
            log.fine(String.format(&quot;strokeRect_FFFFF(%f, %f, %f, %f, %f)&quot;,
                                   x, y, w, h, lineWidth));
        }
        BasicStroke stroke = new BasicStroke(
            lineWidth,
            BasicStroke.CAP_BUTT,
            BasicStroke.JOIN_MITER,
            Math.max(1.0f, lineWidth),
            state.getStrokeNoClone().getDashSizes(),
            state.getStrokeNoClone().getDashOffset());

        if (!shouldRenderRect(x, y, w, h, null, stroke)) {
            return;
        }
        new Composite() {
            @Override void doPaint(Graphics g) {
                g.setStroke(stroke);
                Paint paint = state.getStrokeNoClone().getPaint();
                if (paint == null) {
                    paint = state.getPaintNoClone();
                }
                g.setPaint(paint);
                g.drawRect(x, y, w, h);
            }
        }.paint();
    }

    @Override
    public void strokePath(final WCPath path) {
        log.fine(&quot;strokePath&quot;);
        if (path != null) {
            final BasicStroke stroke = state.getStrokeNoClone().getPlatformStroke();
            final DropShadow shadow = state.getShadowNoClone();
            final Path2D p2d = (Path2D)path.getPlatformPath();

            if ((stroke == null &amp;&amp; shadow == null) ||
                !shouldRenderShape(p2d, shadow, stroke))
            {
                return;
            }
            new Composite() {
                @Override void doPaint(Graphics g) {
                    if (shadow != null) {
                        final NGPath node = new NGPath();
                        node.updateWithPath2d(p2d);
                        render(g, shadow, null, stroke, node);
                    } else if (stroke != null) {
                        Paint paint = state.getStrokeNoClone().getPaint();
                        if (paint == null) {
                            paint = state.getPaintNoClone();
                        }
                        g.setPaint(paint);
                        g.setStroke(stroke);
                        g.draw(p2d);
                    }
                }
            }.paint();
        }
    }

    @Override
    public void fillPath(final WCPath path) {
        log.fine(&quot;fillPath&quot;);
        if (path != null) {
            if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(),
                                   state.getShadowNoClone(), null))
            {
                return;
            }
            new Composite() {
                @Override void doPaint(Graphics g) {
                    Path2D p2d = (Path2D) path.getPlatformPath();
                    Paint paint = state.getPaintNoClone();
                    DropShadow shadow = state.getShadowNoClone();
                    if (shadow != null) {
                        final NGPath node = new NGPath();
                        node.updateWithPath2d(p2d);
                        render(g, shadow, paint, null, node);
                    } else {
                        g.setPaint(paint);
                        g.fill(p2d);
                    }
                }
            }.paint();
        }
    }

    public void setPerspectiveTransform(WCTransform tm) {
        final GeneralTransform3D at = new GeneralTransform3D().set(tm.getMatrix());
        state.setPerspectiveTransform(at);
        resetCachedGraphics();
    }

    public void setTransform(WCTransform tm) {
        final double m[] = tm.getMatrix();
        final Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
        if (state.getLayerNoClone() == null) {
            at.preConcatenate(baseTransform);
        }
        state.setTransform(at);
        resetCachedGraphics();
    }

    public WCTransform getTransform() {
        Affine3D xf = state.getTransformNoClone();
        return new WCTransform(xf.getMxx(), xf.getMyx(),
                               xf.getMxy(), xf.getMyy(),
                               xf.getMxt(), xf.getMyt());
    }

    public void concatTransform(WCTransform tm) {
        double m[] = tm.getMatrix();
        Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
        state.concatTransform(at);
        resetCachedGraphics();
    }

    @Override
    public void flush() {
        flushAllLayers();
    }

    @Override
    public WCGradient createLinearGradient(WCPoint p1, WCPoint p2) {
        return new WCLinearGradient(p1, p2);
    }

    @Override
    public WCGradient createRadialGradient(WCPoint p1, float r1, WCPoint p2, float r2) {
        return new WCRadialGradient(p1, r1, p2, r2);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/javafx/webkit/prism/WCMediaPlayerImpl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="13"></A> * questions.
 */

<FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#13',2,'match51-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.javafx.webkit.prism;

import java.net.URI;
import java.util.List;

import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.media.PrismMediaFrameHandler;
import com.sun.media.jfxmedia.Media;
import com.sun.media.jfxmedia.MediaManager;
import com.sun.media.jfxmedia.MediaPlayer;
import com.sun.media.jfxmedia.control.VideoDataBuffer;
import com.sun.media.jfxmedia.events.BufferListener;
import com.sun.media.jfxmedia.events.BufferProgressEvent;
import com.sun.media.jfxmedia.events.MediaErrorListener;
import com.sun.media.jfxmedia.events.NewFrameEvent;
import com.sun.media.jfxmedia.events.PlayerStateEvent;
import com.sun.media.jfxmedia.events.PlayerStateListener;
import com.sun.media.jfxmedia.events.PlayerTimeListener;
import com.sun.media.jfxmedia.events.VideoRendererListener;
import com.sun.media.jfxmedia.events.VideoTrackSizeListener;
import com.sun.media.jfxmedia.locator.Locator;
import com.sun.media.jfxmedia.track.AudioTrack;
import com.sun.media.jfxmedia.track.Track;
import com.sun.media.jfxmedia.track.VideoTrack;
import com.sun.prism.Graphics;
import com.sun.prism.Texture;
import com.sun.webkit.graphics.WCGraphicsContext;
import com.sun.webkit.graphics.WCMediaPlayer;


final class WCMediaPlayerImpl extends WCMediaPlayer
        implements PlayerStateListener, MediaErrorListener,
        VideoTrackSizeListener, BufferListener, PlayerTimeListener
{

    // lock for fields access (player, createThread, frameHandler)
    private final Object lock = new Object();

    private volatile MediaPlayer player</B></FONT>;
    private volatile CreateThread createThread;
    private volatile PrismMediaFrameHandler frameHandler;

    private final MediaFrameListener frameListener;

    // we need this flag to handle a case when 1st frame arrives before onReady
    private boolean gotFirstFrame = false;

    // 1: at the end (rate &gt; 0); -1: at the begining (rate &lt; 0)
    private int finished = 0;

    WCMediaPlayerImpl() {
        frameListener = new MediaFrameListener();
    }

    private MediaPlayer getPlayer() {
        synchronized(lock) {
            if (createThread != null) {
                return null;
            }
            return player;
        }
    }

    private void setPlayer(MediaPlayer p) {
        synchronized (lock) {
            player = p;
            installListeners();
            frameHandler = PrismMediaFrameHandler.getHandler(player);
        }

        finished = 0;
    }

    private final class CreateThread extends Thread {
        private boolean cancelled = false;
        private final String url;
        private final String userAgent;
        private CreateThread(String url, String userAgent) {
            this.url = url;
            this.userAgent = userAgent;
            gotFirstFrame = false;
        }

        @Override
        public void run() {
            log.fine(&quot;CreateThread: started, url={0}&quot;, url);

            notifyNetworkStateChanged(NETWORK_STATE_LOADING);
            notifyReadyStateChanged(READY_STATE_HAVE_NOTHING);

            MediaPlayer p = null;

            try {
                Locator locator = new Locator(new URI(url));
                if (userAgent != null) {
                    locator.setConnectionProperty(&quot;User-Agent&quot;, userAgent);
                }
                locator.init();
                    log.fine(&quot;CreateThread: locator created&quot;);

                p = MediaManager.getPlayer(locator);
            } catch (Exception ex) {
                log.warning(&quot;CreateThread ERROR: {0}&quot;, ex.toString());
                if (log.isLoggable(PlatformLogger.Level.FINE)) {
                    ex.printStackTrace(System.out);
                }
                onError(this, 0, ex.getMessage());
                return;
            }

            synchronized (lock) {
                if (cancelled) {
                    log.fine(&quot;CreateThread: cancelled&quot;);
                    p.dispose();
                    return;
                }
                createThread = null;
                setPlayer(p);
            }
            log.fine(&quot;CreateThread: completed&quot;);
        }

        private void cancel() {
            synchronized (lock) {
                cancelled = true;
            }
        }
    }


    protected void load(String url, String userAgent) {
        synchronized (lock) {
            if (createThread != null) {
                createThread.cancel();
            }
            disposePlayer();
            createThread = new CreateThread(url, userAgent);
        }
        // fx media player does not support loading only metadata,
        // so handle PRELOAD_METADATA as PRELOAD_AUTO (start loading)
        if (getPreload() != PRELOAD_NONE) {
            createThread.start();
        }
    }

    protected void cancelLoad() {
        synchronized (lock) {
            if (createThread != null) {
                createThread.cancel();
            }
        }
        MediaPlayer p = getPlayer();
        if (p != null) {
            p.stop();
        }
        notifyNetworkStateChanged(NETWORK_STATE_EMPTY);
        notifyReadyStateChanged(READY_STATE_HAVE_NOTHING);
    }

    protected void disposePlayer() {
        MediaPlayer old;
        synchronized (lock) {
            removeListeners();
            old = player;
            player = null;
            if (frameHandler != null) {
                frameHandler.releaseTextures();
                frameHandler = null;
            }
        }
        if (old != null) {
            old.stop();
            old.dispose();
            old = null;
            if (frameListener != null) {
                frameListener.releaseVideoFrames();
            }
        }
    }

    private void installListeners() {
        if (null != player) {
            player.addMediaPlayerListener(this);
            player.addMediaErrorListener(this);
            player.addVideoTrackSizeListener(this);
            player.addBufferListener(this);
            player.getVideoRenderControl().addVideoRendererListener(frameListener);
        }
    }

    private void removeListeners() {
        if (null != player) {
            player.removeMediaPlayerListener(this);
            player.removeMediaErrorListener(this);
            player.removeVideoTrackSizeListener(this);
            player.removeBufferListener(this);
            player.getVideoRenderControl().removeVideoRendererListener(frameListener);
        }
    }

    protected void prepareToPlay() {
        synchronized (lock) {
            if (player == null) {
                // Only start the thread if it has been created but not yet started.
                Thread t = createThread;
                if (t != null &amp;&amp; t.getState() == Thread.State.NEW) {
                    t.start();
                }
            }
        }
    }

    protected void play() {
        MediaPlayer p = getPlayer();
        if (p != null) {
            p.play();
            // workaround: webkit doesn't like late notifications
            notifyPaused(false);
        }
    }

    protected void pause() {
        MediaPlayer p = getPlayer();
        if (p != null) {
            p.pause();
            // workaround: webkit doesn't like late notifications
            notifyPaused(true);
        }
    }

    protected float getCurrentTime() {
        MediaPlayer p = getPlayer();
        if (p == null) {
            return 0f;
        }
        return finished == 0 ? (float)p.getPresentationTime()
                : finished &gt; 0 ? (float)p.getDuration()
                : 0f;
    }

    protected void seek(float time) {
        MediaPlayer p = getPlayer();
        if (p != null) {
            finished = 0;
            if (getReadyState() &gt;= READY_STATE_HAVE_METADATA) {
                notifySeeking(true, READY_STATE_HAVE_METADATA);
            } else {
                notifySeeking(true, READY_STATE_HAVE_NOTHING);
            }
            p.seek(time);

            // fx media doesn't have a notification about seek completeness
            // while seeking fx player returns 0 as current time
            final float seekTime = time;
            Thread seekCompletedThread = new Thread(new Runnable() {
                public void run() {
                    while (isSeeking()) {
                        MediaPlayer p = getPlayer();
                        if (p == null) {
                            break;
                        }
                        double cur = p.getPresentationTime();
                        if (seekTime &lt; 0.01 || Math.abs(cur) &gt;= 0.01) {
                            notifySeeking(false, READY_STATE_HAVE_ENOUGH_DATA);
                            break;
                        }
                        try {
                            Thread.sleep(10);
                        } catch (InterruptedException ex) {
                        }
                    }
                }
            });
            seekCompletedThread.setDaemon(true);
            seekCompletedThread.start();
        }
    }

    protected void setRate(float rate) {
        MediaPlayer p = getPlayer();
        if (p != null) {
            p.setRate(rate);
        }
    }

    protected void setVolume(float volume) {
        MediaPlayer p = getPlayer();
        if (p != null) {
            p.setVolume(volume);
        }
    }

    protected void setMute(boolean mute) {
        MediaPlayer p = getPlayer();
        if (p != null) {
            p.setMute(mute);
        }
    }

    protected void setSize(int w, int h) {
        // nothing to do
    }

    protected void setPreservesPitch(boolean preserve) {
        // nothing to do
    }

    protected void renderCurrentFrame(WCGraphicsContext gc, int x, int y, int w, int h) {
        // TODO: need a render lock in MediaFrameHandler
        synchronized (lock) {
            renderImpl(gc, x, y, w, h);
        }
    }


    private void renderImpl(WCGraphicsContext gc, int x, int y, int w, int h) {
        log.finer(&quot;&gt;&gt;(Prism)renderImpl&quot;);
        Graphics g = (Graphics)gc.getPlatformGraphics();

        Texture texture = null;
        VideoDataBuffer currentFrame = frameListener.getLatestFrame();

        if (null != currentFrame) {
            if (null != frameHandler) {
                texture = frameHandler.getTexture(g, currentFrame);
            }
            currentFrame.releaseFrame();
        }

        if (texture != null) {
            g.drawTexture(texture,
                    x, y, x + w, y + h,
                    0f, 0f, texture.getContentWidth(), texture.getContentHeight());
            texture.unlock();
        } else {
            log.finest(&quot;  (Prism)renderImpl, texture is null, draw black rect&quot;);
            gc.fillRect(x, y, w, h, 0xFF000000);
        }
        log.finer(&quot;&lt;&lt;(Prism)renderImpl&quot;);
    }

    // PlayerStateListener
    @Override
    public void onReady(PlayerStateEvent pse) {
        MediaPlayer p = getPlayer();
        log.fine(&quot;onReady&quot;);
        Media media = p.getMedia();
        boolean hasVideo = false;
        boolean hasAudio = false;
        if (media != null) {
            List&lt;Track&gt; tracks = media.getTracks();
            if (tracks != null) {
                log.fine(&quot;{0} track(s) detected:&quot;, tracks.size());
                for (Track track : tracks) {
                    if (track instanceof VideoTrack) {
                        hasVideo = true;
                    } else if (track instanceof AudioTrack) {
                        hasAudio = true;
                    }
                    log.fine(&quot;track: {0}&quot;, track);
                }
            } else {
                log.warning(&quot;onReady, tracks IS NULL&quot;);
            }
        } else {
            log.warning(&quot;onReady, media IS NULL&quot;);
        }
        log.fine(&quot;onReady, hasVideo:{0}, hasAudio: {1}&quot;, new Object[]{hasVideo, hasAudio});
        notifyReady(hasVideo, hasAudio, (float)p.getDuration());

        // if we have no video, report READY_STATE_HAVE_ENOUGH_DATA right now
        if (!hasVideo) {
            notifyReadyStateChanged(READY_STATE_HAVE_ENOUGH_DATA);
        } else {
            if (getReadyState() &lt; READY_STATE_HAVE_METADATA) {
                if (gotFirstFrame) {
                    notifyReadyStateChanged(READY_STATE_HAVE_ENOUGH_DATA);
                } else {
                    notifyReadyStateChanged(READY_STATE_HAVE_METADATA);
                }
            }
        }
    }

    @Override
    public void onPlaying(PlayerStateEvent pse) {
        log.fine(&quot;onPlaying&quot;);
        notifyPaused(false);
    }

    @Override
    public void onPause(PlayerStateEvent pse) {
        log.fine(&quot;onPause, time: {0}&quot;, pse.getTime());
        notifyPaused(true);
    }

    @Override
    public void onStop(PlayerStateEvent pse) {
        log.fine(&quot;onStop&quot;);
        notifyPaused(true);
    }

    @Override
    public void onStall(PlayerStateEvent pse) {
        log.fine(&quot;onStall&quot;);
    }

    @Override
    public void onFinish(PlayerStateEvent pse) {
        MediaPlayer p = getPlayer();
        if (p != null) {
            finished = p.getRate() &gt; 0 ? 1 : -1;
            log.fine(&quot;onFinish, time: {0}&quot;, pse.getTime());
            notifyFinished();
        }
    }

    @Override
    public void onHalt(PlayerStateEvent pse) {
        log.fine(&quot;onHalt&quot;);
    }

    // MediaErrorListener
    @Override
    public void onError(Object source, int errCode, String message) {
        //MediaPlayer p = getPlayer();
        log.warning(&quot;onError, errCode={0}, msg={1}&quot;, new Object[]{errCode, message});
        // TODO: parse errCode to detect NETWORK_STATE_FORMAT_ERROR/
        // NETWORK_STATE_NETWORK_ERROR/NETWORK_STATE_DECODE_ERROR
        notifyNetworkStateChanged(NETWORK_STATE_NETWORK_ERROR);
        notifyReadyStateChanged(READY_STATE_HAVE_NOTHING);
    }

    //PlayerTimeListener
    @Override
    public void onDurationChanged(double duration) {
        log.fine(&quot;onDurationChanged, duration={0}&quot;, duration);
        notifyDurationChanged((float)duration);
    }

    // VideoTrackSizeListener
    @Override
    public void onSizeChanged(int width, int height) {
        //MediaPlayer p = getPlayer();
        log.fine(&quot;onSizeChanged, new size = {0} x {1}&quot;, new Object[]{width, height});
        notifySizeChanged(width, height);
    }

    private void notifyFrameArrived() {
        if (!gotFirstFrame) {
            // this is the first frame
            // don't set HAVE_ENOUGH_DATA state before onReady
            if (getReadyState() &gt;= READY_STATE_HAVE_METADATA) {
                notifyReadyStateChanged(READY_STATE_HAVE_ENOUGH_DATA);
            }
            gotFirstFrame = true;
        }
        if (finished != 0) {
            log.fine(&quot;notifyFrameArrived (after finished) time: {0}&quot;, getPlayer().getPresentationTime());
        }
        notifyNewFrame();
    }

    private float bufferedStart = 0f;
    private float bufferedEnd   = 0f;
    private boolean buffering   = false;

    private void updateBufferingStatus() {
        int newNetworkState =
                buffering ? NETWORK_STATE_LOADING
                : bufferedStart &gt; 0 ? NETWORK_STATE_IDLE : NETWORK_STATE_LOADED;
        log.fine(&quot;updateBufferingStatus, buffered: [{0} - {1}], buffering = {2}&quot;,
            new Object[]{bufferedStart, bufferedEnd, buffering});
        notifyNetworkStateChanged(newNetworkState);
    }

    // BufferListener
    @Override
    public void onBufferProgress(BufferProgressEvent event) {
        /* event (in the current API):
         * double getDuration(): duration of the movie (seconds);
         * long getBufferStart(): start of the buffered data (bytes)
         * long getBufferStop(): end of the movie (bytes)
         * long getBufferPosition(): end of the buffered data (bytes)
         */
        // if duration is not yet known, we cannot calculate buffered ranges
        if (event.getDuration() &lt; 0) {
            return;
        }
        double bytes2seconds = event.getDuration() / (double)event.getBufferStop();
        bufferedStart = (float)(bytes2seconds * event.getBufferStart());
        bufferedEnd = (float)(bytes2seconds * event.getBufferPosition());
        buffering = event.getBufferPosition() &lt; event.getBufferStop();

        float ranges[] = new float[2];
        ranges[0] = bufferedStart;
        ranges[1] = bufferedEnd;
        int bytesLoaded = (int)(event.getBufferPosition() - event.getBufferStart());
        log.finer(&quot;onBufferProgress, &quot;
                + &quot;bufferStart={0}, bufferStop={1}, bufferPos={2}, duration={3}; &quot;
                + &quot;notify range [{4},[5]], bytesLoaded: {6}&quot;,
                new Object[]{event.getBufferStart(), event.getBufferStop(),
                             event.getBufferPosition(), event.getDuration(),
                             ranges[0], ranges[1], bytesLoaded});
        notifyBufferChanged(ranges, bytesLoaded);
        updateBufferingStatus();
    }

    /* Inner class that will listen for new frames from the jfxmedia player and
     * manage our own texture cache to remove the dependency on
     * PrismMediaFrameHandler
     */
    private final class MediaFrameListener implements VideoRendererListener {
        private final Object frameLock = new Object();
        private VideoDataBuffer currentFrame;
        private VideoDataBuffer nextFrame;

        public void videoFrameUpdated(NewFrameEvent nfe) {
            synchronized (frameLock) {
                if (null != nextFrame) {
                    nextFrame.releaseFrame();
                }
                nextFrame = nfe.getFrameData();
                if (null != nextFrame) {
                    nextFrame.holdFrame();
                }
            }

            // and finally notify the base player that we have a new frame
            notifyFrameArrived();
        }

        public void releaseVideoFrames() {
            synchronized (frameLock) {
                if (null != nextFrame) {
                    nextFrame.releaseFrame();
                    nextFrame = null;
                }

                if (null != currentFrame) {
                    currentFrame.releaseFrame();
                    currentFrame = null;
                }
            }
        }

        public VideoDataBuffer getLatestFrame() {
            synchronized (frameLock) {
                if (null != nextFrame) {
                    if (null != currentFrame) {
                        currentFrame.releaseFrame();
                    }
                    currentFrame = nextFrame;
                    nextFrame = null;
                }

                // avoid premature release
                if (null != currentFrame) {
                    currentFrame.holdFrame();
                }
                return currentFrame;
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/webkit/graphics/WCImage.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.webkit.graphics;

import java.nio.ByteBuffer;

public abstract class WCImage extends Ref {
    private WCRenderQueue rq;
    private String fileExtension;

    public abstract int getWidth();

    public abstract int getHeight();

    public String getFileExtension() {
        return fileExtension;
    }

    public void setFileExtension(String fileExtension) {
        this.fileExtension = fileExtension;
    }

    public Object getPlatformImage() {return null;}

    protected abstract byte[] toData(String mimeType);

    protected abstract String toDataURL(String mimeType);

    public ByteBuffer getPixelBuffer() {return null;}

    protected void drawPixelBuffer() {}

    public synchronized void setRQ(WCRenderQueue rq) {
        this.rq = rq;
    }

    // should be called on render thread
    protected synchronized void flushRQ() {
        if (rq != null) {
            rq.decode();
        }
    }

<A NAME="36"></A>    protected synchronized boolean isDirty() {
        return (rq == null)
           ? false
           : !<FONT color="#ff00ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#36',2,'match51-top.html#36',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>rq.isEmpty();
    }

    public static WCImage getImage(Object imgFrame) {
        WCImage img = null;
        if (imgFrame instanceof WCImage) {
            //from BufferImage.drawPattern (canvas/fill layer):
            //NativeImagePtr is a wrapper over the WCImage
            img = (WCImage)imgFrame;
        } else if (</B></FONT>imgFrame instanceof WCImageFrame) {
            //from BitmapImage.drawPattern (decoder/GIF animator):
            //NativeImagePtr is a wrapper over the WCImageFrame
            img = ((WCImageFrame)imgFrame).getFrame();
        }
        return img;
    }

    public abstract float getPixelScale();
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/webkit/network/URLLoader.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.webkit.network;

import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;
import com.sun.webkit.Invoker;
import com.sun.webkit.LoadListenerClient;
import com.sun.webkit.WebPage;
import static com.sun.webkit.network.URLs.newURL;
import java.io.EOFException;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.lang.annotation.Native;
import java.net.ConnectException;
import java.net.HttpRetryException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.NoRouteToHostException;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLDecoder;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.security.AccessControlException;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.zip.GZIPInputStream;
import java.util.zip.InflaterInputStream;
import javax.net.ssl.SSLHandshakeException;

/**
 * A runnable that loads a resource specified by a URL.
 */
final class URLLoader implements Runnable {

    @Native public static final int ALLOW_UNASSIGNED = java.net.IDN.ALLOW_UNASSIGNED;

    private static final PlatformLogger logger =
            PlatformLogger.getLogger(URLLoader.class.getName());
    private static final int MAX_REDIRECTS = 10;
    private static final int MAX_BUF_COUNT = 3;
    private static final String GET = &quot;GET&quot;;
    private static final String HEAD = &quot;HEAD&quot;;
    private static final String DELETE = &quot;DELETE&quot;;


    private final WebPage webPage;
    private final ByteBufferPool byteBufferPool;
    private final boolean asynchronous;
    private String url;
    private String method;
    private final String headers;
    private FormDataElement[] formDataElements;
    private final long data;
    private volatile boolean canceled = false;


    /**
     * Creates a new {@code URLLoader}.
     */
    URLLoader(WebPage webPage,
              ByteBufferPool byteBufferPool,
              boolean asynchronous,
              String url,
              String method,
              String headers,
              FormDataElement[] formDataElements,
              long data)
    {
        this.webPage = webPage;
        this.byteBufferPool = byteBufferPool;
        this.asynchronous = asynchronous;
        this.url = url;
        this.method = method;
        this.headers = headers;
        this.formDataElements = formDataElements;
        this.data = data;
    }


    /**
     * Cancels this loader.
     */
    private void fwkCancel() {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(&quot;data: [0x%016X]&quot;, data));
        }
        canceled = true;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void run() {
        // Run the loader in the page's access control context
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            doRun();
            return null;
        }, webPage.getAccessControlContext());
    }

    /**
     * Executes this loader.
     */
    private void doRun() {
        Throwable error = null;
        int errorCode = 0;
        try {
            int redirectCount = 0;
            boolean streaming = true;
            boolean connectionResetRetry = true;
            while (true) {
                // RT-14438
                String actualUrl = url;
                if (url.startsWith(&quot;file:&quot;)) {
                    int questionMarkPosition = url.indexOf('?');
                    if (questionMarkPosition != -1) {
                        actualUrl = url.substring(0, questionMarkPosition);
                    }
                }

                URL urlObject = newURL(actualUrl);

                // RT-22458
                workaround7177996(urlObject);

                URLConnection c = urlObject.openConnection();
                prepareConnection(c);

                Redirect redirect = null;
                try {
                    sendRequest(c, streaming);
                    redirect = receiveResponse(c);
                } catch (HttpRetryException ex) {
                    // RT-19914
                    if (streaming) {
                        streaming = false;
                        continue; // retry without streaming
                    } else {
                        throw ex;
                    }
                } catch (SocketException ex) {
                    // SocketException: Connection reset, Retry once
                    if (&quot;Connection reset&quot;.equals(ex.getMessage()) &amp;&amp; connectionResetRetry) {
                        connectionResetRetry = false;
                        continue;
                    } else {
                        throw ex;
                    }
                } finally {
                    close(c);
                }

                if (redirect != null) {
                    if (redirectCount++ &gt;= MAX_REDIRECTS) {
                        throw new TooManyRedirectsException();
                    }
                    boolean resetRequest = !redirect.preserveRequest
                            &amp;&amp; !method.equals(GET) &amp;&amp; !method.equals(HEAD);
                    String newMethod = resetRequest ? GET : method;
                    willSendRequest(redirect.url, newMethod, c);
                    // willSendRequest() may cancel this loader
                    if (canceled) {
                        break;
                    }
                    url = redirect.url;
                    method = newMethod;
                    formDataElements = resetRequest ? null : formDataElements;
                } else {
                    break;
                }
            }
        } catch (MalformedURLException ex) {
            error = ex;
            errorCode = LoadListenerClient.MALFORMED_URL;
        } catch (AccessControlException ex) {
            error = ex;
            errorCode = LoadListenerClient.PERMISSION_DENIED;
        } catch (UnknownHostException ex) {
            error = ex;
            errorCode = LoadListenerClient.UNKNOWN_HOST;
        } catch (NoRouteToHostException ex) {
            error = ex;
            errorCode = LoadListenerClient.NO_ROUTE_TO_HOST;
        } catch (ConnectException ex) {
            error = ex;
            errorCode = LoadListenerClient.CONNECTION_REFUSED;
        } catch (SocketException ex) {
            error = ex;
            errorCode = LoadListenerClient.CONNECTION_RESET;
        } catch (SSLHandshakeException ex) {
            error = ex;
            errorCode = LoadListenerClient.SSL_HANDSHAKE;
        } catch (SocketTimeoutException ex) {
            error = ex;
            errorCode = LoadListenerClient.CONNECTION_TIMED_OUT;
        } catch (InvalidResponseException ex) {
            error = ex;
            errorCode = LoadListenerClient.INVALID_RESPONSE;
        } catch (TooManyRedirectsException ex) {
            error = ex;
            errorCode = LoadListenerClient.TOO_MANY_REDIRECTS;
        } catch (FileNotFoundException ex) {
            error = ex;
            errorCode = LoadListenerClient.FILE_NOT_FOUND;
        } catch (Throwable th) {
            error = th;
            errorCode = LoadListenerClient.UNKNOWN_ERROR;
        }

        if (error != null) {
            if (errorCode == LoadListenerClient.UNKNOWN_ERROR) {
                logger.warning(&quot;Unexpected error&quot;, error);
            } else {
                logger.finest(&quot;Load error&quot;, error);
            }
            didFail(errorCode, error.getMessage());
        }
    }

    private static void workaround7177996(URL url)
        throws FileNotFoundException
    {
        if (!url.getProtocol().equals(&quot;file&quot;)) {
            return;
        }

        String host = url.getHost();
        if (host == null || host.equals(&quot;&quot;) || host.equals(&quot;~&quot;)
                || host.equalsIgnoreCase(&quot;localhost&quot;) )
        {
           return;
        }

        if (System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;)) {
            String path = null;
            try {
                path = URLDecoder.decode(url.getPath(), &quot;UTF-8&quot;);
            } catch (UnsupportedEncodingException e) {
                // The system should always have the platform default
            }
            path = path.replace('/', '\\');
            path = path.replace('|', ':');
            File file = new File(&quot;\\\\&quot; + host + path);
            if (!file.exists()) {
                throw new FileNotFoundException(&quot;File not found: &quot; + url);
            }
        } else {
            throw new FileNotFoundException(&quot;File not found: &quot; + url);
        }
    }

    /**
     * Prepares a connection.
     */
    private void prepareConnection(URLConnection c) throws IOException {
        // The following two timeouts are quite arbitrary and should
        // probably be configurable via an API
        c.setConnectTimeout(30000);   // 30 seconds
        c.setReadTimeout(60000 * 60); // 60 minutes

        // Given that WebKit has its own cache, do not use
        // any URLConnection caches, even if someone installs them.
        // As a side effect, this fixes the problem of WebPane not
        // working well with the plug-in cache, which was one of
        // the causes for RT-11880.
        c.setUseCaches(false);

        Locale loc = Locale.getDefault();
        String lang = &quot;&quot;;
        if (!loc.equals(Locale.US) &amp;&amp; !loc.equals(Locale.ENGLISH)) {
            lang = loc.getCountry().isEmpty() ?
                loc.getLanguage() + &quot;,&quot;:
                loc.getLanguage() + &quot;-&quot; + loc.getCountry() + &quot;,&quot;;
        }
        c.setRequestProperty(&quot;Accept-Language&quot;, lang.toLowerCase() + &quot;en-us;q=0.8,en;q=0.7&quot;);
        c.setRequestProperty(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);
        c.setRequestProperty(&quot;Accept-Charset&quot;, &quot;ISO-8859-1,utf-8;q=0.7,*;q=0.7&quot;);

        if (headers != null &amp;&amp; headers.length() &gt; 0) {
            for (String h : headers.split(&quot;\n&quot;)) {
                int i = h.indexOf(':');
                if (i &gt; 0) {
                    c.addRequestProperty(h.substring(0, i), h.substring(i + 2));
                }
            }
        }

        if (c instanceof HttpURLConnection) {
            HttpURLConnection httpConnection = (HttpURLConnection) c;
            httpConnection.setRequestMethod(method);
            // There are too many bugs in the way HttpURLConnection handles
            // redirects, so we will deal with them ourselves
            httpConnection.setInstanceFollowRedirects(false);
        }
    }

    /**
     * Sends request to the server.
     */
    private void sendRequest(URLConnection c, boolean streaming)
        throws IOException
    {
        OutputStream out = null;
        try {
            long bytesToBeSent = 0;
            boolean sendFormData = formDataElements != null
                    &amp;&amp; c instanceof HttpURLConnection
                    &amp;&amp; !method.equals(DELETE);
            boolean isGetOrHead = method.equals(GET) || method.equals(HEAD);
            if (sendFormData) {
                c.setDoOutput(true);

                for (FormDataElement formDataElement : formDataElements) {
                    formDataElement.open();
                    bytesToBeSent += formDataElement.getSize();
                }

                if (streaming) {
                    HttpURLConnection http = (HttpURLConnection) c;
                    if (bytesToBeSent &lt;= Integer.MAX_VALUE) {
                        http.setFixedLengthStreamingMode((int) bytesToBeSent);
                    } else {
                        http.setChunkedStreamingMode(0);
                    }
                }
            } else if (!isGetOrHead &amp;&amp; (c instanceof HttpURLConnection)) {
                c.setRequestProperty(&quot;Content-Length&quot;, &quot;0&quot;);
            }

            int maxTryCount = isGetOrHead ? 3 : 1;
            c.setConnectTimeout(c.getConnectTimeout() / maxTryCount);
            int tryCount = 0;
            while (!canceled) {
                try {
                    c.connect();
                    break;
                } catch (SocketTimeoutException ex) {
                    if (++tryCount &gt;= maxTryCount) {
                        throw ex;
                    }
                } catch (IllegalArgumentException ex) {
                    // Happens with some malformed URLs
                    throw new MalformedURLException(url);
                }
            }

            if (sendFormData) {
                out = c.getOutputStream();
                byte[] buffer = new byte[4096];
                long bytesSent = 0;
                for (FormDataElement formDataElement : formDataElements) {
                    InputStream in = formDataElement.getInputStream();
                    int count;
                    while ((count = in.read(buffer)) &gt; 0) {
                        out.write(buffer, 0, count);
                        bytesSent += count;
                        didSendData(bytesSent, bytesToBeSent);
                    }
                    formDataElement.close();
                }
                out.flush();
                out.close();
                out = null;
            }
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException ignore) {}
            }
            if (formDataElements != null &amp;&amp; c instanceof HttpURLConnection) {
                for (FormDataElement formDataElement : formDataElements) {
                    try {
                        formDataElement.close();
                    } catch (IOException ignore) {}
                }
            }
        }
    }

    /**
     * Receives response from the server.
     */
    private Redirect receiveResponse(URLConnection c)
        throws IOException, InterruptedException
    {
        if (canceled) {
            return null;
        }

        InputStream errorStream = null;

        if (c instanceof HttpURLConnection) {
            HttpURLConnection http = (HttpURLConnection) c;

            int code = http.getResponseCode();
            if (code == -1) {
                throw new InvalidResponseException();
            }

            if (canceled) {
                return null;
            }

            // See RT-17435
            switch (code) {
                case 301: // Moved Permanently
                case 302: // Found
                case 303: // See Other
                case 307: // Temporary Redirect
                    String newLoc = http.getHeaderField(&quot;Location&quot;);
                    if (newLoc != null) {
                        URL newUrl;
                        try {
                            newUrl = newURL(newLoc);
                        } catch (MalformedURLException mue) {
                            // Try to treat newLoc as a relative URI to conform
                            // to popular browsers
                            newUrl = newURL(c.getURL(), newLoc);
                        }
                        return new Redirect(newUrl.toExternalForm(),
                                            code == 307);
                    }
                    break;

                case 304: // Not Modified
                    didReceiveResponse(c);
                    didFinishLoading();
                    return null;
            }

            if (code &gt;= 400 &amp;&amp; !method.equals(HEAD)) {
                errorStream = http.getErrorStream();
            }
        }

        // Let's see if it's an ftp (or ftps) URL and we need to transform
        // a directory listing into HTML
        if (url.startsWith(&quot;ftp:&quot;) || url.startsWith(&quot;ftps:&quot;)) {
            boolean dir = false;
            boolean notsure = false;
            // Unfortunately, there is no clear way to determine if we are
            // accessing a directory, so a bit of guessing is in order
            String path = c.getURL().getPath();
            if (path == null || path.isEmpty() || path.endsWith(&quot;/&quot;)
                    || path.contains(&quot;;type=d&quot;))
            {
                dir = true;
            } else {
                String type = c.getContentType();
                if (&quot;text/plain&quot;.equalsIgnoreCase(type)
                        || &quot;text/html&quot;.equalsIgnoreCase(type))
                {
                    dir = true;
                    notsure = true;
                }
            }
            if (dir) {
                c = new DirectoryURLConnection(c, notsure);
            }
        }

        // Same is true for FileURLConnection
        if (url.startsWith(&quot;file:&quot;)) {
            if(&quot;text/plain&quot;.equals(c.getContentType())
                    &amp;&amp; c.getHeaderField(&quot;content-length&quot;) == null)
            {
                // It is a directory
                c = new DirectoryURLConnection(c);
            }
        }

        didReceiveResponse(c);

        if (method.equals(HEAD)) {
            didFinishLoading();
            return null;
        }

        InputStream inputStream = null;
        try {
            inputStream = errorStream == null
                ? c.getInputStream() : errorStream;
        } catch (HttpRetryException ex) {
<A NAME="17"></A>            // HttpRetryException is handled from doRun() method.
            // Hence rethrowing the exception to caller(doRun() method)
            throw ex;
        } catch (<FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#17',2,'match51-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>IOException e) {
            if (logger.isLoggable(Level.FINE)) {
                logger.fine(String.format(&quot;Exception caught: [%s], %s&quot;,
                    e.getClass().getSimpleName(),
                    e.getMessage()));
            }
        }</B></FONT>

        String encoding = c.getContentEncoding();
        if (inputStream != null) {
            try {
                if (&quot;gzip&quot;.equalsIgnoreCase(encoding)) {
                    inputStream = new GZIPInputStream(inputStream);
                } else if (&quot;deflate&quot;.equalsIgnoreCase(encoding)) {
                    inputStream = new InflaterInputStream(inputStream);
                }
            } catch (IOException e) {
                if (logger.isLoggable(Level.FINE)) {
                    logger.fine(String.format(&quot;Exception caught: [%s], %s&quot;,
                        e.getClass().getSimpleName(),
                        e.getMessage()));
                }
            }
        }

        ByteBufferAllocator allocator =
                byteBufferPool.newAllocator(MAX_BUF_COUNT);
        ByteBuffer byteBuffer = null;
        try {
            if (inputStream != null) {
                // 8192 is the default size of a BufferedInputStream used in
                // most URLConnections, by using the same size, we avoid quite
                // a few System.arrayCopy() calls
                byte[] buffer = new byte[8192];
                while (!canceled) {
                    int count;
                    try {
                        count = inputStream.read(buffer);
                    } catch (EOFException ex) {
                        // can be thrown by GZIPInputStream signaling
                        // the end of the stream
                        count = -1;
                    }

                    if (count == -1) {
                        break;
                    }

                    if (byteBuffer == null) {
                        byteBuffer = allocator.allocate();
                    }

                    int remaining = byteBuffer.remaining();
                    if (count &lt; remaining) {
                        byteBuffer.put(buffer, 0, count);
                    } else {
                        byteBuffer.put(buffer, 0, remaining);

                        byteBuffer.flip();
                        didReceiveData(byteBuffer, allocator);
                        byteBuffer = null;

                        int outstanding = count - remaining;
                        if (outstanding &gt; 0) {
                            byteBuffer = allocator.allocate();
                            byteBuffer.put(buffer, remaining, outstanding);
                        }
                    }
                }
            }
            if (!canceled) {
                if (byteBuffer != null &amp;&amp; byteBuffer.position() &gt; 0) {
                    byteBuffer.flip();
                    didReceiveData(byteBuffer, allocator);
                    byteBuffer = null;
                }
                didFinishLoading();
            }
        } finally {
            if (byteBuffer != null) {
                byteBuffer.clear();
                allocator.release(byteBuffer);
            }
        }
        return null;
    }

    /**
     * Releases the resources that may be associated with a connection.
     */
    private static void close(URLConnection c) {
        if (c instanceof HttpURLConnection) {
            InputStream errorStream = ((HttpURLConnection) c).getErrorStream();
            if (errorStream != null) {
                try {
                    errorStream.close();
                } catch (IOException ignore) {}
            }
        }
        try {
            c.getInputStream().close();
        } catch (IOException ignore) {}
    }


    /**
     * A holder for redirect information.
     */
    private static final class Redirect {
        private final String url;
        private final boolean preserveRequest;

        private Redirect(String url, boolean preserveRequest) {
            this.url = url;
            this.preserveRequest = preserveRequest;
        }
    }

    /**
     * Signals an invalid response from the server.
     */
    private static final class InvalidResponseException extends IOException {
        private InvalidResponseException() {
            super(&quot;Invalid server response&quot;);
        }
    }

    /**
     * Signals that too many redirects have been encountered
     * while processing the request.
     */
    private static final class TooManyRedirectsException extends IOException {
        private TooManyRedirectsException() {
            super(&quot;Too many redirects&quot;);
        }
    }

    private void didSendData(final long totalBytesSent,
                             final long totalBytesToBeSent)
    {
        callBack(() -&gt; {
            if (!canceled) {
                notifyDidSendData(totalBytesSent, totalBytesToBeSent);
            }
        });
    }

    private void notifyDidSendData(long totalBytesSent,
                                   long totalBytesToBeSent)
    {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(
                    &quot;totalBytesSent: [%d], &quot;
                    + &quot;totalBytesToBeSent: [%d], &quot;
                    + &quot;data: [0x%016X]&quot;,
                    totalBytesSent,
                    totalBytesToBeSent,
                    data));
        }
        twkDidSendData(totalBytesSent, totalBytesToBeSent, data);
    }

    private void willSendRequest(String newUrl,
                                 final String newMethod,
                                 URLConnection c) throws InterruptedException
    {
        final String adjustedNewUrl = adjustUrlForWebKit(newUrl);
        final int status = extractStatus(c);
        final String contentType = c.getContentType();
        final String contentEncoding = extractContentEncoding(c);
        final long contentLength = extractContentLength(c);
        final String responseHeaders = extractHeaders(c);
        final String adjustedUrl = adjustUrlForWebKit(url);
        final CountDownLatch latch =
                asynchronous ? new CountDownLatch(1) : null;
        callBack(() -&gt; {
            try {
                if (!canceled) {
                    boolean keepGoing = notifyWillSendRequest(
                            adjustedNewUrl,
                            newMethod,
                            status,
                            contentType,
                            contentEncoding,
                            contentLength,
                            responseHeaders,
                            adjustedUrl);
                    if (!keepGoing) {
                        fwkCancel();
                    }
                }
            } finally {
                if (latch != null) {
                    latch.countDown();
                }
            }
        });
        if (latch != null) {
            latch.await();
        }
    }

    private boolean notifyWillSendRequest(String newUrl,
                                          String newMethod,
                                          int status,
                                          String contentType,
                                          String contentEncoding,
                                          long contentLength,
                                          String headers,
                                          String url)
    {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(
                    &quot;newUrl: [%s], &quot;
                    + &quot;newMethod: [%s], &quot;
                    + &quot;status: [%d], &quot;
                    + &quot;contentType: [%s], &quot;
                    + &quot;contentEncoding: [%s], &quot;
                    + &quot;contentLength: [%d], &quot;
                    + &quot;url: [%s], &quot;
                    + &quot;data: [0x%016X], &quot;
                    + &quot;headers:%n%s&quot;,
                    newUrl,
                    newMethod,
                    status,
                    contentType,
                    contentEncoding,
                    contentLength,
                    url,
                    data,
                    Util.formatHeaders(headers)));
        }
        boolean result = twkWillSendRequest(
                newUrl,
                newMethod,
                status,
                contentType,
                contentEncoding,
                contentLength,
                headers,
                url,
                data);
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(&quot;result: [%s]&quot;, result));
        }
        return result;
    }

    private void didReceiveResponse(URLConnection c) {
        final int status = extractStatus(c);
        final String contentType = c.getContentType();
        final String contentEncoding = extractContentEncoding(c);
        final long contentLength = extractContentLength(c);
        final String responseHeaders = extractHeaders(c);
        final String adjustedUrl = adjustUrlForWebKit(url);
        callBack(() -&gt; {
            if (!canceled) {
                notifyDidReceiveResponse(
                        status,
                        contentType,
                        contentEncoding,
                        contentLength,
                        responseHeaders,
                        adjustedUrl);
            }
        });
    }

    private void notifyDidReceiveResponse(int status,
                                          String contentType,
                                          String contentEncoding,
                                          long contentLength,
                                          String headers,
                                          String url)
    {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(
                    &quot;status: [%d], &quot;
                    + &quot;contentType: [%s], &quot;
                    + &quot;contentEncoding: [%s], &quot;
                    + &quot;contentLength: [%d], &quot;
                    + &quot;url: [%s], &quot;
                    + &quot;data: [0x%016X], &quot;
                    + &quot;headers:%n%s&quot;,
                    status,
                    contentType,
                    contentEncoding,
                    contentLength,
                    url,
                    data,
                    Util.formatHeaders(headers)));
        }
        twkDidReceiveResponse(
                status,
                contentType,
                contentEncoding,
                contentLength,
                headers,
                url,
                data);
    }

    private void didReceiveData(final ByteBuffer byteBuffer,
                                final ByteBufferAllocator allocator)
    {
        callBack(() -&gt; {
            if (!canceled) {
                notifyDidReceiveData(
                        byteBuffer,
                        byteBuffer.position(),
                        byteBuffer.remaining());
            }
            byteBuffer.clear();
            allocator.release(byteBuffer);
        });
    }

    private void notifyDidReceiveData(ByteBuffer byteBuffer,
                                      int position,
                                      int remaining)
    {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(
                    &quot;byteBuffer: [%s], &quot;
                    + &quot;position: [%s], &quot;
                    + &quot;remaining: [%s], &quot;
                    + &quot;data: [0x%016X]&quot;,
                    byteBuffer,
                    position,
                    remaining,
                    data));
        }
        twkDidReceiveData(byteBuffer, position, remaining, data);
    }

    private void didFinishLoading() {
        callBack(() -&gt; {
            if (!canceled) {
                notifyDidFinishLoading();
            }
        });
    }

    private void notifyDidFinishLoading() {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(&quot;data: [0x%016X]&quot;, data));
        }
        twkDidFinishLoading(data);
    }

    private void didFail(final int errorCode, final String message) {
        final String adjustedUrl = adjustUrlForWebKit(url);
        callBack(() -&gt; {
            if (!canceled) {
                notifyDidFail(errorCode, adjustedUrl, message);
            }
        });
    }

    private void notifyDidFail(int errorCode, String url, String message) {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(String.format(
                    &quot;errorCode: [%d], &quot;
                    + &quot;url: [%s], &quot;
                    + &quot;message: [%s], &quot;
                    + &quot;data: [0x%016X]&quot;,
                    errorCode,
                    url,
                    message,
                    data));
        }
        twkDidFail(errorCode, url, message, data);
    }

    private void callBack(Runnable runnable) {
        if (asynchronous) {
            Invoker.getInvoker().invokeOnEventThread(runnable);
        } else {
            runnable.run();
        }
    }

    private static native void twkDidSendData(long totalBytesSent,
                                              long totalBytesToBeSent,
                                              long data);

    private static native boolean twkWillSendRequest(String newUrl,
                                                     String newMethod,
                                                     int status,
                                                     String contentType,
                                                     String contentEncoding,
                                                     long contentLength,
                                                     String headers,
                                                     String url,
                                                     long data);

    private static native void twkDidReceiveResponse(int status,
                                                     String contentType,
                                                     String contentEncoding,
                                                     long contentLength,
                                                     String headers,
                                                     String url,
                                                     long data);

    private static native void twkDidReceiveData(ByteBuffer byteBuffer,
                                                 int position,
                                                 int remaining,
                                                 long data);

    private static native void twkDidFinishLoading(long data);

    private static native void twkDidFail(int errorCode,
                                          String url,
                                          String message,
                                          long data);

    /**
     * Given a {@link URLConnection}, returns the connection status
     * for passing into native callbacks.
     */
    private static int extractStatus(URLConnection c) {
        int status = 0;
        if (c instanceof HttpURLConnection) {
            try {
                status = ((HttpURLConnection) c).getResponseCode();
            } catch (java.io.IOException ignore) {}
        }
        return status;
    }

    /**
     * Given a {@link URLConnection}, returns the content encoding
     * for passing into native callbacks.
     */
    private static String extractContentEncoding(URLConnection c) {
        String contentEncoding = c.getContentEncoding();
        // For compressed streams, the encoding is in Content-Type
        if (&quot;gzip&quot;.equalsIgnoreCase(contentEncoding) ||
            &quot;deflate&quot;.equalsIgnoreCase(contentEncoding))
        {
            contentEncoding = null;
            String contentType  = c.getContentType();
            if (contentType != null) {
                int i = contentType.indexOf(&quot;charset=&quot;);
                if (i &gt;= 0) {
                    contentEncoding = contentType.substring(i + 8);
                    i = contentEncoding.indexOf(&quot;;&quot;);
                    if (i &gt; 0) {
                        contentEncoding = contentEncoding.substring(0, i);
                    }
                }
            }
        }
        return contentEncoding;
    }

    /**
     * Given a {@link URLConnection}, returns the content length
     * for passing into native callbacks.
     */
    private static long extractContentLength(URLConnection c) {
        // Cannot use URLConnection.getContentLength()
        // as it only returns an int
        try {
            return Long.parseLong(c.getHeaderField(&quot;content-length&quot;));
        } catch (Exception ex) {
            return -1;
        }
    }

    /**
     * Given a {@link URLConnection}, returns the headers string
     * for passing into native callbacks.
     */
    private static String extractHeaders(URLConnection c) {
        StringBuilder sb = new StringBuilder();
        Map&lt;String, List&lt;String&gt;&gt; headers = c.getHeaderFields();
        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry: headers.entrySet()) {
            String key = entry.getKey();
            List&lt;String&gt; values = entry.getValue();
            for (String value : values) {
                sb.append(key != null ? key : &quot;&quot;);
                sb.append(':').append(value).append('\n');
            }
        }
        return sb.toString();
    }

    /**
     * Adjust a URL string for passing into WebKit.
     */
    private static String adjustUrlForWebKit(String url) {
        try {
            url = Util.adjustUrlForWebKit(url);
        } catch (Exception ignore) {
        }
        return url;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/webkit/perf/PerfLogger.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.webkit.perf;

import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;

public final class PerfLogger {
    private static Thread shutdownHook;
    private static Map&lt;PlatformLogger, PerfLogger&gt; loggers;

    private final HashMap&lt;String, ProbeStat&gt; probes =
            new HashMap&lt;String, ProbeStat&gt;();
    private final PlatformLogger log;
    private final boolean isEnabled; // needed at shutdown time

    /**
     * Finds or creates a logger with the given {@code log}.
     * In order the logger be enabled the {@code log} should be loggable.
     *
     * @param log associated {@code Logger}
     */
    public synchronized static PerfLogger getLogger(PlatformLogger log) {
        if (loggers == null) {
            loggers = new HashMap&lt;PlatformLogger, PerfLogger&gt;();
        }
        PerfLogger l = loggers.get(log);
        if (l == null) {
            l = new PerfLogger(log);
            loggers.put(log, l);
        }
        // Add the hook if at least one logger is enabled.
        if (l.isEnabled() &amp;&amp; shutdownHook == null) {
            shutdownHook = new Thread() {
                @Override
                public void run() {
                    for (PerfLogger l: loggers.values()) {
                        if (!l.isEnabled()) continue;
                        // Using stdout as logging might be off at shutdown time.
                        l.log(false);
                    }
                }
            };
            Runtime.getRuntime().addShutdownHook(shutdownHook);
        }
        return l;
    }

    /**
     * Finds or creates a logger with {@code Logger} named
     * com.sun.webkit.perf.{@code name}.
     *
     * @param name the {@code PerfLogger} short name
     */
    public synchronized static PerfLogger getLogger(String name) {
        return getLogger(PlatformLogger.getLogger(&quot;com.sun.webkit.perf.&quot; + name));
    }

    private PerfLogger(PlatformLogger log) {
        this.log = log;
        this.isEnabled = log.isLoggable(Level.FINE);
        startCount(&quot;TOTALTIME&quot;);
    }

    /**
     * The class contains perf statistics for a registered probe.
     */
    public static final class ProbeStat {
        private final String probe;
        private int count;
        private long totalTime;
        private long startTime;
        private boolean isRunning = false;

        private ProbeStat(String probe) {
            this.probe = probe;
        }

        public String getProbe() {
            return probe;
        }

        public int getCount() {
            return count;
        }

        public long getTotalTime() {
            return totalTime;
        }

        private void reset() {
            count = 0;
            totalTime = startTime = 0;
        }

        private void suspend() {
            if (isRunning) {
                totalTime += System.currentTimeMillis() - startTime;
                isRunning = false;
            }
        }

        private void resume() {
            isRunning = true;
            count++;
            startTime = System.currentTimeMillis();
        }

        private void snapshot() {
            if (isRunning) {
                totalTime += System.currentTimeMillis() - startTime;
                startTime = System.currentTimeMillis();
            }
        }

        @Override
        public String toString() {
            return super.toString() + &quot;[count=&quot; + count + &quot;, time=&quot; + totalTime + &quot;]&quot;;
        }
    }

    public boolean isEnabled() {
        return isEnabled;
    }

    private synchronized String fullName(String probe) {
        return log.getName() + &quot;.&quot; + probe;
    }

    private final Comparator timeComparator = (arg0, arg1) -&gt; {
        long t0 = probes.get((String)arg0).totalTime;
        long t1 = probes.get((String)arg1).totalTime;
        if (t0 &gt; t1) {
            return 1;
        } else if (t0 &lt; t1) {
            return -1;
        }
        return 0;
    };

    private final Comparator countComparator = (arg0, arg1) -&gt; {
        long c0 = probes.get((String)arg0).count;
        long c1 = probes.get((String)arg1).count;
        if (c0 &gt; c1) {
            return 1;
        } else if (c0 &lt; c1) {
            return -1;
        }
        return 0;
    };

    /**
     * Resets perf statistics.
     */
    public synchronized void reset() {
        for (Map.Entry&lt;String, ProbeStat&gt; entry: probes.entrySet()) {
            entry.getValue().reset();
        }
        startCount(&quot;TOTALTIME&quot;);
    }
<A NAME="22"></A>
    public synchronized static void resetAll() {
        for (PerfLogger l: loggers.values()) {
            <FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#22',2,'match51-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>l.reset();
        }
    }

    private synchronized ProbeStat registerProbe(String probe) {
        String p = probe.intern();
        if (probes.containsKey(p)) {</B></FONT>
            log.fine(&quot;Warning: \&quot;&quot; + fullName(p) + &quot;\&quot; probe already exists&quot;);
        } else {
            log.fine(&quot;Registering \&quot;&quot; + fullName(p) + &quot;\&quot; probe&quot;);
        }
        ProbeStat stat = new ProbeStat(p);
        probes.put(p, stat);
        return stat;
    }

    public synchronized ProbeStat getProbeStat(String probe) {
        String p = probe.intern();
        ProbeStat s = probes.get(p);
        if (s != null) {
            s.snapshot();
        }
        return s;
    }

    /**
     * Starts count statistics for the probe with zero initial data.
     */
    public synchronized void startCount(String probe) {
        if (!isEnabled()) {
            return;
        }
        String p = probe.intern();
        ProbeStat stat = probes.get(p);
        if (stat == null) {
            stat = registerProbe(p);
        }
        stat.reset();
        stat.resume();
    }

    /**
     * Suspends count statistics for the probe.
     */
    public synchronized void suspendCount(String probe) {
        if (!isEnabled()) {
            return;
        }
        String p = probe.intern();
        ProbeStat stat = probes.get(p);
        if (stat != null) {
            stat.suspend();
        } else {
            log.fine(&quot;Warning: \&quot;&quot; + fullName(p) + &quot;\&quot; probe is not registered&quot;);
        }
    }

    /**
     * Resumes count statistics for the probe, or starts if it's not yet started.
     */
    public synchronized void resumeCount(String probe) {
        if (!isEnabled()) {
            return;
        }
        String p = probe.intern();
        ProbeStat stat = probes.get(p);
        if (stat == null) {
            stat = registerProbe(p);
        }
        stat.resume();
    }

    /**
     * Prints perf statistics to the buffer.
     */
    public synchronized void log(StringBuffer buf) {
        if (!isEnabled()) {
            return;
        }
        buf.append(&quot;=========== Performance Statistics =============\n&quot;);

        ProbeStat total = getProbeStat(&quot;TOTALTIME&quot;);

        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.addAll(probes.keySet());

        buf.append(&quot;\nTime:\n&quot;);
        Collections.sort(list, timeComparator);
        for (String p: list) {
            ProbeStat s = getProbeStat(p);
            buf.append(String.format(&quot;%s: %dms&quot;, fullName(p), s.totalTime));
            if (total.totalTime &gt; 0){
                buf.append(String.format(&quot;, %.2f%%%n&quot;, (float)100*s.totalTime/total.totalTime));
            } else {
                buf.append(&quot;\n&quot;);
            }
        }

        buf.append(&quot;\nInvocations count:\n&quot;);
        Collections.sort(list, countComparator);
        for (String p: list) {
            buf.append(String.format(&quot;%s: %d%n&quot;, fullName(p), getProbeStat(p).count));
        }
        buf.append(&quot;================================================\n&quot;);
    }

    /**
     * Logs perf statistics.
     */
    public synchronized void log() {
        log(true);
    }

    private synchronized void log(boolean useLogger) {
        StringBuffer buf = new StringBuffer();
        log(buf);
        if (useLogger) {
            log.fine(buf.toString());
        } else {
            System.out.println(buf.toString());
            System.out.flush();
        }
    }

    /**
     * Logs perf statistics of all loggers.
     */
    public synchronized static void logAll() {
        for (PerfLogger l: loggers.values()) {
            l.log();
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/View/StartView.java</CENTER></H3><HR>
<PRE>
/*
  RMIT University Vietnam
  Course: INTE2512 Object-Oriented Programming
  Semester: 2019C
  Assessment: Assignment 2
  Author: Hoang Quoc Dai
  ID: s3426353
  Created  date: 15/12/2019
  Last modified: 16/12/2019
  Acknowledgement: If you use any resources, acknowledge here. Failure to do so will be considered as plagiarism.
*/
package sample.View;

import javafx.geometry.Pos;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;


public class StartView extends VBox {
    private Button btLevel1;
    private Button btLevel2;
    private Button btLevel3;
    private Button btSoundPlay;
    private Button btSoundPause;
    private Label message;
    private Label message1;

    public StartView() {
        // Create a vBox
        HBox hBox = new HBox();
        hBox.setSpacing(10);
        hBox.setAlignment(Pos.CENTER);
        // Set name for buttons and message label
        setBtLevel1(new Button(&quot;Level 1&quot;));
        setBtLevel2(new Button(&quot;Level 2&quot;));
        setBtLevel3(new Button(&quot;Level 3&quot;));
        setBtSoundPlay(new Button(&quot;Music On&quot;));
        setBtSoundPause(new Button(&quot;Music Pause&quot;));
        setMessage(new Label(&quot;Hello, QUOC DAI ! &quot;));
        setMessage1(new Label(&quot;PLEASE CHOOSE THE LEVEL TO START !&quot;));
        //Set Front, Size, Color for Message
        getMessage().setFont(new Font(&quot;Arial&quot;, 40));
        getMessage().setTextFill(Color.WHITE);
        //Set Front, Size, Color for Message1
        getMessage1().setFont(new Font(&quot;Arial&quot;, 40));
        getMessage1().setTextFill(Color.WHITE);
        // add 4 buttons to hBox
        hBox.getChildren().addAll(getBtLevel1(), getBtLevel2(), getBtLevel3(), getBtSoundPlay(), getBtSoundPause());

        setAlignment(Pos.CENTER);
        setSpacing(10);

        // add hBox and label to vBox
        getChildren().addAll(getMessage(), getMessage1(),hBox);
    }

    public Button getBtLevel1() {
        return btLevel1;
    }

    public Button getBtLevel2() {
        return btLevel2;
    }

    public Button getBtLevel3() {
        return btLevel3;
    }

    private void setBtLevel1(Button btLevel1) {
        this.btLevel1 = btLevel1;
    }

    private void setBtLevel2(Button btLevel2) {
        this.btLevel2 = btLevel2;
    }

    private void setBtLevel3(Button btLevel3) {
        this.btLevel3 = btLevel3;
    }

    private Label getMessage() {
        return message;
    }

    private void setMessage(Label message) {
        this.message = message;
    }

    private Label getMessage1() {
        return message1;
    }

    private void setMessage1(Label message1) {
<A NAME="7"></A>        this.message1 = message1;
    }

    <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#7',2,'match51-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>public Button getBtSoundPlay() {
        return btSoundPlay;
    }

    private void setBtSoundPlay(Button btSoundPlay) {
        this.btSoundPlay = btSoundPlay;
    }

    public Button getBtSoundPause() {
        return btSoundPause;
    }

    private void setBtSoundPause(Button btSoundPause) {
        this.btSoundPause = btSoundPause;
    }
}</B></FONT>
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/View/TimeBar.java</CENTER></H3><HR>
<PRE>
package sample.View;

import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;


public class TimeBar extends AnchorPane{
    private Timeline timeline;

    public TimeBar() {
        //Create rectangle
        Rectangle rectangle = new Rectangle(1280, 30);
        rectangle.setFill(Color.YELLOW);
        // Create pane and add rectangle to it
        Pane pane = new Pane();
        pane.getChildren().add(rectangle);
        pane.setStyle(&quot;-fx-background-color: white;&quot;);
        AnchorPane.setTopAnchor(pane, 0.0);
        AnchorPane.setLeftAnchor(pane, 0.0);
        AnchorPane.setRightAnchor(pane, 0.0);
        AnchorPane.setBottomAnchor(pane,0.0);
        getChildren().addAll(pane);
        // Create Timeline animation
        double paneWidth = pane.getWidth(); //
        double rectangleWidth = rectangle.getLayoutBounds().getWidth();
        KeyValue initKeyValue1 = new KeyValue(rectangle.translateXProperty(), paneWidth);
        KeyValue initKeyValue2 = new KeyValue(rectangle.scaleXProperty(), 1.0);
        KeyFrame initFrame = new KeyFrame(Duration.ZERO, initKeyValue1, initKeyValue2);
        KeyValue endKeyValue1 = new KeyValue(rectangle.translateXProperty(), -1.0 * rectangleWidth);
        KeyValue endKeyValue2 = new KeyValue(rectangle.scaleXProperty(), 0.2);
        KeyFrame endFrame = new KeyFrame(Duration.minutes(2), endKeyValue1, endKeyValue2);
<A NAME="4"></A>        setTimeline(new Timeline(25 , initFrame, endFrame));
        getTimeline().setCycleCount(1);
        getTimeline().setRate(1);
        <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match51-0.html#4',2,'match51-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getTimeline().setAutoReverse(false);
        getTimeline().play();
    }

    private Timeline getTimeline() {
        return timeline;
    }

    private void setTimeline(Timeline timeline) {
        this.timeline = timeline;
    }
}</B></FONT>
</PRE>

</BODY>
</HTML>
