<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>daihoangquoc_</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.base/javafx/util/converter/PercentageStringConverter.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.util.converter;

import java.text.NumberFormat;
import java.util.Locale;
import javafx.util.StringConverter;

/**
 * &lt;p&gt;{@link StringConverter} implementation for {@link Number} values
 * that represent percentages.&lt;/p&gt;
 *
 * @see CurrencyStringConverter
 * @see NumberStringConverter
 * @see StringConverter
 * @since JavaFX 2.1
 */
public class PercentageStringConverter extends NumberStringConverter {


    // ------------------------------------------------------------ Constructors
    public PercentageStringConverter() {
        this(Locale.getDefault());
    }

    public PercentageStringConverter(Locale locale) {
        super(locale, null, null);
    }

    public PercentageStringConverter(NumberFormat numberFormat) {
        super(null, null, numberFormat);
    }

    // ----------------------------------------------------------------- Methods
<A NAME="42"></A>
    /** {@inheritDoc} */
    @Override public NumberFormat getNumberFormat() {
        Locale _locale = locale == null ? <FONT color="#c57717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#42',2,'match31-top.html#42',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Locale.getDefault() : locale;

        if (numberFormat != null) {
            return numberFormat;
        } else {
            return NumberFormat.getPercentInstance(_locale);
        }
    }
}</B></FONT>
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/ScrollBarBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.util.Utils;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Orientation;
import javafx.scene.control.ScrollBar;
import javafx.scene.control.Skin;
import com.sun.javafx.scene.control.inputmap.InputMap;
import javafx.util.Duration;

import static javafx.scene.input.KeyCode.*;
import static javafx.scene.input.KeyEvent.KEY_RELEASED;

/**
 * A Behavior implementation for ScrollBars.
 *
 */

public class ScrollBarBehavior extends BehaviorBase&lt;ScrollBar&gt; {

    private final InputMap&lt;ScrollBar&gt; inputMap;

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    public ScrollBarBehavior(ScrollBar scrollBar) {
        super(scrollBar);

        // create a map for scrollbar-specific mappings (this reuses the default
        // InputMap installed on the control, if it is non-null, allowing us to pick up any user-specified mappings)
        inputMap = createInputMap();

        // scrollbar-specific mappings for key and mouse input
        addDefaultMapping(inputMap,
            new InputMap.KeyMapping(HOME, KEY_RELEASED, e -&gt; home()),
            new InputMap.KeyMapping(END, KEY_RELEASED, e -&gt; end())
        );

        // create two child input maps for horizontal and vertical scrollbars
        InputMap&lt;ScrollBar&gt; horizontalInputMap = new InputMap&lt;&gt;(scrollBar);
        horizontalInputMap.setInterceptor(e -&gt; scrollBar.getOrientation() != Orientation.HORIZONTAL);
        horizontalInputMap.getMappings().addAll(
            new InputMap.KeyMapping(LEFT, e -&gt; rtl(scrollBar, this::incrementValue, this::decrementValue)),
            new InputMap.KeyMapping(KP_LEFT, e -&gt; rtl(scrollBar, this::incrementValue, this::decrementValue)),
            new InputMap.KeyMapping(RIGHT, e -&gt; rtl(scrollBar, this::decrementValue, this::incrementValue)),
            new InputMap.KeyMapping(KP_RIGHT, e -&gt; rtl(scrollBar, this::decrementValue, this::incrementValue))
        );
        addDefaultChildMap(inputMap, horizontalInputMap);

        InputMap&lt;ScrollBar&gt; verticalInputMap = new InputMap&lt;&gt;(scrollBar);
        verticalInputMap.setInterceptor(e -&gt; scrollBar.getOrientation() != Orientation.VERTICAL);
        verticalInputMap.getMappings().addAll(
                new InputMap.KeyMapping(UP, e -&gt; decrementValue()),
                new InputMap.KeyMapping(KP_UP, e -&gt; decrementValue()),
                new InputMap.KeyMapping(DOWN, e -&gt; incrementValue()),
                new InputMap.KeyMapping(KP_DOWN, e -&gt; incrementValue())
        );
        addDefaultChildMap(inputMap, verticalInputMap);
    }

    /***************************************************************************
     *                                                                         *
     * Functions                                                               *
     *                                                                         *
     **************************************************************************/


    @Override public InputMap&lt;ScrollBar&gt; getInputMap() {
<A NAME="6"></A>        return inputMap;
    }
    private void home() {
        <FONT color="#50ebec"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#6',2,'match31-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getNode().setValue(getNode().getMin());
    }

    private void decrementValue() {
        getNode().adjustValue(0);
    }

    private void end() {
        getNode</B></FONT>().setValue(getNode().getMax());
    }

    private void incrementValue() {
        getNode().adjustValue(1);
    }


    /***************************************************************************
     *                                                                         *
     * Mouse event handling                                                    *
     *                                                                         *
     **************************************************************************/

    /**
     * This timeline is used to adjust the value of the bar when the
     * track has been pressed but not released.
     */
    Timeline timeline;

    /**
     * Invoked by the ScrollBar {@link Skin} implementation whenever a mouse
     * press occurs on the &quot;track&quot; of the bar. This will cause the thumb to
     * be moved by some amount.
     *
     * @param position The mouse position on track with 0.0 being beginning of track and 1.0 being the end
     */
    public void trackPress(double position) {

        /* We can get a press if someone presses an end button.  In that
         * case, we don't want to start a timeline because the end button
         * will have already done so.  We can detect that because the timeline
         * will not be null.
         */
        if (timeline != null) return;

        // determine the percentage of the way between min and max
        // represented by this mouse event
        final ScrollBar bar = getNode();
        if (!bar.isFocused() &amp;&amp; bar.isFocusTraversable()) bar.requestFocus();
        final double pos = position;
        final boolean incrementing = (pos &gt; ((bar.getValue() - bar.getMin())/(bar.getMax() - bar.getMin())));
        timeline = new Timeline();
        timeline.setCycleCount(Timeline.INDEFINITE);

        final EventHandler&lt;ActionEvent&gt; step =
                event -&gt; {
                    boolean i = (pos &gt; ((bar.getValue() - bar.getMin())/(bar.getMax() - bar.getMin())));
                    if (incrementing == i) {
                        // we started incrementing and still are, or we
                        // started decrementing and still are
                        bar.adjustValue(pos);
                    }
                    else {
                        stopTimeline();
                    }
                };

        final KeyFrame kf = new KeyFrame(Duration.millis(200), step);
        timeline.getKeyFrames().add(kf);
        // do the first step immediately
        timeline.play();
        step.handle(null);
    }

    /**
     */
    public void trackRelease() {
        stopTimeline();
    }

    /**
     * Invoked by the ScrollBar {@link Skin} implementation whenever a mouse
     * press occurs on the decrement button of the bar.
     */
    public void decButtonPressed() {
        final ScrollBar bar = getNode();
        if (!bar.isFocused() &amp;&amp; bar.isFocusTraversable()) bar.requestFocus();
        stopTimeline();
        timeline = new Timeline();
        timeline.setCycleCount(Timeline.INDEFINITE);

        final EventHandler&lt;ActionEvent&gt; dec =
                event -&gt; {
                    if (bar.getValue() &gt; bar.getMin()) {
                        bar.decrement();
                    }
                    else {
                        stopTimeline();
                    }
                };

        final KeyFrame kf = new KeyFrame(Duration.millis(200), dec);
        timeline.getKeyFrames().add(kf);
        // do the first step immediately
        timeline.play();
        dec.handle(null);
    }

    /**
     */
    public void decButtonReleased() {
        stopTimeline();
    }

    /**
     * Invoked by the ScrollBar {@link Skin} implementation whenever a mouse
     * press occurs on the increment button of the bar.
     */
    public void incButtonPressed() {
        final ScrollBar bar = getNode();
        if (!bar.isFocused() &amp;&amp; bar.isFocusTraversable()) bar.requestFocus();
        stopTimeline();
        timeline = new Timeline();
        timeline.setCycleCount(Timeline.INDEFINITE);

        final EventHandler&lt;ActionEvent&gt; inc =
                event -&gt; {
                    if (bar.getValue() &lt; bar.getMax()) {
                        bar.increment();
                    }
                    else {
                        stopTimeline();
                    }
                };

        final KeyFrame kf = new KeyFrame(Duration.millis(200), inc);
        timeline.getKeyFrames().add(kf);
        // do the first step immediately
        timeline.play();
        inc.handle(null);
    }

    /**
     */
    public void incButtonReleased() {
        stopTimeline();
    }

    /**
     * @param position The mouse position on track with 0.0 being begining of track and 1.0 being the end
     */
    //public function thumbPressed(e:MouseEvent, position:Number):Void {
    //}

    /**
     * @param position The mouse position on track with 0.0 being begining of track and 1.0 being the end
     */
    public void thumbDragged(double position) {
        final ScrollBar scrollbar = getNode();

        // Stop the timeline for continuous increments as drags take precedence
        stopTimeline();

        if (!scrollbar.isFocused() &amp;&amp; scrollbar.isFocusTraversable()) scrollbar.requestFocus();
        double newValue = (position * (scrollbar.getMax() - scrollbar.getMin())) + scrollbar.getMin();
        if (!Double.isNaN(newValue)) {
            scrollbar.setValue(Utils.clamp(scrollbar.getMin(), newValue, scrollbar.getMax()));
        }
    }

    private void stopTimeline() {
        if (timeline != null) {
            timeline.stop();
            timeline = null;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/TextInputControlBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.PlatformUtil;
import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.skin.FXVK;

import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.scene.control.skin.TextInputControlSkin;
import javafx.application.ConditionalFeature;
import javafx.beans.InvalidationListener;
import javafx.collections.ObservableList;
import javafx.geometry.NodeOrientation;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.IndexRange;
import javafx.scene.control.MenuItem;
import javafx.scene.control.PasswordField;
import javafx.scene.control.SeparatorMenuItem;
import javafx.scene.control.TextInputControl;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.Clipboard;
import com.sun.javafx.scene.control.inputmap.InputMap;
import com.sun.javafx.scene.control.inputmap.KeyBinding;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;

import java.text.Bidi;
import java.util.function.Predicate;

import static com.sun.javafx.PlatformUtil.isLinux;
import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;
import static com.sun.javafx.scene.control.inputmap.KeyBinding.OptionalBoolean;
import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;
import static javafx.scene.control.skin.TextInputControlSkin.TextUnit;
import static javafx.scene.control.skin.TextInputControlSkin.Direction;
import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;
import static com.sun.javafx.scene.control.inputmap.InputMap.MouseMapping;
import static javafx.scene.input.KeyCode.*;
import static javafx.scene.input.KeyEvent.*;

/**
 * All of the &quot;button&quot; types (CheckBox, RadioButton, ToggleButton, and Button)
 * and also maybe some other types like hyperlinks operate on the &quot;armed&quot;
 * selection strategy, just like JButton. This behavior class encapsulates that
 * logic in a way that can be reused and extended by each of the individual
 * class behaviors.
 *
 */
public abstract class TextInputControlBehavior&lt;T extends TextInputControl&gt; extends BehaviorBase&lt;T&gt; {

    /**
     * Specifies whether we ought to show handles. We should do it on touch platforms, but not
     * iOS (and maybe not Android either?)
     */
    static final boolean SHOW_HANDLES = Properties.IS_TOUCH_SUPPORTED &amp;&amp; !PlatformUtil.isIOS();

    public static final String DISABLE_FORWARD_TO_PARENT = &quot;TextInputControlBehavior.disableForwardToParent&quot;;

    /**************************************************************************
     * Fields                                                                 *
     *************************************************************************/

    final T textInputControl;

    protected ContextMenu contextMenu;

    private InvalidationListener textListener = observable -&gt; invalidateBidi();

    private final InputMap&lt;T&gt; inputMap;




    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    public TextInputControlBehavior(T c) {
        super(c);

        this.textInputControl = c;

        textInputControl.textProperty().addListener(textListener);

        // create a map for text input-specific mappings (this reuses the default
        // InputMap installed on the control, if it is non-null, allowing us to pick up any user-specified mappings)
        inputMap = createInputMap();

        // some of the mappings are only valid when the control is editable, or
        // only on certain platforms, so we create the following predicates that filters out the mapping when the
        // control is not in the correct state / on the correct platform
        final Predicate&lt;KeyEvent&gt; validWhenEditable = e -&gt; !c.isEditable();
        final Predicate&lt;KeyEvent&gt; validOnWindows = e -&gt; !PlatformUtil.isWindows();
        final Predicate&lt;KeyEvent&gt; validOnLinux = e -&gt; !PlatformUtil.isLinux();

        KeyMapping cancelEditMapping;
        KeyMapping consumeMostPressedEventsMapping;

        // create a child input map for mappings which are applicable on all
        // platforms, and regardless of editing state
        addDefaultMapping(inputMap,
                // caret movement
                keyMapping(RIGHT, e -&gt; nextCharacterVisually(true)),
                keyMapping(LEFT, e -&gt; nextCharacterVisually(false)),
                keyMapping(UP, e -&gt; c.home()),
                keyMapping(HOME, e -&gt; c.home()),
                keyMapping(DOWN, e -&gt; c.end()),
                keyMapping(END, e -&gt; c.end()),
                keyMapping(ENTER, this::fire),

                keyMapping(new KeyBinding(HOME).shortcut(), e -&gt; c.home()),
                keyMapping(new KeyBinding(END).shortcut(), e -&gt; c.end()),

                // deletion (only applies when control is editable)
                keyMapping(new KeyBinding(BACK_SPACE), e -&gt; deletePreviousChar(), validWhenEditable),
                keyMapping(new KeyBinding(BACK_SPACE).shift(), e -&gt; deletePreviousChar(), validWhenEditable),
                keyMapping(new KeyBinding(DELETE), e -&gt; deleteNextChar(), validWhenEditable),

                // cut (only applies when control is editable)
                keyMapping(new KeyBinding(X).shortcut(), e -&gt; cut(), validWhenEditable),
                keyMapping(new KeyBinding(CUT), e -&gt; cut(), validWhenEditable),

                // copy
                keyMapping(new KeyBinding(C).shortcut(), e -&gt; c.copy()),
                keyMapping(new KeyBinding(INSERT).shortcut(), e -&gt; c.copy()),
                keyMapping(COPY, e -&gt; c.copy()),

                // paste (only applies when control is editable)
                keyMapping(new KeyBinding(V).shortcut(), e -&gt; paste(), validWhenEditable),
                keyMapping(new KeyBinding(PASTE), e -&gt; paste(), validWhenEditable),
                keyMapping(new KeyBinding(INSERT).shift(), e -&gt; paste(), validWhenEditable),

                // selection
                keyMapping(new KeyBinding(RIGHT).shift(), e -&gt; selectRight()),
                keyMapping(new KeyBinding(LEFT).shift(), e -&gt; selectLeft()),
                keyMapping(new KeyBinding(UP).shift(), e -&gt; selectHome()),
                keyMapping(new KeyBinding(DOWN).shift(), e -&gt; selectEnd()),
                keyMapping(new KeyBinding(HOME).shortcut().shift(), e -&gt; selectHome()),
                keyMapping(new KeyBinding(END).shortcut().shift(), e -&gt; selectEnd()),
                keyMapping(new KeyBinding(A).shortcut(), e -&gt; c.selectAll()),

                // Traversal Bindings
                new KeyMapping(new KeyBinding(TAB), FocusTraversalInputMap::traverseNext),
                new KeyMapping(new KeyBinding(TAB).shift(), FocusTraversalInputMap::traversePrevious),
                new KeyMapping(new KeyBinding(TAB).ctrl(), FocusTraversalInputMap::traverseNext),
                new KeyMapping(new KeyBinding(TAB).ctrl().shift(), FocusTraversalInputMap::traversePrevious),

                // The following keys are forwarded to the parent container
                cancelEditMapping = new KeyMapping(ESCAPE, this::cancelEdit),

                keyMapping(new KeyBinding(Z).shortcut(), e -&gt; undo()),

                // character input.
                // Any other key press first goes to normal text input
                // Note this is KEY_TYPED because otherwise the character is not available in the event.
                keyMapping(new KeyBinding(null, KEY_TYPED)
                                    .alt(OptionalBoolean.ANY)
                                    .shift(OptionalBoolean.ANY)
                                    .ctrl(OptionalBoolean.ANY)
                                    .meta(OptionalBoolean.ANY),
                           this::defaultKeyTyped),

                // However, we want to consume other key press / release events too, for
                // things that would have been handled by the InputCharacter normally
                consumeMostPressedEventsMapping =
                    keyMapping(new KeyBinding(null, KEY_PRESSED).shift(OptionalBoolean.ANY),
                               e -&gt; { if (!e.getCode().isFunctionKey()) e.consume(); }),

                // VK
                new KeyMapping(new KeyBinding(DIGIT9).ctrl().shift(), e -&gt; {
                    FXVK.toggleUseVK(textInputControl);
                }, p -&gt; !PlatformImpl.isSupported(ConditionalFeature.VIRTUAL_KEYBOARD)),

                // mouse and context menu mappings
                new MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed),
                new MouseMapping(MouseEvent.MOUSE_DRAGGED, this::mouseDragged),
                new MouseMapping(MouseEvent.MOUSE_RELEASED, this::mouseReleased),
                new InputMap.Mapping&lt;ContextMenuEvent&gt;(ContextMenuEvent.CONTEXT_MENU_REQUESTED, this::contextMenuRequested) {
                    @Override public int getSpecificity(Event event) {
                        return 1;
                    }
                }
        );

        cancelEditMapping.setAutoConsume(false);
        consumeMostPressedEventsMapping.setAutoConsume(false);

        // mac os specific mappings
        InputMap&lt;T&gt; macOsInputMap = new InputMap&lt;&gt;(c);
        macOsInputMap.setInterceptor(e -&gt; !PlatformUtil.isMac());
        macOsInputMap.getMappings().addAll(
            // Mac OS specific mappings
            keyMapping(new KeyBinding(HOME).shift(), e -&gt; selectHomeExtend()),
            keyMapping(new KeyBinding(END).shift(), e -&gt; selectEndExtend()),
            keyMapping(new KeyBinding(LEFT).shortcut(), e -&gt; c.home()),
            keyMapping(new KeyBinding(RIGHT).shortcut(), e -&gt; c.end()),
            keyMapping(new KeyBinding(LEFT).alt(), e -&gt; leftWord()),
            keyMapping(new KeyBinding(RIGHT).alt(), e -&gt; rightWord()),
            keyMapping(new KeyBinding(DELETE).alt(), e -&gt; deleteNextWord()),
            keyMapping(new KeyBinding(BACK_SPACE).alt(), e -&gt; deletePreviousWord()),
            keyMapping(new KeyBinding(BACK_SPACE).shortcut(), e -&gt; deleteFromLineStart()),
            keyMapping(new KeyBinding(Z).shortcut().shift(), e -&gt; redo()),
            keyMapping(new KeyBinding(LEFT).shortcut().shift(), e -&gt; selectHomeExtend()),
            keyMapping(new KeyBinding(RIGHT).shortcut().shift(), e -&gt; selectEndExtend()),

            // Mac OS specific selection mappings
            keyMapping(new KeyBinding(LEFT).shift().alt(), e -&gt; selectLeftWord()),
            keyMapping(new KeyBinding(RIGHT).shift().alt(), e -&gt; selectRightWord())
        );
        addDefaultChildMap(inputMap, macOsInputMap);

        // windows / linux specific mappings
        InputMap&lt;T&gt; nonMacOsInputMap = new InputMap&lt;&gt;(c);
        nonMacOsInputMap.setInterceptor(e -&gt; PlatformUtil.isMac());
        nonMacOsInputMap.getMappings().addAll(
            keyMapping(new KeyBinding(HOME).shift(), e -&gt; selectHome()),
            keyMapping(new KeyBinding(END).shift(), e -&gt; selectEnd()),
            keyMapping(new KeyBinding(LEFT).ctrl(), e -&gt; leftWord()),
            keyMapping(new KeyBinding(RIGHT).ctrl(), e -&gt; rightWord()),
            keyMapping(new KeyBinding(H).ctrl(), e -&gt; deletePreviousChar()),
            keyMapping(new KeyBinding(DELETE).ctrl(), e -&gt; deleteNextWord()),
            keyMapping(new KeyBinding(BACK_SPACE).ctrl(), e -&gt; deletePreviousWord()),
            keyMapping(new KeyBinding(BACK_SLASH).ctrl(), e -&gt; c.deselect()),
            keyMapping(new KeyBinding(Y).ctrl(), e -&gt; redo(), validOnWindows),
            keyMapping(new KeyBinding(Z).ctrl().shift(), e -&gt; redo(), validOnLinux),
            keyMapping(new KeyBinding(LEFT).ctrl().shift(), e -&gt; selectLeftWord()),
            keyMapping(new KeyBinding(RIGHT).ctrl().shift(), e -&gt; selectRightWord())
        );
        addDefaultChildMap(inputMap, nonMacOsInputMap);

        addKeyPadMappings(inputMap);

        textInputControl.textProperty().addListener(textListener);

        contextMenu = new ContextMenu();
}

    @Override public InputMap&lt;T&gt; getInputMap() {
        return inputMap;
    }

    /**
     * Bind keypad arrow keys to the same as the regular arrow keys.
     */
    protected void addKeyPadMappings(InputMap&lt;T&gt; map) {
        // First create a temporary map for the keypad mappings
        InputMap&lt;T&gt; tmpMap = new InputMap&lt;&gt;(getNode());
        for (Object o : map.getMappings()) {
            if (o instanceof KeyMapping) {
                KeyMapping mapping = (KeyMapping)o;
                KeyBinding kb = (KeyBinding)mapping.getMappingKey();
                if (kb.getCode() != null) {
                    KeyCode newCode = null;
                    switch (kb.getCode()) {
                        case LEFT:  newCode = KP_LEFT;  break;
                        case RIGHT: newCode = KP_RIGHT; break;
                        case UP:    newCode = KP_UP;    break;
                        case DOWN:  newCode = KP_DOWN;  break;
                        default:
                    }
                    if (newCode != null) {
                        KeyBinding newkb = new KeyBinding(newCode).shift(kb.getShift())
                                                                  .ctrl(kb.getCtrl())
                                                                  .alt(kb.getAlt())
                                                                  .meta(kb.getMeta());
                        tmpMap.getMappings().add(new KeyMapping(newkb, mapping.getEventHandler()));
                    }
                }
            }
        }
        // Install mappings
        for (Object o : tmpMap.getMappings()) {
            map.getMappings().add((KeyMapping)o);
        }

        // Recursive call for child maps
        for (Object o : map.getChildInputMaps()) {
            addKeyPadMappings((InputMap&lt;T&gt;)o);
        }
    }


    /**
     * Wraps the event handler to pause caret blinking when
     * processing the key event.
     */
    protected KeyMapping keyMapping(final KeyCode keyCode, final EventHandler&lt;KeyEvent&gt; eventHandler) {
        return keyMapping(new KeyBinding(keyCode), eventHandler);
    }

    protected KeyMapping keyMapping(KeyBinding keyBinding, final EventHandler&lt;KeyEvent&gt; eventHandler) {
        return keyMapping(keyBinding, eventHandler, null);
    }

    protected KeyMapping keyMapping(KeyBinding keyBinding, final EventHandler&lt;KeyEvent&gt; eventHandler,
                                    Predicate&lt;KeyEvent&gt; interceptor) {
        return new KeyMapping(keyBinding,
                              e -&gt; {
                                  setCaretAnimating(false);
                                  eventHandler.handle(e);
                                  setCaretAnimating(true);
                              },
                              interceptor);
    }





    /**************************************************************************
     * Disposal methods                                                       *
     *************************************************************************/

    @Override public void dispose() {
        textInputControl.textProperty().removeListener(textListener);
        super.dispose();
    }

    /**************************************************************************
     * Abstract methods                                                       *
     *************************************************************************/

    protected abstract void deleteChar(boolean previous);
    protected abstract void replaceText(int start, int end, String txt);
    protected abstract void setCaretAnimating(boolean play);
    protected abstract void deleteFromLineStart();

    protected abstract void mousePressed(MouseEvent e);
    protected abstract void mouseDragged(MouseEvent e);
    protected abstract void mouseReleased(MouseEvent e);
    protected abstract void contextMenuRequested(ContextMenuEvent e);

    /**************************************************************************
     * Key handling implementation                                            *
     *************************************************************************/

    /**
     * The default handler for a key typed event, which is called when none of
     * the other key bindings match. This is the method which handles basic
     * text entry.
     * @param event not null
     */
    private void defaultKeyTyped(KeyEvent event) {
        final TextInputControl textInput = getNode();
        // I'm not sure this case can actually ever happen, maybe this
        // should be an assert instead?
        if (!textInput.isEditable() || textInput.isDisabled()) return;

        // Sometimes we get events with no key character, in which case
        // we need to bail.
        String character = event.getCharacter();
        if (character.length() == 0) return;

        // Filter out control keys except control+Alt on PC or Alt on Mac
        if (event.isControlDown() || event.isAltDown() || (isMac() &amp;&amp; event.isMetaDown())) {
            if (!((event.isControlDown() || isMac()) &amp;&amp; event.isAltDown())) return;
        }

        setEditing(true);

        // Ignore characters in the control range and the ASCII delete
        // character as well as meta key presses
        if (character.charAt(0) &gt; 0x1F
                &amp;&amp; character.charAt(0) != 0x7F
                &amp;&amp; !event.isMetaDown()) { // Not sure about this one
            final IndexRange selection = textInput.getSelection();
            final int start = selection.getStart();
            final int end = selection.getEnd();

            replaceText(start, end, character);
        }

<A NAME="31"></A>        setEditing(false);
    }

    <FONT color="#3ea99f"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#31',2,'match31-top.html#31',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private Bidi bidi = null;
    private Boolean mixed = null;
    private Boolean rtlText = null;

    private void invalidateBidi() {
        bidi = null;
        mixed = null;
        rtlText = null;
    }

    private Bidi getBidi() {
        if (bidi == null) {</B></FONT>
            bidi = new Bidi(textInputControl.textProperty().getValueSafe(),
                    (textInputControl.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT)
                            ? Bidi.DIRECTION_RIGHT_TO_LEFT
                            : Bidi.DIRECTION_LEFT_TO_RIGHT);
        }
        return bidi;
    }

    protected boolean isMixed() {
        if (mixed == null) {
            mixed = getBidi().isMixed();
        }
        return mixed;
    }

    protected boolean isRTLText() {
        if (rtlText == null) {
            Bidi bidi = getBidi();
            rtlText =
                    (bidi.isRightToLeft() ||
                            (isMixed() &amp;&amp;
                                    textInputControl.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT));
        }
        return rtlText;
    }

    private void nextCharacterVisually(boolean moveRight) {
        if (isMixed()) {
            TextInputControlSkin&lt;?&gt; skin = (TextInputControlSkin&lt;?&gt;)textInputControl.getSkin();
            skin.moveCaret(TextUnit.CHARACTER, moveRight ? Direction.RIGHT : Direction.LEFT, false);
        } else if (moveRight != isRTLText()) {
            textInputControl.forward();
        } else {
            textInputControl.backward();
        }
    }

    private void selectLeft() {
        if (isRTLText()) {
            textInputControl.selectForward();
        } else {
            textInputControl.selectBackward();
        }
    }

    private void selectRight() {
        if (isRTLText()) {
            textInputControl.selectBackward();
        } else {
            textInputControl.selectForward();
        }
    }

    private void deletePreviousChar() {
        setEditing(true);
        deleteChar(true);
        setEditing(false);
    }

    private void deleteNextChar() {
        setEditing(true);
        deleteChar(false);
        setEditing(false);
    }

    protected void deletePreviousWord() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
        int end = textInputControl.getCaretPosition();

        if (end &gt; 0) {
            textInputControl.previousWord();
            int start = textInputControl.getCaretPosition();
            replaceText(start, end, &quot;&quot;);
        }
        setEditing(false);
    }

    protected void deleteNextWord() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
        int start = textInputControl.getCaretPosition();

        if (start &lt; textInputControl.getLength()) {
            nextWord();
            int end = textInputControl.getCaretPosition();
            replaceText(start, end, &quot;&quot;);
        }
        setEditing(false);
    }

    public void deleteSelection() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
        IndexRange selection = textInputControl.getSelection();

        if (selection.getLength() &gt; 0) {
            deleteChar(false);
        }
        setEditing(false);
    }
<A NAME="17"></A>
    public void cut() {
        setEditing(true);
        <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#17',2,'match31-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getNode().cut();
        setEditing(false);
    }

    public void paste() {
        setEditing(true);
        getNode().paste();
        setEditing(false);
    }

    public void undo() {
        setEditing(true);
        getNode().undo();
        setEditing</B></FONT>(false);
    }

    public void redo() {
        setEditing(true);
        getNode().redo();
        setEditing(false);
    }

    protected void selectPreviousWord() {
        getNode().selectPreviousWord();
    }

    public void selectNextWord() {
        TextInputControl textInputControl = getNode();
        if (isMac() || isLinux()) {
            textInputControl.selectEndOfNextWord();
        } else {
            textInputControl.selectNextWord();
        }
    }

    private void selectLeftWord() {
        if (isRTLText()) {
            selectNextWord();
        } else {
            selectPreviousWord();
        }
    }

    private void selectRightWord() {
        if (isRTLText()) {
            selectPreviousWord();
        } else {
            selectNextWord();
        }
    }

    protected void selectWord() {
        final TextInputControl textInputControl = getNode();
        textInputControl.previousWord();
        if (isWindows()) {
            textInputControl.selectNextWord();
        } else {
            textInputControl.selectEndOfNextWord();
        }
        if (SHOW_HANDLES &amp;&amp; contextMenu.isShowing()) {
            populateContextMenu();
        }
    }

    protected void selectAll() {
        getNode().selectAll();
        if (SHOW_HANDLES &amp;&amp; contextMenu.isShowing()) {
            populateContextMenu();
        }
    }

    protected void previousWord() {
        getNode().previousWord();
    }

    protected void nextWord() {
        TextInputControl textInputControl = getNode();
        if (isMac() || isLinux()) {
            textInputControl.endOfNextWord();
        } else {
            textInputControl.nextWord();
        }
    }

    private void leftWord() {
        if (isRTLText()) {
            nextWord();
<A NAME="4"></A>        } else {
            previousWord();
        }
    <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#4',2,'match31-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    private void rightWord() {
        if (isRTLText()) {
            previousWord();
        } else {
            nextWord();
        }
    }

    protected void fire(KeyEvent event) {</B></FONT> } // TODO move to TextFieldBehavior
    protected void cancelEdit(KeyEvent event) { forwardToParent(event);} // not autoconsumed

    protected void forwardToParent(KeyEvent event) {
        // fix for JDK-8145515
        if (getNode().getProperties().containsKey(DISABLE_FORWARD_TO_PARENT)) {
            return;
        }

        if (getNode().getParent() != null) {
            getNode().getParent().fireEvent(event);
        }
    }

    protected void selectHome() {
        getNode().selectHome();
    }

    protected void selectEnd() {
        getNode().selectEnd();
    }

    protected void selectHomeExtend() {
        getNode().extendSelection(0);
    }

    protected void selectEndExtend() {
        TextInputControl textInputControl = getNode();
        textInputControl.extendSelection(textInputControl.getLength());
    }

    private boolean editing = false;
    protected void setEditing(boolean b) {
        editing = b;
    }
    public boolean isEditing() {
        return editing;
    }

    protected void populateContextMenu() {
        TextInputControl textInputControl = getNode();
        boolean editable = textInputControl.isEditable();
        boolean hasText = (textInputControl.getLength() &gt; 0);
        boolean hasSelection = (textInputControl.getSelection().getLength() &gt; 0);
        boolean allSelected = (textInputControl.getSelection().getLength() == textInputControl.getLength());
        boolean maskText = (textInputControl instanceof PasswordField); // (maskText(&quot;A&quot;) != &quot;A&quot;);
        ObservableList&lt;MenuItem&gt; items = contextMenu.getItems();

        if (SHOW_HANDLES) {
            items.clear();
            if (!maskText &amp;&amp; hasSelection) {
                if (editable) {
                    items.add(cutMI);
                }
                items.add(copyMI);
            }
            if (editable &amp;&amp; Clipboard.getSystemClipboard().hasString()) {
                items.add(pasteMI);
            }
            if (hasText &amp;&amp; !allSelected) {
                if (!hasSelection &amp;&amp; !(textInputControl instanceof PasswordField)) {
                    items.add(selectWordMI);
                }
                items.add(selectAllMI);
            }
            selectWordMI.getProperties().put(&quot;refreshMenu&quot;, Boolean.TRUE);
            selectAllMI.getProperties().put(&quot;refreshMenu&quot;, Boolean.TRUE);
        } else {
            if (editable) {
                items.setAll(undoMI, redoMI, cutMI, copyMI, pasteMI, deleteMI,
                        separatorMI, selectAllMI);
            } else {
                items.setAll(copyMI, separatorMI, selectAllMI);
            }
            undoMI.setDisable(!getNode().isUndoable());
            redoMI.setDisable(!getNode().isRedoable());
            cutMI.setDisable(maskText || !hasSelection);
            copyMI.setDisable(maskText || !hasSelection);
            pasteMI.setDisable(!Clipboard.getSystemClipboard().hasString());
            deleteMI.setDisable(!hasSelection);
        }
    }

    private static class ContextMenuItem extends MenuItem {
        ContextMenuItem(final String action, EventHandler&lt;ActionEvent&gt; onAction) {
            super(getString(&quot;TextInputControl.menu.&quot; + action));
            setOnAction(onAction);
        }
    }

    private final MenuItem undoMI   = new ContextMenuItem(&quot;Undo&quot;, e -&gt; undo());
    private final MenuItem redoMI   = new ContextMenuItem(&quot;Redo&quot;, e -&gt; redo());
    private final MenuItem cutMI    = new ContextMenuItem(&quot;Cut&quot;, e -&gt; cut());
    private final MenuItem copyMI   = new ContextMenuItem(&quot;Copy&quot;, e -&gt; getNode().copy());
    private final MenuItem pasteMI  = new ContextMenuItem(&quot;Paste&quot;, e -&gt; paste());
    private final MenuItem deleteMI = new ContextMenuItem(&quot;DeleteSelection&quot;, e -&gt; deleteSelection());
    private final MenuItem selectWordMI = new ContextMenuItem(&quot;SelectWord&quot;, e -&gt; selectWord());
    private final MenuItem selectAllMI = new ContextMenuItem(&quot;SelectAll&quot;, e -&gt; selectAll());
    private final MenuItem separatorMI = new SeparatorMenuItem();

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/Axis.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;

import com.sun.javafx.scene.NodeHelper;
import javafx.css.Styleable;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableObjectProperty;

import javafx.css.converter.BooleanConverter;
import javafx.css.converter.EnumConverter;
import javafx.css.converter.PaintConverter;
import javafx.css.converter.SizeConverter;

import java.util.*;

import javafx.animation.FadeTransition;
import javafx.beans.binding.DoubleExpression;
import javafx.beans.binding.ObjectExpression;
import javafx.beans.binding.StringExpression;
import javafx.beans.property.*;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.css.FontCssMetaData;
import javafx.css.StyleableProperty;
import javafx.geometry.Bounds;
import javafx.geometry.Dimension2D;
import javafx.geometry.Orientation;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.scene.control.Label;
import javafx.scene.layout.Region;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.scene.shape.LineTo;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.Path;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.scene.transform.Rotate;
import javafx.scene.transform.Translate;
import javafx.util.Duration;


/**
 * Base class for all axes in JavaFX that represents an axis drawn on a chart area.
 * It holds properties for axis auto ranging, ticks and labels along the axis.
 * &lt;p&gt;
 * Some examples of concrete subclasses include {@link NumberAxis} whose axis plots data
 * in numbers and {@link CategoryAxis} whose values / ticks represent string
 * categories along its axis.
 * @since JavaFX 2.0
 */
public abstract class Axis&lt;T&gt; extends Region {

    // -------------- PRIVATE FIELDS -----------------------------------------------------------------------------------

    Text measure = new Text();
    private Orientation effectiveOrientation;
    private double effectiveTickLabelRotation = Double.NaN;
    private Label axisLabel = new Label();
    private final Path tickMarkPath = new Path();
    private double oldLength = 0;
    /** True when the current range invalid and all dependent calculations need to be updated */
    boolean rangeValid = false;
    boolean measureInvalid = false;
    boolean tickLabelsVisibleInvalid = false;

    private BitSet labelsToSkip = new BitSet();

    // -------------- PUBLIC PROPERTIES --------------------------------------------------------------------------------

    private final ObservableList&lt;TickMark&lt;T&gt;&gt; tickMarks = FXCollections.observableArrayList();
    private final ObservableList&lt;TickMark&lt;T&gt;&gt; unmodifiableTickMarks = FXCollections.unmodifiableObservableList(tickMarks);
    /**
     * Unmodifiable observable list of tickmarks, each TickMark directly representing a tickmark on this axis. This is updated
     * whenever the displayed tickmarks changes.
     *
     * @return Unmodifiable observable list of TickMarks on this axis
     */
    public ObservableList&lt;TickMark&lt;T&gt;&gt; getTickMarks() { return unmodifiableTickMarks; }

    /** The side of the plot which this axis is being drawn on */
    private ObjectProperty&lt;Side&gt; side = new StyleableObjectProperty&lt;Side&gt;(){
        @Override protected void invalidated() {
            // cause refreshTickMarks
            Side edge = get();
            pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, edge == Side.TOP);
            pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, edge == Side.RIGHT);
            pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, edge == Side.BOTTOM);
            pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, edge == Side.LEFT);
            requestAxisLayout();
        }

        @Override
        public CssMetaData&lt;Axis&lt;?&gt;,Side&gt; getCssMetaData() {
            return StyleableProperties.SIDE;
        }

        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;side&quot;;
        }
    };
    public final Side getSide() { return side.get(); }
    public final void setSide(Side value) { side.set(value); }
    public final ObjectProperty&lt;Side&gt; sideProperty() { return side; }

    final void setEffectiveOrientation(Orientation orientation) {
        effectiveOrientation = orientation;
    }

    final Side getEffectiveSide() {
        final Side side = getSide();
        if (side == null || (side.isVertical() &amp;&amp; effectiveOrientation == Orientation.HORIZONTAL)
                || side.isHorizontal() &amp;&amp; effectiveOrientation == Orientation.VERTICAL) {
            // Means side == null &amp;&amp; effectiveOrientation == null produces Side.BOTTOM
            return effectiveOrientation == Orientation.VERTICAL ? Side.LEFT : Side.BOTTOM;
        }
        return side;
    }

    /** The axis label */
    private ObjectProperty&lt;String&gt; label = new ObjectPropertyBase&lt;String&gt;() {
        @Override protected void invalidated() {
            axisLabel.setText(get());
            requestAxisLayout();
        }

        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;label&quot;;
        }
    };
    public final String getLabel() { return label.get(); }
    public final void setLabel(String value) { label.set(value); }
    public final ObjectProperty&lt;String&gt; labelProperty() { return label; }

    /** true if tick marks should be displayed */
    private BooleanProperty tickMarkVisible = new StyleableBooleanProperty(true) {
        @Override protected void invalidated() {
            tickMarkPath.setVisible(get());
            requestAxisLayout();
        }

        @Override
        public CssMetaData&lt;Axis&lt;?&gt;,Boolean&gt; getCssMetaData() {
            return StyleableProperties.TICK_MARK_VISIBLE;
        }
        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;tickMarkVisible&quot;;
        }
    };
    public final boolean isTickMarkVisible() { return tickMarkVisible.get(); }
    public final void setTickMarkVisible(boolean value) { tickMarkVisible.set(value); }
    public final BooleanProperty tickMarkVisibleProperty() { return tickMarkVisible; }

    /** true if tick mark labels should be displayed */
    private BooleanProperty tickLabelsVisible = new StyleableBooleanProperty(true) {
        @Override protected void invalidated() {
            // update textNode visibility for each tick
            for (TickMark&lt;T&gt; tick : tickMarks) {
                tick.setTextVisible(get());
            }
            tickLabelsVisibleInvalid = true;
            requestAxisLayout();
        }

        @Override
        public CssMetaData&lt;Axis&lt;?&gt;,Boolean&gt; getCssMetaData() {
            return StyleableProperties.TICK_LABELS_VISIBLE;
        }

        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;tickLabelsVisible&quot;;
        }
    };
    public final boolean isTickLabelsVisible() { return tickLabelsVisible.get(); }
    public final void setTickLabelsVisible(boolean value) {
        tickLabelsVisible.set(value); }
    public final BooleanProperty tickLabelsVisibleProperty() { return tickLabelsVisible; }

    /** The length of tick mark lines */
    private DoubleProperty tickLength = new StyleableDoubleProperty(8) {
        @Override protected void invalidated() {
            if (tickLength.get() &lt; 0 &amp;&amp; !tickLength.isBound()) {
                tickLength.set(0);
            }
            // this effects preferred size so request layout
            requestAxisLayout();
        }

        @Override
        public CssMetaData&lt;Axis&lt;?&gt;,Number&gt; getCssMetaData() {
            return StyleableProperties.TICK_LENGTH;
        }
        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;tickLength&quot;;
        }
    };
    public final double getTickLength() { return tickLength.get(); }
    public final void setTickLength(double value) { tickLength.set(value); }
    public final DoubleProperty tickLengthProperty() { return tickLength; }

    /** This is true when the axis determines its range from the data automatically */
    private BooleanProperty autoRanging = new BooleanPropertyBase(true) {
        @Override protected void invalidated() {
            if(get()) {
                // auto range turned on, so need to auto range now
//                autoRangeValid = false;
                requestAxisLayout();
            }
        }

        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;autoRanging&quot;;
        }
    };
    public final boolean isAutoRanging() { return autoRanging.get(); }
    public final void setAutoRanging(boolean value) { autoRanging.set(value); }
    public final BooleanProperty autoRangingProperty() { return autoRanging; }

    /** The font for all tick labels */
    private ObjectProperty&lt;Font&gt; tickLabelFont = new StyleableObjectProperty&lt;Font&gt;(Font.font(&quot;System&quot;,8)) {
        @Override protected void invalidated() {
            Font f = get();
            measure.setFont(f);
            for(TickMark&lt;T&gt; tm : getTickMarks()) {
                tm.textNode.setFont(f);
            }
            measureInvalid = true;
            requestAxisLayout();
        }

        @Override
        public CssMetaData&lt;Axis&lt;?&gt;,Font&gt; getCssMetaData() {
            return StyleableProperties.TICK_LABEL_FONT;
        }

        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;tickLabelFont&quot;;
        }
    };
    public final Font getTickLabelFont() { return tickLabelFont.get(); }
    public final void setTickLabelFont(Font value) { tickLabelFont.set(value); }
    public final ObjectProperty&lt;Font&gt; tickLabelFontProperty() { return tickLabelFont; }

    /** The fill for all tick labels */
    private ObjectProperty&lt;Paint&gt; tickLabelFill = new StyleableObjectProperty&lt;Paint&gt;(Color.BLACK) {
        @Override protected void invalidated() {
            for (TickMark&lt;T&gt; tick : tickMarks) {
                tick.textNode.setFill(getTickLabelFill());
            }
        }

        @Override
        public CssMetaData&lt;Axis&lt;?&gt;,Paint&gt; getCssMetaData() {
            return StyleableProperties.TICK_LABEL_FILL;
        }

        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;tickLabelFill&quot;;
        }
    };
    public final Paint getTickLabelFill() { return tickLabelFill.get(); }
    public final void setTickLabelFill(Paint value) { tickLabelFill.set(value); }
    public final ObjectProperty&lt;Paint&gt; tickLabelFillProperty() { return tickLabelFill; }

    /** The gap between tick labels and the tick mark lines */
    private DoubleProperty tickLabelGap = new StyleableDoubleProperty(3) {
        @Override protected void invalidated() {
           requestAxisLayout();
        }

        @Override
        public CssMetaData&lt;Axis&lt;?&gt;,Number&gt; getCssMetaData() {
            return StyleableProperties.TICK_LABEL_TICK_GAP;
        }

        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;tickLabelGap&quot;;
        }
    };
    public final double getTickLabelGap() { return tickLabelGap.get(); }
    public final void setTickLabelGap(double value) { tickLabelGap.set(value); }
    public final DoubleProperty tickLabelGapProperty() { return tickLabelGap; }

    /**
     * When true any changes to the axis and its range will be animated.
     */
    private BooleanProperty animated = new SimpleBooleanProperty(this, &quot;animated&quot;, true);

    /**
     * Indicates whether the changes to axis range will be animated or not.
     *
     * @return true if axis range changes will be animated and false otherwise
     */
    public final boolean getAnimated() { return animated.get(); }
    public final void setAnimated(boolean value) { animated.set(value); }
    public final BooleanProperty animatedProperty() { return animated; }

    /**
     * Rotation in degrees of tick mark labels from their normal horizontal.
     */
    private DoubleProperty tickLabelRotation = new DoublePropertyBase(0) {
        @Override protected void invalidated() {
            if (isAutoRanging()) {
                invalidateRange(); // NumberAxis and CategoryAxis use this property in autorange
            }
            requestAxisLayout();
        }

        @Override
        public Object getBean() {
            return Axis.this;
        }

        @Override
        public String getName() {
            return &quot;tickLabelRotation&quot;;
        }
    };
    public final double getTickLabelRotation() { return tickLabelRotation.getValue(); }
    public final void setTickLabelRotation(double value) { tickLabelRotation.setValue(value); }
    public final DoubleProperty tickLabelRotationProperty() { return tickLabelRotation; }

    // -------------- CONSTRUCTOR --------------------------------------------------------------------------------------

    /**
     * Creates and initializes a new instance of the Axis class.
     */
    public Axis() {
        getStyleClass().setAll(&quot;axis&quot;);
        axisLabel.getStyleClass().add(&quot;axis-label&quot;);
        axisLabel.setAlignment(Pos.CENTER);
        tickMarkPath.getStyleClass().add(&quot;axis-tick-mark&quot;);
        getChildren().addAll(axisLabel, tickMarkPath);
    }

    // -------------- METHODS ------------------------------------------------------------------------------------------

    /**
     * See if the current range is valid, if it is not then any range dependent calulcations need to redone on the next layout pass
     *
     * @return true if current range calculations are valid
     */
    protected final boolean isRangeValid() { return rangeValid; }

    /**
     * Mark the current range invalid, this will cause anything that depends on the range to be recalculated on the
     * next layout.
     */
    protected final void invalidateRange() { rangeValid = false; }

    /**
     * This is used to check if any given animation should run. It returns true if animation is enabled and the node
     * is visible and in a scene.
     *
     * @return true if animations should happen
     */
    protected final boolean shouldAnimate(){
        return getAnimated() &amp;&amp; NodeHelper.isTreeShowing(this);
    }

    /**
     * We suppress requestLayout() calls here by doing nothing as we don't want changes to our children to cause
     * layout. If you really need to request layout then call requestAxisLayout().
     */
    @Override public void requestLayout() {}

    /**
     * Request that the axis is laid out in the next layout pass. This replaces requestLayout() as it has been
     * overridden to do nothing so that changes to children's bounds etc do not cause a layout. This was done as a
     * optimization as the Axis knows the exact minimal set of changes that really need layout to be updated. So we
     * only want to request layout then, not on any child change.
     */
    public void requestAxisLayout() {
        super.requestLayout();
    }

    /**
     * Called when data has changed and the range may not be valid any more. This is only called by the chart if
     * isAutoRanging() returns true. If we are auto ranging it will cause layout to be requested and auto ranging to
     * happen on next layout pass.
     *
     * @param data The current set of all data that needs to be plotted on this axis
     */
    public void invalidateRange(List&lt;T&gt; data) {
        invalidateRange();
        requestAxisLayout();
    }

    /**
     * This calculates the upper and lower bound based on the data provided to invalidateRange() method. This must not
     * effect the state of the axis, changing any properties of the axis. Any results of the auto-ranging should be
     * returned in the range object. This will we passed to setRange() if it has been decided to adopt this range for
     * this axis.
     *
     * @param length The length of the axis in screen coordinates
     * @return Range information, this is implementation dependent
     */
    protected abstract Object autoRange(double length);

    /**
     * Called to set the current axis range to the given range. If isAnimating() is true then this method should
     * animate the range to the new range.
     *
     * @param range A range object returned from autoRange()
     * @param animate If true animate the change in range
     */
    protected abstract void setRange(Object range, boolean animate);

    /**
     * Called to get the current axis range.
     *
     * @return A range object that can be passed to setRange() and calculateTickValues()
     */
    protected abstract Object getRange();

    /**
     * Get the display position of the zero line along this axis.
     *
     * @return display position or Double.NaN if zero is not in current range;
     */
    public abstract double getZeroPosition();

    /**
     * Get the display position along this axis for a given value.
     * If the value is not in the current range, the returned value will be an extrapolation of the display
     * position.
     *
     * If the value is not valid for this Axis and the axis cannot display such value in any range,
     * Double.NaN is returned
     *
     * @param value The data value to work out display position for
     * @return display position or Double.NaN if value not valid
     */
    public abstract double getDisplayPosition(T value);

    /**
     * Get the data value for the given display position on this axis. If the axis
     * is a CategoryAxis this will be the nearest value.
     *
     * @param  displayPosition A pixel position on this axis
     * @return the nearest data value to the given pixel position or
     *         null if not on axis;
     */
    public abstract T getValueForDisplay(double displayPosition);

    /**
     * Checks if the given value is plottable on this axis
     *
     * @param value The value to check if its on axis
     * @return true if the given value is plottable on this axis
     */
    public abstract boolean isValueOnAxis(T value);

    /**
     * All axis values must be representable by some numeric value. This gets the numeric value for a given data value.
     *
     * @param value The data value to convert
     * @return Numeric value for the given data value
     */
    public abstract double toNumericValue(T value);

    /**
     * All axis values must be representable by some numeric value. This gets the data value for a given numeric value.
     *
     * @param value The numeric value to convert
     * @return Data value for given numeric value
     */
    public abstract T toRealValue(double value);

    /**
     * Calculate a list of all the data values for each tick mark in range
     *
     * @param length The length of the axis in display units
     * @param range A range object returned from autoRange()
     * @return A list of tick marks that fit along the axis if it was the given length
     */
    protected abstract List&lt;T&gt; calculateTickValues(double length, Object range);

    /**
     * Computes the preferred height of this axis for the given width. If axis orientation
     * is horizontal, it takes into account the tick mark length, tick label gap and
     * label height.
     *
     * @return the computed preferred width for this axis
     */
    @Override protected double computePrefHeight(double width) {
        final Side side = getEffectiveSide();
        if (side.isVertical()) {
            // TODO for now we have no hard and fast answer here, I guess it should work
            // TODO out the minimum size needed to display min, max and zero tick mark labels.
            return 100;
        } else { // HORIZONTAL
            // we need to first auto range as this may/will effect tick marks
            Object range = autoRange(width);
            // calculate max tick label height
            double maxLabelHeight = 0;
            // calculate the new tick marks
            if (isTickLabelsVisible()) {
                final List&lt;T&gt; newTickValues = calculateTickValues(width, range);
                for (T value: newTickValues) {
                    maxLabelHeight = Math.max(maxLabelHeight,measureTickMarkSize(value, range).getHeight());
                }
            }
            // calculate tick mark length
            final double tickMarkLength = isTickMarkVisible() ? (getTickLength() &gt; 0) ? getTickLength() : 0 : 0;
            // calculate label height
            final double labelHeight =
                    axisLabel.getText() == null || axisLabel.getText().length() == 0 ?
                    0 : axisLabel.prefHeight(-1);
            return maxLabelHeight + getTickLabelGap() + tickMarkLength + labelHeight;
        }
    }

    /**
     * Computes the preferred width of this axis for the given height. If axis orientation
     * is vertical, it takes into account the tick mark length, tick label gap and
     * label height.
     *
     * @return the computed preferred width for this axis
     */
    @Override protected double computePrefWidth(double height) {
        final Side side = getEffectiveSide();
        if (side.isVertical()) {
            // we need to first auto range as this may/will effect tick marks
            Object range = autoRange(height);
            // calculate max tick label width
            double maxLabelWidth = 0;
            // calculate the new tick marks
            if (isTickLabelsVisible()) {
                final List&lt;T&gt; newTickValues = calculateTickValues(height,range);
                for (T value: newTickValues) {
                    maxLabelWidth = Math.max(maxLabelWidth, measureTickMarkSize(value, range).getWidth());
                }
            }
            // calculate tick mark length
            final double tickMarkLength = isTickMarkVisible() ? (getTickLength() &gt; 0) ? getTickLength() : 0 : 0;
            // calculate label height
            final double labelHeight =
                    axisLabel.getText() == null || axisLabel.getText().length() == 0 ?
                    0 : axisLabel.prefHeight(-1);
            return maxLabelWidth + getTickLabelGap() + tickMarkLength + labelHeight;
        } else  { // HORIZONTAL
            // TODO for now we have no hard and fast answer here, I guess it should work
            // TODO out the minimum size needed to display min, max and zero tick mark labels.
            return 100;
        }
    }

    /**
     * Called during layout if the tickmarks have been updated, allowing subclasses to do anything they need to
     * in reaction.
     */
    protected void tickMarksUpdated(){}

    /**
     * Invoked during the layout pass to layout this axis and all its content.
     */
    @Override protected void layoutChildren() {
        final boolean isFirstPass = oldLength == 0;
        // auto range if it is not valid
        final Side side = getEffectiveSide();
        final double length = side.isVertical() ? getHeight() : getWidth();
        boolean rangeInvalid = !isRangeValid();
        boolean lengthDiffers = oldLength != length;
        if (lengthDiffers || rangeInvalid) {
            // get range
            Object range;
            if(isAutoRanging()) {
                // auto range
                range = autoRange(length);
                // set current range to new range
                setRange(range, getAnimated() &amp;&amp; !isFirstPass &amp;&amp; NodeHelper.isTreeShowing(this) &amp;&amp; rangeInvalid);
            } else {
                range = getRange();
            }
            // calculate new tick marks
            List&lt;T&gt; newTickValues = calculateTickValues(length, range);

            // remove everything
            Iterator&lt;TickMark&lt;T&gt;&gt; tickMarkIterator = tickMarks.iterator();
            while (tickMarkIterator.hasNext()) {
                TickMark&lt;T&gt; tick = tickMarkIterator.next();
                final TickMark&lt;T&gt; tm = tick;
                if (shouldAnimate()) {
                    FadeTransition ft = new FadeTransition(Duration.millis(250),tick.textNode);
                    ft.setToValue(0);
                    ft.setOnFinished(actionEvent -&gt; {
                        getChildren().remove(tm.textNode);
                    });
                    ft.play();
                } else {
                    getChildren().remove(tm.textNode);
                }
                // we have to remove the tick mark immediately so we don't draw tick line for it or grid lines and fills
                tickMarkIterator.remove();
            }

            // add new tick marks for new values
            for(T newValue: newTickValues) {
                final TickMark&lt;T&gt; tick = new TickMark&lt;T&gt;();
                tick.setValue(newValue);
                tick.textNode.setText(getTickMarkLabel(newValue));
                tick.textNode.setFont(getTickLabelFont());
                tick.textNode.setFill(getTickLabelFill());
                tick.setTextVisible(isTickLabelsVisible());
                if (shouldAnimate()) tick.textNode.setOpacity(0);
                getChildren().add(tick.textNode);
                tickMarks.add(tick);
                if (shouldAnimate()) {
                    FadeTransition ft = new FadeTransition(Duration.millis(750),tick.textNode);
                    ft.setFromValue(0);
                    ft.setToValue(1);
                    ft.play();
                }
            }

            // call tick marks updated to inform subclasses that we have updated tick marks
            tickMarksUpdated();
            // mark all done
            oldLength = length;
            rangeValid = true;
        }

        if (lengthDiffers || rangeInvalid || measureInvalid || tickLabelsVisibleInvalid) {
            measureInvalid = false;
            tickLabelsVisibleInvalid = false;
            // RT-12272 : tick labels overlapping
            // first check if all visible labels fit, if not, retain every nth label
            labelsToSkip.clear();
            int numLabelsToSkip = 0;
            double totalLabelsSize = 0;
            double maxLabelSize = 0;
            for (TickMark&lt;T&gt; m : tickMarks) {
                m.setPosition(getDisplayPosition(m.getValue()));
                if (m.isTextVisible()) {
                    double tickSize = measureTickMarkSize(m.getValue(), side);
                    totalLabelsSize += tickSize;
                    maxLabelSize = Math.round(Math.max(maxLabelSize, tickSize));
                }
            }
            if (maxLabelSize &gt; 0 &amp;&amp; length &lt; totalLabelsSize) {
                numLabelsToSkip = ((int)(tickMarks.size() * maxLabelSize / length)) + 1;
            }

            if (numLabelsToSkip &gt; 0) {
                int tickIndex = 0;
                for (TickMark&lt;T&gt; m : tickMarks) {
                    if (m.isTextVisible()) {
                        m.setTextVisible((tickIndex++ % numLabelsToSkip) == 0);
                    }
                }
            }

            // now check if labels for bounds overlap nearby labels, this can happen due to JDK-8097501
            // use tickLabelGap to prevent sticking
            if (tickMarks.size() &gt; 2) {
                TickMark&lt;T&gt; m1 = tickMarks.get(0);
                TickMark&lt;T&gt; m2 = tickMarks.get(1);
                if (isTickLabelsOverlap(side, m1, m2, getTickLabelGap())) {
                    m2.setTextVisible(false);
                }
                m1 = tickMarks.get(tickMarks.size()-2);
                m2 = tickMarks.get(tickMarks.size()-1);
                if (isTickLabelsOverlap(side, m1, m2, getTickLabelGap())) {
                    m1.setTextVisible(false);
                }
            }
            updateTickMarks(side, length);
        }
    }

    private void updateTickMarks(Side side, double length) {
        // clear tick mark path elements as we will recreate
        tickMarkPath.getElements().clear();
        // do layout of axis label, tick mark lines and text
        final double width = getWidth();
        final double height = getHeight();
        final double tickMarkLength = (isTickMarkVisible() &amp;&amp; getTickLength() &gt; 0) ? getTickLength() : 0;
        final double effectiveLabelRotation = getEffectiveTickLabelRotation();
        if (Side.LEFT.equals(side)) {
            // offset path to make strokes snap to pixel
            tickMarkPath.setLayoutX(-0.5);
            tickMarkPath.setLayoutY(0.5);
            if (getLabel() != null) {
                axisLabel.getTransforms().setAll(new Translate(0, height), new Rotate(-90, 0, 0));
                axisLabel.setLayoutX(0);
                axisLabel.setLayoutY(0);
                //noinspection SuspiciousNameCombination
                axisLabel.resize(height, Math.ceil(axisLabel.prefHeight(width)));
            }
            for (TickMark&lt;T&gt; tick : tickMarks) {
                positionTextNode(tick.textNode, width - getTickLabelGap() - tickMarkLength,
                        tick.getPosition(), effectiveLabelRotation, side);
                updateTickMark(tick, length,
                        width - tickMarkLength, tick.getPosition(),
                        width, tick.getPosition());
            }
        } else if (Side.RIGHT.equals(side)) {
            // offset path to make strokes snap to pixel
            tickMarkPath.setLayoutX(0.5);
            tickMarkPath.setLayoutY(0.5);
            if (getLabel() != null) {
                final double axisLabelWidth = Math.ceil(axisLabel.prefHeight(width));
                axisLabel.getTransforms().setAll(new Translate(0, height), new Rotate(-90, 0, 0));
                axisLabel.setLayoutX(width-axisLabelWidth);
                axisLabel.setLayoutY(0);
                //noinspection SuspiciousNameCombination
                axisLabel.resize(height, axisLabelWidth);
            }
            for (TickMark&lt;T&gt; tick : tickMarks) {
                positionTextNode(tick.textNode, getTickLabelGap() + tickMarkLength,
                        tick.getPosition(), effectiveLabelRotation, side);
                updateTickMark(tick, length,
                        0, tick.getPosition(),
                        tickMarkLength, tick.getPosition());
            }
        } else if (Side.TOP.equals(side)) {
            // offset path to make strokes snap to pixel
            tickMarkPath.setLayoutX(0.5);
            tickMarkPath.setLayoutY(-0.5);
            if (getLabel() != null) {
                axisLabel.getTransforms().clear();
                axisLabel.setLayoutX(0);
                axisLabel.setLayoutY(0);
                axisLabel.resize(width, Math.ceil(axisLabel.prefHeight(width)));
            }
            for (TickMark&lt;T&gt; tick : tickMarks) {
                positionTextNode(tick.textNode, tick.getPosition(), height - tickMarkLength - getTickLabelGap(),
                        effectiveLabelRotation, side);
                updateTickMark(tick, length,
                        tick.getPosition(), height,
                        tick.getPosition(), height - tickMarkLength);
            }
        } else {
            // BOTTOM
            // offset path to make strokes snap to pixel
            tickMarkPath.setLayoutX(0.5);
            tickMarkPath.setLayoutY(0.5);
            if (getLabel() != null) {
                axisLabel.getTransforms().clear();
                final double labelHeight = Math.ceil(axisLabel.prefHeight(width));
                axisLabel.setLayoutX(0);
                axisLabel.setLayoutY(height - labelHeight);
                axisLabel.resize(width, labelHeight);
            }
            for (TickMark&lt;T&gt; tick : tickMarks) {
                positionTextNode(tick.textNode, tick.getPosition(), tickMarkLength + getTickLabelGap(),
                        effectiveLabelRotation, side);
                updateTickMark(tick, length,
                        tick.getPosition(), 0,
                        tick.getPosition(), tickMarkLength);
            }
        }
    }

    /**
     * Checks if two consecutive tick mark labels overlaps.
     * @param side side of the Axis
     * @param m1 first tick mark
     * @param m2 second tick mark
     * @param gap minimum space between labels
     * @return true if labels overlap
     */
    private boolean isTickLabelsOverlap(Side side, TickMark&lt;T&gt; m1, TickMark&lt;T&gt; m2, double gap) {
        if (!m1.isTextVisible() || !m2.isTextVisible()) return false;
        double m1Size = measureTickMarkSize(m1.getValue(), side);
        double m2Size = measureTickMarkSize(m2.getValue(), side);
        double m1Start = m1.getPosition() - m1Size / 2;
        double m1End = m1.getPosition() + m1Size / 2;
        double m2Start = m2.getPosition() - m2Size / 2;
        double m2End = m2.getPosition() + m2Size / 2;
        return side.isVertical() ? (m1Start - m2End) &lt;= gap : (m2Start - m1End) &lt;= gap;
    }

    /**
     * Positions a text node to one side of the given point, it X height is vertically centered on point if LEFT or
     * RIGHT and its centered horizontally if TOP ot BOTTOM.
     *
     * @param node The text node to position
     * @param posX The x position, to place text next to
     * @param posY The y position, to place text next to
     * @param angle The text rotation
     * @param side The side to place text next to position x,y at
     */
    private void positionTextNode(Text node, double posX, double posY, double angle, Side side) {
<A NAME="13"></A>        node.setLayoutX(0);
        node.setLayoutY(0);
        node.setRotate(angle);
        final Bounds bounds = <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#13',2,'match31-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>node.getBoundsInParent();
        if (Side.LEFT.equals(side)) {
            node.setLayoutX(posX-bounds.getWidth()-bounds.getMinX());
            node.setLayoutY(posY - (bounds.getHeight() / 2d) - bounds.getMinY());
        } else if (Side.RIGHT.equals(side)) {
            node.setLayoutX(posX-bounds.getMinX</B></FONT>());
            node.setLayoutY(posY-(bounds.getHeight()/2d)-bounds.getMinY());
        } else if (Side.TOP.equals(side)) {
            node.setLayoutX(posX-(bounds.getWidth()/2d)-bounds.getMinX());
            node.setLayoutY(posY-bounds.getHeight()-bounds.getMinY());
        } else {
            node.setLayoutX(posX-(bounds.getWidth()/2d)-bounds.getMinX());
            node.setLayoutY(posY-bounds.getMinY());
        }
    }

    /**
     * Updates visibility of the text node and adds the tick mark to the path
     */
    private void updateTickMark(TickMark&lt;T&gt; tick, double length,
            double startX, double startY, double endX, double endY)
    {
        // check if position is inside bounds
        if (tick.getPosition() &gt;= 0 &amp;&amp; tick.getPosition() &lt;= Math.ceil(length)) {
            tick.textNode.setVisible(tick.isTextVisible());
            // add tick mark line
            tickMarkPath.getElements().addAll(
                    new MoveTo(startX, startY),
                    new LineTo(endX, endY)
            );
        } else {
            tick.textNode.setVisible(false);
        }
    }
    /**
     * Get the string label name for a tick mark with the given value
     *
     * @param value The value to format into a tick label string
     * @return A formatted string for the given value
     */
    protected abstract String getTickMarkLabel(T value);

    /**
     * Measure the size of the label for given tick mark value. This uses the font that is set for the tick marks
     *
     *
     * @param labelText     tick mark label text
     * @param rotation  The text rotation
     * @return size of tick mark label for given value
     */
    protected final Dimension2D measureTickMarkLabelSize(String labelText, double rotation) {
        measure.setRotate(rotation);
        measure.setText(labelText);
        Bounds bounds = measure.getBoundsInParent();
        return new Dimension2D(bounds.getWidth(), bounds.getHeight());
    }

    /**
     * Measure the size of the label for given tick mark value. This uses the font that is set for the tick marks
     *
     * @param value     tick mark value
     * @param rotation  The text rotation
     * @return size of tick mark label for given value
     */
    protected final Dimension2D measureTickMarkSize(T value, double rotation) {
        return measureTickMarkLabelSize(getTickMarkLabel(value), rotation);
    }

    /**
     * Measure the size of the label for given tick mark value. This uses the font that is set for the tick marks
     *
     * @param value tick mark value
     * @param range range to use during calculations
     * @return size of tick mark label for given value
     */
    protected Dimension2D measureTickMarkSize(T value, Object range) {
        return measureTickMarkSize(value, getEffectiveTickLabelRotation());
    }

    /**
     * Measure the size of the label for given tick mark value. This uses the font that is set for the tick marks
     *
     * @param value tick mark value
     * @param side side of this Axis
     * @return size of tick mark label for given value
     * @see #measureTickMarkSize(Object, Object)
     */
    private double measureTickMarkSize(T value, Side side) {
        Dimension2D size = measureTickMarkSize(value, getEffectiveTickLabelRotation());
        return side.isVertical() ? size.getHeight() : size.getWidth();
    }

    final double getEffectiveTickLabelRotation() {
        return !isAutoRanging() || Double.isNaN(effectiveTickLabelRotation) ? getTickLabelRotation() : effectiveTickLabelRotation;
    }

    /**
     *
     * @param rotation NaN for using the tickLabelRotationProperty()
     */
    final void setEffectiveTickLabelRotation(double rotation) {
        effectiveTickLabelRotation = rotation;
    }

    // -------------- TICKMARK INNER CLASS -----------------------------------------------------------------------------

    /**
     * TickMark represents the label text, its associated properties for each tick
     * along the Axis.
     * @since JavaFX 2.0
     */
    public static final class TickMark&lt;T&gt; {
        /**
         * The display text for tick mark
         */
        private StringProperty label = new StringPropertyBase() {
            @Override protected void invalidated() {
                textNode.setText(getValue());
            }

            @Override
            public Object getBean() {
                return TickMark.this;
            }

            @Override
            public String getName() {
                return &quot;label&quot;;
            }
        };
        public final String getLabel() { return label.get(); }
        public final void setLabel(String value) { label.set(value); }
        public final StringExpression labelProperty() { return label; }

        /**
         * The value for this tick mark in data units
         */
        private ObjectProperty&lt;T&gt; value = new SimpleObjectProperty&lt;T&gt;(this, &quot;value&quot;);
        public final T getValue() { return value.get(); }
        public final void setValue(T v) { value.set(v); }
        public final ObjectExpression&lt;T&gt; valueProperty() { return value; }

        /**
         * The display position along the axis from axis origin in display units
         */
        private DoubleProperty position = new SimpleDoubleProperty(this, &quot;position&quot;);
        public final double getPosition() { return position.get(); }
        public final void setPosition(double value) { position.set(value); }
        public final DoubleExpression positionProperty() { return position; }

        Text textNode = new Text();

        /** true if tick mark labels should be displayed */
        private BooleanProperty textVisible = new BooleanPropertyBase(true) {
            @Override protected void invalidated() {
                if(!get()) {
                    textNode.setVisible(false);
                }
            }

            @Override
            public Object getBean() {
                return TickMark.this;
            }

            @Override
            public String getName() {
                return &quot;textVisible&quot;;
            }
        };

        /**
         * Indicates whether this tick mark label text is displayed or not.
         * @return true if tick mark label text is visible and false otherwise
         */
        public final boolean isTextVisible() { return textVisible.get(); }

        /**
         * Specifies whether this tick mark label text is displayed or not.
         * @param value true if tick mark label text is visible and false otherwise
         */
        public final void setTextVisible(boolean value) { textVisible.set(value); }

        /**
         * Creates and initializes an instance of TickMark.
         */
        public TickMark() {
        }

        /**
         * Returns a string representation of this {@code TickMark} object.
         * @return a string representation of this {@code TickMark} object.
         */
        @Override public String toString() {
            return value.get().toString();
        }
    }

    // -------------- STYLESHEET HANDLING ------------------------------------------------------------------------------

    private static class StyleableProperties {
        private static final CssMetaData&lt;Axis&lt;?&gt;,Side&gt; SIDE =
            new CssMetaData&lt;Axis&lt;?&gt;,Side&gt;(&quot;-fx-side&quot;,
                new EnumConverter&lt;Side&gt;(Side.class)) {

            @Override
            public boolean isSettable(Axis&lt;?&gt; n) {
                return n.side == null || !n.side.isBound();
            }

            @SuppressWarnings(&quot;unchecked&quot;) // sideProperty() is StyleableProperty&lt;Side&gt;
            @Override
            public StyleableProperty&lt;Side&gt; getStyleableProperty(Axis&lt;?&gt; n) {
                return (StyleableProperty&lt;Side&gt;)n.sideProperty();
            }
        };

        private static final CssMetaData&lt;Axis&lt;?&gt;,Number&gt; TICK_LENGTH =
            new CssMetaData&lt;Axis&lt;?&gt;,Number&gt;(&quot;-fx-tick-length&quot;,
                SizeConverter.getInstance(), 8.0) {

            @Override
            public boolean isSettable(Axis&lt;?&gt; n) {
                return n.tickLength == null || !n.tickLength.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(Axis&lt;?&gt; n) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.tickLengthProperty();
            }
        };

        private static final CssMetaData&lt;Axis&lt;?&gt;,Font&gt; TICK_LABEL_FONT =
            new FontCssMetaData&lt;Axis&lt;?&gt;&gt;(&quot;-fx-tick-label-font&quot;,
                Font.font(&quot;system&quot;, 8.0)) {

            @Override
            public boolean isSettable(Axis&lt;?&gt; n) {
                return n.tickLabelFont == null || !n.tickLabelFont.isBound();
            }

            @SuppressWarnings(&quot;unchecked&quot;) // tickLabelFontProperty() is StyleableProperty&lt;Font&gt;
            @Override
            public StyleableProperty&lt;Font&gt; getStyleableProperty(Axis&lt;?&gt; n) {
                return (StyleableProperty&lt;Font&gt;)n.tickLabelFontProperty();
            }
        };

        private static final CssMetaData&lt;Axis&lt;?&gt;,Paint&gt; TICK_LABEL_FILL =
            new CssMetaData&lt;Axis&lt;?&gt;,Paint&gt;(&quot;-fx-tick-label-fill&quot;,
                PaintConverter.getInstance(), Color.BLACK) {

            @Override
            public boolean isSettable(Axis&lt;?&gt; n) {
                return n.tickLabelFill == null | !n.tickLabelFill.isBound();
            }

            @SuppressWarnings(&quot;unchecked&quot;) // tickLabelFillProperty() is StyleableProperty&lt;Paint&gt;
            @Override
            public StyleableProperty&lt;Paint&gt; getStyleableProperty(Axis&lt;?&gt; n) {
                return (StyleableProperty&lt;Paint&gt;)n.tickLabelFillProperty();
            }
        };

        private static final CssMetaData&lt;Axis&lt;?&gt;,Number&gt; TICK_LABEL_TICK_GAP =
            new CssMetaData&lt;Axis&lt;?&gt;,Number&gt;(&quot;-fx-tick-label-gap&quot;,
                SizeConverter.getInstance(), 3.0) {

            @Override
            public boolean isSettable(Axis&lt;?&gt; n) {
                return n.tickLabelGap == null || !n.tickLabelGap.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(Axis&lt;?&gt; n) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.tickLabelGapProperty();
            }
        };

        private static final CssMetaData&lt;Axis&lt;?&gt;,Boolean&gt; TICK_MARK_VISIBLE =
            new CssMetaData&lt;Axis&lt;?&gt;,Boolean&gt;(&quot;-fx-tick-mark-visible&quot;,
                BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(Axis&lt;?&gt; n) {
                return n.tickMarkVisible == null || !n.tickMarkVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Axis&lt;?&gt; n) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)n.tickMarkVisibleProperty();
            }
        };

        private static final CssMetaData&lt;Axis&lt;?&gt;,Boolean&gt; TICK_LABELS_VISIBLE =
            new CssMetaData&lt;Axis&lt;?&gt;,Boolean&gt;(&quot;-fx-tick-labels-visible&quot;,
                BooleanConverter.getInstance(), Boolean.TRUE) {

            @Override
            public boolean isSettable(Axis&lt;?&gt; n) {
                return n.tickLabelsVisible == null || !n.tickLabelsVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Axis&lt;?&gt; n) {
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)n.tickLabelsVisibleProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
        final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
            new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());
            styleables.add(SIDE);
            styleables.add(TICK_LENGTH);
            styleables.add(TICK_LABEL_FONT);
            styleables.add(TICK_LABEL_FILL);
            styleables.add(TICK_LABEL_TICK_GAP);
            styleables.add(TICK_MARK_VISIBLE);
            styleables.add(TICK_LABELS_VISIBLE);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    /** pseudo-class indicating this is a vertical Top side Axis. */
    private static final PseudoClass TOP_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;top&quot;);
    /** pseudo-class indicating this is a vertical Bottom side Axis. */
    private static final PseudoClass BOTTOM_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;bottom&quot;);
    /** pseudo-class indicating this is a vertical Left side Axis. */
    private static final PseudoClass LEFT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;left&quot;);
    /** pseudo-class indicating this is a vertical Right side Axis. */
    private static final PseudoClass RIGHT_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;right&quot;);

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/BarChart.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;

import java.util.*;

import javafx.scene.AccessibleRole;
import javafx.animation.Animation;
import javafx.animation.FadeTransition;
import javafx.animation.Interpolator;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.ParallelTransition;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.NamedArg;
import javafx.beans.property.DoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.Orientation;
import javafx.scene.Node;
import javafx.scene.layout.StackPane;
import javafx.util.Duration;

import com.sun.javafx.charts.Legend.LegendItem;

import javafx.css.StyleableDoubleProperty;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;

import javafx.css.converter.SizeConverter;
import javafx.collections.ListChangeListener;

import javafx.css.Styleable;
import javafx.css.StyleableProperty;

/**
 * A chart that plots bars indicating data values for a category. The bars can be vertical or horizontal depending on
 * which axis is a category axis.
 * @since JavaFX 2.0
 */
public class BarChart&lt;X,Y&gt; extends XYChart&lt;X,Y&gt; {

    // -------------- PRIVATE FIELDS -------------------------------------------

    private Map&lt;Series&lt;X,Y&gt;, Map&lt;String, Data&lt;X,Y&gt;&gt;&gt; seriesCategoryMap = new HashMap&lt;&gt;();
    private final Orientation orientation;
    private CategoryAxis categoryAxis;
    private ValueAxis valueAxis;
    private Timeline dataRemoveTimeline;
    private double bottomPos  = 0;
    private static String NEGATIVE_STYLE = &quot;negative&quot;;
    private ParallelTransition pt;
    // For storing data values in case removed and added immediately.
    private Map&lt;Data&lt;X,Y&gt;, Double&gt; XYValueMap =
                                new HashMap&lt;Data&lt;X,Y&gt;, Double&gt;();
    // -------------- PUBLIC PROPERTIES ----------------------------------------

    /** The gap to leave between bars in the same category */
    private DoubleProperty barGap = new StyleableDoubleProperty(4) {
        @Override protected void invalidated() {
            get();
            requestChartLayout();
        }

        public Object getBean() {
            return BarChart.this;
        }

        public String getName() {
            return &quot;barGap&quot;;
        }

        public CssMetaData&lt;BarChart&lt;?,?&gt;,Number&gt; getCssMetaData() {
            return StyleableProperties.BAR_GAP;
        }
    };
    public final double getBarGap() { return barGap.getValue(); }
    public final void setBarGap(double value) { barGap.setValue(value); }
    public final DoubleProperty barGapProperty() { return barGap; }

    /** The gap to leave between bars in separate categories */
    private DoubleProperty categoryGap = new StyleableDoubleProperty(10) {
        @Override protected void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return BarChart.this;
        }

        @Override
        public String getName() {
            return &quot;categoryGap&quot;;
        }

        public CssMetaData&lt;BarChart&lt;?,?&gt;,Number&gt; getCssMetaData() {
            return StyleableProperties.CATEGORY_GAP;
        }
    };
    public final double getCategoryGap() { return categoryGap.getValue(); }
    public final void setCategoryGap(double value) { categoryGap.setValue(value); }
    public final DoubleProperty categoryGapProperty() { return categoryGap; }

    // -------------- CONSTRUCTOR ----------------------------------------------

    /**
     * Construct a new BarChart with the given axis. The two axis should be a ValueAxis/NumberAxis and a CategoryAxis,
     * they can be in either order depending on if you want a horizontal or vertical bar chart.
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     */
    public BarChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis) {
        this(xAxis, yAxis, FXCollections.&lt;Series&lt;X, Y&gt;&gt;observableArrayList());
    }

    /**
     * Construct a new BarChart with the given axis and data. The two axis should be a ValueAxis/NumberAxis and a
     * CategoryAxis, they can be in either order depending on if you want a horizontal or vertical bar chart.
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart
     */
    public BarChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis, @NamedArg(&quot;data&quot;) ObservableList&lt;Series&lt;X,Y&gt;&gt; data) {
        super(xAxis, yAxis);
        getStyleClass().add(&quot;bar-chart&quot;);
        if (!((xAxis instanceof ValueAxis &amp;&amp; yAxis instanceof CategoryAxis) ||
             (yAxis instanceof ValueAxis &amp;&amp; xAxis instanceof CategoryAxis))) {
            throw new IllegalArgumentException(&quot;Axis type incorrect, one of X,Y should be CategoryAxis and the other NumberAxis&quot;);
        }
        if (xAxis instanceof CategoryAxis) {
            categoryAxis = (CategoryAxis)xAxis;
            valueAxis = (ValueAxis)yAxis;
            orientation = Orientation.VERTICAL;
        } else {
            categoryAxis = (CategoryAxis)yAxis;
            valueAxis = (ValueAxis)xAxis;
            orientation = Orientation.HORIZONTAL;
        }
        // update css
        pseudoClassStateChanged(HORIZONTAL_PSEUDOCLASS_STATE, orientation == Orientation.HORIZONTAL);
        pseudoClassStateChanged(VERTICAL_PSEUDOCLASS_STATE, orientation == Orientation.VERTICAL);
        setData(data);
    }

    /**
     * Construct a new BarChart with the given axis and data. The two axis should be a ValueAxis/NumberAxis and a
     * CategoryAxis, they can be in either order depending on if you want a horizontal or vertical bar chart.
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart
     * @param categoryGap The gap to leave between bars in separate categories
     */
     public BarChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis, @NamedArg(&quot;data&quot;) ObservableList&lt;Series&lt;X,Y&gt;&gt; data, @NamedArg(&quot;categoryGap&quot;) double categoryGap) {
        this(xAxis, yAxis);
        setData(data);
        setCategoryGap(categoryGap);
    }

    // -------------- PROTECTED METHODS ----------------------------------------

    @Override protected void dataItemAdded(Series&lt;X,Y&gt; series, int itemIndex, Data&lt;X,Y&gt; item) {
        String category;
        if (orientation == Orientation.VERTICAL) {
            category = (String)item.getXValue();
        } else {
            category = (String)item.getYValue();
        }
         Map&lt;String, Data&lt;X,Y&gt;&gt; categoryMap = seriesCategoryMap.get(series);

        if (categoryMap == null) {
            categoryMap = new HashMap&lt;String, Data&lt;X,Y&gt;&gt;();
            seriesCategoryMap.put(series, categoryMap);
        }
        // check if category is already present
        if (!categoryAxis.getCategories().contains(category)) {
            // note: cat axis categories can be updated only when autoranging is true.
            categoryAxis.getCategories().add(itemIndex, category);
        } else if (categoryMap.containsKey(category)){
            // RT-21162 : replacing the previous data, first remove the node from scenegraph.
            Data&lt;X,Y&gt; data = categoryMap.get(category);
            getPlotChildren().remove(data.getNode());
            removeDataItemFromDisplay(series, data);
            requestChartLayout();
            categoryMap.remove(category);
        }
        categoryMap.put(category, item);
        Node bar = createBar(series, getData().indexOf(series), item, itemIndex);
        if (shouldAnimate()) {
            animateDataAdd(item, bar);
        } else {
            getPlotChildren().add(bar);
        }
    }

    @Override protected void dataItemRemoved(final Data&lt;X,Y&gt; item, final Series&lt;X,Y&gt; series) {
        final Node bar = item.getNode();

        if (bar != null) {
            bar.focusTraversableProperty().unbind();
        }
<A NAME="16"></A>
        if (shouldAnimate()) {
            XYValueMap.clear();
            dataRemoveTimeline = <FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#16',2,'match31-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>createDataRemoveTimeline(item, bar, series);
            dataRemoveTimeline.setOnFinished(event -&gt; {
                item.setSeries(null);
                removeDataItemFromDisplay(series, item);
            });
            dataRemoveTimeline.play();
        }</B></FONT> else {
            processDataRemove(series, item);
            removeDataItemFromDisplay(series, item);
        }
    }

    /** {@inheritDoc} */
    @Override protected void dataItemChanged(Data&lt;X, Y&gt; item) {
        double barVal;
        double currentVal;
        if (orientation == Orientation.VERTICAL) {
            barVal = ((Number)item.getYValue()).doubleValue();
            currentVal = ((Number)item.getCurrentY()).doubleValue();
        } else {
            barVal = ((Number)item.getXValue()).doubleValue();
            currentVal = ((Number)item.getCurrentX()).doubleValue();
        }
        if (currentVal &gt; 0 &amp;&amp; barVal &lt; 0) { // going from positive to negative
            // add style class negative
            item.getNode().getStyleClass().add(NEGATIVE_STYLE);
        } else if (currentVal &lt; 0 &amp;&amp; barVal &gt; 0) { // going from negative to positive
            // remove style class negative
            // RT-21164 upside down bars: was adding NEGATIVE_STYLE styleclass
            // instead of removing it; when going from negative to positive
            item.getNode().getStyleClass().remove(NEGATIVE_STYLE);
        }
    }

    @Override protected void seriesChanged(ListChangeListener.Change&lt;? extends Series&gt; c) {
        // Update style classes for all series lines and symbols
        // Note: is there a more efficient way of doing this?
        for (int i = 0; i &lt; getDataSize(); i++) {
            final Series&lt;X,Y&gt; series = getData().get(i);
            for (int j=0; j&lt;series.getData().size(); j++) {
                Data&lt;X,Y&gt; item = series.getData().get(j);
                Node bar = item.getNode();
                bar.getStyleClass().setAll(&quot;chart-bar&quot;, &quot;series&quot; + i, &quot;data&quot; + j, series.defaultColorStyleClass);
            }
        }
    }

    @Override protected void seriesAdded(Series&lt;X,Y&gt; series, int seriesIndex) {
        // handle any data already in series
        // create entry in the map
        Map&lt;String, Data&lt;X,Y&gt;&gt; categoryMap = new HashMap&lt;String, Data&lt;X,Y&gt;&gt;();
        for (int j=0; j&lt;series.getData().size(); j++) {
            Data&lt;X,Y&gt; item = series.getData().get(j);
            Node bar = createBar(series, seriesIndex, item, j);
            String category;
            if (orientation == Orientation.VERTICAL) {
                category = (String)item.getXValue();
            } else {
                category = (String)item.getYValue();
            }
            categoryMap.put(category, item);
            if (shouldAnimate()) {
                animateDataAdd(item, bar);
            } else {
                // RT-21164 check if bar value is negative to add NEGATIVE_STYLE style class
                double barVal = (orientation == Orientation.VERTICAL) ? ((Number)item.getYValue()).doubleValue() :
                        ((Number)item.getXValue()).doubleValue();
                if (barVal &lt; 0) {
                    bar.getStyleClass().add(NEGATIVE_STYLE);
                }
                getPlotChildren().add(bar);
            }
        }
        if (categoryMap.size() &gt; 0) seriesCategoryMap.put(series, categoryMap);
    }

    @Override protected void seriesRemoved(final Series&lt;X,Y&gt; series) {
        // remove all symbol nodes
        if (shouldAnimate()) {
            pt = new ParallelTransition();
            pt.setOnFinished(event -&gt; {
                removeSeriesFromDisplay(series);
            });

            XYValueMap.clear();
            for (final Data&lt;X,Y&gt; d : series.getData()) {
                final Node bar = d.getNode();
                // Animate series deletion
                if (getSeriesSize() &gt; 1) {
                    Timeline t = createDataRemoveTimeline(d, bar, series);
                    pt.getChildren().add(t);
                } else {
                    // fade out last series
                    FadeTransition ft = new FadeTransition(Duration.millis(700),bar);
                    ft.setFromValue(1);
                    ft.setToValue(0);
                    ft.setOnFinished(actionEvent -&gt; {
                        processDataRemove(series, d);
                        bar.setOpacity(1.0);
                    });
                    pt.getChildren().add(ft);
                }
            }
            pt.play();
        } else {
            for (Data&lt;X,Y&gt; d : series.getData()) {
                processDataRemove(series, d);
            }
            removeSeriesFromDisplay(series);
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutPlotChildren() {
        double catSpace = categoryAxis.getCategorySpacing();
        // calculate bar spacing
        final double availableBarSpace = catSpace - (getCategoryGap() + getBarGap());
        double barWidth = (availableBarSpace / getSeriesSize()) - getBarGap();
        final double barOffset = -((catSpace - getCategoryGap()) / 2);
        final double zeroPos = (valueAxis.getLowerBound() &gt; 0) ?
                valueAxis.getDisplayPosition(valueAxis.getLowerBound()) : valueAxis.getZeroPosition();
        // RT-24813 : if the data in a series gets too large, barWidth can get negative.
        if (barWidth &lt;= 0) barWidth = 1;
        // update bar positions and sizes
        int catIndex = 0;
        for (String category : categoryAxis.getCategories()) {
            int index = 0;
            for (Iterator&lt;Series&lt;X, Y&gt;&gt; sit = getDisplayedSeriesIterator(); sit.hasNext(); ) {
                Series&lt;X, Y&gt; series = sit.next();
                final Data&lt;X,Y&gt; item = getDataItem(series, index, catIndex, category);
                if (item != null) {
                    final Node bar = item.getNode();
                    final double categoryPos;
                    final double valPos;
                    if (orientation == Orientation.VERTICAL) {
                        categoryPos = getXAxis().getDisplayPosition(item.getCurrentX());
                        valPos = getYAxis().getDisplayPosition(item.getCurrentY());
                    } else {
                        categoryPos = getYAxis().getDisplayPosition(item.getCurrentY());
                        valPos = getXAxis().getDisplayPosition(item.getCurrentX());
                    }
                    if (Double.isNaN(categoryPos) || Double.isNaN(valPos)) {
                        continue;
                    }
                    final double bottom = Math.min(valPos,zeroPos);
                    final double top = Math.max(valPos,zeroPos);
                    bottomPos = bottom;
                    if (orientation == Orientation.VERTICAL) {
                        bar.resizeRelocate( categoryPos + barOffset + (barWidth + getBarGap()) * index,
                                            bottom, barWidth, top-bottom);
                    } else {
                        //noinspection SuspiciousNameCombination
                        bar.resizeRelocate( bottom, categoryPos + barOffset + (barWidth + getBarGap()) * index,
                                            top-bottom, barWidth);
                    }

                    index++;
                }
            }
            catIndex++;
        }
    }

    @Override
    LegendItem createLegendItemForSeries(Series&lt;X, Y&gt; series, int seriesIndex) {
        LegendItem legendItem = new LegendItem(series.getName());
        legendItem.getSymbol().getStyleClass().addAll(&quot;chart-bar&quot;, &quot;series&quot; + seriesIndex,
                &quot;bar-legend-symbol&quot;, series.defaultColorStyleClass);
        return legendItem;
    }

    // -------------- PRIVATE METHODS ------------------------------------------

    private void updateMap(Series&lt;X,Y&gt; series, Data&lt;X,Y&gt; item) {
        final String category = (orientation == Orientation.VERTICAL) ? (String)item.getXValue() :
                                     (String)item.getYValue();
        Map&lt;String, Data&lt;X,Y&gt;&gt; categoryMap = seriesCategoryMap.get(series);
        if (categoryMap != null) {
            categoryMap.remove(category);
            if (categoryMap.isEmpty()) seriesCategoryMap.remove(series);
        }
        if (seriesCategoryMap.isEmpty() &amp;&amp; categoryAxis.isAutoRanging()) categoryAxis.getCategories().clear();
    }

    private void processDataRemove(final Series&lt;X,Y&gt; series, final Data&lt;X,Y&gt; item) {
        Node bar = item.getNode();
        getPlotChildren().remove(bar);
        updateMap(series, item);
    }

    private void animateDataAdd(Data&lt;X,Y&gt; item, Node bar) {
        double barVal;
        if (orientation == Orientation.VERTICAL) {
            barVal = ((Number)item.getYValue()).doubleValue();
            if (barVal &lt; 0) {
                bar.getStyleClass().add(NEGATIVE_STYLE);
            }
            item.setCurrentY(getYAxis().toRealValue((barVal &lt; 0) ? -bottomPos : bottomPos));
            getPlotChildren().add(bar);
            item.setYValue(getYAxis().toRealValue(barVal));
            animate(
                    new KeyFrame(Duration.ZERO, new KeyValue(
                            item.currentYProperty(),
                            item.getCurrentY())),
                    new KeyFrame(Duration.millis(700), new KeyValue(
                            item.currentYProperty(),
                            item.getYValue(), Interpolator.EASE_BOTH))
            );
        } else {
            barVal = ((Number)item.getXValue()).doubleValue();
            if (barVal &lt; 0) {
                bar.getStyleClass().add(NEGATIVE_STYLE);
            }
            item.setCurrentX(getXAxis().toRealValue((barVal &lt; 0) ? -bottomPos : bottomPos));
            getPlotChildren().add(bar);
            item.setXValue(getXAxis().toRealValue(barVal));
            animate(
                    new KeyFrame(Duration.ZERO, new KeyValue(
                            item.currentXProperty(),
                            item.getCurrentX())),
                    new KeyFrame(Duration.millis(700), new KeyValue(
                            item.currentXProperty(),
                            item.getXValue(), Interpolator.EASE_BOTH))
            );
        }
    }

    private Timeline createDataRemoveTimeline(final Data&lt;X,Y&gt; item, final Node bar, final Series&lt;X,Y&gt; series) {
        Timeline t = new Timeline();
        if (orientation == Orientation.VERTICAL) {
//            item.setYValue(getYAxis().toRealValue(getYAxis().getZeroPosition()));

            // save data values in case the same data item gets added immediately.
            XYValueMap.put(item, ((Number)item.getYValue()).doubleValue());
            item.setYValue(getYAxis().toRealValue(bottomPos));
            t.getKeyFrames().addAll(
                    new KeyFrame(Duration.ZERO, new KeyValue(
                            item.currentYProperty(), item.getCurrentY())),
                    new KeyFrame(Duration.millis(700), actionEvent -&gt; {
                        processDataRemove(series, item);
                        XYValueMap.clear();
                    }, new KeyValue(
                            item.currentYProperty(),
                            item.getYValue(), Interpolator.EASE_BOTH))
            );
        } else {
            // save data values in case the same data item gets added immediately.
             XYValueMap.put(item, ((Number)item.getXValue()).doubleValue());
            item.setXValue(getXAxis().toRealValue(getXAxis().getZeroPosition()));
            t.getKeyFrames().addAll(
                    new KeyFrame(Duration.ZERO, new KeyValue(
                            item.currentXProperty(), item.getCurrentX())),
                    new KeyFrame(Duration.millis(700), actionEvent -&gt; {
                        processDataRemove(series, item);
                        XYValueMap.clear();
                    }, new KeyValue(
                            item.currentXProperty(),
                            item.getXValue(), Interpolator.EASE_BOTH))
            );
        }
        return t;
    }

    @Override void dataBeingRemovedIsAdded(Data&lt;X,Y&gt; item, Series&lt;X,Y&gt; series) {
        if (dataRemoveTimeline != null) {
            dataRemoveTimeline.setOnFinished(null);
            dataRemoveTimeline.stop();
        }
        processDataRemove(series, item);
        item.setSeries(null);
        removeDataItemFromDisplay(series, item);
        restoreDataValues(item);
        XYValueMap.clear();
    }

    private void restoreDataValues(Data item) {
        Double value = XYValueMap.get(item);
        if (value != null) {
            // Restoring original X/Y values
            if (orientation.equals(Orientation.VERTICAL)) {
                item.setYValue(value);
                item.setCurrentY(value);
            } else {
                item.setXValue(value);
                item.setCurrentX(value);

            }
        }
    }
    @Override void seriesBeingRemovedIsAdded(Series&lt;X,Y&gt; series) {
        boolean lastSeries = (pt.getChildren().size() == 1) ? true : false;
        if (pt!= null) {
            if (!pt.getChildren().isEmpty()) {
                for (Animation a : pt.getChildren()) {
                    a.setOnFinished(null);
                }
            }
            for (Data&lt;X,Y&gt; item : series.getData()) {
                processDataRemove(series, item);
                if (!lastSeries) {
                    restoreDataValues(item);
                }
            }
            XYValueMap.clear();
            pt.setOnFinished(null);
            pt.getChildren().clear();
            pt.stop();
            removeSeriesFromDisplay(series);
        }
    }

    private Node createBar(Series&lt;X,Y&gt; series, int seriesIndex, final Data&lt;X,Y&gt; item, int itemIndex) {
        Node bar = item.getNode();
        if (bar == null) {
            bar = new StackPane();
            bar.setAccessibleRole(AccessibleRole.TEXT);
            bar.setAccessibleRoleDescription(&quot;Bar&quot;);
            bar.focusTraversableProperty().bind(Platform.accessibilityActiveProperty());
            item.setNode(bar);
        }
        bar.getStyleClass().setAll(&quot;chart-bar&quot;, &quot;series&quot; + seriesIndex, &quot;data&quot; + itemIndex, series.defaultColorStyleClass);
        return bar;
    }

    private Data&lt;X,Y&gt; getDataItem(Series&lt;X,Y&gt; series, int seriesIndex, int itemIndex, String category) {
        Map&lt;String, Data&lt;X,Y&gt;&gt; catmap = seriesCategoryMap.get(series);
        return (catmap != null) ? catmap.get(category) : null;
    }

    // -------------- STYLESHEET HANDLING ------------------------------------------------------------------------------

    /*
     * Super-lazy instantiation pattern from Bill Pugh.
     */
    private static class StyleableProperties {
        private static final CssMetaData&lt;BarChart&lt;?,?&gt;,Number&gt; BAR_GAP =
            new CssMetaData&lt;BarChart&lt;?,?&gt;,Number&gt;(&quot;-fx-bar-gap&quot;,
                SizeConverter.getInstance(), 4.0) {

            @Override
            public boolean isSettable(BarChart&lt;?,?&gt; node) {
                return node.barGap == null || !node.barGap.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(BarChart&lt;?,?&gt; node) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)node.barGapProperty();
            }
        };

        private static final CssMetaData&lt;BarChart&lt;?,?&gt;,Number&gt; CATEGORY_GAP =
            new CssMetaData&lt;BarChart&lt;?,?&gt;,Number&gt;(&quot;-fx-category-gap&quot;,
                SizeConverter.getInstance(), 10.0)  {

            @Override
            public boolean isSettable(BarChart&lt;?,?&gt; node) {
                return node.categoryGap == null || !node.categoryGap.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(BarChart&lt;?,?&gt; node) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)node.categoryGapProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                    new ArrayList&lt;&gt;(XYChart.getClassCssMetaData());
            styleables.add(BAR_GAP);
            styleables.add(CATEGORY_GAP);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    /** Pseudoclass indicating this is a vertical chart. */
    private static final PseudoClass VERTICAL_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;vertical&quot;);

    /** Pseudoclass indicating this is a horizontal chart. */
    private static final PseudoClass HORIZONTAL_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;horizontal&quot;);

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/Dialog.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javafx.scene.control;

import java.lang.ref.WeakReference;
import java.util.Optional;

import javafx.beans.InvalidationListener;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyDoubleProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.StringProperty;
import javafx.collections.ListChangeListener;
import javafx.css.PseudoClass;
import javafx.event.Event;
import javafx.event.EventDispatchChain;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.scene.Node;
import javafx.scene.control.ButtonBar.ButtonData;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;
import javafx.util.Callback;

import com.sun.javafx.event.EventHandlerManager;
import com.sun.javafx.tk.Toolkit;

/**
 * A Dialog in JavaFX wraps a {@link DialogPane} and provides the necessary API
 * to present it to end users. In JavaFX 8u40, this essentially means that the
 * {@link DialogPane} is shown to users inside a {@link Stage}, but future releases
 * may offer alternative options (such as 'lightweight' or 'internal' dialogs).
 * This API therefore is intentionally ignorant of the underlying implementation,
 * and attempts to present a common API for all possible implementations.
 *
 * &lt;p&gt;The Dialog class has a single generic type, R, which is used to represent
 * the type of the {@link #resultProperty() result} property (and also, how to
 * convert from {@link ButtonType} to R, through the use of the
 * {@link #resultConverterProperty() result converter} {@link Callback}).
 *
 * &lt;p&gt;&lt;strong&gt;Critical note:&lt;/strong&gt; It is critical that all developers who choose
 * to create their own dialogs by extending the Dialog class understand the
 * importance of the {@link #resultConverterProperty() result converter} property.
 * A result converter must always be set, whenever the R type is not
 * {@link Void} or {@link ButtonType}. If this is not heeded, developers will find
 * that they get ClassCastExceptions in their code, for failure to convert from
 * {@link ButtonType} via the {@link #resultConverterProperty() result converter}.
 *
 * &lt;p&gt;It is likely that most developers would be better served using either the
 * {@link Alert} class (for pre-defined, notification-style alerts), or either of
 * the two pre-built dialogs ({@link TextInputDialog} and {@link ChoiceDialog}),
 * depending on their needs.
 *
 * &lt;p&gt;Once a Dialog is instantiated, the next step is to configure it. Almost
 * all properties on Dialog are not related to the content of the Dialog, the
 * only exceptions are {@link #contentTextProperty()},
 * {@link #headerTextProperty()}, and {@link #graphicProperty()}, and these
 * properties are simply forwarding API onto the respective properties on the
 * {@link DialogPane} stored in the {@link #dialogPaneProperty() dialog pane}
 * property. These three properties are forwarded from DialogPane for developer
 * convenience. For developers wanting to configure their dialog, they will in many
 * cases be required to use code along the lines of
 * {@code dialog.getDialogPane().setExpandableContent(node)}.
 *
 * &lt;p&gt;After configuring these properties, all that remains is to consider whether
 * the buttons (created using {@link ButtonType} and the
 * {@link DialogPane#createButton(ButtonType)} method) are fully configured.
 * Developers will quickly find that the amount of configurability offered
 * via the {@link ButtonType} class is minimal. This is intentional, but does not
 * mean that developers can not modify the buttons created by the {@link ButtonType}
 * that have been specified. To do this, developers simply call the
 * {@link DialogPane#lookupButton(ButtonType)} method with the ButtonType
 * (assuming it has already been set in the {@link DialogPane#getButtonTypes()}
 * list. The returned Node is typically of type {@link Button}, but this depends
 * on if the {@link DialogPane#createButton(ButtonType)} method has been overridden. A
 * typical approach is therefore along the following lines:
 *
 * &lt;pre&gt;{@code
 *     ButtonType loginButtonType = new ButtonType(&quot;Login&quot;, ButtonData.OK_DONE);
 *     Dialog&lt;String&gt; dialog = new Dialog&lt;&gt;();
 *     dialog.getDialogPane().getButtonTypes().add(loginButtonType);
 *     boolean disabled = false; // computed based on content of text fields, for example
 *     dialog.getDialogPane().lookupButton(loginButtonType).setDisable(disabled);}&lt;/pre&gt;
 *
 * &lt;p&gt;Once a Dialog is instantiated and fully configured, the next step is to
 * show it. More often than not, dialogs are shown in a modal and blocking
 * fashion. 'Modal' means that the dialog prevents user interaction with the
 * owning application whilst it is showing, and 'blocking' means that code
 * execution stops at the point in which the dialog is shown. This means that
 * you can show a dialog, await the user response, and then continue running the
 * code that directly follows the show call, giving developers the ability to
 * immediately deal with the user input from the dialog (if relevant).
 *
 * &lt;p&gt;JavaFX dialogs are modal by default (you can change this via the
 * {@link #initModality(javafx.stage.Modality)} API). To specify whether you want
 * blocking or non-blocking dialogs, developers simply choose to call
 * {@link #showAndWait()} or {@link #show()} (respectively). By default most
 * developers should choose to use {@link #showAndWait()}, given the ease of
 * coding in these situations. Shown below is three code snippets, showing three
 * equally valid ways of showing a dialog:
 *
 * &lt;p&gt;&lt;strong&gt;Option 1: The 'traditional' approach&lt;/strong&gt;
 * &lt;pre&gt;{@code
 * Optional&lt;ButtonType&gt; result = dialog.showAndWait();
 * if (result.isPresent() &amp;&amp; result.get() == ButtonType.OK) {
 *     formatSystem();
 * }}&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;strong&gt;Option 2: The traditional + Optional approach&lt;/strong&gt;
 * &lt;pre&gt;{@code
 * dialog.showAndWait().ifPresent(response -&gt; {
 *     if (response == ButtonType.OK) {
 *         formatSystem();
 *     }
 * });}&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;strong&gt;Option 3: The fully lambda approach&lt;/strong&gt;
 * &lt;pre&gt;{@code
 * dialog.showAndWait()
 *      .filter(response -&gt; response == ButtonType.OK)
 *      .ifPresent(response -&gt; formatSystem());}&lt;/pre&gt;
 *
 * &lt;p&gt;There is no better or worse option of the three listed above, so developers
 * are encouraged to work to their own style preferences. The purpose of showing
 * the above is to help introduce developers to the {@link Optional} API, which
 * is new in Java 8 and may be foreign to many developers.
 *
 * &lt;h3&gt;Dialog Validation / Intercepting Button Actions&lt;/h3&gt;
 *
 * &lt;p&gt;In some circumstances it is desirable to prevent a dialog from closing
 * until some aspect of the dialog becomes internally consistent (e.g. a form
 * inside the dialog has all fields in a valid state). To do this, users of the
 * dialogs API should become familiar with the
 * {@link DialogPane#lookupButton(ButtonType)} method. By passing in a
 * {@link javafx.scene.control.ButtonType ButtonType} (that has already been set
 * in the {@link DialogPane#getButtonTypes() button types} list), users will be
 * returned a Node that is typically of type {@link Button} (but this depends
 * on if the {@link DialogPane#createButton(ButtonType)} method has been
 * overridden). With this button, users may add an event filter that is called
 * before the button does its usual event handling, and as such users may
 * prevent the event handling by {@code consuming} the event. Here's a simplified
 * example:
 *
 * &lt;pre&gt;{@code final Button btOk = (Button) dlg.getDialogPane().lookupButton(ButtonType.OK);
 * btOk.addEventFilter(ActionEvent.ACTION, event -&gt; {
 *     if (!validateAndStore()) {
 *         event.consume();
 *     }
 * });}&lt;/pre&gt;
 *
 * &lt;h3&gt;Dialog Closing Rules&lt;/h3&gt;
 *
 * &lt;p&gt;It is important to understand what happens when a Dialog is closed, and
 * also how a Dialog can be closed, especially in abnormal closing situations
 * (such as when the 'X' button is clicked in a dialogs title bar, or when
 * operating system specific keyboard shortcuts (such as alt-F4 on Windows)
 * are entered). Fortunately, the outcome is well-defined in these situations,
 * and can be best summarised in the following bullet points:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;JavaFX dialogs can only be closed 'abnormally' (as defined above) in
 *   two situations:
 *     &lt;ol&gt;
 *       &lt;li&gt;When the dialog only has one button, or
 *       &lt;li&gt;When the dialog has multiple buttons, as long as one of them meets
 *       one of the following requirements:
 *       &lt;ol&gt;
 *           &lt;li&gt;The button has a {@link ButtonType} whose {@link ButtonData} is of type
 *           {@link ButtonData#CANCEL_CLOSE}.&lt;/li&gt;
 *           &lt;li&gt;The button has a {@link ButtonType} whose {@link ButtonData} returns true
 *           when {@link ButtonData#isCancelButton()} is called.&lt;/li&gt;
 *       &lt;/ol&gt;
 *     &lt;/ol&gt;
 *   &lt;li&gt;In all other situations, the dialog will refuse to respond to all
 *   close requests, remaining open until the user clicks on one of the available
 *   buttons in the {@link DialogPane} area of the dialog.
 *   &lt;li&gt;If a dialog is closed abnormally, and if the dialog contains a button
 *   which meets one of the two criteria above, the dialog will attempt to set
 *   the {@link #resultProperty() result} property to whatever value is returned
 *   from calling the {@link #resultConverterProperty() result converter} with
 *   the first matching {@link ButtonType}.
 *   &lt;li&gt;If for any reason the result converter returns null, or if the dialog
 *   is closed when only one non-cancel button is present, the
 *   {@link #resultProperty() result} property will be null, and the
 *   {@link #showAndWait()} method will return {@link Optional#empty()}. This
 *   later point means that, if you use either of option 2 or option 3 (as
 *   presented earlier in this class documentation), the
 *   {@link Optional#ifPresent(java.util.function.Consumer)} lambda will never
 *   be called, and code will continue executing as if the dialog had not
 *   returned any value at all.
 * &lt;/ul&gt;
 *
 * @param &lt;R&gt; The return type of the dialog, via the
 *            {@link #resultProperty() result} property.
 * @see Alert
 * @see TextInputDialog
 * @see ChoiceDialog
 * @since JavaFX 8u40
 */
public class Dialog&lt;R&gt; implements EventTarget {

    /**************************************************************************
     *
     * Static fields
     *
     **************************************************************************/




    /**************************************************************************
     *
     * Static methods
     *
     **************************************************************************/



    /**************************************************************************
     *
     * Private fields
     *
     **************************************************************************/

    final FXDialog dialog;

    private boolean isClosing;



    /**************************************************************************
     *
     * Constructors
     *
     **************************************************************************/

    /**
     * Creates a dialog without a specified owner.
     */
    public Dialog() {
        this.dialog = new HeavyweightDialog(this);
        setDialogPane(new DialogPane());
        initModality(Modality.APPLICATION_MODAL);
    }



    /**************************************************************************
     *
     * Abstract methods
     *
     **************************************************************************/




    /**************************************************************************
     *
     * Public API
     *
     **************************************************************************/

    /**
     * Shows the dialog but does not wait for a user response (in other words,
     * this brings up a non-blocking dialog). Users of this API must either
     * poll the {@link #resultProperty() result property}, or else add a listener
     * to the result property to be informed of when it is set.
     * @throws IllegalStateException if this method is called on a thread
     *     other than the JavaFX Application Thread.
     */
    public final void show() {
        Toolkit.getToolkit().checkFxUserThread();

        Event.fireEvent(this, new DialogEvent(this, DialogEvent.DIALOG_SHOWING));
        if (Double.isNaN(getWidth()) &amp;&amp; Double.isNaN(getHeight())) {
            dialog.sizeToScene();
        }

        dialog.show();

        Event.fireEvent(this, new DialogEvent(this, DialogEvent.DIALOG_SHOWN));
    }

    /**
     * Shows the dialog and waits for the user response (in other words, brings
     * up a blocking dialog, with the returned value the users input).
     * &lt;p&gt;
     * This method must be called on the JavaFX Application thread.
     * Additionally, it must either be called from an input event handler or
     * from the run method of a Runnable passed to
     * {@link javafx.application.Platform#runLater Platform.runLater}.
     * It must not be called during animation or layout processing.
     * &lt;/p&gt;
     *
     * @return An {@link Optional} that contains the {@link #resultProperty() result}.
     *         Refer to the {@link Dialog} class documentation for more detail.
     * @throws IllegalStateException if this method is called on a thread
     *     other than the JavaFX Application Thread.
     * @throws IllegalStateException if this method is called during
     *     animation or layout processing.
     */
    public final Optional&lt;R&gt; showAndWait() {
        Toolkit.getToolkit().checkFxUserThread();

        if (!Toolkit.getToolkit().canStartNestedEventLoop()) {
            throw new IllegalStateException(&quot;showAndWait is not allowed during animation or layout processing&quot;);
        }

        Event.fireEvent(this, new DialogEvent(this, DialogEvent.DIALOG_SHOWING));
        if (Double.isNaN(getWidth()) &amp;&amp; Double.isNaN(getHeight())) {
            dialog.sizeToScene();
        }


        // this is slightly odd - we fire the SHOWN event before the show()
        // call, so that users get the event before the dialog blocks
        Event.fireEvent(this, new DialogEvent(this, DialogEvent.DIALOG_SHOWN));

        dialog.showAndWait();

        return Optional.ofNullable(getResult());
    }

    /**
     * Closes this {@code Dialog}.
     * This call is equivalent to {@link #hide}.
     */
    public final void close() {
        if (isClosing) return;
        isClosing = true;

        final R result = getResult();

        // if the result is null and we do not have permission to close the
        // dialog, then we cancel the close request before any events are
        // even fired
        if (result == null &amp;&amp; ! dialog.requestPermissionToClose(this)) {
            isClosing = false;
            return;
        }

        // if we are here we have permission to close the dialog. However, we
        // may not have a result set to return to the user. Therefore, we need
        // to handle that before the dialog closes (especially in case the
        // dialog is blocking, in which case having a null result is really going
        // to mess up users).
        //
        // In cases where the result is null, and where the dialog has a cancel
        // button, we call into the result converter to see what to do. This is
        // used primarily to handle the requirement that the X button has the
        // same result as clicking the cancel button.
        //
        // A 'cancel button' can mean two different things (although they may
        // be the same thing):
        // 1) A button whose ButtonData is of type CANCEL_CLOSE.
        // 2) A button whose ButtonData returns true for isCancelButton().
        if (result == null) {
            ButtonType cancelButton = null;

            // we do two things here. We are primarily looking for a button with
            // ButtonData.CANCEL_CLOSE. If we find one, we use it as the result.
            // However, if we don't find one, we can also use any button that
            // is a cancel button.
            for (ButtonType button : getDialogPane().getButtonTypes()) {
                ButtonData buttonData = button.getButtonData();
                if (buttonData == null) continue;

                if (buttonData == ButtonData.CANCEL_CLOSE) {
                    cancelButton = button;
                    break;
                }
                if (buttonData.isCancelButton()) {
                    cancelButton = button;
                }
            }

            setResultAndClose(cancelButton, false);
        }

        // start normal closing process
        Event.fireEvent(this, new DialogEvent(this, DialogEvent.DIALOG_HIDING));

        DialogEvent closeRequestEvent = new DialogEvent(this, DialogEvent.DIALOG_CLOSE_REQUEST);
        Event.fireEvent(this, closeRequestEvent);
        if (closeRequestEvent.isConsumed()) {
            isClosing = false;
            return;
        }

        dialog.close();

        Event.fireEvent(this, new DialogEvent(this, DialogEvent.DIALOG_HIDDEN));

        isClosing = false;
    }

    /**
     * Hides this {@code Dialog}.
     */
    public final void hide() {
        close();
    }

    /**
     * Specifies the modality for this dialog. This must be done prior to making
     * the dialog visible. The modality is one of: Modality.NONE,
     * Modality.WINDOW_MODAL, or Modality.APPLICATION_MODAL.
     *
     * @param modality the modality for this dialog.
     *
     * @throws IllegalStateException if this property is set after the dialog
     * has ever been made visible.
     *
     * @defaultValue Modality.APPLICATION_MODAL
     */
    public final void initModality(Modality modality) {
        dialog.initModality(modality);
    }

    /**
     * Retrieves the modality attribute for this dialog.
     *
     * @return the modality.
     */
    public final Modality getModality() {
        return dialog.getModality();
    }

    /**
     * Specifies the style for this dialog. This must be done prior to making
     * the dialog visible. The style is one of: StageStyle.DECORATED,
     * StageStyle.UNDECORATED, StageStyle.TRANSPARENT, StageStyle.UTILITY,
     * or StageStyle.UNIFIED.
     *
     * @param style the style for this dialog.
     *
     * @throws IllegalStateException if this property is set after the dialog
     * has ever been made visible.
     *
     * @defaultValue StageStyle.DECORATED
     */
    public final void initStyle(StageStyle style) {
        dialog.initStyle(style);
    }

    /**
     * Specifies the owner {@link Window} for this dialog, or null for a top-level,
     * unowned dialog. This must be done prior to making the dialog visible.
     *
     * @param window the owner {@link Window} for this dialog.
     *
     * @throws IllegalStateException if this property is set after the dialog
     * has ever been made visible.
     *
     * @defaultValue null
     */
    public final void initOwner(Window window) {
        dialog.initOwner(window);
    }

    /**
     * Retrieves the owner Window for this dialog, or null for an unowned dialog.
     *
     * @return the owner Window.
     */
    public final Window getOwner() {
        return dialog.getOwner();
    }



    /**************************************************************************
     *
     * Properties
     *
     **************************************************************************/

    // --- dialog Pane
    /**
     * The root node of the dialog, the {@link DialogPane} contains all visual
     * elements shown in the dialog. As such, it is possible to completely adjust
     * the display of the dialog by modifying the existing dialog pane or creating
     * a new one.
     */
    private ObjectProperty&lt;DialogPane&gt; dialogPane = new SimpleObjectProperty&lt;DialogPane&gt;(this, &quot;dialogPane&quot;, new DialogPane()) {
        final InvalidationListener expandedListener = o -&gt; {
            DialogPane dialogPane = getDialogPane();
            if (dialogPane == null) return;

            final Node content = dialogPane.getExpandableContent();
            final boolean isExpanded = content == null ? false : content.isVisible();
            setResizable(isExpanded);

            Dialog.this.dialog.sizeToScene();
        };

        final InvalidationListener headerListener = o -&gt; {
            updatePseudoClassState();
        };

        WeakReference&lt;DialogPane&gt; dialogPaneRef = new WeakReference&lt;&gt;(null);

        @Override
        protected void invalidated() {
            DialogPane oldDialogPane = dialogPaneRef.get();
            if (oldDialogPane != null) {
                // clean up
                oldDialogPane.expandedProperty().removeListener(expandedListener);
                oldDialogPane.headerProperty().removeListener(headerListener);
                oldDialogPane.headerTextProperty().removeListener(headerListener);
                oldDialogPane.setDialog(null);
            }

            final DialogPane newDialogPane = getDialogPane();

            if (newDialogPane != null) {
                newDialogPane.setDialog(Dialog.this);

                // if the buttons change, we dynamically update the dialog
                newDialogPane.getButtonTypes().addListener((ListChangeListener&lt;ButtonType&gt;) c -&gt; {
                    newDialogPane.requestLayout();
                });
                newDialogPane.expandedProperty().addListener(expandedListener);
                newDialogPane.headerProperty().addListener(headerListener);
                newDialogPane.headerTextProperty().addListener(headerListener);

                updatePseudoClassState();
                newDialogPane.requestLayout();
            }

            // push the new dialog down into the implementation for rendering
            dialog.setDialogPane(newDialogPane);

            dialogPaneRef = new WeakReference&lt;DialogPane&gt;(newDialogPane);
        }
    };

    public final ObjectProperty&lt;DialogPane&gt; dialogPaneProperty() {
        return dialogPane;
    }

    public final DialogPane getDialogPane() {
        return dialogPane.get();
    }

    public final void setDialogPane(DialogPane value) {
        dialogPane.set(value);
    }


    // --- content text (forwarded from DialogPane)
    /**
     * A property representing the content text for the dialog pane. The content text
     * is lower precedence than the {@link DialogPane#contentProperty() content node}, meaning
     * that if both the content node and the contentText properties are set, the
     * content text will not be displayed in a default DialogPane instance.
     * @return the property representing the content text for the dialog pane
     */
    public final StringProperty contentTextProperty() {
        return getDialogPane().contentTextProperty();
    }

    /**
     * Returns the currently-set content text for this DialogPane.
     * @return the currently-set content text for this DialogPane
     */
    public final String getContentText() {
        return getDialogPane().getContentText();
    }

    /**
     * Sets the string to show in the dialog content area. Note that the content text
     * is lower precedence than the {@link DialogPane#contentProperty() content node}, meaning
     * that if both the content node and the contentText properties are set, the
     * content text will not be displayed in a default DialogPane instance.
     * @param contentText the string to show in the dialog content area
     */
    public final void setContentText(String contentText) {
        getDialogPane().setContentText(contentText);
    }


    // --- header text (forwarded from DialogPane)
    /**
     * A property representing the header text for the dialog pane. The header text
     * is lower precedence than the {@link DialogPane#headerProperty() header node}, meaning
     * that if both the header node and the headerText properties are set, the
     * header text will not be displayed in a default DialogPane instance.
     * @return a property representing the header text for the dialog pane
     */
    public final StringProperty headerTextProperty() {
        return getDialogPane().headerTextProperty();
    }

    /**
     * Returns the currently-set header text for this DialogPane.
     * @return the currently-set header text for this DialogPane
     */
    public final String getHeaderText() {
        return getDialogPane().getHeaderText();
    }

    /**
     * Sets the string to show in the dialog header area. Note that the header text
     * is lower precedence than the {@link DialogPane#headerProperty() header node}, meaning
     * that if both the header node and the headerText properties are set, the
     * header text will not be displayed in a default DialogPane instance.
     * @param headerText the string to show in the dialog header area
     */
    public final void setHeaderText(String headerText) {
        getDialogPane().setHeaderText(headerText);
    }


    // --- graphic (forwarded from DialogPane)
    /**
     * The dialog graphic, presented either in the header, if one is showing, or
     * to the left of the {@link DialogPane#contentProperty() content}.
     *
     * @return An ObjectProperty wrapping the current graphic.
     */
    public final ObjectProperty&lt;Node&gt; graphicProperty() {
        return getDialogPane().graphicProperty();
    }

    public final Node getGraphic() {
        return getDialogPane().getGraphic();
    }

    /**
     * Sets the dialog graphic, which will be displayed either in the header, if
     * one is showing, or to the left of the {@link DialogPane#contentProperty() content}.
     *
     * @param graphic
     *            The new dialog graphic, or null if no graphic should be shown.
     */
    public final void setGraphic(Node graphic) {
        getDialogPane().setGraphic(graphic);
    }


    // --- result
    private final ObjectProperty&lt;R&gt; resultProperty = new SimpleObjectProperty&lt;R&gt;() {
        protected void invalidated() {
            close();
        }
    };

    /**
     * A property representing what has been returned from the dialog. A result
     * is generated through the {@link #resultConverterProperty() result converter},
     * which is intended to convert from the {@link ButtonType} that the user
     * clicked on into a value of type R. Refer to the {@link Dialog} class
     * JavaDoc for more details.
     * @return a property representing what has been returned from the dialog
     */
    public final ObjectProperty&lt;R&gt; resultProperty() {
        return resultProperty;
    }

    public final R getResult() {
        return resultProperty().get();
    }

    public final void setResult(R value) {
        this.resultProperty().set(value);
    }


    // --- result converter
    private final ObjectProperty&lt;Callback&lt;ButtonType, R&gt;&gt; resultConverterProperty
        = new SimpleObjectProperty&lt;&gt;(this, &quot;resultConverter&quot;);

    /**
     * API to convert the {@link ButtonType} that the user clicked on into a
     * result that can be returned via the {@link #resultProperty() result}
     * property. This is necessary as {@link ButtonType} represents the visual
     * button within the dialog, and do not know how to map themselves to a valid
     * result - that is a requirement of the dialog implementation by making use
     * of the result converter. In some cases, the result type of a Dialog
     * subclass is ButtonType (which means that the result converter can be null),
     * but in some cases (where the result type, R, is not ButtonType or Void),
     * this callback must be specified.
     * @return the API to convert the {@link ButtonType} that the user clicked on
     */
    public final ObjectProperty&lt;Callback&lt;ButtonType, R&gt;&gt; resultConverterProperty() {
        return resultConverterProperty;
    }

    public final Callback&lt;ButtonType, R&gt; getResultConverter() {
        return resultConverterProperty().get();
    }

    public final void setResultConverter(Callback&lt;ButtonType, R&gt; value) {
        this.resultConverterProperty().set(value);
    }


    // --- showing
    /**
     * Represents whether the dialog is currently showing.
     * @return the property representing whether the dialog is currently showing
     */
    public final ReadOnlyBooleanProperty showingProperty() {
        return dialog.showingProperty();
    }

    /**
     * Returns whether or not the dialog is showing.
     *
     * @return true if dialog is showing.
     */
    public final boolean isShowing() {
        return showingProperty().get();
    }


    // --- resizable
    /**
     * Represents whether the dialog is resizable.
     * @return the property representing whether the dialog is resizable
     */
    public final BooleanProperty resizableProperty() {
        return dialog.resizableProperty();
    }

    /**
     * Returns whether or not the dialog is resizable.
     *
     * @return true if dialog is resizable.
     */
    public final boolean isResizable() {
        return resizableProperty().get();
    }

    /**
     * Sets whether the dialog can be resized by the user.
     * Resizable dialogs can also be maximized ( maximize button
     * becomes visible)
     *
     * @param resizable true if dialog should be resizable.
     */
    public final void setResizable(boolean resizable) {
        resizableProperty().set(resizable);
    }


    // --- width
    /**
     * Property representing the width of the dialog.
     * @return the property representing the width of the dialog
     */
    public final ReadOnlyDoubleProperty widthProperty() {
        return dialog.widthProperty();
    }

    /**
     * Returns the width of the dialog.
     * @return the width of the dialog
     */
    public final double getWidth() {
        return widthProperty().get();
    }

    /**
     * Sets the width of the dialog.
     * @param width the width of the dialog
     */
    public final void setWidth(double width) {
        dialog.setWidth(width);
    }


    // --- height
    /**
     * Property representing the height of the dialog.
     * @return the property representing the height of the dialog
     */
    public final ReadOnlyDoubleProperty heightProperty() {
        return dialog.heightProperty();
    }

    /**
     * Returns the height of the dialog.
     * @return the height of the dialog
     */
    public final double getHeight() {
        return heightProperty().get();
    }

    /**
     * Sets the height of the dialog.
     * @param height the height of the dialog
     */
    public final void setHeight(double height) {
        dialog.setHeight(height);
    }


    // --- title
    /**
     * Return the titleProperty of the dialog.
     * @return the titleProperty of the dialog
     */
    public final StringProperty titleProperty(){
        return this.dialog.titleProperty();
    }

    /**
     * Return the title of the dialog.
     * @return the title of the dialog
     */
    public final String getTitle(){
        return this.dialog.titleProperty().get();
    }
    /**
     * Change the Title of the dialog.
<A NAME="46"></A>     * @param title the Title of the dialog
     */
    public final void setTitle(String title){
        <FONT color="#92c7c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#46',2,'match31-top.html#46',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>this.dialog.titleProperty().set(title);
    }


    // --- x
    public final double getX() {
        return dialog.getX();
    }

    public final void setX(double x) {
        dialog.setX(x);
    }

    /**
     * The horizontal location of this {@code Dialog}. Changing this attribute
     * will move the {@code Dialog} horizontally.
     * @return the horizontal location of this {@code Dialog}
     */
    public final ReadOnlyDoubleProperty xProperty() {
        return dialog.xProperty();
    }

    // --- y
    public final double getY() {
        return dialog.getY();
    }

    publ</B></FONT>ic final void setY(double y) {
        dialog.setY(y);
    }

    /**
     * The vertical location of this {@code Dialog}. Changing this attribute
     * will move the {@code Dialog} vertically.
     * @return the vertical location of this {@code Dialog}
     */
    public final ReadOnlyDoubleProperty yProperty() {
        return dialog.yProperty();
    }



    /***************************************************************************
     *
     * Events
     *
     **************************************************************************/

    private final EventHandlerManager eventHandlerManager = new EventHandlerManager(this);

    /** {@inheritDoc} */
    @Override public EventDispatchChain buildEventDispatchChain(EventDispatchChain tail) {
        return tail.prepend(eventHandlerManager);
    }

    /**
     * Called just prior to the Dialog being shown.
     */
    private ObjectProperty&lt;EventHandler&lt;DialogEvent&gt;&gt; onShowing;
    public final void setOnShowing(EventHandler&lt;DialogEvent&gt; value) { onShowingProperty().set(value); }
    public final EventHandler&lt;DialogEvent&gt; getOnShowing() {
        return onShowing == null ? null : onShowing.get();
    }
    public final ObjectProperty&lt;EventHandler&lt;DialogEvent&gt;&gt; onShowingProperty() {
        if (onShowing == null) {
            onShowing = new SimpleObjectProperty&lt;EventHandler&lt;DialogEvent&gt;&gt;(this, &quot;onShowing&quot;) {
                @Override protected void invalidated() {
                    eventHandlerManager.setEventHandler(DialogEvent.DIALOG_SHOWING, get());
                }
            };
        }
        return onShowing;
    }

    /**
     * Called just after the Dialog is shown.
     */
    private ObjectProperty&lt;EventHandler&lt;DialogEvent&gt;&gt; onShown;
    public final void setOnShown(EventHandler&lt;DialogEvent&gt; value) { onShownProperty().set(value); }
    public final EventHandler&lt;DialogEvent&gt; getOnShown() {
        return onShown == null ? null : onShown.get();
    }
    public final ObjectProperty&lt;EventHandler&lt;DialogEvent&gt;&gt; onShownProperty() {
        if (onShown == null) {
            onShown = new SimpleObjectProperty&lt;EventHandler&lt;DialogEvent&gt;&gt;(this, &quot;onShown&quot;) {
                @Override protected void invalidated() {
                    eventHandlerManager.setEventHandler(DialogEvent.DIALOG_SHOWN, get());
                }
            };
        }
        return onShown;
    }

    /**
     * Called just prior to the Dialog being hidden.
     */
    private ObjectProperty&lt;EventHandler&lt;DialogEvent&gt;&gt; onHiding;
    public final void setOnHiding(EventHandler&lt;DialogEvent&gt; value) { onHidingProperty().set(value); }
    public final EventHandler&lt;DialogEvent&gt; getOnHiding() {
        return onHiding == null ? null : onHiding.get();
    }
    public final ObjectProperty&lt;EventHandler&lt;DialogEvent&gt;&gt; onHidingProperty() {
        if (onHiding == null) {
            onHiding = new SimpleObjectProperty&lt;EventHandler&lt;DialogEvent&gt;&gt;(this, &quot;onHiding&quot;) {
                @Override protected void invalidated() {
                    eventHandlerManager.setEventHandler(DialogEvent.DIALOG_HIDING, get());
                }
            };
        }
        return onHiding;
    }

    /**
     * Called just after the Dialog has been hidden.
     * When the {@code Dialog} is hidden, this event handler is invoked allowing
     * the developer to clean up resources or perform other tasks when the
     * {@link Alert} is closed.
     */
    private ObjectProperty&lt;EventHandler&lt;DialogEvent&gt;&gt; onHidden;
    public final void setOnHidden(EventHandler&lt;DialogEvent&gt; value) { onHiddenProperty().set(value); }
    public final EventHandler&lt;DialogEvent&gt; getOnHidden() {
        return onHidden == null ? null : onHidden.get();
    }
    public final ObjectProperty&lt;EventHandler&lt;DialogEvent&gt;&gt; onHiddenProperty() {
        if (onHidden == null) {
            onHidden = new SimpleObjectProperty&lt;EventHandler&lt;DialogEvent&gt;&gt;(this, &quot;onHidden&quot;) {
                @Override protected void invalidated() {
                    eventHandlerManager.setEventHandler(DialogEvent.DIALOG_HIDDEN, get());
                }
            };
        }
        return onHidden;
    }

    /**
     * Called when there is an external request to close this {@code Dialog}.
     * The installed event handler can prevent dialog closing by consuming the
     * received event.
     */
    private ObjectProperty&lt;EventHandler&lt;DialogEvent&gt;&gt; onCloseRequest;
    public final void setOnCloseRequest(EventHandler&lt;DialogEvent&gt; value) {
        onCloseRequestProperty().set(value);
    }
    public final EventHandler&lt;DialogEvent&gt; getOnCloseRequest() {
        return (onCloseRequest != null) ? onCloseRequest.get() : null;
    }
    public final ObjectProperty&lt;EventHandler&lt;DialogEvent&gt;&gt;
            onCloseRequestProperty() {
        if (onCloseRequest == null) {
            onCloseRequest = new SimpleObjectProperty&lt;EventHandler&lt;DialogEvent&gt;&gt;(this, &quot;onCloseRequest&quot;) {
                @Override protected void invalidated() {
                    eventHandlerManager.setEventHandler(DialogEvent.DIALOG_CLOSE_REQUEST, get());
                }
            };
        }
        return onCloseRequest;
    }



    /***************************************************************************
     *
     * Private implementation
     *
     **************************************************************************/

    // This code is called both in the normal and in the abnormal case (i.e.
    // both when a button is clicked and when the user forces a window closed
    // with keyboard OS-specific shortcuts or OS-native titlebar buttons).
    @SuppressWarnings(&quot;unchecked&quot;)
    void setResultAndClose(ButtonType cmd, boolean close) {
        Callback&lt;ButtonType, R&gt; resultConverter = getResultConverter();

        R priorResultValue = getResult();
        R newResultValue = null;

        if (resultConverter == null) {
            // The choice to cast cmd to R here was a conscious decision, taking
            // into account the choices available to us. Firstly, to summarise the
            // issue, at this point here we have a null result converter, and no
            // idea how to convert the given ButtonType to R. Our options are:
            //
            // 1) We could throw an exception here, but this requires that all
            // developers who create a dialog set a result converter (at least
            // setResultConverter(buttonType -&gt; (R) buttonType)). This is
            // non-intuitive and depends on the developer reading documentation.
            //
            // 2) We could set a default result converter in the resultConverter
            // property that does the identity conversion. This saves people from
            // having to set a default result converter, but it is a little odd
            // that the result converter is non-null by default.
            //
            // 3) We can cast the button type here, which is what we do. This means
            // that the result converter is null by default.
            //
            // In the case of option 1), developers will receive a NPE when the
            // dialog is closed, regardless of how it was closed. In the case of
            // option 2) and 3), the user unfortunately receives a ClassCastException
            // in their code. This is unfortunate as it is not immediately obvious
            // why the ClassCastException occurred, and how to resolve it. However,
            // we decided to take this later approach as it prevents the issue of
            // requiring all custom dialog developers from having to supply their
            // own result converters.
            newResultValue = (R) cmd;
        } else {
            newResultValue = resultConverter.call(cmd);
        }

        setResult(newResultValue);

        // fix for the case where we set the same result as what
        // was already set. We should still close the dialog, but
        // we need to special-case it here, as the result property
        // won't fire any event if the value won't change.
        if (close &amp;&amp; priorResultValue == newResultValue) {
            close();
        }
    }




    /***************************************************************************
     *
     * Stylesheet Handling
     *
     **************************************************************************/
    private static final PseudoClass HEADER_PSEUDO_CLASS =
            PseudoClass.getPseudoClass(&quot;header&quot;); //$NON-NLS-1$
    private static final PseudoClass NO_HEADER_PSEUDO_CLASS =
            PseudoClass.getPseudoClass(&quot;no-header&quot;); //$NON-NLS-1$

    private void updatePseudoClassState() {
        DialogPane dialogPane = getDialogPane();
        if (dialogPane != null) {
            final boolean hasHeader = getDialogPane().hasHeader();
            dialogPane.pseudoClassStateChanged(HEADER_PSEUDO_CLASS,     hasHeader);
            dialogPane.pseudoClassStateChanged(NO_HEADER_PSEUDO_CLASS, !hasHeader);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/SplitPane.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.WeakHashMap;

import javafx.beans.DefaultProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.geometry.Orientation;
import javafx.scene.Node;

import javafx.css.StyleableObjectProperty;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;

import javafx.css.converter.EnumConverter;
import javafx.scene.control.skin.SplitPaneSkin;

import javafx.css.Styleable;
import javafx.css.StyleableProperty;

/**
 * &lt;p&gt;A control that has two or more sides, each separated by a divider, which can be
 * dragged by the user to give more space to one of the sides, resulting in
 * the other side shrinking by an equal amount.&lt;/p&gt;
 *
 * &lt;p&gt;{@link Node Nodes} can be positioned horizontally next to each other, or stacked
 * vertically. This can be controlled by setting the {@link #orientationProperty()}.&lt;/p&gt;
 *
 * &lt;p&gt; The dividers in a SplitPane have the following behavior
 * &lt;ul&gt;
 * &lt;li&gt;Dividers cannot overlap another divider&lt;/li&gt;
 * &lt;li&gt;Dividers cannot overlap a node.&lt;/li&gt;
 * &lt;li&gt;Dividers moving to the left/top will stop when the node's min size is reached.&lt;/li&gt;
 * &lt;li&gt;Dividers moving to the right/bottom will stop when the node's max size is reached.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Nodes needs to be placed inside a layout container before they are added
 * into the SplitPane.  If the node is not inside a layout container
 * the maximum and minimum position of the divider will be the
 * maximum and minimum size of the content.
 * &lt;/p&gt;
 *
 * &lt;p&gt;A divider's position ranges from 0 to 1.0(inclusive).  A position of 0 will place the
 * divider at the left/top most edge of the SplitPane plus the minimum size of the node.  A
 * position of 1.0 will place the divider at the right/bottom most edge of the SplitPane minus the
 * minimum size of the node.  A divider position of 0.5 will place the
 * the divider in the middle of the SplitPane.  Setting the divider position greater
 * than the node's maximum size position will result in the divider being set at the
 * node's maximum size position.  Setting the divider position less than the node's minimum size position
 * will result in the divider being set at the node's minimum size position. Therefore the value set in
 * {@link #setDividerPosition} and {@link #setDividerPositions} may not be the same as the value returned by
 * {@link #getDividerPositions}.
 * &lt;/p&gt;
 *
 * &lt;p&gt;If there are more than two nodes in the SplitPane and the divider positions are set in such a
 * way that the dividers cannot fit the nodes the dividers will be automatically adjusted by the SplitPane.
 * &lt;p&gt;For example we have three nodes whose sizes and divider positions are
 * &lt;/p&gt;
 * &lt;pre&gt;
 * Node 1: min 25 max 100
 * Node 2: min 100 max 200
 * Node 3: min 25 max 50
 * divider 1: 0.40
 * divider 2: 0.45
 * &lt;/pre&gt;
 *
 * &lt;p&gt;The result will be Node 1 size will be its pref size and divider 1 will be positioned 0.40,
 * Node 2 size will be its min size and divider 2 position will be the min size of Node 2 plus
 * divider 1 position, and the remaining space will be given to Node 3.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * SplitPane sets focusTraversable to false.
 * &lt;/p&gt;
 *
 * &lt;p&gt;Example:&lt;/p&gt;
 * &lt;pre&gt;&lt;code&gt;
 * SplitPane sp = new SplitPane();
 * final StackPane sp1 = new StackPane();
 * sp1.getItems().add(new Button(&quot;Button One&quot;));
 * final StackPane sp2 = new StackPane();
 * sp2.getItems().add(new Button(&quot;Button Two&quot;));
 * final StackPane sp3 = new StackPane();
 * sp3.getItems().add(new Button(&quot;Button Three&quot;));
 * sp.getItems().addAll(sp1, sp2, sp3);
 * sp.setDividerPositions(0.3f, 0.6f, 0.9f);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;items&quot;)
public class SplitPane extends Control {

    /********************************************************************
     *  static methods
     ********************************************************************/
    private static final String RESIZABLE_WITH_PARENT = &quot;resizable-with-parent&quot;;

    /**
     * Sets a node in the SplitPane to be resizable or not when the SplitPane is
     * resized.  By default all node are resizable.  Setting value to false will
     * prevent the node from being resized.
     * @param node A node in the SplitPane.
     * @param value true if the node is resizable or false if not resizable.
     * @since JavaFX 2.1
     */
<A NAME="10"></A>    public static void setResizableWithParent(Node node, Boolean value) {
        if (value == null) {
            node.getProperties().remove(RESIZABLE_WITH_PARENT);
        } else <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#10',2,'match31-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
            node.getProperties().put(RESIZABLE_WITH_PARENT, value);
        }
    }

    /**
     * Return true if the node is resizable when the parent container is resized false otherwise.
     * @param node A node in the SplitPane.
     * @defaultValue true
     * @return true if the node is resizable false otherwise.
     * @since JavaFX 2.1
     */
    public static Boolean isResizableWithParent(Node node) {
        if (node.hasProperties()) {
            Object value = node.getProperties</B></FONT>().get(RESIZABLE_WITH_PARENT);
            if (value != null) {
                return (Boolean)value;
            }
        }
        return true;
    }

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new SplitPane with no content.
     */
    public SplitPane() {
        this((Node[])null);
    }

    /**
     * Creates a new SplitPane with the given items set as the content to split
     * between one or more dividers.
     *
     * @param items The items to place inside the SplitPane.
     * @since JavaFX 8u40
     */
    public SplitPane(Node... items) {
        getStyleClass().setAll(DEFAULT_STYLE_CLASS);
        // focusTraversable is styleable through css. Calling setFocusTraversable
        // makes it look to css like the user set the value and css will not
        // override. Initializing focusTraversable by calling applyStyle with a
        // null StyleOrigin ensures that css will be able to override the value.
        ((StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)focusTraversableProperty()).applyStyle(null, Boolean.FALSE);

        getItems().addListener(new ListChangeListener&lt;Node&gt;() {
            @Override public void onChanged(Change&lt;? extends Node&gt; c) {
                while (c.next()) {
                    int from = c.getFrom();
                    int index = from;
                    for (int i = 0; i &lt; c.getRemovedSize(); i++) {
                        if (index &lt; dividers.size()) {
                            dividerCache.put(index, Double.MAX_VALUE);
                        } else if (index == dividers.size()) {
                            if (!dividers.isEmpty()) {
                                if (c.wasReplaced()) {
                                    dividerCache.put(index - 1, dividers.get(index - 1).getPosition());
                                } else {
                                    dividerCache.put(index - 1, Double.MAX_VALUE);
                                }
                            }
                        }
                        index++;
                    }
                    for (int i = 0; i &lt; dividers.size(); i++) {
                        if (dividerCache.get(i) == null) {
                            dividerCache.put(i, dividers.get(i).getPosition());
                        }
                    }
                }
                dividers.clear();
                for (int i = 0; i &lt; getItems().size() - 1; i++) {
                    if (dividerCache.containsKey(i) &amp;&amp; dividerCache.get(i) != Double.MAX_VALUE) {
                        Divider d = new Divider();
                        d.setPosition(dividerCache.get(i));
                        dividers.add(d);
                    } else {
                        dividers.add(new Divider());
                    }
                    dividerCache.remove(i);
                }
            }
        });

        if (items != null) {
            getItems().addAll(items);
        }

        // initialize pseudo-class state
        pseudoClassStateChanged(HORIZONTAL_PSEUDOCLASS_STATE, true);
    }

    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- Vertical
    private ObjectProperty&lt;Orientation&gt; orientation;

    /**
     * &lt;p&gt;This property controls how the SplitPane should be displayed to the
     * user. {@link javafx.geometry.Orientation#HORIZONTAL} will result in
     * two (or more) nodes being placed next to each other horizontally, whilst
     * {@link javafx.geometry.Orientation#VERTICAL} will result in the nodes being
     * stacked vertically.&lt;/p&gt;
     *
     * @param value the orientation value
     */
    public final void setOrientation(Orientation value) {
        orientationProperty().set(value);
    };

    /**
     * The orientation for the SplitPane.
     * @return The orientation for the SplitPane.
     */
    public final Orientation getOrientation() {
        return orientation == null ? Orientation.HORIZONTAL : orientation.get();
    }

    /**
     * The orientation for the SplitPane.
     * @return the orientation property for the SplitPane
     */
    public final ObjectProperty&lt;Orientation&gt; orientationProperty() {
        if (orientation == null) {
            orientation = new StyleableObjectProperty&lt;Orientation&gt;(Orientation.HORIZONTAL) {
                @Override public void invalidated() {
                    final boolean isVertical = (get() == Orientation.VERTICAL);
                    pseudoClassStateChanged(VERTICAL_PSEUDOCLASS_STATE,    isVertical);
                    pseudoClassStateChanged(HORIZONTAL_PSEUDOCLASS_STATE, !isVertical);
                }

                @Override public CssMetaData&lt;SplitPane,Orientation&gt; getCssMetaData() {
                    return StyleableProperties.ORIENTATION;
                }

                @Override
                public Object getBean() {
                    return SplitPane.this;
                }

                @Override
                public String getName() {
                    return &quot;orientation&quot;;
                }
            };
        }
        return orientation;
    }



    /***************************************************************************
     *                                                                         *
     * Instance Variables                                                      *
     *                                                                         *
     **************************************************************************/

    private final ObservableList&lt;Node&gt; items = FXCollections.observableArrayList();

    private final ObservableList&lt;Divider&gt; dividers = FXCollections.observableArrayList();
    private final ObservableList&lt;Divider&gt; unmodifiableDividers = FXCollections.unmodifiableObservableList(dividers);

    // Cache the divider positions if the items have not been created.
    private final WeakHashMap&lt;Integer, Double&gt; dividerCache = new WeakHashMap&lt;Integer, Double&gt;();

    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns an ObservableList which can be use to modify the contents of the SplitPane.
     * The order the nodes are placed into this list will be the same order in the SplitPane.
     *
     * @return the list of items in this SplitPane.
     */
    public ObservableList&lt;Node&gt; getItems() {
        return items;
    }

    /**
     * Returns an unmodifiable list of all the dividers in this SplitPane.
     *
     * @return the list of dividers.
     */
    public ObservableList&lt;Divider&gt; getDividers() {
        return unmodifiableDividers;
    }

    /**
     * Sets the position of the divider at the specified divider index.
     *
     * @param dividerIndex the index of the divider.
     * @param position the divider position, between 0.0 and 1.0 (inclusive).
     */
    public void setDividerPosition(int dividerIndex, double position) {
        if (getDividers().size() &lt;= dividerIndex)  {
            dividerCache.put(dividerIndex, position);
            return;
        }
        if (dividerIndex &gt;= 0) {
            getDividers().get(dividerIndex).setPosition(position);
        }
    }

    /**
     * Sets the position of the divider
     *
     * @param positions the divider position, between 0.0 and 1.0 (inclusive).
     */
    public void setDividerPositions(double... positions) {
        if (dividers.isEmpty()) {
            for (int i = 0; i &lt; positions.length; i++) {
                dividerCache.put(i, positions[i]);
            }
            return;
        }
        for (int i = 0; i &lt; positions.length &amp;&amp; i &lt; dividers.size(); i++) {
            dividers.get(i).setPosition(positions[i]);
        }
    }

    /**
     * Returns an array of double containing the position of each divider.
     *
     * @return an array of double containing the position of each divider.
     */
    public double[] getDividerPositions() {
        double[] positions = new double[dividers.size()];
        for (int i = 0; i &lt; dividers.size(); i++) {
            positions[i] = dividers.get(i).getPosition();
        }
        return positions;
    }

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new SplitPaneSkin(this);
    }

    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;split-pane&quot;;

    private static class StyleableProperties {
        private static final CssMetaData&lt;SplitPane,Orientation&gt; ORIENTATION =
            new CssMetaData&lt;SplitPane,Orientation&gt;(&quot;-fx-orientation&quot;,
                new EnumConverter&lt;Orientation&gt;(Orientation.class),
                Orientation.HORIZONTAL) {

            @Override
            public Orientation getInitialValue(SplitPane node) {
                // A vertical SplitPane should remain vertical
                return node.getOrientation();
            }

            @Override
            public boolean isSettable(SplitPane n) {
                return n.orientation == null || !n.orientation.isBound();
            }

            @Override
            public StyleableProperty&lt;Orientation&gt; getStyleableProperty(SplitPane n) {
                return (StyleableProperty&lt;Orientation&gt;)(WritableValue&lt;Orientation&gt;)n.orientationProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
            styleables.add(ORIENTATION);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
        return getClassCssMetaData();
    }

    private static final PseudoClass VERTICAL_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;vertical&quot;);
    private static final PseudoClass HORIZONTAL_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;horizontal&quot;);

    /**
     * Returns the initial focus traversable state of this control, for use
     * by the JavaFX CSS engine to correctly set its initial value. This method
     * is overridden as by default UI controls have focus traversable set to true,
     * but that is not appropriate for this control.
     *
     * @since 9
     */
    @Override protected Boolean getInitialFocusTraversable() {
        return Boolean.FALSE;
    }


    /***************************************************************************
     *                                                                         *
     * Support Classes                                                         *
     *                                                                         *
     **************************************************************************/

    /**
     * Represents a single divider in the SplitPane.
     * @since JavaFX 2.0
     */
    public static class Divider {

        /**
         * Creates a default Divider instance.
         */
        public Divider() {

        }

        /**
         * &lt;p&gt;Represents the location where the divider should ideally be
         * positioned, between 0.0 and 1.0 (inclusive). 0.0 represents the
         * left- or top-most point, and 1.0 represents the right- or bottom-most
         * point (depending on the horizontal property). The SplitPane will attempt
         * to get the divider to the point requested, but it must take into account
         * the minimum width/height of the nodes contained within it.&lt;/p&gt;
         *
         * &lt;p&gt;As the user drags the SplitPane divider around this property will
         * be updated to always represent its current location.&lt;/p&gt;
         *
         * @defaultValue 0.5
         */
        private DoubleProperty position;
        public final void setPosition(double value) {
            positionProperty().set(value);
        }

        public final double getPosition() {
            return position == null ? 0.5F : position.get();
        }

        public final DoubleProperty positionProperty() {
            if (position == null) {
                position = new SimpleDoubleProperty(this, &quot;position&quot;, 0.5F);// {
//                    @Override protected void invalidated() {
//                        if (get() &lt; 0) {
//                            this.value = value;
//                        } else if (get() &gt; 1) {
//                            this.value = value;
//                        }
//                    }
//                };
            }
            return position;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TableUtil.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javafx.beans.InvalidationListener;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;

/**
 * A package protected util class used by TableView and TreeTableView to reduce
 * the level of code duplication.
 */
class TableUtil {

    private TableUtil() {
        // no-op
    }

    static void removeTableColumnListener(List&lt;? extends TableColumnBase&gt; list,
                        final InvalidationListener columnVisibleObserver,
                        final InvalidationListener columnSortableObserver,
                        final InvalidationListener columnSortTypeObserver,
                        final InvalidationListener columnComparatorObserver) {

        if (list == null) return;
        for (TableColumnBase col : list) {
            col.visibleProperty().removeListener(columnVisibleObserver);
            col.sortableProperty().removeListener(columnSortableObserver);
            col.comparatorProperty().removeListener(columnComparatorObserver);

//            col.sortTypeProperty().removeListener(columnSortTypeObserver);
            if (col instanceof TableColumn) {
                ((TableColumn)col).sortTypeProperty().removeListener(columnSortTypeObserver);
            } else if (col instanceof TreeTableColumn) {
                ((TreeTableColumn)col).sortTypeProperty().removeListener(columnSortTypeObserver);
            }

            removeTableColumnListener(col.getColumns(),
                                      columnVisibleObserver,
                                      columnSortableObserver,
                                      columnSortTypeObserver,
                                      columnComparatorObserver);
        }
    }

    static void addTableColumnListener(List&lt;? extends TableColumnBase&gt; list,
                        final InvalidationListener columnVisibleObserver,
                        final InvalidationListener columnSortableObserver,
                        final InvalidationListener columnSortTypeObserver,
                        final InvalidationListener columnComparatorObserver) {

        if (list == null) return;
        for (TableColumnBase col : list) {
            col.visibleProperty().addListener(columnVisibleObserver);
            col.sortableProperty().addListener(columnSortableObserver);
            col.comparatorProperty().addListener(columnComparatorObserver);

            if (col instanceof TableColumn) {
                ((TableColumn)col).sortTypeProperty().addListener(columnSortTypeObserver);
            } else if (col instanceof TreeTableColumn) {
                ((TreeTableColumn)col).sortTypeProperty().addListener(columnSortTypeObserver);
            }

            addTableColumnListener(col.getColumns(),
                                   columnVisibleObserver,
                                   columnSortableObserver,
                                   columnSortTypeObserver,
                                   columnComparatorObserver);
        }
    }

    static void removeColumnsListener(List&lt;? extends TableColumnBase&gt; list, ListChangeListener cl) {
<A NAME="24"></A>        if (list == null) return;

        for (TableColumnBase col : list) {
            <FONT color="#ada96e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#24',2,'match31-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>col.getColumns().removeListener(cl);
            removeColumnsListener(col.getColumns(), cl);
        }
    }

    static void addColumnsListener(List&lt;? extends TableColumnBase&gt; list, ListChangeListener cl) {</B></FONT>
        if (list == null) return;

        for (TableColumnBase col : list) {
            col.getColumns().addListener(cl);
            addColumnsListener(col.getColumns(), cl);
        }
    }

    static void handleSortFailure(ObservableList&lt;? extends TableColumnBase&gt; sortOrder,
            SortEventType sortEventType, final Object... supportInfo) {
        // if the sort event is consumed we need to back out the previous
        // action so that the UI is not in an incorrect state
        if (sortEventType == SortEventType.COLUMN_SORT_TYPE_CHANGE) {
            // go back to the previous sort type
            final TableColumnBase changedColumn = (TableColumnBase) supportInfo[0];
            revertSortType(changedColumn);
        } else if (sortEventType == SortEventType.SORT_ORDER_CHANGE) {
            // Revert the sortOrder list to what it was previously
            ListChangeListener.Change change = (ListChangeListener.Change) supportInfo[0];

            final List toRemove = new ArrayList();
            final List toAdd = new ArrayList();
            while (change.next()) {
                if (change.wasAdded()) {
                    toRemove.addAll(change.getAddedSubList());
                }

                if (change.wasRemoved()) {
                    toAdd.addAll(change.getRemoved());
                }
            }

            sortOrder.removeAll(toRemove);
            sortOrder.addAll(toAdd);
        } else if (sortEventType == SortEventType.COLUMN_SORTABLE_CHANGE) {
            // no-op - it is ok for the sortable type to remain as-is
        } else if (sortEventType == SortEventType.COLUMN_COMPARATOR_CHANGE) {
            // no-op - it is ok for the comparator to remain as-is
        }
    }

    private static void revertSortType(TableColumnBase changedColumn) {
        if (changedColumn instanceof TableColumn) {
            TableColumn tableColumn = (TableColumn)changedColumn;
            final TableColumn.SortType sortType = tableColumn.getSortType();
            if (sortType == TableColumn.SortType.ASCENDING) {
                tableColumn.setSortType(null);
            } else if (sortType == TableColumn.SortType.DESCENDING) {
                tableColumn.setSortType(TableColumn.SortType.ASCENDING);
            } else if (sortType == null) {
                tableColumn.setSortType(TableColumn.SortType.DESCENDING);
            }
        } else if (changedColumn instanceof TreeTableColumn) {
            TreeTableColumn tableColumn = (TreeTableColumn)changedColumn;
            final TreeTableColumn.SortType sortType = tableColumn.getSortType();
            if (sortType == TreeTableColumn.SortType.ASCENDING) {
                tableColumn.setSortType(null);
            } else if (sortType == TreeTableColumn.SortType.DESCENDING) {
                tableColumn.setSortType(TreeTableColumn.SortType.ASCENDING);
            } else if (sortType == null) {
                tableColumn.setSortType(TreeTableColumn.SortType.DESCENDING);
            }
        }
    }

    static enum SortEventType {
         SORT_ORDER_CHANGE,
         COLUMN_SORT_TYPE_CHANGE,
         COLUMN_SORTABLE_CHANGE,
         COLUMN_COMPARATOR_CHANGE
     }





    /**
     * The constrained resize algorithm used by TableView and TreeTableView.
     * @param prop
     * @param isFirstRun
     * @param tableWidth
     * @param visibleLeafColumns
     * @return
     */
    static boolean constrainedResize(ResizeFeaturesBase prop,
                                     boolean isFirstRun,
                                     double tableWidth,
                                     List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; visibleLeafColumns) {
        TableColumnBase&lt;?,?&gt; column = prop.getColumn();
        double delta = prop.getDelta();

        /*
         * There are two phases to the constrained resize policy:
         *   1) Ensuring internal consistency (i.e. table width == sum of all visible
         *      columns width). This is often called when the table is resized.
         *   2) Resizing the given column by __up to__ the given delta.
         *
         * It is possible that phase 1 occur and there be no need for phase 2 to
         * occur.
         */

        boolean isShrinking;
        double target;
        double totalLowerBound = 0;
        double totalUpperBound = 0;

        if (tableWidth == 0) return false;

        /*
         * PHASE 1: Check to ensure we have internal consistency. Based on the
         *          Swing JTable implementation.
         */
        // determine the width of all visible columns, and their preferred width
        double colWidth = 0;
        for (TableColumnBase&lt;?,?&gt; col : visibleLeafColumns) {
            colWidth += col.getWidth();
        }

        if (Math.abs(colWidth - tableWidth) &gt; 1) {
            isShrinking = colWidth &gt; tableWidth;
            target = tableWidth;

            if (isFirstRun) {
                // if we are here we have an inconsistency - these two values should be
                // equal when this resizing policy is being used.
                for (TableColumnBase&lt;?,?&gt; col : visibleLeafColumns) {
                    totalLowerBound += col.getMinWidth();
                    totalUpperBound += col.getMaxWidth();
                }

                // We run into trouble if the numbers are set to infinity later on
                totalUpperBound = totalUpperBound == Double.POSITIVE_INFINITY ?
                    Double.MAX_VALUE :
                    (totalUpperBound == Double.NEGATIVE_INFINITY ? Double.MIN_VALUE : totalUpperBound);

                for (TableColumnBase col : visibleLeafColumns) {
                    double lowerBound = col.getMinWidth();
                    double upperBound = col.getMaxWidth();

                    // Check for zero. This happens when the distribution of the delta
                    // finishes early due to a series of &quot;fixed&quot; entries at the end.
                    // In this case, lowerBound == upperBound, for all subsequent terms.
                    double newSize;
                    if (Math.abs(totalLowerBound - totalUpperBound) &lt; .0000001) {
                        newSize = lowerBound;
                    } else {
                        double f = (target - totalLowerBound) / (totalUpperBound - totalLowerBound);
                        newSize = Math.round(lowerBound + f * (upperBound - lowerBound));
                    }

                    double remainder = resize(col, newSize - col.getWidth());

                    target -= newSize + remainder;
                    totalLowerBound -= lowerBound;
                    totalUpperBound -= upperBound;
                }

                isFirstRun = false;
            } else {
                double actualDelta = tableWidth - colWidth;
                List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; cols = visibleLeafColumns;
                resizeColumns(cols, actualDelta);
            }
        }

        // At this point we can be happy in the knowledge that we have internal
        // consistency, i.e. table width == sum of the width of all visible
        // leaf columns.

        /*
         * Column may be null if we just changed the resize policy, and we
         * just wanted to enforce internal consistency, as mentioned above.
         */
        if (column == null) {
            return false;
        }

        /*
         * PHASE 2: Handling actual column resizing (by the user). Based on my own
         *          implementation (based on the UX spec).
         */

        isShrinking = delta &lt; 0;

        // need to find the last leaf column of the given column - it is this
        // column that we actually resize from. If this column is a leaf, then we
        // use it.
        TableColumnBase&lt;?,?&gt; leafColumn = column;
        while (leafColumn.getColumns().size() &gt; 0) {
            leafColumn = leafColumn.getColumns().get(leafColumn.getColumns().size() - 1);
        }

        int colPos = visibleLeafColumns.indexOf(leafColumn);
        int endColPos = visibleLeafColumns.size() - 1;

        // we now can split the observableArrayList into two subobservableArrayLists, representing all
        // columns that should grow, and all columns that should shrink
        //    var growingCols = if (isShrinking)
        //        then table.visibleLeafColumns[colPos+1..endColPos]
        //        else table.visibleLeafColumns[0..colPos];
        //    var shrinkingCols = if (isShrinking)
        //        then table.visibleLeafColumns[0..colPos]
        //        else table.visibleLeafColumns[colPos+1..endColPos];


        double remainingDelta = delta;
        while (endColPos &gt; colPos &amp;&amp; remainingDelta != 0) {
            TableColumnBase&lt;?,?&gt; resizingCol = visibleLeafColumns.get(endColPos);
            endColPos--;

            // if the column width is fixed, break out and try the next column
            if (! resizingCol.isResizable()) continue;

            // for convenience we discern between the shrinking and growing columns
            TableColumnBase&lt;?,?&gt; shrinkingCol = isShrinking ? leafColumn : resizingCol;
            TableColumnBase&lt;?,?&gt; growingCol = !isShrinking ? leafColumn : resizingCol;

            //        (shrinkingCol.width == shrinkingCol.minWidth) or (growingCol.width == growingCol.maxWidth)

            if (growingCol.getWidth() &gt; growingCol.getPrefWidth()) {
                // growingCol is willing to be generous in this case - it goes
                // off to find a potentially better candidate to grow
                List&lt;? extends TableColumnBase&gt; seq = visibleLeafColumns.subList(colPos + 1, endColPos + 1);
                for (int i = seq.size() - 1; i &gt;= 0; i--) {
                    TableColumnBase&lt;?,?&gt; c = seq.get(i);
                    if (c.getWidth() &lt; c.getPrefWidth()) {
                        growingCol = c;
                        break;
                    }
                }
            }
            //
            //        if (shrinkingCol.width &lt; shrinkingCol.prefWidth) {
            //            for (c in reverse table.visibleLeafColumns[colPos+1..endColPos]) {
            //                if (c.width &gt; c.prefWidth) {
            //                    shrinkingCol = c;
            //                    break;
            //                }
            //            }
            //        }



            double sdiff = Math.min(Math.abs(remainingDelta), shrinkingCol.getWidth() - shrinkingCol.getMinWidth());

//                System.out.println(&quot;\tshrinking &quot; + shrinkingCol.getText() + &quot; and growing &quot; + growingCol.getText());
//                System.out.println(&quot;\t\tMath.min(Math.abs(&quot;+remainingDelta+&quot;), &quot;+shrinkingCol.getWidth()+&quot; - &quot;+shrinkingCol.getMinWidth()+&quot;) = &quot; + sdiff);

            double delta1 = resize(shrinkingCol, -sdiff);
            double delta2 = resize(growingCol, sdiff);
            remainingDelta += isShrinking ? sdiff : -sdiff;
        }
        return remainingDelta == 0;
    }

    // function used to actually perform the resizing of the given column,
    // whilst ensuring it stays within the min and max bounds set on the column.
    // Returns the remaining delta if it could not all be applied.
    static double resize(TableColumnBase column, double delta) {
        if (delta == 0) return 0.0F;
        if (! column.isResizable()) return delta;

        final boolean isShrinking = delta &lt; 0;
        final List&lt;TableColumnBase&lt;?,?&gt;&gt; resizingChildren = getResizableChildren(column, isShrinking);

        if (resizingChildren.size() &gt; 0) {
            return resizeColumns(resizingChildren, delta);
        } else {
            double newWidth = column.getWidth() + delta;

            if (newWidth &gt; column.getMaxWidth()) {
                column.doSetWidth(column.getMaxWidth());
                return newWidth - column.getMaxWidth();
            } else if (newWidth &lt; column.getMinWidth()) {
                column.doSetWidth(column.getMinWidth());
                return newWidth - column.getMinWidth();
            } else {
                column.doSetWidth(newWidth);
                return 0.0F;
            }
        }
    }

    // Returns all children columns of the given column that are able to be
    // resized. This is based on whether they are visible, resizable, and have
    // not space before they hit the min / max values.
    private static List&lt;TableColumnBase&lt;?,?&gt;&gt; getResizableChildren(TableColumnBase&lt;?,?&gt; column, boolean isShrinking) {
        if (column == null || column.getColumns().isEmpty()) {
            return Collections.emptyList();
        }

        List&lt;TableColumnBase&lt;?,?&gt;&gt; tablecolumns = new ArrayList&lt;TableColumnBase&lt;?,?&gt;&gt;();
        for (TableColumnBase c : column.getColumns()) {
            if (! c.isVisible()) continue;
            if (! c.isResizable()) continue;

            if (isShrinking &amp;&amp; c.getWidth() &gt; c.getMinWidth()) {
                tablecolumns.add(c);
            } else if (!isShrinking &amp;&amp; c.getWidth() &lt; c.getMaxWidth()) {
                tablecolumns.add(c);
            }
        }
        return tablecolumns;
    }

    private static double resizeColumns(List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; columns, double delta) {
        // distribute space between all visible children who can be resized.
        // To do this we need to work out if we're shrinking or growing the
        // children, and then which children can be resized based on their
        // min/pref/max/fixed properties. The results of this are in the
        // resizingChildren observableArrayList above.
        final int columnCount = columns.size();

        // work out how much of the delta we should give to each child. It should
        // be an equal amount (at present), although perhaps we'll allow for
        // functions to calculate this at a later date.
        double colDelta = delta / columnCount;

        // we maintain a count of the amount of delta remaining to ensure that
        // the column resize operation accurately reflects the location of the
        // mouse pointer. Every time this value is not 0, the UI is a teeny bit
        // more inaccurate whilst the user continues to resize.
        double remainingDelta = delta;

        // We maintain a count of the current column that we're on in case we
        // need to redistribute the remainingDelta among remaining sibling.
        int col = 0;

        // This is a bit hacky - often times the leftOverDelta is zero, but
        // remainingDelta doesn't quite get down to 0. In these instances we
        // short-circuit and just return 0.0.
        boolean isClean = true;
        for (TableColumnBase&lt;?,?&gt; childCol : columns) {
            col++;

            // resize each child column
            double leftOverDelta = resize(childCol, colDelta);

            // calculate the remaining delta if the was anything left over in
            // the last resize operation
            remainingDelta = remainingDelta - colDelta + leftOverDelta;

            //      println(&quot;\tResized {childCol.text} with {colDelta}, but {leftOverDelta} was left over. RemainingDelta is now {remainingDelta}&quot;);

            if (leftOverDelta != 0) {
                isClean = false;
                // and recalculate the distribution of the remaining delta for
                // the remaining siblings.
                colDelta = remainingDelta / (columnCount - col);
            }
        }

        // see isClean above for why this is done
        return isClean ? 0.0 : remainingDelta;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TableView.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.WeakHashMap;

import com.sun.javafx.logging.PlatformLogger.Level;
import com.sun.javafx.scene.control.Logging;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.SelectedCellsMap;
import com.sun.javafx.scene.control.SelectedItemsReadOnlyObservableList;
import com.sun.javafx.scene.control.behavior.TableCellBehavior;
import com.sun.javafx.scene.control.behavior.TableCellBehaviorBase;
import javafx.beans.*;
import javafx.beans.Observable;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.Property;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.MapChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.collections.transformation.SortedList;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;
import javafx.css.Styleable;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableProperty;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.layout.Region;
import javafx.util.Callback;

import com.sun.javafx.collections.MappingChange;
import com.sun.javafx.collections.NonIterableChange;
import javafx.css.converter.SizeConverter;
import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
import com.sun.javafx.scene.control.TableColumnComparatorBase.TableColumnComparator;
import javafx.scene.control.skin.TableViewSkin;

/**
 * The TableView control is designed to visualize an unlimited number of rows
 * of data, broken out into columns. A TableView is therefore very similar to the
 * {@link ListView} control, with the addition of support for columns. For an
 * example on how to create a TableView, refer to the 'Creating a TableView'
 * control section below.
 *
 * &lt;p&gt;The TableView control has a number of features, including:
 * &lt;ul&gt;
 * &lt;li&gt;Powerful {@link TableColumn} API:
 *   &lt;ul&gt;
 *   &lt;li&gt;Support for {@link TableColumn#cellFactoryProperty() cell factories} to
 *      easily customize {@link Cell cell} contents in both rendering and editing
 *      states.
 *   &lt;li&gt;Specification of {@link TableColumn#minWidthProperty() minWidth}/
 *      {@link TableColumn#prefWidthProperty() prefWidth}/
 *      {@link TableColumn#maxWidthProperty() maxWidth},
 *      and also {@link TableColumn#resizableProperty() fixed width columns}.
 *   &lt;li&gt;Width resizing by the user at runtime.
 *   &lt;li&gt;Column reordering by the user at runtime.
 *   &lt;li&gt;Built-in support for {@link TableColumn#getColumns() column nesting}
 *   &lt;/ul&gt;
 * &lt;li&gt;Different {@link #columnResizePolicyProperty() resizing policies} to
 *      dictate what happens when the user resizes columns.
 * &lt;li&gt;Support for {@link #getSortOrder() multiple column sorting} by clicking
 *      the column header (hold down Shift keyboard key whilst clicking on a
 *      header to sort by multiple columns).
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Note that TableView is intended to be used to visualize data - it is not
 * intended to be used for laying out your user interface. If you want to lay
 * your user interface out in a grid-like fashion, consider the
 * {@link javafx.scene.layout.GridPane} layout instead.&lt;/p&gt;
 *
 * &lt;h2&gt;Creating a TableView&lt;/h2&gt;
 *
 * &lt;p&gt;
 * Creating a TableView is a multi-step process, and also depends on the
 * underlying data model needing to be represented. For this example we'll use
 * an {@literal ObservableList&lt;Person&gt;}, as it is the simplest way of showing data in a
 * TableView. The {@code Person} class will consist of a first
 * name and last name properties. That is:
 *
 * &lt;pre&gt;
 * {@code
 * public class Person {
 *     private StringProperty firstName;
 *     public void setFirstName(String value) { firstNameProperty().set(value); }
 *     public String getFirstName() { return firstNameProperty().get(); }
 *     public StringProperty firstNameProperty() {
 *         if (firstName == null) firstName = new SimpleStringProperty(this, &quot;firstName&quot;);
 *         return firstName;
 *     }
 *
 *     private StringProperty lastName;
 *     public void setLastName(String value) { lastNameProperty().set(value); }
 *     public String getLastName() { return lastNameProperty().get(); }
 *     public StringProperty lastNameProperty() {
 *         if (lastName == null) lastName = new SimpleStringProperty(this, &quot;lastName&quot;);
 *         return lastName;
 *     }
 * }}&lt;/pre&gt;
 *
 * &lt;p&gt;Firstly, a TableView instance needs to be defined, as such:
 *
 * &lt;pre&gt;
 * {@code
 * TableView&lt;Person&gt; table = new TableView&lt;&gt;();}&lt;/pre&gt;
 *
 * &lt;p&gt;With the basic table defined, we next focus on the data model. As mentioned,
 * for this example, we'll be using an {@literal ObservableList&lt;Person&gt;}. We can immediately
 * set such a list directly in to the TableView, as such:
 *
 * &lt;pre&gt;
 * {@code
 * ObservableList&lt;Person&gt; teamMembers = getTeamMembers();
 * table.setItems(teamMembers);}&lt;/pre&gt;
 *
 * &lt;p&gt;With the items set as such, TableView will automatically update whenever
 * the &lt;code&gt;teamMembers&lt;/code&gt; list changes. If the items list is available
 * before the TableView is instantiated, it is possible to pass it directly into
 * the constructor.
 *
 * &lt;p&gt;At this point we now have a TableView hooked up to observe the
 * &lt;code&gt;teamMembers&lt;/code&gt; observableList. The missing ingredient
 * now is the means of splitting out the data contained within the model and
 * representing it in one or more {@link TableColumn TableColumn} instances. To
 * create a two-column TableView to show the firstName and lastName properties,
 * we extend the last code sample as follows:
 *
 * &lt;pre&gt;
 * {@code
 * ObservableList&lt;Person&gt; teamMembers = ...;
 * table.setItems(teamMembers);
 *
 * TableColumn&lt;Person,String&gt; firstNameCol = new TableColumn&lt;&gt;(&quot;First Name&quot;);
 * firstNameCol.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;firstName&quot;));
 * TableColumn&lt;Person,String&gt; lastNameCol = new TableColumn&lt;&gt;(&quot;Last Name&quot;);
 * lastNameCol.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;lastName&quot;));
 *
 * table.getColumns().setAll(firstNameCol, lastNameCol);}&lt;/pre&gt;
 *
 * &lt;p&gt;With the code shown above we have fully defined the minimum properties
 * required to create a TableView instance. Running this code (assuming the
 * people ObservableList is appropriately created) will result in a TableView being
 * shown with two columns for firstName and lastName. Any other properties of the
 * Person class will not be shown, as no TableColumns are defined.
 *
 * &lt;h3&gt;TableView support for classes that don't contain properties&lt;/h3&gt;
 *
 * &lt;p&gt;The code shown above is the shortest possible code for creating a TableView
 * when the domain objects are designed with JavaFX properties in mind
 * (additionally, {@link javafx.scene.control.cell.PropertyValueFactory} supports
 * normal JavaBean properties too, although there is a caveat to this, so refer
 * to the class documentation for more information). When this is not the case,
 * it is necessary to provide a custom cell value factory. More information
 * about cell value factories can be found in the {@link TableColumn} API
 * documentation, but briefly, here is how a TableColumn could be specified:
 *
 * &lt;pre&gt;
 * {@code
 * firstNameCol.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;Person, String&gt;, ObservableValue&lt;String&gt;&gt;() {
 *     public ObservableValue&lt;String&gt; call(CellDataFeatures&lt;Person, String&gt; p) {
 *         // p.getValue() returns the Person instance for a particular TableView row
 *         return p.getValue().firstNameProperty();
 *     }
 * });
 *
 * // or with a lambda expression:
 * firstNameCol.setCellValueFactory(p -&gt; p.getValue().firstNameProperty());
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;TableView Selection / Focus APIs&lt;/h3&gt;
 * &lt;p&gt;To track selection and focus, it is necessary to become familiar with the
 * {@link SelectionModel} and {@link FocusModel} classes. A TableView has at most
 * one instance of each of these classes, available from
 * {@link #selectionModelProperty() selectionModel} and
 * {@link #focusModelProperty() focusModel} properties respectively.
 * Whilst it is possible to use this API to set a new selection model, in
 * most circumstances this is not necessary - the default selection and focus
 * models should work in most circumstances.
 *
 * &lt;p&gt;The default {@link SelectionModel} used when instantiating a TableView is
 * an implementation of the {@link MultipleSelectionModel} abstract class.
 * However, as noted in the API documentation for
 * the {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 * property, the default value is {@link SelectionMode#SINGLE}. To enable
 * multiple selection in a default TableView instance, it is therefore necessary
 * to do the following:
 *
 * &lt;pre&gt;
 * {@code
 * tableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}&lt;/pre&gt;
 *
 * &lt;h3&gt;Customizing TableView Visuals&lt;/h3&gt;
 * &lt;p&gt;The visuals of the TableView can be entirely customized by replacing the
 * default {@link #rowFactoryProperty() row factory}. A row factory is used to
 * generate {@link TableRow} instances, which are used to represent an entire
 * row in the TableView.
 *
 * &lt;p&gt;In many cases, this is not what is desired however, as it is more commonly
 * the case that cells be customized on a per-column basis, not a per-row basis.
 * It is therefore important to note that a {@link TableRow} is not a
 * {@link TableCell}. A  {@link TableRow} is simply a container for zero or more
 * {@link TableCell}, and in most circumstances it is more likely that you'll
 * want to create custom TableCells, rather than TableRows. The primary use case
 * for creating custom TableRow instances would most probably be to introduce
 * some form of column spanning support.
 *
 * &lt;p&gt;You can create custom {@link TableCell} instances per column by assigning
 * the appropriate function to the TableColumn
 * {@link TableColumn#cellFactoryProperty() cell factory} property.
 *
 * &lt;p&gt;See the {@link Cell} class documentation for a more complete
 * description of how to write custom Cells.
 *
 * &lt;h3&gt;Sorting&lt;/h3&gt;
 * &lt;p&gt;Prior to JavaFX 8.0, the TableView control would treat the
 * {@link #getItems() items} list as the view model, meaning that any changes to
 * the list would be immediately reflected visually. TableView would also modify
 * the order of this list directly when a user initiated a sort. This meant that
 * (again, prior to JavaFX 8.0) it was not possible to have the TableView return
 * to an unsorted state (after iterating through ascending and descending
 * orders).&lt;/p&gt;
 *
 * &lt;p&gt;Starting with JavaFX 8.0 (and the introduction of {@link SortedList}), it
 * is now possible to have the collection return to the unsorted state when
 * there are no columns as part of the TableView
 * {@link #getSortOrder() sort order}. To do this, you must create a SortedList
 * instance, and bind its
 * {@link javafx.collections.transformation.SortedList#comparatorProperty() comparator}
 * property to the TableView {@link #comparatorProperty() comparator} property,
 * list so:&lt;/p&gt;
 *
 * &lt;pre&gt;
 * {@code
 * // create a SortedList based on the provided ObservableList
 * SortedList sortedList = new SortedList(FXCollections.observableArrayList(2, 1, 3));
 *
 * // create a TableView with the sorted list set as the items it will show
 * final TableView&lt;Integer&gt; tableView = new TableView&lt;&gt;(sortedList);
 *
 * // bind the sortedList comparator to the TableView comparator
 * sortedList.comparatorProperty().bind(tableView.comparatorProperty());
 *
 * // Don't forget to define columns!
 * }&lt;/pre&gt;
 *
 * &lt;h3&gt;Editing&lt;/h3&gt;
 * &lt;p&gt;This control supports inline editing of values, and this section attempts to
 * give an overview of the available APIs and how you should use them.&lt;/p&gt;
 *
 * &lt;p&gt;Firstly, cell editing most commonly requires a different user interface
 * than when a cell is not being edited. This is the responsibility of the
 * {@link Cell} implementation being used. For TableView, it is highly
 * recommended that editing be
 * {@link javafx.scene.control.TableColumn#cellFactoryProperty() per-TableColumn},
 * rather than {@link #rowFactoryProperty() per row}, as more often than not
 * you want users to edit each column value differently, and this approach allows
 * for editors specific to each column. It is your choice whether the cell is
 * permanently in an editing state (e.g. this is common for {@link CheckBox} cells),
 * or to switch to a different UI when editing begins (e.g. when a double-click
 * is received on a cell).&lt;/p&gt;
 *
 * &lt;p&gt;To know when editing has been requested on a cell,
 * simply override the {@link javafx.scene.control.Cell#startEdit()} method, and
 * update the cell {@link javafx.scene.control.Cell#textProperty() text} and
 * {@link javafx.scene.control.Cell#graphicProperty() graphic} properties as
 * appropriate (e.g. set the text to null and set the graphic to be a
 * {@link TextField}). Additionally, you should also override
 * {@link Cell#cancelEdit()} to reset the UI back to its original visual state
 * when the editing concludes. In both cases it is important that you also
 * ensure that you call the super method to have the cell perform all duties it
 * must do to enter or exit its editing mode.&lt;/p&gt;
 *
 * &lt;p&gt;Once your cell is in an editing state, the next thing you are most probably
 * interested in is how to commit or cancel the editing that is taking place. This is your
 * responsibility as the cell factory provider. Your cell implementation will know
 * when the editing is over, based on the user input (e.g. when the user presses
 * the Enter or ESC keys on their keyboard). When this happens, it is your
 * responsibility to call {@link Cell#commitEdit(Object)} or
 * {@link Cell#cancelEdit()}, as appropriate.&lt;/p&gt;
 *
 * &lt;p&gt;When you call {@link Cell#commitEdit(Object)} an event is fired to the
 * TableView, which you can observe by adding an {@link EventHandler} via
 * {@link TableColumn#setOnEditCommit(javafx.event.EventHandler)}. Similarly,
 * you can also observe edit events for
 * {@link TableColumn#setOnEditStart(javafx.event.EventHandler) edit start}
 * and {@link TableColumn#setOnEditCancel(javafx.event.EventHandler) edit cancel}.&lt;/p&gt;
 *
 * &lt;p&gt;By default the TableColumn edit commit handler is non-null, with a default
 * handler that attempts to overwrite the property value for the
 * item in the currently-being-edited row. It is able to do this as the
 * {@link Cell#commitEdit(Object)} method is passed in the new value, and this
 * is passed along to the edit commit handler via the
 * {@link javafx.scene.control.TableColumn.CellEditEvent CellEditEvent} that is
 * fired. It is simply a matter of calling
 * {@link javafx.scene.control.TableColumn.CellEditEvent#getNewValue()} to
 * retrieve this value.
 *
 * &lt;p&gt;It is very important to note that if you call
 * {@link TableColumn#setOnEditCommit(javafx.event.EventHandler)} with your own
 * {@link EventHandler}, then you will be removing the default handler. Unless
 * you then handle the writeback to the property (or the relevant data source),
 * nothing will happen. You can work around this by using the
 * {@link TableColumn#addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}
 * method to add a {@link TableColumn#editCommitEvent()} {@link EventType} with
 * your desired {@link EventHandler} as the second argument. Using this method,
 * you will not replace the default implementation, but you will be notified when
 * an edit commit has occurred.&lt;/p&gt;
 *
 * &lt;p&gt;Hopefully this summary answers some of the commonly asked questions.
 * Fortunately, JavaFX ships with a number of pre-built cell factories that
 * handle all the editing requirements on your behalf. You can find these
 * pre-built cell factories in the javafx.scene.control.cell package.&lt;/p&gt;
 *
 * @see TableColumn
 * @see TablePosition
 * @param &lt;S&gt; The type of the objects contained within the TableView items list.
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;items&quot;)
public class TableView&lt;S&gt; extends Control {

    /***************************************************************************
     *                                                                         *
     * Static properties and methods                                           *
     *                                                                         *
     **************************************************************************/

    // strings used to communicate via the TableView properties map between
    // the control and the skin. Because they are private here, the strings
    // are also duplicated in the TableViewSkin class - so any changes to these
    // strings must also be duplicated there
    static final String SET_CONTENT_WIDTH = &quot;TableView.contentWidth&quot;;

    /**
     * &lt;p&gt;Very simple resize policy that just resizes the specified column by the
     * provided delta and shifts all other columns (to the right of the given column)
     * further to the right (when the delta is positive) or to the left (when the
     * delta is negative).
     *
     * &lt;p&gt;It also handles the case where we have nested columns by sharing the new space,
     * or subtracting the removed space, evenly between all immediate children columns.
     * Of course, the immediate children may themselves be nested, and they would
     * then use this policy on their children.
     */
    public static final Callback&lt;ResizeFeatures, Boolean&gt; UNCONSTRAINED_RESIZE_POLICY = new Callback&lt;ResizeFeatures, Boolean&gt;() {
        @Override public String toString() {
            return &quot;unconstrained-resize&quot;;
        }

        @Override public Boolean call(ResizeFeatures prop) {
            double result = TableUtil.resize(prop.getColumn(), prop.getDelta());
            return Double.compare(result, 0.0) == 0;
        }
    };

    /**
     * &lt;p&gt;Simple policy that ensures the width of all visible leaf columns in
     * this table sum up to equal the width of the table itself.
     *
     * &lt;p&gt;When the user resizes a column width with this policy, the table automatically
     * adjusts the width of the right hand side columns. When the user increases a
     * column width, the table decreases the width of the rightmost column until it
     * reaches its minimum width. Then it decreases the width of the second
     * rightmost column until it reaches minimum width and so on. When all right
     * hand side columns reach minimum size, the user cannot increase the size of
     * resized column any more.
     */
    public static final Callback&lt;ResizeFeatures, Boolean&gt; CONSTRAINED_RESIZE_POLICY = new Callback&lt;ResizeFeatures, Boolean&gt;() {

        private boolean isFirstRun = true;

        @Override public String toString() {
            return &quot;constrained-resize&quot;;
        }

        @Override public Boolean call(ResizeFeatures prop) {
            TableView&lt;?&gt; table = prop.getTable();
            List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; visibleLeafColumns = table.getVisibleLeafColumns();
            Boolean result = TableUtil.constrainedResize(prop,
                                               isFirstRun,
                                               table.contentWidth,
                                               visibleLeafColumns);
            isFirstRun = ! isFirstRun ? false : ! result;
            return result;
        }
    };

    /**
     * The default {@link #sortPolicyProperty() sort policy} that this TableView
     * will use if no other policy is specified. The sort policy is a simple
     * {@link Callback} that accepts a TableView as the sole argument and expects
     * a Boolean response representing whether the sort succeeded or not. A Boolean
     * response of true represents success, and a response of false (or null) will
     * be considered to represent failure.
     * @since JavaFX 8.0
     */
    public static final Callback&lt;TableView, Boolean&gt; DEFAULT_SORT_POLICY = new Callback&lt;TableView, Boolean&gt;() {
        @Override public Boolean call(TableView table) {
            try {
                ObservableList&lt;?&gt; itemsList = table.getItems();
                if (itemsList instanceof SortedList) {
                    // it is the responsibility of the SortedList to bind to the
                    // comparator provided by the TableView. However, we don't
                    // want to fail the sort (which would put the UI in an
                    // inconsistent state), so we return true here, but only if
                    // the SortedList has its comparator bound to the TableView
                    // comparator property.
                    SortedList sortedList = (SortedList) itemsList;
                    boolean comparatorsBound = sortedList.comparatorProperty().
                            isEqualTo(table.comparatorProperty()).get();

                    if (! comparatorsBound) {
                        // this isn't a good situation to be in, so lets log it
                        // out in case the developer is unaware
                        if (Logging.getControlsLogger().isLoggable(Level.INFO)) {
                            String s = &quot;TableView items list is a SortedList, but the SortedList &quot; +
                                    &quot;comparator should be bound to the TableView comparator for &quot; +
                                    &quot;sorting to be enabled (e.g. &quot; +
                                    &quot;sortedList.comparatorProperty().bind(tableView.comparatorProperty());).&quot;;
                            Logging.getControlsLogger().info(s);
                        }
                    }
                    return comparatorsBound;
                } else {
                    if (itemsList == null || itemsList.isEmpty()) {
                        // sorting is not supported on null or empty lists
                        return true;
                    }

                    Comparator comparator = table.getComparator();
                    if (comparator == null) {
                        return true;
                    }

                    // otherwise we attempt to do a manual sort, and if successful
                    // we return true
                    FXCollections.sort(itemsList, comparator);
                    return true;
                }
            } catch (UnsupportedOperationException e) {
                // TODO might need to support other exception types including:
                // ClassCastException - if the class of the specified element prevents it from being added to this list
                // NullPointerException - if the specified element is null and this list does not permit null elements
                // IllegalArgumentException - if some property of this element prevents it from being added to this list

                // If we are here the list does not support sorting, so we gracefully
                // fail the sort request and ensure the UI is put back to its previous
                // state. This is handled in the code that calls the sort policy.

                return false;
            }
        }
    };



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default TableView control with no content.
     *
     * &lt;p&gt;Refer to the {@link TableView} class documentation for details on the
     * default state of other properties.
     */
    public TableView() {
        this(FXCollections.&lt;S&gt;observableArrayList());
    }

    /**
     * Creates a TableView with the content provided in the items ObservableList.
     * This also sets up an observer such that any changes to the items list
     * will be immediately reflected in the TableView itself.
     *
     * &lt;p&gt;Refer to the {@link TableView} class documentation for details on the
     * default state of other properties.
     *
     * @param items The items to insert into the TableView, and the list to watch
     *          for changes (to automatically show in the TableView).
     */
    public TableView(ObservableList&lt;S&gt; items) {
        getStyleClass().setAll(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.TABLE_VIEW);

        // we quite happily accept items to be null here
        setItems(items);

        // install default selection and focus models
        // it's unlikely this will be changed by many users.
        setSelectionModel(new TableViewArrayListSelectionModel&lt;S&gt;(this));
        setFocusModel(new TableViewFocusModel&lt;S&gt;(this));

        // we watch the columns list, such that when it changes we can update
        // the leaf columns and visible leaf columns lists (which are read-only).
        getColumns().addListener(weakColumnsObserver);

        // watch for changes to the sort order list - and when it changes run
        // the sort method.
        getSortOrder().addListener((ListChangeListener&lt;TableColumn&lt;S, ?&gt;&gt;) c -&gt; {
            doSort(TableUtil.SortEventType.SORT_ORDER_CHANGE, c);
        });

        // We're watching for changes to the content width such
        // that the resize policy can be run if necessary. This comes from
        // TreeViewSkin.
        getProperties().addListener(new MapChangeListener&lt;Object, Object&gt;() {
            @Override
            public void onChanged(Change&lt;? extends Object, ? extends Object&gt; c) {
                if (c.wasAdded() &amp;&amp; SET_CONTENT_WIDTH.equals(c.getKey())) {
                    if (c.getValueAdded() instanceof Number) {
                        setContentWidth((Double) c.getValueAdded());
                    }
                    getProperties().remove(SET_CONTENT_WIDTH);
                }
            }
        });

        isInited = true;
    }



    /***************************************************************************
     *                                                                         *
     * Instance Variables                                                      *
     *                                                                         *
     **************************************************************************/

    // this is the only publicly writable list for columns. This represents the
    // columns as they are given initially by the developer.
    private final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; columns = FXCollections.observableArrayList();

    // Finally, as convenience, we also have an observable list that contains
    // only the leaf columns that are currently visible.
    private final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; visibleLeafColumns = FXCollections.observableArrayList();
    private final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; unmodifiableVisibleLeafColumns = FXCollections.unmodifiableObservableList(visibleLeafColumns);


    // Allows for multiple column sorting based on the order of the TableColumns
    // in this observableArrayList. Each TableColumn is responsible for whether it is
    // sorted using ascending or descending order.
    private ObservableList&lt;TableColumn&lt;S,?&gt;&gt; sortOrder = FXCollections.observableArrayList();

    // width of VirtualFlow minus the vbar width
    private double contentWidth;

    // Used to minimise the amount of work performed prior to the table being
    // completely initialised. In particular it reduces the amount of column
    // resize operations that occur, which slightly improves startup time.
    private boolean isInited = false;



    /***************************************************************************
     *                                                                         *
     * Callbacks and Events                                                    *
     *                                                                         *
     **************************************************************************/

    private final ListChangeListener&lt;TableColumn&lt;S,?&gt;&gt; columnsObserver = new ListChangeListener&lt;TableColumn&lt;S,?&gt;&gt;() {
        @Override public void onChanged(Change&lt;? extends TableColumn&lt;S,?&gt;&gt; c) {
            final List&lt;TableColumn&lt;S,?&gt;&gt; columns = getColumns();

            // Fix for RT-39822 - don't allow the same column to be installed twice
            while (c.next()) {
                if (c.wasAdded()) {
                    List&lt;TableColumn&lt;S,?&gt;&gt; duplicates = new ArrayList&lt;&gt;();
                    for (TableColumn&lt;S,?&gt; addedColumn : c.getAddedSubList()) {
                        if (addedColumn == null) continue;

                        int count = 0;
                        for (TableColumn&lt;S,?&gt; column : columns) {
                            if (addedColumn == column) {
                                count++;
                            }
                        }

                        if (count &gt; 1) {
                            duplicates.add(addedColumn);
                        }
                    }

                    if (!duplicates.isEmpty()) {
                        String titleList = &quot;&quot;;
                        for (TableColumn&lt;S,?&gt; dupe : duplicates) {
                            titleList += &quot;'&quot; + dupe.getText() + &quot;', &quot;;
                        }
                        throw new IllegalStateException(&quot;Duplicate TableColumns detected in TableView columns list with titles &quot; + titleList);
                    }
                }
            }
            c.reset();

            // Fix for RT-15194: Need to remove removed columns from the
            // sortOrder list.
            List&lt;TableColumn&lt;S,?&gt;&gt; toRemove = new ArrayList&lt;&gt;();
            while (c.next()) {
                final List&lt;? extends TableColumn&lt;S, ?&gt;&gt; removed = c.getRemoved();
                final List&lt;? extends TableColumn&lt;S, ?&gt;&gt; added = c.getAddedSubList();

                if (c.wasRemoved()) {
                    toRemove.addAll(removed);
                    for (TableColumn&lt;S,?&gt; tc : removed) {
                        tc.setTableView(null);
                    }
                }

                if (c.wasAdded()) {
                    toRemove.removeAll(added);
                    for (TableColumn&lt;S,?&gt; tc : added) {
                        tc.setTableView(TableView.this);
                    }
                }

                // set up listeners
                TableUtil.removeColumnsListener(removed, weakColumnsObserver);
                TableUtil.addColumnsListener(added, weakColumnsObserver);

                TableUtil.removeTableColumnListener(c.getRemoved(),
                        weakColumnVisibleObserver,
                        weakColumnSortableObserver,
                        weakColumnSortTypeObserver,
                        weakColumnComparatorObserver);
                TableUtil.addTableColumnListener(c.getAddedSubList(),
                        weakColumnVisibleObserver,
                        weakColumnSortableObserver,
                        weakColumnSortTypeObserver,
                        weakColumnComparatorObserver);
            }

            // We don't maintain a bind for leafColumns, we simply call this update
            // function behind the scenes in the appropriate places.
            updateVisibleLeafColumns();

            sortOrder.removeAll(toRemove);

            // Fix for RT-38892.
            final TableViewFocusModel&lt;S&gt; fm = getFocusModel();
            final TableViewSelectionModel&lt;S&gt; sm = getSelectionModel();
            c.reset();

            // we need to collect together all removed and all added columns, because
            // the code below works on the actually removed columns. If we perform
            // the code within this while loop, we'll be deselecting columns that
            // should be deselected (because they have just moved place, for example).
            List&lt;TableColumn&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;();
            List&lt;TableColumn&lt;S,?&gt;&gt; added = new ArrayList&lt;&gt;();
            while (c.next()) {
                if (c.wasRemoved()) {
                    removed.addAll(c.getRemoved());
                }
                if (c.wasAdded()) {
                    added.addAll(c.getAddedSubList());
                }
            }
            removed.removeAll(added);

            // Fix for focus - we simply move focus to a cell to the left
            // of the focused cell if the focused cell was located within
            // a column that has been removed.
            if (fm != null) {
                TablePosition&lt;S, ?&gt; focusedCell = fm.getFocusedCell();
                boolean match = false;
                for (TableColumn&lt;S, ?&gt; tc : removed) {
                    match = focusedCell != null &amp;&amp; focusedCell.getTableColumn() == tc;
                    if (match) {
                        break;
                    }
                }

                if (match) {
                    int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(focusedCell.getTableColumn(), 0);
                    int newFocusColumnIndex =
                            matchingColumnIndex == 0 ? 0 :
                            Math.min(getVisibleLeafColumns().size() - 1, matchingColumnIndex - 1);
                    fm.focus(focusedCell.getRow(), getVisibleLeafColumn(newFocusColumnIndex));
                }
            }

            // Fix for selection - we remove selection from all cells that
            // were within the removed column.
            if (sm != null) {
                List&lt;TablePosition&gt; selectedCells = new ArrayList&lt;&gt;(sm.getSelectedCells());
                for (TablePosition selectedCell : selectedCells) {
                    boolean match = false;
                    for (TableColumn&lt;S, ?&gt; tc : removed) {
                        match = selectedCell != null &amp;&amp; selectedCell.getTableColumn() == tc;
                        if (match) break;
                    }

                    if (match) {
                        // we can't just use the selectedCell.getTableColumn(), as that
                        // column no longer exists and therefore its index is not correct.
                        int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(selectedCell.getTableColumn(), -1);
                        if (matchingColumnIndex == -1) continue;

                        if (sm instanceof TableViewArrayListSelectionModel) {
                            // Also, because the table column no longer exists in the columns
                            // list at this point, we can't just call:
                            // sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
                            // as the tableColumn would map to an index of -1, which means that
                            // selection will not be cleared. Instead, we have to create
                            // a new TablePosition with a fixed column index and use that.
                            TablePosition&lt;S,?&gt; fixedTablePosition =
                                    new TablePosition&lt;&gt;(TableView.this,
                                            selectedCell.getRow(),
                                            selectedCell.getTableColumn());
                            fixedTablePosition.fixedColumnIndex = matchingColumnIndex;

                            ((TableViewArrayListSelectionModel)sm).clearSelection(fixedTablePosition);
                        } else {
                            sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
                        }
                    }
                }
            }


            // update the lastKnownColumnIndex map
            lastKnownColumnIndex.clear();
            for (TableColumn&lt;S,?&gt; tc : getColumns()) {
                int index = getVisibleLeafIndex(tc);
                if (index &gt; -1) {
                    lastKnownColumnIndex.put(tc, index);
                }
            }
        }
    };

    private final WeakHashMap&lt;TableColumn&lt;S,?&gt;, Integer&gt; lastKnownColumnIndex = new WeakHashMap&lt;&gt;();

    private final InvalidationListener columnVisibleObserver = valueModel -&gt; {
        updateVisibleLeafColumns();
    };

    private final InvalidationListener columnSortableObserver = valueModel -&gt; {
        Object col = ((Property&lt;?&gt;)valueModel).getBean();
        if (! getSortOrder().contains(col)) return;
        doSort(TableUtil.SortEventType.COLUMN_SORTABLE_CHANGE, col);
    };

    private final InvalidationListener columnSortTypeObserver = valueModel -&gt; {
        Object col = ((Property&lt;?&gt;)valueModel).getBean();
        if (! getSortOrder().contains(col)) return;
        doSort(TableUtil.SortEventType.COLUMN_SORT_TYPE_CHANGE, col);
    };

    private final InvalidationListener columnComparatorObserver = valueModel -&gt; {
        Object col = ((Property&lt;?&gt;)valueModel).getBean();
        if (! getSortOrder().contains(col)) return;
        doSort(TableUtil.SortEventType.COLUMN_COMPARATOR_CHANGE, col);
    };

    /* proxy pseudo-class state change from selectionModel's cellSelectionEnabledProperty */
    private final InvalidationListener cellSelectionModelInvalidationListener = o -&gt; {
        final boolean isCellSelection = ((BooleanProperty)o).get();
        pseudoClassStateChanged(PSEUDO_CLASS_CELL_SELECTION,  isCellSelection);
        pseudoClassStateChanged(PSEUDO_CLASS_ROW_SELECTION,  !isCellSelection);
    };


    private final WeakInvalidationListener weakColumnVisibleObserver =
            new WeakInvalidationListener(columnVisibleObserver);

    private final WeakInvalidationListener weakColumnSortableObserver =
            new WeakInvalidationListener(columnSortableObserver);

<A NAME="45"></A>    private final WeakInvalidationListener weakColumnSortTypeObserver =
            new WeakInvalidationListener(columnSortTypeObserver);

    <FONT color="#79d867"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#45',2,'match31-top.html#45',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private final WeakInvalidationListener weakColumnComparatorObserver =
            new WeakInvalidationListener(columnComparatorObserver);

    private final WeakListChangeListener&lt;TableColumn&lt;S,?&gt;&gt; weakColumnsObserver =
            new WeakListChangeListener&lt;TableColumn&lt;S,?&gt;&gt;(columnsObserver);

    private final WeakInvalidationListener weakCellSelectionModelInvalidationListener =
            new WeakInvalidationListener(cellSelectionModelInvalidationListener);



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/


    // --- Items
    /**
     * The underlying data model for the TableView. Note that it has a generic
     * type that must match the type of the TableView itself.
     * @return the items property
     */
    public final ObjectProperty&lt;ObservableList&lt;S&gt;&gt; itemsProperty() { return</B></FONT> items; }
    private ObjectProperty&lt;ObservableList&lt;S&gt;&gt; items =
        new SimpleObjectProperty&lt;ObservableList&lt;S&gt;&gt;(this, &quot;items&quot;) {
            WeakReference&lt;ObservableList&lt;S&gt;&gt; oldItemsRef;

            @Override protected void invalidated() {
                final ObservableList&lt;S&gt; oldItems = oldItemsRef == null ? null : oldItemsRef.get();
                final ObservableList&lt;S&gt; newItems = getItems();

                // Fix for RT-36425
                if (newItems != null &amp;&amp; newItems == oldItems) {
                    return;
                }

                // Fix for RT-35763
                if (! (newItems instanceof SortedList)) {
                    getSortOrder().clear();
                }

                oldItemsRef = new WeakReference&lt;&gt;(newItems);
            }
        };
    public final void setItems(ObservableList&lt;S&gt; value) { itemsProperty().set(value); }
    public final ObservableList&lt;S&gt; getItems() {return items.get(); }


    // --- Table menu button visible
    private BooleanProperty tableMenuButtonVisible;
    /**
     * This controls whether a menu button is available when the user clicks
     * in a designated space within the TableView, within which is a radio menu
     * item for each TableColumn in this table. This menu allows for the user to
     * show and hide all TableColumns easily.
     * @return the tableMenuButtonVisible property
     */
    public final BooleanProperty tableMenuButtonVisibleProperty() {
        if (tableMenuButtonVisible == null) {
            tableMenuButtonVisible = new SimpleBooleanProperty(this, &quot;tableMenuButtonVisible&quot;);
        }
        return tableMenuButtonVisible;
    }
    public final void setTableMenuButtonVisible (boolean value) {
        tableMenuButtonVisibleProperty().set(value);
    }
    public final boolean isTableMenuButtonVisible() {
        return tableMenuButtonVisible == null ? false : tableMenuButtonVisible.get();
    }


    // --- Column Resize Policy
    private ObjectProperty&lt;Callback&lt;ResizeFeatures, Boolean&gt;&gt; columnResizePolicy;
    public final void setColumnResizePolicy(Callback&lt;ResizeFeatures, Boolean&gt; callback) {
        columnResizePolicyProperty().set(callback);
    }
    public final Callback&lt;ResizeFeatures, Boolean&gt; getColumnResizePolicy() {
        return columnResizePolicy == null ? UNCONSTRAINED_RESIZE_POLICY : columnResizePolicy.get();
    }

    /**
     * This is the function called when the user completes a column-resize
     * operation. The two most common policies are available as static functions
     * in the TableView class: {@link #UNCONSTRAINED_RESIZE_POLICY} and
     * {@link #CONSTRAINED_RESIZE_POLICY}.
     * @return columnResizePolicy property
     */
    public final ObjectProperty&lt;Callback&lt;ResizeFeatures, Boolean&gt;&gt; columnResizePolicyProperty() {
        if (columnResizePolicy == null) {
            columnResizePolicy = new SimpleObjectProperty&lt;Callback&lt;ResizeFeatures, Boolean&gt;&gt;(this, &quot;columnResizePolicy&quot;, UNCONSTRAINED_RESIZE_POLICY) {
                private Callback&lt;ResizeFeatures, Boolean&gt; oldPolicy;

                @Override protected void invalidated() {
                    if (isInited) {
                        get().call(new ResizeFeatures(TableView.this, null, 0.0));

                        if (oldPolicy != null) {
                            PseudoClass state = PseudoClass.getPseudoClass(oldPolicy.toString());
                            pseudoClassStateChanged(state, false);
                        }
                        if (get() != null) {
                            PseudoClass state = PseudoClass.getPseudoClass(get().toString());
                            pseudoClassStateChanged(state, true);
                        }
                        oldPolicy = get();
                    }
                }
            };
        }
        return columnResizePolicy;
    }


    // --- Row Factory
    private ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt;&gt; rowFactory;

    /**
     * A function which produces a TableRow. The system is responsible for
     * reusing TableRows. Return from this function a TableRow which
     * might be usable for representing a single row in a TableView.
     * &lt;p&gt;
     * Note that a TableRow is &lt;b&gt;not&lt;/b&gt; a TableCell. A TableRow is
     * simply a container for a TableCell, and in most circumstances it is more
     * likely that you'll want to create custom TableCells, rather than
     * TableRows. The primary use case for creating custom TableRow
     * instances would most probably be to introduce some form of column
     * spanning support.
     * &lt;p&gt;
     * You can create custom TableCell instances per column by assigning the
     * appropriate function to the cellFactory property in the TableColumn class.
     * @return rowFactory property
     */
    public final ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt;&gt; rowFactoryProperty() {
        if (rowFactory == null) {
            rowFactory = new SimpleObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt;&gt;(this, &quot;rowFactory&quot;);
        }
        return rowFactory;
    }
    public final void setRowFactory(Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt; value) {
        rowFactoryProperty().set(value);
    }
    public final Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt; getRowFactory() {
        return rowFactory == null ? null : rowFactory.get();
    }


    // --- Placeholder Node
    private ObjectProperty&lt;Node&gt; placeholder;
    /**
     * This Node is shown to the user when the table has no content to show.
     * This may be the case because the table model has no data in the first
     * place, that a filter has been applied to the table model, resulting
     * in there being nothing to show the user, or that there are no currently
     * visible columns.
     * @return placeholder property
     */
    public final ObjectProperty&lt;Node&gt; placeholderProperty() {
        if (placeholder == null) {
            placeholder = new SimpleObjectProperty&lt;Node&gt;(this, &quot;placeholder&quot;);
        }
        return placeholder;
    }
    public final void setPlaceholder(Node value) {
        placeholderProperty().set(value);
    }
    public final Node getPlaceholder() {
        return placeholder == null ? null : placeholder.get();
    }


    // --- Selection Model
    private ObjectProperty&lt;TableViewSelectionModel&lt;S&gt;&gt; selectionModel
            = new SimpleObjectProperty&lt;TableViewSelectionModel&lt;S&gt;&gt;(this, &quot;selectionModel&quot;) {

        TableViewSelectionModel&lt;S&gt; oldValue = null;

        @Override protected void invalidated() {

            if (oldValue != null) {
                oldValue.cellSelectionEnabledProperty().removeListener(weakCellSelectionModelInvalidationListener);

                if (oldValue instanceof TableViewArrayListSelectionModel) {
                    ((TableViewArrayListSelectionModel)oldValue).dispose();
                }
            }

            oldValue = get();

            if (oldValue != null) {
                oldValue.cellSelectionEnabledProperty().addListener(weakCellSelectionModelInvalidationListener);
                // fake an invalidation to ensure updated pseudo-class state
                weakCellSelectionModelInvalidationListener.invalidated(oldValue.cellSelectionEnabledProperty());
            }
        }
    };

    /**
     * The SelectionModel provides the API through which it is possible
     * to select single or multiple items within a TableView, as  well as inspect
     * which items have been selected by the user. Note that it has a generic
     * type that must match the type of the TableView itself.
     * @return selectionModel property
     */
    public final ObjectProperty&lt;TableViewSelectionModel&lt;S&gt;&gt; selectionModelProperty() {
        return selectionModel;
    }
    public final void setSelectionModel(TableViewSelectionModel&lt;S&gt; value) {
        selectionModelProperty().set(value);
    }

    public final TableViewSelectionModel&lt;S&gt; getSelectionModel() {
        return selectionModel.get();
    }


    // --- Focus Model
    private ObjectProperty&lt;TableViewFocusModel&lt;S&gt;&gt; focusModel;
    public final void setFocusModel(TableViewFocusModel&lt;S&gt; value) {
        focusModelProperty().set(value);
    }
    public final TableViewFocusModel&lt;S&gt; getFocusModel() {
        return focusModel == null ? null : focusModel.get();
    }
    /**
     * Represents the currently-installed {@link TableViewFocusModel} for this
     * TableView. Under almost all circumstances leaving this as the default
     * focus model will suffice.
     * @return focusModel property
     */
    public final ObjectProperty&lt;TableViewFocusModel&lt;S&gt;&gt; focusModelProperty() {
        if (focusModel == null) {
            focusModel = new SimpleObjectProperty&lt;TableViewFocusModel&lt;S&gt;&gt;(this, &quot;focusModel&quot;);
        }
        return focusModel;
    }


//    // --- Span Model
//    private ObjectProperty&lt;SpanModel&lt;S&gt;&gt; spanModel
//            = new SimpleObjectProperty&lt;SpanModel&lt;S&gt;&gt;(this, &quot;spanModel&quot;) {
//
//        @Override protected void invalidated() {
//            ObservableList&lt;String&gt; styleClass = getStyleClass();
//            if (getSpanModel() == null) {
//                styleClass.remove(CELL_SPAN_TABLE_VIEW_STYLE_CLASS);
//            } else if (! styleClass.contains(CELL_SPAN_TABLE_VIEW_STYLE_CLASS)) {
//                styleClass.add(CELL_SPAN_TABLE_VIEW_STYLE_CLASS);
//            }
//        }
//    };
//
//    public final ObjectProperty&lt;SpanModel&lt;S&gt;&gt; spanModelProperty() {
//        return spanModel;
//    }
//    public final void setSpanModel(SpanModel&lt;S&gt; value) {
//        spanModelProperty().set(value);
//    }
//
//    public final SpanModel&lt;S&gt; getSpanModel() {
//        return spanModel.get();
//    }

    // --- Editable
    private BooleanProperty editable;
    public final void setEditable(boolean value) {
        editableProperty().set(value);
    }
    public final boolean isEditable() {
        return editable == null ? false : editable.get();
    }
    /**
     * Specifies whether this TableView is editable - only if the TableView, the
     * TableColumn (if applicable) and the TableCells within it are both
     * editable will a TableCell be able to go into their editing state.
     * @return the editable property
     */
    public final BooleanProperty editableProperty() {
        if (editable == null) {
            editable = new SimpleBooleanProperty(this, &quot;editable&quot;, false);
        }
        return editable;
    }


    // --- Fixed cell size
    private DoubleProperty fixedCellSize;

    /**
     * Sets the new fixed cell size for this control. Any value greater than
     * zero will enable fixed cell size mode, whereas a zero or negative value
     * (or Region.USE_COMPUTED_SIZE) will be used to disabled fixed cell size
     * mode.
     *
     * @param value The new fixed cell size value, or a value less than or equal
     *              to zero (or Region.USE_COMPUTED_SIZE) to disable.
     * @since JavaFX 8.0
     */
    public final void setFixedCellSize(double value) {
        fixedCellSizeProperty().set(value);
    }

    /**
     * Returns the fixed cell size value. A value less than or equal to zero is
     * used to represent that fixed cell size mode is disabled, and a value
     * greater than zero represents the size of all cells in this control.
     *
     * @return A double representing the fixed cell size of this control, or a
     *      value less than or equal to zero if fixed cell size mode is disabled.
     * @since JavaFX 8.0
     */
    public final double getFixedCellSize() {
        return fixedCellSize == null ? Region.USE_COMPUTED_SIZE : fixedCellSize.get();
    }
    /**
     * Specifies whether this control has cells that are a fixed height (of the
     * specified value). If this value is less than or equal to zero,
     * then all cells are individually sized and positioned. This is a slow
     * operation. Therefore, when performance matters and developers are not
     * dependent on variable cell sizes it is a good idea to set the fixed cell
     * size value. Generally cells are around 24px, so setting a fixed cell size
     * of 24 is likely to result in very little difference in visuals, but a
     * improvement to performance.
     *
     * &lt;p&gt;To set this property via CSS, use the -fx-fixed-cell-size property.
     * This should not be confused with the -fx-cell-size property. The difference
     * between these two CSS properties is that -fx-cell-size will size all
     * cells to the specified size, but it will not enforce that this is the
     * only size (thus allowing for variable cell sizes, and preventing the
     * performance gains from being possible). Therefore, when performance matters
     * use -fx-fixed-cell-size, instead of -fx-cell-size. If both properties are
     * specified in CSS, -fx-fixed-cell-size takes precedence.&lt;/p&gt;
     *
     * @return fixedCellSize property
     * @since JavaFX 8.0
     */
    public final DoubleProperty fixedCellSizeProperty() {
        if (fixedCellSize == null) {
            fixedCellSize = new StyleableDoubleProperty(Region.USE_COMPUTED_SIZE) {
                @Override public CssMetaData&lt;TableView&lt;?&gt;,Number&gt; getCssMetaData() {
                    return StyleableProperties.FIXED_CELL_SIZE;
                }

                @Override public Object getBean() {
                    return TableView.this;
                }

                @Override public String getName() {
                    return &quot;fixedCellSize&quot;;
                }
            };
        }
        return fixedCellSize;
    }


    // --- Editing Cell
    private ReadOnlyObjectWrapper&lt;TablePosition&lt;S,?&gt;&gt; editingCell;
    private void setEditingCell(TablePosition&lt;S,?&gt; value) {
        editingCellPropertyImpl().set(value);
    }
    public final TablePosition&lt;S,?&gt; getEditingCell() {
        return editingCell == null ? null : editingCell.get();
    }

    /**
     * Represents the current cell being edited, or null if
     * there is no cell being edited.
     * @return the editingCell property
     */
    public final ReadOnlyObjectProperty&lt;TablePosition&lt;S,?&gt;&gt; editingCellProperty() {
        return editingCellPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyObjectWrapper&lt;TablePosition&lt;S,?&gt;&gt; editingCellPropertyImpl() {
        if (editingCell == null) {
            editingCell = new ReadOnlyObjectWrapper&lt;TablePosition&lt;S,?&gt;&gt;(this, &quot;editingCell&quot;);
        }
        return editingCell;
    }


    // --- Comparator (built via sortOrder list, so read-only)
    /**
     * The comparator property is a read-only property that is representative of the
     * current state of the {@link #getSortOrder() sort order} list. The sort
     * order list contains the columns that have been added to it either programmatically
     * or via a user clicking on the headers themselves.
     * @since JavaFX 8.0
     */
    private ReadOnlyObjectWrapper&lt;Comparator&lt;S&gt;&gt; comparator;
    private void setComparator(Comparator&lt;S&gt; value) {
        comparatorPropertyImpl().set(value);
    }
    public final Comparator&lt;S&gt; getComparator() {
        return comparator == null ? null : comparator.get();
    }
    public final ReadOnlyObjectProperty&lt;Comparator&lt;S&gt;&gt; comparatorProperty() {
        return comparatorPropertyImpl().getReadOnlyProperty();
    }
    private ReadOnlyObjectWrapper&lt;Comparator&lt;S&gt;&gt; comparatorPropertyImpl() {
        if (comparator == null) {
            comparator = new ReadOnlyObjectWrapper&lt;Comparator&lt;S&gt;&gt;(this, &quot;comparator&quot;);
        }
        return comparator;
    }


    // --- sortPolicy
    /**
     * The sort policy specifies how sorting in this TableView should be performed.
     * For example, a basic sort policy may just call
     * {@code FXCollections.sort(tableView.getItems())}, whereas a more advanced
     * sort policy may call to a database to perform the necessary sorting on the
     * server-side.
     *
     * &lt;p&gt;TableView ships with a {@link TableView#DEFAULT_SORT_POLICY default
     * sort policy} that does precisely as mentioned above: it simply attempts
     * to sort the items list in-place.
     *
     * &lt;p&gt;It is recommended that rather than override the {@link TableView#sort() sort}
     * method that a different sort policy be provided instead.
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, Boolean&gt;&gt; sortPolicy;
    public final void setSortPolicy(Callback&lt;TableView&lt;S&gt;, Boolean&gt; callback) {
        sortPolicyProperty().set(callback);
    }
    @SuppressWarnings(&quot;unchecked&quot;)
    public final Callback&lt;TableView&lt;S&gt;, Boolean&gt; getSortPolicy() {
        return sortPolicy == null ?
                (Callback&lt;TableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY :
                sortPolicy.get();
    }
    @SuppressWarnings(&quot;unchecked&quot;)
    public final ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, Boolean&gt;&gt; sortPolicyProperty() {
        if (sortPolicy == null) {
            sortPolicy = new SimpleObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, Boolean&gt;&gt;(
                    this, &quot;sortPolicy&quot;, (Callback&lt;TableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY) {
                @Override protected void invalidated() {
                    sort();
                }
            };
        }
        return sortPolicy;
    }


    // onSort
    /**
     * Called when there's a request to sort the control.
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt;&gt; onSort;

    public void setOnSort(EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; value) {
        onSortProperty().set(value);
    }

    public EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; getOnSort() {
        if( onSort != null ) {
            return onSort.get();
        }
        return null;
    }

    public ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt;&gt; onSortProperty() {
        if( onSort == null ) {
            onSort = new ObjectPropertyBase&lt;EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt;&gt;() {
                @Override protected void invalidated() {
                    EventType&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; eventType = SortEvent.sortEvent();
                    EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; eventHandler = get();
                    setEventHandler(eventType, eventHandler);
                }

                @Override public Object getBean() {
                    return TableView.this;
                }

                @Override public String getName() {
                    return &quot;onSort&quot;;
                }
            };
        }
        return onSort;
    }


    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/
    /**
     * The TableColumns that are part of this TableView. As the user reorders
     * the TableView columns, this list will be updated to reflect the current
     * visual ordering.
     *
     * &lt;p&gt;Note: to display any data in a TableView, there must be at least one
     * TableColumn in this ObservableList.&lt;/p&gt;
     * @return the columns
     */
    public final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; getColumns() {
        return columns;
    }

    /**
     * The sortOrder list defines the order in which {@link TableColumn} instances
     * are sorted. An empty sortOrder list means that no sorting is being applied
     * on the TableView. If the sortOrder list has one TableColumn within it,
     * the TableView will be sorted using the
     * {@link TableColumn#sortTypeProperty() sortType} and
     * {@link TableColumn#comparatorProperty() comparator} properties of this
     * TableColumn (assuming
     * {@link TableColumn#sortableProperty() TableColumn.sortable} is true).
     * If the sortOrder list contains multiple TableColumn instances, then
     * the TableView is firstly sorted based on the properties of the first
     * TableColumn. If two elements are considered equal, then the second
     * TableColumn in the list is used to determine ordering. This repeats until
     * the results from all TableColumn comparators are considered, if necessary.
     *
     * @return An ObservableList containing zero or more TableColumn instances.
     */
    public final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; getSortOrder() {
        return sortOrder;
    }

    /**
     * Scrolls the TableView so that the given index is visible within the viewport.
     * @param index The index of an item that should be visible to the user.
     */
    public void scrollTo(int index) {
       ControlUtils.scrollToIndex(this, index);
    }

    /**
     * Scrolls the TableView so that the given object is visible within the viewport.
     * @param object The object that should be visible to the user.
     * @since JavaFX 8.0
     */
    public void scrollTo(S object) {
        if( getItems() != null ) {
            int idx = getItems().indexOf(object);
            if( idx &gt;= 0 ) {
                ControlUtils.scrollToIndex(this, idx);
            }
        }
    }

    /**
     * Called when there's a request to scroll an index into view using {@link #scrollTo(int)}
     * or {@link #scrollTo(Object)}
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollTo;

    public void setOnScrollTo(EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; value) {
        onScrollToProperty().set(value);
    }

    public EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; getOnScrollTo() {
        if( onScrollTo != null ) {
            return onScrollTo.get();
        }
        return null;
    }

    public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollToProperty() {
        if( onScrollTo == null ) {
            onScrollTo = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt;() {
                @Override
                protected void invalidated() {
                    setEventHandler(ScrollToEvent.scrollToTopIndex(), get());
                }
                @Override
                public Object getBean() {
                    return TableView.this;
                }

                @Override
                public String getName() {
                    return &quot;onScrollTo&quot;;
                }
            };
        }
        return onScrollTo;
    }

    /**
     * Scrolls the TableView so that the given column is visible within the viewport.
     * @param column The column that should be visible to the user.
     * @since JavaFX 8.0
     */
    public void scrollToColumn(TableColumn&lt;S, ?&gt; column) {
        ControlUtils.scrollToColumn(this, column);
    }

    /**
     * Scrolls the TableView so that the given index is visible within the viewport.
     * @param columnIndex The index of a column that should be visible to the user.
     * @since JavaFX 8.0
     */
    public void scrollToColumnIndex(int columnIndex) {
        if( getColumns() != null ) {
            ControlUtils.scrollToColumn(this, getColumns().get(columnIndex));
        }
    }

    /**
     * Called when there's a request to scroll a column into view using {@link #scrollToColumn(TableColumn)}
     * or {@link #scrollToColumnIndex(int)}
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumn;

    public void setOnScrollToColumn(EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt; value) {
        onScrollToColumnProperty().set(value);
    }

    public EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt; getOnScrollToColumn() {
        if( onScrollToColumn != null ) {
            return onScrollToColumn.get();
        }
        return null;
    }

    public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumnProperty() {
        if( onScrollToColumn == null ) {
            onScrollToColumn = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt;&gt;() {
                @Override protected void invalidated() {
                    EventType&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt; type = ScrollToEvent.scrollToColumn();
                    setEventHandler(type, get());
                }

                @Override public Object getBean() {
                    return TableView.this;
                }

                @Override public String getName() {
                    return &quot;onScrollToColumn&quot;;
                }
            };
        }
        return onScrollToColumn;
    }

    /**
     * Applies the currently installed resize policy against the given column,
     * resizing it based on the delta value provided.
     * @param column the column
     * @param delta the delta
     * @return true if column resize is allowed
     */
    public boolean resizeColumn(TableColumn&lt;S,?&gt; column, double delta) {
        if (column == null || Double.compare(delta, 0.0) == 0) return false;

        boolean allowed = getColumnResizePolicy().call(new ResizeFeatures&lt;S&gt;(TableView.this, column, delta));
        if (!allowed) return false;

        return true;
    }

    /**
     * Causes the cell at the given row/column view indexes to switch into
     * its editing state, if it is not already in it, and assuming that the
     * TableView and column are also editable.
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method will cancel editing if the given row
     * value is less than zero and the given column is null.&lt;/p&gt;
     * @param row the row
     * @param column the column
     */
    public void edit(int row, TableColumn&lt;S,?&gt; column) {
        if (!isEditable() || (column != null &amp;&amp; ! column.isEditable())) {
            return;
        }

        if (row &lt; 0 &amp;&amp; column == null) {
            setEditingCell(null);
        } else {
            setEditingCell(new TablePosition&lt;&gt;(this, row, column));
        }
    }

    /**
     * Returns an unmodifiable list containing the currently visible leaf columns.
     * @return an unmodifiable list containing the currently visible leaf columns
     */
    public ObservableList&lt;TableColumn&lt;S,?&gt;&gt; getVisibleLeafColumns() {
        return unmodifiableVisibleLeafColumns;
    }

    /**
     * Returns the position of the given column, relative to all other
     * visible leaf columns.
     * @param column the column
     * @return the position of the given column, relative to all other
     * visible leaf columns
     */
    public int getVisibleLeafIndex(TableColumn&lt;S,?&gt; column) {
        return visibleLeafColumns.indexOf(column);
    }

    /**
     * Returns the TableColumn in the given column index, relative to all other
     * visible leaf columns.
     * @param column the column
     * @return the TableColumn in the given column index, relative to all other
     * visible leaf columns
     */
    public TableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
        if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
        return visibleLeafColumns.get(column);
    }

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new TableViewSkin&lt;S&gt;(this);
    }

    /**
     * The sort method forces the TableView to re-run its sorting algorithm. More
     * often than not it is not necessary to call this method directly, as it is
     * automatically called when the {@link #getSortOrder() sort order},
     * {@link #sortPolicyProperty() sort policy}, or the state of the
     * TableColumn {@link TableColumn#sortTypeProperty() sort type} properties
     * change. In other words, this method should only be called directly when
     * something external changes and a sort is required.
     * @since JavaFX 8.0
     */
    public void sort() {
        final ObservableList&lt;? extends TableColumnBase&lt;S,?&gt;&gt; sortOrder = getSortOrder();

        // update the Comparator property
        final Comparator&lt;S&gt; oldComparator = getComparator();
        setComparator(sortOrder.isEmpty() ? null : new TableColumnComparator(sortOrder));

        // fire the onSort event and check if it is consumed, if
        // so, don't run the sort
        SortEvent&lt;TableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TableView.this, TableView.this);
        fireEvent(sortEvent);
        if (sortEvent.isConsumed()) {
            // if the sort is consumed we could back out the last action (the code
            // is commented out right below), but we don't as we take it as a
            // sign that the developer has decided to handle the event themselves.

            // sortLock = true;
            // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
            // sortLock = false;
            return;
        }

        final List&lt;TablePosition&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
        final int itemCount = prevState.size();

        // we set makeAtomic to true here, so that we don't fire intermediate
        // sort events - instead we send a single permutation event at the end
        // of this method.
        getSelectionModel().startAtomic();

        // get the sort policy and run it
        Callback&lt;TableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
        if (sortPolicy == null) return;
        Boolean success = sortPolicy.call(this);

        getSelectionModel().stopAtomic();

        if (success == null || ! success) {
            // the sort was a failure. Need to backout if possible
            sortLock = true;
            TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
            setComparator(oldComparator);
            sortLock = false;
        } else {
            // sorting was a success, now we possibly fire an event on the
            // selection model that the items list has 'permutated' to a new ordering

            // FIXME we should support alternative selection model implementations!
            if (getSelectionModel() instanceof TableViewArrayListSelectionModel) {
                final TableViewArrayListSelectionModel&lt;S&gt; sm = (TableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
                final ObservableList&lt;TablePosition&lt;S,?&gt;&gt; newState = (ObservableList&lt;TablePosition&lt;S,?&gt;&gt;)(Object)sm.getSelectedCells();

                List&lt;TablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
                for (int i = 0; i &lt; itemCount; i++) {
                    TablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
                    if (!newState.contains(prevItem)) {
                        removed.add(prevItem);
                    }
                }

                if (!removed.isEmpty()) {
                    // the sort operation effectively permutates the selectedCells list,
                    // but we cannot fire a permutation event as we are talking about
                    // TablePosition's changing (which may reside in the same list
                    // position before and after the sort). Therefore, we need to fire
                    // a single add/remove event to cover the added and removed positions.
                    ListChangeListener.Change&lt;TablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(0, itemCount, removed, newState);
                    sm.fireCustomSelectedCellsListChangeEvent(c);
                }
            }
        }
    }

    /**
     * Calling {@code refresh()} forces the TableView control to recreate and
     * repopulate the cells necessary to populate the visual bounds of the control.
     * In other words, this forces the TableView to update what it is showing to
     * the user. This is useful in cases where the underlying data source has
     * changed in a way that is not observed by the TableView itself.
     *
     * @since JavaFX 8u60
     */
    public void refresh() {
        getProperties().put(Properties.RECREATE, Boolean.TRUE);
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private boolean sortLock = false;
    private TableUtil.SortEventType lastSortEventType = null;
    private Object[] lastSortEventSupportInfo = null;

    private void doSort(final TableUtil.SortEventType sortEventType, final Object... supportInfo) {
        if (sortLock) {
            return;
        }

        this.lastSortEventType = sortEventType;
        this.lastSortEventSupportInfo = supportInfo;
        sort();
        this.lastSortEventType = null;
        this.lastSortEventSupportInfo = null;
    }


    // --- Content width
    private void setContentWidth(double contentWidth) {
        this.contentWidth = contentWidth;
        if (isInited) {
            // sometimes the current column resize policy will have to modify the
            // column width of all columns in the table if the table width changes,
            // so we short-circuit the resize function and just go straight there
            // with a null TableColumn, which indicates to the resize policy function
            // that it shouldn't actually do anything specific to one column.
            getColumnResizePolicy().call(new ResizeFeatures&lt;S&gt;(TableView.this, null, 0.0));
        }
    }

    /**
     * Recomputes the currently visible leaf columns in this TableView.
     */
    private void updateVisibleLeafColumns() {
        // update visible leaf columns list
        List&lt;TableColumn&lt;S,?&gt;&gt; cols = new ArrayList&lt;TableColumn&lt;S,?&gt;&gt;();
        buildVisibleLeafColumns(getColumns(), cols);
        visibleLeafColumns.setAll(cols);

        // sometimes the current column resize policy will have to modify the
        // column width of all columns in the table if the table width changes,
        // so we short-circuit the resize function and just go straight there
        // with a null TableColumn, which indicates to the resize policy function
        // that it shouldn't actually do anything specific to one column.
        getColumnResizePolicy().call(new ResizeFeatures&lt;S&gt;(TableView.this, null, 0.0));
    }

    private void buildVisibleLeafColumns(List&lt;TableColumn&lt;S,?&gt;&gt; cols, List&lt;TableColumn&lt;S,?&gt;&gt; vlc) {
        for (TableColumn&lt;S,?&gt; c : cols) {
            if (c == null) continue;

            boolean hasChildren = ! c.getColumns().isEmpty();

            if (hasChildren) {
                buildVisibleLeafColumns(c.getColumns(), vlc);
            } else if (c.isVisible()) {
                vlc.add(c);
            }
        }
    }



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;table-view&quot;;

    private static final PseudoClass PSEUDO_CLASS_CELL_SELECTION =
            PseudoClass.getPseudoClass(&quot;cell-selection&quot;);
    private static final PseudoClass PSEUDO_CLASS_ROW_SELECTION =
            PseudoClass.getPseudoClass(&quot;row-selection&quot;);

    private static class StyleableProperties {
        private static final CssMetaData&lt;TableView&lt;?&gt;,Number&gt; FIXED_CELL_SIZE =
                new CssMetaData&lt;TableView&lt;?&gt;,Number&gt;(&quot;-fx-fixed-cell-size&quot;,
                                                    SizeConverter.getInstance(),
                                                    Region.USE_COMPUTED_SIZE) {

                    @Override public Double getInitialValue(TableView&lt;?&gt; node) {
                        return node.getFixedCellSize();
                    }

                    @Override public boolean isSettable(TableView&lt;?&gt; n) {
                        return n.fixedCellSize == null || !n.fixedCellSize.isBound();
                    }

                    @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(TableView&lt;?&gt; n) {
                        return (StyleableProperty&lt;Number&gt;) n.fixedCellSizeProperty();
                    }
                };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                    new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
            styleables.add(FIXED_CELL_SIZE);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
        return getClassCssMetaData();
    }



    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case COLUMN_COUNT: return getVisibleLeafColumns().size();
            case ROW_COUNT: return getItems().size();
            case SELECTED_ITEMS: {
                // TableViewSkin returns TableRows back to TableView.
                // TableRowSkin returns TableCells back to TableRow.
                @SuppressWarnings(&quot;unchecked&quot;)
                ObservableList&lt;TableRow&lt;S&gt;&gt; rows = (ObservableList&lt;TableRow&lt;S&gt;&gt;)super.queryAccessibleAttribute(attribute, parameters);
                List&lt;Node&gt; selection = new ArrayList&lt;&gt;();
                for (TableRow&lt;S&gt; row : rows) {
                    @SuppressWarnings(&quot;unchecked&quot;)
                    ObservableList&lt;Node&gt; cells = (ObservableList&lt;Node&gt;)row.queryAccessibleAttribute(attribute, parameters);
                    if (cells != null) selection.addAll(cells);
                }
                return FXCollections.observableArrayList(selection);
            }
            case FOCUS_ITEM: {
                Node row = (Node)super.queryAccessibleAttribute(attribute, parameters);
                if (row == null) return null;
                Node cell = (Node)row.queryAccessibleAttribute(attribute, parameters);
                /* cell equals to null means the row is a placeholder node */
                return cell != null ?  cell : row;
            }
            case CELL_AT_ROW_COLUMN: {
                @SuppressWarnings(&quot;unchecked&quot;)
                TableRow&lt;S&gt; row = (TableRow&lt;S&gt;)super.queryAccessibleAttribute(attribute, parameters);
                return row != null ? row.queryAccessibleAttribute(attribute, parameters) : null;
            }
            case MULTIPLE_SELECTION: {
                MultipleSelectionModel&lt;S&gt; sm = getSelectionModel();
                return sm != null &amp;&amp; sm.getSelectionMode() == SelectionMode.MULTIPLE;
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }


    /***************************************************************************
     *                                                                         *
     * Support Interfaces                                                      *
     *                                                                         *
     **************************************************************************/

     /**
      * An immutable wrapper class for use in the TableView
     * {@link TableView#columnResizePolicyProperty() column resize} functionality.
      * @since JavaFX 2.0
      */
     public static class ResizeFeatures&lt;S&gt; extends ResizeFeaturesBase&lt;S&gt; {
        private TableView&lt;S&gt; table;

        /**
         * Creates an instance of this class, with the provided TableView,
         * TableColumn and delta values being set and stored in this immutable
         * instance.
         *
         * @param table The TableView upon which the resize operation is occurring.
         * @param column The column upon which the resize is occurring, or null
         *      if this ResizeFeatures instance is being created as a result of a
         *      TableView resize operation.
         * @param delta The amount of horizontal space added or removed in the
         *      resize operation.
         */
        public ResizeFeatures(TableView&lt;S&gt; table, TableColumn&lt;S,?&gt; column, Double delta) {
            super(column, delta);
            this.table = table;
        }

        /**
         * Returns the column upon which the resize is occurring, or null
         * if this ResizeFeatures instance was created as a result of a
         * TableView resize operation.
         */
        @Override public TableColumn&lt;S,?&gt; getColumn() {
            return (TableColumn&lt;S,?&gt;) super.getColumn();
        }

        /**
         * Returns the TableView upon which the resize operation is occurring.
         * @return the TableView
         */
        public TableView&lt;S&gt; getTable() {
            return table;
        }
    }



    /***************************************************************************
     *                                                                         *
     * Support Classes                                                         *
     *                                                                         *
     **************************************************************************/


    /**
     * A simple extension of the {@link SelectionModel} abstract class to
     * allow for special support for TableView controls.
     * @since JavaFX 2.0
     */
    public static abstract class TableViewSelectionModel&lt;S&gt; extends TableSelectionModel&lt;S&gt; {

        /***********************************************************************
         *                                                                     *
         * Private fields                                                      *
         *                                                                     *
         **********************************************************************/

        private final TableView&lt;S&gt; tableView;

        boolean blockFocusCall = false;



        /***********************************************************************
         *                                                                     *
         * Constructors                                                        *
         *                                                                     *
         **********************************************************************/

        /**
         * Builds a default TableViewSelectionModel instance with the provided
         * TableView.
         * @param tableView The TableView upon which this selection model should
         *      operate.
         * @throws NullPointerException TableView can not be null.
         */
        public TableViewSelectionModel(final TableView&lt;S&gt; tableView) {
            if (tableView == null) {
                throw new NullPointerException(&quot;TableView can not be null&quot;);
            }

            this.tableView = tableView;
        }



        /***********************************************************************
         *                                                                     *
         * Abstract API                                                        *
         *                                                                     *
         **********************************************************************/

        /**
         * A read-only ObservableList representing the currently selected cells
         * in this TableView. Rather than directly modify this list, please
         * use the other methods provided in the TableViewSelectionModel.
         * @return a read-only ObservableList representing the currently
         * selected cells in this TableView
         */
        public abstract ObservableList&lt;TablePosition&gt; getSelectedCells();


        /***********************************************************************
         *                                                                     *
         * Generic (type erasure) bridging                                     *
         *                                                                     *
         **********************************************************************/

        // --- isSelected
        /** {@inheritDoc} */
        @Override public boolean isSelected(int row, TableColumnBase&lt;S, ?&gt; column) {
            return isSelected(row, (TableColumn&lt;S,?&gt;)column);
        }

        /**
         * Convenience function which tests whether the given row and column index
         * is currently selected in this table instance.
         * @param row the row
         * @param column the column
         * @return true if row and column index is currently selected
         */
        public abstract boolean isSelected(int row, TableColumn&lt;S, ?&gt; column);


        // --- select
        /** {@inheritDoc} */
        @Override public void select(int row, TableColumnBase&lt;S, ?&gt; column) {
            select(row, (TableColumn&lt;S,?&gt;)column);
        }

        /**
         * Selects the cell at the given row/column intersection.
         * @param row the row
         * @param column the column
         */
        public abstract void select(int row, TableColumn&lt;S, ?&gt; column);


        // --- clearAndSelect
        /** {@inheritDoc} */
        @Override public void clearAndSelect(int row, TableColumnBase&lt;S,?&gt; column) {
            clearAndSelect(row, (TableColumn&lt;S,?&gt;) column);
        }

        /**
         * Clears all selection, and then selects the cell at the given row/column
         * intersection.
         * @param row the row
         * @param column the column
         */
        public abstract void clearAndSelect(int row, TableColumn&lt;S,?&gt; column);


        // --- clearSelection
        /** {@inheritDoc} */
        @Override public void clearSelection(int row, TableColumnBase&lt;S,?&gt; column) {
            clearSelection(row, (TableColumn&lt;S,?&gt;) column);
        }

        /**
         * Removes selection from the specified row/column position (in view indexes).
         * If this particular cell (or row if the column value is -1) is not selected,
         * nothing happens.
         * @param row the row
         * @param column the column
         */
        public abstract void clearSelection(int row, TableColumn&lt;S, ?&gt; column);

        /** {@inheritDoc} */
        @Override public void selectRange(int minRow, TableColumnBase&lt;S,?&gt; minColumn,
                                          int maxRow, TableColumnBase&lt;S,?&gt; maxColumn) {
            final int minColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)minColumn);
            final int maxColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)maxColumn);
            for (int _row = minRow; _row &lt;= maxRow; _row++) {
                for (int _col = minColumnIndex; _col &lt;= maxColumnIndex; _col++) {
                    select(_row, tableView.getVisibleLeafColumn(_col));
                }
            }
        }



        /***********************************************************************
         *                                                                     *
         * Public API                                                          *
         *                                                                     *
         **********************************************************************/

        /**
         * Returns the TableView instance that this selection model is installed in.
         * @return the TableView
         */
        public TableView&lt;S&gt; getTableView() {
            return tableView;
        }

        /**
         * Convenience method that returns getTableView().getItems().
         * @return The items list of the current TableView.
         */
        protected List&lt;S&gt; getTableModel()  {
            return tableView.getItems();
        }

        /** {@inheritDoc} */
        @Override protected S getModelItem(int index) {
            if (index &lt; 0 || index &gt;= getItemCount()) return null;
            return tableView.getItems().get(index);
        }

        /** {@inheritDoc} */
        @Override protected int getItemCount() {
            return getTableModel().size();
        }

        /** {@inheritDoc} */
        @Override public void focus(int row) {
            focus(row, null);
        }

        /** {@inheritDoc} */
        @Override public int getFocusedIndex() {
            return getFocusedCell().getRow();
        }



        /***********************************************************************
         *                                                                     *
         * Private implementation                                              *
         *                                                                     *
         **********************************************************************/

        void focus(int row, TableColumn&lt;S,?&gt; column) {
            focus(new TablePosition&lt;&gt;(getTableView(), row, column));
            getTableView().notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
        }

        void focus(TablePosition&lt;S,?&gt; pos) {
            if (blockFocusCall) return;
            if (getTableView().getFocusModel() == null) return;

            getTableView().getFocusModel().focus(pos.getRow(), pos.getTableColumn());
        }

        TablePosition&lt;S,?&gt; getFocusedCell() {
            if (getTableView().getFocusModel() == null) {
                return new TablePosition&lt;&gt;(getTableView(), -1, null);
            }
            return getTableView().getFocusModel().getFocusedCell();
        }
    }



    /**
     * A primitive selection model implementation, using a List&lt;Integer&gt; to store all
     * selected indices.
     */
    // package for testing
    static class TableViewArrayListSelectionModel&lt;S&gt; extends TableViewSelectionModel&lt;S&gt; {

        private int itemCount = 0;

        private final MappingChange.Map&lt;TablePosition&lt;S,?&gt;,Integer&gt; cellToIndicesMap = f -&gt; f.getRow();

        /***********************************************************************
         *                                                                     *
         * Constructors                                                        *
         *                                                                     *
         **********************************************************************/

        public TableViewArrayListSelectionModel(final TableView&lt;S&gt; tableView) {
            super(tableView);
            this.tableView = tableView;

            this.itemsPropertyListener = new InvalidationListener() {
                private WeakReference&lt;ObservableList&lt;S&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());

                @Override public void invalidated(Observable observable) {
                    ObservableList&lt;S&gt; oldItems = weakItemsRef.get();
                    weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());
                    updateItemsObserver(oldItems, tableView.getItems());

                    ((SelectedItemsReadOnlyObservableList)getSelectedItems()).setItemsList(tableView.getItems());
                }
            };
            this.tableView.itemsProperty().addListener(itemsPropertyListener);

            selectedCellsMap = new SelectedCellsMap&lt;TablePosition&lt;S,?&gt;&gt;(this::fireCustomSelectedCellsListChangeEvent) {
                @Override public boolean isCellSelectionEnabled() {
                    return TableViewArrayListSelectionModel.this.isCellSelectionEnabled();
                }
            };

            selectedCellsSeq = new ReadOnlyUnbackedObservableList&lt;TablePosition&lt;S,?&gt;&gt;() {
                @Override public TablePosition&lt;S,?&gt; get(int i) {
                    return selectedCellsMap.get(i);
                }

                @Override public int size() {
                    return selectedCellsMap.size();
                }
            };
//            selectedCellsSeq.addListener((ListChangeListener&lt;? super TablePosition&lt;S,?&gt;&gt;) c -&gt; {
//                ControlUtils.updateSelectedIndices(this, c);
//            });


            /*
             * The following listener is used in conjunction with
             * SelectionModel.select(T obj) to allow for a developer to select
             * an item that is not actually in the data model. When this occurs,
             * we actively try to find an index that matches this object, going
             * so far as to actually watch for all changes to the items list,
             * rechecking each time.
             */

            // watching for changes to the items list content
            ObservableList&lt;S&gt; items = getTableView().getItems();
            if (items != null) {
                ((SelectedItemsReadOnlyObservableList)getSelectedItems()).setItemsList(items);
                items.addListener(weakItemsContentListener);
            }


            updateItemCount();

            updateDefaultSelection();

            cellSelectionEnabledProperty().addListener(o -&gt; {
                updateDefaultSelection();
                TableCellBehaviorBase.setAnchor(tableView, getFocusedCell(), true);
            });
        }

        private void dispose() {
            this.tableView.itemsProperty().removeListener(itemsPropertyListener);

            ObservableList&lt;S&gt; items = getTableView().getItems();
            if (items != null) {
                items.removeListener(weakItemsContentListener);
            }
        }

        private final TableView&lt;S&gt; tableView;

        final InvalidationListener itemsPropertyListener;

        final ListChangeListener&lt;S&gt; itemsContentListener = c -&gt; {
            updateItemCount();

            List&lt;S&gt; items1 = getTableModel();
            boolean doSelectionUpdate = true;

            while (c.next()) {
                if (c.wasReplaced() || c.getAddedSize() == getItemCount()) {
                    this.selectedItemChange = c;
                    updateDefaultSelection();
                    this.selectedItemChange = null;
                    return;
                }

                final S selectedItem = getSelectedItem();
                final int selectedIndex = getSelectedIndex();

                if (items1 == null || items1.isEmpty()) {
                    clearSelection();
                } else if (getSelectedIndex() == -1 &amp;&amp; getSelectedItem() != null) {
                    int newIndex = items1.indexOf(getSelectedItem());
                    if (newIndex != -1) {
                        setSelectedIndex(newIndex);
                        doSelectionUpdate = false;
                    }
                } else if (c.wasRemoved() &amp;&amp;
                        c.getRemovedSize() == 1 &amp;&amp;
                        ! c.wasAdded() &amp;&amp;
                        selectedItem != null &amp;&amp;
                        selectedItem.equals(c.getRemoved().get(0))) {
                    // Bug fix for RT-28637
                    if (getSelectedIndex() &lt; getItemCount()) {
                        final int previousRow = selectedIndex == 0 ? 0 : selectedIndex - 1;
                        S newSelectedItem = getModelItem(previousRow);
                        if (! selectedItem.equals(newSelectedItem)) {
                            clearAndSelect(previousRow);
                        }
                    }
                }
            }

            if (doSelectionUpdate) {
                updateSelection(c);
            }
        };

        final WeakListChangeListener&lt;S&gt; weakItemsContentListener
                = new WeakListChangeListener&lt;&gt;(itemsContentListener);



        /***********************************************************************
         *                                                                     *
         * Observable properties (and getters/setters)                         *
         *                                                                     *
         **********************************************************************/

        // the only 'proper' internal data structure, selectedItems and selectedIndices
        // are both 'read-only and unbacked'.
        private final SelectedCellsMap&lt;TablePosition&lt;S,?&gt;&gt; selectedCellsMap;

        // we create a ReadOnlyUnbackedObservableList of selectedCells here so
        // that we can fire custom list change events.
        private final ReadOnlyUnbackedObservableList&lt;TablePosition&lt;S,?&gt;&gt; selectedCellsSeq;
        @Override public ObservableList&lt;TablePosition&gt; getSelectedCells() {
            return (ObservableList&lt;TablePosition&gt;)(Object)selectedCellsSeq;
        }



        /***********************************************************************
         *                                                                     *
         * Internal properties                                                 *
         *                                                                     *
         **********************************************************************/

        private int previousModelSize = 0;

        // Listen to changes in the tableview items list, such that when it
        // changes we can update the selected indices list to refer to the
        // new indices.
        private void updateSelection(ListChangeListener.Change&lt;? extends S&gt; c) {
            c.reset();

            int shift = 0;
            int startRow = -1;
            while (c.next()) {
                if (c.wasReplaced()) {
                    if (c.getList().isEmpty()) {
                        // the entire items list was emptied - clear selection
                        clearSelection();
                    } else {
                        int index = getSelectedIndex();

                        if (previousModelSize == c.getRemovedSize()) {
                            // all items were removed from the model
                            clearSelection();
                        } else if (index &lt; getItemCount() &amp;&amp; index &gt;= 0) {
                            // Fix for RT-18969: the list had setAll called on it
                            // Use of makeAtomic is a fix for RT-20945
                            startAtomic();
                            clearSelection(index);
                            stopAtomic();
                            select(index);
                        } else {
                            // Fix for RT-22079
                            clearSelection();
                        }
                    }
                } else if (c.wasAdded() || c.wasRemoved()) {
                    startRow = c.getFrom();
                    shift += c.wasAdded() ? c.getAddedSize() : -c.getRemovedSize();
                } else if (c.wasPermutated()) {
                    // General approach:
                    //   -- detected a sort has happened
                    //   -- Create a permutation lookup map (1)
                    //   -- dump all the selected indices into a list (2)
                    //   -- create a list containing the new indices (3)
                    //   -- for each previously-selected index (4)
                    //     -- if index is in the permutation lookup map
                    //       -- add the new index to the new indices list
                    //   -- Perform batch selection (5)

                    startAtomic();

                    final int oldSelectedIndex = getSelectedIndex();

                    // (1)
                    int length = c.getTo() - c.getFrom();
                    HashMap&lt;Integer, Integer&gt; pMap = new HashMap&lt;&gt; (length);
                    for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
                        pMap.put(i, c.getPermutation(i));
                    }

                    // (2)
                    List&lt;TablePosition&lt;S,?&gt;&gt; selectedIndices = new ArrayList&lt;&gt;((ObservableList&lt;TablePosition&lt;S,?&gt;&gt;)(Object)getSelectedCells());

                    // (3)
                    List&lt;TablePosition&lt;S,?&gt;&gt; newIndices = new ArrayList&lt;&gt;(selectedIndices.size());

                    // (4)
                    boolean selectionIndicesChanged = false;
                    for (int i = 0; i &lt; selectedIndices.size(); i++) {
                        final TablePosition&lt;S,?&gt; oldIndex = selectedIndices.get(i);
                        final int oldRow = oldIndex.getRow();

                        if (pMap.containsKey(oldRow)) {
                            int newIndex = pMap.get(oldRow);

                            selectionIndicesChanged = selectionIndicesChanged || newIndex != oldRow;

                            newIndices.add(new TablePosition&lt;&gt;(oldIndex.getTableView(), newIndex, oldIndex.getTableColumn()));
                        }
                    }

                    if (selectionIndicesChanged) {
                        // (5)
                        quietClearSelection();
                        stopAtomic();

                        selectedCellsMap.setAll(newIndices);

                        if (oldSelectedIndex &gt;= 0 &amp;&amp; oldSelectedIndex &lt; itemCount) {
                            int newIndex = c.getPermutation(oldSelectedIndex);
                            setSelectedIndex(newIndex);
                            focus(newIndex);
                        }
                    } else {
                        stopAtomic();
                    }
                }
            }

            TablePosition&lt;S,?&gt; anchor = TableCellBehavior.getAnchor(tableView, null);
            if (shift != 0 &amp;&amp; startRow &gt;= 0 &amp;&amp; anchor != null &amp;&amp; (c.wasRemoved() || c.wasAdded())) {
                if (isSelected(anchor.getRow(), anchor.getTableColumn())) {
                    TablePosition&lt;S,?&gt; newAnchor = new TablePosition&lt;&gt;(tableView, anchor.getRow() + shift, anchor.getTableColumn());
                    TableCellBehavior.setAnchor(tableView, newAnchor, false);
                }
            }

            shiftSelection(startRow, shift, new Callback&lt;ShiftParams, Void&gt;() {
                @Override public Void call(ShiftParams param) {

                    // we make the shifts atomic, as otherwise listeners to
                    // the items / indices lists get a lot of intermediate
                    // noise. They eventually get the summary event fired
                    // from within shiftSelection, so this is ok.
                    startAtomic();

                    final int clearIndex = param.getClearIndex();
                    final int setIndex = param.getSetIndex();
                    TablePosition&lt;S,?&gt; oldTP = null;
                    if (clearIndex &gt; -1) {
                        for (int i = 0; i &lt; selectedCellsMap.size(); i++) {
                            TablePosition&lt;S,?&gt; tp = selectedCellsMap.get(i);
                            if (tp.getRow() == clearIndex) {
                                oldTP = tp;
                                selectedCellsMap.remove(tp);
                            } else if (tp.getRow() == setIndex &amp;&amp; !param.isSelected()) {
                                selectedCellsMap.remove(tp);
                            }
                        }
                    }

                    if (oldTP != null &amp;&amp; param.isSelected()) {
                        TablePosition&lt;S,?&gt; newTP = new TablePosition&lt;&gt;(
                                tableView, param.getSetIndex(), oldTP.getTableColumn());

                        selectedCellsMap.add(newTP);
                    }

                    stopAtomic();

                    return null;
                }
            });

            previousModelSize = getItemCount();
        }

        /***********************************************************************
         *                                                                     *
         * Public selection API                                                *
         *                                                                     *
         **********************************************************************/

        @Override public void clearAndSelect(int row) {
            clearAndSelect(row, null);
        }

        @Override public void clearAndSelect(int row, TableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) return;

            final TablePosition&lt;S,?&gt; newTablePosition = new TablePosition&lt;&gt;(getTableView(), row, column);
            final boolean isCellSelectionEnabled = isCellSelectionEnabled();

            // replace the anchor
            TableCellBehavior.setAnchor(tableView, newTablePosition, false);

            // firstly we make a copy of the selection, so that we can send out
            // the correct details in the selection change event.
            List&lt;TablePosition&lt;S,?&gt;&gt; previousSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());

            // secondly we check if we can short-circuit out of here because the new selection
            // equals the current selection
            final boolean wasSelected = isSelected(row, column);
            if (wasSelected &amp;&amp; previousSelection.size() == 1) {
                // before we return, we double-check that the selected item
                // is equal to the item in the given index
                TablePosition&lt;S,?&gt; selectedCell = getSelectedCells().get(0);
                if (getSelectedItem() == getModelItem(row)) {
                    if (selectedCell.getRow() == row &amp;&amp; selectedCell.getTableColumn() == column) {
                        return;
                    }
                }
            }

            // RT-32411 We used to call quietClearSelection() here, but this
            // resulted in the selectedItems and selectedIndices lists never
            // reporting that they were empty.
            // makeAtomic toggle added to resolve RT-32618
            startAtomic();

            // then clear the current selection
            clearSelection();

            // and select the new cell
            select(row, column);

            stopAtomic();


            // We remove the new selection from the list seeing as it is not removed.
            if (isCellSelectionEnabled) {
                previousSelection.remove(newTablePosition);
            } else {
                for (TablePosition&lt;S,?&gt; tp : previousSelection) {
                    if (tp.getRow() == row) {
                        previousSelection.remove(tp);
                        break;
                    }
                }
            }

            // fire off a single add/remove/replace notification (rather than
            // individual remove and add notifications) - see RT-33324
            ListChangeListener.Change&lt;TablePosition&lt;S, ?&gt;&gt; change;

            /*
             * getFrom() documentation:
             *   If wasAdded is true, the interval contains all the values that were added.
             *   If wasPermutated is true, the interval marks the values that were permutated.
             *   If wasRemoved is true and wasAdded is false, getFrom() and getTo() should
             *   return the same number - the place where the removed elements were positioned in the list.
             */
            if (wasSelected) {
                change = ControlUtils.buildClearAndSelectChange(selectedCellsSeq, previousSelection, row);
            } else {
                final int changeIndex = isCellSelectionEnabled ? 0 : Math.max(0, selectedCellsSeq.indexOf(newTablePosition));
                final int changeSize = isCellSelectionEnabled ? getSelectedCells().size() : 1;
                change = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(
                        changeIndex, changeIndex + changeSize, previousSelection, selectedCellsSeq);
//                selectedCellsSeq._beginChange();
//                selectedCellsSeq._nextAdd(changeIndex, changeIndex + changeSize);
//                selectedCellsSeq._nextRemove(changeIndex, previousSelection);
//                selectedCellsSeq._endChange();
            }
            fireCustomSelectedCellsListChangeEvent(change);
        }

        @Override public void select(int row) {
            select(row, null);
        }

        @Override
        public void select(int row, TableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) return;

            // if I'm in cell selection mode but the column is null, select each
            // of the contained cells individually
            if (isCellSelectionEnabled() &amp;&amp; column == null) {
                List&lt;TableColumn&lt;S,?&gt;&gt; columns = getTableView().getVisibleLeafColumns();
                for (int i = 0; i &lt; columns.size(); i++) {
                    select(row, columns.get(i));
                }
                return;
            }

            if (TableCellBehavior.hasDefaultAnchor(tableView)) {
                TableCellBehavior.removeAnchor(tableView);
            }

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
            }
            selectedCellsMap.add(new TablePosition&lt;&gt;(getTableView(), row, column));

            updateSelectedIndex(row);
            focus(row, column);
        }

        @Override public void select(S obj) {
            if (obj == null &amp;&amp; getSelectionMode() == SelectionMode.SINGLE) {
                clearSelection();
                return;
            }

            // We have no option but to iterate through the model and select the
            // first occurrence of the given object. Once we find the first one, we
            // don't proceed to select any others.
            S rowObj = null;
            for (int i = 0; i &lt; getItemCount(); i++) {
                rowObj = getModelItem(i);
                if (rowObj == null) continue;

                if (rowObj.equals(obj)) {
                    if (isSelected(i)) {
                        return;
                    }

                    if (getSelectionMode() == SelectionMode.SINGLE) {
                        quietClearSelection();
                    }

                    select(i);
                    return;
                }
            }

            // if we are here, we did not find the item in the entire data model.
            // Even still, we allow for this item to be set to the give object.
            // We expect that in concrete subclasses of this class we observe the
            // data model such that we check to see if the given item exists in it,
            // whilst SelectedIndex == -1 &amp;&amp; SelectedItem != null.
            setSelectedIndex(-1);
            setSelectedItem(obj);
        }

        @Override public void selectIndices(int row, int... rows) {
            if (rows == null) {
                select(row);
                return;
            }

            /*
             * Performance optimisation - if multiple selection is disabled, only
             * process the end-most row index.
             */
            int rowCount = getItemCount();

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();

                for (int i = rows.length - 1; i &gt;= 0; i--) {
                    int index = rows[i];
                    if (index &gt;= 0 &amp;&amp; index &lt; rowCount) {
                        select(index);
                        break;
                    }
                }

                if (selectedCellsMap.isEmpty()) {
                    if (row &gt; 0 &amp;&amp; row &lt; rowCount) {
                        select(row);
                    }
                }
            } else {
                int lastIndex = -1;
                Set&lt;TablePosition&lt;S,?&gt;&gt; positions = new LinkedHashSet&lt;&gt;();

                // --- firstly, we special-case the non-varargs 'row' argument
                if (row &gt;= 0 &amp;&amp; row &lt; rowCount) {
                    // if I'm in cell selection mode, we want to select each
                    // of the contained cells individually
                    if (isCellSelectionEnabled()) {
                        List&lt;TableColumn&lt;S,?&gt;&gt; columns = getTableView().getVisibleLeafColumns();
                        for (int column = 0; column &lt; columns.size(); column++) {
                            if (! selectedCellsMap.isSelected(row, column)) {
                                positions.add(new TablePosition&lt;&gt;(getTableView(), row, columns.get(column)));
                                lastIndex = row;
                            }
                        }
                    } else {
                        boolean match = selectedCellsMap.isSelected(row, -1);
                        if (!match) {
                            positions.add(new TablePosition&lt;&gt;(getTableView(), row, null));
                        }
                    }

                    lastIndex = row;
                }

                // --- now we iterate through all varargs values
                for (int i = 0; i &lt; rows.length; i++) {
                    int index = rows[i];
                    if (index &lt; 0 || index &gt;= rowCount) continue;
                    lastIndex = index;

                    if (isCellSelectionEnabled()) {
                        List&lt;TableColumn&lt;S,?&gt;&gt; columns = getTableView().getVisibleLeafColumns();
                        for (int column = 0; column &lt; columns.size(); column++) {
                            if (! selectedCellsMap.isSelected(index, column)) {
                                positions.add(new TablePosition&lt;&gt;(getTableView(), index, columns.get(column)));
                                lastIndex = index;
                            }
                        }
                    } else {
                        if (! selectedCellsMap.isSelected(index, -1)) {
                            // if we are here then we have successfully gotten through the for-loop above
                            positions.add(new TablePosition&lt;&gt;(getTableView(), index, null));
                        }
                    }
                }

                selectedCellsMap.addAll(positions);

                if (lastIndex != -1) {
                    select(lastIndex);
                }
            }
        }

        @Override public void selectAll() {
            if (getSelectionMode() == SelectionMode.SINGLE) return;

            if (isCellSelectionEnabled()) {
                List&lt;TablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
                TableColumn&lt;S,?&gt; column;
                TablePosition&lt;S,?&gt; tp = null;
                for (int col = 0; col &lt; getTableView().getVisibleLeafColumns().size(); col++) {
                    column = getTableView().getVisibleLeafColumns().get(col);
                    for (int row = 0; row &lt; getItemCount(); row++) {
                        tp = new TablePosition&lt;&gt;(getTableView(), row, column);
                        indices.add(tp);
                    }
                }
                selectedCellsMap.setAll(indices);

                if (tp != null) {
                    select(tp.getRow(), tp.getTableColumn());
                    focus(tp.getRow(), tp.getTableColumn());
                }
            } else {
                List&lt;TablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
                for (int i = 0; i &lt; getItemCount(); i++) {
                    indices.add(new TablePosition&lt;&gt;(getTableView(), i, null));
                }
                selectedCellsMap.setAll(indices);

                int focusedIndex = getFocusedIndex();
                if (focusedIndex == -1) {
                    final int itemCount = getItemCount();
                    if (itemCount &gt; 0) {
                        select(itemCount - 1);
                        focus(indices.get(indices.size() - 1));
                    }
                } else {
                    select(focusedIndex);
                    focus(focusedIndex);
                }
            }
        }

        @Override public void selectRange(int minRow, TableColumnBase&lt;S,?&gt; minColumn,
                                          int maxRow, TableColumnBase&lt;S,?&gt; maxColumn) {
            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
                select(maxRow, maxColumn);
                return;
            }

            startAtomic();

            final int itemCount = getItemCount();
            final boolean isCellSelectionEnabled = isCellSelectionEnabled();

            final int minColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)minColumn);
            final int maxColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)maxColumn);
            final int _minColumnIndex = Math.min(minColumnIndex, maxColumnIndex);
            final int _maxColumnIndex = Math.max(minColumnIndex, maxColumnIndex);

            final int _minRow = Math.min(minRow, maxRow);
            final int _maxRow = Math.max(minRow, maxRow);

            List&lt;TablePosition&lt;S,?&gt;&gt; cellsToSelect = new ArrayList&lt;&gt;();

            for (int _row = _minRow; _row &lt;= _maxRow; _row++) {
                // begin copy/paste of select(int, column) method (with some
                // slight modifications)
                if (_row &lt; 0 || _row &gt;= itemCount) continue;

                if (! isCellSelectionEnabled) {
                    cellsToSelect.add(new TablePosition&lt;&gt;(tableView, _row, (TableColumn&lt;S,?&gt;)minColumn));
                } else {
                    for (int _col = _minColumnIndex; _col &lt;= _maxColumnIndex; _col++) {
                        final TableColumn&lt;S, ?&gt; column = tableView.getVisibleLeafColumn(_col);

                        // if I'm in cell selection mode but the column is null, I don't want
                        // to select the whole row instead...
                        if (column == null &amp;&amp; isCellSelectionEnabled) continue;

                        cellsToSelect.add(new TablePosition&lt;&gt;(tableView, _row, column));
                        // end copy/paste
                    }
                }
            }

            // to prevent duplication we remove all currently selected cells from
            // our list of cells to select.
            cellsToSelect.removeAll(getSelectedCells());

            selectedCellsMap.addAll(cellsToSelect);
            stopAtomic();

            // fire off events.
            // Note that focus and selection always goes to maxRow, not _maxRow.
            updateSelectedIndex(maxRow);
            focus(maxRow, (TableColumn&lt;S,?&gt;)maxColumn);

            final TableColumn&lt;S,?&gt; startColumn = (TableColumn&lt;S,?&gt;)minColumn;
            final TableColumn&lt;S,?&gt; endColumn = isCellSelectionEnabled ? (TableColumn&lt;S,?&gt;)maxColumn : startColumn;
            final int startChangeIndex = selectedCellsMap.indexOf(new TablePosition&lt;&gt;(tableView, minRow, startColumn));
            final int endChangeIndex = selectedCellsMap.indexOf(new TablePosition&lt;&gt;(tableView, maxRow, endColumn));

            if (startChangeIndex &gt; -1 &amp;&amp; endChangeIndex &gt; -1) {
                final int startIndex = Math.min(startChangeIndex, endChangeIndex);
                final int endIndex = Math.max(startChangeIndex, endChangeIndex);

                ListChangeListener.Change c = new NonIterableChange.SimpleAddChange&lt;&gt;(startIndex, endIndex + 1, selectedCellsSeq);
                fireCustomSelectedCellsListChangeEvent(c);
//                selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextAdd(startIndex, endIndex + 1));
            }
        }

        @Override public void clearSelection(int index) {
            clearSelection(index, null);
        }

        @Override
        public void clearSelection(int row, TableColumn&lt;S,?&gt; column) {
            clearSelection(new TablePosition&lt;&gt;(getTableView(), row, column));
        }

        private void clearSelection(TablePosition&lt;S,?&gt; tp) {
            final boolean csMode = isCellSelectionEnabled();
            final int row = tp.getRow();
            final boolean columnIsNull = tp.getTableColumn() == null;

            List&lt;TablePosition&gt; toRemove = new ArrayList&lt;&gt;();
            for (TablePosition pos : getSelectedCells()) {
                if (!csMode) {
                    if (pos.getRow() == row) {
                        toRemove.add(pos);
                        break;
                    }
                } else {
                    if (columnIsNull &amp;&amp; pos.getRow() == row) {
                        // if we are in cell selection mode and the column is null,
                        // we remove all items in the row
                        toRemove.add(pos);
                    } else if (pos.equals(tp)) {
                        toRemove.add(tp);
                        break;
                    }
                }
            }
            toRemove.stream().forEach(selectedCellsMap::remove);

            if (isEmpty() &amp;&amp; ! isAtomic()) {
                updateSelectedIndex(-1);
                selectedCellsMap.clear();
            }
        }

        @Override public void clearSelection() {
            final List&lt;TablePosition&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;((Collection)getSelectedCells());

            quietClearSelection();

            if (! isAtomic()) {
                updateSelectedIndex(-1);
                focus(-1);

                if (!removed.isEmpty()) {
                    ListChangeListener.Change&lt;TablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange&lt;TablePosition&lt;S, ?&gt;&gt;(0, 0, selectedCellsSeq) {
                        @Override public List&lt;TablePosition&lt;S, ?&gt;&gt; getRemoved() {
                            return removed;
                        }
                    };
                    fireCustomSelectedCellsListChangeEvent(c);
//                    selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextRemove(0, removed));
                }
            }
        }

        private void quietClearSelection() {
            startAtomic();
            selectedCellsMap.clear();
            stopAtomic();
        }

        @Override public boolean isSelected(int index) {
            return isSelected(index, null);
        }

        @Override
        public boolean isSelected(int row, TableColumn&lt;S,?&gt; column) {
            // When in cell selection mode, if the column is null, then we interpret
            // the users query to be asking if _all_ of the cells in the row are selected,
            // rather than if _any_ of the cells in the row are selected.
            final boolean isCellSelectionEnabled = isCellSelectionEnabled();
            if (isCellSelectionEnabled &amp;&amp; column == null) {
                int columnCount = tableView.getVisibleLeafColumns().size();
                for (int col = 0; col &lt; columnCount; col++) {
                    if (!selectedCellsMap.isSelected(row, col)) {
                        return false;
                    }
                }
                return true;
            } else {
                int columnIndex = !isCellSelectionEnabled || column == null ? -1 : tableView.getVisibleLeafIndex(column);
                return selectedCellsMap.isSelected(row, columnIndex);
            }
        }

        @Override public boolean isEmpty() {
            return selectedCellsMap.isEmpty();
        }

        @Override public void selectPrevious() {
            if (isCellSelectionEnabled()) {
                // in cell selection mode, we have to wrap around, going from
                // right-to-left, and then wrapping to the end of the previous line
                TablePosition&lt;S,?&gt; pos = getFocusedCell();
                if (pos.getColumn() - 1 &gt;= 0) {
                    // go to previous row
                    select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
                } else if (pos.getRow() &lt; getItemCount() - 1) {
                    // wrap to end of previous row
                    select(pos.getRow() - 1, getTableColumn(getTableView().getVisibleLeafColumns().size() - 1));
                }
            } else {
                int focusIndex = getFocusedIndex();
                if (focusIndex == -1) {
                    select(getItemCount() - 1);
                } else if (focusIndex &gt; 0) {
                    select(focusIndex - 1);
                }
            }
        }

        @Override public void selectNext() {
            if (isCellSelectionEnabled()) {
                // in cell selection mode, we have to wrap around, going from
                // left-to-right, and then wrapping to the start of the next line
                TablePosition&lt;S,?&gt; pos = getFocusedCell();
                if (pos.getColumn() + 1 &lt; getTableView().getVisibleLeafColumns().size()) {
                    // go to next column
                    select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
                } else if (pos.getRow() &lt; getItemCount() - 1) {
                    // wrap to start of next row
                    select(pos.getRow() + 1, getTableColumn(0));
                }
            } else {
                int focusIndex = getFocusedIndex();
                if (focusIndex == -1) {
                    select(0);
                } else if (focusIndex &lt; getItemCount() -1) {
                    select(focusIndex + 1);
                }
            }
        }

        @Override public void selectAboveCell() {
            TablePosition&lt;S,?&gt; pos = getFocusedCell();
            if (pos.getRow() == -1) {
                select(getItemCount() - 1);
            } else if (pos.getRow() &gt; 0) {
                select(pos.getRow() - 1, pos.getTableColumn());
            }
        }

        @Override public void selectBelowCell() {
            TablePosition&lt;S,?&gt; pos = getFocusedCell();

            if (pos.getRow() == -1) {
                select(0);
            } else if (pos.getRow() &lt; getItemCount() -1) {
                select(pos.getRow() + 1, pos.getTableColumn());
            }
        }

        @Override public void selectFirst() {
            TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
            }

            if (getItemCount() &gt; 0) {
                if (isCellSelectionEnabled()) {
                    select(0, focusedCell.getTableColumn());
                } else {
                    select(0);
                }
            }
        }

        @Override public void selectLast() {
            TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();

            if (getSelectionMode() == SelectionMode.SINGLE) {
                quietClearSelection();
            }

            int numItems = getItemCount();
            if (numItems &gt; 0 &amp;&amp; getSelectedIndex() &lt; numItems - 1) {
                if (isCellSelectionEnabled()) {
                    select(numItems - 1, focusedCell.getTableColumn());
                } else {
                    select(numItems - 1);
                }
            }
        }

        @Override
        public void selectLeftCell() {
            if (! isCellSelectionEnabled()) return;

            TablePosition&lt;S,?&gt; pos = getFocusedCell();
            if (pos.getColumn() - 1 &gt;= 0) {
                select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
            }
        }

        @Override
        public void selectRightCell() {
            if (! isCellSelectionEnabled()) return;

            TablePosition&lt;S,?&gt; pos = getFocusedCell();
            if (pos.getColumn() + 1 &lt; getTableView().getVisibleLeafColumns().size()) {
                select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
            }
        }



        /***********************************************************************
         *                                                                     *
         * Support code                                                        *
         *                                                                     *
         **********************************************************************/

        private void updateItemsObserver(ObservableList&lt;S&gt; oldList, ObservableList&lt;S&gt; newList) {
            // the items list has changed, we need to observe
            // the new list, and remove any observer we had from the old list
            if (oldList != null) {
                oldList.removeListener(weakItemsContentListener);
            }
            if (newList != null) {
                newList.addListener(weakItemsContentListener);
            }

            updateItemCount();
            updateDefaultSelection();
        }

        private void updateDefaultSelection() {
            // when the items list totally changes, we should clear out
            // the selection
            int newSelectionIndex = -1;
            if (tableView.getItems() != null) {
                S selectedItem = getSelectedItem();
                if (selectedItem != null) {
                    newSelectionIndex = tableView.getItems().indexOf(selectedItem);
                }
            }

            clearSelection();
            select(newSelectionIndex, isCellSelectionEnabled() ? getTableColumn(0) : null);
        }

        private TableColumn&lt;S,?&gt; getTableColumn(int pos) {
            return getTableView().getVisibleLeafColumn(pos);
        }

        // Gets a table column to the left or right of the current one, given an offset
        private TableColumn&lt;S,?&gt; getTableColumn(TableColumn&lt;S,?&gt; column, int offset) {
            int columnIndex = getTableView().getVisibleLeafIndex(column);
            int newColumnIndex = columnIndex + offset;
            return getTableView().getVisibleLeafColumn(newColumnIndex);
        }

        private void updateSelectedIndex(int row) {
            setSelectedIndex(row);
            setSelectedItem(getModelItem(row));
        }

        /** {@inheritDoc} */
        @Override protected int getItemCount() {
            return itemCount;
        }

        private void updateItemCount() {
            if (tableView == null) {
                itemCount = -1;
            } else {
                List&lt;S&gt; items = getTableModel();
                itemCount = items == null ? -1 : items.size();
            }
        }

        private void fireCustomSelectedCellsListChangeEvent(ListChangeListener.Change&lt;? extends TablePosition&lt;S,?&gt;&gt; c) {
            ControlUtils.updateSelectedIndices(this, c);

            if (isAtomic()) {
                return;
            }

            selectedCellsSeq.callObservers(new MappingChange&lt;&gt;(c, MappingChange.NOOP_MAP, selectedCellsSeq));
        }
    }




    /**
     * A {@link FocusModel} with additional functionality to support the requirements
     * of a TableView control.
     *
     * @see TableView
     * @since JavaFX 2.0
     */
    public static class TableViewFocusModel&lt;S&gt; extends TableFocusModel&lt;S, TableColumn&lt;S, ?&gt;&gt; {

        private final TableView&lt;S&gt; tableView;

        private final TablePosition&lt;S,?&gt; EMPTY_CELL;

        /**
         * Creates a default TableViewFocusModel instance that will be used to
         * manage focus of the provided TableView control.
         *
         * @param tableView The tableView upon which this focus model operates.
         * @throws NullPointerException The TableView argument can not be null.
         */
        public TableViewFocusModel(final TableView&lt;S&gt; tableView) {
            if (tableView == null) {
                throw new NullPointerException(&quot;TableView can not be null&quot;);
            }

            this.tableView = tableView;
            this.EMPTY_CELL = new TablePosition&lt;&gt;(tableView, -1, null);

            itemsObserver = new InvalidationListener() {
                private WeakReference&lt;ObservableList&lt;S&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());

                @Override public void invalidated(Observable observable) {
                    ObservableList&lt;S&gt; oldItems = weakItemsRef.get();
                    weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());
                    updateItemsObserver(oldItems, tableView.getItems());
                }
            };
            this.tableView.itemsProperty().addListener(new WeakInvalidationListener(itemsObserver));
            if (tableView.getItems() != null) {
                this.tableView.getItems().addListener(weakItemsContentListener);
            }

            updateDefaultFocus();

            focusedCellProperty().addListener(o -&gt; {
                tableView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
            });
        }

        private final InvalidationListener itemsObserver;

        // Listen to changes in the tableview items list, such that when it
        // changes we can update the focused index to refer to the new indices.
        private final ListChangeListener&lt;S&gt; itemsContentListener = c -&gt; {
            c.next();

            if (c.wasReplaced() || c.getAddedSize() == getItemCount()) {
                updateDefaultFocus();
                return;
            }

            TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
            final int focusedIndex = focusedCell.getRow();
            if (focusedIndex == -1 || c.getFrom() &gt; focusedIndex) {
                return;
            }

            c.reset();
            boolean added = false;
            boolean removed = false;
            int addedSize = 0;
            int removedSize = 0;
            while (c.next()) {
                added |= c.wasAdded();
                removed |= c.wasRemoved();
                addedSize += c.getAddedSize();
                removedSize += c.getRemovedSize();
            }

            if (added &amp;&amp; ! removed) {
                if (addedSize &lt; c.getList().size()) {
                    final int newFocusIndex = Math.min(getItemCount() - 1, getFocusedIndex() + addedSize);
                    focus(newFocusIndex, focusedCell.getTableColumn());
                }
            } else if (!added &amp;&amp; removed) {
                final int newFocusIndex = Math.max(0, getFocusedIndex() - removedSize);
                if (newFocusIndex &lt; 0) {
                    focus(0, focusedCell.getTableColumn());
                } else {
                    focus(newFocusIndex, focusedCell.getTableColumn());
                }
            }
        };

        private WeakListChangeListener&lt;S&gt; weakItemsContentListener
                = new WeakListChangeListener&lt;&gt;(itemsContentListener);

        private void updateItemsObserver(ObservableList&lt;S&gt; oldList, ObservableList&lt;S&gt; newList) {
            // the tableview items list has changed, we need to observe
            // the new list, and remove any observer we had from the old list
            if (oldList != null) oldList.removeListener(weakItemsContentListener);
            if (newList != null) newList.addListener(weakItemsContentListener);

            updateDefaultFocus();
        }

        /** {@inheritDoc} */
        @Override protected int getItemCount() {
            if (tableView.getItems() == null) return -1;
            return tableView.getItems().size();
        }

        /** {@inheritDoc} */
        @Override protected S getModelItem(int index) {
            if (tableView.getItems() == null) return null;

            if (index &lt; 0 || index &gt;= getItemCount()) return null;

            return tableView.getItems().get(index);
        }

        /**
         * The position of the current item in the TableView which has the focus.
         */
        private ReadOnlyObjectWrapper&lt;TablePosition&gt; focusedCell;
        public final ReadOnlyObjectProperty&lt;TablePosition&gt; focusedCellProperty() {
            return focusedCellPropertyImpl().getReadOnlyProperty();
        }
        private void setFocusedCell(TablePosition value) { focusedCellPropertyImpl().set(value);  }
        public final TablePosition getFocusedCell() { return focusedCell == null ? EMPTY_CELL : focusedCell.get(); }

        private ReadOnlyObjectWrapper&lt;TablePosition&gt; focusedCellPropertyImpl() {
            if (focusedCell == null) {
                focusedCell = new ReadOnlyObjectWrapper&lt;TablePosition&gt;(EMPTY_CELL) {
                    private TablePosition old;
                    @Override protected void invalidated() {
                        if (get() == null) return;

                        if (old == null || !old.equals(get())) {
                            setFocusedIndex(get().getRow());
                            setFocusedItem(getModelItem(getValue().getRow()));

                            old = get();
                        }
                    }

                    @Override
                    public Object getBean() {
                        return TableViewFocusModel.this;
                    }

                    @Override
                    public String getName() {
                        return &quot;focusedCell&quot;;
                    }
                };
            }
            return focusedCell;
        }


        /**
         * Causes the item at the given index to receive the focus.
         *
         * @param row The row index of the item to give focus to.
         * @param column The column of the item to give focus to. Can be null.
         */
        @Override public void focus(int row, TableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) {
                setFocusedCell(EMPTY_CELL);
            } else {
                TablePosition&lt;S,?&gt; oldFocusCell = getFocusedCell();
                TablePosition&lt;S,?&gt; newFocusCell = new TablePosition&lt;&gt;(tableView, row, column);
                setFocusedCell(newFocusCell);

                if (newFocusCell.equals(oldFocusCell)) {
                    // manually update the focus properties to ensure consistency
                    setFocusedIndex(row);
                    setFocusedItem(getModelItem(row));
                }
            }
        }

        /**
         * Convenience method for setting focus on a particular row or cell
         * using a {@link TablePosition}.
         *
         * @param pos The table position where focus should be set.
         */
        public void focus(TablePosition pos) {
            if (pos == null) return;
            focus(pos.getRow(), pos.getTableColumn());
        }


        /***********************************************************************
         *                                                                     *
         * Public API                                                          *
         *                                                                     *
         **********************************************************************/

        /**
         * Tests whether the row / cell at the given location currently has the
         * focus within the TableView.
         */
        @Override public boolean isFocused(int row, TableColumn&lt;S,?&gt; column) {
            if (row &lt; 0 || row &gt;= getItemCount()) return false;

            TablePosition cell = getFocusedCell();
            boolean columnMatch = column == null || column.equals(cell.getTableColumn());

            return cell.getRow() == row &amp;&amp; columnMatch;
        }

        /**
         * Causes the item at the given index to receive the focus. This does not
         * cause the current selection to change. Updates the focusedItem and
         * focusedIndex properties such that &lt;code&gt;focusedIndex = -1&lt;/code&gt; unless
         * &lt;pre&gt;&lt;code&gt;0 &amp;lt;= index &amp;lt; model size&lt;/code&gt;&lt;/pre&gt;.
         *
         * @param index The index of the item to get focus.
         */
        @Override public void focus(int index) {
            if (index &lt; 0 || index &gt;= getItemCount()) {
                setFocusedCell(EMPTY_CELL);
            } else {
                setFocusedCell(new TablePosition&lt;&gt;(tableView, index, null));
            }
        }

        /**
         * Attempts to move focus to the cell above the currently focused cell.
         */
        @Override public void focusAboveCell() {
            TablePosition cell = getFocusedCell();

            if (getFocusedIndex() == -1) {
                focus(getItemCount() - 1, cell.getTableColumn());
            } else if (getFocusedIndex() &gt; 0) {
                focus(getFocusedIndex() - 1, cell.getTableColumn());
            }
        }

        /**
         * Attempts to move focus to the cell below the currently focused cell.
         */
        @Override public void focusBelowCell() {
            TablePosition cell = getFocusedCell();
            if (getFocusedIndex() == -1) {
                focus(0, cell.getTableColumn());
            } else if (getFocusedIndex() != getItemCount() -1) {
                focus(getFocusedIndex() + 1, cell.getTableColumn());
            }
        }

        /**
         * Attempts to move focus to the cell to the left of the currently focused cell.
         */
        @Override public void focusLeftCell() {
            TablePosition cell = getFocusedCell();
            if (cell.getColumn() &lt;= 0) return;
            focus(cell.getRow(), getTableColumn(cell.getTableColumn(), -1));
        }

        /**
         * Attempts to move focus to the cell to the right of the the currently focused cell.
         */
        @Override public void focusRightCell() {
            TablePosition cell = getFocusedCell();
            if (cell.getColumn() == getColumnCount() - 1) return;
            focus(cell.getRow(), getTableColumn(cell.getTableColumn(), 1));
        }

        /** {@inheritDoc} */
        @Override public void focusPrevious() {
            if (getFocusedIndex() == -1) {
                focus(0);
            } else if (getFocusedIndex() &gt; 0) {
                focusAboveCell();
            }
        }

        /** {@inheritDoc} */
        @Override public void focusNext() {
            if (getFocusedIndex() == -1) {
                focus(0);
            } else if (getFocusedIndex() != getItemCount() -1) {
                focusBelowCell();
            }
        }

        /***********************************************************************
         *                                                                     *
         * Private Implementation                                              *
         *                                                                     *
         **********************************************************************/

        private void updateDefaultFocus() {
            // when the items list totally changes, we should clear out
            // the focus
            int newValueIndex = -1;
            if (tableView.getItems() != null) {
                S focusedItem = getFocusedItem();
                if (focusedItem != null) {
                    newValueIndex = tableView.getItems().indexOf(focusedItem);
                }

                // we put focus onto the first item, if there is at least
                // one item in the list
                if (newValueIndex == -1) {
                    newValueIndex = tableView.getItems().size() &gt; 0 ? 0 : -1;
                }
            }

            TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
            TableColumn&lt;S,?&gt; focusColumn = focusedCell != null &amp;&amp; !EMPTY_CELL.equals(focusedCell) ?
               focusedCell.getTableColumn() : tableView.getVisibleLeafColumn(0);

            focus(newValueIndex, focusColumn);
        }

        private int getColumnCount() {
            return tableView.getVisibleLeafColumns().size();
        }

        // Gets a table column to the left or right of the current one, given an offset
        private TableColumn&lt;S,?&gt; getTableColumn(TableColumn&lt;S,?&gt; column, int offset) {
            int columnIndex = tableView.getVisibleLeafIndex(column);
            int newColumnIndex = columnIndex + offset;
            return tableView.getVisibleLeafColumn(newColumnIndex);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TextFormatter.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javafx.scene.control;

import com.sun.javafx.scene.control.FormatterAccessor;
import javafx.beans.NamedArg;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.util.StringConverter;

import java.util.function.Consumer;
import java.util.function.UnaryOperator;

/**
 * A Formatter describes a format of a {@code TextInputControl} text by using two distinct mechanisms:
 * &lt;ul&gt;
 *     &lt;li&gt;A filter ({@link #getFilter()}) that can intercept and modify user input. This helps to keep the text
 *     in the desired format. A default text supplier can be used to provide the intial text.&lt;/li&gt;
 *     &lt;li&gt;A value converter ({@link #getValueConverter()}) and value ({@link #valueProperty()})
 *     can be used to provide special format that represents a value of type {@code V}.
 *     If the control is editable and the text is changed by the user, the value is then updated to correspond to the text.
 * &lt;/ul&gt;
 * &lt;p&gt;
 * It's possible to have a formatter with just filter or value converter. If value converter is not provided however, setting a value will
 * result in an {@code IllegalStateException} and the value is always null.
 * &lt;p&gt;
 * Since {@code Formatter} contains a value which represents the state of the {@code TextInputControl} to which it is currently assigned, a single
 * {@code Formatter} instance can be used only in one {@code TextInputControl} at a time.
 *
 * @param &lt;V&gt; The type of the value
 * @since JavaFX 8u40
 */
public class TextFormatter&lt;V&gt; {
    private final StringConverter&lt;V&gt; valueConverter;
    private final UnaryOperator&lt;Change&gt; filter;

    private Consumer&lt;TextFormatter&lt;?&gt;&gt; textUpdater;

    /**
     * This string converter converts the text to the same String value. This might be useful for cases where you
     * want to manipulate with the text through the value or you need to provide a default text value.
     */
    public static final StringConverter&lt;String&gt; IDENTITY_STRING_CONVERTER = new StringConverter&lt;String&gt;() {
        @Override
        public String toString(String object) {
            return object == null ? &quot;&quot; : object;
        }
        @Override
        public String fromString(String string) {
            return string;
        }
    };


    /**
     * Creates a new Formatter with the provided filter.
     * @param filter The filter to use in this formatter or null
     */
    public TextFormatter(@NamedArg(&quot;filter&quot;) UnaryOperator&lt;Change&gt; filter) {
        this(null, null, filter);
    }

    /**
     * Creates a new Formatter with the provided filter, value converter and default value.
     * @param valueConverter The value converter to use in this formatter or null.
     * @param defaultValue the default value.
     * @param filter The filter to use in this formatter or null
     */
    public TextFormatter(@NamedArg(&quot;valueConverter&quot;) StringConverter&lt;V&gt; valueConverter,
                         @NamedArg(&quot;defaultValue&quot;) V defaultValue, @NamedArg(&quot;filter&quot;) UnaryOperator&lt;Change&gt; filter) {
        this.filter = filter;
        this.valueConverter = valueConverter;
        setValue(defaultValue);
    }

    /**
     * Creates a new Formatter with the provided value converter and default value.
     * @param valueConverter The value converter to use in this formatter. This must not be null.
     * @param defaultValue the default value
     */
    public TextFormatter(@NamedArg(&quot;valueConverter&quot;) StringConverter&lt;V&gt; valueConverter, @NamedArg(&quot;defaultValue&quot;) V defaultValue) {
        this(valueConverter, defaultValue, null);
    }

    /**
     * Creates a new Formatter with the provided value converter. The default value will be null.
     * @param valueConverter The value converter to use in this formatter. This must not be null.
     */
    public TextFormatter(@NamedArg(&quot;valueConverter&quot;) StringConverter&lt;V&gt; valueConverter) {
        this(valueConverter, null, null);
    }


    /**
     * The converter between the values and text.
     * It maintains a &quot;binding&quot; between the {@link javafx.scene.control.TextInputControl#textProperty()} }
     * and {@link #valueProperty()} }. The value is updated when the control loses it's focus or it is commited (TextField only).
     * Setting the value will update the text of the control, usin the provided converter.
     *
     * If it's impossible to convert text to value, an exception should be thrown.
     * @return StringConverter for values or null if none provided
     * @see javafx.scene.control.TextField#commitValue()
     * @see javafx.scene.control.TextField#cancelEdit()
     */
    public final StringConverter&lt;V&gt; getValueConverter() {
        return valueConverter;
    }

    /**
     * Filter allows user to intercept and modify any change done to the text content.
     * &lt;p&gt;
     * The filter itself is an {@code UnaryOperator} that accepts {@link javafx.scene.control.TextFormatter.Change} object.
     * It should return a {@link javafx.scene.control.TextFormatter.Change} object that contains the actual (filtered)
     * change. Returning null rejects the change.
     * @return the filter for this formatter or null if there is none
     */
    public final UnaryOperator&lt;Change&gt; getFilter() {
        return filter;
    }

    /**
     * The current value for this formatter. When the formatter is set on a {@code TextInputControl} and has a
     * {@code valueConverter}, the value is set by the control, when the text is commited.
     */
    private final ObjectProperty&lt;V&gt; value = new ObjectPropertyBase&lt;V&gt;() {

        @Override
        public Object getBean() {
            return TextFormatter.this;
        }

        @Override
        public String getName() {
            return &quot;value&quot;;
        }

        @Override
        protected void invalidated() {
            if (valueConverter == null &amp;&amp; get() != null) {
                if (isBound()) {
                    unbind();
                }
                throw new IllegalStateException(&quot;Value changes are not supported when valueConverter is not set&quot;);
            }
            updateText();
        }
    };

    public final ObjectProperty&lt;V&gt; valueProperty() {
        return value;
    }
    public final void setValue(V value) {
        if (valueConverter == null &amp;&amp; value != null) {
            throw new IllegalStateException(&quot;Value changes are not supported when valueConverter is not set&quot;);
        }
        this.value.set(value);
    }
    public final V getValue() {
        return value.get();
    }

    private void updateText() {
        if (textUpdater != null) {
            textUpdater.accept(this);
        }
    }

    void bindToControl(Consumer&lt;TextFormatter&lt;?&gt;&gt; updater) {
        if (textUpdater != null) {
            throw new IllegalStateException(&quot;Formatter is already used in other control&quot;);
        }
        this.textUpdater = updater;
    }

    void unbindFromControl() {
        this.textUpdater = null;
    }

    void updateValue(String text) {
        if (!value.isBound()) {
            try {
                V v = valueConverter.fromString(text);
                setValue(v);
            } catch (Exception e) {
                updateText(); // Set the text with the latest value
            }
        }
    }

    /**
     * Contains the state representing a change in the content or selection for a
     * TextInputControl. This object is passed to any registered
     * {@code formatter} on the TextInputControl whenever the text
     * for the TextInputControl is modified.
     * &lt;p&gt;
     *     This class contains state and convenience methods for determining what
     *     change occurred on the control. It also has a reference to the
     *     TextInputControl itself so that the developer may query any other
     *     state on the control. Note that you should never modify the state
     *     of the control directly from within the formatter handler.
     * &lt;/p&gt;
     * &lt;p&gt;
     *     The Change of the text is described by &lt;b&gt;range&lt;/b&gt; ({@link #getRangeStart()}, {@link #getRangeEnd()}) and
     *     text ({@link #getText()}. There are 3 cases that can occur:
     *     &lt;ul&gt;
     *         &lt;li&gt;&lt;b&gt;Some text was deleted:&lt;/b&gt; In this case, {@code text} is empty and {@code range} denotes the {@code range} of deleted text.
     *         E.g. In text &quot;Lorem ipsum dolor sit amet&quot;, removal of the second word would result in {@code range} being (6,11) and
     *         an empty {@code text}. Similarly, if you want to delete some different or additional text, just set the {@code range}.
     *         If you want to remove first word instead of the second, just call {@code setRange(0,5)}&lt;/li&gt;
     *         &lt;li&gt;&lt;b&gt;Some text was added:&lt;/b&gt; Now the {@code range} is empty (means nothing was deleted), but it's value is still important.
     *         Both the start and end of the {@code range} point to the index wheret the new text was added. E.g. adding &quot;ipsum &quot; to &quot;Lorem dolor sit amet&quot;
     *         would result in a change with {@code range} of (6,6) and {@code text} containing the String &quot;ipsum &quot;.&lt;/li&gt;
     *         &lt;li&gt;&lt;b&gt;Some text was replaced:&lt;/b&gt; The combination of the 2 cases above. Both {@code text} and {@code range} are not empty. The text in {@code range} is deleted
     *         and replaced by {@code text} in the Change. The new text is added instead of the old text, which is at the beginning of the {@code range}.
     *         E.g. when some text is being deleted, you can simply replace it by some placeholder text just by setting a new text
     *         ({@code setText(&quot;new text&quot;)})&lt;/li&gt;
     *     &lt;/ul&gt;
     * &lt;p&gt;
     *     The Change is mutable, but not observable. It should be used
     *     only for the life of a single change. It is intended that the
     *     Change will be modified from within the formatter.
     * &lt;/p&gt;
     * @since JavaFX 8u40
     */
    public static final class Change implements Cloneable {
        private final FormatterAccessor accessor;
        private Control control;
        int start;
        int end;
        String text;

        int anchor;
        int caret;

        Change(Control control, FormatterAccessor accessor,  int anchor, int caret) {
            this(control, accessor, caret, caret, &quot;&quot;, anchor, caret);
        }

        Change(Control control, FormatterAccessor accessor, int start, int end, String text) {
            this(control, accessor, start, end, text, start + text.length(), start + text.length());
        }

        // Restrict construction to TextInputControl only. Because we are the
        // only ones who can create this, we don't bother doing a check here
        // to make sure the arguments are within reason (they will be).
        Change(Control control, FormatterAccessor accessor, int start, int end, String text, int anchor, int caret) {
            this.control = control;
            this.accessor = accessor;
            this.start = start;
            this.end = end;
            this.text = text;
            this.anchor = anchor;
            this.caret = caret;
        }

        /**
         * Gets the control associated with this change.
         * @return The control associated with this change. This will never be null.
         */
        public final Control getControl() { return control; }

        /**
         * Gets the start index into the {@link TextInputControl#getText()}
         * for the modification. This will always be a value &amp;gt; 0 and
         * &amp;lt;= {@link TextInputControl#getLength()}.
         *
         * @return The start index
         */
        public final int getRangeStart() { return start; }

        /**
         * Gets the end index into the {@link TextInputControl#getText()}
         * for the modification. This will always be a value &amp;gt; {@link #getRangeStart()} and
         * &amp;lt;= {@link TextInputControl#getLength()}.
         *
         * @return The end index
         */
        public final int getRangeEnd() { return end; }

        /**
         * A method assigning both the start and end values
         * together, in such a way as to ensure they are valid with respect to
         * each other. The start must be less than or equal to the end.
         *
         * @param start The new start value. Must be a valid start value
         * @param end The new end value. Must be a valid end value
         */
        public final void setRange(int start, int end) {
            int length = accessor.getTextLength();
            if (start &lt; 0 || start &gt; length || end &lt; 0 || end &gt; length) {
                throw new IndexOutOfBoundsException();
            }
            this.start = start;
            this.end = end;
        }


        /**
         * Gets the new caret position. This value will always be &amp;gt; 0 and
         * &amp;lt;= {@link #getControlNewText()}{@code}.getLength()}
         *
         * @return The new caret position
         */
        public final int getCaretPosition() { return caret; }

        /**
         * Gets the new anchor. This value will always be &amp;gt; 0 and
         * &amp;lt;= {@link #getControlNewText()}{@code}.getLength()}
         *
         * @return The new anchor position
         */
        public final int getAnchor() { return anchor; }

        /**
         * Gets the current caret position of the control.
         * @return The previous caret position
         */
        public final int getControlCaretPosition() { return accessor.getCaret();}

        /**
         * Gets the current anchor position of the control.
         * @return The previous anchor
         */
        public final int getControlAnchor() { return accessor.getAnchor(); }

        /**
         * Sets the selection. The anchor and caret position values must be &amp;gt; 0 and
         * &amp;lt;= {@link #getControlNewText()}{@code}.getLength()}. Note that there
         * is an order dependence here, in that the positions should be
         * specified after the new text has been specified.
         *
         * @param newAnchor The new anchor position
         * @param newCaretPosition The new caret position
         */
        public final void selectRange(int newAnchor, int newCaretPosition) {
            if (newAnchor &lt; 0 || newAnchor &gt; accessor.getTextLength() - (end - start) + text.length()
                    || newCaretPosition &lt; 0 || newCaretPosition &gt; accessor.getTextLength() - (end - start) + text.length()) {
                throw new IndexOutOfBoundsException();
            }
            anchor = newAnchor;
            caret = newCaretPosition;
        }

        /**
         * Gets the selection of this change. Note that the selection range refers to {@link #getControlNewText()}, not
         * the current control text.
         * @return The selected range of this change.
         */
        public final IndexRange getSelection() {
            return IndexRange.normalize(anchor, caret);
        }


        /**
         * Sets the anchor. The anchor value must be &amp;gt; 0 and
         * &amp;lt;= {@link #getControlNewText()}{@code}.getLength()}. Note that there
         * is an order dependence here, in that the position should be
         * specified after the new text has been specified.
         *
         * @param newAnchor The new anchor position
         */
        public final void setAnchor(int newAnchor) {
            if (newAnchor &lt; 0 || newAnchor &gt; accessor.getTextLength() - (end - start) + text.length()) {
                throw new IndexOutOfBoundsException();
            }
            anchor = newAnchor;
        }

        /**
         * Sets the caret position. The caret position value must be &amp;gt; 0 and
         * &amp;lt;= {@link #getControlNewText()}{@code}.getLength()}. Note that there
         * is an order dependence here, in that the position should be
         * specified after the new text has been specified.
         *
         * @param newCaretPosition The new caret position
         */
        public final void setCaretPosition(int newCaretPosition) {
            if (newCaretPosition &lt; 0 || newCaretPosition &gt; accessor.getTextLength() - (end - start) + text.length()) {
                throw new IndexOutOfBoundsException();
            }
            caret = newCaretPosition;
        }

        /**
         * Gets the text used in this change. For example, this may be new
         * text being added, or text which is replacing all the control's text
         * within the range of start and end. Typically it is an empty string
         * only for cases where the range is being deleted.
         *
         * @return The text involved in this change. This will never be null.
         */
        public final String getText() { return text; }

        /**
         * Sets the text to use in this change. This is used to replace the
         * range from start to end, if such a range exists, or to insert text
         * at the position represented by start == end.
         *
         * @param value The text. This cannot be null.
         */
        public final void setText(String value) {
            if (value == null) throw new NullPointerException();
            text = value;
        }

        /**
         * This is the full text that control has before the change. To get the text
         * after this change, use {@link #getControlNewText()}.
         * @return the previous text of control
         */
        public final String getControlText() {
            return accessor.getText(0, accessor.getTextLength());
        }

        /**
         * Gets the complete new text which will be used on the control after
         * this change. Note that some controls (such as TextField) may do further
         * filtering after the change is made (such as stripping out newlines)
         * such that you cannot assume that the newText will be exactly the same
         * as what is finally set as the content on the control, however it is
         * correct to assume that this is the case for the purpose of computing
         * the new caret position and new anchor position (as those values supplied
         * will be modified as necessary after the control has stripped any
         * additional characters that the control might strip).
         *
         * @return The controls proposed new text at the time of this call, according
<A NAME="38"></A>         *         to the state set for start, end, and text properties on this Change object.
         */
        public final String getControlNewText() {
            return accessor.getText(0, start) + text + accessor.getText(end, <FONT color="#348781"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#38',2,'match31-top.html#38',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>accessor.getTextLength());
        }

        /**
         * Gets whether this change was in response to text being added. Note that
         * after the Change object is modified by the formatter (by one
         * of the setters) the return value of this method is not altered. It answers
         * as to whether this change was fired as a result of text being added,
         * not whether text will end up being added in the end.
         *
         * @return true if text was being added
         */
        public final boolean isAdded() { return !text.isEmpty(); }

        /**
         * Gets whether this change was in response to text being deleted. Note that
         * after the Change object is modified by the formatter (by one
         * of the setters) the return value of this method is not altered. It answers
         * as to whether this change was fired as a result of text being deleted,
         * not whether text will end up being deleted in the end.
         *
         * @return true if text was being deleted
         */
        public final boolean isDeleted() { return start != end; }

        /**
         * Gets whether this change was in response to text being replaced. Note that
         * after the Change object is modified by the formatter (by one
         * of the setters) the return value of this method is not altered. It answers
         * as to whether this change was fired as a result of text being replaced,
         * not whether text will end up being replaced in the end.
         *
         * @return true if text was being replaced
         */
        public final boolean isReplaced() {
            return isAdded() &amp;&amp; isDeleted();
        }

        /**
         * The content change is any of add, delete or replace changes. Basically it's a shortcut for
         * {@code c.isAdded() || c.isDeleted() };
         * @return true if the content changed
         */
        public final boolean isContentChange() {</B></FONT>
            return isAdded() || isDeleted();
        }

        @Override
        public String toString() {
            StringBuilder builder = new StringBuilder(&quot;TextInputControl.Change [&quot;);
            if (isReplaced()) {
                builder.append(&quot; replaced \&quot;&quot;).append(accessor.getText(start, end)).append(&quot;\&quot; with \&quot;&quot;).append(text).
                        append(&quot;\&quot; at (&quot;).append(start).append(&quot;, &quot;).append(end).append(&quot;)&quot;);
            } else if (isDeleted()) {
                builder.append(&quot; deleted \&quot;&quot;).append(accessor.getText(start, end)).
                        append(&quot;\&quot; at (&quot;).append(start).append(&quot;, &quot;).append(end).append(&quot;)&quot;);
            } else if (isAdded()) {
                builder.append(&quot; added \&quot;&quot;).append(text).append(&quot;\&quot; at &quot;).append(start);
            }
            if (isAdded() || isDeleted()) {
                builder.append(&quot;; &quot;);
            } else {
                builder.append(&quot; &quot;);
            }
            builder.append(&quot;new selection (anchor, caret): [&quot;).append(anchor).append(&quot;, &quot;).append(caret).append(&quot;]&quot;);
            builder.append(&quot; ]&quot;);
            return builder.toString();
        }

        @Override
        public Change clone() {
            try {
                return (Change) super.clone();
            } catch (CloneNotSupportedException e) {
                // Cannot happen
                throw new RuntimeException(e);
            }
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/LabeledSkinBase.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.LabeledText;
import com.sun.javafx.scene.control.behavior.TextBinding;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.application.Platform;
import javafx.beans.InvalidationListener;
import javafx.geometry.HPos;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Orientation;
import javafx.geometry.Point2D;
import javafx.geometry.Pos;
import javafx.geometry.VPos;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Accordion;
import javafx.scene.control.ContentDisplay;
import javafx.scene.control.Control;
import javafx.scene.control.Label;
import javafx.scene.control.Labeled;
import javafx.scene.control.OverrunStyle;
import javafx.scene.control.SkinBase;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCombination;
import javafx.scene.input.Mnemonic;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;

import static javafx.scene.control.ContentDisplay.BOTTOM;
import static javafx.scene.control.ContentDisplay.LEFT;
import static javafx.scene.control.ContentDisplay.RIGHT;
import static javafx.scene.control.ContentDisplay.TOP;
import static javafx.scene.control.OverrunStyle.CLIP;

/**
 * Default skin implementation for controls extends {@link Labeled}.
 *
 * @see Labeled
 * @since 9
 */
public abstract class LabeledSkinBase&lt;C extends Labeled&gt; extends SkinBase&lt;C&gt; {

    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    /**
     *  The Text node used to display the text. This is package only
     *  for the sake of testing!
     */
    LabeledText text;

    /**
     * Indicates that the text content is invalid and needs to be updated.
     * This is package private only for the sake of testing.
     */
    boolean invalidText = true;

    /**
     * A reference to the last-known graphic on the Labeled. This reference
     * is kept so that we can remove listeners from the old graphic later
     */
    Node graphic;

    /**
     * The cached full width of the non-truncated text. We only want to
     * recompute this if the text has itself changed, or if the font has changed.
     * This is package private ONLY FOR THE SAKE OF TESTING
     */
    double textWidth = Double.NEGATIVE_INFINITY;

    /**
     * The cached width of the ellipsis string. This will be recomputed
     * if the font or the ellipsisString property have changed.
     * This is package private ONLY FOR THE SAKE OF TESTING
     */
    double ellipsisWidth = Double.NEGATIVE_INFINITY;

    /**
     * A listener which is applied to the graphic whenever the graphic is set
     * and is visible within the labeled. For example, if there is a graphic
     * defined on the Labeled but the ContentDisplay is set to TEXT_ONLY, then
     * we will not bother installing this listener on the graphic. In all
     * other cases, if the graphic is defined, it will have this listener
     * added to it, which ensures that if the graphic's layout bounds change,
     * we end up performing a layout and potentially update the visible text.
     *
     * This is package private ONLY FOR THE SAKE OF TESTING
     */
    final InvalidationListener graphicPropertyChangedListener = valueModel -&gt; {
        invalidText = true;
        if (getSkinnable() != null) getSkinnable().requestLayout();
    };

    private Rectangle textClip;
    private double wrapWidth;
    private double wrapHeight;

    private TextBinding bindings;
    private Line mnemonic_underscore;

    private boolean containsMnemonic = false;
    private Scene mnemonicScene = null;
    private KeyCombination mnemonicCode;
    // needs to be an object, as MenuItem isn't a node
    private Node labeledNode = null;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Constructor for LabeledSkinBase. The Labeled must be specified, and cannot be null.
     * At the conclusion of the constructor call, the skin will be marked as
     * needsLayout, and will be fully configured based on the current state of
     * the labeled. Any subsequent changes to the Labeled will be handled via
     * listeners and applied appropriately.
     *
     * @param labeled The labeled that this skin should be installed onto.
     */
    public LabeledSkinBase(final C labeled) {
        super(labeled);

        // Configure the Text node with all of the attributes from the
        // Labeled which apply to it.
        text = new LabeledText(labeled);

        updateChildren();

        // Labels do not block the mouse by default, unlike most other UI Controls.
        //consumeMouseEvents(false);

        // Register listeners
        /*
         * There are basically 2 things to worry about in each of these handlers
         *  1) Update the Text node
         *  2) Have the text metrics changed?
         *
         * If the metrics have changed, we need to request a layout and invalidate
         * the text so that we recompute the display text on next read.
         */
        registerChangeListener(labeled.ellipsisStringProperty(), o -&gt; {
            textMetricsChanged();
            invalidateWidths();
            ellipsisWidth = Double.NEGATIVE_INFINITY;
        });
        registerChangeListener(labeled.widthProperty(), o -&gt; {
            updateWrappingWidth();
            invalidText = true;
            // No requestLayout() because Control will force a layout
        });
        registerChangeListener(labeled.heightProperty(), o -&gt; {
            invalidText = true;
            // No requestLayout() because Control will force a layout
        });
        registerChangeListener(labeled.fontProperty(), o -&gt; {
            textMetricsChanged();
            invalidateWidths();
            ellipsisWidth = Double.NEGATIVE_INFINITY;
        });
        registerChangeListener(labeled.graphicProperty(), o -&gt; {
            updateChildren();
            textMetricsChanged();
        });
        registerChangeListener(labeled.contentDisplayProperty(), o -&gt; {
            updateChildren();
            textMetricsChanged();
        });
        registerChangeListener(labeled.labelPaddingProperty(), o -&gt; textMetricsChanged());
        registerChangeListener(labeled.graphicTextGapProperty(), o -&gt; textMetricsChanged());
        registerChangeListener(labeled.alignmentProperty(), o -&gt; {
            // Doesn't involve text metrics because if the text is too long, then
            // it will already have fit all available width and a change to hpos
            // has no effect. Or it is too short (i.e. it all fits) and we don't
            // have to worry about truncation. So just call request layout.
            // Doesn't involve text metrics because if the text is too long, then
            // it will already have fit all available height and a change to vpos
            // has no effect. Or it is too short (i.e. it all fits) and we don't
            // have to worry about truncation. So just call request layout.
            getSkinnable().requestLayout();
        });
        registerChangeListener(labeled.mnemonicParsingProperty(), o -&gt; {
            containsMnemonic = false;
            textMetricsChanged();
        });
        registerChangeListener(labeled.textProperty(), o -&gt; {
            updateChildren();
            textMetricsChanged();
            invalidateWidths();
        });
        registerChangeListener(labeled.textAlignmentProperty(), o -&gt; { /* NO-OP */ });
        registerChangeListener(labeled.textOverrunProperty(), o -&gt; textMetricsChanged());
        registerChangeListener(labeled.wrapTextProperty(), o -&gt; {
            updateWrappingWidth();
            textMetricsChanged();
        });
        registerChangeListener(labeled.underlineProperty(), o -&gt; textMetricsChanged());
        registerChangeListener(labeled.lineSpacingProperty(), o -&gt; textMetricsChanged());
        registerChangeListener(labeled.sceneProperty(), o -&gt; sceneChanged());
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Updates the children managed by LabeledSkinBase, which can be the Labeled
     * graphic and/or a Text node. Only those nodes which actually must
     * be used are used. For example, with a ContentDisplay of
     * GRAPHIC_ONLY the text node is not added, and with a ContentDisplay
     * of TEXT_ONLY, the graphic is not added.
     */
    protected void updateChildren() {
        final Labeled labeled = getSkinnable();
        // Only in some situations do we want to have the graphicPropertyChangedListener
        // installed. Since updateChildren() is not called much, we'll just remove it always
        // and reinstall it later if it is necessary to do so.
        if (graphic != null) {
            graphic.layoutBoundsProperty().removeListener(graphicPropertyChangedListener);
        }
        // Now update the graphic (since it may have changed)
        graphic = labeled.getGraphic();

        // RT-19851 Only setMouseTransparent(true) for an ImageView.  This allows the button
        // to be picked regardless of the changing images on top of it.
        if (graphic instanceof ImageView) {
            graphic.setMouseTransparent(true);
        }

        // Now update the children (and add the graphicPropertyChangedListener as necessary)
        if (isIgnoreGraphic()) {
            if (labeled.getContentDisplay() == ContentDisplay.GRAPHIC_ONLY) {
                getChildren().clear();
            } else {
                getChildren().setAll(text);
            }
        } else {
            graphic.layoutBoundsProperty().addListener(graphicPropertyChangedListener);
            if (isIgnoreText()) {
                getChildren().setAll(graphic);
            } else {
                getChildren().setAll(graphic, text);
            }
        }
    }

    /**
     * Compute and return the minimum width of this Labeled. The minimum width is
     * the smaller of the width of &quot;...&quot; and the width with the actual text.
     * In this way, if the text width itself is smaller than the ellipsis then
     * we should use that as the min width, otherwise the ellipsis needs to be the
     * min width.
     * &lt;p&gt;
     * We use the same calculation here regardless of whether we are talking
     * about a single or multiline labeled. So a multiline labeled may find that
     * the width of the &quot;...&quot; is as small as it will ever get.
     */
    @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return computeMinLabeledPartWidth(height, topInset, rightInset, bottomInset, leftInset);
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return computeMinLabeledPartHeight(width, topInset, rightInset, bottomInset, leftInset);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        // Get the preferred width of the text
        final Labeled labeled = getSkinnable();
        final Font font = text.getFont();
        String string = labeled.getText();
        boolean emptyText = string == null || string.isEmpty();
        double widthPadding = leftInset + rightInset;

        if (!isIgnoreText()) {
            widthPadding += leftLabelPadding() + rightLabelPadding();
        }

        double textWidth = 0.0;
        if (!emptyText) {
            if (labeled.isMnemonicParsing()) {
                if (string.contains(&quot;_&quot;) &amp;&amp; (string.indexOf(&quot;_&quot;) != string.length()-1)) {
                    string = string.replaceFirst(&quot;_&quot;, &quot;&quot;);
                }
            }
            textWidth = Utils.computeTextWidth(font, string, 0);
        }

        // Fix for RT-39889
        double graphicWidth = graphic == null ? 0.0 :
                Utils.boundedSize(graphic.prefWidth(-1), graphic.minWidth(-1), graphic.maxWidth(-1));

        // Now add on the graphic, gap, and padding as appropriate
        if (isIgnoreGraphic()) {
            return textWidth + widthPadding;
        } else if (isIgnoreText()) {
            return graphicWidth + widthPadding;
        } else if (labeled.getContentDisplay() == ContentDisplay.LEFT
                || labeled.getContentDisplay() == ContentDisplay.RIGHT) {
            return textWidth + labeled.getGraphicTextGap() + graphicWidth + widthPadding;
        } else {
            return Math.max(textWidth, graphicWidth) + widthPadding;
        }
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        final Labeled labeled = getSkinnable();
        final Font font = text.getFont();
        final ContentDisplay contentDisplay = labeled.getContentDisplay();
        final double gap = labeled.getGraphicTextGap();

        width -= leftInset + rightInset;

        if (!isIgnoreText()) {
            width -= leftLabelPadding() + rightLabelPadding();
        }

        String str = labeled.getText();
        if (str != null &amp;&amp; str.endsWith(&quot;\n&quot;)) {
            // Strip ending newline so we don't count another row.
            str = str.substring(0, str.length() - 1);
        }

        double textWidth = width;
        if (!isIgnoreGraphic() &amp;&amp;
                (contentDisplay == LEFT || contentDisplay == RIGHT)) {
            textWidth -= (graphic.prefWidth(-1) + gap);
        }

        // TODO figure out how to cache this effectively.
        final double textHeight = Utils.computeTextHeight(font, str,
                labeled.isWrapText() ? textWidth : 0,
                labeled.getLineSpacing(), text.getBoundsType());

        // Now we want to add on the graphic if necessary!
        double h = textHeight;
        if (!isIgnoreGraphic()) {
            final Node graphic = labeled.getGraphic();
            if (contentDisplay == TOP || contentDisplay == BOTTOM) {
                h = graphic.prefHeight(width) + gap + textHeight;
            } else {
                h = Math.max(textHeight, graphic.prefHeight(width));
            }
        }

        double padding = topInset + bottomInset;

        if (!isIgnoreText()) {
            padding += topLabelPadding() + bottomLabelPadding();
        }

        return  h + padding;
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return getSkinnable().prefWidth(height);
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return getSkinnable().prefHeight(width);
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        double textBaselineOffset = text.getBaselineOffset();
        double h = textBaselineOffset;
        final Labeled labeled = getSkinnable();
        final Node g = labeled.getGraphic();
        if (!isIgnoreGraphic()) {
            ContentDisplay contentDisplay = labeled.getContentDisplay();
            if (contentDisplay == ContentDisplay.TOP) {
                h = g.prefHeight(-1) + labeled.getGraphicTextGap() + textBaselineOffset;
            } else if (contentDisplay == ContentDisplay.LEFT || contentDisplay == RIGHT) {
                h = textBaselineOffset + (g.prefHeight(-1) - text.prefHeight(-1)) / 2;
            }
        }

        double offset = topInset + h;
        if (!isIgnoreText()) {
            offset += topLabelPadding();
        }
        return offset;
    }

    /**
     * The Layout algorithm works like this:
     *
     *  - Get the labeled w/h, graphic w/h, text w/h
     *  - Compute content w/h based on graphicVPos, graphicHPos,
     *    graphicTextGap, and graphic w/h and text w/h
     *  - (Note that the text content has been pre-truncated where
     *    necessary)
     *  - compute content x/y based on content w/h and labeled w/h
     *    and the labeled's hpos and vpos
     *  - position the graphic and text
     */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        layoutLabelInArea(x, y, w, h);
    }

    /**
     * Performs the actual layout of the label content within the area given.
     * This method is called by subclasses that override layoutChildren().
     *
     * @param x The x position of the label part of the control, inside padding
     *
     * @param y The y position of the label part of the control, inside padding
     *
     * @param w The width of the label part of the control, not including padding
     *
     * @param h The height of the label part of the control, not including padding
     */
    protected void layoutLabelInArea(double x, double y, double w, double h) {
        layoutLabelInArea(x, y, w, h, null);
    }

    /**
     * Performs the actual layout of the label content within the area given.
     * This method is called by subclasses that override layoutChildren().
     *
     * @param x The x position of the label part of the control, inside padding
     *
     * @param y The y position of the label part of the control, inside padding
     *
     * @param w The width of the label part of the control, not including padding
     *
     * @param h The height of the label part of the control, not including padding
     *
     * @param alignment The alignment of the label part of the control within the given area. If null, then the control's alignment will be used.
     */
    protected void layoutLabelInArea(double x, double y, double w, double h, Pos alignment) {
        // References to essential labeled state
        final Labeled labeled = getSkinnable();
        final ContentDisplay contentDisplay = labeled.getContentDisplay();

        if (alignment == null) {
            alignment = labeled.getAlignment();
        }

        final HPos hpos = alignment == null ? HPos.LEFT   : alignment.getHpos();
        final VPos vpos = alignment == null ? VPos.CENTER : alignment.getVpos();

        // Figure out whether we should ignore the Graphic, and/or
        // ignore the Text
        final boolean ignoreGraphic = isIgnoreGraphic();
        final boolean ignoreText = isIgnoreText();

        if (!ignoreText) {
            x += leftLabelPadding();
            y += topLabelPadding();
            w -= leftLabelPadding() + rightLabelPadding();
            h -= topLabelPadding() + bottomLabelPadding();
        }

        // Compute some standard useful numbers for the graphic, text, and gap
        double graphicWidth;
        double graphicHeight;
        double textWidth;
        double textHeight;

        if (ignoreGraphic) {
            graphicWidth = graphicHeight = 0;
        } else if (ignoreText) {
            if (graphic.isResizable()) {
                Orientation contentBias = graphic.getContentBias();
                if (contentBias == Orientation.HORIZONTAL) {
                    graphicWidth  = Utils.boundedSize(w, graphic.minWidth(-1), graphic.maxWidth(-1));
                    graphicHeight = Utils.boundedSize(h, graphic.minHeight(graphicWidth), graphic.maxHeight(graphicWidth));
                } else if (contentBias == Orientation.VERTICAL) {
                    graphicHeight = Utils.boundedSize(h, graphic.minHeight(-1), graphic.maxHeight(-1));
                    graphicWidth  = Utils.boundedSize(w, graphic.minWidth(graphicHeight), graphic.maxWidth(graphicHeight));
                } else {
                    graphicWidth  = Utils.boundedSize(w, graphic.minWidth(-1), graphic.maxWidth(-1));
                    graphicHeight = Utils.boundedSize(h, graphic.minHeight(-1), graphic.maxHeight(-1));
                }
                graphic.resize(graphicWidth, graphicHeight);
            } else {
                graphicWidth = graphic.getLayoutBounds().getWidth();
                graphicHeight = graphic.getLayoutBounds().getHeight();
            }
        } else {
            graphic.autosize(); // We have to do this before getting metrics
            graphicWidth = graphic.getLayoutBounds().getWidth();
            graphicHeight = graphic.getLayoutBounds().getHeight();
        }

        if (ignoreText) {
            textWidth  = textHeight = 0;
            text.setText(&quot;&quot;);
        } else {
            updateDisplayedText(w, h); // Have to do this just in case it needs to be recomputed
            textWidth  = snapSizeX(Math.min(text.getLayoutBounds().getWidth(),  wrapWidth));
            textHeight = snapSizeY(Math.min(text.getLayoutBounds().getHeight(), wrapHeight));
        }

        final double gap = (ignoreText || ignoreGraphic) ? 0 : labeled.getGraphicTextGap();

        // Figure out the contentWidth and contentHeight. This is the width
        // and height of the Labeled and Graphic together, not the available
        // content area (which would be a different calculation).
        double contentWidth = Math.max(graphicWidth, textWidth);
        double contentHeight = Math.max(graphicHeight, textHeight);
        if (contentDisplay == ContentDisplay.TOP || contentDisplay == ContentDisplay.BOTTOM) {
            contentHeight = graphicHeight + gap + textHeight;
        } else if (contentDisplay == ContentDisplay.LEFT || contentDisplay == ContentDisplay.RIGHT) {
            contentWidth = graphicWidth + gap + textWidth;
        }

        // Now we want to compute the x/y location to place the content at.

        // Compute the contentX position based on hpos and the space available
        double contentX;
        if (hpos == HPos.LEFT) {
            contentX = x;
        } else if (hpos == HPos.RIGHT) {
            contentX = x + (w - contentWidth);
        } else {
            // TODO Baseline may not be handled correctly
            // may have been CENTER or null, treat as center
            contentX = (x + ((w - contentWidth) / 2.0));
        }

        // Compute the contentY position based on vpos and the space available
        double contentY;
        if (vpos == VPos.TOP) {
            contentY = y;
        } else if (vpos == VPos.BOTTOM) {
            contentY = (y + (h - contentHeight));
        } else {
            // TODO Baseline may not be handled correctly
            // may have been CENTER, BASELINE, or null, treat as center
            contentY = (y + ((h - contentHeight) / 2.0));
        }

        Point2D mnemonicPos = null;
        double mnemonicWidth = 0.0;
        double mnemonicHeight = 0.0;
        if (containsMnemonic) {
            final Font font = text.getFont();
            String preSt = bindings.getText();
            mnemonicPos = Utils.computeMnemonicPosition(font, preSt, bindings.getMnemonicIndex(), this.wrapWidth, labeled.getLineSpacing());
            mnemonicWidth = Utils.computeTextWidth(font, preSt.substring(bindings.getMnemonicIndex(), bindings.getMnemonicIndex() + 1), 0);
            mnemonicHeight = Utils.computeTextHeight(font, &quot;_&quot;, 0, text.getBoundsType());
        }


        // Now to position the graphic and text. At this point I know the
        // contentX and contentY locations (including the padding and whatnot
        // that was defined on the Labeled). I also know the content width and
        // height. So now I just need to lay out the graphic and text within
        // that content x/y/w/h area.
        if ((!ignoreGraphic || !ignoreText) &amp;&amp; !text.isManaged()) {
            text.setManaged(true);
        }

        if (ignoreGraphic &amp;&amp; ignoreText) {
            // There might be a text node as a child, or a graphic node as
            // a child. However we don't have to do anything for the graphic
            // node because the only way it can be a child and still have
            // ignoreGraphic true is if it is unmanaged. Text however might
            // be a child but still not matter, in which case we will just
            // stop managing it (although really I wish it just wasn't here
            // all all in that case)
            if (text.isManaged()) {
                text.setManaged(false);
            }
            text.relocate(snapPositionX(contentX), snapPositionY(contentY));
        } else if (ignoreGraphic) {
            // Since I only have to position the text, it goes at the
            // contentX/contentY location. Note that positionNode will
            // adjust the text based on the text's minX/minY so no need to
            // worry about that here
            text.relocate(snapPositionX(contentX), snapPositionY(contentY));
            if (containsMnemonic &amp;&amp; (mnemonicPos != null)) {
                mnemonic_underscore.setEndX(mnemonicWidth-2.0);
                mnemonic_underscore.relocate(snapPositionX(contentX + mnemonicPos.getX()),
                                             snapPositionY(contentY + mnemonicPos.getY()));
            }

        } else if (ignoreText) {
            // there isn't text to display, so we need to position it
            // such that it doesn't affect the content area (although when
            // there is a graphic, the text isn't even in the scene)
            text.relocate(snapPositionX(contentX), snapPositionY(contentY));
            graphic.relocate(snapPositionX(contentX), snapPositionY(contentY));
            if (containsMnemonic &amp;&amp; (mnemonicPos != null)) {
                mnemonic_underscore.setEndX(mnemonicWidth);
                mnemonic_underscore.setStrokeWidth(mnemonicHeight/10.0);
                mnemonic_underscore.relocate(snapPositionX(contentX + mnemonicPos.getX()),
                                             snapPositionY(contentY + mnemonicPos.getY()));
            }
        } else {
            // There is both text and a graphic, so I need to position them
            // relative to each other
            double graphicX = 0;
            double graphicY = 0;
            double textX = 0;
            double textY = 0;

            if (contentDisplay == ContentDisplay.TOP) {
                graphicX = contentX + ((contentWidth - graphicWidth) / 2.0);
                textX = contentX + ((contentWidth - textWidth) / 2.0);
                // The graphic is above the text, so it is positioned at
                // graphicY and the text below it.
                graphicY = contentY;
                textY = graphicY + graphicHeight + gap;
            } else if (contentDisplay == ContentDisplay.RIGHT) {
                // The graphic is to the right of the text
                textX = contentX;
                graphicX = textX + textWidth + gap;
                graphicY = contentY + ((contentHeight - graphicHeight) / 2.0);
                textY = contentY + ((contentHeight - textHeight) / 2.0);
            } else if (contentDisplay == ContentDisplay.BOTTOM) {
                graphicX = contentX + ((contentWidth - graphicWidth) / 2.0);
                textX = contentX + ((contentWidth - textWidth) / 2.0);
                // The graphic is below the text
                textY = contentY;
                graphicY = textY + textHeight + gap;
            } else if (contentDisplay == ContentDisplay.LEFT) {
                // The graphic is to the left of the text, so the graphicX is
                // simply the contentX and the textX is to the right of it.
                graphicX = contentX;
                textX = graphicX + graphicWidth + gap;
                graphicY = contentY + ((contentHeight - graphicHeight) / 2.0);
                textY = contentY + ((contentHeight - textHeight) / 2.0);
            } else if (contentDisplay == ContentDisplay.CENTER) {
                graphicX = contentX + ((contentWidth - graphicWidth) / 2.0);
                textX = contentX + ((contentWidth - textWidth) / 2.0);
                graphicY = contentY + ((contentHeight - graphicHeight) / 2.0);
                textY = contentY + ((contentHeight - textHeight) / 2.0);
            }
            text.relocate(snapPositionX(textX), snapPositionY(textY));
            if (containsMnemonic &amp;&amp; (mnemonicPos != null)) {
                mnemonic_underscore.setEndX(mnemonicWidth);
                mnemonic_underscore.setStrokeWidth(mnemonicHeight/10.0);
                mnemonic_underscore.relocate(snapPositionX(textX + mnemonicPos.getX()),
                                             snapPositionY(textY + mnemonicPos.getY()));
            }
            graphic.relocate(snapPositionX(graphicX), snapPositionY(graphicY));
        }

        /**
         * check if the label text overflows it's bounds.
         * If there's an overflow, and no text clip then
         * we'll clip it.
         * If there is no overflow, and the label text has a
         * clip, then remove it.
         */
        if ((text != null) &amp;&amp;
                ((text.getLayoutBounds().getHeight() &gt; wrapHeight) ||
                        (text.getLayoutBounds().getWidth() &gt; wrapWidth))) {

            if (textClip == null) {
                textClip = new Rectangle();
            }

            if (labeled.getEffectiveNodeOrientation() == NodeOrientation.LEFT_TO_RIGHT) {
                textClip.setX(text.getLayoutBounds().getMinX());
            } else {
                textClip.setX(text.getLayoutBounds().getMaxX() - wrapWidth);
            }
            textClip.setY(text.getLayoutBounds().getMinY());
            textClip.setWidth(wrapWidth);
            textClip.setHeight(wrapHeight);
            if (text.getClip() == null) {
                text.setClip(textClip);
            }
        }
        else {
            /**
             * content fits inside bounds, no need
             * for a clip
             */
            if (text.getClip() != null) {
                text.setClip(null);
            }
        }
    }

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case TEXT: {
                Labeled labeled = getSkinnable();
                String accText = labeled.getAccessibleText();
                if (accText != null &amp;&amp; !accText.isEmpty()) return accText;

                /* Use the text in the binding if available to handle mnemonics */
                if (bindings != null) {
                    String text = bindings.getText();
                    if (text != null &amp;&amp; !text.isEmpty()) return text;
                }
                /* Avoid the content in text.getText() as it can contain ellipses
                 * for clipping
                 */
                String text = labeled.getText();
                if (text != null &amp;&amp; !text.isEmpty()) return text;

                /* Use the graphic as last resource. Note that this implementation
                 * does not attempt to combine the label and graphics if both
                 * are being displayed
                 */
                if (graphic != null) {
                    Object result = graphic.queryAccessibleAttribute(AccessibleAttribute.TEXT);
                    if (result != null) return result;
                }
                return null;
            }
            case MNEMONIC: {
                if (bindings != null) {
                    return bindings.getMnemonic();
                }
                return null;
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private double computeMinLabeledPartWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        // First compute the minTextWidth by checking the width of the string
        // made by the ellipsis &quot;...&quot;, and then by checking the width of the
        // string made up by labeled.text. We want the smaller of the two.
        final Labeled labeled = getSkinnable();
        final ContentDisplay contentDisplay = labeled.getContentDisplay();
        final double gap = labeled.getGraphicTextGap();
        double minTextWidth = 0;

        final Font font = text.getFont();
        OverrunStyle truncationStyle = labeled.getTextOverrun();
        String ellipsisString = labeled.getEllipsisString();
        final String string = labeled.getText();
        final boolean emptyText = string == null || string.isEmpty();

        if (!emptyText) {
            // We only want to recompute the full text width if the font or text changed
            if (truncationStyle == CLIP) {
                if (textWidth == Double.NEGATIVE_INFINITY) {
                    // Show at minimum the first character
                    textWidth = Utils.computeTextWidth(font, string.substring(0, 1), 0);
                }
                minTextWidth = textWidth;
            } else {
                if (textWidth == Double.NEGATIVE_INFINITY) {
                    textWidth = Utils.computeTextWidth(font, string, 0);
                }
                // We only want to recompute the ellipsis width if the font has changed
                if (ellipsisWidth == Double.NEGATIVE_INFINITY) {
                    ellipsisWidth = Utils.computeTextWidth(font, ellipsisString, 0);
                }
                minTextWidth = Math.min(textWidth, ellipsisWidth);
            }
        }

        // Now inspect the graphic and the hpos to determine the the minWidth
        final Node graphic = labeled.getGraphic();
        double width;
        if (isIgnoreGraphic()) {
            width = minTextWidth;
        } else if (isIgnoreText()) {
            width = graphic.minWidth(-1);
        } else if (contentDisplay == LEFT || contentDisplay == RIGHT){
            width = (minTextWidth + graphic.minWidth(-1) + gap);
        } else {
            width = Math.max(minTextWidth, graphic.minWidth(-1));
        }

        double padding = leftInset + rightInset;
        if (!isIgnoreText()) {
            padding += leftLabelPadding() + rightLabelPadding();
        }

        return width + padding;
    }

    private double computeMinLabeledPartHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        final Labeled labeled = getSkinnable();
        final Font font = text.getFont();

        String str = labeled.getText();
        if (str != null &amp;&amp; str.length() &gt; 0) {
            int newlineIndex = str.indexOf('\n');
            if (newlineIndex &gt;= 0) {
                str = str.substring(0, newlineIndex);
            }
        }

        // TODO figure out how to cache this effectively.
        // Base minimum height on one line (ignoring wrapping here).
        double s = labeled.getLineSpacing();
        final double textHeight = Utils.computeTextHeight(font, str, 0, s, text.getBoundsType());

        double h = textHeight;

        // Now we want to add on the graphic if necessary!
        if (!isIgnoreGraphic()) {
            final Node graphic = labeled.getGraphic();
            if (labeled.getContentDisplay() == ContentDisplay.TOP
                    || labeled.getContentDisplay() == ContentDisplay.BOTTOM) {
                h = graphic.minHeight(width) + labeled.getGraphicTextGap() + textHeight;
            } else {
                h = Math.max(textHeight, graphic.minHeight(width));
            }
        }

        double padding = topInset + bottomInset;
        if (!isIgnoreText()) {
            padding += topLabelPadding() - bottomLabelPadding();
        }
        return h + padding;
    }

    double topLabelPadding() {
        return snapSizeY(getSkinnable().getLabelPadding().getTop());
    }

    double bottomLabelPadding() {
        return snapSizeY(getSkinnable().getLabelPadding().getBottom());
    }

    double leftLabelPadding() {
        return snapSizeX(getSkinnable().getLabelPadding().getLeft());
    }

    double rightLabelPadding() {
        return snapSizeX(getSkinnable().getLabelPadding().getRight());
    }


    /**
     * Called whenever some state has changed that affects the text metrics.
     * Changes here will involve invalidating the display text so the next
     * call to updateDisplayedText computes a new value, and call requestLayout.
     */
    private void textMetricsChanged() {
        invalidText = true;
        getSkinnable().requestLayout();
    }

    /*
    ** The Label is a mnemonic, and it's target node
    ** has changed, but it's label hasn't so just
    ** swap them over, and tidy up.
    */
    void mnemonicTargetChanged() {
        if (containsMnemonic == true) {
            /*
            ** was there previously a labelFor
            */
            removeMnemonic();

            /*
            ** is there a new labelFor
            */
            Control control = getSkinnable();
            if (control instanceof Label) {
                labeledNode = ((Label)control).getLabelFor();
                addMnemonic();
            }
            else {
                labeledNode = null;
            }
        }
    }

    private void sceneChanged() {
        final Labeled labeled = getSkinnable();
        Scene scene = labeled.getScene();

        if (scene != null &amp;&amp; containsMnemonic) {
<A NAME="40"></A>            addMnemonic();
        }

    <FONT color="#347235"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#40',2,'match31-top.html#40',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    /**
     * Marks minWidth as being invalid and in need of recomputation.
     */
    private void invalidateWidths() {
        textWidth = Double.NEGATIVE_INFINITY;
    }

    /**
     * Updates the content of the underlying Text node. This method should
     * only be called when necessary. If the invalidText flag is not set, then
     * the method is a no-op. This care is taken because recomputing the
     * text to display is an expensive operation. Package private ONLY FOR THE
     * SAKE OF TESTING.
     */
    void updateDisplayedText() {
        updateDisplayedText(-1, -1);
    }</B></FONT>

    private void updateDisplayedText(double w, double h) {
        if (invalidText) {
            final Labeled labeled = getSkinnable();
            String s = labeled.getText();

            int mnemonicIndex = -1;

            /*
            ** if there's a valid string then parse it
            */
            if (s != null &amp;&amp; s.length() &gt; 0) {
                bindings = new TextBinding(s);

                if (!com.sun.javafx.PlatformUtil.isMac() &amp;&amp; getSkinnable().isMnemonicParsing() == true) {
                    /*
                    ** the Labeled has a MnemonicParsing property,
                    ** if set true, then auto-parsing will check for
                    ** a mnemonic
                    */
                    if (labeled instanceof Label) {
                        // buttons etc
                        labeledNode = ((Label)labeled).getLabelFor();
                    } else {
                        labeledNode = labeled;
                    }

                    if (labeledNode == null) {
                        labeledNode = labeled;
                    }
                    mnemonicIndex = bindings.getMnemonicIndex() ;
                }
            }

            /*
            ** we were previously a mnemonic
            */
            if (containsMnemonic) {
                /*
                ** are we no longer a mnemonic, or have we changed code?
                */
                if (mnemonicScene != null) {
                    if (mnemonicIndex == -1 ||
                            (bindings != null &amp;&amp; !bindings.getMnemonicKeyCombination().equals(mnemonicCode))) {
                        removeMnemonic();
                        containsMnemonic = false;
                    }
                }
            }
            else {
                /*
                ** this can happen if mnemonic parsing is
                ** disabled on a previously valid mnemonic
                */
                removeMnemonic();
            }

            /*
            ** check we have a labeled
            */
            if (s != null &amp;&amp; s.length() &gt; 0) {
                if (mnemonicIndex &gt;= 0 &amp;&amp; containsMnemonic == false) {
                    containsMnemonic = true;
                    mnemonicCode = bindings.getMnemonicKeyCombination();
                    addMnemonic();
                }
            }

            if (containsMnemonic == true) {
                s = bindings.getText();
                if (mnemonic_underscore == null) {
                    mnemonic_underscore = new Line();
                    mnemonic_underscore.setStartX(0.0f);
                    mnemonic_underscore.setStartY(0.0f);
                    mnemonic_underscore.setEndY(0.0f);
                    mnemonic_underscore.getStyleClass().clear();
                    mnemonic_underscore.getStyleClass().setAll(&quot;mnemonic-underline&quot;);
                }
                if (!getChildren().contains(mnemonic_underscore)) {
                    getChildren().add(mnemonic_underscore);
                }
            } else {
                /*
                ** we don't need a mnemonic....
                */
                if (getSkinnable().isMnemonicParsing() == true &amp;&amp; com.sun.javafx.PlatformUtil.isMac() &amp;&amp; bindings != null) {
                    s = bindings.getText();
                }
                else {
                    s = labeled.getText();
                }
                if (mnemonic_underscore != null) {
                    if (getChildren().contains(mnemonic_underscore)) {
                        Platform.runLater(() -&gt; {
                              getChildren().remove(mnemonic_underscore);
                              mnemonic_underscore = null;
                        });
                    }
                }
            }

            int len = s != null ? s.length() : 0;
            boolean multiline = false;

            if (s != null &amp;&amp; len &gt; 0) {
                int i = s.indexOf('\n');
                if (i &gt; -1 &amp;&amp; i &lt; len - 1) {
                    // Multiline text with embedded newlines - not
                    // taking into account a potential trailing newline.
                    multiline = true;
                }
            }

            String result;
            boolean horizontalPosition =
                    (labeled.getContentDisplay() == ContentDisplay.LEFT ||
                    labeled.getContentDisplay() == ContentDisplay.RIGHT);

            double availableWidth = labeled.getWidth() -
                    snappedLeftInset() - snappedRightInset();

            if (!isIgnoreText()) {
                availableWidth -= leftLabelPadding() + rightLabelPadding();
            }
            availableWidth = Math.max(availableWidth, 0);

            if (w == -1) {
                w = availableWidth;
            }
            double minW = Math.min(computeMinLabeledPartWidth(-1, snappedTopInset() , snappedRightInset(), snappedBottomInset(), snappedLeftInset()), availableWidth);
            if (horizontalPosition &amp;&amp; !isIgnoreGraphic()) {
                double graphicW = (labeled.getGraphic().getLayoutBounds().getWidth() + labeled.getGraphicTextGap());
                w -= graphicW;
                minW -= graphicW;
            }
            wrapWidth = Math.max(minW, w);

            boolean verticalPosition =
                    (labeled.getContentDisplay() == ContentDisplay.TOP ||
                    labeled.getContentDisplay() == ContentDisplay.BOTTOM);

            double availableHeight = labeled.getHeight() -
                    snappedTopInset() - snappedBottomInset();

            if (!isIgnoreText()) {
                availableHeight -= topLabelPadding() + bottomLabelPadding();
            }
            availableHeight = Math.max(availableHeight, 0);

            if (h == -1) {
                h = availableHeight;
            }
            double minH = Math.min(computeMinLabeledPartHeight(wrapWidth, snappedTopInset() , snappedRightInset(), snappedBottomInset(), snappedLeftInset()), availableHeight);
            if (verticalPosition &amp;&amp; labeled.getGraphic() != null) {
                double graphicH = labeled.getGraphic().getLayoutBounds().getHeight() + labeled.getGraphicTextGap();
                h -= graphicH;
                minH -= graphicH;
            }
            wrapHeight = Math.max(minH, h);

            updateWrappingWidth();

            Font font = text.getFont();
            OverrunStyle truncationStyle = labeled.getTextOverrun();
            String ellipsisString = labeled.getEllipsisString();

            if (labeled.isWrapText()) {
                result = Utils.computeClippedWrappedText(font, s, wrapWidth, wrapHeight, truncationStyle, ellipsisString, text.getBoundsType());
            } else if (multiline) {
                StringBuilder sb = new StringBuilder();

                String[] splits = s.split(&quot;\n&quot;);
                for (int i = 0; i &lt; splits.length; i++) {
                    sb.append(Utils.computeClippedText(font, splits[i], wrapWidth, truncationStyle, ellipsisString));
                    if (i &lt; splits.length - 1) {
                        sb.append('\n');
                    }
                }

                // TODO: Consider what to do in the case where vertical space is
                // limited and the last visible line isn't already truncated
                // with a trailing ellipsis. What if the style calls for leading
                // or center ellipses? We could possibly add an additional
                // trailing ellipsis to the last visible line, like this:

                // +--------------------------------+
                // |  This is some long text with multiple lines\n
                // |  where more than one exceed the|width\n
                // |  and wrapText is false, and all|lines\n
                // +--don't fit.--------------------+
                //
                // +--------------------------------+
                // |  This is some...multiple lines |
                // |  where more t...ceed the width |
                // |  and wrapText...d all lines... |
                // +--------------------------------+

                result = sb.toString();
            } else {
                result = Utils.computeClippedText(font, s, wrapWidth, truncationStyle, ellipsisString);
            }

            if (result != null &amp;&amp; result.endsWith(&quot;\n&quot;)) {
                // Strip ending newline so we don't display another row.
                result = result.substring(0, result.length() - 1);
            }

            text.setText(result);
            updateWrappingWidth();
            invalidText = false;
        }
    }

    private void addMnemonic() {
        if (labeledNode != null) {
            mnemonicScene = labeledNode.getScene();
            if (mnemonicScene != null) {
                mnemonicScene.addMnemonic(new Mnemonic(labeledNode, mnemonicCode));
            }
        }
    }


    private void removeMnemonic() {
        if (mnemonicScene != null &amp;&amp; labeledNode != null) {
            mnemonicScene.removeMnemonic(new Mnemonic(labeledNode, mnemonicCode));
            mnemonicScene = null;
        }
    }

    /**
     * Updates the wrapping width of the text node. Although changing the font
     * does affect the metrics used for text layout, this method does not
     * call requestLayout or invalidate the text, since it may be called
     * from the constructor and such work would be duplicative and wasted.
     */
    private void updateWrappingWidth() {
        final Labeled labeled = getSkinnable();
        text.setWrappingWidth(0);
        if (labeled.isWrapText()) {
            // Note that the wrapping width needs to be set to zero before
            // getting the text's real preferred width.
            double w = Math.min(text.prefWidth(-1), wrapWidth);
            text.setWrappingWidth(w);
        }
    }

    /**
     * Gets whether for various computations we can ignore the presence of the graphic
     * (or lack thereof).
     * @return
     */
    boolean isIgnoreGraphic() {
        return (graphic == null ||
                !graphic.isManaged() ||
                getSkinnable().getContentDisplay() == ContentDisplay.TEXT_ONLY);
    }

    /**
     * Gets whether for various computations we can ignore the presence of the text.
     * @return
     */
    boolean isIgnoreText() {
        final Labeled labeled = getSkinnable();
        final String txt = labeled.getText();
        return (txt == null ||
                txt.equals(&quot;&quot;) ||
                labeled.getContentDisplay() == ContentDisplay.GRAPHIC_ONLY);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TableHeaderRow.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import java.util.*;

import javafx.beans.InvalidationListener;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.StringProperty;
import javafx.collections.ListChangeListener;
import javafx.collections.WeakListChangeListener;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.geometry.Side;
import javafx.geometry.VPos;
import javafx.scene.control.CheckMenuItem;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Control;
import javafx.scene.control.Label;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableColumnBase;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;

import com.sun.javafx.scene.control.skin.resources.ControlResources;

/**
 * Region responsible for painting the entire row of column headers.
 *
 * @since 9
 * @see javafx.scene.control.TableView
 * @see TableViewSkin
 * @see javafx.scene.control.TreeTableView
 * @see TreeTableViewSkin
 */
public class TableHeaderRow extends StackPane {

    /***************************************************************************
     *                                                                         *
     * Static Fields                                                           *
     *                                                                         *
     **************************************************************************/


    /***************************************************************************
     *                                                                         *
     * Private Fields                                                          *
     *                                                                         *
     **************************************************************************/

    // JDK-8090129: This constant should not be static, because the
    // Locale may change between instances.
    private final String MENU_SEPARATOR =
            ControlResources.getString(&quot;TableView.nestedColumnControlMenuSeparator&quot;);

    private final VirtualFlow flow;
    final TableViewSkinBase&lt;?,?,?,?,?&gt; tableSkin;
    private Map&lt;TableColumnBase, CheckMenuItem&gt; columnMenuItems = new HashMap&lt;TableColumnBase, CheckMenuItem&gt;();
    private double scrollX;
    private double tableWidth;
    private Rectangle clip;
    private TableColumnHeader reorderingRegion;

    /**
     * This is the ghosted region representing the table column that is being
     * dragged. It moves along the x-axis but is fixed in the y-axis.
     */
    private StackPane dragHeader;
    private final Label dragHeaderLabel = new Label();

    private Region filler;

    /**
     * This is the region where the user can interact with to show/hide columns.
     * It is positioned in the top-right hand corner of the TableHeaderRow, and
     * when clicked shows a PopupMenu consisting of all leaf columns.
     */
    private Pane cornerRegion;

    /**
     * PopupMenu shown to users to allow for them to hide/show columns in the
     * table.
     */
    private ContextMenu columnPopupMenu;

    /**
     * There are two different mouse dragged event handlers in the header code.
     * Firstly, the column reordering functionality, and secondly, the column
     * resizing functionality. Because these are handled in separate classes and
     * with separate event handlers, we occasionally run into the issue where
     * both event handlers were being called, resulting in bad UX. To remove this
     * issue, we lock when the column dragging happens, and prevent resize operations
     * from taking place.
     */
    boolean columnDragLock = false;



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private InvalidationListener tableWidthListener = o -&gt; updateTableWidth();

    private InvalidationListener tablePaddingListener = o -&gt; updateTableWidth();

    // This is necessary for RT-20300 (but was updated for RT-20840)
    private ListChangeListener visibleLeafColumnsListener = c -&gt; getRootHeader().setHeadersNeedUpdate();

    private final ListChangeListener tableColumnsListener = c -&gt; {
        while (c.next()) {
            updateTableColumnListeners(c.getAddedSubList(), c.getRemoved());
        }
    };

    private final InvalidationListener columnTextListener = observable -&gt; {
        TableColumnBase&lt;?,?&gt; column = (TableColumnBase&lt;?,?&gt;) ((StringProperty)observable).getBean();
        CheckMenuItem menuItem = columnMenuItems.get(column);
        if (menuItem != null) {
            menuItem.setText(getText(column.getText(), column));
        }
    };

    private final WeakInvalidationListener weakTableWidthListener =
            new WeakInvalidationListener(tableWidthListener);

    private final WeakInvalidationListener weakTablePaddingListener =
            new WeakInvalidationListener(tablePaddingListener);

    private final WeakListChangeListener weakVisibleLeafColumnsListener =
            new WeakListChangeListener(visibleLeafColumnsListener);

    private final WeakListChangeListener weakTableColumnsListener =
            new WeakListChangeListener(tableColumnsListener);

    private final WeakInvalidationListener weakColumnTextListener =
            new WeakInvalidationListener(columnTextListener);



    /***************************************************************************
     *                                                                         *
     * Constructor                                                             *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new TableHeaderRow instance to visually represent the column
     * header area of controls such as {@link javafx.scene.control.TableView} and
     * {@link javafx.scene.control.TreeTableView}.
     *
     * @param skin The skin used by the UI control.
     */
    public TableHeaderRow(final TableViewSkinBase skin) {
        this.tableSkin = skin;
        this.flow = skin.flow;

        getStyleClass().setAll(&quot;column-header-background&quot;);

        // clip the header so it doesn't show outside of the table bounds
        clip = new Rectangle();
        clip.setSmooth(false);
        clip.heightProperty().bind(heightProperty());
        setClip(clip);

        // listen to table width to keep header in sync
        updateTableWidth();
        tableSkin.getSkinnable().widthProperty().addListener(weakTableWidthListener);
        tableSkin.getSkinnable().paddingProperty().addListener(weakTablePaddingListener);
        TableSkinUtils.getVisibleLeafColumns(skin).addListener(weakVisibleLeafColumnsListener);

        // popup menu for hiding/showing columns
        columnPopupMenu = new ContextMenu();
        updateTableColumnListeners(TableSkinUtils.getColumns(tableSkin), Collections.&lt;TableColumnBase&lt;?,?&gt;&gt;emptyList());
        TableSkinUtils.getVisibleLeafColumns(skin).addListener(weakTableColumnsListener);
        TableSkinUtils.getColumns(tableSkin).addListener(weakTableColumnsListener);

        // drag header region. Used to indicate the current column being reordered
        dragHeader = new StackPane();
        dragHeader.setVisible(false);
        dragHeader.getStyleClass().setAll(&quot;column-drag-header&quot;);
        dragHeader.setManaged(false);
        dragHeader.setMouseTransparent(true);
        dragHeader.getChildren().add(dragHeaderLabel);

        // the header lives inside a NestedTableColumnHeader
        NestedTableColumnHeader rootHeader = createRootHeader();
        setRootHeader(rootHeader);
        rootHeader.setFocusTraversable(false);
        rootHeader.setTableHeaderRow(this);

        // The 'filler' area that extends from the right-most column to the edge
        // of the tableview, or up to the 'column control' button
        filler = new Region();
        filler.getStyleClass().setAll(&quot;filler&quot;);

        // Give focus to the table when an empty area of the header row is clicked.
        // This ensures the user knows that the table has focus.
        setOnMousePressed(e -&gt; {
            skin.getSkinnable().requestFocus();
        });

        // build the corner region button for showing the popup menu
        final StackPane image = new StackPane();
        image.setSnapToPixel(false);
        image.getStyleClass().setAll(&quot;show-hide-column-image&quot;);
        cornerRegion = new StackPane() {
            @Override protected void layoutChildren() {
                double imageWidth = image.snappedLeftInset() + image.snappedRightInset();
                double imageHeight = image.snappedTopInset() + image.snappedBottomInset();

                image.resize(imageWidth, imageHeight);
                positionInArea(image, 0, 0, getWidth(), getHeight() - 3,
                        0, HPos.CENTER, VPos.CENTER);
            }
        };
        cornerRegion.getStyleClass().setAll(&quot;show-hide-columns-button&quot;);
        cornerRegion.getChildren().addAll(image);

        BooleanProperty tableMenuButtonVisibleProperty = TableSkinUtils.tableMenuButtonVisibleProperty(skin);
        if (tableMenuButtonVisibleProperty != null) {
            cornerRegion.visibleProperty().bind(tableMenuButtonVisibleProperty);
        };

        cornerRegion.setOnMousePressed(me -&gt; {
            // show a popupMenu which lists all columns
            columnPopupMenu.show(cornerRegion, Side.BOTTOM, 0, 0);
            me.consume();
        });

        // the actual header
        // the region that is anchored above the vertical scrollbar
        // a 'ghost' of the header being dragged by the user to force column
        // reordering
        getChildren().addAll(filler, rootHeader, cornerRegion, dragHeader);
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- reordering
    private BooleanProperty reordering = new SimpleBooleanProperty(this, &quot;reordering&quot;, false) {
        @Override protected void invalidated() {
            TableColumnHeader r = getReorderingRegion();
            if (r != null) {
                double dragHeaderHeight = r.getNestedColumnHeader() != null ?
                        r.getNestedColumnHeader().getHeight() :
                        getReorderingRegion().getHeight();

                dragHeader.resize(dragHeader.getWidth(), dragHeaderHeight);
                dragHeader.setTranslateY(getHeight() - dragHeaderHeight);
            }
            dragHeader.setVisible(isReordering());
        }
    };
    final void setReordering(boolean value) {
        this.reordering.set(value);
    }
    final boolean isReordering() {
        return reordering.get();
    }
    final BooleanProperty reorderingProperty() {
        return reordering;
    }

    // --- root header
    /*
     * The header row is actually just one NestedTableColumnHeader that spans
     * the entire width. Nested within this is the TableColumnHeader's and
     * NestedTableColumnHeader's, as necessary. This makes it nice and clean
     * to handle column reordering - we basically enforce the rule that column
     * reordering only occurs within a single NestedTableColumnHeader, and only
     * at that level.
     */
    private ReadOnlyObjectWrapper&lt;NestedTableColumnHeader&gt; rootHeader = new ReadOnlyObjectWrapper&lt;&gt;(this, &quot;rootHeader&quot;);
    private final ReadOnlyObjectProperty&lt;NestedTableColumnHeader&gt; rootHeaderProperty() {
        return rootHeader.getReadOnlyProperty();
    }
    final NestedTableColumnHeader getRootHeader() {
        return rootHeader.get();
    }
    private final void setRootHeader(NestedTableColumnHeader value) {
        rootHeader.set(value);
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected void layoutChildren() {
        double x = scrollX;
        double headerWidth = snapSizeX(getRootHeader().prefWidth(-1));
        double prefHeight = getHeight() - snappedTopInset() - snappedBottomInset();
        double cornerWidth = snapSizeX(flow.getVbar().prefWidth(-1));

        // position the main nested header
        getRootHeader().resizeRelocate(x, snappedTopInset(), headerWidth, prefHeight);

        // position the filler region
        final Control control = tableSkin.getSkinnable();
        if (control == null) {
            return;
        }

        final BooleanProperty tableMenuButtonVisibleProperty = TableSkinUtils.tableMenuButtonVisibleProperty(tableSkin);

        final double controlInsets = control.snappedLeftInset() + control.snappedRightInset();
        double fillerWidth = tableWidth - headerWidth + filler.getInsets().getLeft() - controlInsets;
        fillerWidth -= tableMenuButtonVisibleProperty != null &amp;&amp; tableMenuButtonVisibleProperty.get() ? cornerWidth : 0;
        filler.setVisible(fillerWidth &gt; 0);
        if (fillerWidth &gt; 0) {
            filler.resizeRelocate(x + headerWidth, snappedTopInset(), fillerWidth, prefHeight);
        }

        // position the top-right rectangle (which sits above the scrollbar)
        cornerRegion.resizeRelocate(tableWidth - cornerWidth, snappedTopInset(), cornerWidth, prefHeight);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height) {
        return getRootHeader().prefWidth(height);
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width) {
        return computePrefHeight(width);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width) {
        // we hardcode 24.0 here to avoid RT-37616, where the
        // entire header row would disappear when all columns were hidden.
        double headerPrefHeight = getRootHeader().prefHeight(width);
        headerPrefHeight = headerPrefHeight == 0.0 ? 24.0 : headerPrefHeight;
        return snappedTopInset() + headerPrefHeight + snappedBottomInset();
    }

    // used to be protected to allow subclasses to modify the horizontal scrolling,
    // but made private again for JDK 9
    void updateScrollX() {
        scrollX = flow.getHbar().isVisible() ? -flow.getHbar().getValue() : 0.0F;
        requestLayout();

        // Fix for RT-36392: without this call even though we call requestLayout()
        // we don't seem to ever see the layoutChildren() method above called,
        // which means the layout is not always updated to use the latest scrollX.
        layout();
    }

    // used to be protected to allow subclass to customise the width, to allow for features
    // such as row headers, but made private again for JDK 9
    private void updateTableWidth() {
        // snapping added for RT-19428
        final Control c = tableSkin.getSkinnable();
        if (c == null) {
            this.tableWidth = 0;
        } else {
            Insets insets = c.getInsets() == null ? Insets.EMPTY : c.getInsets();
            double padding = snapSizeX(insets.getLeft()) + snapSizeX(insets.getRight());
            this.tableWidth = snapSizeX(c.getWidth()) - padding;
        }

        clip.setWidth(tableWidth);
    }

    /**
     * Creates a new NestedTableColumnHeader instance. By default this method should not be overridden, but in some
     * circumstances it makes sense (e.g. testing, or when extreme customization is desired).
     *
     * @return A new NestedTableColumnHeader instance.
     */
    protected NestedTableColumnHeader createRootHeader() {
        return new NestedTableColumnHeader(null);
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    TableColumnHeader getReorderingRegion() {
        return reorderingRegion;
    }

    void setReorderingColumn(TableColumnBase rc) {
        dragHeaderLabel.setText(rc == null ? &quot;&quot; : rc.getText());
    }

    void setReorderingRegion(TableColumnHeader reorderingRegion) {
        this.reorderingRegion = reorderingRegion;

        if (reorderingRegion != null) {
            dragHeader.resize(reorderingRegion.getWidth(), dragHeader.getHeight());
        }
    }

    void setDragHeaderX(double dragHeaderX) {
        dragHeader.setTranslateX(dragHeaderX);
    }

    TableColumnHeader getColumnHeaderFor(final TableColumnBase&lt;?,?&gt; col) {
        if (col == null) return null;
        List&lt;TableColumnBase&lt;?,?&gt;&gt; columnChain = new ArrayList&lt;&gt;();
        columnChain.add(col);

        TableColumnBase&lt;?,?&gt; parent = col.getParentColumn();
        while (parent != null) {
            columnChain.add(0, parent);
            parent = parent.getParentColumn();
        }

        // we now have a list from top to bottom of a nested column hierarchy,
        // and we can now navigate down to retrieve the header with ease
        TableColumnHeader currentHeader = getRootHeader();
        for (int depth = 0; depth &lt; columnChain.size(); depth++) {
            // this is the column we are looking for at this depth
            TableColumnBase&lt;?,?&gt; column = columnChain.get(depth);

            // and now we iterate through the nested table column header at this
            // level to get the header
            currentHeader = getColumnHeaderFor(column, currentHeader);
        }
        return currentHeader;
    }

    private TableColumnHeader getColumnHeaderFor(final TableColumnBase&lt;?,?&gt; col, TableColumnHeader currentHeader) {
        if (currentHeader instanceof NestedTableColumnHeader) {
            List&lt;TableColumnHeader&gt; headers = ((NestedTableColumnHeader)currentHeader).getColumnHeaders();

            for (int i = 0; i &lt; headers.size(); i++) {
                TableColumnHeader header = headers.get(i);
                if (header.getTableColumn() == col) {
                    return header;
                }
            }
        }

        return null;
    }

    private void updateTableColumnListeners(List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; added, List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; removed) {
        // remove binding from all removed items
        for (TableColumnBase tc : removed) {
            remove(tc);
        }

        rebuildColumnMenu();
    }

    private void remove(TableColumnBase&lt;?,?&gt; col) {
        if (col == null) return;

        CheckMenuItem item = columnMenuItems.remove(col);
        if (item != null) {
            col.textProperty().removeListener(weakColumnTextListener);
            item.selectedProperty().unbindBidirectional(col.visibleProperty());

            columnPopupMenu.getItems().remove(item);
        }

        if (! col.getColumns().isEmpty()) {
            for (TableColumnBase tc : col.getColumns()) {
                remove(tc);
            }
        }
    }

    private void rebuildColumnMenu() {
        columnPopupMenu.getItems().clear();

        for (TableColumnBase&lt;?,?&gt; col : TableSkinUtils.getColumns(tableSkin)) {
            // we only create menu items for leaf columns, visible or not
            if (col.getColumns().isEmpty()) {
                createMenuItem(col);
            } else {
                List&lt;TableColumnBase&lt;?,?&gt;&gt; leafColumns = getLeafColumns(col);
                for (TableColumnBase&lt;?,?&gt; _col : leafColumns) {
                    createMenuItem(_col);
                }
            }
        }
    }

<A NAME="8"></A>    private List&lt;TableColumnBase&lt;?,?&gt;&gt; getLeafColumns(TableColumnBase&lt;?,?&gt; col) {
        List&lt;TableColumnBase&lt;?,?&gt;&gt; leafColumns = new ArrayList&lt;&gt;();

        for (TableColumnBase&lt;?,?&gt; _col : col.getColumns()) <FONT color="#bce954"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#8',2,'match31-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
            if (_col.getColumns().isEmpty()) {
                leafColumns.add(_col);
            } else {
                leafColumns.addAll(getLeafColumns(_col));
            }
        }</B></FONT>

        return leafColumns;
    }

    private void createMenuItem(TableColumnBase&lt;?,?&gt; col) {
        CheckMenuItem item = columnMenuItems.get(col);
        if (item == null) {
            item = new CheckMenuItem();
            columnMenuItems.put(col, item);
        }

        // bind column text and isVisible so that the menu item is always correct
        item.setText(getText(col.getText(), col));
        col.textProperty().addListener(weakColumnTextListener);

        // ideally we would have API to observe the binding status of a property,
        // but for now that doesn't exist, so we set this once and then forget
        item.setDisable(col.visibleProperty().isBound());

        // fake bidrectional binding (a real one was used here but resulted in JBS-8136468)
        item.setSelected(col.isVisible());
        final CheckMenuItem _item = item;
        item.selectedProperty().addListener(o -&gt; {
            if (col.visibleProperty().isBound()) return;
            col.setVisible(_item.isSelected());
        });
        col.visibleProperty().addListener(o -&gt; _item.setSelected(col.isVisible()));

        columnPopupMenu.getItems().add(item);
    }

    /*
     * Function used for building the strings in the popup menu
     */
    private String getText(String text, TableColumnBase col) {
        String s = text;
        TableColumnBase parentCol = col.getParentColumn();
        while (parentCol != null) {
            if (isColumnVisibleInHeader(parentCol, TableSkinUtils.getColumns(tableSkin))) {
                s = parentCol.getText() + MENU_SEPARATOR + s;
            }
            parentCol = parentCol.getParentColumn();
        }
        return s;
    }

    // We need to show strings properly. If a column has a parent column which is
    // not inserted into the TableView columns list, it effectively doesn't have
    // a parent column from the users perspective. As such, we shouldn't include
    // the parent column text in the menu. Fixes RT-14482.
    private boolean isColumnVisibleInHeader(TableColumnBase col, List columns) {
        if (col == null) return false;

        for (int i = 0; i &lt; columns.size(); i++) {
            TableColumnBase column = (TableColumnBase) columns.get(i);
            if (col.equals(column)) return true;

            if (! column.getColumns().isEmpty()) {
                boolean isVisible = isColumnVisibleInHeader(col, column.getColumns());
                if (isVisible) return true;
            }
        }

        return false;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/VirtualFlow.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.ParentHelper;
import com.sun.javafx.scene.control.Logging;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.VirtualScrollBar;
import com.sun.javafx.scene.control.skin.Utils;
import com.sun.javafx.scene.traversal.Algorithm;
import com.sun.javafx.scene.traversal.Direction;
import com.sun.javafx.scene.traversal.ParentTraversalEngine;
import com.sun.javafx.scene.traversal.TraversalContext;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.BooleanPropertyBase;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ChangeListener;
import javafx.collections.ObservableList;
import javafx.event.EventDispatcher;
import javafx.event.EventHandler;
import javafx.geometry.Orientation;
import javafx.scene.AccessibleRole;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Cell;
import javafx.scene.control.IndexedCell;
import javafx.scene.control.ScrollBar;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import javafx.util.Callback;
import javafx.util.Duration;
import com.sun.javafx.logging.PlatformLogger;

import java.util.AbstractList;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.List;

/**
 * Implementation of a virtualized container using a cell based mechanism. This
 * is used by the skin implementations for UI controls such as
 * {@link javafx.scene.control.ListView}, {@link javafx.scene.control.TreeView},
 * {@link javafx.scene.control.TableView}, and {@link javafx.scene.control.TreeTableView}.
 *
 * @since 9
 */
public class VirtualFlow&lt;T extends IndexedCell&gt; extends Region {

    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    /**
     * Scroll events may request to scroll about a number of &quot;lines&quot;. We first
     * decide how big one &quot;line&quot; is - for fixed cell size it's clear,
     * for variable cell size we settle on a single number so that the scrolling
     * speed is consistent. Now if the line is so big that
     * MIN_SCROLLING_LINES_PER_PAGE of them don't fit into one page, we make
     * them smaller to prevent the scrolling step to be too big (perhaps
     * even more than one page).
     */
    private static final int MIN_SCROLLING_LINES_PER_PAGE = 8;

    /**
     * Indicates that this is a newly created cell and we need call processCSS for it.
     *
     * See RT-23616 for more details.
     */
    private static final String NEW_CELL = &quot;newcell&quot;;

    private static final double GOLDEN_RATIO_MULTIPLIER = 0.618033987;



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private boolean touchDetected = false;
    private boolean mouseDown = false;

    /**
     * The width of the VirtualFlow the last time it was laid out. We
     * use this information for several fast paths during the layout pass.
     */
    double lastWidth = -1;

    /**
     * The height of the VirtualFlow the last time it was laid out. We
     * use this information for several fast paths during the layout pass.
     */
    double lastHeight = -1;

    /**
     * The number of &quot;virtual&quot; cells in the flow the last time it was laid out.
     * For example, there may have been 1000 virtual cells, but only 20 actual
     * cells created and in use. In that case, lastCellCount would be 1000.
     */
    int lastCellCount = 0;

    /**
     * We remember the last value for vertical the last time we laid out the
     * flow. If vertical has changed, we will want to change the max &amp; value
     * for the different scroll bars. Since we do all the scroll bar update
     * work in the layoutChildren function, we need to know what the old value for
     * vertical was.
     */
    boolean lastVertical;

    /**
     * The position last time we laid out. If none of the lastXXX vars have
     * changed respective to their values in layoutChildren, then we can just punt
     * out of the method (I hope...)
     */
    double lastPosition;

    /**
     * The breadth of the first visible cell last time we laid out.
     */
    double lastCellBreadth = -1;

    /**
     * The length of the first visible cell last time we laid out.
     */
    double lastCellLength = -1;

    /**
     * The list of cells representing those cells which actually make up the
     * current view. The cells are ordered such that the first cell in this
     * list is the first in the view, and the last cell is the last in the
     * view. When pixel scrolling, the list is simply shifted and items drop
     * off the beginning or the end, depending on the order of scrolling.
     * &lt;p&gt;
     * This is package private ONLY FOR TESTING
     */
    final ArrayLinkedList&lt;T&gt; cells = new ArrayLinkedList&lt;T&gt;();

    /**
     * A structure containing cells that can be reused later. These are cells
     * that at one time were needed to populate the view, but now are no longer
     * needed. We keep them here until they are needed again.
     * &lt;p&gt;
     * This is package private ONLY FOR TESTING
     */
    final ArrayLinkedList&lt;T&gt; pile = new ArrayLinkedList&lt;T&gt;();

    /**
     * A special cell used to accumulate bounds, such that we reduce object
     * churn. This cell must be recreated whenever the cell factory function
     * changes. This has package access ONLY for testing.
     */
    T accumCell;

    /**
     * This group is used for holding the 'accumCell'. 'accumCell' must
     * be added to the skin for it to be styled. Otherwise, it doesn't
     * report the correct width/height leading to issues when scrolling
     * the flow
     */
    Group accumCellParent;

    /**
     * The group which holds the cells.
     */
    final Group sheet;

    final ObservableList&lt;Node&gt; sheetChildren;

    /**
     * The scroll bar used for scrolling horizontally. This has package access
     * ONLY for testing.
     */
    private VirtualScrollBar hbar = new VirtualScrollBar(this);

    /**
     * The scroll bar used to scrolling vertically. This has package access
     * ONLY for testing.
     */
    private VirtualScrollBar vbar = new VirtualScrollBar(this);

    /**
     * Control in which the cell's sheet is placed and forms the viewport. The
     * viewportBreadth and viewportLength are simply the dimensions of the
     * clipView. This has package access ONLY for testing.
     */
    ClippedContainer clipView;

    /**
     * When both the horizontal and vertical scroll bars are visible,
     * we have to 'fill in' the bottom right corner where the two scroll bars
     * meet. This is handled by this corner region. This has package access
     * ONLY for testing.
     */
    StackPane corner;

    // used for panning the virtual flow
    private double lastX;
    private double lastY;
    private boolean isPanning = false;

    private boolean fixedCellSizeEnabled = false;

    private boolean needsReconfigureCells = false; // when cell contents are the same
    private boolean needsRecreateCells = false; // when cell factory changed
    private boolean needsRebuildCells = false; // when cell contents have changed
    private boolean needsCellsLayout = false;
    private boolean sizeChanged = false;
    private final BitSet dirtyCells = new BitSet();

    Timeline sbTouchTimeline;
    KeyFrame sbTouchKF1;
    KeyFrame sbTouchKF2;

    private boolean needBreadthBar;
    private boolean needLengthBar;
    private boolean tempVisibility = false;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new VirtualFlow instance.
     */
    public VirtualFlow() {
        getStyleClass().add(&quot;virtual-flow&quot;);
        setId(&quot;virtual-flow&quot;);

        // initContent
        // --- sheet
        sheet = new Group();
        sheet.getStyleClass().add(&quot;sheet&quot;);
        sheet.setAutoSizeChildren(false);

        sheetChildren = sheet.getChildren();

        // --- clipView
        clipView = new ClippedContainer(this);
        clipView.setNode(sheet);
        getChildren().add(clipView);

        // --- accumCellParent
        accumCellParent = new Group();
        accumCellParent.setVisible(false);
        getChildren().add(accumCellParent);


        /*
        ** don't allow the ScrollBar to handle the ScrollEvent,
        ** In a VirtualFlow a vertical scroll should scroll on the vertical only,
        ** whereas in a horizontal ScrollBar it can scroll horizontally.
        */
        // block the event from being passed down to children
        final EventDispatcher blockEventDispatcher = (event, tail) -&gt; event;
        // block ScrollEvent from being passed down to scrollbar's skin
        final EventDispatcher oldHsbEventDispatcher = hbar.getEventDispatcher();
        hbar.setEventDispatcher((event, tail) -&gt; {
            if (event.getEventType() == ScrollEvent.SCROLL &amp;&amp;
                    !((ScrollEvent)event).isDirect()) {
                tail = tail.prepend(blockEventDispatcher);
                tail = tail.prepend(oldHsbEventDispatcher);
                return tail.dispatchEvent(event);
            }
            return oldHsbEventDispatcher.dispatchEvent(event, tail);
        });
        // block ScrollEvent from being passed down to scrollbar's skin
        final EventDispatcher oldVsbEventDispatcher = vbar.getEventDispatcher();
        vbar.setEventDispatcher((event, tail) -&gt; {
            if (event.getEventType() == ScrollEvent.SCROLL &amp;&amp;
                    !((ScrollEvent)event).isDirect()) {
                tail = tail.prepend(blockEventDispatcher);
                tail = tail.prepend(oldVsbEventDispatcher);
                return tail.dispatchEvent(event);
            }
            return oldVsbEventDispatcher.dispatchEvent(event, tail);
        });
        /*
        ** listen for ScrollEvents over the whole of the VirtualFlow
        ** area, the above dispatcher having removed the ScrollBars
        ** scroll event handling.
        */
        setOnScroll(new EventHandler&lt;ScrollEvent&gt;() {
            @Override public void handle(ScrollEvent event) {
                if (Properties.IS_TOUCH_SUPPORTED) {
                    if (touchDetected == false &amp;&amp;  mouseDown == false ) {
                        startSBReleasedAnimation();
                    }
                }
                /*
                ** calculate the delta in the direction of the flow.
                */
                double virtualDelta = 0.0;
                if (isVertical()) {
                    switch(event.getTextDeltaYUnits()) {
                        case PAGES:
                            virtualDelta = event.getTextDeltaY() * lastHeight;
                            break;
                        case LINES:
                            double lineSize;
                            if (fixedCellSizeEnabled) {
                                lineSize = getFixedCellSize();
                            } else {
                                // For the scrolling to be reasonably consistent
                                // we set the lineSize to the average size
                                // of all currently loaded lines.
                                T lastCell = cells.getLast();
                                lineSize =
                                        (getCellPosition(lastCell)
                                            + getCellLength(lastCell)
                                            - getCellPosition(cells.getFirst()))
                                        / cells.size();
                            }

                            if (lastHeight / lineSize &lt; MIN_SCROLLING_LINES_PER_PAGE) {
                                lineSize = lastHeight / MIN_SCROLLING_LINES_PER_PAGE;
                            }

                            virtualDelta = event.getTextDeltaY() * lineSize;
                            break;
                        case NONE:
                            virtualDelta = event.getDeltaY();
                    }
                } else { // horizontal
                    switch(event.getTextDeltaXUnits()) {
                        case CHARACTERS:
                            // can we get character size here?
                            // for now, fall through to pixel values
                        case NONE:
                            double dx = event.getDeltaX();
                            double dy = event.getDeltaY();

                            virtualDelta = (Math.abs(dx) &gt; Math.abs(dy) ? dx : dy);
                    }
                }

                if (virtualDelta != 0.0) {
                    /*
                    ** only consume it if we use it
                    */
                    double result = scrollPixels(-virtualDelta);
                    if (result != 0.0) {
                        event.consume();
                    }
                }

                ScrollBar nonVirtualBar = isVertical() ? hbar : vbar;
                if (needBreadthBar) {
                    double nonVirtualDelta = isVertical() ? event.getDeltaX() : event.getDeltaY();
                    if (nonVirtualDelta != 0.0) {
                        double newValue = nonVirtualBar.getValue() - nonVirtualDelta;
                        if (newValue &lt; nonVirtualBar.getMin()) {
                            nonVirtualBar.setValue(nonVirtualBar.getMin());
                        } else if (newValue &gt; nonVirtualBar.getMax()) {
                            nonVirtualBar.setValue(nonVirtualBar.getMax());
                        } else {
                            nonVirtualBar.setValue(newValue);
                        }
                        event.consume();
                    }
                }
            }
        });


        addEventFilter(MouseEvent.MOUSE_PRESSED, new EventHandler&lt;MouseEvent&gt;() {
            @Override
            public void handle(MouseEvent e) {
                mouseDown = true;
                if (Properties.IS_TOUCH_SUPPORTED) {
                    scrollBarOn();
                }
                if (isFocusTraversable()) {
                    // We check here to see if the current focus owner is within
                    // this VirtualFlow, and if so we back-off from requesting
                    // focus back to the VirtualFlow itself. This is particularly
                    // relevant given the bug identified in RT-32869. In this
                    // particular case TextInputControl was clearing selection
                    // when the focus on the TextField changed, meaning that the
                    // right-click context menu was not showing the correct
                    // options as there was no selection in the TextField.
                    boolean doFocusRequest = true;
                    Node focusOwner = getScene().getFocusOwner();
                    if (focusOwner != null) {
                        Parent parent = focusOwner.getParent();
                        while (parent != null) {
                            if (parent.equals(VirtualFlow.this)) {
                                doFocusRequest = false;
                                break;
                            }
                            parent = parent.getParent();
                        }
                    }

                    if (doFocusRequest) {
                        requestFocus();
                    }
                }

                lastX = e.getX();
                lastY = e.getY();

                // determine whether the user has push down on the virtual flow,
                // or whether it is the scrollbar. This is done to prevent
                // mouse events being 'doubled up' when dragging the scrollbar
                // thumb - it has the side-effect of also starting the panning
                // code, leading to flicker
                isPanning = ! (vbar.getBoundsInParent().contains(e.getX(), e.getY())
                        || hbar.getBoundsInParent().contains(e.getX(), e.getY()));
            }
        });
        addEventFilter(MouseEvent.MOUSE_RELEASED, e -&gt; {
            mouseDown = false;
            if (Properties.IS_TOUCH_SUPPORTED) {
                startSBReleasedAnimation();
            }
        });
        addEventFilter(MouseEvent.MOUSE_DRAGGED, e -&gt; {
            if (Properties.IS_TOUCH_SUPPORTED) {
                scrollBarOn();
            }
            if (! isPanning || ! isPannable()) return;

            // With panning enabled, we support panning in both vertical
            // and horizontal directions, regardless of the fact that
            // VirtualFlow is virtual in only one direction.
            double xDelta = lastX - e.getX();
            double yDelta = lastY - e.getY();

            // figure out the distance that the mouse moved in the virtual
            // direction, and then perform the movement along that axis
            // virtualDelta will contain the amount we actually did move
            double virtualDelta = isVertical() ? yDelta : xDelta;
            double actual = scrollPixels(virtualDelta);
            if (actual != 0) {
                // update last* here, as we know we've just adjusted the
                // scrollbar. This means we don't get the situation where a
                // user presses-and-drags a long way past the min or max
                // values, only to change directions and see the scrollbar
                // start moving immediately.
                if (isVertical()) lastY = e.getY();
                else lastX = e.getX();
            }

            // similarly, we do the same in the non-virtual direction
            double nonVirtualDelta = isVertical() ? xDelta : yDelta;
            ScrollBar nonVirtualBar = isVertical() ? hbar : vbar;
            if (nonVirtualBar.isVisible()) {
                double newValue = nonVirtualBar.getValue() + nonVirtualDelta;
                if (newValue &lt; nonVirtualBar.getMin()) {
                    nonVirtualBar.setValue(nonVirtualBar.getMin());
                } else if (newValue &gt; nonVirtualBar.getMax()) {
                    nonVirtualBar.setValue(nonVirtualBar.getMax());
                } else {
                    nonVirtualBar.setValue(newValue);

                    // same as the last* comment above
                    if (isVertical()) lastX = e.getX();
                    else lastY = e.getY();
                }
            }
        });

        /*
         * We place the scrollbars _above_ the rectangle, such that the drag
         * operations often used in conjunction with scrollbars aren't
         * misinterpreted as drag operations on the rectangle as well (which
         * would be the case if the scrollbars were underneath it as the
         * rectangle itself doesn't block the mouse.
         */
        // --- vbar
        vbar.setOrientation(Orientation.VERTICAL);
        vbar.addEventHandler(MouseEvent.ANY, event -&gt; {
            event.consume();
        });
        getChildren().add(vbar);

        // --- hbar
        hbar.setOrientation(Orientation.HORIZONTAL);
        hbar.addEventHandler(MouseEvent.ANY, event -&gt; {
            event.consume();
        });
        getChildren().add(hbar);

        // --- corner
        corner = new StackPane();
        corner.getStyleClass().setAll(&quot;corner&quot;);
        getChildren().add(corner);



        // initBinds
        // clipView binds
        InvalidationListener listenerX = valueModel -&gt; {
            updateHbar();
        };
        verticalProperty().addListener(listenerX);
        hbar.valueProperty().addListener(listenerX);
        hbar.visibleProperty().addListener(listenerX);

//        ChangeListener listenerY = new ChangeListener() {
//            @Override public void handle(Bean bean, PropertyReference property) {
//                clipView.setClipY(isVertical() ? 0 : vbar.getValue());
//            }
//        };
//        addChangedListener(VERTICAL, listenerY);
//        vbar.addChangedListener(ScrollBar.VALUE, listenerY);

        ChangeListener&lt;Number&gt; listenerY = (ov, t, t1) -&gt; {
            clipView.setClipY(isVertical() ? 0 : vbar.getValue());
        };
        vbar.valueProperty().addListener(listenerY);

        super.heightProperty().addListener((observable, oldHeight, newHeight) -&gt; {
            // Fix for RT-8480, where the VirtualFlow does not show its content
            // after changing size to 0 and back.
            if (oldHeight.doubleValue() == 0 &amp;&amp; newHeight.doubleValue() &gt; 0) {
                recreateCells();
            }
        });


        /*
        ** there are certain animations that need to know if the touch is
        ** happening.....
        */
        setOnTouchPressed(e -&gt; {
            touchDetected = true;
            scrollBarOn();
        });

        setOnTouchReleased(e -&gt; {
            touchDetected = false;
            startSBReleasedAnimation();
        });

        ParentHelper.setTraversalEngine(this, new ParentTraversalEngine(this, new Algorithm() {

            Node selectNextAfterIndex(int index, TraversalContext context) {
                T nextCell;
                while ((nextCell = getVisibleCell(++index)) != null) {
                    if (nextCell.isFocusTraversable()) {
                        return nextCell;
                    }
                    Node n = context.selectFirstInParent(nextCell);
                    if (n != null) {
                        return n;
                    }
                }
                return null;
            }

            Node selectPreviousBeforeIndex(int index, TraversalContext context) {
                T prevCell;
                while ((prevCell = getVisibleCell(--index)) != null) {
                    Node prev = context.selectLastInParent(prevCell);
                    if (prev != null) {
                        return prev;
                    }
                    if (prevCell.isFocusTraversable()) {
                        return prevCell;
                    }
                }
                return null;
            }

            @Override
            public Node select(Node owner, Direction dir, TraversalContext context) {
                T cell;
                if (cells.isEmpty()) return null;
                if (cells.contains(owner)) {
                    cell = (T) owner;
                } else {
                    cell = findOwnerCell(owner);
                    Node next = context.selectInSubtree(cell, owner, dir);
                    if (next != null) {
                        return next;
                    }
                    if (dir == Direction.NEXT) dir = Direction.NEXT_IN_LINE;
                }
                int cellIndex = cell.getIndex();
                switch(dir) {
                    case PREVIOUS:
                        return selectPreviousBeforeIndex(cellIndex, context);
                    case NEXT:
                        Node n = context.selectFirstInParent(cell);
                        if (n != null) {
                            return n;
                        }
                        // Intentional fall-through
                    case NEXT_IN_LINE:
                        return selectNextAfterIndex(cellIndex, context);
                }
                return null;
            }

            private T findOwnerCell(Node owner) {
                Parent p = owner.getParent();
                while (!cells.contains(p)) {
                    p = p.getParent();
                }
                return (T)p;
            }

            @Override
            public Node selectFirst(TraversalContext context) {
                T firstCell = cells.getFirst();
                if (firstCell == null) return null;
                if (firstCell.isFocusTraversable()) return firstCell;
                Node n = context.selectFirstInParent(firstCell);
                if (n != null) {
                    return n;
                }
                return selectNextAfterIndex(firstCell.getIndex(), context);
            }

            @Override
            public Node selectLast(TraversalContext context) {
                T lastCell = cells.getLast();
                if (lastCell == null) return null;
                Node p = context.selectLastInParent(lastCell);
                if (p != null) {
                    return p;
                }
                if (lastCell.isFocusTraversable()) return lastCell;
                return selectPreviousBeforeIndex(lastCell.getIndex(), context);
            }
        }));
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * There are two main complicating factors in the implementation of the
     * VirtualFlow, which are made even more complicated due to the performance
     * sensitive nature of this code. The first factor is the actual
     * virtualization mechanism, wired together with the PositionMapper.
     * The second complicating factor is the desire to do minimal layout
     * and minimal updates to CSS.
     *
     * Since the layout mechanism runs at most once per pulse, we want to hook
     * into this mechanism for minimal recomputation. Whenever a layout pass
     * is run we record the width/height that the virtual flow was last laid
     * out to. In subsequent passes, if the width/height has not changed then
     * we know we only have to rebuild the cells. If the width or height has
     * changed, then we can make appropriate decisions based on whether the
     * width / height has been reduced or expanded.
     *
     * In various places, if requestLayout is called it is generally just
     * used to indicate that some form of layout needs to happen (either the
     * entire thing has to be reconstructed, or just the cells need to be
     * reconstructed, generally).
     *
     * The accumCell is a special cell which is used in some computations
     * when an actual cell for that item isn't currently available. However,
     * the accumCell must be cleared whenever the cellFactory function is
     * changed because we need to use the cells that come from the new factory.
     *
     * In addition to storing the lastWidth and lastHeight, we also store the
     * number of cells that existed last time we performed a layout. In this
     * way if the number of cells change, we can request a layout and when it
     * occurs we can tell that the number of cells has changed and react
     * accordingly.
     *
     * Because the VirtualFlow can be laid out horizontally or vertically a
     * naming problem is present when trying to conceptualize and implement
     * the flow. In particular, the words &quot;width&quot; and &quot;height&quot; are not
     * precise when describing the unit of measure along the &quot;virtualized&quot;
     * axis and the &quot;orthogonal&quot; axis. For example, the height of a cell when
     * the flow is vertical is the magnitude along the &quot;virtualized axis&quot;,
     * and the width is along the axis orthogonal to it.
     *
     * Since &quot;height&quot; and &quot;width&quot; are not reliable terms, we use the words
     * &quot;length&quot; and &quot;breadth&quot; to describe the magnitude of a cell along
     * the virtualized axis and orthogonal axis. For example, in a vertical
     * flow, the height=length and the width=breadth. In a horizontal axis,
     * the height=breadth and the width=length.
     *
     * These terms are somewhat arbitrary, but chosen so that when reading
     * most of the below code you can think in just one dimension, with
     * helper functions converting width/height in to length/breadth, while
     * also being different from width/height so as not to get confused with
     * the actual width/height of a cell.
     */

    // --- vertical
    /**
     * Indicates the primary direction of virtualization. If true, then the
     * primary direction of virtualization is vertical, meaning that cells will
     * stack vertically on top of each other. If false, then they will stack
     * horizontally next to each other.
     */
    private BooleanProperty vertical;
    public final void setVertical(boolean value) {
        verticalProperty().set(value);
    }

    public final boolean isVertical() {
        return vertical == null ? true : vertical.get();
    }

    public final BooleanProperty verticalProperty() {
        if (vertical == null) {
            vertical = new BooleanPropertyBase(true) {
                @Override protected void invalidated() {
                    pile.clear();
                    sheetChildren.clear();
                    cells.clear();
                    lastWidth = lastHeight = -1;
                    setMaxPrefBreadth(-1);
                    setViewportBreadth(0);
                    setViewportLength(0);
                    lastPosition = 0;
                    hbar.setValue(0);
                    vbar.setValue(0);
                    setPosition(0.0f);
                    setNeedsLayout(true);
                    requestLayout();
                }

                @Override
                public Object getBean() {
                    return VirtualFlow.this;
                }

                @Override
                public String getName() {
                    return &quot;vertical&quot;;
                }
            };
        }
        return vertical;
    }

    // --- pannable
    /**
     * Indicates whether the VirtualFlow viewport is capable of being panned
     * by the user (either via the mouse or touch events).
     */
    private BooleanProperty pannable = new SimpleBooleanProperty(this, &quot;pannable&quot;, true);
    public final boolean isPannable() { return pannable.get(); }
    public final void setPannable(boolean value) { pannable.set(value); }
    public final BooleanProperty pannableProperty() { return pannable; }

    // --- cell count
    /**
     * Indicates the number of cells that should be in the flow. The user of
     * the VirtualFlow must set this appropriately. When the cell count changes
     * the VirtualFlow responds by updating the visuals. If the items backing
     * the cells change, but the count has not changed, you must call the
     * reconfigureCells() function to update the visuals.
     */
    private IntegerProperty cellCount = new SimpleIntegerProperty(this, &quot;cellCount&quot;, 0) {
        private int oldCount = 0;

        @Override protected void invalidated() {
            int cellCount = get();

            boolean countChanged = oldCount != cellCount;
            oldCount = cellCount;

            // ensure that the virtual scrollbar adjusts in size based on the current
            // cell count.
            if (countChanged) {
                VirtualScrollBar lengthBar = isVertical() ? vbar : hbar;
                lengthBar.setMax(cellCount);
            }

            // I decided *not* to reset maxPrefBreadth here for the following
            // situation. Suppose I have 30 cells and then I add 10 more. Just
            // because I added 10 more doesn't mean the max pref should be
            // reset. Suppose the first 3 cells were extra long, and I was
            // scrolled down such that they weren't visible. If I were to reset
            // maxPrefBreadth when subsequent cells were added or removed, then the
            // scroll bars would erroneously reset as well. So I do not reset
            // the maxPrefBreadth here.

            // Fix for RT-12512, RT-14301 and RT-14864.
            // Without this, the VirtualFlow length-wise scrollbar would not change
            // as expected. This would leave items unable to be shown, as they
            // would exist outside of the visible area, even when the scrollbar
            // was at its maximum position.
            // FIXME this should be only executed on the pulse, so this will likely
            // lead to performance degradation until it is handled properly.
            if (countChanged) {
                layoutChildren();

                // Fix for RT-13965: Without this line of code, the number of items in
                // the sheet would constantly grow, leaking memory for the life of the
                // application. This was especially apparent when the total number of
                // cells changes - regardless of whether it became bigger or smaller.
                sheetChildren.clear();

                Parent parent = getParent();
                if (parent != null) parent.requestLayout();
            }
            // TODO suppose I had 100 cells and I added 100 more. Further
            // suppose I was scrolled to the bottom when that happened. I
            // actually want to update the position of the mapper such that
            // the view remains &quot;stable&quot;.
        }
    };
    public final int getCellCount() { return cellCount.get(); }
    public final void setCellCount(int value) { cellCount.set(value);  }
    public final IntegerProperty cellCountProperty() { return cellCount; }


    // --- position
    /**
     * The position of the VirtualFlow within its list of cells. This is a value
     * between 0 and 1.
     */
    private DoubleProperty position = new SimpleDoubleProperty(this, &quot;position&quot;) {
        @Override public void setValue(Number v) {
            super.setValue(com.sun.javafx.util.Utils.clamp(0, get(), 1));
        }

        @Override protected void invalidated() {
            super.invalidated();
            requestLayout();
        }
    };
    public final double getPosition() { return position.get(); }
    public final void setPosition(double value) { position.set(value); }
    public final DoubleProperty positionProperty() { return position; }

    // --- fixed cell size
    /**
     * For optimisation purposes, some use cases can trade dynamic cell length
     * for speed - if fixedCellSize is greater than zero we'll use that rather
     * than determine it by querying the cell itself.
     */
    private DoubleProperty fixedCellSize = new SimpleDoubleProperty(this, &quot;fixedCellSize&quot;) {
        @Override protected void invalidated() {
            fixedCellSizeEnabled = get() &gt; 0;
            needsCellsLayout = true;
            layoutChildren();
        }
    };
    public final void setFixedCellSize(final double value) { fixedCellSize.set(value); }
    public final double getFixedCellSize() { return fixedCellSize.get(); }
    public final DoubleProperty fixedCellSizeProperty() { return fixedCellSize; }


    // --- Cell Factory
    private ObjectProperty&lt;Callback&lt;VirtualFlow&lt;T&gt;, T&gt;&gt; cellFactory;

    /**
     * Sets a new cell factory to use in the VirtualFlow. This forces all old
     * cells to be thrown away, and new cells to be created with
     * the new cell factory.
     * @param value the new cell factory
     */
    public final void setCellFactory(Callback&lt;VirtualFlow&lt;T&gt;, T&gt; value) {
        cellFactoryProperty().set(value);
    }

    /**
     * Returns the current cell factory.
     * @return the current cell factory
     */
    public final Callback&lt;VirtualFlow&lt;T&gt;, T&gt; getCellFactory() {
        return cellFactory == null ? null : cellFactory.get();
    }

    /**
     * &lt;p&gt;Setting a custom cell factory has the effect of deferring all cell
     * creation, allowing for total customization of the cell. Internally, the
     * VirtualFlow is responsible for reusing cells - all that is necessary
     * is for the custom cell factory to return from this function a cell
     * which might be usable for representing any item in the VirtualFlow.
     *
     * &lt;p&gt;Refer to the {@link Cell} class documentation for more detail.
     * @return  the cell factory property
     */
    public final ObjectProperty&lt;Callback&lt;VirtualFlow&lt;T&gt;, T&gt;&gt; cellFactoryProperty() {
        if (cellFactory == null) {
            cellFactory = new SimpleObjectProperty&lt;Callback&lt;VirtualFlow&lt;T&gt;, T&gt;&gt;(this, &quot;cellFactory&quot;) {
                @Override protected void invalidated() {
                    if (get() != null) {
                        accumCell = null;
                        setNeedsLayout(true);
                        recreateCells();
                        if (getParent() != null) getParent().requestLayout();
                    }
                }
            };
        }
        return cellFactory;
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Overridden to implement somewhat more efficient support for layout. The
     * VirtualFlow can generally be considered as being unmanaged, in that
     * whenever the position changes, or other such things change, we need
     * to perform a layout but there is no reason to notify the parent. However
     * when things change which may impact the preferred size (such as
     * vertical, createCell, and configCell) then we need to notify the
     * parent.
     */
    @Override public void requestLayout() {
// Note: This block is commented as it was relaying on a bad assumption on how
//       layout request was handled in parent class that is now fixed.
//
//        // isNeedsLayout() is commented out due to RT-21417. This does not
//        // appear to impact performance (indeed, it may help), and resolves the
//        // issue identified in RT-21417.
//        setNeedsLayout(true);

        // The fix is to prograte this layout request to its parent class.
        // A better fix will be required if performance is negatively affected
        // by this fix.
        super.requestLayout();
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren() {
        if (needsRecreateCells) {
            lastWidth = -1;
            lastHeight = -1;
            releaseCell(accumCell);
//            accumCell = null;
//            accumCellParent.getChildren().clear();
            sheet.getChildren().clear();
            for (int i = 0, max = cells.size(); i &lt; max; i++) {
                cells.get(i).updateIndex(-1);
            }
            cells.clear();
            pile.clear();
            releaseAllPrivateCells();
        } else if (needsRebuildCells) {
            lastWidth = -1;
            lastHeight = -1;
            releaseCell(accumCell);
            for (int i = 0, max = cells.size(); i &lt; max; i++) {
                cells.get(i).updateIndex(-1);
            }
            addAllToPile();
            releaseAllPrivateCells();
        } else if (needsReconfigureCells) {
            setMaxPrefBreadth(-1);
            lastWidth = -1;
            lastHeight = -1;
        }

        if (! dirtyCells.isEmpty()) {
            int index;
            final int cellsSize = cells.size();
            while ((index = dirtyCells.nextSetBit(0)) != -1 &amp;&amp; index &lt; cellsSize) {
                T cell = cells.get(index);
                // updateIndex(-1) works for TableView, but breaks ListView.
                // For now, the TableView just does not use the dirtyCells API
//                cell.updateIndex(-1);
                if (cell != null) {
                    cell.requestLayout();
                }
                dirtyCells.clear(index);
            }

            setMaxPrefBreadth(-1);
            lastWidth = -1;
            lastHeight = -1;
        }

        final boolean hasSizeChange = sizeChanged;
        boolean recreatedOrRebuilt = needsRebuildCells || needsRecreateCells || sizeChanged;

        needsRecreateCells = false;
        needsReconfigureCells = false;
        needsRebuildCells = false;
        sizeChanged = false;

        if (needsCellsLayout) {
            for (int i = 0, max = cells.size(); i &lt; max; i++) {
                Cell&lt;?&gt; cell = cells.get(i);
                if (cell != null) {
                    cell.requestLayout();
                }
            }
            needsCellsLayout = false;

            // yes, we return here - if needsCellsLayout was set to true, we
            // only did it to do the above - not rerun the entire layout.
            return;
        }

        final double width = getWidth();
        final double height = getHeight();
        final boolean isVertical = isVertical();
        final double position = getPosition();

        // if the width and/or height is 0, then there is no point doing
        // any of this work. In particular, this can happen during startup
        if (width &lt;= 0 || height &lt;= 0) {
            addAllToPile();
            lastWidth = width;
            lastHeight = height;
            hbar.setVisible(false);
            vbar.setVisible(false);
            corner.setVisible(false);
            return;
        }

        // we check if any of the cells in the cells list need layout. This is a
        // sign that they are perhaps animating their sizes. Without this check,
        // we may not perform a layout here, meaning that the cell will likely
        // 'jump' (in height normally) when the user drags the virtual thumb as
        // that is the first time the layout would occur otherwise.
        boolean cellNeedsLayout = false;
        boolean thumbNeedsLayout = false;

        if (Properties.IS_TOUCH_SUPPORTED) {
            if ((tempVisibility == true &amp;&amp; (hbar.isVisible() == false || vbar.isVisible() == false)) ||
                (tempVisibility == false &amp;&amp; (hbar.isVisible() == true || vbar.isVisible() == true))) {
                thumbNeedsLayout = true;
            }
        }

        if (!cellNeedsLayout) {
            for (int i = 0; i &lt; cells.size(); i++) {
                Cell&lt;?&gt; cell = cells.get(i);
                cellNeedsLayout = cell.isNeedsLayout();
                if (cellNeedsLayout) break;
            }
        }

        final int cellCount = getCellCount();
        final T firstCell = getFirstVisibleCell();

        // If no cells need layout, we check other criteria to see if this
        // layout call is even necessary. If it is found that no layout is
        // needed, we just punt.
        if (! cellNeedsLayout &amp;&amp; !thumbNeedsLayout) {
            boolean cellSizeChanged = false;
            if (firstCell != null) {
                double breadth = getCellBreadth(firstCell);
                double length = getCellLength(firstCell);
                cellSizeChanged = (breadth != lastCellBreadth) || (length != lastCellLength);
                lastCellBreadth = breadth;
                lastCellLength = length;
            }

            if (width == lastWidth &amp;&amp;
                height == lastHeight &amp;&amp;
                cellCount == lastCellCount &amp;&amp;
                isVertical == lastVertical &amp;&amp;
                position == lastPosition &amp;&amp;
                ! cellSizeChanged)
            {
                // TODO this happens to work around the problem tested by
                // testCellLayout_LayoutWithoutChangingThingsUsesCellsInSameOrderAsBefore
                // but isn't a proper solution. Really what we need to do is, when
                // laying out cells, we need to make sure that if a cell is pressed
                // AND we are doing a full rebuild then we need to make sure we
                // use that cell in the same physical location as before so that
                // it gets the mouse release event.
                return;
            }
        }

        /*
         * This function may get called under a variety of circumstances.
         * It will determine what has changed from the last time it was laid
         * out, and will then take one of several execution paths based on
         * what has changed so as to perform minimal layout work and also to
         * give the expected behavior. One or more of the following may have
         * happened:
         *
         *  1) width/height has changed
         *      - If the width and/or height has been reduced (but neither of
         *        them has been expanded), then we simply have to reposition and
         *        resize the scroll bars
         *      - If the width (in the vertical case) has expanded, then we
         *        need to resize the existing cells and reposition and resize
         *        the scroll bars
         *      - If the height (in the vertical case) has expanded, then we
         *        need to resize and reposition the scroll bars and add
         *        any trailing cells
         *
         *  2) cell count has changed
         *      - If the number of cells is bigger, or it is smaller but not
         *        so small as to move the position then we can just update the
         *        cells in place without performing layout and update the
         *        scroll bars.
         *      - If the number of cells has been reduced and it affects the
         *        position, then move the position and rebuild all the cells
         *        and update the scroll bars
         *
         *  3) size of the cell has changed
         *      - If the size changed in the virtual direction (ie: height
         *        in the case of vertical) then layout the cells, adding
         *        trailing cells as necessary and updating the scroll bars
         *      - If the size changed in the non virtual direction (ie: width
         *        in the case of vertical) then simply adjust the widths of
         *        the cells as appropriate and adjust the scroll bars
         *
         *  4) vertical changed, cells is empty, maxPrefBreadth == -1, etc
         *      - Full rebuild.
         *
         * Each of the conditions really resolves to several of a handful of
         * possible outcomes:
         *  a) reposition &amp; rebuild scroll bars
         *  b) resize cells in non-virtual direction
         *  c) add trailing cells
         *  d) update cells
         *  e) resize cells in the virtual direction
         *  f) all of the above
         *
         * So this function first determines what outcomes need to occur, and
         * then will execute all the ones that really need to happen. Every code
         * path ends up touching the &quot;reposition &amp; rebuild scroll bars&quot; outcome,
         * so that one will be executed every time.
         */
        boolean needTrailingCells = false;
        boolean rebuild = cellNeedsLayout  ||
                isVertical != lastVertical ||
                cells.isEmpty()            ||
                getMaxPrefBreadth() == -1  ||
                position != lastPosition   ||
                cellCount != lastCellCount ||
                hasSizeChange ||
                (isVertical &amp;&amp; height &lt; lastHeight) || (! isVertical &amp;&amp; width &lt; lastWidth);

        if (!rebuild) {
            // Check if maxPrefBreadth didn't change
            double maxPrefBreadth = getMaxPrefBreadth();
            boolean foundMax = false;
            for (int i = 0; i &lt; cells.size(); ++i) {
                double breadth = getCellBreadth(cells.get(i));
                if (maxPrefBreadth == breadth) {
                    foundMax = true;
                } else if (breadth &gt; maxPrefBreadth) {
                    rebuild = true;
                    break;
                }
            }
            if (!foundMax) { // All values were lower
                rebuild = true;
            }
        }

        if (! rebuild) {
            if ((isVertical &amp;&amp; height &gt; lastHeight) || (! isVertical &amp;&amp; width &gt; lastWidth)) {
                // resized in the virtual direction
                needTrailingCells = true;
            }
        }

        initViewport();

        // Get the index of the &quot;current&quot; cell
        int currentIndex = computeCurrentIndex();
        if (lastCellCount != cellCount) {
            // The cell count has changed. We want to keep the viewport
            // stable if possible. If position was 0 or 1, we want to keep
            // the position in the same place. If the new cell count is &gt;=
            // the currentIndex, then we will adjust the position to be 1.
            // Otherwise, our goal is to leave the index of the cell at the
            // top consistent, with the same translation etc.
            if (position == 0 || position == 1) {
                // Update the item count
//                setItemCount(cellCount);
            } else if (currentIndex &gt;= cellCount) {
                setPosition(1.0f);
//                setItemCount(cellCount);
            } else if (firstCell != null) {
                double firstCellOffset = getCellPosition(firstCell);
                int firstCellIndex = getCellIndex(firstCell);
//                setItemCount(cellCount);
                adjustPositionToIndex(firstCellIndex);
                double viewportTopToCellTop = -computeOffsetForCell(firstCellIndex);
                adjustByPixelAmount(viewportTopToCellTop - firstCellOffset);
            }

            // Update the current index
            currentIndex = computeCurrentIndex();
        }

        if (rebuild) {
            setMaxPrefBreadth(-1);
            // Start by dumping all the cells into the pile
            addAllToPile();

            // The distance from the top of the viewport to the top of the
            // cell for the current index.
            double offset = -computeViewportOffset(getPosition());

            // Add all the leading and trailing cells (the call to add leading
            // cells will add the current cell as well -- that is, the one that
            // represents the current position on the mapper).
            addLeadingCells(currentIndex, offset);

            // Force filling of space with empty cells if necessary
            addTrailingCells(true);
        } else if (needTrailingCells) {
            addTrailingCells(true);
        }

        computeBarVisiblity();

        recreatedOrRebuilt = recreatedOrRebuilt || rebuild;
        updateScrollBarsAndCells(recreatedOrRebuilt);

        lastWidth = getWidth();
        lastHeight = getHeight();
        lastCellCount = getCellCount();
        lastVertical = isVertical();
        lastPosition = getPosition();

        cleanPile();
    }

    /** {@inheritDoc} */
    @Override protected void setWidth(double value) {
        if (value != lastWidth) {
            super.setWidth(value);
            sizeChanged = true;
            setNeedsLayout(true);
            requestLayout();
        }
    }

    /** {@inheritDoc} */
    @Override protected void setHeight(double value) {
        if (value != lastHeight) {
            super.setHeight(value);
            sizeChanged = true;
            setNeedsLayout(true);
            requestLayout();
        }
    }

    /**
     * Get a cell which can be used in the layout. This function will reuse
     * cells from the pile where possible, and will create new cells when
     * necessary.
     * @param prefIndex the preferred index
     * @return the available cell
     */
    protected T getAvailableCell(int prefIndex) {
        T cell = null;

        // Fix for RT-12822. We try to retrieve the cell from the pile rather
        // than just grab a random cell from the pile (or create another cell).
        for (int i = 0, max = pile.size(); i &lt; max; i++) {
            T _cell = pile.get(i);
            assert _cell != null;

            if (getCellIndex(_cell) == prefIndex) {
                cell = _cell;
                pile.remove(i);
                break;
            }
        }

        if (cell == null &amp;&amp; !pile.isEmpty()) {
            cell = pile.removeLast();
        }

        if (cell == null) {
            cell = getCellFactory().call(this);
            cell.getProperties().put(NEW_CELL, null);
        }

        if (cell.getParent() == null) {
            sheetChildren.add(cell);
        }

        return cell;
    }

    /**
     * This method will remove all cells from the VirtualFlow and remove them,
     * adding them to the 'pile' (that is, a place from where cells can be used
     * at a later date). This method is protected to allow subclasses to clean up
     * appropriately.
     */
    protected void addAllToPile() {
        for (int i = 0, max = cells.size(); i &lt; max; i++) {
            addToPile(cells.removeFirst());
        }
    }

    /**
     * Gets a cell for the given index if the cell has been created and laid out.
     * &quot;Visible&quot; is a bit of a misnomer, the cell might not be visible in the
     * viewport (it may be clipped), but does distinguish between cells that
     * have been created and are in use vs. those that are in the pile or
     * not created.
     * @param index the index
     * @return the visible cell
     */
    public T getVisibleCell(int index) {
        if (cells.isEmpty()) return null;

        // check the last index
        T lastCell = cells.getLast();
        int lastIndex = getCellIndex(lastCell);
        if (index == lastIndex) return lastCell;

        // check the first index
        T firstCell = cells.getFirst();
        int firstIndex = getCellIndex(firstCell);
        if (index == firstIndex) return firstCell;

        // if index is &gt; firstIndex and &lt; lastIndex then we can get the index
        if (index &gt; firstIndex &amp;&amp; index &lt; lastIndex) {
            T cell = cells.get(index - firstIndex);
            if (getCellIndex(cell) == index) return cell;
        }

        // there is no visible cell for the specified index
        return null;
    }

    /**
     * Locates and returns the last non-empty IndexedCell that is currently
     * partially or completely visible. This function may return null if there
     * are no cells, or if the viewport length is 0.
     * @return the last visible cell
     */
    public T getLastVisibleCell() {
        if (cells.isEmpty() || getViewportLength() &lt;= 0) return null;

        T cell;
        for (int i = cells.size() - 1; i &gt;= 0; i--) {
            cell = cells.get(i);
            if (! cell.isEmpty()) {
                return cell;
            }
        }

        return null;
    }

    /**
     * Locates and returns the first non-empty IndexedCell that is partially or
     * completely visible. This really only ever returns null if there are no
     * cells or the viewport length is 0.
     * @return the first visible cell
     */
    public T getFirstVisibleCell() {
        if (cells.isEmpty() || getViewportLength() &lt;= 0) return null;
        T cell = cells.getFirst();
        return cell.isEmpty() ? null : cell;
    }

    /**
     * Adjust the position of cells so that the specified cell
     * will be positioned at the start of the viewport. The given cell must
     * already be &quot;live&quot;.
     * @param firstCell the first cell
     */
    public void scrollToTop(T firstCell) {
        if (firstCell != null) {
            scrollPixels(getCellPosition(firstCell));
        }
    }

    /**
     * Adjust the position of cells so that the specified cell
     * will be positioned at the end of the viewport. The given cell must
     * already be &quot;live&quot;.
     * @param lastCell the last cell
     */
    public void scrollToBottom(T lastCell) {
        if (lastCell != null) {
            scrollPixels(getCellPosition(lastCell) + getCellLength(lastCell) - getViewportLength());
        }
    }

    /**
     * Adjusts the cells such that the selected cell will be fully visible in
     * the viewport (but only just).
     * @param cell the cell
     */
    public void scrollTo(T cell) {
        if (cell != null) {
            final double start = getCellPosition(cell);
            final double length = getCellLength(cell);
            final double end = start + length;
            final double viewportLength = getViewportLength();

            if (start &lt; 0) {
                scrollPixels(start);
            } else if (end &gt; viewportLength) {
                scrollPixels(end - viewportLength);
            }
        }
    }

    /**
     * Adjusts the cells such that the cell in the given index will be fully visible in
     * the viewport.
     * @param index the index
     */
    public void scrollTo(int index) {
        T cell = getVisibleCell(index);
        if (cell != null) {
            scrollTo(cell);
        } else {
            adjustPositionToIndex(index);
            addAllToPile();
            requestLayout();
        }
    }

    /**
     * Adjusts the cells such that the cell in the given index will be fully visible in
     * the viewport, and positioned at the very top of the viewport.
     * @param index the index
     */
    public void scrollToTop(int index) {
        boolean posSet = false;

        if (index &gt;= getCellCount() - 1) {
            setPosition(1);
            posSet = true;
        } else if (index &lt; 0) {
            setPosition(0);
            posSet = true;
        }

        if (! posSet) {
            adjustPositionToIndex(index);
            double offset = - computeOffsetForCell(index);
            adjustByPixelAmount(offset);
        }

        requestLayout();
    }

//    //TODO We assume all the cell have the same length.  We will need to support
//    // cells of different lengths.
//    public void scrollToOffset(int offset) {
//        scrollPixels(offset * getCellLength(0));
//    }

    /**
     * Given a delta value representing a number of pixels, this method attempts
     * to move the VirtualFlow in the given direction (positive is down/right,
     * negative is up/left) the given number of pixels. It returns the number of
     * pixels actually moved.
     * @param delta the delta value
     * @return the number of pixels actually moved
     */
    public double scrollPixels(final double delta) {
        // Short cut this method for cases where nothing should be done
        if (delta == 0) return 0;

        final boolean isVertical = isVertical();
        if (((isVertical &amp;&amp; (tempVisibility ? !needLengthBar : !vbar.isVisible())) ||
                (! isVertical &amp;&amp; (tempVisibility ? !needLengthBar : !hbar.isVisible())))) return 0;

        double pos = getPosition();
        if (pos == 0.0f &amp;&amp; delta &lt; 0) return 0;
        if (pos == 1.0f &amp;&amp; delta &gt; 0) return 0;

        adjustByPixelAmount(delta);
        if (pos == getPosition()) {
            // The pos hasn't changed, there's nothing to do. This is likely
            // to occur when we hit either extremity
            return 0;
        }

        // Now move stuff around. Translating by pixels fundamentally means
        // moving the cells by the delta. However, after having
        // done that, we need to go through the cells and see which cells,
        // after adding in the translation factor, now fall off the viewport.
        // Also, we need to add cells as appropriate to the end (or beginning,
        // depending on the direction of travel).
        //
        // One simplifying assumption (that had better be true!) is that we
        // will only make it this far in the function if the virtual scroll
        // bar is visible. Otherwise, we never will pixel scroll. So as we go,
        // if we find that the maxPrefBreadth exceeds the viewportBreadth,
        // then we will be sure to show the breadthBar and update it
        // accordingly.
        if (cells.size() &gt; 0) {
            for (int i = 0; i &lt; cells.size(); i++) {
                T cell = cells.get(i);
                assert cell != null;
                positionCell(cell, getCellPosition(cell) - delta);
            }

            // Fix for RT-32908
            T firstCell = cells.getFirst();
            double layoutY = firstCell == null ? 0 : getCellPosition(firstCell);
            for (int i = 0; i &lt; cells.size(); i++) {
                T cell = cells.get(i);
                assert cell != null;
                double actualLayoutY = getCellPosition(cell);
                if (Math.abs(actualLayoutY - layoutY) &gt; 0.001) {
                    // we need to shift the cell to layoutY
                    positionCell(cell, layoutY);
                }

                layoutY += getCellLength(cell);
            }
            // end of fix for RT-32908
            cull();
            firstCell = cells.getFirst();

            // Add any necessary leading cells
            if (firstCell != null) {
                int firstIndex = getCellIndex(firstCell);
                double prevIndexSize = getCellLength(firstIndex - 1);
                addLeadingCells(firstIndex - 1, getCellPosition(firstCell) - prevIndexSize);
            } else {
                int currentIndex = computeCurrentIndex();

                // The distance from the top of the viewport to the top of the
                // cell for the current index.
                double offset = -computeViewportOffset(getPosition());

                // Add all the leading and trailing cells (the call to add leading
                // cells will add the current cell as well -- that is, the one that
                // represents the current position on the mapper).
                addLeadingCells(currentIndex, offset);
            }

            // Starting at the tail of the list, loop adding cells until
            // all the space on the table is filled up. We want to make
            // sure that we DO NOT add empty trailing cells (since we are
            // in the full virtual case and so there are no trailing empty
            // cells).
            if (! addTrailingCells(false)) {
                // Reached the end, but not enough cells to fill up to
                // the end. So, remove the trailing empty space, and translate
                // the cells down
                final T lastCell = getLastVisibleCell();
                final double lastCellSize = getCellLength(lastCell);
                final double cellEnd = getCellPosition(lastCell) + lastCellSize;
                final double viewportLength = getViewportLength();

                if (cellEnd &lt; viewportLength) {
                    // Reposition the nodes
                    double emptySize = viewportLength - cellEnd;
                    for (int i = 0; i &lt; cells.size(); i++) {
                        T cell = cells.get(i);
                        positionCell(cell, getCellPosition(cell) + emptySize);
                    }
                    setPosition(1.0f);
                    // fill the leading empty space
                    firstCell = cells.getFirst();
                    int firstIndex = getCellIndex(firstCell);
                    double prevIndexSize = getCellLength(firstIndex - 1);
                    addLeadingCells(firstIndex - 1, getCellPosition(firstCell) - prevIndexSize);
                }
            }
        }

        // Now throw away any cells that don't fit
        cull();

        // Finally, update the scroll bars
        updateScrollBarsAndCells(false);
        lastPosition = getPosition();

        // notify
        return delta; // TODO fake
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height) {
        double w = isVertical() ? getPrefBreadth(height) : getPrefLength();
        return w + vbar.prefWidth(-1);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width) {
        double h = isVertical() ? getPrefLength() : getPrefBreadth(width);
        return h + hbar.prefHeight(-1);
    }

    /**
     * Return a cell for the given index. This may be called for any cell,
     * including beyond the range defined by cellCount, in which case an
     * empty cell will be returned. The returned value should not be stored for
     * any reason.
     * @param index the index
     * @return the cell
     */
    public T getCell(int index) {
        // If there are cells, then we will attempt to get an existing cell
        if (! cells.isEmpty()) {
            // First check the cells that have already been created and are
            // in use. If this call returns a value, then we can use it
            T cell = getVisibleCell(index);
            if (cell != null) return cell;
        }

        // check the pile
        for (int i = 0; i &lt; pile.size(); i++) {
            T cell = pile.get(i);
            if (getCellIndex(cell) == index) {
                // Note that we don't remove from the pile: if we do it leads
                // to a severe performance decrease. This seems to be OK, as
                // getCell() is only used for cell measurement purposes.
                // pile.remove(i);
                return cell;
            }
        }

        if (pile.size() &gt; 0) {
            return pile.get(0);
        }

        // We need to use the accumCell and return that
        if (accumCell == null) {
            Callback&lt;VirtualFlow&lt;T&gt;,T&gt; cellFactory = getCellFactory();
            if (cellFactory != null) {
                accumCell = cellFactory.call(this);
                accumCell.getProperties().put(NEW_CELL, null);
                accumCellParent.getChildren().setAll(accumCell);

                // Note the screen reader will attempt to find all
                // the items inside the view to calculate the item count.
                // Having items under different parents (sheet and accumCellParent)
                // leads the screen reader to compute wrong values.
                // The regular scheme to provide items to the screen reader
                // uses getPrivateCell(), which places the item in the sheet.
                // The accumCell, and its children, should be ignored by the
                // screen reader.
                accumCell.setAccessibleRole(AccessibleRole.NODE);
                accumCell.getChildrenUnmodifiable().addListener((Observable c) -&gt; {
                    for (Node n : accumCell.getChildrenUnmodifiable()) {
                        n.setAccessibleRole(AccessibleRole.NODE);
                    }
                });
            }
        }
        setCellIndex(accumCell, index);
        resizeCellSize(accumCell);
        return accumCell;
    }

    /**
     * The VirtualFlow uses this method to set a cells index (rather than calling
     * {@link IndexedCell#updateIndex(int)} directly), so it is a perfect place
     * for subclasses to override if this if of interest.
     *
     * @param cell The cell whose index will be updated.
     * @param index The new index for the cell.
     */
    protected void setCellIndex(T cell, int index) {
        assert cell != null;

        cell.updateIndex(index);

        // make sure the cell is sized correctly. This is important for both
        // general layout of cells in a VirtualFlow, but also in cases such as
        // RT-34333, where the sizes were being reported incorrectly to the
        // ComboBox popup.
        if ((cell.isNeedsLayout() &amp;&amp; cell.getScene() != null) || cell.getProperties().containsKey(NEW_CELL)) {
            cell.applyCss();
            cell.getProperties().remove(NEW_CELL);
        }
    }

    /**
     * Return the index for a given cell. This allows subclasses to customise
     * how cell indices are retrieved.
     * @param cell the cell
     * @return the index
     */
    protected int getCellIndex(T cell){
        return cell.getIndex();
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    final VirtualScrollBar getHbar() {
        return hbar;
    }
    final VirtualScrollBar getVbar() {
        return vbar;
    }

    /**
     * The maximum preferred size in the non-virtual direction. For example,
     * if vertical, then this is the max pref width of all cells encountered.
     * &lt;p&gt;
     * In general, this is the largest preferred size in the non-virtual
     * direction that we have ever encountered. We don't reduce this size
     * unless instructed to do so, so as to reduce the amount of scroll bar
     * jitter. The access on this variable is package ONLY FOR TESTING.
     */
    private double maxPrefBreadth;
    private final void setMaxPrefBreadth(double value) {
        this.maxPrefBreadth = value;
    }
    final double getMaxPrefBreadth() {
        return maxPrefBreadth;
    }

    /**
     * The breadth of the viewport portion of the VirtualFlow as computed during
     * the layout pass. In a vertical flow this would be the same as the clip
     * view width. In a horizontal flow this is the clip view height.
     * The access on this variable is package ONLY FOR TESTING.
     */
    private double viewportBreadth;
    private final void setViewportBreadth(double value) {
        this.viewportBreadth = value;
    }
    private final double getViewportBreadth() {
        return viewportBreadth;
    }

    /**
     * The length of the viewport portion of the VirtualFlow as computed
     * during the layout pass. In a vertical flow this would be the same as the
     * clip view height. In a horizontal flow this is the clip view width.
     * The access on this variable is package ONLY FOR TESTING.
     */
    private double viewportLength;
    void setViewportLength(double value) {
        this.viewportLength = value;
    }
    double getViewportLength() {
        return viewportLength;
    }

    /**
     * Compute and return the length of the cell for the given index. This is
     * called both internally when adjusting by pixels, and also at times
     * by PositionMapper (see the getItemSize callback). When called by
     * PositionMapper, it is possible that it will be called for some index
     * which is not associated with any cell, so we have to do a bit of work
     * to use a cell as a helper for computing cell size in some cases.
     */
    double getCellLength(int index) {
        if (fixedCellSizeEnabled) return getFixedCellSize();

        T cell = getCell(index);
        double length = getCellLength(cell);
        releaseCell(cell);
        return length;
    }

    /**
     */
    double getCellBreadth(int index) {
        T cell = getCell(index);
        double b = getCellBreadth(cell);
        releaseCell(cell);
        return b;
    }

    /**
     * Gets the length of a specific cell
     */
    double getCellLength(T cell) {
        if (cell == null) return 0;
        if (fixedCellSizeEnabled) return getFixedCellSize();

        return isVertical() ?
                cell.getLayoutBounds().getHeight()
                : cell.getLayoutBounds().getWidth();
    }

    /**
     * Gets the breadth of a specific cell
     */
    double getCellBreadth(Cell cell) {
        return isVertical() ?
                cell.prefWidth(-1)
                : cell.prefHeight(-1);
    }

    /**
     * Gets the layout position of the cell along the length axis
     */
    double getCellPosition(T cell) {
        if (cell == null) return 0;

        return isVertical() ?
                cell.getLayoutY()
                : cell.getLayoutX();
    }

    private void positionCell(T cell, double position) {
        if (isVertical()) {
            cell.setLayoutX(0);
            cell.setLayoutY(snapSizeY(position));
        } else {
            cell.setLayoutX(snapSizeX(position));
            cell.setLayoutY(0);
        }
    }

    private void resizeCellSize(T cell) {
        if (cell == null) return;

        if (isVertical()) {
            double width = Math.max(getMaxPrefBreadth(), getViewportBreadth());
            cell.resize(width, fixedCellSizeEnabled ? getFixedCellSize() : Utils.boundedSize(cell.prefHeight(width), cell.minHeight(width), cell.maxHeight(width)));
        } else {
            double height = Math.max(getMaxPrefBreadth(), getViewportBreadth());
            cell.resize(fixedCellSizeEnabled ? getFixedCellSize() : Utils.boundedSize(cell.prefWidth(height), cell.minWidth(height), cell.maxWidth(height)), height);
        }
    }

    private List&lt;T&gt; getCells() {
        return cells;
    }

    // Returns last visible cell whose bounds are entirely within the viewport
    T getLastVisibleCellWithinViewPort() {
        if (cells.isEmpty() || getViewportLength() &lt;= 0) return null;

        T cell;
        final double max = getViewportLength();
        for (int i = cells.size() - 1; i &gt;= 0; i--) {
            cell = cells.get(i);
            if (cell.isEmpty()) continue;

            final double cellStart = getCellPosition(cell);
            final double cellEnd = cellStart + getCellLength(cell);

            // we use the magic +2 to allow for a little bit of fuzziness,
            // this is to help in situations such as RT-34407
            if (cellEnd &lt;= (max + 2)) {
                return cell;
            }
        }

        return null;
    }

    // Returns first visible cell whose bounds are entirely within the viewport
    T getFirstVisibleCellWithinViewPort() {
        if (cells.isEmpty() || getViewportLength() &lt;= 0) return null;

        T cell;
        for (int i = 0; i &lt; cells.size(); i++) {
            cell = cells.get(i);
            if (cell.isEmpty()) continue;

            final double cellStart = getCellPosition(cell);
            if (cellStart &gt;= 0) {
                return cell;
            }
        }

        return null;
    }

    /**
     * Adds all the cells prior to and including the given currentIndex, until
     * no more can be added without falling off the flow. The startOffset
     * indicates the distance from the leading edge (top) of the viewport to
     * the leading edge (top) of the currentIndex.
     */
    void addLeadingCells(int currentIndex, double startOffset) {
        // The offset will keep track of the distance from the top of the
        // viewport to the top of the current index. We will increment it
        // as we lay out leading cells.
        double offset = startOffset;
        // The index is the absolute index of the cell being laid out
        int index = currentIndex;

        // Offset should really be the bottom of the current index
        boolean first = true; // first time in, we just fudge the offset and let
        // it be the top of the current index then redefine
        // it as the bottom of the current index thereafter
        // while we have not yet laid out so many cells that they would fall
        // off the flow, we will continue to create and add cells. The
        // offset is our indication of whether we can lay out additional
        // cells. If the offset is ever &lt; 0, except in the case of the very
        // first cell, then we must quit.
        T cell = null;

        // special case for the position == 1.0, skip adding last invisible cell
        if (index == getCellCount() &amp;&amp; offset == getViewportLength()) {
            index--;
            first = false;
        }
        while (index &gt;= 0 &amp;&amp; (offset &gt; 0 || first)) {
            cell = getAvailableCell(index);
            setCellIndex(cell, index);
            resizeCellSize(cell); // resize must be after config
            cells.addFirst(cell);

            // A little gross but better than alternatives because it reduces
            // the number of times we have to update a cell or compute its
            // size. The first time into this loop &quot;offset&quot; is actually the
            // top of the current index. On all subsequent visits, it is the
            // bottom of the current index.
            if (first) {
                first = false;
            } else {
                offset -= getCellLength(cell);
            }

            // Position the cell, and update the maxPrefBreadth variable as we go.
            positionCell(cell, offset);
            setMaxPrefBreadth(Math.max(getMaxPrefBreadth(), getCellBreadth(cell)));
            cell.setVisible(true);
            --index;
        }

        // There are times when after laying out the cells we discover that
        // the top of the first cell which represents index 0 is below the top
        // of the viewport. In these cases, we have to adjust the cells up
        // and reset the mapper position. This might happen when items got
        // removed at the top or when the viewport size increased.
        if (cells.size() &gt; 0) {
            cell = cells.getFirst();
            int firstIndex = getCellIndex(cell);
            double firstCellPos = getCellPosition(cell);
            if (firstIndex == 0 &amp;&amp; firstCellPos &gt; 0) {
                setPosition(0.0f);
                offset = 0;
                for (int i = 0; i &lt; cells.size(); i++) {
                    cell = cells.get(i);
                    positionCell(cell, offset);
                    offset += getCellLength(cell);
                }
            }
        } else {
            // reset scrollbar to top, so if the flow sees cells again it starts at the top
            vbar.setValue(0);
            hbar.setValue(0);
        }
    }

    /**
     * Adds all the trailing cells that come &lt;em&gt;after&lt;/em&gt; the last index in
     * the cells ObservableList.
     */
    boolean addTrailingCells(boolean fillEmptyCells) {
        // If cells is empty then addLeadingCells bailed for some reason and
        // we're hosed, so just punt
        if (cells.isEmpty()) return false;

        // While we have not yet laid out so many cells that they would fall
        // off the flow, so we will continue to create and add cells. When the
        // offset becomes greater than the width/height of the flow, then we
        // know we cannot add any more cells.
        T startCell = cells.getLast();
        double offset = getCellPosition(startCell) + getCellLength(startCell);
        int index = getCellIndex(startCell) + 1;
        final int cellCount = getCellCount();
        boolean filledWithNonEmpty = index &lt;= cellCount;

        final double viewportLength = getViewportLength();

        // Fix for RT-37421, which was a regression caused by RT-36556
        if (offset &lt; 0 &amp;&amp; !fillEmptyCells) {
            return false;
        }

        //
        // RT-36507: viewportLength gives the maximum number of
        // additional cells that should ever be able to fit in the viewport if
        // every cell had a height of 1. If index ever exceeds this count,
        // then offset is not incrementing fast enough, or at all, which means
        // there is something wrong with the cell size calculation.
        //
        final double maxCellCount = viewportLength;
        while (offset &lt; viewportLength) {
            if (index &gt;= cellCount) {
                if (offset &lt; viewportLength) filledWithNonEmpty = false;
                if (! fillEmptyCells) return filledWithNonEmpty;
                // RT-36507 - return if we've exceeded the maximum
                if (index &gt; maxCellCount) {
                    final PlatformLogger logger = Logging.getControlsLogger();
                    if (logger.isLoggable(PlatformLogger.Level.INFO)) {
                        logger.info(&quot;index exceeds maxCellCount. Check size calculations for &quot; + startCell.getClass());
                    }
                    return filledWithNonEmpty;
                }
            }
            T cell = getAvailableCell(index);
            setCellIndex(cell, index);
            resizeCellSize(cell); // resize happens after config!
            cells.addLast(cell);

            // Position the cell and update the max pref
            positionCell(cell, offset);
            setMaxPrefBreadth(Math.max(getMaxPrefBreadth(), getCellBreadth(cell)));

            offset += getCellLength(cell);
            cell.setVisible(true);
            ++index;
        }

        // Discover whether the first cell coincides with index #0. If after
        // adding all the trailing cells we find that a) the first cell was
        // not index #0 and b) there are trailing cells, then we have a
        // problem. We need to shift all the cells down and add leading cells,
        // one at a time, until either the very last non-empty cells is aligned
        // with the bottom OR we have laid out cell index #0 at the first
        // position.
        T firstCell = cells.getFirst();
        index = getCellIndex(firstCell);
        T lastNonEmptyCell = getLastVisibleCell();
        double start = getCellPosition(firstCell);
        double end = getCellPosition(lastNonEmptyCell) + getCellLength(lastNonEmptyCell);
        if ((index != 0 || (index == 0 &amp;&amp; start &lt; 0)) &amp;&amp; fillEmptyCells &amp;&amp;
                lastNonEmptyCell != null &amp;&amp; getCellIndex(lastNonEmptyCell) == cellCount - 1 &amp;&amp; end &lt; viewportLength) {

            double prospectiveEnd = end;
            double distance = viewportLength - end;
            while (prospectiveEnd &lt; viewportLength &amp;&amp; index != 0 &amp;&amp; (-start) &lt; distance) {
                index--;
                T cell = getAvailableCell(index);
                setCellIndex(cell, index);
                resizeCellSize(cell); // resize must be after config
                cells.addFirst(cell);
                double cellLength = getCellLength(cell);
                start -= cellLength;
                prospectiveEnd += cellLength;
                positionCell(cell, start);
                setMaxPrefBreadth(Math.max(getMaxPrefBreadth(), getCellBreadth(cell)));
                cell.setVisible(true);
            }

            // The amount by which to translate the cells down
            firstCell = cells.getFirst();
            start = getCellPosition(firstCell);
            double delta = viewportLength - end;
            if (getCellIndex(firstCell) == 0 &amp;&amp; delta &gt; (-start)) {
                delta = (-start);
            }
            // Move things
            for (int i = 0; i &lt; cells.size(); i++) {
                T cell = cells.get(i);
                positionCell(cell, getCellPosition(cell) + delta);
            }

            // Check whether the first cell, subsequent to our adjustments, is
            // now index #0 and aligned with the top. If so, change the position
            // to be at 0 instead of 1.
            start = getCellPosition(firstCell);
            if (getCellIndex(firstCell) == 0 &amp;&amp; start == 0) {
                setPosition(0);
            } else if (getPosition() != 1) {
                setPosition(1);
            }
        }

        return filledWithNonEmpty;
    }

    void reconfigureCells() {
        needsReconfigureCells = true;
        requestLayout();
    }

    void recreateCells() {
        needsRecreateCells = true;
        requestLayout();
    }

    void rebuildCells() {
        needsRebuildCells = true;
        requestLayout();
    }

    void requestCellLayout() {
        needsCellsLayout = true;
        requestLayout();
    }

    void setCellDirty(int index) {
        dirtyCells.set(index);
        requestLayout();
    }

    private void startSBReleasedAnimation() {
        if (sbTouchTimeline == null) {
            /*
            ** timeline to leave the scrollbars visible for a short
            ** while after a scroll/drag
            */
            sbTouchTimeline = new Timeline();
            sbTouchKF1 = new KeyFrame(Duration.millis(0), event -&gt; {
                tempVisibility = true;
                requestLayout();
            });

            sbTouchKF2 = new KeyFrame(Duration.millis(1000), event -&gt; {
                if (touchDetected == false &amp;&amp; mouseDown == false) {
                    tempVisibility = false;
                    requestLayout();
                }
            });
            sbTouchTimeline.getKeyFrames().addAll(sbTouchKF1, sbTouchKF2);
        }
        sbTouchTimeline.playFromStart();
    }

    private void scrollBarOn() {
        tempVisibility = true;
        requestLayout();
    }

    void updateHbar() {
        if (! isVisible() || getScene() == null) return;
        // Bring the clipView.clipX back to 0 if control is vertical or
        // the hbar isn't visible (fix for RT-11666)
        if (isVertical()) {
            if (hbar.isVisible()) {
                clipView.setClipX(hbar.getValue());
            } else {
                // all cells are now less than the width of the flow,
                // so we should shift the hbar/clip such that
                // everything is visible in the viewport.
                clipView.setClipX(0);
                hbar.setValue(0);
            }
        }
    }

    /**
     * @return true if bar visibility changed
     */
    private boolean computeBarVisiblity() {
        if (cells.isEmpty()) {
            // In case no cells are set yet, we assume no bars are needed
            needLengthBar = false;
            needBreadthBar = false;
            return true;
        }

        final boolean isVertical = isVertical();
        boolean barVisibilityChanged = false;

        VirtualScrollBar breadthBar = isVertical ? hbar : vbar;
        VirtualScrollBar lengthBar = isVertical ? vbar : hbar;

        final double viewportBreadth = getViewportBreadth();

        final int cellsSize = cells.size();
        final int cellCount = getCellCount();
        for (int i = 0; i &lt; 2; i++) {
            final boolean lengthBarVisible = getPosition() &gt; 0
                    || cellCount &gt; cellsSize
                    || (cellCount == cellsSize &amp;&amp; (getCellPosition(cells.getLast()) + getCellLength(cells.getLast())) &gt; getViewportLength())
                    || (cellCount == cellsSize - 1 &amp;&amp; barVisibilityChanged &amp;&amp; needBreadthBar);

            if (lengthBarVisible ^ needLengthBar) {
                needLengthBar = lengthBarVisible;
                barVisibilityChanged = true;
            }

            // second conditional removed for RT-36669.
            final boolean breadthBarVisible = (maxPrefBreadth &gt; viewportBreadth);// || (needLengthBar &amp;&amp; maxPrefBreadth &gt; (viewportBreadth - lengthBarBreadth));
            if (breadthBarVisible ^ needBreadthBar) {
                needBreadthBar = breadthBarVisible;
                barVisibilityChanged = true;
            }
        }

        // Start by optimistically deciding whether the length bar and
        // breadth bar are needed and adjust the viewport dimensions
        // accordingly. If during layout we find that one or the other of the
        // bars actually is needed, then we will perform a cleanup pass

        if (!Properties.IS_TOUCH_SUPPORTED) {
            updateViewportDimensions();
            breadthBar.setVisible(needBreadthBar);
            lengthBar.setVisible(needLengthBar);
        } else {
            breadthBar.setVisible(needBreadthBar &amp;&amp; tempVisibility);
            lengthBar.setVisible(needLengthBar &amp;&amp; tempVisibility);
        }

        return barVisibilityChanged;
    }

    private void updateViewportDimensions() {
        final boolean isVertical = isVertical();
        final double breadthBarLength = isVertical ? snapSizeY(hbar.prefHeight(-1)) : snapSizeX(vbar.prefWidth(-1));
        final double lengthBarBreadth = isVertical ? snapSizeX(vbar.prefWidth(-1)) : snapSizeY(hbar.prefHeight(-1));

        setViewportBreadth((isVertical ? getWidth() : getHeight()) - (needLengthBar ? lengthBarBreadth : 0));
        setViewportLength((isVertical ? getHeight() : getWidth()) - (needBreadthBar ? breadthBarLength : 0));
    }

    private void initViewport() {
        // Initialize the viewportLength and viewportBreadth to match the
        // width/height of the flow
        final boolean isVertical = isVertical();

        updateViewportDimensions();

        VirtualScrollBar breadthBar = isVertical ? hbar : vbar;
        VirtualScrollBar lengthBar = isVertical ? vbar : hbar;

        // If there has been a switch between the virtualized bar, then we
        // will want to do some stuff TODO.
        breadthBar.setVirtual(false);
        lengthBar.setVirtual(true);
    }

    private void updateScrollBarsAndCells(boolean recreate) {
        // Assign the hbar and vbar to the breadthBar and lengthBar so as
        // to make some subsequent calculations easier.
        final boolean isVertical = isVertical();
        VirtualScrollBar breadthBar = isVertical ? hbar : vbar;
        VirtualScrollBar lengthBar = isVertical ? vbar : hbar;

        // We may have adjusted the viewport length and breadth after the
        // layout due to scroll bars becoming visible. So we need to perform
        // a follow up pass and resize and shift all the cells to fit the
        // viewport. Note that the prospective viewport size is always &gt;= the
        // final viewport size, so we don't have to worry about adding
        // cells during this cleanup phase.
        fitCells();

        // Update cell positions.
        // When rebuilding the cells, we add the cells and along the way compute
        // the maxPrefBreadth. Based on the computed value, we may add
        // the breadth scrollbar which changes viewport length, so we need
        // to re-position the cells.
        if (!cells.isEmpty()) {
            final double currOffset = -computeViewportOffset(getPosition());
            final int currIndex = computeCurrentIndex() - cells.getFirst().getIndex();
            final int size = cells.size();

            // position leading cells
            double offset = currOffset;

            for (int i = currIndex - 1; i &gt;= 0 &amp;&amp; i &lt; size; i--) {
                final T cell = cells.get(i);

                offset -= getCellLength(cell);

                positionCell(cell, offset);
            }

            // position trailing cells
            offset = currOffset;
            for (int i = currIndex; i &gt;= 0 &amp;&amp; i &lt; size; i++) {
                final T cell = cells.get(i);
                positionCell(cell, offset);

                offset += getCellLength(cell);
            }
        }

        // Toggle visibility on the corner
        corner.setVisible(breadthBar.isVisible() &amp;&amp; lengthBar.isVisible());

        double sumCellLength = 0;
        double flowLength = (isVertical ? getHeight() : getWidth()) -
                (breadthBar.isVisible() ? breadthBar.prefHeight(-1) : 0);

        final double viewportBreadth = getViewportBreadth();
        final double viewportLength = getViewportLength();

        // Now position and update the scroll bars
        if (breadthBar.isVisible()) {
            /*
            ** Positioning the ScrollBar
            */
            if (!Properties.IS_TOUCH_SUPPORTED) {
                if (isVertical) {
                    hbar.resizeRelocate(0, viewportLength,
                            viewportBreadth, hbar.prefHeight(viewportBreadth));
                } else {
                    vbar.resizeRelocate(viewportLength, 0,
                            vbar.prefWidth(viewportBreadth), viewportBreadth);
                }
            }
            else {
                if (isVertical) {
                    hbar.resizeRelocate(0, (viewportLength-hbar.getHeight()),
                            viewportBreadth, hbar.prefHeight(viewportBreadth));
                } else {
                    vbar.resizeRelocate((viewportLength-vbar.getWidth()), 0,
                            vbar.prefWidth(viewportBreadth), viewportBreadth);
                }
            }

            if (getMaxPrefBreadth() != -1) {
                double newMax = Math.max(1, getMaxPrefBreadth() - viewportBreadth);
                if (newMax != breadthBar.getMax()) {
                    breadthBar.setMax(newMax);

                    double breadthBarValue = breadthBar.getValue();
                    boolean maxed = breadthBarValue != 0 &amp;&amp; newMax == breadthBarValue;
                    if (maxed || breadthBarValue &gt; newMax) {
                        breadthBar.setValue(newMax);
                    }

                    breadthBar.setVisibleAmount((viewportBreadth / getMaxPrefBreadth()) * newMax);
                }
            }
        }

        // determine how many cells there are on screen so that the scrollbar
        // thumb can be appropriately sized
        if (recreate &amp;&amp; (lengthBar.isVisible() || Properties.IS_TOUCH_SUPPORTED)) {
            final int cellCount = getCellCount();
            int numCellsVisibleOnScreen = 0;
            for (int i = 0, max = cells.size(); i &lt; max; i++) {
                T cell = cells.get(i);
                if (cell != null &amp;&amp; !cell.isEmpty()) {
                    sumCellLength += (isVertical ? cell.getHeight() : cell.getWidth());
                    if (sumCellLength &gt; flowLength) {
                        break;
                    }

                    numCellsVisibleOnScreen++;
                }
            }

            lengthBar.setMax(1);
            if (numCellsVisibleOnScreen == 0 &amp;&amp; cellCount == 1) {
                // special case to help resolve RT-17701 and the case where we have
                // only a single row and it is bigger than the viewport
                lengthBar.setVisibleAmount(flowLength / sumCellLength);
            } else {
                lengthBar.setVisibleAmount(numCellsVisibleOnScreen / (float) cellCount);
            }
        }

        if (lengthBar.isVisible()) {
            // Fix for RT-11873. If this isn't here, we can have a situation where
            // the scrollbar scrolls endlessly. This is possible when the cell
            // count grows as the user hits the maximal position on the scrollbar
            // (i.e. the list size dynamically grows as the user needs more).
            //
            // This code was commented out to resolve RT-14477 after testing
            // whether RT-11873 can be recreated. It could not, and therefore
            // for now this code will remained uncommented until it is deleted
            // following further testing.
//            if (lengthBar.getValue() == 1.0 &amp;&amp; lastCellCount != cellCount) {
//                lengthBar.setValue(0.99);
//            }

            /*
            ** Positioning the ScrollBar
            */
            if (!Properties.IS_TOUCH_SUPPORTED) {
                if (isVertical) {
                    vbar.resizeRelocate(viewportBreadth, 0, vbar.prefWidth(viewportLength), viewportLength);
                } else {
                    hbar.resizeRelocate(0, viewportBreadth, viewportLength, hbar.prefHeight(-1));
                }
            }
            else {
                if (isVertical) {
                    vbar.resizeRelocate((viewportBreadth-vbar.getWidth()), 0, vbar.prefWidth(viewportLength), viewportLength);
                } else {
                    hbar.resizeRelocate(0, (viewportBreadth-hbar.getHeight()), viewportLength, hbar.prefHeight(-1));
                }
            }
        }

        if (corner.isVisible()) {
            if (!Properties.IS_TOUCH_SUPPORTED) {
                corner.resize(vbar.getWidth(), hbar.getHeight());
                corner.relocate(hbar.getLayoutX() + hbar.getWidth(), vbar.getLayoutY() + vbar.getHeight());
            }
            else {
                corner.resize(vbar.getWidth(), hbar.getHeight());
                corner.relocate(hbar.getLayoutX() + (hbar.getWidth()-vbar.getWidth()), vbar.getLayoutY() + (vbar.getHeight()-hbar.getHeight()));
                hbar.resize(hbar.getWidth()-vbar.getWidth(), hbar.getHeight());
                vbar.resize(vbar.getWidth(), vbar.getHeight()-hbar.getHeight());
            }
        }

        clipView.resize(snapSizeX(isVertical ? viewportBreadth : viewportLength),
                        snapSizeY(isVertical ? viewportLength : viewportBreadth));

        // If the viewportLength becomes large enough that all cells fit
        // within the viewport, then we want to update the value to match.
        if (getPosition() != lengthBar.getValue()) {
            lengthBar.setValue(getPosition());
        }
    }

    /**
     * Adjusts the cells location and size if necessary. The breadths of all
     * cells will be adjusted to fit the viewportWidth or maxPrefBreadth, and
     * the layout position will be updated if necessary based on index and
     * offset.
     */
    private void fitCells() {
        double size = Math.max(getMaxPrefBreadth(), getViewportBreadth());
        boolean isVertical = isVertical();

        // Note: Do not optimise this loop by pre-calculating the cells size and
        // storing that into a int value - this can lead to RT-32828
        for (int i = 0; i &lt; cells.size(); i++) {
            Cell&lt;?&gt; cell = cells.get(i);
            if (isVertical) {
                cell.resize(size, cell.prefHeight(size));
            } else {
                cell.resize(cell.prefWidth(size), size);
            }
        }
    }

    private void cull() {
        final double viewportLength = getViewportLength();
        for (int i = cells.size() - 1; i &gt;= 0; i--) {
            T cell = cells.get(i);
            double cellSize = getCellLength(cell);
            double cellStart = getCellPosition(cell);
            double cellEnd = cellStart + cellSize;
            if (cellStart &gt;= viewportLength || cellEnd &lt; 0) {
                addToPile(cells.remove(i));
            }
        }
    }

    /**
     * After using the accum cell, it needs to be released!
     */
    private void releaseCell(T cell) {
        if (accumCell != null &amp;&amp; cell == accumCell) {
            accumCell.updateIndex(-1);
        }
    }

    /**
     * This method is an experts-only method - if the requested index is not
     * already an existing visible cell, it will create a cell for the
     * given index and insert it into the sheet. From that point on it will be
     * unmanaged, and is up to the caller of this method to manage it.
     */
    T getPrivateCell(int index)  {
        T cell = null;

        // If there are cells, then we will attempt to get an existing cell
        if (! cells.isEmpty()) {
            // First check the cells that have already been created and are
            // in use. If this call returns a value, then we can use it
            cell = getVisibleCell(index);
            if (cell != null) {
                // Force the underlying text inside the cell to be updated
                // so that when the screen reader runs, it will match the
                // text in the cell (force updateDisplayedText())
                cell.layout();
                return cell;
            }
        }

        // check the existing sheet children
        if (cell == null) {
            for (int i = 0; i &lt; sheetChildren.size(); i++) {
                T _cell = (T) sheetChildren.get(i);
                if (getCellIndex(_cell) == index) {
                    return _cell;
                }
            }
        }

        Callback&lt;VirtualFlow&lt;T&gt;, T&gt; cellFactory = getCellFactory();
        if (cellFactory != null) {
            cell = cellFactory.call(this);
        }

        if (cell != null) {
            setCellIndex(cell, index);
            resizeCellSize(cell);
            cell.setVisible(false);
            sheetChildren.add(cell);
            privateCells.add(cell);
        }

        return cell;
    }

    private final List&lt;T&gt; privateCells = new ArrayList&lt;&gt;();

    private void releaseAllPrivateCells() {
        sheetChildren.removeAll(privateCells);
        privateCells.clear();
    }

    /**
     * Puts the given cell onto the pile. This is called whenever a cell has
     * fallen off the flow's start.
     */
    private void addToPile(T cell) {
        assert cell != null;
        pile.addLast(cell);
    }

    private void cleanPile() {
        boolean wasFocusOwner = false;

        for (int i = 0, max = pile.size(); i &lt; max; i++) {
            T cell = pile.get(i);
            wasFocusOwner = wasFocusOwner || doesCellContainFocus(cell);
            cell.setVisible(false);
        }

        // Fix for RT-35876: Rather than have the cells do weird things with
        // focus (in particular, have focus jump between cells), we return focus
        // to the VirtualFlow itself.
        if (wasFocusOwner) {
            requestFocus();
        }
    }

    private boolean doesCellContainFocus(Cell&lt;?&gt; c) {
        Scene scene = c.getScene();
        final Node focusOwner = scene == null ? null : scene.getFocusOwner();

        if (focusOwner != null) {
            if (c.equals(focusOwner)) {
                return true;
            }

            Parent p = focusOwner.getParent();
            while (p != null &amp;&amp; ! (p instanceof VirtualFlow)) {
                if (c.equals(p)) {
                    return true;
                }
                p = p.getParent();
            }
        }

        return false;
    }

    private double getPrefBreadth(double oppDimension) {
        double max = getMaxCellWidth(10);

        // This primarily exists for the case where we do not want the breadth
        // to grow to ensure a golden ratio between width and height (for example,
        // when a ListView is used in a ComboBox - the width should not grow
        // just because items are being added to the ListView)
        if (oppDimension &gt; -1) {
            double prefLength = getPrefLength();
            max = Math.max(max, prefLength * GOLDEN_RATIO_MULTIPLIER);
        }

        return max;
    }

    private double getPrefLength() {
        double sum = 0.0;
        int rows = Math.min(10, getCellCount());
        for (int i = 0; i &lt; rows; i++) {
            sum += getCellLength(i);
        }
        return sum;
    }

    double getMaxCellWidth(int rowsToCount) {
        double max = 0.0;

        // we always measure at least one row
        int rows = Math.max(1, rowsToCount == -1 ? getCellCount() : rowsToCount);
        for (int i = 0; i &lt; rows; i++) {
            max = Math.max(max, getCellBreadth(i));
        }
        return max;
    }

    // Old PositionMapper
    /**
     * Given a position value between 0 and 1, compute and return the viewport
     * offset from the &quot;current&quot; cell associated with that position value.
     * That is, if the return value of this function where used as a translation
     * factor for a sheet that contained all the items, then the current
     * item would end up positioned correctly.
     */
    private double computeViewportOffset(double position) {
        double p = com.sun.javafx.util.Utils.clamp(0, position, 1);
        double fractionalPosition = p * getCellCount();
        int cellIndex = (int) fractionalPosition;
        double fraction = fractionalPosition - cellIndex;
        double cellSize = getCellLength(cellIndex);
        double pixelOffset = cellSize * fraction;
        double viewportOffset = getViewportLength() * p;
        return pixelOffset - viewportOffset;
    }

    private void adjustPositionToIndex(int index) {
        int cellCount = getCellCount();
        if (cellCount &lt;= 0) {
            setPosition(0.0f);
        } else {
            setPosition(((double)index) / cellCount);
        }
    }

    /**
     * Adjust the position based on a delta of pixels. If negative, then the
     * position will be adjusted negatively. If positive, then the position will
     * be adjusted positively. If the pixel amount is too great for the range of
     * the position, then it will be clamped such that position is always
     * strictly between 0 and 1
     */
    private void adjustByPixelAmount(double numPixels) {
        if (numPixels == 0) return;
        // Starting from the current cell, we move in the direction indicated
        // by numPixels one cell at a team. For each cell, we discover how many
        // pixels the &quot;position&quot; line would move within that cell, and adjust
        // our count of numPixels accordingly. When we come to the &quot;final&quot; cell,
        // then we can take the remaining number of pixels and multiply it by
        // the &quot;travel rate&quot; of &quot;p&quot; within that cell to get the delta. Add
        // the delta to &quot;p&quot; to get position.

        // get some basic info about the list and the current cell
        boolean forward = numPixels &gt; 0;
        int cellCount = getCellCount();
        double fractionalPosition = getPosition() * cellCount;
        int cellIndex = (int) fractionalPosition;
        if (forward &amp;&amp; cellIndex == cellCount) return;
        double cellSize = getCellLength(cellIndex);
        double fraction = fractionalPosition - cellIndex;
        double pixelOffset = cellSize * fraction;

        // compute the percentage of &quot;position&quot; that represents each cell
        double cellPercent = 1.0 / cellCount;

        // To help simplify the algorithm, we pretend as though the current
        // position is at the beginning of the current cell. This reduces some
        // of the corner cases and provides a simpler algorithm without adding
        // any overhead to performance.
        double start = computeOffsetForCell(cellIndex);
        double end = cellSize + computeOffsetForCell(cellIndex + 1);

        // We need to discover the distance that the fictional &quot;position line&quot;
        // would travel within this cell, from its current position to the end.
        double remaining = end - start;

        // Keep track of the number of pixels left to travel
        double n = forward ?
              numPixels + pixelOffset - (getViewportLength() * getPosition()) - start
            : -numPixels + end - (pixelOffset - (getViewportLength() * getPosition()));

        // &quot;p&quot; represents the most recent value for position. This is always
        // based on the edge between two cells, except at the very end of the
        // algorithm where it is added to the computed &quot;p&quot; offset for the final
        // value of Position.
        double p = cellPercent * cellIndex;

        // Loop over the cells one at a time until either we reach the end of
        // the cells, or we find that the &quot;n&quot; will fall within the cell we're on
        while (n &gt; remaining &amp;&amp; ((forward &amp;&amp; cellIndex &lt; cellCount - 1) || (! forward &amp;&amp; cellIndex &gt; 0))) {
            if (forward) cellIndex++; else cellIndex--;
            n -= remaining;
            cellSize = getCellLength(cellIndex);
            start = computeOffsetForCell(cellIndex);
            end = cellSize + computeOffsetForCell(cellIndex + 1);
            remaining = end - start;
            p = cellPercent * cellIndex;
        }

        // if remaining is &lt; n, then we must have hit an end, so as a
        // fast path, we can just set position to 1.0 or 0.0 and return
        // because we know we hit the end
        if (n &gt; remaining) {
            setPosition(forward ? 1.0f : 0.0f);
        } else if (forward) {
            double rate = cellPercent / Math.abs(end - start);
            setPosition(p + (rate * n));
        } else {
<A NAME="36"></A>            double rate = cellPercent / Math.abs(end - start);
            setPosition((p + cellPercent) - (rate * n));
        }
    <FONT color="#ff00ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#36',2,'match31-top.html#36',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    private int computeCurrentIndex() {
        return (int) (getPosition() * getCellCount());
    }

    /**
     * Given an item index, this function will compute and return the viewport
     * offset from the beginning of the specified item. Notice that because each
     * item has the same percentage of the position dedicated to it, and since
     * we are measuring from the start of each item, this is a very simple
     * calculation.
     */
    private double computeOffsetForCell(int itemIndex) {
        double cellCount = getCellCount()</B></FONT>;
        double p = com.sun.javafx.util.Utils.clamp(0, itemIndex, cellCount) / cellCount;
        return -(getViewportLength() * p);
    }

//    /**
//     * Adjust the position based on a chunk of pixels. The position is based
//     * on the start of the scrollbar position.
//     */
//    private void adjustByPixelChunk(double numPixels) {
//        setPosition(0);
//        adjustByPixelAmount(numPixels);
//    }
    // end of old PositionMapper code




    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    /**
     * A simple extension to Region that ensures that anything wanting to flow
     * outside of the bounds of the Region is clipped.
     */
    static class ClippedContainer extends Region {

        /**
         * The Node which is embedded within this {@code ClipView}.
         */
        private Node node;
        public Node getNode() { return this.node; }
        public void setNode(Node n) {
            this.node = n;

            getChildren().clear();
            getChildren().add(node);
        }

        public void setClipX(double clipX) {
            setLayoutX(-clipX);
            clipRect.setLayoutX(clipX);
        }

        public void setClipY(double clipY) {
            setLayoutY(-clipY);
            clipRect.setLayoutY(clipY);
        }

        private final Rectangle clipRect;

        public ClippedContainer(final VirtualFlow&lt;?&gt; flow) {
            if (flow == null) {
                throw new IllegalArgumentException(&quot;VirtualFlow can not be null&quot;);
            }

            getStyleClass().add(&quot;clipped-container&quot;);

            // clipping
            clipRect = new Rectangle();
            clipRect.setSmooth(false);
            setClip(clipRect);
            // --- clipping

            super.widthProperty().addListener(valueModel -&gt; {
                clipRect.setWidth(getWidth());
            });
            super.heightProperty().addListener(valueModel -&gt; {
                clipRect.setHeight(getHeight());
            });
        }
    }

    /**
     * A List-like implementation that is exceedingly efficient for the purposes
     * of the VirtualFlow. Typically there is not much variance in the number of
     * cells -- it is always some reasonably consistent number. Yet for efficiency
     * in code, we like to use a linked list implementation so as to append to
     * start or append to end. However, at times when we need to iterate, LinkedList
     * is expensive computationally as well as requiring the construction of
     * temporary iterators.
     * &lt;p&gt;
     * This linked list like implementation is done using an array. It begins by
     * putting the first item in the center of the allocated array, and then grows
     * outward (either towards the first or last of the array depending on whether
     * we are inserting at the head or tail). It maintains an index to the start
     * and end of the array, so that it can efficiently expose iteration.
     * &lt;p&gt;
     * This class is package private solely for the sake of testing.
     */
    static class ArrayLinkedList&lt;T&gt; extends AbstractList&lt;T&gt; {
        /**
         * The array list backing this class. We default the size of the array
         * list to be fairly large so as not to require resizing during normal
         * use, and since that many ArrayLinkedLists won't be created it isn't
         * very painful to do so.
         */
        private final ArrayList&lt;T&gt; array;

        private int firstIndex = -1;
        private int lastIndex = -1;

        public ArrayLinkedList() {
            array = new ArrayList&lt;T&gt;(50);

            for (int i = 0; i &lt; 50; i++) {
                array.add(null);
            }
        }

        public T getFirst() {
            return firstIndex == -1 ? null : array.get(firstIndex);
        }

        public T getLast() {
            return lastIndex == -1 ? null : array.get(lastIndex);
        }

        public void addFirst(T cell) {
            // if firstIndex == -1 then that means this is the first item in the
            // list and we need to initialize firstIndex and lastIndex
            if (firstIndex == -1) {
                firstIndex = lastIndex = array.size() / 2;
                array.set(firstIndex, cell);
            } else if (firstIndex == 0) {
                // we're already at the head of the array, so insert at position
                // 0 and then increment the lastIndex to compensate
                array.add(0, cell);
                lastIndex++;
            } else {
                // we're not yet at the head of the array, so insert at the
                // firstIndex - 1 position and decrement first position
                array.set(--firstIndex, cell);
            }
        }

        public void addLast(T cell) {
            // if lastIndex == -1 then that means this is the first item in the
            // list and we need to initialize the firstIndex and lastIndex
            if (firstIndex == -1) {
                firstIndex = lastIndex = array.size() / 2;
                array.set(lastIndex, cell);
            } else if (lastIndex == array.size() - 1) {
                // we're at the end of the array so need to &quot;add&quot; so as to force
                // the array to be expanded in size
                array.add(++lastIndex, cell);
            } else {
                array.set(++lastIndex, cell);
            }
        }

        public int size() {
            return firstIndex == -1 ? 0 : lastIndex - firstIndex + 1;
        }

        public boolean isEmpty() {
            return firstIndex == -1;
        }

        public T get(int index) {
            if (index &gt; (lastIndex - firstIndex) || index &lt; 0) {
                // Commented out exception due to RT-29111
                // throw new java.lang.ArrayIndexOutOfBoundsException();
                return null;
            }

            return array.get(firstIndex + index);
        }

        public void clear() {
            for (int i = 0; i &lt; array.size(); i++) {
                array.set(i, null);
            }

            firstIndex = lastIndex = -1;
        }

        public T removeFirst() {
            if (isEmpty()) return null;
            return remove(0);
        }

        public T removeLast() {
            if (isEmpty()) return null;
            return remove(lastIndex - firstIndex);
        }

        public T remove(int index) {
            if (index &gt; lastIndex - firstIndex || index &lt; 0) {
                throw new ArrayIndexOutOfBoundsException();
            }

            // if the index == 0, then we're removing the first
            // item and can simply set it to null in the array and increment
            // the firstIndex unless there is only one item, in which case
            // we have to also set first &amp; last index to -1.
            if (index == 0) {
                T cell = array.get(firstIndex);
                array.set(firstIndex, null);
                if (firstIndex == lastIndex) {
                    firstIndex = lastIndex = -1;
                } else {
                    firstIndex++;
                }
                return cell;
            } else if (index == lastIndex - firstIndex) {
                // if the index == lastIndex - firstIndex, then we're removing the
                // last item and can simply set it to null in the array and
                // decrement the lastIndex
                T cell = array.get(lastIndex);
                array.set(lastIndex--, null);
                return cell;
            } else {
                // if the index is somewhere in between, then we have to remove the
                // item and decrement the lastIndex
                T cell = array.get(firstIndex + index);
                array.set(firstIndex + index, null);
                for (int i = (firstIndex + index + 1); i &lt;= lastIndex; i++) {
                    array.set(i - 1, array.get(i));
                }
                array.set(lastIndex--, null);
                return cell;
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.fxml/com/sun/javafx/fxml/PropertyNotFoundException.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.fxml;

/**
 * Thrown when a caller attempts to set the value of a non-existent bean
 * property.
 */
public class PropertyNotFoundException extends RuntimeException {
    private static final long serialVersionUID = 0;

    public PropertyNotFoundException() {
<A NAME="3"></A>        super();
    }

    <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#3',2,'match31-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>public PropertyNotFoundException(String message) {
        super(message);
    }

    public PropertyNotFoundException(Throwable cause) {
        super</B></FONT>(cause);
    }

    public PropertyNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.fxml/javafx/fxml/FXMLLoader.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.fxml;

import com.sun.javafx.util.Logging;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.regex.Pattern;

import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.property.Property;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.*;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.util.Builder;
import javafx.util.BuilderFactory;
import javafx.util.Callback;

import javax.script.Bindings;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import javax.script.SimpleBindings;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.util.StreamReaderDelegate;

import com.sun.javafx.beans.IDProperty;
import com.sun.javafx.fxml.BeanAdapter;
import com.sun.javafx.fxml.ParseTraceElement;
import com.sun.javafx.fxml.PropertyNotFoundException;
import com.sun.javafx.fxml.expression.Expression;
import com.sun.javafx.fxml.expression.ExpressionValue;
import com.sun.javafx.fxml.expression.KeyPath;
import static com.sun.javafx.FXPermissions.MODIFY_FXML_CLASS_LOADER_PERMISSION;
import com.sun.javafx.fxml.FXMLLoaderHelper;
import com.sun.javafx.fxml.MethodHelper;
import java.net.MalformedURLException;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.EnumMap;
import java.util.Locale;
import java.util.StringTokenizer;
import com.sun.javafx.reflect.ConstructorUtil;
import com.sun.javafx.reflect.MethodUtil;
import com.sun.javafx.reflect.ReflectUtil;

/**
 * Loads an object hierarchy from an XML document.
 * For more information, see the
 * &lt;a href=&quot;doc-files/introduction_to_fxml.html&quot;&gt;Introduction to FXML&lt;/a&gt;
 * document.
 *
 * @since JavaFX 2.0
 */
public class FXMLLoader {

    // Indicates permission to get the ClassLoader
    private static final RuntimePermission GET_CLASSLOADER_PERMISSION =
        new RuntimePermission(&quot;getClassLoader&quot;);

    // Instance of StackWalker used to get caller class (must be private)
    private static final StackWalker walker =
        AccessController.doPrivileged((PrivilegedAction&lt;StackWalker&gt;) () -&gt;
            StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE));

    // Abstract base class for elements
    private abstract class Element {
        public final Element parent;

        public Object value = null;
        private BeanAdapter valueAdapter = null;

        public final LinkedList&lt;Attribute&gt; eventHandlerAttributes = new LinkedList&lt;Attribute&gt;();
        public final LinkedList&lt;Attribute&gt; instancePropertyAttributes = new LinkedList&lt;Attribute&gt;();
        public final LinkedList&lt;Attribute&gt; staticPropertyAttributes = new LinkedList&lt;Attribute&gt;();
        public final LinkedList&lt;PropertyElement&gt; staticPropertyElements = new LinkedList&lt;PropertyElement&gt;();

        public Element() {
            parent = current;
        }

        public boolean isCollection() {
            // Return true if value is a list, or if the value's type defines
            // a default property that is a list
            boolean collection;
            if (value instanceof List&lt;?&gt;) {
                collection = true;
            } else {
                Class&lt;?&gt; type = value.getClass();
                DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);

                if (defaultProperty != null) {
                    collection = getProperties().get(defaultProperty.value()) instanceof List&lt;?&gt;;
                } else {
                    collection = false;
                }
            }

            return collection;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public void add(Object element) throws LoadException {
            // If value is a list, add element to it; otherwise, get the value
            // of the default property, which is assumed to be a list and add
            // to that (coerce to the appropriate type)
            List&lt;Object&gt; list;
            if (value instanceof List&lt;?&gt;) {
                list = (List&lt;Object&gt;)value;
            } else {
                Class&lt;?&gt; type = value.getClass();
                DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
                String defaultPropertyName = defaultProperty.value();

                // Get the list value
                list = (List&lt;Object&gt;)getProperties().get(defaultPropertyName);

                // Coerce the element to the list item type
                if (!Map.class.isAssignableFrom(type)) {
                    Type listType = getValueAdapter().getGenericType(defaultPropertyName);
                    element = BeanAdapter.coerce(element, BeanAdapter.getListItemType(listType));
                }
            }

            list.add(element);
        }

        public void set(Object value) throws LoadException {
            if (this.value == null) {
                throw constructLoadException(&quot;Cannot set value on this element.&quot;);
            }

            // Apply value to this element's properties
            Class&lt;?&gt; type = this.value.getClass();
            DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
            if (defaultProperty == null) {
                throw constructLoadException(&quot;Element does not define a default property.&quot;);
            }

            getProperties().put(defaultProperty.value(), value);
        }

        public void updateValue(Object value) {
            this.value = value;
            valueAdapter = null;
        }

        public boolean isTyped() {
            return !(value instanceof Map&lt;?, ?&gt;);
        }

        public BeanAdapter getValueAdapter() {
            if (valueAdapter == null) {
                valueAdapter = new BeanAdapter(value);
            }

            return valueAdapter;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public Map&lt;String, Object&gt; getProperties() {
            return (isTyped()) ? getValueAdapter() : (Map&lt;String, Object&gt;)value;
        }

        public void processStartElement() throws IOException {
            for (int i = 0, n = xmlStreamReader.getAttributeCount(); i &lt; n; i++) {
                String prefix = xmlStreamReader.getAttributePrefix(i);
                String localName = xmlStreamReader.getAttributeLocalName(i);
                String value = xmlStreamReader.getAttributeValue(i);

                if (loadListener != null
                    &amp;&amp; prefix != null
                    &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
                    loadListener.readInternalAttribute(prefix + &quot;:&quot; + localName, value);
                }

                processAttribute(prefix, localName, value);
            }
        }

        public void processEndElement() throws IOException {
            // No-op
        }

        public void processCharacters() throws IOException {
            throw constructLoadException(&quot;Unexpected characters in input stream.&quot;);
        }

        public void processInstancePropertyAttributes() throws IOException {
            if (instancePropertyAttributes.size() &gt; 0) {
                for (Attribute attribute : instancePropertyAttributes) {
                    processPropertyAttribute(attribute);
                }
            }
        }

        public void processAttribute(String prefix, String localName, String value)
            throws IOException{
            if (prefix == null) {
                // Add the attribute to the appropriate list
                if (localName.startsWith(EVENT_HANDLER_PREFIX)) {
                    if (loadListener != null) {
                        loadListener.readEventHandlerAttribute(localName, value);
                    }

                    eventHandlerAttributes.add(new Attribute(localName, null, value));
                } else {
                    int i = localName.lastIndexOf('.');

                    if (i == -1) {
                        // The attribute represents an instance property
                        if (loadListener != null) {
                            loadListener.readPropertyAttribute(localName, null, value);
                        }

                        instancePropertyAttributes.add(new Attribute(localName, null, value));
                    } else {
                        // The attribute represents a static property
                        String name = localName.substring(i + 1);
                        Class&lt;?&gt; sourceType = getType(localName.substring(0, i));

                        if (sourceType != null) {
                            if (loadListener != null) {
                                loadListener.readPropertyAttribute(name, sourceType, value);
                            }

                            staticPropertyAttributes.add(new Attribute(name, sourceType, value));
                        } else if (staticLoad) {
                            if (loadListener != null) {
                                loadListener.readUnknownStaticPropertyAttribute(localName, value);
                            }
                        } else {
                            throw constructLoadException(localName + &quot; is not a valid attribute.&quot;);
                        }
                    }

                }
            } else {
                throw constructLoadException(prefix + &quot;:&quot; + localName
                    + &quot; is not a valid attribute.&quot;);
            }
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public void processPropertyAttribute(Attribute attribute) throws IOException {
            String value = attribute.value;
            if (isBindingExpression(value)) {
                // Resolve the expression
                Expression expression;

                if (attribute.sourceType != null) {
                    throw constructLoadException(&quot;Cannot bind to static property.&quot;);
                }

                if (!isTyped()) {
                    throw constructLoadException(&quot;Cannot bind to untyped object.&quot;);
                }

                // TODO We may want to identify binding properties in processAttribute()
                // and apply them after build() has been called
                if (this.value instanceof Builder) {
                    throw constructLoadException(&quot;Cannot bind to builder property.&quot;);
                }

                if (!isStaticLoad()) {
                    value = value.substring(BINDING_EXPRESSION_PREFIX.length(),
                            value.length() - 1);
                    expression = Expression.valueOf(value);

                    // Create the binding
                    BeanAdapter targetAdapter = new BeanAdapter(this.value);
                    ObservableValue&lt;Object&gt; propertyModel = targetAdapter.getPropertyModel(attribute.name);
                    Class&lt;?&gt; type = targetAdapter.getType(attribute.name);

                    if (propertyModel instanceof Property&lt;?&gt;) {
                        ((Property&lt;Object&gt;) propertyModel).bind(new ExpressionValue(namespace, expression, type));
                    }
                }
            } else if (isBidirectionalBindingExpression(value)) {
                throw constructLoadException(new UnsupportedOperationException(&quot;This feature is not currently enabled.&quot;));
            } else {
                processValue(attribute.sourceType, attribute.name, value);
            }
        }

        private boolean isBindingExpression(String aValue) {
            return aValue.startsWith(BINDING_EXPRESSION_PREFIX)
                   &amp;&amp; aValue.endsWith(BINDING_EXPRESSION_SUFFIX);
        }

        private boolean isBidirectionalBindingExpression(String aValue) {
            return aValue.startsWith(BI_DIRECTIONAL_BINDING_PREFIX);
        }

        private boolean processValue(Class sourceType, String propertyName, String aValue)
            throws LoadException {

            boolean processed = false;
                //process list or array first
                if (sourceType == null &amp;&amp; isTyped()) {
                    BeanAdapter valueAdapter = getValueAdapter();
                    Class&lt;?&gt; type = valueAdapter.getType(propertyName);

                    if (type == null) {
                        throw new PropertyNotFoundException(&quot;Property \&quot;&quot; + propertyName
                            + &quot;\&quot; does not exist&quot; + &quot; or is read-only.&quot;);
                    }

                    if (List.class.isAssignableFrom(type)
                        &amp;&amp; valueAdapter.isReadOnly(propertyName)) {
                        populateListFromString(valueAdapter, propertyName, aValue);
                        processed = true;
                    } else if (type.isArray()) {
                        applyProperty(propertyName, sourceType,
                                populateArrayFromString(type, aValue));
                        processed = true;
                    }
                }
                if (!processed) {
                    applyProperty(propertyName, sourceType, resolvePrefixedValue(aValue));
                    processed = true;
                }
                return processed;
        }

        /**
         * Resolves value prefixed with RELATIVE_PATH_PREFIX and RESOURCE_KEY_PREFIX.
         */
        private Object resolvePrefixedValue(String aValue) throws LoadException {
            if (aValue.startsWith(ESCAPE_PREFIX)) {
                aValue = aValue.substring(ESCAPE_PREFIX.length());

                if (aValue.length() == 0
                    || !(aValue.startsWith(ESCAPE_PREFIX)
                        || aValue.startsWith(RELATIVE_PATH_PREFIX)
                        || aValue.startsWith(RESOURCE_KEY_PREFIX)
                        || aValue.startsWith(EXPRESSION_PREFIX)
                        || aValue.startsWith(BI_DIRECTIONAL_BINDING_PREFIX))) {
                    throw constructLoadException(&quot;Invalid escape sequence.&quot;);
                }
                return aValue;
            } else if (aValue.startsWith(RELATIVE_PATH_PREFIX)) {
                aValue = aValue.substring(RELATIVE_PATH_PREFIX.length());
                if (aValue.length() == 0) {
                    throw constructLoadException(&quot;Missing relative path.&quot;);
                }
                if (aValue.startsWith(RELATIVE_PATH_PREFIX)) {
                    // The prefix was escaped
                    warnDeprecatedEscapeSequence(RELATIVE_PATH_PREFIX);
                    return aValue;
                } else {
                        if (aValue.charAt(0) == '/') {
                            // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
                            final URL res = getClassLoader().getResource(aValue.substring(1));
                            if (res == null) {
                                throw constructLoadException(&quot;Invalid resource: &quot; + aValue + &quot; not found on the classpath&quot;);
                            }
                            return res.toString();
                        } else {
                            try {
                                return new URL(FXMLLoader.this.location, aValue).toString();
                            } catch (MalformedURLException e) {
                                System.err.println(FXMLLoader.this.location + &quot;/&quot; + aValue);
                            }
                        }
                }
            } else if (aValue.startsWith(RESOURCE_KEY_PREFIX)) {
                aValue = aValue.substring(RESOURCE_KEY_PREFIX.length());
                if (aValue.length() == 0) {
                    throw constructLoadException(&quot;Missing resource key.&quot;);
                }
                if (aValue.startsWith(RESOURCE_KEY_PREFIX)) {
                    // The prefix was escaped
                    warnDeprecatedEscapeSequence(RESOURCE_KEY_PREFIX);
                    return aValue;
                } else {
                    // Resolve the resource value
                    if (resources == null) {
                        throw constructLoadException(&quot;No resources specified.&quot;);
                    }
                    if (!resources.containsKey(aValue)) {
                        throw constructLoadException(&quot;Resource \&quot;&quot; + aValue + &quot;\&quot; not found.&quot;);
                    }

                    return resources.getString(aValue);
                }
            } else if (aValue.startsWith(EXPRESSION_PREFIX)) {
                aValue = aValue.substring(EXPRESSION_PREFIX.length());
                if (aValue.length() == 0) {
                    throw constructLoadException(&quot;Missing expression.&quot;);
                }
                if (aValue.startsWith(EXPRESSION_PREFIX)) {
                    // The prefix was escaped
                    warnDeprecatedEscapeSequence(EXPRESSION_PREFIX);
                    return aValue;
                } else if (aValue.equals(NULL_KEYWORD)) {
                    // The attribute value is null
                    return null;
                }
                return Expression.get(namespace, KeyPath.parse(aValue));
            }
            return aValue;
        }

        /**
         * Creates an array of given type and populates it with values from
         * a string where tokens are separated by ARRAY_COMPONENT_DELIMITER.
         * If token is prefixed with RELATIVE_PATH_PREFIX a value added to
         * the array becomes relative to document location.
         */
        private Object populateArrayFromString(
                Class&lt;?&gt;type,
                String stringValue) throws LoadException {

            Object propertyValue = null;
            // Split the string and set the values as an array
            Class&lt;?&gt; componentType = type.getComponentType();

            if (stringValue.length() &gt; 0) {
                String[] values = stringValue.split(ARRAY_COMPONENT_DELIMITER);
                propertyValue = Array.newInstance(componentType, values.length);
                for (int i = 0; i &lt; values.length; i++) {
                    Array.set(propertyValue, i,
                            BeanAdapter.coerce(resolvePrefixedValue(values[i].trim()),
                            type.getComponentType()));
                }
            } else {
                propertyValue = Array.newInstance(componentType, 0);
            }
            return propertyValue;
        }

        /**
         * Populates list with values from a string where tokens are separated
         * by ARRAY_COMPONENT_DELIMITER. If token is prefixed with RELATIVE_PATH_PREFIX
         * a value added to the list becomes relative to document location.
         */
        private void populateListFromString(
                BeanAdapter valueAdapter,
                String listPropertyName,
                String stringValue) throws LoadException {
            // Split the string and add the values to the list
            List&lt;Object&gt; list = (List&lt;Object&gt;)valueAdapter.get(listPropertyName);
            Type listType = valueAdapter.getGenericType(listPropertyName);
            Type itemType = (Class&lt;?&gt;)BeanAdapter.getGenericListItemType(listType);

            if (itemType instanceof ParameterizedType) {
                itemType = ((ParameterizedType)itemType).getRawType();
            }

            if (stringValue.length() &gt; 0) {
                String[] values = stringValue.split(ARRAY_COMPONENT_DELIMITER);

                for (String aValue: values) {
                    aValue = aValue.trim();
                    list.add(
                            BeanAdapter.coerce(resolvePrefixedValue(aValue),
                                               (Class&lt;?&gt;)itemType));
                }
            }
        }

        public void warnDeprecatedEscapeSequence(String prefix) {
            System.err.println(prefix + prefix + &quot; is a deprecated escape sequence. &quot;
                + &quot;Please use \\&quot; + prefix + &quot; instead.&quot;);
        }

        public void applyProperty(String name, Class&lt;?&gt; sourceType, Object value) {
            if (sourceType == null) {
                getProperties().put(name, value);
            } else {
                BeanAdapter.put(this.value, sourceType, name, value);
            }
        }

        private Object getExpressionObject(String handlerValue) throws LoadException{
            if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                handlerValue = handlerValue.substring(EXPRESSION_PREFIX.length());

                if (handlerValue.length() == 0) {
                    throw constructLoadException(&quot;Missing expression reference.&quot;);
                }

                Object expression = Expression.get(namespace, KeyPath.parse(handlerValue));
                if (expression == null) {
                    throw constructLoadException(&quot;Unable to resolve expression : $&quot; + handlerValue);
                }
                return expression;
            }
            return null;
        }

        private &lt;T&gt; T getExpressionObjectOfType(String handlerValue, Class&lt;T&gt; type) throws LoadException{
            Object expression = getExpressionObject(handlerValue);
            if (expression != null) {
                if (type.isInstance(expression)) {
                    return (T) expression;
                }
                throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue +&quot;\&quot; expression.&quot;
                        + &quot;Does not point to a &quot; + type.getName());
            }
            return null;
        }

        private MethodHandler getControllerMethodHandle(String handlerName, SupportedType... types) throws LoadException {
            if (handlerName.startsWith(CONTROLLER_METHOD_PREFIX)) {
                handlerName = handlerName.substring(CONTROLLER_METHOD_PREFIX.length());

                if (!handlerName.startsWith(CONTROLLER_METHOD_PREFIX)) {
                    if (handlerName.length() == 0) {
                        throw constructLoadException(&quot;Missing controller method.&quot;);
                    }

                    if (controller == null) {
                        throw constructLoadException(&quot;No controller specified.&quot;);
                    }

                    for (SupportedType t : types) {
                        Method method = controllerAccessor
                                            .getControllerMethods()
                                            .get(t)
                                            .get(handlerName);
                        if (method != null) {
                            return new MethodHandler(controller, method, t);
                        }
                    }
                    Method method = controllerAccessor
                                        .getControllerMethods()
                                        .get(SupportedType.PARAMETERLESS)
                                        .get(handlerName);
                    if (method != null) {
                        return new MethodHandler(controller, method, SupportedType.PARAMETERLESS);
                    }

                    return null;

                }

            }
            return null;
        }

        public void processEventHandlerAttributes() throws LoadException {
            if (eventHandlerAttributes.size() &gt; 0 &amp;&amp; !staticLoad) {
                for (Attribute attribute : eventHandlerAttributes) {
                    String handlerName = attribute.value;
                    if (value instanceof ObservableList &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
                        processObservableListHandler(handlerName);
                    } else if (value instanceof ObservableMap &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
                        processObservableMapHandler(handlerName);
                    } else if (value instanceof ObservableSet &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
                        processObservableSetHandler(handlerName);
                    } else if (attribute.name.endsWith(CHANGE_EVENT_HANDLER_SUFFIX)) {
                        processPropertyHandler(attribute.name, handlerName);
                    } else {
                        EventHandler&lt;? extends Event&gt; eventHandler = null;
                        MethodHandler handler = getControllerMethodHandle(handlerName, SupportedType.EVENT);
                        if (handler != null) {
                            eventHandler = new ControllerMethodEventHandler&lt;&gt;(handler);
                        }

                        if (eventHandler == null) {
                            eventHandler = getExpressionObjectOfType(handlerName, EventHandler.class);
                        }

                        if (eventHandler == null) {
                            if (handlerName.length() == 0 || scriptEngine == null) {
                                throw constructLoadException(&quot;Error resolving &quot; + attribute.name + &quot;='&quot; + attribute.value
                                        + &quot;', either the event handler is not in the Namespace or there is an error in the script.&quot;);
                            }

                            eventHandler = new ScriptEventHandler(handlerName, scriptEngine);
                        }

                        // Add the handler
                        getValueAdapter().put(attribute.name, eventHandler);
                    }
                }
            }
        }

        private void processObservableListHandler(String handlerValue) throws LoadException {
            ObservableList list = (ObservableList)value;
            if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.LIST_CHANGE_LISTENER);
                if (handler != null) {
                    list.addListener(new ObservableListChangeAdapter(handler));
                } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                }
            } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                Object listener = getExpressionObject(handlerValue);
                   if (listener instanceof ListChangeListener) {
                    list.addListener((ListChangeListener) listener);
                } else if (listener instanceof InvalidationListener) {
                    list.addListener((InvalidationListener) listener);
                } else {
                    throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                            + &quot;Must be either ListChangeListener or InvalidationListener&quot;);
                }
            }
        }

        private void processObservableMapHandler(String handlerValue) throws LoadException {
            ObservableMap map = (ObservableMap)value;
            if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.MAP_CHANGE_LISTENER);
                if (handler != null) {
                    map.addListener(new ObservableMapChangeAdapter(handler));
                } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                }
            } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                Object listener = getExpressionObject(handlerValue);
                if (listener instanceof MapChangeListener) {
                    map.addListener((MapChangeListener) listener);
                } else if (listener instanceof InvalidationListener) {
                    map.addListener((InvalidationListener) listener);
                } else {
                    throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                            + &quot;Must be either MapChangeListener or InvalidationListener&quot;);
                }
            }
        }

        private void processObservableSetHandler(String handlerValue) throws LoadException {
            ObservableSet set = (ObservableSet)value;
            if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.SET_CHANGE_LISTENER);
                if (handler != null) {
                    set.addListener(new ObservableSetChangeAdapter(handler));
                } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                }
            } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                Object listener = getExpressionObject(handlerValue);
                if (listener instanceof SetChangeListener) {
                    set.addListener((SetChangeListener) listener);
<A NAME="14"></A>                } else if (listener instanceof InvalidationListener) {
                    set.addListener((InvalidationListener) listener);
                } else {
                    throw <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#14',2,'match31-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                            + &quot;Must be either SetChangeListener or InvalidationListener&quot;);
                }
            }
        }

        private void processPropertyHandler(String attributeName, String handlerValue) throws LoadException {</B></FONT>
            int i = EVENT_HANDLER_PREFIX.length();
            int j = attributeName.length() - CHANGE_EVENT_HANDLER_SUFFIX.length();

            if (i != j) {
                String key = Character.toLowerCase(attributeName.charAt(i))
                        + attributeName.substring(i + 1, j);

                ObservableValue&lt;Object&gt; propertyModel = getValueAdapter().getPropertyModel(key);
                if (propertyModel == null) {
                    throw constructLoadException(value.getClass().getName() + &quot; does not define&quot;
                            + &quot; a property model for \&quot;&quot; + key + &quot;\&quot;.&quot;);
                }

                if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
                    final MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.PROPERTY_CHANGE_LISTENER, SupportedType.EVENT);
                    if (handler != null) {
                        if (handler.type == SupportedType.EVENT) {
                            // Note: this part is solely for purpose of 2.2 backward compatibility where an Event object
                            // has been used instead of usual property change parameters
                            propertyModel.addListener(new ChangeListener&lt;Object&gt;() {
                                @Override
                                public void changed(ObservableValue&lt;?&gt; observable, Object oldValue, Object newValue) {
                                    handler.invoke(new Event(value, null, Event.ANY));
                                }
                            });
                        } else {
                            propertyModel.addListener(new PropertyChangeAdapter(handler));
                        }
                    } else {
                    throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
                    }
                } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
                    Object listener = getExpressionObject(handlerValue);
                    if (listener instanceof ChangeListener) {
                        propertyModel.addListener((ChangeListener) listener);
                    } else if (listener instanceof InvalidationListener) {
                        propertyModel.addListener((InvalidationListener) listener);
                    } else {
                        throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
                                + &quot;Must be either ChangeListener or InvalidationListener&quot;);
                    }
                }

            }
        }
    }

    // Element representing a value
    private abstract class ValueElement extends Element {
        public String fx_id = null;

        @Override
        public void processStartElement() throws IOException {
            super.processStartElement();

            updateValue(constructValue());

            if (value instanceof Builder&lt;?&gt;) {
                processInstancePropertyAttributes();
            } else {
                processValue();
            }
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void processEndElement() throws IOException {
            super.processEndElement();

            // Build the value, if necessary
            if (value instanceof Builder&lt;?&gt;) {
                Builder&lt;Object&gt; builder = (Builder&lt;Object&gt;)value;
                updateValue(builder.build());

                processValue();
            } else {
                processInstancePropertyAttributes();
            }

            processEventHandlerAttributes();

            // Process static property attributes
            if (staticPropertyAttributes.size() &gt; 0) {
                for (Attribute attribute : staticPropertyAttributes) {
                    processPropertyAttribute(attribute);
                }
            }

            // Process static property elements
            if (staticPropertyElements.size() &gt; 0) {
                for (PropertyElement element : staticPropertyElements) {
                    BeanAdapter.put(value, element.sourceType, element.name, element.value);
                }
            }

            if (parent != null) {
                if (parent.isCollection()) {
                    parent.add(value);
                } else {
                    parent.set(value);
                }
            }
        }

        private Object getListValue(Element parent, String listPropertyName, Object value) {
            // If possible, coerce the value to the list item type
            if (parent.isTyped()) {
                Type listType = parent.getValueAdapter().getGenericType(listPropertyName);

                if (listType != null) {
                    Type itemType = BeanAdapter.getGenericListItemType(listType);

                    if (itemType instanceof ParameterizedType) {
                        itemType = ((ParameterizedType)itemType).getRawType();
                    }

                    value = BeanAdapter.coerce(value, (Class&lt;?&gt;)itemType);
                }
            }

            return value;
        }

        private void processValue() throws LoadException {
            // If this is the root element, update the value
            if (parent == null) {
                root = value;

                // checking version of fx namespace - throw exception if not supported
                String fxNSURI = xmlStreamReader.getNamespaceContext().getNamespaceURI(&quot;fx&quot;);
                if (fxNSURI != null) {
                    String fxVersion = fxNSURI.substring(fxNSURI.lastIndexOf(&quot;/&quot;) + 1);
                    if (compareJFXVersions(FX_NAMESPACE_VERSION, fxVersion) &lt; 0) {
                        throw constructLoadException(&quot;Loading FXML document of version &quot; +
                                fxVersion + &quot; by JavaFX runtime supporting version &quot; + FX_NAMESPACE_VERSION);
                    }
                }

                // checking the version JavaFX API - print warning if not supported
                String defaultNSURI = xmlStreamReader.getNamespaceContext().getNamespaceURI(&quot;&quot;);
                if (defaultNSURI != null) {
                    String nsVersion = defaultNSURI.substring(defaultNSURI.lastIndexOf(&quot;/&quot;) + 1);
                    if (compareJFXVersions(JAVAFX_VERSION, nsVersion) &lt; 0) {
                        Logging.getJavaFXLogger().warning(&quot;Loading FXML document with JavaFX API of version &quot; +
                                nsVersion + &quot; by JavaFX runtime of version &quot; + JAVAFX_VERSION);
                    }
                }
            }

            // Add the value to the namespace
            if (fx_id != null) {
                namespace.put(fx_id, value);

                // If the value defines an ID property, set it
                IDProperty idProperty = value.getClass().getAnnotation(IDProperty.class);

                if (idProperty != null) {
                    Map&lt;String, Object&gt; properties = getProperties();
                    // set fx:id property value to Node.id only if Node.id was not
                    // already set when processing start element attributes
                    if (properties.get(idProperty.value()) == null) {
                        properties.put(idProperty.value(), fx_id);
                    }
                }

                // Set the controller field value
                injectFields(fx_id, value);
            }
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void processCharacters() throws LoadException {
            Class&lt;?&gt; type = value.getClass();
            DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);

            // If the default property is a read-only list, add the value to it;
            // otherwise, set the value as the default property
            if (defaultProperty != null) {
                String text = xmlStreamReader.getText();
                text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;);

                String defaultPropertyName = defaultProperty.value();
                BeanAdapter valueAdapter = getValueAdapter();

                if (valueAdapter.isReadOnly(defaultPropertyName)
                    &amp;&amp; List.class.isAssignableFrom(valueAdapter.getType(defaultPropertyName))) {
                    List&lt;Object&gt; list = (List&lt;Object&gt;)valueAdapter.get(defaultPropertyName);
                    list.add(getListValue(this, defaultPropertyName, text));
                } else {
                    valueAdapter.put(defaultPropertyName, text.trim());
                }
            } else {
                throw constructLoadException(type.getName() + &quot; does not have a default property.&quot;);
            }
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException{
            if (prefix != null
                &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
                if (localName.equals(FX_ID_ATTRIBUTE)) {
                    // Verify that ID is a valid identifier
                    if (value.equals(NULL_KEYWORD)) {
                        throw constructLoadException(&quot;Invalid identifier.&quot;);
                    }

                    for (int i = 0, n = value.length(); i &lt; n; i++) {
                        if (!Character.isJavaIdentifierPart(value.charAt(i))) {
                            throw constructLoadException(&quot;Invalid identifier.&quot;);
                        }
                    }

                    fx_id = value;

                } else if (localName.equals(FX_CONTROLLER_ATTRIBUTE)) {
                    if (current.parent != null) {
                        throw constructLoadException(FX_NAMESPACE_PREFIX + &quot;:&quot; + FX_CONTROLLER_ATTRIBUTE
                            + &quot; can only be applied to root element.&quot;);
                    }

                    if (controller != null) {
                        throw constructLoadException(&quot;Controller value already specified.&quot;);
                    }

                    if (!staticLoad) {
                        Class&lt;?&gt; type;
                        try {
                            type = getClassLoader().loadClass(value);
                        } catch (ClassNotFoundException exception) {
                            throw constructLoadException(exception);
                        }

                        try {
                            if (controllerFactory == null) {
                                ReflectUtil.checkPackageAccess(type);
                                setController(type.newInstance());
                            } else {
                                setController(controllerFactory.call(type));
                            }
                        } catch (InstantiationException exception) {
                            throw constructLoadException(exception);
                        } catch (IllegalAccessException exception) {
                            throw constructLoadException(exception);
                        }
                    }
                } else {
                    throw constructLoadException(&quot;Invalid attribute.&quot;);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        public abstract Object constructValue() throws IOException;
    }

    // Element representing a class instance
    private class InstanceDeclarationElement extends ValueElement {
        public Class&lt;?&gt; type;

        public String constant = null;
        public String factory = null;

        public InstanceDeclarationElement(Class&lt;?&gt; type) throws LoadException {
            this.type = type;
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix != null
                &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
                if (localName.equals(FX_VALUE_ATTRIBUTE)) {
                    this.value = value;
                } else if (localName.equals(FX_CONSTANT_ATTRIBUTE)) {
                    constant = value;
                } else if (localName.equals(FX_FACTORY_ATTRIBUTE)) {
                    factory = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws IOException {
            Object value;
            if (this.value != null) {
                value = BeanAdapter.coerce(this.value, type);
            } else if (constant != null) {
                value = BeanAdapter.getConstantValue(type, constant);
            } else if (factory != null) {
                Method factoryMethod;
                try {
                    factoryMethod = MethodUtil.getMethod(type, factory, new Class[] {});
                } catch (NoSuchMethodException exception) {
                    throw constructLoadException(exception);
                }

                try {
                    value = MethodHelper.invoke(factoryMethod, null, new Object [] {});
                } catch (IllegalAccessException exception) {
                    throw constructLoadException(exception);
                } catch (InvocationTargetException exception) {
                    throw constructLoadException(exception);
                }
            } else {
                value = (builderFactory == null) ? null : builderFactory.getBuilder(type);

                if (value == null) {
                    value = DEFAULT_BUILDER_FACTORY.getBuilder(type);
                }

                if (value == null) {
                    try {
                        ReflectUtil.checkPackageAccess(type);
                        value = type.newInstance();
                    } catch (InstantiationException exception) {
                        throw constructLoadException(exception);
                    } catch (IllegalAccessException exception) {
                        throw constructLoadException(exception);
                    }
                }
            }

            return value;
        }
    }

    // Element representing an unknown type
    private class UnknownTypeElement extends ValueElement {
        // Map type representing an unknown value
        @DefaultProperty(&quot;items&quot;)
        public class UnknownValueMap extends AbstractMap&lt;String, Object&gt; {
            private ArrayList&lt;?&gt; items = new ArrayList&lt;Object&gt;();
            private HashMap&lt;String, Object&gt; values = new HashMap&lt;String, Object&gt;();

            @Override
            public Object get(Object key) {
                if (key == null) {
                    throw new NullPointerException();
                }

                return (key.equals(getClass().getAnnotation(DefaultProperty.class).value())) ?
                    items : values.get(key);
            }

            @Override
            public Object put(String key, Object value) {
                if (key == null) {
                    throw new NullPointerException();
                }

                if (key.equals(getClass().getAnnotation(DefaultProperty.class).value())) {
                    throw new IllegalArgumentException();
                }

                return values.put(key, value);
            }

            @Override
            public Set&lt;Entry&lt;String, Object&gt;&gt; entrySet() {
                return Collections.emptySet();
            }
        }

        @Override
        public void processEndElement() throws IOException {
            // No-op
        }

        @Override
        public Object constructValue() throws LoadException {
            return new UnknownValueMap();
        }
    }

    // Element representing an include
    private class IncludeElement extends ValueElement {
        public String source = null;
        public ResourceBundle resources = FXMLLoader.this.resources;
        public Charset charset = FXMLLoader.this.charset;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(INCLUDE_SOURCE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    source = value;
                } else if (localName.equals(INCLUDE_RESOURCES_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    resources = ResourceBundle.getBundle(value, Locale.getDefault(),
                            FXMLLoader.this.resources.getClass().getClassLoader());
                } else if (localName.equals(INCLUDE_CHARSET_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    charset = Charset.forName(value);
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws IOException {
            if (source == null) {
                throw constructLoadException(INCLUDE_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
            }

            URL location;
            final ClassLoader cl = getClassLoader();
            if (source.charAt(0) == '/') {
            // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
                location = cl.getResource(source.substring(1));
                if (location == null) {
                    throw constructLoadException(&quot;Cannot resolve path: &quot; + source);
                }
            } else {
                if (FXMLLoader.this.location == null) {
                    throw constructLoadException(&quot;Base location is undefined.&quot;);
                }

                location = new URL(FXMLLoader.this.location, source);
            }

            FXMLLoader fxmlLoader = new FXMLLoader(location, resources,
                builderFactory, controllerFactory, charset,
                loaders);
            fxmlLoader.parentLoader = FXMLLoader.this;

            if (isCyclic(FXMLLoader.this, fxmlLoader)) {
                throw new IOException(
                        String.format(
                        &quot;Including \&quot;%s\&quot; in \&quot;%s\&quot; created cyclic reference.&quot;,
                        fxmlLoader.location.toExternalForm(),
                        FXMLLoader.this.location.toExternalForm()));
            }
            fxmlLoader.setClassLoader(cl);
            fxmlLoader.setStaticLoad(staticLoad);

            Object value = fxmlLoader.loadImpl(callerClass);

            if (fx_id != null) {
                String id = this.fx_id + CONTROLLER_SUFFIX;
                Object controller = fxmlLoader.getController();

                namespace.put(id, controller);
                injectFields(id, controller);
            }

            return value;
        }
    }

    private void injectFields(String fieldName, Object value) throws LoadException {
        if (controller != null &amp;&amp; fieldName != null) {
            List&lt;Field&gt; fields = controllerAccessor.getControllerFields().get(fieldName);
            if (fields != null) {
                try {
                    for (Field f : fields) {
                        f.set(controller, value);
                    }
                } catch (IllegalAccessException exception) {
                    throw constructLoadException(exception);
                }
            }
        }
    }

    // Element representing a reference
    private class ReferenceElement extends ValueElement {
        public String source = null;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(REFERENCE_SOURCE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    source = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws LoadException {
            if (source == null) {
                throw constructLoadException(REFERENCE_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
            }

            KeyPath path = KeyPath.parse(source);
            if (!Expression.isDefined(namespace, path)) {
                throw constructLoadException(&quot;Value \&quot;&quot; + source + &quot;\&quot; does not exist.&quot;);
            }

            return Expression.get(namespace, path);
        }
    }

    // Element representing a copy
    private class CopyElement extends ValueElement {
        public String source = null;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(COPY_SOURCE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    source = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws LoadException {
            if (source == null) {
                throw constructLoadException(COPY_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
            }

            KeyPath path = KeyPath.parse(source);
            if (!Expression.isDefined(namespace, path)) {
                throw constructLoadException(&quot;Value \&quot;&quot; + source + &quot;\&quot; does not exist.&quot;);
            }

            Object sourceValue = Expression.get(namespace, path);
            Class&lt;?&gt; sourceValueType = sourceValue.getClass();

            Constructor&lt;?&gt; constructor = null;
            try {
                constructor = ConstructorUtil.getConstructor(sourceValueType, new Class[] { sourceValueType });
            } catch (NoSuchMethodException exception) {
                // No-op
            }

            Object value;
            if (constructor != null) {
                try {
                    ReflectUtil.checkPackageAccess(sourceValueType);
                    value = constructor.newInstance(sourceValue);
                } catch (InstantiationException exception) {
                    throw constructLoadException(exception);
                } catch (IllegalAccessException exception) {
                    throw constructLoadException(exception);
                } catch (InvocationTargetException exception) {
                    throw constructLoadException(exception);
                }
            } else {
                throw constructLoadException(&quot;Can't copy value &quot; + sourceValue + &quot;.&quot;);
            }

            return value;
        }
    }

    // Element representing a predefined root value
    private class RootElement extends ValueElement {
        public String type = null;

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null) {
                if (localName.equals(ROOT_TYPE_ATTRIBUTE)) {
                    if (loadListener != null) {
                        loadListener.readInternalAttribute(localName, value);
                    }

                    type = value;
                } else {
                    super.processAttribute(prefix, localName, value);
                }
            } else {
                super.processAttribute(prefix, localName, value);
            }
        }

        @Override
        public Object constructValue() throws LoadException {
            if (type == null) {
                throw constructLoadException(ROOT_TYPE_ATTRIBUTE + &quot; is required.&quot;);
            }

            Class&lt;?&gt; type = getType(this.type);

            if (type == null) {
                throw constructLoadException(this.type + &quot; is not a valid type.&quot;);
            }

            Object value;
            if (root == null) {
                if (staticLoad) {
                    value = (builderFactory == null) ? null : builderFactory.getBuilder(type);

                    if (value == null) {
                        value = DEFAULT_BUILDER_FACTORY.getBuilder(type);
                    }

                    if (value == null) {
                        try {
                            ReflectUtil.checkPackageAccess(type);
                            value = type.newInstance();
                        } catch (InstantiationException exception) {
                            throw constructLoadException(exception);
                        } catch (IllegalAccessException exception) {
                            throw constructLoadException(exception);
                        }
                    }
                    root = value;
                } else {
                    throw constructLoadException(&quot;Root hasn't been set. Use method setRoot() before load.&quot;);
                }
            } else {
                if (!type.isAssignableFrom(root.getClass())) {
                    throw constructLoadException(&quot;Root is not an instance of &quot;
                        + type.getName() + &quot;.&quot;);
                }

                value = root;
            }

            return value;
        }
    }

    // Element representing a property
    private class PropertyElement extends Element {
        public final String name;
        public final Class&lt;?&gt; sourceType;
        public final boolean readOnly;

        public PropertyElement(String name, Class&lt;?&gt; sourceType) throws LoadException {
            if (parent == null) {
                throw constructLoadException(&quot;Invalid root element.&quot;);
            }

            if (parent.value == null) {
                throw constructLoadException(&quot;Parent element does not support property elements.&quot;);
            }

            this.name = name;
            this.sourceType = sourceType;

            if (sourceType == null) {
                // The element represents an instance property
                if (name.startsWith(EVENT_HANDLER_PREFIX)) {
                    throw constructLoadException(&quot;\&quot;&quot; + name + &quot;\&quot; is not a valid element name.&quot;);
                }

                Map&lt;String, Object&gt; parentProperties = parent.getProperties();

                if (parent.isTyped()) {
                    readOnly = parent.getValueAdapter().isReadOnly(name);
                } else {
                // If the map already defines a value for the property, assume
                    // that it is read-only
                    readOnly = parentProperties.containsKey(name);
                }

                if (readOnly) {
                    Object value = parentProperties.get(name);
                    if (value == null) {
                        throw constructLoadException(&quot;Invalid property.&quot;);
                    }

                    updateValue(value);
                }
            } else {
                // The element represents a static property
                readOnly = false;
            }
        }

        @Override
        public boolean isCollection() {
            return (readOnly) ? super.isCollection() : false;
        }

        @Override
        public void add(Object element) throws LoadException {
            // Coerce the element to the list item type
            if (parent.isTyped()) {
                Type listType = parent.getValueAdapter().getGenericType(name);
                element = BeanAdapter.coerce(element, BeanAdapter.getListItemType(listType));
            }

            // Add the item to the list
            super.add(element);
        }

        @Override
        public void set(Object value) throws LoadException {
            // Update the value
            updateValue(value);

            if (sourceType == null) {
                // Apply value to parent element's properties
                parent.getProperties().put(name, value);
            } else {
                if (parent.value instanceof Builder) {
                    // Defer evaluation of the property
                    parent.staticPropertyElements.add(this);
                } else {
                    // Apply the static property value
                    BeanAdapter.put(parent.value, sourceType, name, value);
                }
            }
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (!readOnly) {
                throw constructLoadException(&quot;Attributes are not supported for writable property elements.&quot;);
            }

            super.processAttribute(prefix, localName, value);
        }

        @Override
        public void processEndElement() throws IOException {
            super.processEndElement();

            if (readOnly) {
                processInstancePropertyAttributes();
                processEventHandlerAttributes();
            }
        }

        @Override
        public void processCharacters() throws IOException {
            String text = xmlStreamReader.getText();
            text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;).trim();

            if (readOnly) {
                if (isCollection()) {
                    add(text);
                } else {
                    super.processCharacters();
                }
            } else {
                set(text);
            }
        }
    }

    // Element representing an unknown static property
    private class UnknownStaticPropertyElement extends Element {
        public UnknownStaticPropertyElement() throws LoadException {
            if (parent == null) {
                throw constructLoadException(&quot;Invalid root element.&quot;);
            }

            if (parent.value == null) {
                throw constructLoadException(&quot;Parent element does not support property elements.&quot;);
            }
        }

        @Override
        public boolean isCollection() {
            return false;
        }

        @Override
        public void set(Object value) {
            updateValue(value);
        }

        @Override
        public void processCharacters() throws IOException {
            String text = xmlStreamReader.getText();
            text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;);

            updateValue(text.trim());
        }
    }

    // Element representing a script block
    private class ScriptElement extends Element {
        public String source = null;
        public Charset charset = FXMLLoader.this.charset;

        @Override
        public boolean isCollection() {
            return false;
        }

        @Override
        public void processStartElement() throws IOException {
            super.processStartElement();

            if (source != null &amp;&amp; !staticLoad) {
                int i = source.lastIndexOf(&quot;.&quot;);
                if (i == -1) {
                    throw constructLoadException(&quot;Cannot determine type of script \&quot;&quot;
                        + source + &quot;\&quot;.&quot;);
                }

                String extension = source.substring(i + 1);
                ScriptEngine engine;
                final ClassLoader cl = getClassLoader();
                if (scriptEngine != null &amp;&amp; scriptEngine.getFactory().getExtensions().contains(extension)) {
                    // If we have a page language and it's engine supports the extension, use the same engine
                    engine = scriptEngine;
                } else {
                    ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();
                    try {
                        Thread.currentThread().setContextClassLoader(cl);
                        ScriptEngineManager scriptEngineManager = getScriptEngineManager();
                        engine = scriptEngineManager.getEngineByExtension(extension);
                    } finally {
                        Thread.currentThread().setContextClassLoader(oldLoader);
                    }
                }

                if (engine == null) {
                    throw constructLoadException(&quot;Unable to locate scripting engine for&quot;
                        + &quot; extension &quot; + extension + &quot;.&quot;);
                }

                try {
                    URL location;
                    if (source.charAt(0) == '/') {
                        // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
                        location = cl.getResource(source.substring(1));
                    } else {
                        if (FXMLLoader.this.location == null) {
                            throw constructLoadException(&quot;Base location is undefined.&quot;);
                        }

                        location = new URL(FXMLLoader.this.location, source);
                    }

                    InputStreamReader scriptReader = null;
                    try {
                        scriptReader = new InputStreamReader(location.openStream(), charset);
                        engine.eval(scriptReader);
                    } catch(ScriptException exception) {
                        exception.printStackTrace();
                    } finally {
                        if (scriptReader != null) {
                            scriptReader.close();
                        }
                    }
                } catch (IOException exception) {
                    throw constructLoadException(exception);
                }
            }
        }

        @Override
        public void processEndElement() throws IOException {
            super.processEndElement();

            if (value != null &amp;&amp; !staticLoad) {
                // Evaluate the script
                try {
                    scriptEngine.eval((String)value);
                } catch (ScriptException exception) {
                    System.err.println(exception.getMessage());
                }
            }
        }

        @Override
        public void processCharacters() throws LoadException {
            if (source != null) {
                throw constructLoadException(&quot;Script source already specified.&quot;);
            }

            if (scriptEngine == null &amp;&amp; !staticLoad) {
                throw constructLoadException(&quot;Page language not specified.&quot;);
            }

            updateValue(xmlStreamReader.getText());
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws IOException {
            if (prefix == null
                &amp;&amp; localName.equals(SCRIPT_SOURCE_ATTRIBUTE)) {
                if (loadListener != null) {
                    loadListener.readInternalAttribute(localName, value);
                }

                source = value;
            } else if (localName.equals(SCRIPT_CHARSET_ATTRIBUTE)) {
                if (loadListener != null) {
                    loadListener.readInternalAttribute(localName, value);
                }

                charset = Charset.forName(value);
            } else {
                throw constructLoadException(prefix == null ? localName : prefix + &quot;:&quot; + localName
                    + &quot; is not a valid attribute.&quot;);
            }
        }
    }

    // Element representing a define block
    private class DefineElement extends Element {
        @Override
        public boolean isCollection() {
            return true;
        }

        @Override
        public void add(Object element) {
            // No-op
        }

        @Override
        public void processAttribute(String prefix, String localName, String value)
            throws LoadException{
            throw constructLoadException(&quot;Element does not support attributes.&quot;);
        }
    }

    // Class representing an attribute of an element
    private static class Attribute {
        public final String name;
        public final Class&lt;?&gt; sourceType;
        public final String value;

        public Attribute(String name, Class&lt;?&gt; sourceType, String value) {
            this.name = name;
            this.sourceType = sourceType;
            this.value = value;
        }
    }

    // Event handler that delegates to a method defined by the controller object
    private static class ControllerMethodEventHandler&lt;T extends Event&gt; implements EventHandler&lt;T&gt; {
        private final MethodHandler handler;

        public ControllerMethodEventHandler(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void handle(T event) {
            handler.invoke(event);
        }
    }

    // Event handler implemented in script code
    private static class ScriptEventHandler implements EventHandler&lt;Event&gt; {
        public final String script;
        public final ScriptEngine scriptEngine;

        public ScriptEventHandler(String script, ScriptEngine scriptEngine) {
            this.script = script;
            this.scriptEngine = scriptEngine;
        }

        @Override
        public void handle(Event event) {
            // Don't pollute the page namespace with values defined in the script
            Bindings engineBindings = scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);
            Bindings localBindings = scriptEngine.createBindings();
            localBindings.put(EVENT_KEY, event);
            localBindings.putAll(engineBindings);
            scriptEngine.setBindings(localBindings, ScriptContext.ENGINE_SCOPE);

            // Execute the script
            try {
                scriptEngine.eval(script);
            } catch (ScriptException exception){
                throw new RuntimeException(exception);
            }

            // Restore the original bindings
            scriptEngine.setBindings(engineBindings, ScriptContext.ENGINE_SCOPE);
        }
    }

    // Observable list change listener
    private static class ObservableListChangeAdapter implements ListChangeListener {
        private final MethodHandler handler;

        public ObservableListChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void onChanged(Change change) {
            if (handler != null) {
                handler.invoke(change);
            }
        }
    }

    // Observable map change listener
    private static class ObservableMapChangeAdapter implements MapChangeListener {
        public final MethodHandler handler;

        public ObservableMapChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void onChanged(Change change) {
            if (handler != null) {
                handler.invoke(change);
            }
        }
    }

    // Observable set change listener
    private static class ObservableSetChangeAdapter implements SetChangeListener {
        public final MethodHandler handler;

        public ObservableSetChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void onChanged(Change change) {
            if (handler != null) {
                handler.invoke(change);
            }
        }
    }

    // Property model change listener
    private static class PropertyChangeAdapter implements ChangeListener&lt;Object&gt; {
        public final MethodHandler handler;

        public PropertyChangeAdapter(MethodHandler handler) {
            this.handler = handler;
        }

        @Override
        public void changed(ObservableValue&lt;? extends Object&gt; observable, Object oldValue, Object newValue) {
            handler.invoke(observable, oldValue, newValue);
        }
    }

    private static class MethodHandler {
        private final Object controller;
        private final Method method;
        private final SupportedType type;

        private MethodHandler(Object controller, Method method, SupportedType type) {
            this.method = method;
            this.controller = controller;
            this.type = type;
        }

        public void invoke(Object... params) {
            try {
                if (type != SupportedType.PARAMETERLESS) {
                    MethodHelper.invoke(method, controller, params);
                } else {
                    MethodHelper.invoke(method, controller, new Object[] {});
                }
            } catch (InvocationTargetException exception) {
                throw new RuntimeException(exception);
            } catch (IllegalAccessException exception) {
                throw new RuntimeException(exception);
            }
        }
    }

    private URL location;
    private ResourceBundle resources;

    private ObservableMap&lt;String, Object&gt; namespace = FXCollections.observableHashMap();

    private Object root = null;
    private Object controller = null;

    private BuilderFactory builderFactory;
    private Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory;
    private Charset charset;

    private final LinkedList&lt;FXMLLoader&gt; loaders;

    private ClassLoader classLoader = null;
    private boolean staticLoad = false;
    private LoadListener loadListener = null;

    private FXMLLoader parentLoader;

    private XMLStreamReader xmlStreamReader = null;
    private Element current = null;

    private ScriptEngine scriptEngine = null;

    private List&lt;String&gt; packages = new LinkedList&lt;String&gt;();
    private Map&lt;String, Class&lt;?&gt;&gt; classes = new HashMap&lt;String, Class&lt;?&gt;&gt;();

    private ScriptEngineManager scriptEngineManager = null;

    private static ClassLoader defaultClassLoader = null;

    private static final Pattern extraneousWhitespacePattern = Pattern.compile(&quot;\\s+&quot;);

    private static BuilderFactory DEFAULT_BUILDER_FACTORY = new JavaFXBuilderFactory();

    /**
     * The character set used when character set is not explicitly specified.
     */
    public static final String DEFAULT_CHARSET_NAME = &quot;UTF-8&quot;;

    /**
     * The tag name of language processing instruction.
     */
    public static final String LANGUAGE_PROCESSING_INSTRUCTION = &quot;language&quot;;
    /**
     * The tag name of import processing instruction.
     */
    public static final String IMPORT_PROCESSING_INSTRUCTION = &quot;import&quot;;

    /**
     * Prefix of 'fx' namespace.
     */
    public static final String FX_NAMESPACE_PREFIX = &quot;fx&quot;;
    /**
     * The name of fx:controller attribute of a root.
     */
    public static final String FX_CONTROLLER_ATTRIBUTE = &quot;controller&quot;;
    /**
     * The name of fx:id attribute.
     */
    public static final String FX_ID_ATTRIBUTE = &quot;id&quot;;
    /**
     * The name of fx:value attribute.
     */
    public static final String FX_VALUE_ATTRIBUTE = &quot;value&quot;;
    /**
     * The tag name of 'fx:constant'.
     * @since JavaFX 2.2
     */
    public static final String FX_CONSTANT_ATTRIBUTE = &quot;constant&quot;;
    /**
     * The name of 'fx:factory' attribute.
     */
    public static final String FX_FACTORY_ATTRIBUTE = &quot;factory&quot;;

    /**
     * The tag name of {@literal &lt;fx:include&gt;}.
     */
    public static final String INCLUDE_TAG = &quot;include&quot;;
    /**
     * The {@literal &lt;fx:include&gt;} 'source' attribute.
     */
    public static final String INCLUDE_SOURCE_ATTRIBUTE = &quot;source&quot;;
    /**
     * The {@literal &lt;fx:include&gt;} 'resources' attribute.
     */
    public static final String INCLUDE_RESOURCES_ATTRIBUTE = &quot;resources&quot;;
    /**
     * The {@literal &lt;fx:include&gt;} 'charset' attribute.
     */
    public static final String INCLUDE_CHARSET_ATTRIBUTE = &quot;charset&quot;;

    /**
     * The tag name of {@literal &lt;fx:script&gt;}.
     */
    public static final String SCRIPT_TAG = &quot;script&quot;;
    /**
     * The {@literal &lt;fx:script&gt;} 'source' attribute.
     */
    public static final String SCRIPT_SOURCE_ATTRIBUTE = &quot;source&quot;;
    /**
     * The {@literal &lt;fx:script&gt;} 'charset' attribute.
     */
    public static final String SCRIPT_CHARSET_ATTRIBUTE = &quot;charset&quot;;

    /**
     * The tag name of {@literal &lt;fx:define&gt;}.
     */
    public static final String DEFINE_TAG = &quot;define&quot;;

    /**
     * The tag name of {@literal &lt;fx:reference&gt;}.
     */
    public static final String REFERENCE_TAG = &quot;reference&quot;;
    /**
     * The {@literal &lt;fx:reference&gt;} 'source' attribute.
     */
    public static final String REFERENCE_SOURCE_ATTRIBUTE = &quot;source&quot;;

    /**
     * The tag name of {@literal &lt;fx:root&gt;}.
     * @since JavaFX 2.2
     */
    public static final String ROOT_TAG = &quot;root&quot;;
    /**
     * The {@literal &lt;fx:root&gt;} 'type' attribute.
     * @since JavaFX 2.2
     */
    public static final String ROOT_TYPE_ATTRIBUTE = &quot;type&quot;;

    /**
     * The tag name of {@literal &lt;fx:copy&gt;}.
     */
    public static final String COPY_TAG = &quot;copy&quot;;
    /**
     * The {@literal &lt;fx:copy&gt;} 'source' attribute.
     */
    public static final String COPY_SOURCE_ATTRIBUTE = &quot;source&quot;;

    /**
     * The prefix of event handler attributes.
     */
    public static final String EVENT_HANDLER_PREFIX = &quot;on&quot;;
    /**
     * The name of the Event object in event handler scripts.
     */
    public static final String EVENT_KEY = &quot;event&quot;;
    /**
     * Suffix for property change/invalidation handlers.
     */
    public static final String CHANGE_EVENT_HANDLER_SUFFIX = &quot;Change&quot;;
    private static final String COLLECTION_HANDLER_NAME = EVENT_HANDLER_PREFIX + CHANGE_EVENT_HANDLER_SUFFIX;

    /**
     * Value that represents 'null'.
     */
    public static final String NULL_KEYWORD = &quot;null&quot;;

    /**
     * Escape prefix for escaping special characters inside attribute values.
     * Serves as an escape for {@link #ESCAPE_PREFIX}, {@link #RELATIVE_PATH_PREFIX},
     * {@link #RESOURCE_KEY_PREFIX}, {@link #EXPRESSION_PREFIX},
     * {@link #BI_DIRECTIONAL_BINDING_PREFIX}
     * @since JavaFX 2.1
     */
    public static final String ESCAPE_PREFIX = &quot;\\&quot;;
    /**
     * Prefix for relative location resolution.
     */
    public static final String RELATIVE_PATH_PREFIX = &quot;@&quot;;
    /**
     * Prefix for resource resolution.
     */
    public static final String RESOURCE_KEY_PREFIX = &quot;%&quot;;
    /**
     * Prefix for (variable) expression resolution.
     */
    public static final String EXPRESSION_PREFIX = &quot;$&quot;;
    /**
     * Prefix for binding expression resolution.
     */
    public static final String BINDING_EXPRESSION_PREFIX = &quot;${&quot;;
    /**
     * Suffix for binding expression resolution.
     */
    public static final String BINDING_EXPRESSION_SUFFIX = &quot;}&quot;;

    /**
     * Prefix for bidirectional-binding expression resolution.
     * @since JavaFX 2.1
     */
    public static final String BI_DIRECTIONAL_BINDING_PREFIX = &quot;#{&quot;;
    /**
     * Suffix for bidirectional-binding expression resolution.
     * @since JavaFX 2.1
     */
    public static final String BI_DIRECTIONAL_BINDING_SUFFIX = &quot;}&quot;;

    /**
     * Delimiter for arrays as values.
     * @since JavaFX 2.1
     */
    public static final String ARRAY_COMPONENT_DELIMITER = &quot;,&quot;;

    /**
     * A key for location URL in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.2
     */
    public static final String LOCATION_KEY = &quot;location&quot;;
    /**
     * A key for ResourceBundle in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.2
     */
    public static final String RESOURCES_KEY = &quot;resources&quot;;

    /**
     * Prefix for controller method resolution.
     */
    public static final String CONTROLLER_METHOD_PREFIX = &quot;#&quot;;
    /**
     * A key for controller in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.1
     */
    public static final String CONTROLLER_KEYWORD = &quot;controller&quot;;
    /**
     * A suffix for controllers of included fxml files.
     * The full key is stored in namespace map.
     * @see #getNamespace()
     * @since JavaFX 2.2
     */
    public static final String CONTROLLER_SUFFIX = &quot;Controller&quot;;

    /**
     * The name of initialize method.
     * @since JavaFX 2.2
     */
    public static final String INITIALIZE_METHOD_NAME = &quot;initialize&quot;;

    /**
     * Contains the current javafx version.
     * @since JavaFX 8.0
     */
    public static final String JAVAFX_VERSION;

    /**
     * Contains the current fx namepsace version.
     * @since JavaFX 8.0
     */
    public static final String FX_NAMESPACE_VERSION = &quot;1&quot;;

    static {
        JAVAFX_VERSION = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
            @Override
            public String run() {
                return System.getProperty(&quot;javafx.version&quot;);
            }
        });

        FXMLLoaderHelper.setFXMLLoaderAccessor(new FXMLLoaderHelper.FXMLLoaderAccessor() {
            @Override
            public void setStaticLoad(FXMLLoader fxmlLoader, boolean staticLoad) {
                fxmlLoader.setStaticLoad(staticLoad);
            }
        });
    }

    /**
     * Creates a new FXMLLoader instance.
     */
    public FXMLLoader() {
        this((URL)null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location) {
        this(location, null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources) {
        this(location, resources, null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory) {
        this(location, resources, builderFactory, null);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @param controllerFactory the controller factory used by this loader
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory) {
        this(location, resources, builderFactory, controllerFactory, Charset.forName(DEFAULT_CHARSET_NAME));
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param charset the character set used by this loader
     */
    public FXMLLoader(Charset charset) {
        this(null, null, null, null, charset);
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @param controllerFactory the controller factory used by this loader
     * @param charset the character set used by this loader
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory, Charset charset) {
        this(location, resources, builderFactory, controllerFactory, charset,
            new LinkedList&lt;FXMLLoader&gt;());
    }

    /**
     * Creates a new FXMLLoader instance.
     *
     * @param location the location used to resolve relative path attribute values
     * @param resources resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used by this loader
     * @param controllerFactory the controller factory used by this loader
     * @param charset the character set used by this loader
     * @param loaders list of loaders
     * @since JavaFX 2.1
     */
    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
        Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory, Charset charset,
        LinkedList&lt;FXMLLoader&gt; loaders) {
        setLocation(location);
        setResources(resources);
        setBuilderFactory(builderFactory);
        setControllerFactory(controllerFactory);
        setCharset(charset);

        this.loaders = new LinkedList(loaders);
    }

    /**
     * Returns the location used to resolve relative path attribute values.
     * @return the location used to resolve relative path attribute values
     */
    public URL getLocation() {
        return location;
    }

    /**
     * Sets the location used to resolve relative path attribute values.
     *
     * @param location the location
     */
    public void setLocation(URL location) {
        this.location = location;
    }

    /**
     * Returns the resources used to resolve resource key attribute values.
     * @return the resources used to resolve resource key attribute values
     */
    public ResourceBundle getResources() {
        return resources;
    }

    /**
     * Sets the resources used to resolve resource key attribute values.
     *
     * @param resources the resources
     */
    public void setResources(ResourceBundle resources) {
        this.resources = resources;
    }

    /**
     * Returns the namespace used by this loader.
     * @return the namespace
     */
    public ObservableMap&lt;String, Object&gt; getNamespace() {
        return namespace;
    }

    /**
     * Returns the root of the object hierarchy.
     * @param &lt;T&gt; the type of the root object
     * @return the root of the object hierarchy
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T getRoot() {
        return (T)root;
    }

    /**
     * Sets the root of the object hierarchy. The value passed to this method
     * is used as the value of the {@code &lt;fx:root&gt;} tag. This method
     * must be called prior to loading the document when using
     * {@code &lt;fx:root&gt;}.
     *
     * @param root the root of the object hierarchy
     *
     * @since JavaFX 2.2
     */
    public void setRoot(Object root) {
        this.root = root;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof FXMLLoader) {
            FXMLLoader loader = (FXMLLoader)obj;
            if (location == null || loader.location == null) {
                return loader.location == location;
            }
            return location.toExternalForm().equals(
                    loader.location.toExternalForm());
        }
        return false;
    }

    private boolean isCyclic(
                            FXMLLoader currentLoader,
                            FXMLLoader node) {
        if (currentLoader == null) {
            return false;
        }
        if (currentLoader.equals(node)) {
            return true;
        }
        return isCyclic(currentLoader.parentLoader, node);
    }

    /**
     * Returns the controller associated with the root object.
     * @param &lt;T&gt; the type of the controller
     * @return the controller associated with the root object
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T getController() {
        return (T)controller;
    }

    /**
     * Sets the controller associated with the root object. The value passed to
     * this method is used as the value of the {@code fx:controller} attribute.
     * This method must be called prior to loading the document when using
     * controller event handlers when an {@code fx:controller} attribute is not
     * specified in the document.
     *
     * @param controller the controller to associate with the root object
     *
     * @since JavaFX 2.2
     */
    public void setController(Object controller) {
        this.controller = controller;

        if (controller == null) {
            namespace.remove(CONTROLLER_KEYWORD);
        } else {
            namespace.put(CONTROLLER_KEYWORD, controller);
        }

        controllerAccessor.setController(controller);
    }

    /**
     * Returns the builder factory used by this loader.
     * @return the builder factory
     */
    public BuilderFactory getBuilderFactory() {
        return builderFactory;
    }

    /**
     * Sets the builder factory used by this loader.
     *
     * @param builderFactory the builder factory
     */
    public void setBuilderFactory(BuilderFactory builderFactory) {
        this.builderFactory = builderFactory;
    }

    /**
     * Returns the controller factory used by this loader.
     * @return the controller factory
     * @since JavaFX 2.1
     */
    public Callback&lt;Class&lt;?&gt;, Object&gt; getControllerFactory() {
        return controllerFactory;
    }

    /**
     * Sets the controller factory used by this loader.
     *
     * @param controllerFactory the controller factory
     * @since JavaFX 2.1
     */
    public void setControllerFactory(Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory) {
        this.controllerFactory = controllerFactory;
    }

    /**
     * Returns the character set used by this loader.
     * @return the character set
     */
    public Charset getCharset() {
        return charset;
    }

    /**
     * Sets the character set used by this loader.
     *
     * @param charset the character set
     * @since JavaFX 2.1
     */
    public void setCharset(Charset charset) {
        if (charset == null) {
            throw new NullPointerException(&quot;charset is null.&quot;);
        }

        this.charset = charset;
    }

    /**
     * Returns the classloader used by this loader.
     * @return the classloader
     * @since JavaFX 2.1
     */
    public ClassLoader getClassLoader() {
        if (classLoader == null) {
            final SecurityManager sm = System.getSecurityManager();
            final Class caller = (sm != null) ?
                    walker.getCallerClass() :
                    null;
            return getDefaultClassLoader(caller);
        }
        return classLoader;
    }

    /**
     * Sets the classloader used by this loader and clears any existing
     * imports.
     *
     * @param classLoader the classloader
     * @since JavaFX 2.1
     */
    public void setClassLoader(ClassLoader classLoader) {
        if (classLoader == null) {
            throw new IllegalArgumentException();
        }

        this.classLoader = classLoader;

        clearImports();
    }

    /*
     * Returns the static load flag.
     */
    boolean isStaticLoad() {
        // SB-dependency: RT-21226 has been filed to track this
        return staticLoad;
    }

    /*
     * Sets the static load flag.
     *
     * @param staticLoad
     */
    void setStaticLoad(boolean staticLoad) {
        // SB-dependency: RT-21226 has been filed to track this
        this.staticLoad = staticLoad;
    }

    /**
     * Returns this loader's load listener.
     *
     * @return the load listener
     *
     * @since 9
     */
    public LoadListener getLoadListener() {
        // SB-dependency: RT-21228 has been filed to track this
        return loadListener;
    }

    /**
     * Sets this loader's load listener.
     *
     * @param loadListener the load listener
     *
     * @since 9
     */
    public final void setLoadListener(LoadListener loadListener) {
        // SB-dependency: RT-21228 has been filed to track this
        this.loadListener = loadListener;
    }

    /**
     * Loads an object hierarchy from a FXML document. The location from which
     * the document will be loaded must have been set by a prior call to
     * {@link #setLocation(URL)}.
     *
     * @param &lt;T&gt; the type of the root object
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     *
     * @since JavaFX 2.1
     */
    public &lt;T&gt; T load() throws IOException {
        return loadImpl((System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param inputStream an input stream containing the FXML data to load
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public &lt;T&gt; T load(InputStream inputStream) throws IOException {
        return loadImpl(inputStream, (System.getSecurityManager() != null)
                                         ? walker.getCallerClass()
                                         : null);
    }

    private Class&lt;?&gt; callerClass;

    private &lt;T&gt; T loadImpl(final Class&lt;?&gt; callerClass) throws IOException {
        if (location == null) {
            throw new IllegalStateException(&quot;Location is not set.&quot;);
        }

        InputStream inputStream = null;
        T value;
        try {
            inputStream = location.openStream();
            value = loadImpl(inputStream, callerClass);
        } finally {
            if (inputStream != null) {
                inputStream.close();
            }
        }

        return value;
    }

    @SuppressWarnings({ &quot;dep-ann&quot;, &quot;unchecked&quot; })
    private &lt;T&gt; T loadImpl(InputStream inputStream,
                           Class&lt;?&gt; callerClass) throws IOException {
        if (inputStream == null) {
            throw new NullPointerException(&quot;inputStream is null.&quot;);
        }

        this.callerClass = callerClass;
        controllerAccessor.setCallerClass(callerClass);
        try {
            clearImports();

            // Initialize the namespace
            namespace.put(LOCATION_KEY, location);
            namespace.put(RESOURCES_KEY, resources);

            // Clear the script engine
            scriptEngine = null;

            // Create the parser
            try {
                XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
                xmlInputFactory.setProperty(&quot;javax.xml.stream.isCoalescing&quot;, true);

                // Some stream readers incorrectly report an empty string as the prefix
                // for the default namespace; correct this as needed
                InputStreamReader inputStreamReader = new InputStreamReader(inputStream, charset);
                xmlStreamReader = new StreamReaderDelegate(xmlInputFactory.createXMLStreamReader(inputStreamReader)) {
                    @Override
                    public String getPrefix() {
                        String prefix = super.getPrefix();

                        if (prefix != null
                            &amp;&amp; prefix.length() == 0) {
                            prefix = null;
                        }

                        return prefix;
                    }

                    @Override
                    public String getAttributePrefix(int index) {
                        String attributePrefix = super.getAttributePrefix(index);

                        if (attributePrefix != null
                            &amp;&amp; attributePrefix.length() == 0) {
                            attributePrefix = null;
                        }

                        return attributePrefix;
                    }
                };
            } catch (XMLStreamException exception) {
                throw constructLoadException(exception);
            }

            // Push this loader onto the stack
            loaders.push(this);

            // Parse the XML stream
            try {
                while (xmlStreamReader.hasNext()) {
                    int event = xmlStreamReader.next();

                    switch (event) {
                        case XMLStreamConstants.PROCESSING_INSTRUCTION: {
                            processProcessingInstruction();
                            break;
                        }

                        case XMLStreamConstants.COMMENT: {
                            processComment();
                            break;
                        }

                        case XMLStreamConstants.START_ELEMENT: {
                            processStartElement();
                            break;
                        }

                        case XMLStreamConstants.END_ELEMENT: {
                            processEndElement();
                            break;
                        }

                        case XMLStreamConstants.CHARACTERS: {
                            processCharacters();
                            break;
                        }
                    }
                }
            } catch (XMLStreamException exception) {
                throw constructLoadException(exception);
            }

            if (controller != null) {
                if (controller instanceof Initializable) {
                    ((Initializable)controller).initialize(location, resources);
                } else {
                    // Inject controller fields
                    Map&lt;String, List&lt;Field&gt;&gt; controllerFields =
                            controllerAccessor.getControllerFields();

                    injectFields(LOCATION_KEY, location);

                    injectFields(RESOURCES_KEY, resources);

                    // Initialize the controller
                    Method initializeMethod = controllerAccessor
                                                  .getControllerMethods()
                                                  .get(SupportedType.PARAMETERLESS)
                                                  .get(INITIALIZE_METHOD_NAME);

                    if (initializeMethod != null) {
                        try {
                            MethodHelper.invoke(initializeMethod, controller, new Object [] {});
                        } catch (IllegalAccessException exception) {
                            throw constructLoadException(exception);
                        } catch (InvocationTargetException exception) {
                            throw constructLoadException(exception);
                        }
                    }
                }
            }
        } catch (final LoadException exception) {
            throw exception;
        } catch (final Exception exception) {
            throw constructLoadException(exception);
        } finally {
            controllerAccessor.setCallerClass(null);
            // Clear controller accessor caches
            controllerAccessor.reset();
            // Clear the parser
            xmlStreamReader = null;
        }

        return (T)root;
    }

    private void clearImports() {
        packages.clear();
        classes.clear();
    }

    private LoadException constructLoadException(String message){
        return new LoadException(message + constructFXMLTrace());
    }

    private LoadException constructLoadException(Throwable cause) {
        return new LoadException(constructFXMLTrace(), cause);
    }

    private LoadException constructLoadException(String message, Throwable cause){
        return new LoadException(message + constructFXMLTrace(), cause);
    }

    private String constructFXMLTrace() {
        StringBuilder messageBuilder = new StringBuilder(&quot;\n&quot;);

        for (FXMLLoader loader : loaders) {
            messageBuilder.append(loader.location != null ? loader.location.getPath() : &quot;unknown path&quot;);

            if (loader.current != null) {
                messageBuilder.append(&quot;:&quot;);
                messageBuilder.append(loader.getLineNumber());
            }

            messageBuilder.append(&quot;\n&quot;);
        }
        return messageBuilder.toString();
    }

    /**
     * Returns the current line number.
     */
    int getLineNumber() {
        return xmlStreamReader.getLocation().getLineNumber();
    }

    /**
     * Returns the current parse trace.
     */
    ParseTraceElement[] getParseTrace() {
        ParseTraceElement[] parseTrace = new ParseTraceElement[loaders.size()];

        int i = 0;
        for (FXMLLoader loader : loaders) {
            parseTrace[i++] = new ParseTraceElement(loader.location, (loader.current != null) ?
                loader.getLineNumber() : -1);
        }

        return parseTrace;
    }

    private void processProcessingInstruction() throws LoadException {
        String piTarget = xmlStreamReader.getPITarget().trim();

        if (piTarget.equals(LANGUAGE_PROCESSING_INSTRUCTION)) {
            processLanguage();
        } else if (piTarget.equals(IMPORT_PROCESSING_INSTRUCTION)) {
            processImport();
        }
    }

    private void processLanguage() throws LoadException {
        if (scriptEngine != null) {
            throw constructLoadException(&quot;Page language already set.&quot;);
        }

        String language = xmlStreamReader.getPIData();

        if (loadListener != null) {
            loadListener.readLanguageProcessingInstruction(language);
        }

        if (!staticLoad) {
            ScriptEngineManager scriptEngineManager = getScriptEngineManager();
            scriptEngine = scriptEngineManager.getEngineByName(language);
        }
    }

    private void processImport() throws LoadException {
        String target = xmlStreamReader.getPIData().trim();

        if (loadListener != null) {
            loadListener.readImportProcessingInstruction(target);
        }

        if (target.endsWith(&quot;.*&quot;)) {
            importPackage(target.substring(0, target.length() - 2));
        } else {
            importClass(target);
        }
    }

    private void processComment() throws LoadException {
        if (loadListener != null) {
            loadListener.readComment(xmlStreamReader.getText());
        }
    }

    private void processStartElement() throws IOException {
        // Create the element
        createElement();

        // Process the start tag
        current.processStartElement();

        // Set the root value
        if (root == null) {
            root = current.value;
        }
    }

    private void createElement() throws IOException {
        String prefix = xmlStreamReader.getPrefix();
        String localName = xmlStreamReader.getLocalName();

        if (prefix == null) {
            int i = localName.lastIndexOf('.');

            if (Character.isLowerCase(localName.charAt(i + 1))) {
                String name = localName.substring(i + 1);

                if (i == -1) {
                    // This is an instance property
                    if (loadListener != null) {
                        loadListener.beginPropertyElement(name, null);
                    }

                    current = new PropertyElement(name, null);
                } else {
                    // This is a static property
                    Class&lt;?&gt; sourceType = getType(localName.substring(0, i));

                    if (sourceType != null) {
                        if (loadListener != null) {
                            loadListener.beginPropertyElement(name, sourceType);
                        }

                        current = new PropertyElement(name, sourceType);
                    } else if (staticLoad) {
                        // The source type was not recognized
                        if (loadListener != null) {
                            loadListener.beginUnknownStaticPropertyElement(localName);
                        }

                        current = new UnknownStaticPropertyElement();
                    } else {
                        throw constructLoadException(localName + &quot; is not a valid property.&quot;);
                    }
                }
            } else {
                if (current == null &amp;&amp; root != null) {
                    throw constructLoadException(&quot;Root value already specified.&quot;);
                }

                Class&lt;?&gt; type = getType(localName);

                if (type != null) {
                    if (loadListener != null) {
                        loadListener.beginInstanceDeclarationElement(type);
                    }

                    current = new InstanceDeclarationElement(type);
                } else if (staticLoad) {
                    // The type was not recognized
                    if (loadListener != null) {
                        loadListener.beginUnknownTypeElement(localName);
                    }

                    current = new UnknownTypeElement();
                } else {
                    throw constructLoadException(localName + &quot; is not a valid type.&quot;);
                }
            }
        } else if (prefix.equals(FX_NAMESPACE_PREFIX)) {
            if (localName.equals(INCLUDE_TAG)) {
                if (loadListener != null) {
                    loadListener.beginIncludeElement();
                }

                current = new IncludeElement();
            } else if (localName.equals(REFERENCE_TAG)) {
                if (loadListener != null) {
                    loadListener.beginReferenceElement();
                }

                current = new ReferenceElement();
            } else if (localName.equals(COPY_TAG)) {
                if (loadListener != null) {
                    loadListener.beginCopyElement();
                }

                current = new CopyElement();
            } else if (localName.equals(ROOT_TAG)) {
                if (loadListener != null) {
                    loadListener.beginRootElement();
                }

                current = new RootElement();
            } else if (localName.equals(SCRIPT_TAG)) {
                if (loadListener != null) {
                    loadListener.beginScriptElement();
                }

                current = new ScriptElement();
            } else if (localName.equals(DEFINE_TAG)) {
                if (loadListener != null) {
                    loadListener.beginDefineElement();
                }

                current = new DefineElement();
            } else {
                throw constructLoadException(prefix + &quot;:&quot; + localName + &quot; is not a valid element.&quot;);
            }
        } else {
            throw constructLoadException(&quot;Unexpected namespace prefix: &quot; + prefix + &quot;.&quot;);
        }
    }

    private void processEndElement() throws IOException {
        current.processEndElement();

        if (loadListener != null) {
            loadListener.endElement(current.value);
        }

        // Move up the stack
        current = current.parent;
    }

    private void processCharacters() throws IOException {
        // Process the characters
        if (!xmlStreamReader.isWhiteSpace()) {
            current.processCharacters();
        }
    }

    private void importPackage(String name) throws LoadException {
        packages.add(name);
    }

    private void importClass(String name) throws LoadException {
        try {
            loadType(name, true);
        } catch (ClassNotFoundException exception) {
            throw constructLoadException(exception);
        }
    }

    private Class&lt;?&gt; getType(String name) throws LoadException {
        Class&lt;?&gt; type = null;

        if (Character.isLowerCase(name.charAt(0))) {
            // This is a fully-qualified class name
            try {
                type = loadType(name, false);
            } catch (ClassNotFoundException exception) {
                // No-op
            }
        } else {
            // This is an unqualified class name
            type = classes.get(name);

            if (type == null) {
                // The class has not been loaded yet; look it up
                for (String packageName : packages) {
                    try {
                        type = loadTypeForPackage(packageName, name);
                    } catch (ClassNotFoundException exception) {
                        // No-op
                    }

                    if (type != null) {
                        break;
                    }
                }

                if (type != null) {
                    classes.put(name, type);
                }
            }
        }

        return type;
    }

    private Class&lt;?&gt; loadType(String name, boolean cache) throws ClassNotFoundException {
        int i = name.indexOf('.');
        int n = name.length();
        while (i != -1
            &amp;&amp; i &lt; n
            &amp;&amp; Character.isLowerCase(name.charAt(i + 1))) {
            i = name.indexOf('.', i + 1);
        }

        if (i == -1 || i == n) {
            throw new ClassNotFoundException();
        }

        String packageName = name.substring(0, i);
        String className = name.substring(i + 1);

        Class&lt;?&gt; type = loadTypeForPackage(packageName, className);

        if (cache) {
            classes.put(className, type);
        }

        return type;
    }

    // TODO Rename to loadType() when deprecated static version is removed
    private Class&lt;?&gt; loadTypeForPackage(String packageName, String className) throws ClassNotFoundException {
        return getClassLoader().loadClass(packageName + &quot;.&quot; + className.replace('.', '$'));
    }

    private static enum SupportedType {
        PARAMETERLESS {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 0;
            }

        },
        EVENT {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        Event.class.isAssignableFrom(m.getParameterTypes()[0]);
            }

        },
        LIST_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        m.getParameterTypes()[0].equals(ListChangeListener.Change.class);
            }

        },
        MAP_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        m.getParameterTypes()[0].equals(MapChangeListener.Change.class);
            }

        },
        SET_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 1 &amp;&amp;
                        m.getParameterTypes()[0].equals(SetChangeListener.Change.class);
            }

        },
        PROPERTY_CHANGE_LISTENER {

            @Override
            protected boolean methodIsOfType(Method m) {
                return m.getParameterTypes().length == 3 &amp;&amp;
                        ObservableValue.class.isAssignableFrom(m.getParameterTypes()[0])
                        &amp;&amp; m.getParameterTypes()[1].equals(m.getParameterTypes()[2]);
            }

        };

        protected abstract boolean methodIsOfType(Method m);
    }

    private static SupportedType toSupportedType(Method m) {
        for (SupportedType t : SupportedType.values()) {
            if (t.methodIsOfType(m)) {
                return t;
            }
        }
        return null;
    }

    private ScriptEngineManager getScriptEngineManager() {
        if (scriptEngineManager == null) {
            scriptEngineManager = new javax.script.ScriptEngineManager();
            scriptEngineManager.setBindings(new SimpleBindings(namespace));
        }

        return scriptEngineManager;
    }

    /**
     * Loads a type using the default class loader.
     *
     * @param packageName the package name of the class to load
     * @param className the name of the class to load
     *
     * @throws ClassNotFoundException if the specified class cannot be found
     * @return the class
     *
     * @deprecated
     * This method now delegates to {@link #getDefaultClassLoader()}.
     */
    @Deprecated
    public static Class&lt;?&gt; loadType(String packageName, String className) throws ClassNotFoundException {
        return loadType(packageName + &quot;.&quot; + className.replace('.', '$'));
    }

    /**
     * Loads a type using the default class loader.
     *
     * @param className the name of the class to load
     * @throws ClassNotFoundException if the specified class cannot be found
     * @return the class
     *
     * @deprecated
     * This method now delegates to {@link #getDefaultClassLoader()}.
     */
    @Deprecated
    public static Class&lt;?&gt; loadType(String className) throws ClassNotFoundException {
        ReflectUtil.checkPackageAccess(className);
        return Class.forName(className, true, getDefaultClassLoader());
    }

    private static boolean needsClassLoaderPermissionCheck(Class caller) {
        if (caller == null) {
            return false;
        }
        return !FXMLLoader.class.getModule().equals(caller.getModule());
    }

    private static ClassLoader getDefaultClassLoader(Class caller) {
        if (defaultClassLoader == null) {
            final SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                if (needsClassLoaderPermissionCheck(caller)) {
                    sm.checkPermission(GET_CLASSLOADER_PERMISSION);
                }
            }
            return Thread.currentThread().getContextClassLoader();
        }
        return defaultClassLoader;
    }

    /**
     * Returns the default class loader.
     * @return the default class loader
     * @since JavaFX 2.1
     */
    public static ClassLoader getDefaultClassLoader() {
        final SecurityManager sm = System.getSecurityManager();
        final Class caller = (sm != null) ?
                walker.getCallerClass() :
                null;
        return getDefaultClassLoader(caller);
    }

    /**
     * Sets the default class loader.
     *
     * @param defaultClassLoader
     * The default class loader to use when loading classes.
     * @since JavaFX 2.1
     */
    public static void setDefaultClassLoader(ClassLoader defaultClassLoader) {
        if (defaultClassLoader == null) {
            throw new NullPointerException();
        }
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            sm.checkPermission(MODIFY_FXML_CLASS_LOADER_PERMISSION);
        }

        FXMLLoader.defaultClassLoader = defaultClassLoader;
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public static &lt;T&gt; T load(URL location) throws IOException {
        return loadImpl(location, (System.getSecurityManager() != null)
                                      ? walker.getCallerClass()
                                      : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, Class&lt;?&gt; callerClass)
            throws IOException {
        return loadImpl(location, null, callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources)
                                     throws IOException {
        return loadImpl(location, resources,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  Class&lt;?&gt; callerClass) throws IOException {
        return loadImpl(location, resources,  null,
                        callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used to load the document
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources,
                             BuilderFactory builderFactory)
                                     throws IOException {
        return loadImpl(location, resources, builderFactory,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  BuilderFactory builderFactory,
                                  Class&lt;?&gt; callerClass) throws IOException {
        return loadImpl(location, resources, builderFactory, null, callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used when loading the document
     * @param controllerFactory the controller factory used when loading the document
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     *
     * @since JavaFX 2.1
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources,
                             BuilderFactory builderFactory,
                             Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory)
                                     throws IOException {
        return loadImpl(location, resources, builderFactory, controllerFactory,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  BuilderFactory builderFactory,
                                  Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
                                  Class&lt;?&gt; callerClass) throws IOException {
        return loadImpl(location, resources, builderFactory, controllerFactory,
                        Charset.forName(DEFAULT_CHARSET_NAME), callerClass);
    }

    /**
     * Loads an object hierarchy from a FXML document.
     *
     * @param &lt;T&gt; the type of the root object
     * @param location the location used to resolve relative path attribute values
     * @param resources the resources used to resolve resource key attribute values
     * @param builderFactory the builder factory used when loading the document
     * @param controllerFactory the controller factory used when loading the document
     * @param charset the character set used when loading the document
     *
     * @throws IOException if an error occurs during loading
     * @return the loaded object hierarchy
     *
     * @since JavaFX 2.1
     */
    public static &lt;T&gt; T load(URL location, ResourceBundle resources,
                             BuilderFactory builderFactory,
                             Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
                             Charset charset) throws IOException {
        return loadImpl(location, resources, builderFactory, controllerFactory,
                        charset,
                        (System.getSecurityManager() != null)
                            ? walker.getCallerClass()
                            : null);
    }

    private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
                                  BuilderFactory builderFactory,
                                  Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
                                  Charset charset, Class&lt;?&gt; callerClass)
                                          throws IOException {
        if (location == null) {
            throw new NullPointerException(&quot;Location is required.&quot;);
        }

        FXMLLoader fxmlLoader =
                new FXMLLoader(location, resources, builderFactory,
                               controllerFactory, charset);

        return fxmlLoader.&lt;T&gt;loadImpl(callerClass);
    }

    /**
     * Utility method for comparing two JavaFX version strings (such as 2.2.5, 8.0.0-ea)
     * @param rtVer String representation of JavaFX runtime version, including - or _ appendix
     * @param nsVer String representation of JavaFX version to compare against runtime version
     * @return number &amp;lt; 0 if runtime version is lower, 0 when both versions are the same,
     *          number &amp;gt; 0 if runtime is higher version
     */
    static int compareJFXVersions(String rtVer, String nsVer) {

        int retVal = 0;

        if (rtVer == null || &quot;&quot;.equals(rtVer) ||
            nsVer == null || &quot;&quot;.equals(nsVer)) {
            return retVal;
        }

        if (rtVer.equals(nsVer)) {
            return retVal;
        }

        // version string can contain '-'
        int dashIndex = rtVer.indexOf(&quot;-&quot;);
        if (dashIndex &gt; 0) {
            rtVer = rtVer.substring(0, dashIndex);
        }

        // or &quot;_&quot;
        int underIndex = rtVer.indexOf(&quot;_&quot;);
        if (underIndex &gt; 0) {
            rtVer = rtVer.substring(0, underIndex);
        }

        // do not try to compare if the string is not valid version format
        if (!Pattern.matches(&quot;^(\\d+)(\\.\\d+)*$&quot;, rtVer) ||
            !Pattern.matches(&quot;^(\\d+)(\\.\\d+)*$&quot;, nsVer)) {
            return retVal;
        }

        StringTokenizer nsVerTokenizer = new StringTokenizer(nsVer, &quot;.&quot;);
        StringTokenizer rtVerTokenizer = new StringTokenizer(rtVer, &quot;.&quot;);
        int nsDigit = 0, rtDigit = 0;
        boolean rtVerEnd = false;

        while (nsVerTokenizer.hasMoreTokens() &amp;&amp; retVal == 0) {
            nsDigit = Integer.parseInt(nsVerTokenizer.nextToken());
            if (rtVerTokenizer.hasMoreTokens()) {
                rtDigit = Integer.parseInt(rtVerTokenizer.nextToken());
                retVal = rtDigit - nsDigit;
            } else {
                rtVerEnd = true;
                break;
            }
        }

        if (rtVerTokenizer.hasMoreTokens() &amp;&amp; retVal == 0) {
            rtDigit = Integer.parseInt(rtVerTokenizer.nextToken());
            if (rtDigit &gt; 0) {
                retVal = 1;
            }
        }

        if (rtVerEnd) {
            if (nsDigit &gt; 0) {
                retVal = -1;
            } else {
                while (nsVerTokenizer.hasMoreTokens()) {
                    nsDigit = Integer.parseInt(nsVerTokenizer.nextToken());
                    if (nsDigit &gt; 0) {
                        retVal = -1;
                        break;
                    }
                }
            }
        }

        return retVal;
    }

    private static void checkClassLoaderPermission() {
        final SecurityManager securityManager = System.getSecurityManager();
        if (securityManager != null) {
            securityManager.checkPermission(MODIFY_FXML_CLASS_LOADER_PERMISSION);
        }
    }

    private final ControllerAccessor controllerAccessor =
            new ControllerAccessor();

    private static final class ControllerAccessor {
        private static final int PUBLIC = 1;
        private static final int PROTECTED = 2;
        private static final int PACKAGE = 4;
        private static final int PRIVATE = 8;
        private static final int INITIAL_CLASS_ACCESS =
                PUBLIC | PROTECTED | PACKAGE | PRIVATE;
        private static final int INITIAL_MEMBER_ACCESS =
                PUBLIC | PROTECTED | PACKAGE | PRIVATE;

        private static final int METHODS = 0;
        private static final int FIELDS = 1;

        private Object controller;
        private ClassLoader callerClassLoader;

        private Map&lt;String, List&lt;Field&gt;&gt; controllerFields;
        private Map&lt;SupportedType, Map&lt;String, Method&gt;&gt; controllerMethods;

        void setController(final Object controller) {
            if (this.controller != controller) {
                this.controller = controller;
                reset();
            }
        }

        void setCallerClass(final Class&lt;?&gt; callerClass) {
            final ClassLoader newCallerClassLoader =
                    (callerClass != null) ? callerClass.getClassLoader()
                                          : null;
            if (callerClassLoader != newCallerClassLoader) {
                callerClassLoader = newCallerClassLoader;
                reset();
            }
        }

        void reset() {
            controllerFields = null;
            controllerMethods = null;
        }

        Map&lt;String, List&lt;Field&gt;&gt; getControllerFields() {
            if (controllerFields == null) {
                controllerFields = new HashMap&lt;&gt;();

                if (callerClassLoader == null) {
                    // allow null class loader only with permission check
                    checkClassLoaderPermission();
                }

                addAccessibleMembers(controller.getClass(),
                                     INITIAL_CLASS_ACCESS,
                                     INITIAL_MEMBER_ACCESS,
                                     FIELDS);
            }

            return controllerFields;
        }

        Map&lt;SupportedType, Map&lt;String, Method&gt;&gt; getControllerMethods() {
            if (controllerMethods == null) {
                controllerMethods = new EnumMap&lt;&gt;(SupportedType.class);
                for (SupportedType t: SupportedType.values()) {
                    controllerMethods.put(t, new HashMap&lt;String, Method&gt;());
                }

                if (callerClassLoader == null) {
                    // allow null class loader only with permission check
                    checkClassLoaderPermission();
                }

                addAccessibleMembers(controller.getClass(),
                                     INITIAL_CLASS_ACCESS,
                                     INITIAL_MEMBER_ACCESS,
                                     METHODS);
            }

            return controllerMethods;
        }

        private void addAccessibleMembers(final Class&lt;?&gt; type,
                                          final int prevAllowedClassAccess,
                                          final int prevAllowedMemberAccess,
                                          final int membersType) {
            if (type == Object.class) {
                return;
            }

            int allowedClassAccess = prevAllowedClassAccess;
            int allowedMemberAccess = prevAllowedMemberAccess;
            if ((callerClassLoader != null)
                    &amp;&amp; (type.getClassLoader() != callerClassLoader)) {
                // restrict further access
                allowedClassAccess &amp;= PUBLIC;
                allowedMemberAccess &amp;= PUBLIC;
            }

            final int classAccess = getAccess(type.getModifiers());
            if ((classAccess &amp; allowedClassAccess) == 0) {
                // we are done
                return;
            }

            ReflectUtil.checkPackageAccess(type);

            addAccessibleMembers(type.getSuperclass(),
                                 allowedClassAccess,
                                 allowedMemberAccess,
                                 membersType);

            final int finalAllowedMemberAccess = allowedMemberAccess;
            AccessController.doPrivileged(
                    new PrivilegedAction&lt;Void&gt;() {
                        @Override
                        public Void run() {
                            if (membersType == FIELDS) {
                                addAccessibleFields(type,
                                                    finalAllowedMemberAccess);
                            } else {
                                addAccessibleMethods(type,
                                                     finalAllowedMemberAccess);
                            }

                            return null;
                        }
                    });
        }

        private void addAccessibleFields(final Class&lt;?&gt; type,
                                         final int allowedMemberAccess) {
            final boolean isPublicType = Modifier.isPublic(type.getModifiers());

            final Field[] fields = type.getDeclaredFields();
            for (int i = 0; i &lt; fields.length; ++i) {
                final Field field = fields[i];
                final int memberModifiers = field.getModifiers();

                if (((memberModifiers &amp; (Modifier.STATIC
                                             | Modifier.FINAL)) != 0)
                        || ((getAccess(memberModifiers) &amp; allowedMemberAccess)
                                == 0)) {
                    continue;
                }

                if (!isPublicType || !Modifier.isPublic(memberModifiers)) {
                    if (field.getAnnotation(FXML.class) == null) {
                        // no fxml annotation on a non-public field
                        continue;
                    }

                    // Ensure that the field is accessible
                    field.setAccessible(true);
                }

                List&lt;Field&gt; list = controllerFields.get(field.getName());
                if (list == null) {
                    list = new ArrayList&lt;&gt;(1);
                    controllerFields.put(field.getName(), list);
                }
                list.add(field);

            }
        }

        private void addAccessibleMethods(final Class&lt;?&gt; type,
                                          final int allowedMemberAccess) {
            final boolean isPublicType = Modifier.isPublic(type.getModifiers());

            final Method[] methods = type.getDeclaredMethods();
            for (int i = 0; i &lt; methods.length; ++i) {
                final Method method = methods[i];
                final int memberModifiers = method.getModifiers();

                if (((memberModifiers &amp; (Modifier.STATIC
                                             | Modifier.NATIVE)) != 0)
                        || ((getAccess(memberModifiers) &amp; allowedMemberAccess)
                                == 0)) {
                    continue;
                }

                if (!isPublicType || !Modifier.isPublic(memberModifiers)) {
                    if (method.getAnnotation(FXML.class) == null) {
                        // no fxml annotation on a non-public method
                        continue;
                    }

                    // Ensure that the method is accessible
                    method.setAccessible(true);
                }

                // Add this method to the map if:
                // a) it is the initialize() method, or
                // b) it takes a single event argument, or
                // c) it takes no arguments and a handler with this
                //    name has not already been defined
                final String methodName = method.getName();
                final SupportedType convertedType;

                if ((convertedType = toSupportedType(method)) != null) {
                    controllerMethods.get(convertedType)
                                     .put(methodName, method);
                }
            }
        }

        private static int getAccess(final int fullModifiers) {
            final int untransformedAccess =
                    fullModifiers &amp; (Modifier.PRIVATE | Modifier.PROTECTED
                                                      | Modifier.PUBLIC);

            switch (untransformedAccess) {
                case Modifier.PUBLIC:
                    return PUBLIC;

                case Modifier.PROTECTED:
                    return PROTECTED;

                case Modifier.PRIVATE:
                    return PRIVATE;

                default:
                    return PACKAGE;
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/Window.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui;

import com.sun.glass.events.MouseEvent;
import com.sun.glass.events.WindowEvent;
import com.sun.prism.impl.PrismSettings;

import java.lang.annotation.Native;

import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

public abstract class Window {

    public static class EventHandler {
        public void handleWindowEvent(Window window, long time, int type) {
        }

        /**
         * Notifies a listener that the screen object for this Window instance
         * has been updated.
         *
         * Note that while the old and new screen objects may be different,
         * they can still represent the same physical screen. This can happen
         * if e.g. only a certain parameter of the screen has been updated such
         * as its scale factor.
         *
         * On some platforms when a window is moved to another physical screen
         * an app can receive this event twice. One representing the physical
         * screen change, and another - the display's parameters change. Note
         * that sending two events instead of just one is platform-specific.
         *
         * The event handler can use the {@link Screen#getNativeScreen} method
         * to determine if this is the same physical screen or not. If the
         * native system always creates new native screen instances, there's no
         * way for the app to distinguish between a real move to another screen
         * or jsut a parameters update event. Since this is a somewhat rare
         * event, an app is advised to always process it the same way.
         *
         * @see Window#getScreen
         */
        public void handleScreenChangedEvent(Window window, long time, Screen oldScreen, Screen newScreen) {
        }

        /**
         * Notifies the listener that the window level has changed. The Level should be one of
         * {@link com.sun.glass.ui.Window.Level#NORMAL}, {@link com.sun.glass.ui.Window.Level#FLOATING},
         * {@link com.sun.glass.ui.Window.Level#TOPMOST}.
         * @param level Level from {@link com.sun.glass.ui.Window.Level} class
         */
        public void handleLevelEvent(int level) {
        }
    }

    // Native object handle (HWND, or NSWindow*, etc.)
    private long ptr;

    // 'Delegate window' ptr. Used in e.g. the Full Screen mode.
    private volatile long delegatePtr = 0L;

    // window list
    static private final LinkedList&lt;Window&gt; visibleWindows = new LinkedList&lt;Window&gt;();
     // Return a list of all visible windows.  Note that on platforms without a native window manager,
     // this list will be sorted in proper z-order
    static public synchronized List&lt;Window&gt; getWindows() {
        Application.checkEventThread();
        return Collections.unmodifiableList(Window.visibleWindows);
    }

    static public List&lt;Window&gt; getWindowsClone() {
        Application.checkEventThread();
        return (List&lt;Window&gt;)visibleWindows.clone();
    }

    // used by Lens Native
    static protected void add(Window window) {
        visibleWindows.add(window);
    }

    static protected void addFirst(Window window) {
        visibleWindows.addFirst(window);
    }

    // used by Lens Native
    static protected void remove(Window window) {
        visibleWindows.remove(window);
    }

    // window style mask

    // visual kind: mutually exclusive
    public static final int UNTITLED        = 0;
    public static final int TITLED          = 1 &lt;&lt; 0;
    public static final int TRANSPARENT     = 1 &lt;&lt; 1;

    // functional type: mutually exclusive
    /**
     * Normal window.
     *
     * Usual top-level window.
     */
    public static final int NORMAL          = 0;
    /**
     * An utility window.
     *
     * Often used for floating toolbars. It has smaller than usual decorations
     * and doesn't display a taskbar button.
     */
    @Native public static final int UTILITY         = 1 &lt;&lt; 2;
    /**
     * A popup window.
     *
     * Used to display popups (tooltips, popup menus, etc.) Note that by
     * default it may display a task-bar button. To hide it the window must be
     * owned.
     */
    @Native public static final int POPUP           = 1 &lt;&lt; 3;

    // These affect window decorations as well as system menu actions,
    // so applicable to both decorated and undecorated windows
    @Native public static final int CLOSABLE        = 1 &lt;&lt; 4;
    @Native public static final int MINIMIZABLE     = 1 &lt;&lt; 5;
    @Native public static final int MAXIMIZABLE     = 1 &lt;&lt; 6;

    /**
     * Indicates that the window trim will draw from right to left.
     */
    @Native public static final int RIGHT_TO_LEFT     = 1 &lt;&lt; 7;

    /**
     * Indicates that a window will have a client area textured the same way as the platform decorations
     * and will not have a border between decorations and the client area.
     * This is supported not on all platforms, the client should check if the feature is supported by using
     * {@link com.sun.glass.ui.Application#supportsUnifiedWindows()}
     */
    @Native public static final int UNIFIED = 1 &lt;&lt; 8;

    final static public class State {
        @Native public static final int NORMAL = 1;
        @Native public static final int MINIMIZED = 2;
        @Native public static final int MAXIMIZED = 3;
    }

    /**
     * Available window levels.
     *
     * Note that on some platforms both {@code FLOATING} and {@code TOPMOST}
     * may represent the same window level.
     *
     * @see #setLevel
     */
    public static final class Level {
        @Native private static final int _MIN = 1;

        /** Normal window level. */
        @Native public static final int NORMAL = 1;

        /** A window level that is above all other NORMAL windows. */
        @Native public static final int FLOATING = 2;

        /** A very topmost window level. May cover system UI elements such as dock, taskbar, etc. */
        @Native public static final int TOPMOST = 3;

        @Native private static final int _MAX = 3;
    }

    private final Window owner;
    private final long parent;
    private final int styleMask;
    private final boolean isDecorated;
    private boolean shouldStartUndecoratedMove = false;

    protected View view = null;
    protected Screen screen = null;
    private MenuBar menubar = null;
    private String title = &quot;&quot;;
    private UndecoratedMoveResizeHelper helper = null;

    private int state = State.NORMAL;
    private int level = Level.NORMAL;
    protected int x = 0;
    protected int y = 0;
    protected int width = 0;
    protected int height = 0;
    private float alpha = 1.0f;
    protected float platformScaleX = 1.0f;
    protected float platformScaleY = 1.0f;
    private float outputScaleX = 1.0f;
    private float outputScaleY = 1.0f;
    private float renderScaleX = 1.0f;
    private float renderScaleY = 1.0f;
    private boolean appletMode = false;

    // This is a workaround for RT-15970: as for embedded windows we don't
    // receive any MOVE notifications from the native platform, we poll
    // the window location on screen from timer and post synthetic events
    // if it has changed
    private Timer embeddedLocationTimer = null;
    private int lastKnownEmbeddedX = 0;
    private int lastKnownEmbeddedY = 0;

    private volatile boolean isResizable = false;
    private volatile boolean isVisible = false;
    private volatile boolean isFocused = false;
    private volatile boolean isFocusable = true;
    private volatile boolean isModal = false;

    // Indicates how many times setEnabled(false) has been called.
    // A value of 0 means the window is enabled.
    private volatile int disableCount = 0;

    private int minimumWidth = 0, minimumHeight = 0;
    private int maximumWidth = Integer.MAX_VALUE, maximumHeight = Integer.MAX_VALUE;

    private EventHandler eventHandler;

    protected abstract long _createWindow(long ownerPtr, long screenPtr, int mask);
    protected Window(Window owner, Screen screen, int styleMask) {
        Application.checkEventThread();
        switch (styleMask &amp; (TITLED | TRANSPARENT)) {
            case UNTITLED:
            case TITLED:
            case TRANSPARENT:
                break;
            default:
                throw new RuntimeException(&quot;The visual kind should be UNTITLED, TITLED, or TRANSPARENT, but not a combination of these&quot;);
        }
        switch (styleMask &amp; (POPUP | UTILITY)) {
            case NORMAL:
            case POPUP:
            case UTILITY:
                break;
            default:
                throw new RuntimeException(&quot;The functional type should be NORMAL, POPUP, or UTILITY, but not a combination of these&quot;);
        }

        if (((styleMask &amp; UNIFIED) != 0)
                &amp;&amp; !Application.GetApplication().supportsUnifiedWindows()) {
           styleMask &amp;= ~UNIFIED;
        }

        if (((styleMask &amp; TRANSPARENT) != 0)
                &amp;&amp; !Application.GetApplication().supportsTransparentWindows()) {
            styleMask &amp;= ~TRANSPARENT;
        }


        this.owner = owner;
        this.parent = 0L;
        this.styleMask = styleMask;
        this.isDecorated = (this.styleMask &amp; Window.TITLED) != 0;

        this.screen = screen != null ? screen : Screen.getMainScreen();
        if (PrismSettings.allowHiDPIScaling) {
            this.platformScaleX = this.screen.getPlatformScaleX();
            this.platformScaleY = this.screen.getPlatformScaleY();
            this.outputScaleX = this.screen.getRecommendedOutputScaleX();
            this.outputScaleY = this.screen.getRecommendedOutputScaleY();
        }

        this.ptr = _createWindow(owner != null ? owner.getNativeHandle() : 0L,
                this.screen.getNativeScreen(), this.styleMask);
        if (this.ptr == 0L) {
            throw new RuntimeException(&quot;could not create platform window&quot;);
        }
    }

    protected abstract long _createChildWindow(long parent);
    /**
     * Constructs a child window of the specified native parent window.
     */
    protected Window(long parent) {
        Application.checkEventThread();
        this.owner = null;
        this.parent = parent;
        this.styleMask = Window.UNTITLED;
        this.isDecorated = false;

        // Note: we can't always catch screen changes when parent is moved...
        this.screen = null; // should infer from the parent

        this.ptr = _createChildWindow(parent);
        if (this.ptr == 0L) {
            throw new RuntimeException(&quot;could not create platform window&quot;);
        }

        if (screen == null) {
            screen = Screen.getMainScreen(); // start with a default

            if (PrismSettings.allowHiDPIScaling) {
                this.platformScaleX = this.screen.getPlatformScaleX();
                this.platformScaleY = this.screen.getPlatformScaleY();
                this.outputScaleX = this.screen.getRecommendedOutputScaleX();
                this.outputScaleY = this.screen.getRecommendedOutputScaleY();
            }
        }
    }

    public boolean isClosed() {
        Application.checkEventThread();
        return this.ptr == 0L;
    }

    private void checkNotClosed() {
        if (this.ptr == 0L) {
            throw new IllegalStateException(&quot;The window has already been closed&quot;);
        }
    }

    protected abstract boolean _close(long ptr);
    public void close() {
        Application.checkEventThread();
        if (this.view != null) {
            if (this.ptr != 0L) {
                _setView(this.ptr, null);
            }
            this.view.setWindow(null);
            this.view.close();
            this.view = null;
        }
        if (this.ptr != 0L) {
            _close(this.ptr);
        }
    }

    private boolean isChild() {
        Application.checkEventThread();
        return this.parent != 0L;
    }

    /** This method returns &quot;lowest-level&quot; native window handle
     * (HWND on Windows, NSWindow on Mac, X11 Window handle on linux-gtk etc.)
     */
    public long getNativeWindow() {
        Application.checkEventThread();
        checkNotClosed();
        return this.delegatePtr != 0L ? this.delegatePtr : this.ptr;
    }

    /**
     * This method returns &quot;higher-level&quot; native window handle.
     * glass-mat-lib-gtk GtkWindow.java returns GtkWindow pointer for example.
     */
    public long getNativeHandle() {
        Application.checkEventThread();
        return this.delegatePtr != 0L ? this.delegatePtr : this.ptr;
    }

    /**
     * return the &quot;raw' pointer needed by subclasses to pass to native routines
     * @return the native pointer.
     */
    public long getRawHandle() {
        return ptr;
    }

    public Window getOwner() {
        Application.checkEventThread();
        return this.owner;
    }

    public View getView() {
        Application.checkEventThread();
        return this.view;
    }

    protected abstract boolean _setView(long ptr, View view);
    public void setView(final View view) {
        Application.checkEventThread();
        checkNotClosed();
        View oldView = getView();
        if (oldView == view) {
            return;
        }

        if (oldView != null) {
            oldView.setWindow(null);
        }
        if (view != null) {
            Window host = view.getWindow();
            if (host != null) {
                host.setView(null);
            }
        }

        if (view != null &amp;&amp; _setView(this.ptr, view)) {
            this.view = view;
            this.view.setWindow(this);
            if (this.isDecorated == false) {
                this.helper = new UndecoratedMoveResizeHelper();
            }
        } else {
            _setView(this.ptr, null);
            this.view = null;
        }
    }

    public Screen getScreen() {
        Application.checkEventThread();
        return this.screen;
    }

    protected void setScreen(Screen screen) {
        Application.checkEventThread();

        final Screen old = this.screen;
        this.screen = screen;

        if (this.eventHandler != null) {
            if ((old == null &amp;&amp; this.screen != null) ||
                (old != null &amp;&amp; !old.equals(this.screen))) {
                this.eventHandler.handleScreenChangedEvent(this, System.nanoTime(), old, this.screen);
            }
        }
    }

    public int getStyleMask() {
        Application.checkEventThread();
        return this.styleMask;
    }

    public MenuBar getMenuBar() {
        Application.checkEventThread();
        return this.menubar;
    }

    protected abstract boolean _setMenubar(long ptr, long menubarPtr);
    public void setMenuBar(final MenuBar menubar) {
        Application.checkEventThread();
        checkNotClosed();
        if (_setMenubar(this.ptr, menubar.getNativeMenu())) {
            this.menubar = menubar;
        }
    }

    public boolean isDecorated() {
        Application.checkEventThread();
        return this.isDecorated;
    }

    public boolean isMinimized() {
        Application.checkEventThread();
        return (this.state == State.MINIMIZED);
    }

    protected abstract boolean _minimize(long ptr, boolean minimize);
    public boolean minimize(final boolean minimize) {
        Application.checkEventThread();
        checkNotClosed();
        _minimize(this.ptr, minimize);
        //XXX: this is synchronous? On X11 this may not work
        return isMinimized();
    }

    public boolean isMaximized() {
        Application.checkEventThread();
        return (this.state == State.MAXIMIZED);
    }

    protected abstract boolean _maximize(long ptr, boolean maximize, boolean wasMaximized);
    public boolean maximize(final boolean maximize) {
        Application.checkEventThread();
        checkNotClosed();
        _maximize(ptr, maximize, isMaximized());
        return isMaximized();
    }

    protected void notifyScaleChanged(float platformScaleX, float platformScaleY,
                                      float outputScaleX, float outputScaleY)
    {
        if (!PrismSettings.allowHiDPIScaling) return;
        this.platformScaleX = platformScaleX;
        this.platformScaleY = platformScaleY;
        this.outputScaleX = outputScaleX;
        this.outputScaleY = outputScaleY;
        notifyRescale();
    }

    /**
     * Return the horizontal scale used to communicate window locations,
     * sizes, and event coordinates to/from the platform.
     * @return the horizontal platform scaling for screen locations
     */
    public final float getPlatformScaleX() {
        return platformScaleX;
    }

    /**
     * Return the vertical scale used to communicate window locations,
     * sizes, and event coordinates to/from the platform.
     * @return the vertical platform scaling for screen locations
     */
    public final float getPlatformScaleY() {
        return platformScaleY;
    }

    public void setRenderScaleX(float renderScaleX) {
        if (!PrismSettings.allowHiDPIScaling) return;
        this.renderScaleX = renderScaleX;
    }

    public void setRenderScaleY(float renderScaleY) {
        if (!PrismSettings.allowHiDPIScaling) return;
        this.renderScaleY = renderScaleY;
    }

    /**
     * Return the horizontal scale used for rendering the back buffer.
     * @return the horizontal scaling for rendering
     */
    public final float getRenderScaleX() {
        return renderScaleX;
    }

    /**
     * Return the vertical scale used for rendering to the back buffer.
     * @return the vertical scaling for rendering
     */
    public final float getRenderScaleY() {
        return renderScaleY;
    }

    public float getOutputScaleX() {
        return outputScaleX;
    }

    public float getOutputScaleY() {
        return outputScaleY;
    }

    protected abstract int _getEmbeddedX(long ptr);
    protected abstract int _getEmbeddedY(long ptr);

    private void checkScreenLocation() {
        this.x = _getEmbeddedX(ptr);
        this.y = _getEmbeddedY(ptr);
        if ((this.x != lastKnownEmbeddedX) || (this.y != lastKnownEmbeddedY)) {
            lastKnownEmbeddedX = this.x;
            lastKnownEmbeddedY = this.y;
            handleWindowEvent(System.nanoTime(), WindowEvent.MOVE);
        }
    }

    public int getX() {
        Application.checkEventThread();
        return this.x;
    }

    public int getY() {
        Application.checkEventThread();
        return this.y;
    }

    public int getWidth() {
        Application.checkEventThread();
        return this.width;
    }

    public int getHeight() {
        Application.checkEventThread();
        return this.height;
    }

    protected abstract void _setBounds(long ptr, int x, int y, boolean xSet, boolean ySet,
                                       int w, int h, int cw, int ch,
                                       float xGravity, float yGravity);

    /**
     * Sets the window bounds to the specified values.
     *
     * Gravity values specify how to correct window location if only its size
     * changes (for example when stage decorations are added). User initiated
     * resizing should be ignored and must not influence window location through
     * this mechanism.
     *
     * The corresponding correction formulas are:
     *
     * {@code x -= xGravity * deltaW}
     * {@code y -= yGravity * deltaH}
     *
     * @param x the new window horizontal position, ignored if xSet is set to
     *          false
     * @param y the new window vertical position, ignored if ySet is set to
     *          false
     * @param xSet indicates whether the x parameter is valid
     * @param ySet indicates whether the y parameter is valid
     * @param w the new window width, ignored if set to -1
     * @param h the new window height, ignored if set to -1
     * @param cw the new window content width, ignored if set to -1
     * @param ch the new window content height, ignored if set to -1
     * @param xGravity the xGravity coefficient
     * @param yGravity the yGravity coefficient
     */
    public void setBounds(float x, float y, boolean xSet, boolean ySet,
                          float w, float h, float cw, float ch,
                          float xGravity, float yGravity)
    {
        Application.checkEventThread();
        checkNotClosed();
        float pScaleX = platformScaleX;
        float pScaleY = platformScaleY;
        int px = screen.getPlatformX() + Math.round((x - screen.getX()) * pScaleX);
        int py = screen.getPlatformY() + Math.round((y - screen.getY()) * pScaleY);
<A NAME="26"></A>        int pw = (int) (w &gt; 0 ? Math.ceil(w * pScaleX) : w);
        int ph = (int) (h &gt; 0 ? Math.ceil(h * pScaleY) : h);
        int pcw = (int) (cw &gt; 0 ? Math.ceil(cw * pScaleX) : cw);
        int pch = (int) (ch &gt; 0 ? <FONT color="#95b9c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#26',2,'match31-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Math.ceil(ch * pScaleY) : ch);
        _setBounds(ptr, px, py, xSet, ySet, pw, ph, pcw, pch, xGravity, yGravity);
    }

    public void setPosition(int x, int y) {
        Application.checkEventThread();
        checkNotClosed();
        _setBounds(ptr, x, y, true, true, 0, 0, 0, 0, 0, 0);
    }

    public void setSize(int w, int h) {
        Application.checkEventThread();
        checkNotClosed();
        _setBounds(ptr, 0, 0, false, false, w, h, 0, 0, 0, 0);
    }

    public void setContentSize(int cw, int ch) {
        Application.checkEventThread</B></FONT>();
        checkNotClosed();
        _setBounds(ptr, 0, 0, false, false, 0, 0, cw, ch, 0, 0);
    }

    public boolean isVisible() {
        Application.checkEventThread();
        return this.isVisible;
    }

    /**
     * Generates a ViewEvent.MOVE aka insets (might have) changed.
     */
    private void synthesizeViewMoveEvent() {
        final View view = getView();
        if (view != null) {
            view.notifyView(com.sun.glass.events.ViewEvent.MOVE);
        }
    }

    protected abstract boolean _setVisible(long ptr, boolean visible);
    public void setVisible(final boolean visible) {
        Application.checkEventThread();
        if (this.isVisible != visible) {
            if (!visible) {
                if (getView() != null) {
                    getView().setVisible(visible);
                }
                // Avoid native call if the window has been closed already
                if (this.ptr != 0L) {
                    this.isVisible = _setVisible(this.ptr, visible);
                } else {
                    this.isVisible = visible;
                }
                remove(this);
                if (parent != 0) {
                    embeddedLocationTimer.stop();
                }
            } else {
                checkNotClosed();
                this.isVisible = _setVisible(this.ptr, visible);

                if (getView() != null) {
                    getView().setVisible(this.isVisible);
                }
                add(this);
                if (parent != 0) {
                    final Runnable checkRunnable = () -&gt; checkScreenLocation();
                    final Runnable timerRunnable = () -&gt; Application.invokeLater(checkRunnable);
                    embeddedLocationTimer =
                           Application.GetApplication().createTimer(timerRunnable);
                    embeddedLocationTimer.start(16);
                }

                synthesizeViewMoveEvent();
            }
        }
    }

    protected abstract boolean _setResizable(long ptr, boolean resizable);
    public boolean setResizable(final boolean resizable) {
        Application.checkEventThread();
        checkNotClosed();
        if (this.isResizable != resizable) {
            if (_setResizable(this.ptr, resizable)) {
                this.isResizable = resizable;
                synthesizeViewMoveEvent();
            }
        }
        return isResizable;
    }

    public boolean isResizable() {
        Application.checkEventThread();
        return this.isResizable;
    }

    public boolean isUnifiedWindow() {
        //The UNIFIED flag is set only if it is supported
        return (this.styleMask &amp; Window.UNIFIED) != 0;
    }

    public boolean isTransparentWindow() {
        //The TRANSPARENT flag is set only if it is supported
        return (this.styleMask &amp; Window.TRANSPARENT) != 0;
    }

    private static volatile Window focusedWindow = null;
    public static Window getFocusedWindow() {
        Application.checkEventThread();
        return Window.focusedWindow;
    }

    private static void setFocusedWindow(final Window window) {
        Window.focusedWindow = window;
    }

    public boolean isFocused() {
        Application.checkEventThread();
        return this.isFocused;
    }

    protected abstract boolean _requestFocus(long ptr, int event);
    /**
     * Requests or resigns focus on this window.
     *
     * If this is a top-level window (owned or not), then the only possible
     * value for the {@code event} argument is WindowEvent.FOCUS_GAINED.
     * Otherwise, if the window is a child window, the argument may be
     * WindowEvent.FOCUS_LOST, FOCUS_GAINED, FOCUS_GAINED_FORWARD, or
     * FOCUS_GAINED_BACKWARD.
     *
     * @param event one of WindowEvent.FOCUS_LOST, FOCUS_GAINED, FOCUS_GAINED_FORWARD, FOCUS_GAINED_BACKWARD
     *
     * @throws IllegalArgumentException if the argument value is invalid for this window
     *
     * @return {@code true} if the operation succeeded
     */
    public boolean requestFocus(int event) {
        Application.checkEventThread();
        checkNotClosed();

        if (!isChild() &amp;&amp; event != WindowEvent.FOCUS_GAINED) {
            throw new IllegalArgumentException(&quot;Invalid focus event ID for top-level window&quot;);
        }

        if (isChild() &amp;&amp; (event &lt; WindowEvent._FOCUS_MIN || event &gt; WindowEvent._FOCUS_MAX)) {
            throw new IllegalArgumentException(&quot;Invalid focus event ID for child window&quot;);
        }

        if (event == WindowEvent.FOCUS_LOST &amp;&amp; !isFocused()) {
            // Already unfocused, nothing to do
            return true;
        }

        // At this point either A) the user requests focus for a focused or unfocused window,
        // or B) the window is focused and the user requests FOCUS_LOST
        if (!this.isFocusable) {
            // It's obviously A). Fail.
            return false;
        }

        return _requestFocus(this.ptr, event);
    }

    public boolean requestFocus() {
        Application.checkEventThread();
        return requestFocus(WindowEvent.FOCUS_GAINED);
    }

    protected abstract void _setFocusable(long ptr, boolean isFocusable);
    /**
     * Sets whether this window is focusable.
     *
     * Clicking an unfocusable window doesn't activate it.
     */
    public void setFocusable(final boolean isFocusable) {
        Application.checkEventThread();
        checkNotClosed();
        this.isFocusable = isFocusable;
        if (isEnabled()) {
            _setFocusable(this.ptr, isFocusable);
        }
    }

    protected abstract boolean _grabFocus(long ptr);
    protected abstract void _ungrabFocus(long ptr);
    /**
     * Grabs focus on this window.
     *
     * All mouse clicks that occur in this window's client area or client-areas
     * of any of its unfocusable owned windows are delivered as usual. Whenever
     * a click occurs on another app's window (not related via the ownership
     * relation with this one, or a focusable owned window), or on non-client
     * area of any window (titlebar, etc.), or any third-party app's window, or
     * native OS GUI (e.g. a taskbar), the grab is automatically reset, and the
     * window that held the grab receives the FOCUS_UNGRAB event.
     *
     * Note that for this functionality to work correctly, the window must have
     * a focus upon calling this method. All owned popup windows that should be
     * operable during the grabbed focus state (e.g. nested popup menus) must
     * be unfocusable (see {@link #setFocusable}). Clicking a focusable owned
     * window will reset the grab due to a focus transfer.
     *
     * The click that occurs in another window and causes resetting of the grab
     * may or may not be delivered to that other window depending on the native
     * OS behavior.
     *
     * If any of the application's windows already holds the grab, it is reset
     * prior to grabbing the focus for this window. The method may be called
     * multiple times for one window. Subsequent calls do not affect the grab
     * status unless it is reset between the calls, in which case the focus
     * is grabbed again.
     *
     * Note that grabbing the focus on an application window may prevent
     * delivering certain events to other applications until the grab is reset.
     * Therefore, if the application has finished showing popup windows based
     * on a user action (e.g. clicking a menu item), and doesn't require the
     * grab any more, it should call the {@link #ungrabFocus} method. The
     * FOCUS_UNGRAB event signals that the grab has been reset.
     *
     * A user event handler associated with a menu item must be invoked after
     * resetting the grab. Otherwise, if a developer debugs the application and
     * has installed a breakpoint in the event handler, the debugger may become
     * unoperable due to events blocking for other applications on some
     * platforms.
     *
     * @return {@code true} if the operation is successful
     * @throws IllegalStateException if the window isn't focused currently
     */
    public boolean grabFocus() {
        Application.checkEventThread();
        checkNotClosed();

        if (!isFocused()) {
            throw new IllegalStateException(&quot;The window must be focused when calling grabFocus()&quot;);
        }

        return _grabFocus(this.ptr);
    }

    /**
     * Manually ungrabs focus grabbed on this window previously.
     *
     * This method resets the grab, and forces sending of the FOCUS_UNGRAB
     * event. It should be used when popup windows (such as menus) should be
     * dismissed manually, e.g. when a user clicks a menu item which usually
     * causes the menus to hide.
     *
     * @see #grabFocus
     */
    public void ungrabFocus() {
        Application.checkEventThread();
        checkNotClosed();
        _ungrabFocus(this.ptr);
    }

    public String getTitle() {
        Application.checkEventThread();
        return this.title;
    }

    protected abstract boolean _setTitle(long ptr, String title);
    public void setTitle(String title) {
        Application.checkEventThread();
        checkNotClosed();
        if (title == null) {
            title = &quot;&quot;;
        }
        if (!title.equals(this.title)) {
            if (_setTitle(this.ptr, title)) {
                this.title = title;
            }
        }
    }

    protected abstract void _setLevel(long ptr, int level);
    /**
     * Set the level of this window in the z-order.
     *
     * @param level one of the constants from {@link Window.Level}
     * @see Window.Level
     */
    public void setLevel(final int level) {
        Application.checkEventThread();
        checkNotClosed();
        if (level &lt; Level._MIN || level &gt; Level._MAX) {
            throw new IllegalArgumentException(&quot;Level should be in the range [&quot; + Level._MIN + &quot;..&quot; + Level._MAX + &quot;]&quot;);
        }
        if (this.level != level) {
            _setLevel(this.ptr, level);
            this.level = level;
        }
    }

    public int getLevel() {
        Application.checkEventThread();
        return this.level;
    }

    private boolean isInFullscreen() {
        final View view = getView();
        return view == null ? false : view.isInFullscreen();
    }

    // Invoked from the View class before sending FULLSCREEN_ to the View.EventHandler
    void notifyFullscreen(boolean entered) {
        final float alpha = getAlpha();
        if (alpha &lt; 1f) {
            if (entered) {
                // Reset alpha at native level
                _setAlpha(this.ptr, 1f);
            } else {
                // restore the current opacity level
                setAlpha(alpha);
            }
        }
    }

    protected abstract void _setAlpha(long ptr, float alpha);
    /**
     * Sets the uniform translucency level for this window.
     *
     * In the full screen mode the native window is always fully opaque.
     * The requested opacity level is applied upon exiting the full screen
     * mode only.
     *
     * @param alpha a value in the range [0..1f] (transparent..fully-opaque)
     */
    public void setAlpha(final float alpha) {
        Application.checkEventThread();
        checkNotClosed();
        if (alpha &lt; 0f || alpha &gt; 1f) {
            throw new IllegalArgumentException(&quot;Alpha should be in the range [0f..1f]&quot;);
        }

        this.alpha = alpha;

        if (alpha &lt; 1f &amp;&amp; isInFullscreen()) {
            return;
        }

        _setAlpha(this.ptr, this.alpha);
    }

    public float getAlpha() {
        Application.checkEventThread();
        return this.alpha;
    }

    public boolean getAppletMode() {
        return appletMode;
    }

    public void setAppletMode(boolean appletMode) {
        this.appletMode = appletMode;
    }

    protected abstract boolean _setBackground(long ptr, float r, float g, float b);
    /**
     * Set the background of the window.
     *
     * In most cases the View covers the whole window, so the background color
     * of the window is never seen by the user. However, a window w/o a view
     * does display the background color in its content area.
     *
     * On some platforms setting the background color may produce flickering
     * when painting the content area of the View (even though the View covers
     * the whole window).  Therefore it is recommended to set the background
     * color to windows w/o views only.
     */
    public boolean setBackground(final float r, final float g, final float b) {
        Application.checkEventThread();
        checkNotClosed();
        return _setBackground(this.ptr, r, g, b);
    }

    public boolean isEnabled() {
        Application.checkEventThread();
        return this.disableCount == 0;
    }

    protected abstract void _setEnabled(long ptr, boolean enabled);
    /**
     * Enables or disables the window.
     *
     * A disabled window is unfocusable by definition.
     * Also, key or mouse events aren't generated for disabled windows.
     *
     * When a user tries to activate a disabled window, or the window gets
     * accidentally brought to the top of the stacking order, the window
     * generates the FOCUS_DISABLED window event. A Glass client should react
     * to this event and bring the currently active modal blocker of the
     * disabled window to top by calling blocker's minimize(false), toFront(),
     * and requestFocus() methods. It may also 'blink' the blocker window to
     * further attract user's attention.
     *
     * It's strongly recommended to process the FOCUS_DISABLED event
     * synchronously and as fast as possible to avoid any possible visual and
     * behavioral artifacts. Note that a disabled window may by no means gain
     * the input focus. The purpose of this event is to make sure that the
     * current modal blocker window is always visible to the user, and the user
     * understands why he can't interact with a disabled window.
     *
     * The method supports nested calls. If you disable the window twice
     * with two calls to setEnabled(false), you must call setEnabled(true)
     * twice as well in order to enable it afterwards. This is to support
     * 'nested' modal dialogs when one modal dialog opens another one.
     */
    public void setEnabled(boolean enabled) {
        Application.checkEventThread();
        checkNotClosed();
        if (!enabled) {
            if (++this.disableCount &gt; 1) {
                // already disabled
                return;
            }
        } else {
            if (this.disableCount == 0) {
                //should report a warning about an extra enable call ?
                return;
            }
            if (--this.disableCount &gt; 0) {
                // not yet enabled
                return;
            }
        }

        //TODO: on Windows _setFocusable(this.ptr, isEnabled() ? this.isFocusable : false);
        _setEnabled(this.ptr, isEnabled());
    }

    public int getMinimumWidth() {
        Application.checkEventThread();
        return this.minimumWidth;
    }

    public int getMinimumHeight() {
        Application.checkEventThread();
        return this.minimumHeight;
    }

    public int getMaximumWidth() {
        Application.checkEventThread();
        return this.maximumWidth;
    }

    public int getMaximumHeight() {
        Application.checkEventThread();
        return this.maximumHeight;
    }

    protected abstract boolean _setMinimumSize(long ptr, int width, int height);
    /**
     * Sets the minimum size for this window.
     * A value of zero indicates no restriction.
     * If the native platform is unable to apply the constraints,
     * the values returned by getMinimumWidth()/Height() won't change.
     *
     * @throws IllegalArgumentException if width or height &lt; 0
     */
    public void setMinimumSize(int width, int height) {
        Application.checkEventThread();
        if (width &lt; 0 || height &lt; 0) {
            throw new IllegalArgumentException(&quot;The width and height must be &gt;= 0. Got: width=&quot; + width + &quot;; height=&quot; + height);
        }
        checkNotClosed();
        if (_setMinimumSize(this.ptr, width, height)) {
            this.minimumWidth = width;
            this.minimumHeight = height;
        }
    }

    protected abstract boolean _setMaximumSize(long ptr, int width, int height);
    /**
     * Sets the maximum size for this window.
     * A value of {@code Integer.MAX_VALUE} indicates no restriction.
     * If the native platform is unable to apply the constraints,
     * the values returned by getMaximumWidth()/Height() won't change.
     *
     * @throws IllegalArgumentException if width or height &lt; 0
     */
    public void setMaximumSize(int width, int height) {
        Application.checkEventThread();
        if (width &lt; 0 || height &lt; 0) {
            throw new IllegalArgumentException(&quot;The width and height must be &gt;= 0. Got: width=&quot; + width + &quot;; height=&quot; + height);
        }
        checkNotClosed();
        if (_setMaximumSize(this.ptr,
                    // for easier handling in native:
                    width == Integer.MAX_VALUE ? -1 : width,
                    height == Integer.MAX_VALUE ? -1 : height))
        {
            this.maximumWidth = width;
            this.maximumHeight = height;
        }
    }


    protected abstract void _setIcon(long ptr, Pixels pixels);

    // In the future we may want to pass a collection of Pixels, so that
    // the native platform could pick up the icon with the best dimensions
    public void setIcon(final Pixels pixels) {
        Application.checkEventThread();
        checkNotClosed();
        _setIcon(this.ptr, pixels);
    }

    protected abstract void _setCursor(long ptr, Cursor cursor);

    /**
     * Sets given cursor as the cursor for this window.
     * If the cursor is NONE, it is automatically hidden,
     * otherwise it is automatically shown.
     * @see Cursor#setVisible(boolean)
     */
    public void setCursor(Cursor cursor) {
        Application.checkEventThread();
        _setCursor(this.ptr, cursor);
    }

    protected abstract void _toFront(long ptr);
    /**
     * Bring the window to front in the z-order.
     * This method DOES NOT activate the window. To make it active use
     * the requestFocus() method right after calling toFront().
     */
    public void toFront() {
        Application.checkEventThread();
        checkNotClosed();
        _toFront(ptr);
    }

    protected abstract void _toBack(long ptr);
    /**
     * Send the window to the bottom of the stacking order.
     * This method may or may not de-focus this window
     * depending on the native platform. To make sure some other
     * window is activated, call requestFocus() on that other window.
     */
    public void toBack() {
        Application.checkEventThread();
        checkNotClosed();
        _toBack(this.ptr);
    }

    // *****************************************************
    // modality (prototype using native platform feature)
    // *****************************************************
    protected abstract void _enterModal(long ptr);
    /**
     * Enter modal state blocking everything except our window.
     */
    public void enterModal() {
        checkNotClosed();
        if (this.isModal == false) {
            this.isModal = true;
            _enterModal(this.ptr);
        }
    }

    protected abstract void _enterModalWithWindow(long dialog, long window);
    /**
     * Enter modal state only blocking the given window.
     * On Mac OS X this is done using a dialog sheet.
     */
    public void enterModal(final Window window) {
        checkNotClosed();
        if (this.isModal == false) {
            this.isModal = true;
            _enterModalWithWindow(this.ptr, window.getNativeHandle());
        }
    }

    protected abstract void _exitModal(long ptr);
    public void exitModal() {
        checkNotClosed();
        if (this.isModal == true) {
            _exitModal(this.ptr);
            this.isModal = false;
        }
    }

    public boolean isModal() {
        return this.isModal;
    }

    /** Only used on Mac when run inside a plugin */
    public void dispatchNpapiEvent(Map eventInfo) {
        Application.checkEventThread();
        throw new RuntimeException(&quot;This operation is not supported on this platform&quot;);
    }

    public EventHandler getEventHandler() {
        Application.checkEventThread();
        return eventHandler;
    }

    public void setEventHandler(EventHandler eventHandler) {
        Application.checkEventThread();
        this.eventHandler = eventHandler;
    }

    /**
     * Enables unconditional start of window move operation when
     * mouse is dragged in the client area.
     */
    public void setShouldStartUndecoratedMove(boolean v) {
        Application.checkEventThread();
        this.shouldStartUndecoratedMove = v;
    }

    // *****************************************************
    // notification callbacks
    // *****************************************************
    protected void notifyClose() {
        handleWindowEvent(System.nanoTime(), WindowEvent.CLOSE);
    }

    protected void notifyDestroy() {
        // Mac is known to send multiple WillClose notifications for some reason
        if (this.ptr == 0) {
            return;
        }

        handleWindowEvent(System.nanoTime(), WindowEvent.DESTROY);

        this.ptr = 0;

        // Do this after setting ptr to 0 to avoid a call to _setVisible()
        setVisible(false);
    }

    protected void notifyMove(final int x, final int y) {
        this.x = x;
        this.y = y;
        handleWindowEvent(System.nanoTime(), WindowEvent.MOVE);
    }

    protected void notifyRescale() {
        handleWindowEvent(System.nanoTime(), WindowEvent.RESCALE);
    }

    protected void notifyMoveToAnotherScreen(Screen newScreen) {
        setScreen(newScreen);
    }

    protected void setState(int state) {
        this.state = state;
    }

    /**
     * type values:
     *   - WindowEvent.RESIZE
     *   - WindowEvent.MINIMIZE
     *   - WindowEvent.MAXIMIZE
     *   - WindowEvent.RESTORE
     */
    protected void notifyResize(final int type, final int width, final int height) {
        if (type == WindowEvent.MINIMIZE) {
            this.state = State.MINIMIZED;
        } else {
            if (type == WindowEvent.MAXIMIZE) {
                this.state = State.MAXIMIZED;
            } else { // WindowEvent.RESIZE or WindowEvent.RESTORE
                this.state = State.NORMAL;
            }
            this.width = width;
            this.height = height;

            // update moveRect/resizeRect
            if (this.helper != null){
                this.helper.updateRectangles();
            }
        }
        handleWindowEvent(System.nanoTime(), type);

        /*
         * Send RESIZE notification as MAXIMIZE and RESTORE change the window size
         */
        if (type == WindowEvent.MAXIMIZE || type == WindowEvent.RESTORE) {
            handleWindowEvent(System.nanoTime(), WindowEvent.RESIZE);
        }
    }

    protected void notifyFocus(int event) {
        final boolean focused = event != WindowEvent.FOCUS_LOST;

        if (this.isFocused != focused) {
            this.isFocused = focused;
            if (this.isFocused) {
                setFocusedWindow(this);
            } else {
                setFocusedWindow(null);
            }
            handleWindowEvent(System.nanoTime(), event);
        }
    }

    protected void notifyFocusDisabled() {
        handleWindowEvent(System.nanoTime(), WindowEvent.FOCUS_DISABLED);
    }

    protected void notifyFocusUngrab() {
        handleWindowEvent(System.nanoTime(), WindowEvent.FOCUS_UNGRAB);
    }

    protected void notifyDelegatePtr(long ptr) {
        this.delegatePtr = ptr;
    }

    // *****************************************************
    // window event handlers
    // *****************************************************
    protected void handleWindowEvent(long time, int type) {
        if (this.eventHandler != null) {
            this.eventHandler.handleWindowEvent(this, time, type);
        }
    }

    // *****************************************************
    // programmatical move/resize
    // *****************************************************
    /** Sets &quot;programmatical move&quot; rectangle.
     * The rectangle is measured from top of the View:
     * width is View.width, height is size.
     *
     * throws RuntimeException for decorated window.
     */
    public void setUndecoratedMoveRectangle(int size) {
        Application.checkEventThread();
        if (this.isDecorated == true) {
            //throw new RuntimeException(&quot;setUndecoratedMoveRectangle is only valid for Undecorated Window&quot;);
            System.err.println(&quot;Glass Window.setUndecoratedMoveRectangle is only valid for Undecorated Window. In the future this will be hard error.&quot;);
            Thread.dumpStack();
            return;
        }

        if (this.helper != null) {
            this.helper.setMoveRectangle(size);
        }
    }
    /** The method called only for undecorated windows
     * x, y: mouse coordinates (in View space).
     *
     * throws RuntimeException for decorated window.
     */
    public boolean shouldStartUndecoratedMove(final int x, final int y) {
        Application.checkEventThread();
        if (this.shouldStartUndecoratedMove == true) {
            return true;
        }
        if (this.isDecorated == true) {
            return false;
        }

        if (this.helper != null) {
            return this.helper.shouldStartMove(x, y);
        } else {
            return false;
        }
    }

    /** Sets &quot;programmatical resize&quot; rectangle.
     * The rectangle is measured from top of the View:
     * width is View.width, height is size.
     *
     * throws RuntimeException for decorated window.
     */
    public void setUndecoratedResizeRectangle(int size) {
        Application.checkEventThread();
        if ((this.isDecorated == true) || (this.isResizable == false)) {
            //throw new RuntimeException(&quot;setUndecoratedMoveRectangle is only valid for Undecorated Resizable Window&quot;);
            System.err.println(&quot;Glass Window.setUndecoratedResizeRectangle is only valid for Undecorated Resizable Window. In the future this will be hard error.&quot;);
            Thread.dumpStack();
            return;
        }

        if (this.helper != null) {
            this.helper.setResizeRectangle(size);
        }
    }

    /** The method called only for undecorated windows
     * x, y: mouse coordinates (in View space).
     *
     * throws RuntimeException for decorated window.
     */
    public boolean shouldStartUndecoratedResize(final int x, final int y) {
        Application.checkEventThread();
        if ((this.isDecorated == true) || (this.isResizable == false)) {
            return false;
        }

        if (this.helper != null) {
            return this.helper.shouldStartResize(x, y);
        }  else {
            return false;
        }
    }

    /** Mouse event handler for processing programmatical resize/move
     * (for undecorated windows only).
     * Must be called by View.
     * x &amp; y are View coordinates.
     * NOTE: it's package private!
     * @return true if the event is processed by the window,
     *         false if it has to be delivered to the app
     */
    boolean handleMouseEvent(int type, int button, int x, int y, int xAbs, int yAbs) {
        if (this.isDecorated == false) {
            return this.helper.handleMouseEvent(type, button, x, y, xAbs, yAbs);
        }
        return false;
    }

    @Override
    public String toString() {
        Application.checkEventThread();
        return  &quot;Window:&quot;+&quot;\n&quot;
                + &quot;    ptr: &quot; + getNativeWindow() + &quot;\n&quot;
                + &quot;    screen ptr: &quot; + (screen != null ? screen.getNativeScreen() : &quot;null&quot;) + &quot;\n&quot;
                + &quot;    isDecorated: &quot; + isDecorated() + &quot;\n&quot;
                + &quot;    title: &quot; + getTitle() + &quot;\n&quot;
                + &quot;    visible: &quot; + isVisible() + &quot;\n&quot;
                + &quot;    focused: &quot; + isFocused() + &quot;\n&quot;
                + &quot;    modal: &quot; + isModal() + &quot;\n&quot;
                + &quot;    state: &quot; + state + &quot;\n&quot;
                + &quot;    x: &quot; + getX() + &quot;, y: &quot; + getY() + &quot;, w: &quot; + getWidth() + &quot;, h: &quot; + getHeight() + &quot;\n&quot;
                + &quot;&quot;;
    }

    // &quot;programmical&quot; move/resize support for undecorated windows

    static private class TrackingRectangle {
        int size = 0;
        int x = 0, y = 0, width = 0, height = 0;
        boolean contains(final int x, final int y) {
            return ((size &gt; 0) &amp;&amp;
                    (x &gt;= this.x) &amp;&amp; (x &lt; (this.x + this.width)) &amp;&amp;
                        (y &gt;= this.y) &amp;&amp; (y &lt; (this.y + this.height)));
        }
    }

    protected void notifyLevelChanged(int level) {
        this.level = level;
        if (this.eventHandler != null) {
            this.eventHandler.handleLevelEvent(level);
        }
    }

    private class UndecoratedMoveResizeHelper {
        TrackingRectangle moveRect = null;
        TrackingRectangle resizeRect = null;

        boolean inMove = false;         // we are in &quot;move&quot; mode
        boolean inResize = false;       // we are in &quot;resize&quot; mode

        int startMouseX, startMouseY;   // start mouse coords
        int startX, startY;             // start window location (for move)
        int startWidth, startHeight;    // start window size (for resize)

        UndecoratedMoveResizeHelper() {
            this.moveRect = new TrackingRectangle();
            this.resizeRect = new TrackingRectangle();
        }

        void setMoveRectangle(final int size) {
            this.moveRect.size = size;

            this.moveRect.x = 0;
            this.moveRect.y = 0;
            this.moveRect.width = getWidth();
            this.moveRect.height = this.moveRect.size;
        }

        boolean shouldStartMove(final int x, final int y) {
            return this.moveRect.contains(x, y);
        }

        boolean inMove() {
            return this.inMove;
        }

        void startMove(final int x, final int y) {
            this.inMove = true;

            this.startMouseX = x;
            this.startMouseY = y;

            this.startX = getX();
            this.startY = getY();
        }

        void deltaMove(final int x, final int y) {
            int deltaX = x - this.startMouseX;
            int deltaY = y - this.startMouseY;

            setPosition(this.startX + deltaX, this.startY + deltaY);
        }

        void stopMove() {
            this.inMove = false;
        }

        void setResizeRectangle(final int size) {
            this.resizeRect.size = size;

            // set the rect (bottom right corner of the Window)
            this.resizeRect.x = getWidth() - this.resizeRect.size;
            this.resizeRect.y = getHeight() - this.resizeRect.size;
            this.resizeRect.width = this.resizeRect.size;
            this.resizeRect.height = this.resizeRect.size;
        }

        boolean shouldStartResize(final int x, final int y) {
            return this.resizeRect.contains(x, y);
        }

        boolean inResize() {
            return this.inResize;
        }

        void startResize(final int x, final int y) {
            this.inResize = true;

            this.startMouseX = x;
            this.startMouseY = y;

            this.startWidth = getWidth();
            this.startHeight = getHeight();
        }

        void deltaResize(final int x, final int y) {
            int deltaX = x - this.startMouseX;
            int deltaY = y - this.startMouseY;

            setSize(this.startWidth + deltaX, this.startHeight + deltaY);
        }

        protected void stopResize() {
            this.inResize = false;
        }

        void updateRectangles() {
            if (this.moveRect.size &gt; 0) {
                setMoveRectangle(this.moveRect.size);
            }
            if (this.resizeRect.size &gt; 0) {
                setResizeRectangle(this.resizeRect.size);
            }
        }

        boolean handleMouseEvent(final int type, final int button, final int x, final int y, final int xAbs, final int yAbs) {
            switch (type) {
                case MouseEvent.DOWN:
                    if (button == MouseEvent.BUTTON_LEFT) {
                        if (shouldStartUndecoratedMove(x, y) == true) {
                            startMove(xAbs, yAbs);
                            return true;
                        } else if (shouldStartUndecoratedResize(x, y) == true) {
                            startResize(xAbs, yAbs);
                            return true;
                        }
                    }
                    break;

                case MouseEvent.MOVE:
                case MouseEvent.DRAG:
                    if (inMove() == true) {
                        deltaMove(xAbs, yAbs);
                        return true;
                    } else if (inResize() == true) {
                        deltaResize(xAbs, yAbs);
                        return true;
                    }
                    break;

                case MouseEvent.UP:
                    boolean wasProcessed = inMove() || inResize();
                    stopResize();
                    stopMove();
                    return wasProcessed;
            }
            return false;
        }
    }

    /**
     * Requests text input in form of native keyboard for text component
     * contained by this Window. Native text input component is drawn on the place
     * of JavaFX component to cover it completely and to provide native text editing
     * techniques. Any change of text is immediately reflected in JavaFX text component.
     *
     * @param text text to be shown in the native text input component
     * @param type type of text input component @see com.sun.javafx.scene.control.behavior.TextInputTypes
     * @param width width of JavaFX text input component
     * @param height height of JavaFX text input component
     * @param M standard transformation matrix for drawing the native text component derived from JavaFX component
     */
    public void requestInput(String text, int type, double width, double height,
                                double Mxx, double Mxy, double Mxz, double Mxt,
                                double Myx, double Myy, double Myz, double Myt,
                                double Mzx, double Mzy, double Mzz, double Mzt) {
        Application.checkEventThread();
        _requestInput(this.ptr, text, type, width, height,
                        Mxx, Mxy, Mxz, Mxt,
                        Myx, Myy, Myz, Myt,
                        Mzx, Mzy, Mzz, Mzt);
    }

    /**
     * Native keyboard for text input is no longer necessary.
     * Keyboard will be hidden and native text input component too.
     */
    public void releaseInput() {
        Application.checkEventThread();
        _releaseInput(this.ptr);
    }

    protected abstract void _requestInput(long ptr, String text, int type, double width, double height,
                                            double Mxx, double Mxy, double Mxz, double Mxt,
                                            double Myx, double Myy, double Myz, double Myt,
                                            double Mzx, double Mzy, double Mzz, double Mzt);

    protected abstract void _releaseInput(long ptr);

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/AndroidInputProcessor.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui.monocle;

class AndroidInputProcessor {

    private final AndroidInputDevice device;
    final TouchPipeline touchPipeline;
    private final KeyInput keyInput = new KeyInput();

<A NAME="18"></A>    AndroidInputProcessor(AndroidInputDevice device) {
        this.device = device;
        touchPipeline = new TouchPipeline();
        <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#18',2,'match31-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>touchPipeline.add(TouchInput.getInstance().getBasePipeline());
    }

    void pushEvent(TouchState state) {
        touchPipeline.pushState(state);
    }

    /**
     * Called when events are waiting on the input device to be processed.
     * Called on the runnable processor provided to the input device.
     *
     * @param device The device on which events are pending
     */
    void processEvents(AndroidInputDevice device) {
        touchPipeline.pushState(null);
    }

    synchronized void pushKeyEvent(KeyState keyState) {
        keyInput.setState(keyState);
    }

}</B></FONT>
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/win/WinMenuDelegate.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui.win;

import com.sun.glass.ui.Menu;
import com.sun.glass.ui.Pixels;
import com.sun.glass.ui.delegate.MenuDelegate;
import com.sun.glass.ui.delegate.MenuItemDelegate;

final class WinMenuDelegate extends WinMenuImpl implements MenuDelegate {

    final private Menu owner;
    private WinMenuImpl parent = null;

    public WinMenuDelegate(Menu menu) {
        this.owner = menu;
    }


    public Menu getOwner() {
<A NAME="48"></A>        return owner;
    }

    @Override public boolean createMenu(String title, boolean enabled) <FONT color="#c57726"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#48',2,'match31-top.html#48',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        return create();
    }

    public void dispose() {
        destroy();
    }</B></FONT>

    // all methods report success status (true - success, false - failure)

    @Override public boolean setTitle(String title) {
        if (parent != null) {
            return parent.setSubmenuTitle(this, title);
        }
        return true;
    }

    @Override public boolean setEnabled(boolean enabled) {
        if (parent != null) {
            return parent.enableSubmenu(this, enabled);
        }
        return true;
    }

    @Override public boolean setPixels(Pixels pixels) {
        // TODO: implement images in menuItem
        return false;
    }

    @Override public boolean insert(MenuDelegate menu, int pos) {
        return insertSubmenu((WinMenuDelegate)menu, pos);
    }

    // if item == null =&gt; insert Separator
    @Override public boolean insert(MenuItemDelegate item, int pos) {
        return insertItem((WinMenuItemDelegate)item, pos);
    }

    // removes submenu at {@code pos} which delegate is {@code menu} parameter
    @Override public boolean remove(MenuDelegate menu, int pos) {
        return removeMenu((WinMenuDelegate)menu, pos);
    }

    // removes submenu at {@code pos} which delegate is {@code item} parameter
    @Override public boolean remove(MenuItemDelegate item, int pos) {
        return removeItem((WinMenuItemDelegate)item, pos);
    }

    WinMenuImpl getParent() {
        return parent;
    }

    void setParent(WinMenuImpl newParent) {
        parent = newParent;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/font/CompositeStrike.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.font;

import com.sun.javafx.scene.text.GlyphList;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.Point2D;
import com.sun.javafx.geom.Shape;

public class CompositeStrike implements FontStrike {

    private CompositeFontResource fontResource;
    private float size;
    private int aaMode;
    BaseTransform transform;
    private FontStrike slot0Strike;
    private FontStrike[] strikeSlots;

    private FontStrikeDesc desc;
    DisposerRecord disposer;

    public void clearDesc() {
        fontResource.getStrikeMap().remove(desc);
        // For a composite strike, you also need to remove the strike
        // refs of the raw fonts. At the least this needs to remove
        // the slot 0 strike, but it may be that the fallback strikes
        // should be left alone as they could be shared. This needs
        // to be re-visited.
        if (slot0Strike != null) {
            slot0Strike.clearDesc();
        }
        if (strikeSlots != null) {
            for (int i=1; i&lt;strikeSlots.length; i++) {
                if (strikeSlots[i] != null) {
                    strikeSlots[i].clearDesc();
                }
            }
        }
    }

    CompositeStrike(CompositeFontResource fontResource,
                    float size, BaseTransform graphicsTransform, int aaMode,
                    FontStrikeDesc desc) {

        this.fontResource = fontResource;
        this.size = size;
        if (graphicsTransform.isTranslateOrIdentity()) {
            this.transform = BaseTransform.IDENTITY_TRANSFORM;
        } else {
            this.transform = graphicsTransform.copy();
        }
        this.desc = desc;
        this.aaMode = aaMode;
        // CompositeStrikes do not directly hold any native resources
        // but we need to free the desc key from the strike map after
        // we find the strike has been GC'd.
        disposer = new CompositeStrikeDisposer(fontResource, desc);
    }

<A NAME="39"></A>    public int getAAMode() {
        PrismFontFactory factory = PrismFontFactory.getFontFactory();
        if (factory.isLCDTextSupported()) {
            <FONT color="#152dc6"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#39',2,'match31-top.html#39',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return this.aaMode;
        } else {
            return FontResource.AA_GREYSCALE;
        }
    }

    /**
     * Trusting caller to NOT mutate the returned result, to
     * avoid a clone.
     */
    public BaseTransform getTransform() {
        return transform;
    }

    public FontSt</B></FONT>rike getStrikeSlot(int slot) {
        if (slot == 0) {
            if (slot0Strike == null) {
                FontResource slot0Resource = fontResource.getSlotResource(0);
                slot0Strike = slot0Resource.getStrike(size, transform,
                                                      getAAMode());
            }
            return slot0Strike;
        } else {
            if (strikeSlots == null) {
                strikeSlots = new FontStrike[fontResource.getNumSlots()];
            }

            if (slot &gt;= strikeSlots.length) {
                FontStrike[] tmp = new FontStrike[fontResource.getNumSlots()];
                System.arraycopy(strikeSlots, 0, tmp, 0, strikeSlots.length);
                strikeSlots = tmp;
            }
            if (strikeSlots[slot] == null) {
                FontResource slotResource = fontResource.getSlotResource(slot);
                strikeSlots[slot] = slotResource.getStrike(size, transform,
                                                           getAAMode());
            }
            return strikeSlots[slot];
        }
    }

    public FontResource getFontResource() {
        return fontResource;
    }

    public int getStrikeSlotForGlyph(int glyphCode) {
        return (glyphCode &gt;&gt;&gt; 24);
    }

    public float getSize() {
        return size;
    }

    public boolean drawAsShapes() {
        return getStrikeSlot(0).drawAsShapes();
    }

    private PrismMetrics metrics;

    public Metrics getMetrics() {
        if (metrics == null) {
            PrismFontFile fr = (PrismFontFile)fontResource.getSlotResource(0);
            metrics = fr.getFontMetrics(size);
        }
        return metrics;
    }

    public Glyph getGlyph(char symbol) {
        int glyphCode = fontResource.getGlyphMapper().charToGlyph(symbol);
        return getGlyph(glyphCode);
    }

    public Glyph getGlyph(int glyphCode) {
        int slot = (glyphCode &gt;&gt;&gt; 24);
        int slotglyphCode = glyphCode &amp; CompositeGlyphMapper.GLYPHMASK;
        return getStrikeSlot(slot).getGlyph(slotglyphCode);
    }

     /**
     * Access to individual character advances are frequently needed for layout
     * understand that advance may vary for single glyph if ligatures or kerning
     * are enabled
     * @param ch char
     * @return advance of single char
     */
    public float getCharAdvance(char ch) {
        int glyphCode = fontResource.getGlyphMapper().charToGlyph((int)ch);
        return fontResource.getAdvance(glyphCode, size);
    }

    @Override
    public int getQuantizedPosition(Point2D point) {
        return getStrikeSlot(0).getQuantizedPosition(point);
    }

    public Shape getOutline(GlyphList gl, BaseTransform transform) {

        Path2D result = new Path2D();
        getOutline(gl, transform, result);
        return result;
    }

    void getOutline(GlyphList gl, BaseTransform transform, Path2D p) {
        p.reset();
        if (gl == null) {
            return;
        }
        if (transform == null) {
            transform = BaseTransform.IDENTITY_TRANSFORM;
        }
        Affine2D t = new Affine2D();
        for (int i = 0; i &lt; gl.getGlyphCount(); i++) {
            int glyphCode = gl.getGlyphCode(i);
            if (glyphCode != CharToGlyphMapper.INVISIBLE_GLYPH_ID) {
                Glyph glyph = getGlyph(glyphCode);
                Shape gp = glyph.getShape();
                if (gp != null) {
                    t.setTransform(transform);
                    t.translate(gl.getPosX(i), gl.getPosY(i));
                    p.append(gp.getPathIterator(t), false);
                }
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/font/LogicalFont.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.font;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import com.sun.javafx.geom.transform.BaseTransform;

/**
 * This acts as a factory class for the 12 logical composite font
 * resources which are available as well as providing the implementation
 * of the resource.
 */
public class LogicalFont implements CompositeFontResource {

    public static final String SYSTEM     = &quot;System&quot;;
    public static final String SERIF      = &quot;Serif&quot;;
    public static final String SANS_SERIF = &quot;SansSerif&quot;;
    public static final String MONOSPACED = &quot;Monospaced&quot;;

    public static final String STYLE_REGULAR     = &quot;Regular&quot;;
    public static final String STYLE_BOLD        = &quot;Bold&quot;;
    public static final String STYLE_ITALIC      = &quot;Italic&quot;;
    public static final String STYLE_BOLD_ITALIC = &quot;Bold Italic&quot;;

    static final HashMap&lt;String, String&gt;
        canonicalFamilyMap = new  HashMap&lt;String, String&gt;();
    static {
        canonicalFamilyMap.put(&quot;system&quot;, SYSTEM);

        canonicalFamilyMap.put(&quot;serif&quot;, SERIF);

        canonicalFamilyMap.put(&quot;sansserif&quot;, SANS_SERIF);
        canonicalFamilyMap.put(&quot;sans-serif&quot;, SANS_SERIF); // css style
        canonicalFamilyMap.put(&quot;dialog&quot;, SANS_SERIF);
        canonicalFamilyMap.put(&quot;default&quot;, SANS_SERIF);

        canonicalFamilyMap.put(&quot;monospaced&quot;, MONOSPACED);
        canonicalFamilyMap.put(&quot;monospace&quot;, MONOSPACED); // css style
        canonicalFamilyMap.put(&quot;dialoginput&quot;, MONOSPACED);
    }

    static boolean isLogicalFont(String name) {
        int spaceIndex = name.indexOf(' ');
        if (spaceIndex != -1) name = name.substring(0, spaceIndex);
        return canonicalFamilyMap.get(name) != null;
    }

    private static String getCanonicalFamilyName(String name) {
         if (name == null) {
             return SANS_SERIF;
         }
         String lcName = name.toLowerCase();
         return canonicalFamilyMap.get(lcName);
    }

    static LogicalFont[] logicalFonts = new LogicalFont[16];

    static PGFont getLogicalFont(String familyName, boolean bold,
                               boolean italic, float size) {

        String canonicalFamilyName = getCanonicalFamilyName(familyName);
        if (canonicalFamilyName == null) {
            return null;
        }

        int fontIndex = 0;
        if (canonicalFamilyName.equals(SANS_SERIF)) {
            fontIndex = 0;
        } else if (canonicalFamilyName.equals(SERIF)) {
            fontIndex = 4;
       } else if (canonicalFamilyName.equals(MONOSPACED)) {
            fontIndex = 8;
        } else {
            fontIndex = 12;
        }
        if (bold) {
            fontIndex +=1;
        }
        if (italic) {
            fontIndex +=2;
        }

        LogicalFont font = logicalFonts[fontIndex];
        if (font == null) {
            font = new LogicalFont(canonicalFamilyName, bold, italic);
            logicalFonts[fontIndex] = font;
        }
        return new PrismFont(font, font.getFullName(), size);
    }

    static PGFont getLogicalFont(String fullName, float size) {

        /* Need to parse this to find the family portion, for which
         * we will allow the various spellings, and the style portion
         * which must be exactly one of those we understand. The matching
         * is however case insensitive.
         * Don't allow an absence of style, we want people to be
         * in the habit of distinguishing family and full name usage.
         * None of the family names we understand have a space, so look
         * for a space to delimit the family and style.
         */
        int spaceIndex = fullName.indexOf(' ');
        if (spaceIndex == -1 || spaceIndex == fullName.length()-1) {
            return null;
        }
        String family = fullName.substring(0, spaceIndex);
        String canonicalFamily = getCanonicalFamilyName(family);
        if (canonicalFamily == null) {
            return null;
        }
        String style = fullName.substring(spaceIndex+1).toLowerCase();
        boolean bold=false, italic=false;
        if (style.equals(&quot;regular&quot;)) {
            // nothing to do
        } else if (style.equals(&quot;bold&quot;)) {
            bold = true;
        } else if (style.equals(&quot;italic&quot;)) {
            italic = true;
        } else if (style.equals(&quot;bold italic&quot;)) {
            bold = true;
            italic = true;
        } else {
            return null;
        }
        return getLogicalFont(canonicalFamily, bold, italic, size);
    }

    boolean isBold, isItalic;
    private String fullName, familyName, styleName;
    private String physicalFamily;
    private String physicalFullName;
    private String physicalFileName;

    private LogicalFont(String family, boolean bold, boolean italic) {

        familyName = family;
        isBold = bold;
        isItalic = italic;

        if (!bold &amp;&amp; !italic) {
            styleName = STYLE_REGULAR;
        } else if (bold &amp;&amp; !italic) {
            styleName = STYLE_BOLD;
        } else if (!bold &amp;&amp; italic) {
            styleName = STYLE_ITALIC;
        } else {
            styleName = STYLE_BOLD_ITALIC;
        }
        fullName = familyName + &quot; &quot; + styleName;
        if (PrismFontFactory.isLinux) {
            FontConfigManager.FcCompFont fcCompFont =
                FontConfigManager.getFontConfigFont(family, bold, italic);
            physicalFullName = fcCompFont.firstFont.fullName;
            physicalFileName = fcCompFont.firstFont.fontFile;
        } else {
            physicalFamily = PrismFontFactory.getSystemFont(familyName);
        }
    }

    private FontResource slot0FontResource;

    private FontResource getSlot0Resource() {
        if (slot0FontResource == null) {
            PrismFontFactory factory = PrismFontFactory.getFontFactory();
            if (physicalFamily != null) {
                slot0FontResource =  factory.getFontResource(physicalFamily,
                                                             isBold,
                                                             isItalic, false);
            } else {
                slot0FontResource = factory.getFontResource(physicalFullName,
                                                            physicalFileName,
                                                            false);
            }
            // Its unlikely but possible that this font isn't installed.
            if (slot0FontResource == null) {
                slot0FontResource = factory.getDefaultFontResource(false);
            }
        }
        return slot0FontResource;
    }

    private ArrayList&lt;String&gt; linkedFontFiles;
    private ArrayList&lt;String&gt; linkedFontNames;
    private FontResource[] fallbacks;
    private FontResource[] nativeFallbacks;

    private void getLinkedFonts() {
        if (fallbacks == null) {
            ArrayList&lt;String&gt;[] linkedFontInfo;
            if (PrismFontFactory.isLinux) {
                FontConfigManager.FcCompFont font =
                    FontConfigManager.getFontConfigFont(familyName,
                                                        isBold, isItalic);
                linkedFontFiles = FontConfigManager.getFileNames(font, true);
                linkedFontNames = FontConfigManager.getFontNames(font, true);
            } else {
                linkedFontInfo = PrismFontFactory.getLinkedFonts(&quot;Tahoma&quot;, true);
                linkedFontFiles = linkedFontInfo[0];
                linkedFontNames = linkedFontInfo[1];
            }
            fallbacks = new FontResource[linkedFontFiles.size()];
        }
    }

    public int getNumSlots() {
        getLinkedFonts();
        int num = linkedFontFiles.size();
        if (nativeFallbacks != null) {
            num += nativeFallbacks.length;
        }
        return num + 1;
    }

    public int getSlotForFont(String fontName) {
        getLinkedFonts();
        int i = 1;
        for (String linkedFontName : linkedFontNames) {
            if (fontName.equalsIgnoreCase(linkedFontName)) {
                return i;
            }
            i++;
        }
        if (nativeFallbacks != null) {
            for (FontResource nativeFallback : nativeFallbacks) {
                if (fontName.equalsIgnoreCase(nativeFallback.getFullName())) {
                    return i;
                }
                i++;
            }
        }

        if (i &gt;= 0x7E) {
            /* There are 8bits (0xFF) reserved in a glyph code to store the slot
             * number. The first bit cannot be set to avoid negative values
             * (leaving 0x7F). The extra -1 (leaving 0x7E) is to account for
             * the primary font resource in PrismCompositeFontResource.
             */
            if (PrismFontFactory.debugFonts) {
                System.err.println(&quot;\tToo many font fallbacks!&quot;);
            }
            return -1;
        }
        PrismFontFactory factory = PrismFontFactory.getFontFactory();
        FontResource fr = factory.getFontResource(fontName, null, false);
        if (fr == null) {
            if (PrismFontFactory.debugFonts) {
                System.err.println(&quot;\t Font name not supported \&quot;&quot; + fontName + &quot;\&quot;.&quot;);
            }
            return -1;
        }

        /* Add the font to the list of native fallbacks */
        FontResource[] tmp;
        if (nativeFallbacks == null) {
            tmp = new FontResource[1];
        } else {
            tmp = new FontResource[nativeFallbacks.length + 1];
            System.arraycopy(nativeFallbacks, 0, tmp, 0, nativeFallbacks.length);
        }
        tmp[tmp.length - 1] = fr;
        nativeFallbacks = tmp;

        return i;
    }

    public FontResource getSlotResource(int slot) {
        if (slot == 0) {
            return getSlot0Resource();
        } else {
            getLinkedFonts();
            slot = slot - 1;
            if (slot &gt;= fallbacks.length) {
                slot = slot - fallbacks.length;
                if (nativeFallbacks == null || slot &gt;= nativeFallbacks.length) {
                    return null;
                }
                return nativeFallbacks[slot];
            }
            if (fallbacks[slot] == null) {
                String file = linkedFontFiles.get(slot);
                String name = linkedFontNames.get(slot);
                fallbacks[slot] =
                    PrismFontFactory.getFontFactory().
                          getFontResource(name, file, false);
                if (fallbacks[slot] == null) {
                    fallbacks[slot] = getSlot0Resource();
                }
            }
            return fallbacks[slot];
        }
    }

    public String getFullName() {
        return fullName;
    }

    public String getPSName() {
        return fullName;
    }

    public String getFamilyName() {
        return familyName;
    }

    public String getStyleName() {
        return styleName;
    }

    public String getLocaleFullName() {
        return fullName;
    }

    public String getLocaleFamilyName() {
        return familyName;
    }

    public String getLocaleStyleName() {
        return styleName;
    }

    public boolean isBold() {
        return getSlotResource(0).isBold();
    }

    public boolean isItalic() {
        return getSlotResource(0).isItalic();
    }

    public String getFileName() {
        return getSlotResource(0).getFileName();
    }

    public int getFeatures() {
        return getSlotResource(0).getFeatures();
    }

    public Object getPeer() {
        return null;
    }

    public boolean isEmbeddedFont() {
        return getSlotResource(0).isEmbeddedFont();
    }

    public void setPeer(Object peer) {
        throw new UnsupportedOperationException(&quot;Not supported&quot;);
    }

    public float[] getGlyphBoundingBox(int glyphCode,
                                float size, float[] retArr) {
        int slot = (glyphCode &gt;&gt;&gt; 24);
        int slotglyphCode = glyphCode &amp; CompositeGlyphMapper.GLYPHMASK;
        FontResource slotResource = getSlotResource(slot);
        return slotResource.getGlyphBoundingBox(slotglyphCode, size, retArr);
   }

    public float getAdvance(int glyphCode, float size) {
        int slot = (glyphCode &gt;&gt;&gt; 24);
        int slotglyphCode = glyphCode &amp; CompositeGlyphMapper.GLYPHMASK;
        FontResource slotResource = getSlotResource(slot);
        return slotResource.getAdvance(slotglyphCode, size);
    }

    CompositeGlyphMapper mapper;
    public CharToGlyphMapper getGlyphMapper() {
        //return getSlot0Resource().getGlyphMapper();
        if (mapper == null) {
            mapper = new CompositeGlyphMapper(this);
        }
        return mapper;
    }

    Map&lt;FontStrikeDesc, WeakReference&lt;FontStrike&gt;&gt; strikeMap =
        new ConcurrentHashMap&lt;FontStrikeDesc, WeakReference&lt;FontStrike&gt;&gt;();

    public Map&lt;FontStrikeDesc, WeakReference&lt;FontStrike&gt;&gt; getStrikeMap() {
        return strikeMap;
    }

    public int getDefaultAAMode() {
        return getSlot0Resource().getDefaultAAMode();
    }

    public FontStrike getStrike(float size, BaseTransform transform) {
        return getStrike(size, transform, getDefaultAAMode());
    }

    public FontStrike getStrike(float size, BaseTransform transform,
                                int aaMode) {
        FontStrikeDesc desc= new FontStrikeDesc(size, transform, aaMode);
        WeakReference&lt;FontStrike&gt; ref = strikeMap.get(desc);
        CompositeStrike strike = null;

        if (ref != null) {
            strike = (CompositeStrike)ref.get();
        }
        if (strike == null) {
            strike = new CompositeStrike(this, size, transform, aaMode, desc);
            if (strike.disposer != null) {
                ref = Disposer.addRecord(strike, strike.disposer);
            } else {
                ref = new WeakReference&lt;FontStrike&gt;(strike);
            }
            strikeMap.put(desc, ref);
        }
        return strike;
    }

    // Family 0 = SansSerif, 1 = Serif, 2 = Monospaced, 3 = System
    private static final int SANS_SERIF_INDEX = 0;
    private static final int SERIF_INDEX      = 1;
    private static final int MONOSPACED_INDEX = 2;
    private static final int SYSTEM_INDEX = 3;
    // Within a family styles are in the usual order
    static String[][] logFamilies = null;

    private static void buildFamily(String[] fullNames, String family) {
        fullNames[0] = family + &quot; &quot; + STYLE_REGULAR;
        fullNames[1] = family + &quot; &quot; + STYLE_BOLD;
        fullNames[2] = family + &quot; &quot; + STYLE_ITALIC;
        fullNames[3] = family + &quot; &quot; + STYLE_BOLD_ITALIC;
    }

    private static void buildFamilies() {
        if (logFamilies == null) {
            String[][] tmpFamilies = new String[SYSTEM_INDEX+1][4];
            buildFamily(tmpFamilies[SANS_SERIF_INDEX], SANS_SERIF);
            buildFamily(tmpFamilies[SERIF_INDEX], SERIF);
            buildFamily(tmpFamilies[MONOSPACED_INDEX], MONOSPACED);
            buildFamily(tmpFamilies[SYSTEM_INDEX], SYSTEM);
            logFamilies = tmpFamilies;
        }
    }

    static void addFamilies(ArrayList&lt;String&gt; familyList) {
        familyList.add(SANS_SERIF);
        familyList.add(SERIF);
        familyList.add(MONOSPACED);
<A NAME="23"></A>        familyList.add(SYSTEM);
    }

    static void addFullNames(ArrayList&lt;String&gt; fullNames) <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#23',2,'match31-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        buildFamilies();
        for (int f = 0; f &lt; logFamilies.length; f++) {
            for (int n = 0; n &lt; logFamilies[f].length; n++) {
                fullNames.add(logFamilies[f][n]);
            }
        }
    }

    static String[] getFontsInFamily(String family</B></FONT>) {
        String canonicalFamily = getCanonicalFamilyName(family);
        if (canonicalFamily == null) {
            return null;
        }
        buildFamilies();
        if (canonicalFamily.equals(SANS_SERIF)) {
            return logFamilies[SANS_SERIF_INDEX];
        } else if (canonicalFamily.equals(SERIF)) {
            return logFamilies[SERIF_INDEX];
        } else if (canonicalFamily.equals(MONOSPACED)) {
            return logFamilies[MONOSPACED_INDEX];
        } else {
            return logFamilies[SYSTEM_INDEX];
        }
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (!(obj instanceof LogicalFont)) {
            return false;
        }
        final LogicalFont other = (LogicalFont)obj;

        return this.fullName.equals(other.fullName);
    }

    private int hash;
    @Override
    public int hashCode() {
        if (hash != 0) {
            return hash;
        }
        else {
            hash = fullName.hashCode();
            return hash;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/geom/RectangularShape.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.geom;

import com.sun.javafx.geom.transform.BaseTransform;

/**
 * &lt;code&gt;RectangularShape&lt;/code&gt; is the base class for a number of
 * {@link Shape} objects whose geometry is defined by a rectangular frame.
 * This class does not directly specify any specific geometry by
 * itself, but merely provides manipulation methods inherited by
 * a whole category of &lt;code&gt;Shape&lt;/code&gt; objects.
 * The manipulation methods provided by this class can be used to
 * query and modify the rectangular frame, which provides a reference
 * for the subclasses to define their geometry.
 *
 * @version     1.26, 05/05/07
 */
public abstract class RectangularShape extends Shape {

    /**
     * This is an abstract class that cannot be instantiated directly.
     *
     * @see Arc2D
     * @see Ellipse2D
     * @see Rectangle2D
     * @see RoundRectangle2D
     */
    protected RectangularShape() { }

    /**
     * Returns the X coordinate of the upper-left corner of
     * the framing rectangle in &lt;code&gt;double&lt;/code&gt; precision.
     * @return the X coordinate of the upper-left corner of
     * the framing rectangle.
     */
    public abstract float getX();

    /**
     * Returns the Y coordinate of the upper-left corner of
     * the framing rectangle in &lt;code&gt;double&lt;/code&gt; precision.
     * @return the Y coordinate of the upper-left corner of
     * the framing rectangle.
     */
    public abstract float getY();

    /**
     * Returns the width of the framing rectangle in
     * &lt;code&gt;double&lt;/code&gt; precision.
     * @return the width of the framing rectangle.
     */
    public abstract float getWidth();

    /**
     * Returns the height of the framing rectangle
<A NAME="49"></A>     * in &lt;code&gt;double&lt;/code&gt; precision.
     * @return the height of the framing rectangle.
     */
    public abstract float getHeight()<FONT color="#8e35ef"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#49',2,'match31-top.html#49',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>;

    /**
     * Returns the smallest X coordinate of the framing
     * rectangle of the &lt;code&gt;Shape&lt;/code&gt; in &lt;code&gt;double&lt;/code&gt;
     * precision.
     * @return the smallest X coordinate of the framing
     *      rectangle of the &lt;code&gt;Shape&lt;/code&gt;.
     */
    public float getMinX() {
        return getX();
    }

    /**
     * Returns the smallest Y coordinate of the framing
     * rectangle of the &lt;code&gt;Shape&lt;/code&gt; in &lt;code&gt;double&lt;/code&gt;
     * precision.
     * @return the smallest Y coordinate of the framing
     *      rectangle of the &lt;code&gt;Shape&lt;/code&gt;.
     */
    public float getMinY() {
        return getY();
    }

    /**
     * Returns the largest X coordinate of the framing
     * rectangle of the &lt;code&gt;Shape&lt;/code&gt; in &lt;code&gt;double&lt;/code&gt;
     * precision.
     * @return the largest X coordinate of the framing
     *      rectangle of the &lt;code&gt;Shape&lt;/code&gt;.
     */
    public float getMaxX() {
        return getX() + getWidth();
    }

    /**
     * Returns the largest Y coordinate of the framing
     * rectangle of the &lt;code&gt;Shape&lt;/code&gt; in &lt;code&gt;double&lt;/code&gt;
     * precision.
     * @return the largest Y coordinate of the framing
     *      rectangle of the &lt;code&gt;Shape&lt;/code&gt;.
     */
    public float getMaxY() {
        return getY() + getHeight();
    }</B></FONT>

    /**
     * Returns the X coordinate of the center of the framing
     * rectangle of the &lt;code&gt;Shape&lt;/code&gt; in &lt;code&gt;double&lt;/code&gt;
     * precision.
     * @return the X coordinate of the center of the framing rectangle
     *      of the &lt;code&gt;Shape&lt;/code&gt;.
     */
    public float getCenterX() {
        return getX() + getWidth() / 2f;
    }

    /**
     * Returns the Y coordinate of the center of the framing
     * rectangle of the &lt;code&gt;Shape&lt;/code&gt; in &lt;code&gt;double&lt;/code&gt;
     * precision.
     * @return the Y coordinate of the center of the framing rectangle
     *      of the &lt;code&gt;Shape&lt;/code&gt;.
     */
    public float getCenterY() {
        return getY() + getHeight() / 2f;
    }

    /**
     * Determines whether the &lt;code&gt;RectangularShape&lt;/code&gt; is empty.
     * When the &lt;code&gt;RectangularShape&lt;/code&gt; is empty, it encloses no
     * area.
     * @return &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;RectangularShape&lt;/code&gt; is empty;
     *      &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public abstract boolean isEmpty();

    /**
     * Sets the location and size of the framing rectangle of this
     * &lt;code&gt;Shape&lt;/code&gt; to the specified rectangular values.
     *
     * @param x the X coordinate of the upper-left corner of the
     *          specified rectangular shape
     * @param y the Y coordinate of the upper-left corner of the
     *          specified rectangular shape
     * @param w the width of the specified rectangular shape
     * @param h the height of the specified rectangular shape
     * @see #getFrame
     */
    public abstract void setFrame(float x, float y, float w, float h);

    /**
     * Sets the location and size of the framing rectangle of this
     * &lt;code&gt;Shape&lt;/code&gt; to the specified {@link Point2D} and
     * {@link Dimension2D}, respectively.  The framing rectangle is used
     * by the subclasses of &lt;code&gt;RectangularShape&lt;/code&gt; to define
     * their geometry.
     * @param loc the specified &lt;code&gt;Point2D&lt;/code&gt;
     * @param size the specified &lt;code&gt;Dimension2D&lt;/code&gt;
     * @see #getFrame
     */
    public void setFrame(Point2D loc, Dimension2D size) {
        setFrame(loc.x, loc.y, size.width, size.height);
    }

    /**
     * Sets the diagonal of the framing rectangle of this &lt;code&gt;Shape&lt;/code&gt;
     * based on the two specified coordinates.  The framing rectangle is
     * used by the subclasses of &lt;code&gt;RectangularShape&lt;/code&gt; to define
     * their geometry.
     *
     * @param x1 the X coordinate of the start point of the specified diagonal
     * @param y1 the Y coordinate of the start point of the specified diagonal
     * @param x2 the X coordinate of the end point of the specified diagonal
     * @param y2 the Y coordinate of the end point of the specified diagonal
     */
    public void setFrameFromDiagonal(float x1, float y1, float x2, float y2) {
        if (x2 &lt; x1) {
            float t = x1;
            x1 = x2;
            x2 = t;
        }
        if (y2 &lt; y1) {
            float t = y1;
            y1 = y2;
            y2 = t;
        }
        setFrame(x1, y1, x2 - x1, y2 - y1);
    }

    /**
     * Sets the diagonal of the framing rectangle of this &lt;code&gt;Shape&lt;/code&gt;
     * based on two specified &lt;code&gt;Point2D&lt;/code&gt; objects.  The framing
     * rectangle is used by the subclasses of &lt;code&gt;RectangularShape&lt;/code&gt;
     * to define their geometry.
     *
     * @param p1 the start &lt;code&gt;Point2D&lt;/code&gt; of the specified diagonal
     * @param p2 the end &lt;code&gt;Point2D&lt;/code&gt; of the specified diagonal
     */
    public void setFrameFromDiagonal(Point2D p1, Point2D p2) {
        setFrameFromDiagonal(p1.x, p1.y, p2.x, p2.y);
    }

    /**
     * Sets the framing rectangle of this &lt;code&gt;Shape&lt;/code&gt;
     * based on the specified center point coordinates and corner point
     * coordinates.  The framing rectangle is used by the subclasses of
     * &lt;code&gt;RectangularShape&lt;/code&gt; to define their geometry.
     *
     * @param centerX the X coordinate of the specified center point
     * @param centerY the Y coordinate of the specified center point
     * @param cornerX the X coordinate of the specified corner point
     * @param cornerY the Y coordinate of the specified corner point
     */
    public void setFrameFromCenter(float centerX, float centerY,
                   float cornerX, float cornerY)
    {
        float halfW = Math.abs(cornerX - centerX);
        float halfH = Math.abs(cornerY - centerY);
        setFrame(centerX - halfW, centerY - halfH, halfW * 2f, halfH * 2f);
    }

    /**
     * Sets the framing rectangle of this &lt;code&gt;Shape&lt;/code&gt; based on a
     * specified center &lt;code&gt;Point2D&lt;/code&gt; and corner
     * &lt;code&gt;Point2D&lt;/code&gt;.  The framing rectangle is used by the subclasses
     * of &lt;code&gt;RectangularShape&lt;/code&gt; to define their geometry.
     * @param center the specified center &lt;code&gt;Point2D&lt;/code&gt;
     * @param corner the specified corner &lt;code&gt;Point2D&lt;/code&gt;
     */
    public void setFrameFromCenter(Point2D center, Point2D corner) {
        setFrameFromCenter(center.x, center.y, corner.x, corner.y);
    }

    /**
     * {@inheritDoc}
     */
    public boolean contains(Point2D p) {
        return contains(p.x, p.y);
    }

    /**
     * {@inheritDoc}
     */
    public RectBounds getBounds() {
        float width = getWidth();
        float height = getHeight();
        if (width &lt; 0 || height &lt; 0) {
            return new RectBounds();
        }
        float x = getX();
        float y = getY();
        float x1 = (float)Math.floor(x);
        float y1 = (float)Math.floor(y);
        float x2 = (float)Math.ceil(x + width);
        float y2 = (float)Math.ceil(y + height);
        return new RectBounds(x1, y1, x2, y2);
    }

    /**
     * Returns an iterator object that iterates along the
     * &lt;code&gt;Shape&lt;/code&gt; object's boundary and provides access to a
     * flattened view of the outline of the &lt;code&gt;Shape&lt;/code&gt;
     * object's geometry.
     * &lt;p&gt;
     * Only SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types will
     * be returned by the iterator.
     * &lt;p&gt;
     * The amount of subdivision of the curved segments is controlled
     * by the &lt;code&gt;flatness&lt;/code&gt; parameter, which specifies the
     * maximum distance that any point on the unflattened transformed
     * curve can deviate from the returned flattened path segments.
     * An optional {@link BaseTransform} can
     * be specified so that the coordinates returned in the iteration are
     * transformed accordingly.
     * @param tx an optional &lt;code&gt;BaseTransform&lt;/code&gt; to be applied to the
     *      coordinates as they are returned in the iteration,
     *      or &lt;code&gt;null&lt;/code&gt; if untransformed coordinates are desired.
     * @param flatness the maximum distance that the line segments used to
     *          approximate the curved segments are allowed to deviate
     *          from any point on the original curve
     * @return a &lt;code&gt;PathIterator&lt;/code&gt; object that provides access to
     *      the &lt;code&gt;Shape&lt;/code&gt; object's flattened geometry.
     */
    public PathIterator getPathIterator(BaseTransform tx, float flatness) {
        return new FlatteningPathIterator(getPathIterator(tx), flatness);
    }

    @Override
    public String toString() {
        return getClass().getName() +
            &quot;[x=&quot; + getX() +
            &quot;,y=&quot; + getY() +
            &quot;,w=&quot; + getWidth() +
            &quot;,h=&quot; + getHeight() + &quot;]&quot;;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/sg/prism/NGNode.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.sg.prism;

import javafx.scene.CacheHint;
import java.util.ArrayList;
import java.util.List;
import com.sun.glass.ui.Screen;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.BoxBounds;
import com.sun.javafx.geom.DirtyRegionContainer;
import com.sun.javafx.geom.DirtyRegionPool;
import com.sun.javafx.geom.Point2D;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.prism.CompositeMode;
import com.sun.prism.Graphics;
import com.sun.prism.GraphicsPipeline;
import com.sun.prism.RTTexture;
import com.sun.prism.ReadbackGraphics;
import com.sun.prism.impl.PrismSettings;
import com.sun.scenario.effect.Blend;
import com.sun.scenario.effect.Effect;
import com.sun.scenario.effect.FilterContext;
import com.sun.scenario.effect.ImageData;
import com.sun.scenario.effect.impl.prism.PrDrawable;
import com.sun.scenario.effect.impl.prism.PrEffectHelper;
import com.sun.scenario.effect.impl.prism.PrFilterContext;
import com.sun.javafx.logging.PulseLogger;
import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;

/**
 * NGNode is the abstract base class peer of Node, forming
 * the basis for Prism and Scenario render graphs.
 * &lt;p&gt;
 * During synchronization, the FX scene graph will pass down to us
 * the transform which takes us from local space to parent space, the
 * content bounds (ie: geom bounds), and the transformed bounds
 * (ie: boundsInParent), and the clippedBounds. The effect bounds have
 * already been passed to the Effect peer (if there is one).
 * &lt;p&gt;
 * Whenever the transformedBounds of the NGNode are changed, we update
 * the dirtyBounds, so that the next time we need to accumulate dirty
 * regions, we will have the information we need to make sure we create
 * an appropriate dirty region.
 * &lt;p&gt;
 * NGNode maintains a single &quot;dirty&quot; flag, which indicates that this
 * node itself is dirty and must contribute to the dirty region. More
 * specifically, it indicates that this node is now dirty with respect
 * to the back buffer. Any rendering of the scene which will go on the
 * back buffer will cause the dirty flag to be cleared, whereas a
 * rendering of the scene which is for an intermediate image will not
 * clear this dirty flag.
 */
public abstract class NGNode {
    private final static GraphicsPipeline pipeline =
        GraphicsPipeline.getPipeline();

    private final static Boolean effectsSupported =
        (pipeline == null ? false : pipeline.isEffectSupported());

    public static enum DirtyFlag {
        CLEAN,
        // Means that the node is dirty, but only because of translation
        DIRTY_BY_TRANSLATION,
        DIRTY
    }

    /**
     * Used for debug purposes. Set during sync.
     */
    private String name;

    /**
     * Temporary bounds for use by this class or subclasses, designed to
     * reduce the amount of garbage we generate. If we get to the point
     * where we have multi-threaded rasterization, we might need to make
     * this per-instance instead of static.
     */
    private static final BoxBounds TEMP_BOUNDS = new BoxBounds();
    private static final RectBounds TEMP_RECT_BOUNDS = new RectBounds();
    protected static final Affine3D TEMP_TRANSFORM = new Affine3D();

    /**
     * Statics for defining what the culling bits are. We use 2 bits to
     * determine culling status
     */
    static final int DIRTY_REGION_INTERSECTS_NODE_BOUNDS = 0x1;
    static final int DIRTY_REGION_CONTAINS_NODE_BOUNDS = 0x2;
    static final int DIRTY_REGION_CONTAINS_OR_INTERSECTS_NODE_BOUNDS =
            DIRTY_REGION_INTERSECTS_NODE_BOUNDS | DIRTY_REGION_CONTAINS_NODE_BOUNDS;

    /**
     * The transform for this node. Although we are handed all the bounds
     * during synchronization (including the transformed bounds), we still
     * need the transform so that we can apply it to the clip and so forth
     * while accumulating dirty regions and rendering.
     */
    private BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;

    /**
     * The cached transformed bounds. This is never null, but is frequently set
     * to be invalid whenever the bounds for the node have changed. These are
     * &quot;complete&quot; bounds, that is, with transforms and effect and clip applied.
     * Note that this is equivalent to boundsInParent in FX.
     */
    protected BaseBounds transformedBounds = new RectBounds();

    /**
     * The cached bounds. This is never null, but is frequently set to be
     * invalid whenever the bounds for the node have changed. These are the
     * &quot;content&quot; bounds, that is, without transforms or filters applied.
     */
    protected BaseBounds contentBounds = new RectBounds();

    /**
     * We keep a reference to the last transform bounds that were valid
     * and known. We do this to significantly speed up the rendering of the
     * scene by culling and clipping based on &quot;dirty&quot; regions, which are
     * essentially the rectangle formed by the union of the dirtyBounds
     * and the transformedBounds.
     */
    BaseBounds dirtyBounds = new RectBounds();

    /**
     * Whether the node is visible. We need to know about the visibility of
     * the node so that we can determine whether to cull it out, and perform
     * other such optimizations.
     */
    private boolean visible = true;

    /**
     * Indicates that this NGNode is itself dirty and needs its full bounds
     * included in the next repaint. This means it is dirty with respect to
     * the back buffer. We don't bother differentiating between bounds dirty
     * and visuals dirty because we can simply inspect the dirtyBounds to
     * see if it is valid. If so, then bounds must be dirty.
     */
    protected DirtyFlag dirty = DirtyFlag.DIRTY;

    /**
     * The parent of the node. In the case of a normal render graph node,
     * this will be an NGGroup. However, if this node is being used as
     * a clip node, then the parent is the node it is the clip for.
     */
    private NGNode parent;

    /**
     * True if this node is a clip. This means the parent is clipped by this node.
     */
    private boolean isClip;

    /**
     * The node used for specifying the clipping shape for this node. If null,
     * then there is no clip.
     */
    private NGNode clipNode;

    /**
     * The opacity of this node.
     */
    private float opacity = 1f;

    /**
     * The view order of this node.
     */
    private double viewOrder = 0;

    /**
     * The blend mode that controls how the pixels of this node blend into
     * the rest of the scene behind it.
     */
    private Blend.Mode nodeBlendMode;

    /**
     * The depth test flag for this node. It is used when rendering if the window
     * into which we are rendering has a depth buffer.
     */
    private boolean depthTest = true;

    /**
     * A filter used when the node is cached. If null, then the node is not
     * being cached. While in theory this could be created automatically by
     * the implementation due to some form of heuristic, currently we
     * only set this if the application has requested that the node be cached.
     */
    private CacheFilter cacheFilter;

    /**
     * A filter used whenever an effect is placed on the node. Of course
     * effects can form a kind of tree, such that this one effect might be
     * an accumulation of several different effects. This will be null if
     * there are no effects on the FX scene graph node.
     */
    private EffectFilter effectFilter;

    /**
     * If this node is an NGGroup, then this flag will be used to indicate
     * whether one or more of its children is dirty. While it would seem this
     * flag should be on NGGroup, the code turns out to be a bit cleaner with
     * this flag in the NGNode class.
     */
    protected boolean childDirty = false;

    /**
     * How many children are going to be accumulated
     */
    protected int dirtyChildrenAccumulated = 0;

    /**
     * Do not iterate over all children in group. Mark group as dirty
     * when threshold was reached.
     */
    protected final static int DIRTY_CHILDREN_ACCUMULATED_THRESHOLD = 12;

    /**
     * Marks position of this node in dirty regions.
     */
    protected int cullingBits = 0x0;
    private DirtyHint hint;

    /**
     * A cached representation of the opaque region for this node. This
     * cached version needs to be recomputed whenever the opaque region becomes
     * invalid, which includes local transform changes (translations included!).
     */
    private RectBounds opaqueRegion = null;

    /**
     * To avoid object churn we keep opaqueRegion around, and just toggle this
     * boolean to indicate whether we need to recompute the opaqueRegion.
     */
    private boolean opaqueRegionInvalid = true;

    /**
     * Used for debug purposes. This field will keep track of which nodes were
     * rendered as a result of different dirty regions. These correspond to the
     * same positions as the cullingBits. So for example, if a node was rendered
     * by dirty region 0, then painted will have the lowest bit set. If it
     * was rendered by dirty region 3, then it would have the 3rd bit from the
     * right set ( that is, 1 &lt;&lt; 2)
     */
    private int painted = 0;

    protected NGNode() { }

    /***************************************************************************
     *                                                                         *
     *                Methods invoked during synchronization                   *
     *                                                                         *
     **************************************************************************/

    /**
     * Called by the FX scene graph to tell us whether we should be visible or not.
     * @param value whether it is visible
     */
    public void setVisible(boolean value) {
        // If the visibility changes, we need to mark this node as being dirty.
        // If this node is being cached, changing visibility should have no
        // effect, since it doesn't affect the rendering of the content in
        // any way. If we were to release the cached image, that might thwart
        // the developer's attempt to improve performance for things that
        // rapidly appear and disappear but which are expensive to render.
        // Ancestors, of course, must still have their caches invalidated.
        if (visible != value) {
            this.visible = value;
            markDirty();
        }
    }

    /**
     * Called by the FX scene graph to tell us what our new content bounds are.
     * @param bounds must not be null
     */
    public void setContentBounds(BaseBounds bounds) {
        // Note, there isn't anything to do here. We're dirty if geom or
        // visuals or transformed bounds or effects or clip have changed.
        // There's no point dealing with it here.
        contentBounds = contentBounds.deriveWithNewBounds(bounds);
    }

    /**
     * Called by the FX scene graph to tell us what our transformed bounds are.
     * @param bounds must not be null
     */
    public void setTransformedBounds(BaseBounds bounds, boolean byTransformChangeOnly) {
        if (transformedBounds.equals(bounds)) {
            // There has been no change, so ignore. It turns out this happens
            // a lot, because when a leaf has dirty bounds, all parents also
            // assume their bounds have changed, and only when they recompute
            // their bounds do we discover otherwise. This check could happen
            // on the FX side, however, then the FX side needs to cache the
            // former content bounds at the time of the last sync or needs to
            // be able to read state back from the NG side. Yuck. Just doing
            // it here for now.
            return;
        }
        // If the transformed bounds have changed, then we need to save off the
        // transformed bounds into the dirty bounds, so that the resulting
        // dirty region will be correct. If this node is cached, we DO NOT
        // invalidate the cache. The cacheFilter will compare its cached
        // transform to the accumulated transform to determine whether the
        // cache needs to be regenerated. So we will not invalidate it here.
        if (dirtyBounds.isEmpty()) {
            dirtyBounds = dirtyBounds.deriveWithNewBounds(transformedBounds);
            dirtyBounds = dirtyBounds.deriveWithUnion(bounds);
        } else {
            // TODO I think this is vestigial from Scenario and will never
            // actually occur in real life... (RT-23956)
            dirtyBounds = dirtyBounds.deriveWithUnion(transformedBounds);
        }
        transformedBounds = transformedBounds.deriveWithNewBounds(bounds);
        if (hasVisuals() &amp;&amp; !byTransformChangeOnly) {
            markDirty();
        }
    }

    /**
     * Called by the FX scene graph to tell us what our transform matrix is.
     * @param tx must not be null
     */
    public void setTransformMatrix(BaseTransform tx) {
        if (transform.equals(tx)) {
            return;
        }
        // If the transform matrix has changed, then we need to update it,
        // and mark this node as dirty. If this node is cached, we DO NOT
        // invalidate the cache. The cacheFilter will compare its cached
        // transform to the accumulated transform to determine whether the
        // cache needs to be regenerated. So we will not invalidate it here.
        // This approach allows the cached image to be reused in situations
        // where only the translation parameters of the accumulated transform
        // are changing. The scene will still be marked dirty and cached
        // images of any ancestors will be invalidated.
        boolean useHint = false;

        // If the parent is cached, try to check if the transformation is only a translation
        if (parent != null &amp;&amp; parent.cacheFilter != null &amp;&amp; PrismSettings.scrollCacheOpt) {
            if (hint == null) {
                // If there's no hint created yet, this is the first setTransformMatrix
                // call and we have nothing to compare to yet.
                hint = new DirtyHint();
            } else {
                if (transform.getMxx() == tx.getMxx()
                        &amp;&amp; transform.getMxy() == tx.getMxy()
                        &amp;&amp; transform.getMyy() == tx.getMyy()
                        &amp;&amp; transform.getMyx() == tx.getMyx()
                        &amp;&amp; transform.getMxz() == tx.getMxz()
                        &amp;&amp; transform.getMyz() == tx.getMyz()
                        &amp;&amp; transform.getMzx() == tx.getMzx()
                        &amp;&amp; transform.getMzy() == tx.getMzy()
                        &amp;&amp; transform.getMzz() == tx.getMzz()
                        &amp;&amp; transform.getMzt() == tx.getMzt()) {
                    useHint = true;
                    hint.translateXDelta = tx.getMxt() - transform.getMxt();
                    hint.translateYDelta = tx.getMyt() - transform.getMyt();
                }
            }
        }

        transform = transform.deriveWithNewTransform(tx);
        if (useHint) {
            markDirtyByTranslation();
        } else {
            markDirty();
        }
        invalidateOpaqueRegion();
    }

    /**
     * Called by the FX scene graph whenever the clip node for this node changes.
     * @param clipNode can be null if the clip node is being cleared
     */
    public void setClipNode(NGNode clipNode) {
        // Whenever the clipNode itself has changed (that is, the reference to
        // the clipNode), we need to be sure to mark this node dirty and to
        // invalidate the cache of this node (if there is one) and all parents.
        if (clipNode != this.clipNode) {
            // Clear the &quot;parent&quot; property of the clip node, if there was one
            if (this.clipNode != null) this.clipNode.setParent(null);
            // Make the &quot;parent&quot; property of the clip node point to this
            if (clipNode != null) clipNode.setParent(this, true);
            // Keep the reference to the new clip node
            this.clipNode = clipNode;
            // Mark this node dirty, invalidate its cache, and all parents.
            visualsChanged();
            invalidateOpaqueRegion();
        }
    }

    /**
     * Called by the FX scene graph whenever the opacity for the node changes.
     * We create a special filter when the opacity is &lt; 1.
     * @param opacity A value between 0 and 1.
     */
    public void setOpacity(float opacity) {
        // Check the argument to make sure it is valid.
        if (opacity &lt; 0 || opacity &gt; 1) {
            throw new IllegalArgumentException(&quot;Internal Error: The opacity must be between 0 and 1&quot;);
        }
        // If the opacity has changed, react. If this node is being cached,
        // then we do not want to invalidate the cache due to an opacity
        // change. However, as usual, all parent caches must be invalidated.
        if (opacity != this.opacity) {
            final float old = this.opacity;
            this.opacity = opacity;
            markDirty();
            // Even though the opacity has changed, for example from .5 to .6,
            // we don't need to invalidate the opaque region unless it has toggled
            // from 1 to !1, or from !1 to 1.
            if (old &lt; 1 &amp;&amp; (opacity == 1 || opacity == 0) || opacity &lt; 1 &amp;&amp; (old == 1 || old == 0)) {
                invalidateOpaqueRegion();
            }
        }
    }

    /**
     * Called by the FX scene graph whenever the view order for the node
     * changes.
     *
     * @param viewOrder A value between the range of negative Double.MAX_VALUE
     * and positive Double.MAX_VALUE.
     */
    public void setViewOrder(double viewOrder) {
        // If the viewOrder value has changed, react.
        if (viewOrder != this.viewOrder) {
            this.viewOrder = viewOrder;
            // Mark this node dirty and invalidate its cache.
            visualsChanged();
        }
    }

    /**
     * Set by the FX scene graph.
     * @param blendMode may be null to indicate &quot;default&quot;
     */
    public void setNodeBlendMode(Blend.Mode blendMode) {
        // The following code was a broken optimization that made an
        // incorrect assumption about null meaning the same thing as
        // SRC_OVER.  In reality, null means &quot;pass through blending
        // from children&quot; and SRC_OVER means &quot;intercept blending of
        // children, allow them to blend with each other, but pass
        // their result on in a single SRC_OVER operation into the bg&quot;.
        // For leaf nodes, those are mostly the same thing, but Regions
        // and Groups might behave differently for the two modes.
//        if (blendMode == Blend.Mode.SRC_OVER) {
//            blendMode = null;
//        }

        // If the blend mode has changed, react. If this node is being cached,
        // then we do not want to invalidate the cache due to a compositing
        // change. However, as usual, all parent caches must be invalidated.

        if (this.nodeBlendMode != blendMode) {
            this.nodeBlendMode = blendMode;
            markDirty();
            invalidateOpaqueRegion();
        }
    }

    /**
     * Called by the FX scene graph whenever the derived depth test flag for
     * the node changes.
     * @param depthTest indicates whether to perform a depth test operation
     * (if the window has a depth buffer).
     */
    public void setDepthTest(boolean depthTest) {
        // If the depth test flag has changed, react.
        if (depthTest != this.depthTest) {
            this.depthTest = depthTest;
            // Mark this node dirty, invalidate its cache, and all parents.
            visualsChanged();
        }
    }

    /**
     * Called by the FX scene graph whenever &quot;cached&quot; or &quot;cacheHint&quot; changes.
     * These hints provide a way for the developer to indicate whether they
     * want this node to be cached as a raster, which can be quite a performance
     * optimization in some cases (and lethal in others).
     * @param cached specifies whether or not this node should be cached
     * @param cacheHint never null, indicates some hint as to how to cache
     */
    public void setCachedAsBitmap(boolean cached, CacheHint cacheHint) {
        // Validate the arguments
        if (cacheHint == null) {
            throw new IllegalArgumentException(&quot;Internal Error: cacheHint must not be null&quot;);
        }

        if (cached) {
            if (cacheFilter == null) {
                cacheFilter = new CacheFilter(this, cacheHint);
                // We do not technically need to do a render pass here, but if
                // we wait for the next render pass to cache it, then we will
                // cache not the current visuals, but the visuals as defined
                // by any transform changes that happen between now and then.
                // Repainting now encourages the cached version to be as close
                // as possible to the state of the node when the cache hint
                // was set...
                markDirty();
            } else {
                if (!cacheFilter.matchesHint(cacheHint)) {
                    cacheFilter.setHint(cacheHint);
                    // Different hints may have different requirements of
                    // whether the cache is stale.  We do not have enough info
                    // right here to evaluate that, but it will be determined
                    // naturally during a repaint cycle.
                    // If the new hint is more relaxed (QUALITY =&gt; SPEED for
                    // instance) then rendering should be quick.
                    // If the new hint is more restricted (SPEED =&gt; QUALITY)
                    // then we need to render to improve the results anyway.
                    markDirty();
                }
            }
        } else {
            if (cacheFilter != null) {
                cacheFilter.dispose();
                cacheFilter = null;
                // A cache will often look worse than uncached rendering.  It
                // may look the same in some circumstances, and this may then
                // be an unnecessary rendering pass, but we do not have enough
                // information here to be able to optimize that when possible.
                markDirty();
            }
        }
    }

    /**
     * Called by the FX scene graph to set the effect.
     * @param effect the effect (can be null to clear it)
     */
    public void setEffect(Effect effect) {
        final Effect old = getEffect();
        // When effects are disabled, be sure to reset the effect filter
        if (PrismSettings.disableEffects) {
            effect = null;
        }

        // We only need to take action if the effect is different than what was
        // set previously. There are four possibilities. Of these, #1 and #3 matter:
        // 0. effectFilter == null, effect == null
        // 1. effectFilter == null, effect != null
        // 2. effectFilter != null, effectFilter.effect == effect
        // 3. effectFilter != null, effectFilter.effect != effect
        // In any case where the effect is changed, we must both invalidate
        // the cache for this node (if there is one) and all parents, and mark
        // this node as dirty.
        if (effectFilter == null &amp;&amp; effect != null) {
            effectFilter = new EffectFilter(effect, this);
            visualsChanged();
        } else if (effectFilter != null &amp;&amp; effectFilter.getEffect() != effect) {
            effectFilter.dispose();
            effectFilter = null;
            if (effect != null) {
                effectFilter = new EffectFilter(effect, this);
            }
            visualsChanged();
        }

        // The only thing we do with the effect in #computeOpaqueRegion is to check
        // whether the effect is null / not null. If the answer to these question has
        // not changed from last time, then there is no need to recompute the opaque region.
        if (old != effect) {
            if (old == null || effect == null) {
                invalidateOpaqueRegion();
            }
        }
    }

    /**
     * Called by the FX scene graph when an effect in the effect chain on the node
     * changes internally.
     */
    public void effectChanged() {
        visualsChanged();
    }

    /**
     * Return true if contentBounds is purely a 2D bounds, ie. it is a
     * RectBounds or its Z dimension is almost zero.
     */
    public boolean isContentBounds2D() {
        return contentBounds.is2D();
    }

    /***************************************************************************
     *                                                                         *
     * Hierarchy, visibility, and other such miscellaneous NGNode properties   *
     *                                                                         *
     **************************************************************************/

    /**
     * Gets the parent of this node. The parent might be an NGGroup. However,
     * if this node is a clip node on some other node, then the node on which
     * it is set as the clip will be returned. That is, suppose some node A
     * has a clip node B. The method B.getParent() will return A.
     */
    public NGNode getParent() { return parent; }

    /**
     * Only called by this class, or by the NGGroup class.
     */
    public void setParent(NGNode parent) {
        setParent(parent, false);
    }

    private void setParent(NGNode parent, boolean isClip) {
        this.parent = parent;
        this.isClip = isClip;
    }

    /**
     * Used for debug purposes.
     */
    public final void setName(String value) {
        this.name = value;
    }

    /**
     * Used for debug purposes.
     */
    public final String getName() {
        return name;
    }

    protected final Effect getEffect() { return effectFilter == null ? null : effectFilter.getEffect(); }

    /**
     * Gets whether this node's visible property is set
     */
    public boolean isVisible() { return visible; }

    public final BaseTransform getTransform() { return transform; }
    public final float getOpacity() { return opacity; }
    public final Blend.Mode getNodeBlendMode() { return nodeBlendMode; }
    public final boolean isDepthTest() { return depthTest; }
    public final CacheFilter getCacheFilter() { return cacheFilter; }
    public final EffectFilter getEffectFilter() { return effectFilter; }
    public final NGNode getClipNode() { return clipNode; }

    public BaseBounds getContentBounds(BaseBounds bounds, BaseTransform tx) {
        if (tx.isTranslateOrIdentity()) {
            bounds = bounds.deriveWithNewBounds(contentBounds);
            if (!tx.isIdentity()) {
                float translateX = (float) tx.getMxt();
                float translateY = (float) tx.getMyt();
                float translateZ = (float) tx.getMzt();
                bounds = bounds.deriveWithNewBounds(
                    bounds.getMinX() + translateX,
                    bounds.getMinY() + translateY,
                    bounds.getMinZ() + translateZ,
                    bounds.getMaxX() + translateX,
                    bounds.getMaxY() + translateY,
                    bounds.getMaxZ() + translateZ);
            }
            return bounds;
        } else {
            // This is a scale / rotate / skew transform.
            // We have contentBounds cached throughout the entire tree.
            // just walk down the tree and add everything up
            return computeBounds(bounds, tx);
        }
    }

    private BaseBounds computeBounds(BaseBounds bounds, BaseTransform tx) {
        // TODO: This code almost worked, but it ignored the local to
        // parent transforms on the nodes.  The short fix is to disable
        // this block and use the more general form below, but we need
        // to revisit this and see if we can make it work more optimally.
        // @see RT-12105 http://javafx-jira.kenai.com/browse/RT-12105
        if (false &amp;&amp; this instanceof NGGroup) {
            List&lt;NGNode&gt; children = ((NGGroup)this).getChildren();
            BaseBounds tmp = TEMP_BOUNDS;
            for (int i=0; i&lt;children.size(); i++) {
                float minX = bounds.getMinX();
                float minY = bounds.getMinY();
                float minZ = bounds.getMinZ();
                float maxX = bounds.getMaxX();
                float maxY = bounds.getMaxY();
                float maxZ = bounds.getMaxZ();
                NGNode child = children.get(i);
                bounds = child.computeBounds(bounds, tx);
                tmp = tmp.deriveWithNewBounds(minX, minY, minZ, maxX, maxY, maxZ);
                bounds = bounds.deriveWithUnion(tmp);
            }
            return bounds;
        } else {
            bounds = bounds.deriveWithNewBounds(contentBounds);
            return tx.transform(contentBounds, bounds);
        }
    }

    /**
     */
    public final BaseBounds getClippedBounds(BaseBounds bounds, BaseTransform tx) {
        BaseBounds effectBounds = getEffectBounds(bounds, tx);
        if (clipNode != null) {
            // there is a clip in place, so we will save off the effect/content
            // bounds (so as not to generate garbage) and will then get the
            // bounds of the clip node and do an intersection of the two
            float ex1 = effectBounds.getMinX();
            float ey1 = effectBounds.getMinY();
            float ez1 = effectBounds.getMinZ();
            float ex2 = effectBounds.getMaxX();
            float ey2 = effectBounds.getMaxY();
            float ez2 = effectBounds.getMaxZ();
            effectBounds = clipNode.getCompleteBounds(effectBounds, tx);
            effectBounds.intersectWith(ex1, ey1, ez1, ex2, ey2, ez2);
        }
        return effectBounds;
    }

    public final BaseBounds getEffectBounds(BaseBounds bounds, BaseTransform tx) {
        if (effectFilter != null) {
            return effectFilter.getBounds(bounds, tx);
        } else {
            return getContentBounds(bounds, tx);
        }
    }

    public final BaseBounds getCompleteBounds(BaseBounds bounds, BaseTransform tx) {
        if (tx.isIdentity()) {
            bounds = bounds.deriveWithNewBounds(transformedBounds);
            return bounds;
        } else if (transform.isIdentity()) {
            return getClippedBounds(bounds, tx);
        } else {
            double mxx = tx.getMxx();
            double mxy = tx.getMxy();
            double mxz = tx.getMxz();
            double mxt = tx.getMxt();
            double myx = tx.getMyx();
            double myy = tx.getMyy();
            double myz = tx.getMyz();
            double myt = tx.getMyt();
            double mzx = tx.getMzx();
            double mzy = tx.getMzy();
            double mzz = tx.getMzz();
            double mzt = tx.getMzt();
            BaseTransform boundsTx = tx.deriveWithConcatenation(this.transform);
            bounds = getClippedBounds(bounds, tx);
            if (boundsTx == tx) {
                tx.restoreTransform(mxx, mxy, mxz, mxt,
                                    myx, myy, myz, myt,
                                    mzx, mzy, mzz, mzt);
            }
            return bounds;
        }
    }

    /***************************************************************************
     *                                                                         *
     * Dirty States                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Invoked by subclasses whenever some change to the geometry or visuals
     * has occurred. This will mark the node as dirty and invalidate the cache.
     */
    protected void visualsChanged() {
        invalidateCache();
        markDirty();
    }

    protected void geometryChanged() {
        invalidateCache();
        invalidateOpaqueRegion();
        if (hasVisuals()) {
            markDirty();
        }
    }

    /**
     * Makes this node dirty, meaning that it needs to be included in the
     * next repaint to the back buffer, and its bounds should be included
     * in the dirty region. This flag means that this node itself is dirty.
     * In contrast, the childDirty flag indicates that a child of the node
     * (maybe a distant child) is dirty. This method does not invalidate the
     * cache of this node. However, it ends up walking up the tree marking
     * all parents as having a dirty child and also invalidating their caches.
     * This method has no effect if the node is already dirty.
     */
    public final void markDirty() {
        if (dirty != DirtyFlag.DIRTY) {
            dirty = DirtyFlag.DIRTY;
            markTreeDirty();
        }
    }

    /**
     * Mark the node as DIRTY_BY_TRANSLATION. This will call special cache invalidation
     */
    private void markDirtyByTranslation() {
        if (dirty == DirtyFlag.CLEAN) {
            if (parent != null &amp;&amp; parent.dirty == DirtyFlag.CLEAN &amp;&amp; !parent.childDirty) {
                dirty = DirtyFlag.DIRTY_BY_TRANSLATION;
                parent.childDirty = true;
                parent.dirtyChildrenAccumulated++;
                parent.invalidateCacheByTranslation(hint);
                parent.markTreeDirty();
            } else {
                markDirty();
            }
        }
    }

    //Mark tree dirty, but make sure this node's
    // dirtyChildrenAccumulated has not been incremented.
    // Useful when a markTree is called on a node that's not
    // the dirty source of change, e.g. group knows it has new child
    // or one of it's child has been removed
    protected final void markTreeDirtyNoIncrement() {
        if (parent != null &amp;&amp; (!parent.childDirty || dirty == DirtyFlag.DIRTY_BY_TRANSLATION)) {
            markTreeDirty();
        }
    }

    /**
     * Notifies the parent (whether an NGGroup or just a NGNode) that
     * a child has become dirty. This walk will continue all the way up
     * to the root of the tree. If a node is encountered which is already
     * dirty, or which already has childDirty set, then this loop will
     * terminate (ie: there is no point going further so we might as well
     * just bail). This method ends up invalidating the cache of each
     * parent up the tree. Since it is possible for a node to already
     * have its dirty bit set, but not have its cache invalidated, this
     * method is careful to make sure the first parent it encounters
     * which is already marked dirty still has its cache invalidated. If
     * this turns out to be expensive due to high occurrence, we can add
     * a quick &quot;invalidated&quot; flag to every node (at the cost of yet
     * another bit).
     */
    protected final void markTreeDirty() {
        NGNode p = parent;
        boolean atClip = isClip;
        boolean byTranslation = dirty == DirtyFlag.DIRTY_BY_TRANSLATION;
        while (p != null &amp;&amp; p.dirty != DirtyFlag.DIRTY &amp;&amp; (!p.childDirty || atClip || byTranslation)) {
            if (atClip) {
                p.dirty = DirtyFlag.DIRTY;
            } else if (!byTranslation) {
                p.childDirty = true;
                p.dirtyChildrenAccumulated++;
            }
            p.invalidateCache();
            atClip = p.isClip;
            byTranslation = p.dirty == DirtyFlag.DIRTY_BY_TRANSLATION;
            p = p.parent;
        }
        // if we stopped on a parent that already has dirty children, increase it's
        // dirty children count.
        // Note that when incrementDirty is false, we don't increment in this case.
        if (p != null &amp;&amp; p.dirty == DirtyFlag.CLEAN &amp;&amp; !atClip &amp;&amp; !byTranslation) {
            p.dirtyChildrenAccumulated++;
        }
        // Must make sure this happens. In some cases, a parent might
        // already be marked dirty (for example, its opacity may have
        // changed) but its cache has not been made invalid. This call
        // will make sure it is invalidated in that case
        if (p != null) p.invalidateCache();
    }

    /**
     * Gets whether this SGNode is clean. This will return true only if
     * this node and any / all child nodes are clean.
     */
    public final boolean isClean() {
        return dirty == DirtyFlag.CLEAN &amp;&amp; !childDirty;
    }

    /**
     * Clears the dirty flag. This should only happen during rendering.
     */
    protected void clearDirty() {
        dirty = DirtyFlag.CLEAN;
        childDirty = false;
        dirtyBounds.makeEmpty();
        dirtyChildrenAccumulated = 0;
    }

    /**
     * Walks down the tree clearing the &quot;painted&quot; bits for each node. This is only
     * called if we're drawing dirty rectangles or overdraw rectangles.
     */
    public void clearPainted() {
        painted = 0;
        if (this instanceof NGGroup) {
            List&lt;NGNode&gt; children = ((NGGroup)this).getChildren();
            for (int i=0; i&lt;children.size(); i++) {
                children.get(i).clearPainted();
            }
        }
    }

    public void clearDirtyTree() {
        clearDirty();
        if (getClipNode() != null) {
            getClipNode().clearDirtyTree();
        }
        if (this instanceof NGGroup) {
            List&lt;NGNode&gt; children = ((NGGroup) this).getChildren();
            for (int i = 0; i &lt; children.size(); ++i) {
                NGNode child = children.get(i);
                if (child.dirty != DirtyFlag.CLEAN || child.childDirty) {
                    child.clearDirtyTree();
                }
            }
        }
    }

    /**
     * Invalidates the cache, if it is in use. There are several operations
     * which need to cause the cached raster to become invalid so that a
     * subsequent render operation will result in the cached image being
     * reconstructed.
     */
    protected final void invalidateCache() {
        if (cacheFilter != null) {
            cacheFilter.invalidate();
        }
    }

    /**
     * Mark the cache as invalid due to a translation of a child. The cache filter
     * might use this information for optimizations.
     */
    protected final void invalidateCacheByTranslation(DirtyHint hint) {
        if (cacheFilter != null) {
            cacheFilter.invalidateByTranslation(hint.translateXDelta, hint.translateYDelta);
        }
    }

    /***************************************************************************
     *                                                                         *
     * Dirty Regions                                                           *
     *                                                                         *
     * Need to add documentation about dirty regions and how they work. One    *
     * thing to be aware of is that during the dirty region accumulation phase *
     * we use precise floating point values, but during                        *
     *                                                                         *
     **************************************************************************/

    /**
     * Accumulates and returns the dirty regions in transformed coordinates for
     * this node. This method is designed such that a single downward traversal
     * of the tree is sufficient to update the dirty regions.
     * &lt;p&gt;
     * This method only accumulates dirty regions for parts of the tree which lie
     * inside the clip since there is no point in accumulating dirty regions which
     * lie outside the clip. The returned dirty regions bounds  the same object
     * as that passed into the function. The returned dirty regions bounds will
     * always be adjusted such that they do not extend beyond the clip.
     * &lt;p&gt;
     * The given transform is the accumulated transform up to but not including the
     * transform of this node.
     *
     * @param clip must not be null, the clip in scene coordinates, supplied by the
     *        rendering system. At most, this is usually the bounds of the window's
     *        content area, however it might be smaller.
     * @param dirtyRegionTemp must not be null, the dirty region in scene coordinates.
     *        When this method is initially invoked by the rendering system, the
     *        dirtyRegion should be marked as invalid.
     * @param dirtyRegionContainer must not be null, the container of dirty regions in scene
     *        coordinates.
     * @param tx must not be null, the accumulated transform up to but not
     *        including this node's transform. When this method concludes, it must
     *        restore this transform if it was changed within the function.
     * @param pvTx must not be null, it's the perspective transform of the current
     *        perspective camera or identity transform if parallel camera is used.
     * @return The dirty region container. If the returned value is null, then that means
     *         the clip should be used as the dirty region. This is a special
     *         case indicating that there is no more need to walk the tree but
     *         we can take a shortcut. Note that returning null is *always*
     *         safe. Returning something other than null is simply an
     *         optimization for cases where the dirty region is substantially
     *         smaller than the clip.
     * TODO: Only made non-final for the sake of testing (see javafx-sg-prism tests) (RT-23957)
     */
    public /*final*/ int accumulateDirtyRegions(final RectBounds clip,
                                                final RectBounds dirtyRegionTemp,
                                                DirtyRegionPool regionPool,
                                                final DirtyRegionContainer dirtyRegionContainer,
                                                final BaseTransform tx,
                                                final GeneralTransform3D pvTx)
    {
        // This is the main entry point, make sure to check these inputs for validity
        if (clip == null || dirtyRegionTemp == null || regionPool == null || dirtyRegionContainer == null ||
                tx == null || pvTx == null) throw new NullPointerException();

        // Even though a node with 0 visibility or 0 opacity doesn't get
        // rendered, it may contribute to the dirty bounds, for example, if it
        // WAS visible or if it HAD an opacity &gt; 0 last time we rendered then
        // we must honor its dirty region. We have front-loaded this work so
        // that we don't mark nodes as having dirty flags or dirtyBounds if
        // they shouldn't contribute to the dirty region. So we can simply
        // treat all nodes, regardless of their opacity or visibility, as
        // though their dirty regions matter. They do.

        // If this node is clean then we can simply return the dirty region as
        // there is no need to walk any further down this branch of the tree.
        // The node is &quot;clean&quot; if neither it, nor its children, are dirty.
         if (dirty == DirtyFlag.CLEAN &amp;&amp; !childDirty) {
             return DirtyRegionContainer.DTR_OK;
         }

        // We simply collect this nodes dirty region if it has its dirty flag
        // set, regardless of whether it is a group or not. However, if this
        // node is not dirty, then we can ask the accumulateGroupDirtyRegion
        // method to collect the dirty regions of the children.
        if (dirty != DirtyFlag.CLEAN) {
            return accumulateNodeDirtyRegion(clip, dirtyRegionTemp, dirtyRegionContainer, tx, pvTx);
        } else {
            assert childDirty; // this must be true by this point
            return accumulateGroupDirtyRegion(clip, dirtyRegionTemp, regionPool,
                                              dirtyRegionContainer, tx, pvTx);
        }
    }

    /**
     * Accumulates the dirty region of a node.
     * TODO: Only made non-final for the sake of testing (see javafx-sg-prism tests) (RT-23957)
     */
    int accumulateNodeDirtyRegion(final RectBounds clip,
                                  final RectBounds dirtyRegionTemp,
                                  final DirtyRegionContainer dirtyRegionContainer,
                                  final BaseTransform tx,
                                  final GeneralTransform3D pvTx) {

        // Get the dirty bounds of this specific node in scene coordinates
        final BaseBounds bb = computeDirtyRegion(dirtyRegionTemp, tx, pvTx);

        // Note: dirtyRegion is strictly a 2D operation. We simply need the largest
        // rectangular bounds of bb. Hence the Z-axis projection of bb; taking
        // minX, minY, maxX and maxY values from this point on. Also, in many cases
        // bb == dirtyRegionTemp. In fact, the only time this won't be true is if
        // there is (or was) a perspective transform involved on this node.
        if (bb != dirtyRegionTemp) {
            bb.flattenInto(dirtyRegionTemp);
        }

        // If my dirty region is empty, or if it doesn't intersect with the
        // clip, then we can simply return since this node's dirty region is
        // not helpful
        if (dirtyRegionTemp.isEmpty() || clip.disjoint(dirtyRegionTemp)) {
            return DirtyRegionContainer.DTR_OK;
        }

        // If the clip is completely contained within the dirty region (including
        // if they are equal) then we return DTR_CONTAINS_CLIP
        if (dirtyRegionTemp.contains(clip)) {
            return DirtyRegionContainer.DTR_CONTAINS_CLIP;
        }

        // The only overhead in calling intersectWith, and contains (above) is the repeated checking
        // if the isEmpty state. But the code is cleaner and less error prone.
        dirtyRegionTemp.intersectWith(clip);

        // Add the dirty region to the container
        dirtyRegionContainer.addDirtyRegion(dirtyRegionTemp);

        return DirtyRegionContainer.DTR_OK;
    }

    /**
     * Accumulates the dirty region of an NGGroup. This is implemented here as opposed to
     * using polymorphism because we wanted to centralize all of the dirty region
     * management code in one place, rather than having it spread between Prism,
     * Scenario, and any other future toolkits.
     * TODO: Only made non-final for the sake of testing (see javafx-sg-prism tests) (RT-23957)
     */
    int accumulateGroupDirtyRegion(final RectBounds clip,
                                   final RectBounds dirtyRegionTemp,
                                   final DirtyRegionPool regionPool,
                                   DirtyRegionContainer dirtyRegionContainer,
                                   final BaseTransform tx,
                                   final GeneralTransform3D pvTx) {
        // We should have only made it to this point if this node has a dirty
        // child. If this node itself is dirty, this method never would get called.
        // If this node was not dirty and had no dirty children, then this
        // method never should have been called. So at this point, the following
        // assertions should be correct.
        assert childDirty;
        assert dirty == DirtyFlag.CLEAN;

        int status = DirtyRegionContainer.DTR_OK;

        if (dirtyChildrenAccumulated &gt; DIRTY_CHILDREN_ACCUMULATED_THRESHOLD) {
            status = accumulateNodeDirtyRegion(clip, dirtyRegionTemp, dirtyRegionContainer, tx, pvTx);
            return status;
        }

        // If we got here, then we are following a &quot;bread crumb&quot; trail down to
        // some child (perhaps distant) which is dirty. So we need to iterate
        // over all the children and accumulate their dirty regions. Before doing
        // so we, will save off the transform state and restore it after having
        // called all the children.
        double mxx = tx.getMxx();
        double mxy = tx.getMxy();
        double mxz = tx.getMxz();
        double mxt = tx.getMxt();

        double myx = tx.getMyx();
        double myy = tx.getMyy();
        double myz = tx.getMyz();
        double myt = tx.getMyt();

        double mzx = tx.getMzx();
        double mzy = tx.getMzy();
        double mzz = tx.getMzz();
        double mzt = tx.getMzt();
        BaseTransform renderTx = tx;
        if (this.transform != null) renderTx = renderTx.deriveWithConcatenation(this.transform);

        // If this group node has a clip, then we will perform some special
        // logic which will cause the dirty region accumulation loops to run
        // faster. We already have a system whereby if a node determines that
        // its dirty region exceeds that of the clip, it simply returns null,
        // short circuiting the accumulation process. We extend that logic
        // here by also taking into account the clipNode on the group. If
        // there is a clip node, then we will union the bounds of the clip
        // node (in boundsInScene space) with the current clip and pass this
        // new clip down to the children. If they determine that their dirty
        // regions exceed the bounds of this new clip, then they will return
        // null. We'll catch that here, and use that information to know that
        // we ought to simply accumulate the bounds of this group as if it
        // were dirty. This process will do all the other optimizations we
        // already have in place for getting the normal dirty region.
        RectBounds myClip = clip;
        //Save current dirty region so we can fast-reset to (something like) the last state
        //and possibly save a few intersects() calls

        DirtyRegionContainer originalDirtyRegion = null;
        BaseTransform originalRenderTx = null;
        if (effectFilter != null) {
            try {
                myClip = new RectBounds();
                BaseBounds myClipBaseBounds = renderTx.inverseTransform(clip, TEMP_BOUNDS);
                myClipBaseBounds.flattenInto(myClip);
            } catch (NoninvertibleTransformException ex) {
                return DirtyRegionContainer.DTR_OK;
            }

            originalRenderTx = renderTx;
            renderTx = BaseTransform.IDENTITY_TRANSFORM;
            originalDirtyRegion = dirtyRegionContainer;
            dirtyRegionContainer = regionPool.checkOut();
        } else if (clipNode != null) {
            originalDirtyRegion = dirtyRegionContainer;
            myClip = new RectBounds();
            BaseBounds clipBounds = clipNode.getCompleteBounds(myClip, renderTx);
            pvTx.transform(clipBounds, clipBounds);
            clipBounds.flattenInto(myClip);
            myClip.intersectWith(clip);
            dirtyRegionContainer = regionPool.checkOut();
        }


        //Accumulate also removed children to dirty region.
        List&lt;NGNode&gt; removed = ((NGGroup) this).getRemovedChildren();
        if (removed != null) {
            NGNode removedChild;
            for (int i = removed.size() - 1; i &gt;= 0; --i) {
                removedChild = removed.get(i);
                removedChild.dirty = DirtyFlag.DIRTY;
                    status = removedChild.accumulateDirtyRegions(myClip,
                            dirtyRegionTemp,regionPool, dirtyRegionContainer, renderTx, pvTx);
                    if (status == DirtyRegionContainer.DTR_CONTAINS_CLIP) {
                        break;
                    }
            }
        }

        List&lt;NGNode&gt; children = ((NGGroup) this).getChildren();
        int num = children.size();
        for (int i=0; i&lt;num &amp;&amp; status == DirtyRegionContainer.DTR_OK; i++) {
            NGNode child = children.get(i);
            // The child will check the dirty bits itself. If we tested it here
            // (as we used to), we are just doing the check twice. True, it might
            // mean fewer method calls, but hotspot will probably inline this all
            // anyway, and doing the check in one place is less error prone.
            status = child.accumulateDirtyRegions(myClip, dirtyRegionTemp, regionPool,
                                                  dirtyRegionContainer, renderTx, pvTx);
            if (status == DirtyRegionContainer.DTR_CONTAINS_CLIP) {
                break;
            }
        }

        if (effectFilter != null &amp;&amp; status == DirtyRegionContainer.DTR_OK) {
            //apply effect on effect dirty regions
            applyEffect(effectFilter, dirtyRegionContainer, regionPool);

            if (clipNode != null) {
                myClip = new RectBounds();
                BaseBounds clipBounds = clipNode.getCompleteBounds(myClip, renderTx);
                applyClip(clipBounds, dirtyRegionContainer);
            }

            //apply transform on effect dirty regions
            applyTransform(originalRenderTx, dirtyRegionContainer);
            renderTx = originalRenderTx;

            originalDirtyRegion.merge(dirtyRegionContainer);
            regionPool.checkIn(dirtyRegionContainer);
        }

        // If the process of applying the transform caused renderTx to not equal
        // tx, then there is no point restoring it since it will be a different
        // reference and will therefore be gc'd.
        if (renderTx == tx) {
            tx.restoreTransform(mxx, mxy, mxz, mxt, myx, myy, myz, myt, mzx, mzy, mzz, mzt);
        }

        // If the dirty region is null and there is a clip node specified, then what
        // happened is that the dirty region of content within this group exceeded
        // the clip of this group, and thus, we should accumulate the bounds of
        // this group into the dirty region. If the bounds of the group exceeds
        // the bounds of the dirty region, then we end up returning null in the
        // end. But the implementation of accumulateNodeDirtyRegion handles this.
        if (clipNode != null &amp;&amp; effectFilter == null) {
            if (status == DirtyRegionContainer.DTR_CONTAINS_CLIP) {
                status = accumulateNodeDirtyRegion(clip, dirtyRegionTemp, originalDirtyRegion, tx, pvTx);
            } else {
                originalDirtyRegion.merge(dirtyRegionContainer);
            }
            regionPool.checkIn(dirtyRegionContainer);
        }
        return status;
    }

    /**
     * Computes the dirty region for this Node. The specified region is in
     * scene coordinates. The specified tx can be used to convert local bounds
     * to scene bounds (it includes everything up to but not including my own
     * transform).
     *
     * @param dirtyRegionTemp A temporary RectBounds that this method can use for scratch.
     *                        In the case that no perspective transform occurs, it is best if
     *                        the returned BaseBounds is this instance.
     * @param tx Any transform that needs to be applied
     * @param pvTx must not be null, it's the perspective transform of the current
     *        perspective camera or identity transform if parallel camera is used.
     */
    private BaseBounds computeDirtyRegion(final RectBounds dirtyRegionTemp,
                                          final BaseTransform tx,
                                          final GeneralTransform3D pvTx)
    {
        if (cacheFilter != null) {
            return cacheFilter.computeDirtyBounds(dirtyRegionTemp, tx, pvTx);
        }
        // The passed in region is a scratch object that exists for me to use,
        // such that I don't have to create a temporary object. So I just
        // hijack it right here to start with. Note that any of the calls
        // in computeDirtyRegion might end up changing the region instance
        // from dirtyRegionTemp (which is a RectBounds) to a BoxBounds if any
        // of the other bounds / transforms involve a perspective transformation.
        BaseBounds region = dirtyRegionTemp;
        if (!dirtyBounds.isEmpty()) {
            region = region.deriveWithNewBounds(dirtyBounds);
        } else {
            // If dirtyBounds is empty, then we will simply set the bounds to
            // be the same as the transformedBounds (since that means the bounds
            // haven't changed and right now we don't support dirty sub regions
            // for generic nodes). This can happen if, for example, this is
            // a group with a clip and the dirty area of child nodes within
            // the group exceeds the bounds of the clip on the group. Just trust me.
            region = region.deriveWithNewBounds(transformedBounds);
        }

        // We shouldn't do anything with empty region, as we may accidentally make
        // it non empty or turn it into some nonsense (like (-1,-1,0,0) )
        if (!region.isEmpty()) {
                // Now that we have the dirty region, we will simply apply the tx
                // to it (after slightly padding it for good luck) to get the scene
                // coordinates for this.
                region = computePadding(region);
                region = tx.transform(region, region);
                region = pvTx.transform(region, region);
        }
        return region;
    }

    /**
     * LCD Text creates some painful situations where, due to the LCD text
     * algorithm, we end up with some pixels touched that are normally outside
     * the bounds. To compensate, we need a hook for NGText to add padding.
     */
    protected BaseBounds computePadding(BaseBounds region) {
        return region;
    }

    /**
     * Marks if the node has some visuals and that the bounds change
     * should be taken into account when using the dirty region.
     * This will be false for NGGroup (but not for NGRegion)
     * @return true if the node has some visuals
     */
    protected boolean hasVisuals() {
        return true;
    }

    /***************************************************************************
     *                                                                         *
     * Culling                                                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Culling support for multiple dirty regions.
     * Set culling bits for the whole graph.
     * @param drc Array of dirty regions. Cannot be null.
     * @param tx The transform for this render operation. Cannot be null.
     * @param pvTx Perspective camera transformation. Cannot be null.
     */
    public final void doPreCulling(DirtyRegionContainer drc, BaseTransform tx, GeneralTransform3D pvTx) {
        if (drc == null || tx == null || pvTx == null) throw new NullPointerException();
        markCullRegions(drc, -1, tx, pvTx);
    }

    /**
     * Marks placement of the node in dirty region encoded into 2 bit flag:
     * 00 - node outside dirty region
     * 01 - node intersecting dirty region
     * 11 - node completely within dirty region
     *
     * 32 bits = 15 regions max. * 2 bit each. The first two bits are not used
     * because we have a special use case for -1, so they should only be set if
     * in that case.
     *
     * @param drc The array of dirty regions.
     * @param cullingRegionsBitsOfParent culling bits of parent. -1 if there's no parent.
     * @param tx The transform for this render operation. Cannot be null.
     * @param pvTx Perspective camera transform. Cannot be null.
     */
    void markCullRegions(
            DirtyRegionContainer drc,
            int cullingRegionsBitsOfParent,
            BaseTransform tx,
            GeneralTransform3D pvTx) {

        // Spent a long time tracking down how cullingRegionsBitsOfParent works. Note that it is
        // not just the parent's bits, but also -1 in the case of the &quot;root&quot;, where the root is
        // either the actual root, or the root of a sub-render operation such as occurs with
        // render-to-texture for effects!

        if (tx.isIdentity()) {
            TEMP_BOUNDS.deriveWithNewBounds(transformedBounds);
        } else {
            tx.transform(transformedBounds, TEMP_BOUNDS);
        }

        if (!pvTx.isIdentity()) {
            pvTx.transform(TEMP_BOUNDS, TEMP_BOUNDS);
        }

        TEMP_BOUNDS.flattenInto(TEMP_RECT_BOUNDS);

        cullingBits = 0;
        RectBounds region;
        int mask = 0x1; // Check only for intersections
        for(int i = 0; i &lt; drc.size(); i++) {
            region = drc.getDirtyRegion(i);
            if (region == null || region.isEmpty()) {
                break;
            }
            // For each dirty region, we will check to see if this child
            // intersects with the dirty region and whether it contains the
            // dirty region. Note however, that we only care to mark those
            // child nodes which are inside a group that intersects. We don't
            // care about marking child nodes which are within a parent which
            // is wholly contained within the dirty region.
            if ((cullingRegionsBitsOfParent == -1 || (cullingRegionsBitsOfParent &amp; mask) != 0) &amp;&amp;
                    region.intersects(TEMP_RECT_BOUNDS)) {
                int b = DIRTY_REGION_INTERSECTS_NODE_BOUNDS;
                if (region.contains(TEMP_RECT_BOUNDS)) {
                    b = DIRTY_REGION_CONTAINS_NODE_BOUNDS;
                }
                cullingBits = cullingBits | (b &lt;&lt; (2 * i));
            }
            mask = mask &lt;&lt; 2;
        }//for

        // If we are going to cull a node/group that's dirty,
        // make sure it's dirty flags are properly cleared.
        if (cullingBits == 0 &amp;&amp; (dirty != DirtyFlag.CLEAN || childDirty)) {
            clearDirtyTree();
        }

//        System.out.printf(&quot;%s bits: %s bounds: %s\n&quot;,
//            this, Integer.toBinaryString(cullingBits), TEMP_RECT_BOUNDS);
    }

    /**
     * Fills the given StringBuilder with text representing the structure of the NG graph insofar as dirty
     * opts is concerned. Used for debug purposes. This is typically called on the root node. The List of
     * roots is the list of dirty roots as determined by successive calls to getRenderRoot for each dirty
     * region. The output will be prefixed with a key indicating how to interpret the printout.
     *
     * @param s A StringBuilder to fill with the output.
     * @param roots The list of render roots (may be empty, must not be null).
     */
    public final void printDirtyOpts(StringBuilder s, List&lt;NGNode&gt; roots) {
        s.append(&quot;\n*=Render Root\n&quot;);
        s.append(&quot;d=Dirty\n&quot;);
        s.append(&quot;dt=Dirty By Translation\n&quot;);
        s.append(&quot;i=Dirty Region Intersects the NGNode\n&quot;);
        s.append(&quot;c=Dirty Region Contains the NGNode\n&quot;);
        s.append(&quot;ef=Effect Filter\n&quot;);
        s.append(&quot;cf=Cache Filter\n&quot;);
        s.append(&quot;cl=This node is a clip node\n&quot;);
        s.append(&quot;b=Blend mode is set\n&quot;);
        s.append(&quot;or=Opaque Region\n&quot;);
        printDirtyOpts(s, this, BaseTransform.IDENTITY_TRANSFORM, &quot;&quot;, roots);
    }

    /**
     * Used for debug purposes. Recursively visits all NGNodes and prints those that are possibly part of
     * the render operation and annotates each node.
     *
     * @param s The String builder
     * @param node The node that we're printing out information about
     * @param tx The transform
     * @param prefix Some prefix to put in front of the node output (mostly spacing)
     * @param roots The different dirty roots, if any.
     */
    private final void printDirtyOpts(StringBuilder s, NGNode node, BaseTransform tx, String prefix, List&lt;NGNode&gt; roots) {
        if (!node.isVisible() || node.getOpacity() == 0) return;

        BaseTransform copy = tx.copy();
        copy = copy.deriveWithConcatenation(node.getTransform());
        List&lt;String&gt; stuff = new ArrayList&lt;&gt;();
        for (int i=0; i&lt;roots.size(); i++) {
            NGNode root = roots.get(i);
            if (node == root) stuff.add(&quot;*&quot; + i);
        }

        if (node.dirty != NGNode.DirtyFlag.CLEAN) {
            stuff.add(node.dirty == NGNode.DirtyFlag.DIRTY ? &quot;d&quot; : &quot;dt&quot;);
        }

        if (node.cullingBits != 0) {
            int mask = 0x11;
            for (int i=0; i&lt;15; i++) {
                int bits = node.cullingBits &amp; mask;
                if (bits != 0) {
                    stuff.add(bits == 1 ? &quot;i&quot; + i : bits == 0 ? &quot;c&quot; + i : &quot;ci&quot; + i);
                }
                mask = mask &lt;&lt; 2;
            }
        }

        if (node.effectFilter != null) stuff.add(&quot;ef&quot;);
        if (node.cacheFilter != null) stuff.add(&quot;cf&quot;);
        if (node.nodeBlendMode != null) stuff.add(&quot;b&quot;);

        RectBounds opaqueRegion = node.getOpaqueRegion();
        if (opaqueRegion != null) {
            RectBounds or = new RectBounds();
            copy.transform(opaqueRegion, or);
            stuff.add(&quot;or=&quot; + or.getMinX() + &quot;, &quot; + or.getMinY() + &quot;, &quot; + or.getWidth() + &quot;, &quot; + or.getHeight());
        }

        if (stuff.isEmpty()) {
            s.append(prefix + node.name + &quot;\n&quot;);
        } else {
            String postfix = &quot; [&quot;;
            for (int i=0; i&lt;stuff.size(); i++) {
                postfix = postfix + stuff.get(i);
                if (i &lt; stuff.size() - 1) postfix += &quot; &quot;;
            }
            s.append(prefix + node.name + postfix + &quot;]\n&quot;);
        }

        if (node.getClipNode() != null) {
            printDirtyOpts(s, node.getClipNode(), copy, prefix + &quot;  cl &quot;, roots);
        }

        if (node instanceof NGGroup) {
            NGGroup g = (NGGroup)node;
            for (int i=0; i&lt;g.getChildren().size(); i++) {
                printDirtyOpts(s, g.getChildren().get(i), copy, prefix + &quot;  &quot;, roots);
            }
        }
    }

    /**
     * Helper method draws rectangles indicating the overdraw rectangles.
     *
     * @param tx The scene-&gt;parent transform.
     * @param pvTx The perspective camera transform.
     * @param clipBounds The bounds in scene coordinates
     * @param colorBuffer A pixel array where each pixel contains a color indicating how many times
     *                    it has been &quot;drawn&quot;
     * @param dirtyRegionIndex the index of the dirty region we're gathering information for. This is
     *                         needed so we can shift the &quot;painted&quot; field to find out if this node
     *                         was drawn in this dirty region.
     */
    public void drawDirtyOpts(final BaseTransform tx, final GeneralTransform3D pvTx,
                              Rectangle clipBounds, int[] colorBuffer, int dirtyRegionIndex) {
        if ((painted &amp; (1 &lt;&lt; (dirtyRegionIndex * 2))) != 0) {
            // Transforming the content bounds (which includes the clip) to screen coordinates
            tx.copy().deriveWithConcatenation(getTransform()).transform(contentBounds, TEMP_BOUNDS);
            if (pvTx != null) pvTx.transform(TEMP_BOUNDS, TEMP_BOUNDS);
            RectBounds bounds = new RectBounds();
            TEMP_BOUNDS.flattenInto(bounds);

            // Adjust the bounds so that they are relative to the clip. The colorBuffer is sized
            // exactly the same as the clip, and the elements of the colorBuffer represent the
            // pixels inside the clip. However the bounds of this node may overlap the clip in
            // some manner, so we adjust them such that x, y, w, h will be the adjusted bounds.
            assert clipBounds.width * clipBounds.height == colorBuffer.length;
            bounds.intersectWith(clipBounds);
            int x = (int) bounds.getMinX() - clipBounds.x;
            int y = (int) bounds.getMinY() - clipBounds.y;
            int w = (int) (bounds.getWidth() + .5);
            int h = (int) (bounds.getHeight() + .5);

            if (w == 0 || h == 0) {
                // I would normally say we should never reach this point, as it means something was
                // marked as painted but really couldn't have been.
                return;
            }

            // x, y, w, h are 0 based and will fit within the clip, so now we can simply update
            // all the pixels that fall within these bounds.
            for (int i = y; i &lt; y+h; i++) {
                for (int j = x; j &lt; x+w; j++) {
                    final int index = i * clipBounds.width + j;
                    int color = colorBuffer[index];

                    // This is kind of a dirty hack. The idea is to show green if 0 or 1
                    // times a pixel is drawn, Yellow for 2 or 3 times, and red for more
                    // Than that. So I use 0x80007F00 as the first green color, and
                    // 0x80008000 as the second green color, but their so close to the same
                    // thing you probably won't be able to tell them apart, but I can tell
                    // numerically they're different and increment (so I use the colors
                    // as my counters).
                    if (color == 0) {
                        color = 0x8007F00;
                    } else if ((painted &amp; (3 &lt;&lt; (dirtyRegionIndex * 2))) == 3) {
                        switch (color) {
                            case 0x80007F00:
                                color = 0x80008000;
                                break;
                            case 0x80008000:
                                color = 0x807F7F00;
                                break;
                            case 0x807F7F00:
                                color = 0x80808000;
                                break;
                            case 0x80808000:
                                color = 0x807F0000;
                                break;
                            default:
                                color = 0x80800000;
                        }
                    }
                    colorBuffer[index] = color;
                }
            }
        }
    }

    /***************************************************************************
     *                                                                         *
     * Identifying render roots                                                *
     *                                                                         *
     **************************************************************************/
    protected static enum RenderRootResult {
        /**
         * A Node returns NO_RENDER_ROOT when it is not a render root because
         * it does not have an opaqueRegion which completely covers the area
         * of the clip. Maybe the node is dirty, but outside the dirty region
         * that we're currently processing. For an NGGroup, returning
         * NO_RENDER_ROOT means that there is no render root (occluder) within
         * this entire branch of the tree.
         */
        NO_RENDER_ROOT,
        /**
         * A Node returns HAS_RENDER_ROOT when its opaque region completely
         * covers the clip. An NGGroup returns HAS_RENDER_ROOT when one of
         * its children either returned HAS_RENDER_ROOT or HAS_RENDER_ROOT_AND_IS_CLEAN.
         */
        HAS_RENDER_ROOT,
        /**
         * A Node returns HAS_RENDER_ROOT_AND_IS_CLEAN when its opaque region
         * completely covers the clip and the Node is, itself, clean. An NGNode
         * returns HAS_RENDER_ROOT_AND_IS_CLEAN only if it had a child that
         * returned HAS_RENDER_ROOT_AND_IS_CLEAN and none of its children drawn
         * above the render root are dirty.
         *
         * This optimization allows us to recognize situations where perhaps there
         * were some dirty nodes, but they are completely covered by an occluder,
         * and therefore we don't actually have to draw anything.
         */
        HAS_RENDER_ROOT_AND_IS_CLEAN,
    }

    /**
     * Called &lt;strong&gt;after&lt;/strong&gt; preCullingBits in order to get the node
     * from which we should begin drawing. This is our support for occlusion culling.
     * This should only be called on the root node.
     *
     * If no render root was found, we need to render everything from this root, so the path will contain this node.
     * If no rendering is needed (everything dirty is occluded), the path will remain empty
     *
     * @param path node path to store the node path
     */
    public final void getRenderRoot(NodePath path, RectBounds dirtyRegion, int cullingIndex,
                                    BaseTransform tx, GeneralTransform3D pvTx) {

        // This is the main entry point, make sure to check these inputs for validity
        if (path == null || dirtyRegion == null || tx == null || pvTx == null) {
            throw new NullPointerException();
        }
        if (cullingIndex &lt; -1 || cullingIndex &gt; 15) {
            throw new IllegalArgumentException(&quot;cullingIndex cannot be &lt; -1 or &gt; 15&quot;);
        }

        // This method must NEVER BE CALLED if the depth buffer is turned on. I don't have a good way to test
        // for that because NGNode doesn't have a reference to the scene it is a part of...

        RenderRootResult result = computeRenderRoot(path, dirtyRegion, cullingIndex, tx, pvTx);
        if (result == RenderRootResult.NO_RENDER_ROOT) {
            // We didn't find any render root, which means that no one node was large enough
            // to obscure the entire dirty region (or, possibly, some combination of nodes in an
            // NGGroup were not, together, large enough to do the job). So we need to render
            // from the root node, which is this node.
            path.add(this);
        } else if (result == RenderRootResult.HAS_RENDER_ROOT_AND_IS_CLEAN) {
            // We've found a render root, and it is clean and everything above it in painter order
            // is clean, so actually we have nothing to paint this time around (some stuff must
            // have been dirty which is completely occluded by the render root). So we can clear
            // the path, which indicates to the caller that nothing needs to be painted.
            path.clear();
        }
    }

    /**
     * Searches for the last node that covers all of the specified dirty region with an opaque region,
     * in this node's subtree. Such a node can serve as a rendering root as all nodes preceding the node
     * will be covered by it.
     *
     * @param path the NodePath to populate with the path to the render root. Cannot be null.
     * @param dirtyRegion the current dirty region. Cannot be null.
     * @param cullingIndex index of culling information
     * @param tx current transform. Cannot be null.
     * @param pvTx current perspective transform. Cannot be null.
     * @return The result of visiting this node.
     */
    RenderRootResult computeRenderRoot(NodePath path, RectBounds dirtyRegion,
                                       int cullingIndex, BaseTransform tx, GeneralTransform3D pvTx) {
        return computeNodeRenderRoot(path, dirtyRegion, cullingIndex, tx, pvTx);
    }

    private static Point2D[] TEMP_POINTS2D_4 =
            new Point2D[] { new Point2D(), new Point2D(), new Point2D(), new Point2D() };

    // Whether (px, py) is clockwise or counter-clockwise to a-&gt;b
    private static int ccw(double px, double py, Point2D a, Point2D b) {
        return (int)Math.signum(((b.x - a.x) * (py - a.y)) - (b.y - a.y) * (px - a.x));
    }

    private static boolean pointInConvexQuad(double x, double y, Point2D[] rect) {
        int ccw01 = ccw(x, y, rect[0], rect[1]);
        int ccw12 = ccw(x, y, rect[1], rect[2]);
        int ccw23 = ccw(x, y, rect[2], rect[3]);
        int ccw31 = ccw(x, y, rect[3], rect[0]);

        // Possible results after this operation:
        // 0 -&gt; 0 (0x0)
        // 1 -&gt; 1 (0x1)
        // -1 -&gt; Integer.MIN_VALUE (0x80000000)
        ccw01 ^= (ccw01 &gt;&gt;&gt; 1);
        ccw12 ^= (ccw12 &gt;&gt;&gt; 1);
        ccw23 ^= (ccw23 &gt;&gt;&gt; 1);
        ccw31 ^= (ccw31 &gt;&gt;&gt; 1);

        final int union = ccw01 | ccw12 | ccw23 | ccw31;
        // This means all ccw* were either (-1 or 0) or (1 or 0), but not all of them were 0
        return union == 0x80000000 || union == 0x1;
        // Or alternatively...
//        return (union ^ (union &lt;&lt; 31)) &lt; 0;
    }

    /**
     * Check if this node can serve as rendering root for this dirty region.
     *
     * @param path the NodePath to populate with the path to the render root. Cannot be null.
     * @param dirtyRegion the current dirty region. Cannot be null.
     * @param cullingIndex index of culling information, -1 means culling information should not be used
     * @param tx current transform. Cannot be null.
     * @param pvTx current perspective transform. Cannot be null.
     * @return NO_RENDER_ROOT if this node does &lt;em&gt;not&lt;/em&gt; have an opaque
     *         region that fills the entire dirty region. Returns HAS_RENDER_ROOT
     *         if the opaque region fills the dirty region.
     */
    final RenderRootResult computeNodeRenderRoot(NodePath path, RectBounds dirtyRegion,
                                                 int cullingIndex, BaseTransform tx, GeneralTransform3D pvTx) {

        // Nodes outside of the dirty region can be excluded immediately.
        // This can be used only if the culling information is provided.
        if (cullingIndex != -1) {
            final int bits = cullingBits &gt;&gt; (cullingIndex * 2);
            if ((bits &amp; DIRTY_REGION_CONTAINS_OR_INTERSECTS_NODE_BOUNDS) == 0x00) {
                return RenderRootResult.NO_RENDER_ROOT;
            }
        }

        if (!isVisible()) {
            return RenderRootResult.NO_RENDER_ROOT;
        }

        final RectBounds opaqueRegion = getOpaqueRegion();
        if (opaqueRegion == null) return RenderRootResult.NO_RENDER_ROOT;

        final BaseTransform localToParentTx = getTransform();

        BaseTransform localToSceneTx = TEMP_TRANSFORM.deriveWithNewTransform(tx).deriveWithConcatenation(localToParentTx);

        // Now check if the dirty region is fully contained in our opaque region. Suppose the above
        // transform included a rotation about Z. In these cases, the transformed
        // opaqueRegion might be some non-axis aligned quad. So what we need to do is to check
        // that each corner of the dirty region lies within the (potentially rotated) quad
        // of the opaqueRegion.
        if (checkBoundsInQuad(opaqueRegion, dirtyRegion, localToSceneTx, pvTx)) {
            // This node is a render root.
            path.add(this);
            return isClean() ? RenderRootResult.HAS_RENDER_ROOT_AND_IS_CLEAN : RenderRootResult.HAS_RENDER_ROOT;
        }

        return RenderRootResult.NO_RENDER_ROOT;
    }

    static boolean checkBoundsInQuad(RectBounds untransformedQuad,
            RectBounds innerBounds, BaseTransform tx, GeneralTransform3D pvTx) {

        if (pvTx.isIdentity() &amp;&amp; (tx.getType() &amp; ~(BaseTransform.TYPE_TRANSLATION
                | BaseTransform.TYPE_QUADRANT_ROTATION
                | BaseTransform.TYPE_MASK_SCALE)) == 0) {
            // If pvTx is identity and there's simple transformation that will result in axis-aligned rectangle,
            // we can do a quick test by using bound.contains()
            if (tx.isIdentity()) {
                TEMP_BOUNDS.deriveWithNewBounds(untransformedQuad);
            } else {
                tx.transform(untransformedQuad, TEMP_BOUNDS);
            }

            TEMP_BOUNDS.flattenInto(TEMP_RECT_BOUNDS);

            return TEMP_RECT_BOUNDS.contains(innerBounds);
        } else {
            TEMP_POINTS2D_4[0].setLocation(untransformedQuad.getMinX(), untransformedQuad.getMinY());
            TEMP_POINTS2D_4[1].setLocation(untransformedQuad.getMaxX(), untransformedQuad.getMinY());
            TEMP_POINTS2D_4[2].setLocation(untransformedQuad.getMaxX(), untransformedQuad.getMaxY());
            TEMP_POINTS2D_4[3].setLocation(untransformedQuad.getMinX(), untransformedQuad.getMaxY());

            for (Point2D p : TEMP_POINTS2D_4) {
                tx.transform(p, p);
                if (!pvTx.isIdentity()) {
                    pvTx.transform(p, p);
                }
            }

            return (pointInConvexQuad(innerBounds.getMinX(), innerBounds.getMinY(), TEMP_POINTS2D_4)
                    &amp;&amp; pointInConvexQuad(innerBounds.getMaxX(), innerBounds.getMinY(), TEMP_POINTS2D_4)
                    &amp;&amp; pointInConvexQuad(innerBounds.getMaxX(), innerBounds.getMaxY(), TEMP_POINTS2D_4)
                    &amp;&amp; pointInConvexQuad(innerBounds.getMinX(), innerBounds.getMaxY(), TEMP_POINTS2D_4));
        }
    }

    /**
     * Invalidates any cached representation of the opaque region for this node. On the next
     * call to getOpaqueRegion, the opaque region will be recalculated. Any changes to state
     * which is used in the {@link #hasOpaqueRegion()} call must invoke this method
     * or the opaque region calculations will be wrong.
     */
    protected final void invalidateOpaqueRegion() {
        opaqueRegionInvalid = true;
        if (isClip) parent.invalidateOpaqueRegion();
    }

    /**
     * This method exists only for the sake of testing.
     * @return value of opaqueRegionInvalid
     */
    final boolean isOpaqueRegionInvalid() {
        return opaqueRegionInvalid;
    }

    /**
     * Gets the opaque region for this node, if there is one, or returns null.
     * @return The opaque region for this node, or null.
     */
    public final RectBounds getOpaqueRegion() {
        // Note that when we invalidate the opaqueRegion of an NGNode, we don't
        // walk up the tree or communicate with the parents (unlike dirty flags).
        // An NGGroup does not compute an opaqueRegion based on the union of opaque
        // regions of its children (although this is a fine idea to consider!). See RT-32441
        // If we ever fix RT-32441, we must be sure to handle the case of a Group being used
        // as a clip node (such that invalidating a child on the group invalidates the
        // opaque region of every node up to the root).

        // Because the Effect classes have no reference to NGNode, they cannot tell the
        // NGNode to invalidate the opaque region whenever properties on the Effect that
        // would impact the opaqueRegion change. As a result, when an Effect is specified
        // on the NGNode, we will always treat it as if it were invalid. A more invasive
        // (but better) change would be to give Effect the ability to invalidate the
        // NGNode's opaque region when needed.
        if (opaqueRegionInvalid || getEffect() != null) {
            opaqueRegionInvalid = false;
            if (supportsOpaqueRegions() &amp;&amp; hasOpaqueRegion()) {
                opaqueRegion = computeOpaqueRegion(opaqueRegion == null ? new RectBounds() : opaqueRegion);
                // If we got a null result then we encountered an error condition where somebody
                // claimed supportsOpaqueRegions and hasOpaqueRegion, but then they
                // returned null! This should never happen, so we have an assert here. However since
                // assertions are disabled at runtime and we want to avoid the NPE, we also perform
                // a null check.
                assert opaqueRegion != null;
                if (opaqueRegion == null) {
                    return null;
                }
                // If there is a clip, then we need to determine the opaque region of the clip, and
                // intersect that with our existing opaque region. For example, if I had a rectangle
                // with a circle for its clip (centered over the rectangle), then the result needs to
                // be the circle's opaque region.
                final NGNode clip = getClipNode();
                if (clip != null) {
                    final RectBounds clipOpaqueRegion = clip.getOpaqueRegion();
                    // Technically a flip/quadrant rotation is allowed as well, but we don't have a convenient
                    // way to do that yet.
                    if (clipOpaqueRegion == null || (clip.getTransform().getType() &amp; ~(BaseTransform.TYPE_TRANSLATION | BaseTransform.TYPE_MASK_SCALE)) != 0) {
                        // RT-25095: If this node has a clip who's opaque region cannot be determined, then
                        // we cannot determine any opaque region for this node (in fact, it might not have one).
                        // Also, if the transform is something other than identity, scale, or translate then
                        // we're just going to bail (sorry, rotate, maybe next time!)
                        return opaqueRegion = null;
                    }
                    // We have to take into account any transform specified on the clip to put
                    // it into the same coordinate system as this node
                    final BaseBounds b = clip.getTransform().transform(clipOpaqueRegion, TEMP_BOUNDS);
                    b.flattenInto(TEMP_RECT_BOUNDS);
                    opaqueRegion.intersectWith(TEMP_RECT_BOUNDS);

                }
            } else {
                // The opaqueRegion may have been non-null in the past, but there isn't an opaque region now,
                // so we will nuke it to save some memory
                opaqueRegion = null;
            }
        }

        return opaqueRegion;
    }

    /**
     * Gets whether this NGNode supports opaque regions at all. Most node types do not,
     * but some do. If an NGNode subclass is written to support opaque regions, it must override
     * this method to return true. The subclass must then also override the computeDirtyRegion method
     * to return the dirty region, or null if the node in its current state doesn't have one.
     * This method is intended to be immutable.
     *
     * @return Whether this NGNode implementation supports opaque regions. This could also have been
     *         implemented via an interface that some NGNodes implemented, but then we'd have instanceof
     *         checks which I'd rather avoid.
     */
    protected boolean supportsOpaqueRegions() { return false; }

    /**
     * Called only on NGNode subclasses which override {@link #supportsOpaqueRegions()} to return
     * true, this method will return whether or not this NGNode is in a state where it has
     * an opaque region to actually return. If this method returns true, a subsequent call to
     * {@link #computeOpaqueRegion(com.sun.javafx.geom.RectBounds)} &lt;strong&gt;must&lt;/strong&gt; return
     * a non-null result. Any state used in the computation of this method, when it changes, must
     * result in a call to {@link #invalidateOpaqueRegion()}.
     *
     * @return Whether this NGNode currently has an opaque region.
     */
    protected boolean hasOpaqueRegion() {
        final NGNode clip = getClipNode();
        final Effect effect = getEffect();
        return (effect == null || !effect.reducesOpaquePixels()) &amp;&amp;
               getOpacity() == 1f &amp;&amp;
               (nodeBlendMode == null || nodeBlendMode == Blend.Mode.SRC_OVER) &amp;&amp;
               (clip == null ||
               (clip.supportsOpaqueRegions() &amp;&amp; clip.hasOpaqueRegion()));
    }

    /**
     * Computes and returns the opaque region for this node. This method
     * @param opaqueRegion
     * @return
     */
    protected RectBounds computeOpaqueRegion(RectBounds opaqueRegion) {
        return null;
    }

    /**
     * Returns whether a clip represented by this node can be rendered using
     * axis aligned rect clip. The default implementation returns false,
     * specific subclasses should override to return true when appropriate.
     *
     * @return whether this rectangle is axis aligned when rendered given node's
     * and rendering transform
     */
    protected boolean isRectClip(BaseTransform xform, boolean permitRoundedRectangle) {
        return false;
    }

    /***************************************************************************
     *                                                                         *
     * Rendering                                                               *
     *                                                                         *
     **************************************************************************/

    /**
     * Render the tree of nodes to the specified G (graphics) object
     * descending from this node as the root. This method is designed to avoid
     * generated trash as much as possible while descending through the
     * render graph while rendering. This is the appropriate method both to
     * initiate painting of an entire scene, and for a branch. The NGGroup
     * implementation must call this method on each child, not doRender directly.
     *
     * @param g The graphics object we're rendering to. This must never be null.
     */
    public final void render(Graphics g) {
        if (PULSE_LOGGING_ENABLED) {
            PulseLogger.incrementCounter(&quot;Nodes visited during render&quot;);
        }
        // Clear the visuals changed flag
        clearDirty();
        // If it isn't visible, then punt
        if (!visible || opacity == 0f) return;

        // We know that we are going to render this node, so we call the
        // doRender method, which subclasses implement to do the actual
        // rendering work.
        doRender(g);
    }

    /**
     * Called on every render pulse for all nodes in case they have render-time
     * operations that must be completed on a pulse, but were not otherwise
     * rendered by the ordinary damage management logic.
     * The graphics argument will be the graphics that was used to render the
     * scene if it is available, but may be null for cases when the scene
     * required no visible updates and thus no back buffer graphics was
     * actually obtained.  Implementors must have a backup plan for that
     * case when the Graphics object is null.
     *
     * @param gOptional the Graphics object that was used to render the
     *                  Scene, or null
     */
    public void renderForcedContent(Graphics gOptional) {
    }

    // This node requires 2D graphics state for rendering
    boolean isShape3D() {
        return false;
    }

    /**
     * Invoked only by the final render method. Implementations
     * of this method should make sure to save &amp; restore the transform state.
     */
    protected void doRender(Graphics g) {

        g.setState3D(isShape3D());

        boolean preCullingTurnedOff = false;
        if (PrismSettings.dirtyOptsEnabled) {
            if (g.hasPreCullingBits()) {
                //preculling bits available
                final int bits = cullingBits &gt;&gt; (g.getClipRectIndex() * 2);
                if ((bits &amp; DIRTY_REGION_CONTAINS_OR_INTERSECTS_NODE_BOUNDS) == 0) {
                    // If no culling bits are set for this region, this group
                    // does not intersect (nor is covered by) the region
                    return;
                } else if ((bits &amp; DIRTY_REGION_CONTAINS_NODE_BOUNDS) != 0) {
                    // When this group is fully covered by the region,
                    // turn off the culling checks in the subtree, as everything
                    // gets rendered
                    g.setHasPreCullingBits(false);
                    preCullingTurnedOff = true;
                }
            }
        }

        // save current depth test state
        boolean prevDepthTest = g.isDepthTest();

        // Apply Depth test for this node
        // (note that this will only be used if we have a depth buffer for the
        // surface to which we are rendering)
        g.setDepthTest(isDepthTest());

        // save current transform state
        BaseTransform prevXform = g.getTransformNoClone();

        double mxx = prevXform.getMxx();
        double mxy = prevXform.getMxy();
        double mxz = prevXform.getMxz();
        double mxt = prevXform.getMxt();

        double myx = prevXform.getMyx();
        double myy = prevXform.getMyy();
        double myz = prevXform.getMyz();
        double myt = prevXform.getMyt();

        double mzx = prevXform.getMzx();
        double mzy = prevXform.getMzy();
        double mzz = prevXform.getMzz();
        double mzt = prevXform.getMzt();

        // filters are applied in the following order:
        //   transform
        //   blend mode
        //   opacity
        //   cache
        //   clip
        //   effect
        // The clip must be below the cache filter, as this is expected in the
        // CacheFilter in order to apply scrolling optimization
        g.transform(getTransform());
        // Try to keep track of whether this node was *really* painted. Still an
        // approximation, but somewhat more accurate (at least it doesn't include
        // groups which don't paint anything themselves).
        boolean p = false;
        // NOTE: Opt out 2D operations on 3D Shapes, which are not yet handled by Prism
        if (!isShape3D() &amp;&amp; g instanceof ReadbackGraphics &amp;&amp; needsBlending()) {
            renderNodeBlendMode(g);
            p = true;
        } else if (!isShape3D() &amp;&amp; getOpacity() &lt; 1f) {
            renderOpacity(g);
            p = true;
        } else if (!isShape3D() &amp;&amp; getCacheFilter() != null) {
            renderCached(g);
            p = true;
        } else if (!isShape3D() &amp;&amp; getClipNode() != null) {
            renderClip(g);
            p = true;
        } else if (!isShape3D() &amp;&amp; getEffectFilter() != null &amp;&amp; effectsSupported) {
            renderEffect(g);
            p = true;
        } else {
            renderContent(g);
            if (PrismSettings.showOverdraw) {
                p = this instanceof NGRegion || !(this instanceof NGGroup);
            }
        }

        if (preCullingTurnedOff) {
            g.setHasPreCullingBits(true);
        }

        // restore previous transform state
        g.setTransform3D(mxx, mxy, mxz, mxt,
                         myx, myy, myz, myt,
                         mzx, mzy, mzz, mzt);

        // restore previous depth test state
        g.setDepthTest(prevDepthTest);

        if (PULSE_LOGGING_ENABLED) {
            PulseLogger.incrementCounter(&quot;Nodes rendered&quot;);
        }

        // Used for debug purposes. This is not entirely accurate, as it doesn't measure the
        // number of times this node drew to the pixels, and in some cases reports a node as
        // having been drawn even when it didn't lay down any pixels. We'd need to integrate
        // with our shaders or do something much more invasive to get better data here.
        if (PrismSettings.showOverdraw) {
            if (p) {
                painted |= 3 &lt;&lt; (g.getClipRectIndex() * 2);
            } else {
                painted |= 1 &lt;&lt; (g.getClipRectIndex() * 2);
            }
        }
    }

    /**
     * Return true if this node has a blend mode that requires special
     * processing.
     * Regular nodes can handle null or SRC_OVER just by rendering into
     * the existing buffer.
     * Groups override this since they must collect their children into
     * a single rendering pass if their mode is explicitly SRC_OVER.
     * @return true if this node needs special blending support
     */
    protected boolean needsBlending() {
        Blend.Mode mode = getNodeBlendMode();
        return (mode != null &amp;&amp; mode != Blend.Mode.SRC_OVER);
    }

    private void renderNodeBlendMode(Graphics g) {
        // The following is safe; curXform will not be mutated below
        BaseTransform curXform = g.getTransformNoClone();

        BaseBounds clipBounds = getClippedBounds(new RectBounds(), curXform);
        if (clipBounds.isEmpty()) {
            clearDirtyTree();
            return;
        }

        if (!isReadbackSupported(g)) {
            if (getOpacity() &lt; 1f) {
                renderOpacity(g);
            } else if (getClipNode() != null) {
                renderClip(g);
            } else {
                renderContent(g);
            }
            return;
        }

        // TODO: optimize this (RT-26936)
        // Extract clip bounds
        Rectangle clipRect = new Rectangle(clipBounds);
        clipRect.intersectWith(PrEffectHelper.getGraphicsClipNoClone(g));

        // render the node content into the first offscreen image
        FilterContext fctx = getFilterContext(g);
        PrDrawable contentImg = (PrDrawable)
            Effect.getCompatibleImage(fctx, clipRect.width, clipRect.height);
        if (contentImg == null) {
            clearDirtyTree();
            return;
        }
        Graphics gContentImg = contentImg.createGraphics();
        gContentImg.setHasPreCullingBits(g.hasPreCullingBits());
        gContentImg.setClipRectIndex(g.getClipRectIndex());
        gContentImg.translate(-clipRect.x, -clipRect.y);
        gContentImg.transform(curXform);
        if (getOpacity() &lt; 1f) {
            renderOpacity(gContentImg);
        } else if (getCacheFilter() != null) {
            renderCached(gContentImg);
        } else if (getClipNode() != null) {
            renderClip(g);
        } else if (getEffectFilter() != null) {
            renderEffect(gContentImg);
        } else {
            renderContent(gContentImg);
        }

        // the above image has already been rendered in device space, so
        // just translate to the node origin in device space here...
        RTTexture bgRTT = ((ReadbackGraphics) g).readBack(clipRect);
        PrDrawable bgPrD = PrDrawable.create(fctx, bgRTT);
        Blend blend = new Blend(getNodeBlendMode(),
                                new PassThrough(bgPrD, clipRect),
                                new PassThrough(contentImg, clipRect));
        CompositeMode oldmode = g.getCompositeMode();
        g.setTransform(null);
        g.setCompositeMode(CompositeMode.SRC);
        PrEffectHelper.render(blend, g, 0, 0, null);
        g.setCompositeMode(oldmode);
        // transform state will be restored in render() method above...

        Effect.releaseCompatibleImage(fctx, contentImg);
        ((ReadbackGraphics) g).releaseReadBackBuffer(bgRTT);
    }

    private void renderRectClip(Graphics g, NGRectangle clipNode) {
        BaseBounds newClip = clipNode.getShape().getBounds();
        if (!clipNode.getTransform().isIdentity()) {
            newClip = clipNode.getTransform().transform(newClip, newClip);
        }
        final BaseTransform curXform = g.getTransformNoClone();
        final Rectangle curClip = g.getClipRectNoClone();
        newClip = curXform.transform(newClip, newClip);
        newClip.intersectWith(PrEffectHelper.getGraphicsClipNoClone(g));
        if (newClip.isEmpty() ||
            newClip.getWidth() == 0 ||
            newClip.getHeight() == 0) {
            clearDirtyTree();
            return;
        }
        // REMIND: avoid garbage by changing setClipRect to accept xywh
        g.setClipRect(new Rectangle(newClip));
        renderForClip(g);
        g.setClipRect(curClip);
        clipNode.clearDirty(); // as render() is not called on the clipNode,
                               // make sure the dirty flags are cleared
    }

    void renderClip(Graphics g) {
        //  if clip's opacity is 0 there's nothing to render
        if (getClipNode().getOpacity() == 0.0) {
            clearDirtyTree();
            return;
        }

        // The following is safe; curXform will not be mutated below
        BaseTransform curXform = g.getTransformNoClone();

        BaseBounds clipBounds = getClippedBounds(new RectBounds(), curXform);
        if (clipBounds.isEmpty()) {
            clearDirtyTree();
            return;
        }

        if (getClipNode() instanceof NGRectangle) {
            // optimized case for rectangular clip
            NGRectangle rectNode = (NGRectangle)getClipNode();
            if (rectNode.isRectClip(curXform, false)) {
                renderRectClip(g, rectNode);
                return;
            }
        }

        // TODO: optimize this (RT-26936)
        // Extract clip bounds
        Rectangle clipRect = new Rectangle(clipBounds);
        clipRect.intersectWith(PrEffectHelper.getGraphicsClipNoClone(g));

        if (!curXform.is2D()) {
            Rectangle savedClip = g.getClipRect();
            g.setClipRect(clipRect);
            NodeEffectInput clipInput =
                new NodeEffectInput(getClipNode(),
                                    NodeEffectInput.RenderType.FULL_CONTENT);
            NodeEffectInput nodeInput =
                new NodeEffectInput(this,
                                    NodeEffectInput.RenderType.CLIPPED_CONTENT);
            Blend blend = new Blend(Blend.Mode.SRC_IN, clipInput, nodeInput);
            PrEffectHelper.render(blend, g, 0, 0, null);
            clipInput.flush();
            nodeInput.flush();
            g.setClipRect(savedClip);
            // There may have been some errors in the application of the
            // effect and we would not know to what extent the nodes were
            // rendered and cleared or left dirty.  clearDirtyTree() will
            // clear both this node its clip node, and it will not recurse
            // to the children unless they are still marked dirty.  It should
            // be cheap if there was no problem and thorough if there was...
            clearDirtyTree();
            return;
        }

        // render the node content into the first offscreen image
        FilterContext fctx = getFilterContext(g);
        PrDrawable contentImg = (PrDrawable)
            Effect.getCompatibleImage(fctx, clipRect.width, clipRect.height);
        if (contentImg == null) {
            clearDirtyTree();
            return;
        }
        Graphics gContentImg = contentImg.createGraphics();
        gContentImg.setExtraAlpha(g.getExtraAlpha());
        gContentImg.setHasPreCullingBits(g.hasPreCullingBits());
        gContentImg.setClipRectIndex(g.getClipRectIndex());
        gContentImg.translate(-clipRect.x, -clipRect.y);
        gContentImg.transform(curXform);
        renderForClip(gContentImg);

        // render the mask (clipNode) into the second offscreen image
        PrDrawable clipImg = (PrDrawable)
            Effect.getCompatibleImage(fctx, clipRect.width, clipRect.height);
        if (clipImg == null) {
            getClipNode().clearDirtyTree();
            Effect.releaseCompatibleImage(fctx, contentImg);
            return;
        }
        Graphics gClipImg = clipImg.createGraphics();
        gClipImg.translate(-clipRect.x, -clipRect.y);
        gClipImg.transform(curXform);
        getClipNode().render(gClipImg);

        // the above images have already been rendered in device space, so
        // just translate to the node origin in device space here...
        g.setTransform(null);
        Blend blend = new Blend(Blend.Mode.SRC_IN,
                                new PassThrough(clipImg, clipRect),
                                new PassThrough(contentImg, clipRect));
        PrEffectHelper.render(blend, g, 0, 0, null);
        // transform state will be restored in render() method above...

        Effect.releaseCompatibleImage(fctx, contentImg);
        Effect.releaseCompatibleImage(fctx, clipImg);
    }

    void renderForClip(Graphics g) {
        if (getEffectFilter() != null) {
            renderEffect(g);
        } else {
            renderContent(g);
        }
    }

    private void renderOpacity(Graphics g) {
        if (getEffectFilter() != null ||
<A NAME="12"></A>            getCacheFilter() != null ||
            getClipNode() != null ||
            !hasOverlappingContents())
        <FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#12',2,'match31-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
            // if the node has a non-null effect or cached==true, we don't
            // need to bother rendering to an offscreen here because the
            // contents will be flattened as part of rendering the effect
            // (or creating the cached image)
            float ea = g.getExtraAlpha();
            g.setExtraAlpha(ea*getOpacity());
            if (getCacheFilter() != null) {
                renderCached(g);
            } else if (getClipNode() != null) {</B></FONT>
                renderClip(g);
            } else if (getEffectFilter() != null) {
                renderEffect(g);
            } else {
                renderContent(g);
            }
            g.setExtraAlpha(ea);
            return;
        }

        FilterContext fctx = getFilterContext(g);
        BaseTransform curXform = g.getTransformNoClone();
        BaseBounds bounds = getContentBounds(new RectBounds(), curXform);
        Rectangle r = new Rectangle(bounds);
        r.intersectWith(PrEffectHelper.getGraphicsClipNoClone(g));
        PrDrawable img = (PrDrawable)
            Effect.getCompatibleImage(fctx, r.width, r.height);
        if (img == null) {
            return;
        }
        Graphics gImg = img.createGraphics();
        gImg.setHasPreCullingBits(g.hasPreCullingBits());
        gImg.setClipRectIndex(g.getClipRectIndex());
        gImg.translate(-r.x, -r.y);
        gImg.transform(curXform);
        renderContent(gImg);
        // img contents have already been rendered in device space, so
        // just translate to the node origin in device space here...
        g.setTransform(null);
        float ea = g.getExtraAlpha();
        g.setExtraAlpha(getOpacity()*ea);
        g.drawTexture(img.getTextureObject(), r.x, r.y, r.width, r.height);
        g.setExtraAlpha(ea);
        // transform state will be restored in render() method above...
        Effect.releaseCompatibleImage(fctx, img);
    }

    private void renderCached(Graphics g) {
        // We will punt on 3D completely for caching.
        // The first check is for any of its children contains a 3D Transform.
        // The second check is for any of its parents and itself has a 3D Transform
        // The third check is for the printing case, which doesn't use cached
        // bitmaps for the screen and for which there is no cacheFilter.
        if (isContentBounds2D() &amp;&amp; g.getTransformNoClone().is2D() &amp;&amp;
                !(g instanceof com.sun.prism.PrinterGraphics)) {
            getCacheFilter().render(g);
        } else {
            renderContent(g);
        }
    }

    protected void renderEffect(Graphics g) {
        getEffectFilter().render(g);
    }

    protected abstract void renderContent(Graphics g);

    protected abstract boolean hasOverlappingContents();

    /***************************************************************************
     *                                                                         *
     *                       Static Helper Methods.                            *
     *                                                                         *
     **************************************************************************/

    boolean isReadbackSupported(Graphics g) {
        return ((g instanceof ReadbackGraphics) &amp;&amp;
                ((ReadbackGraphics) g).canReadBack());
    }

    /***************************************************************************
     *                                                                         *
     *                      Filters (Cache, Effect, etc).                      *
     *                                                                         *
     **************************************************************************/

    static FilterContext getFilterContext(Graphics g) {
        Screen s = g.getAssociatedScreen();
        if (s == null) {
            return PrFilterContext.getPrinterContext(g.getResourceFactory());
        } else {
            return PrFilterContext.getInstance(s);
        }
    }

    /**
     * A custom effect implementation that has a filter() method that
     * simply wraps the given pre-rendered PrDrawable in an ImageData
     * and returns that result.  This is only used by the renderClip()
     * implementation so we cut some corners here (for example, we assume
     * that the given PrDrawable image is already in device space).
     */
    private static class PassThrough extends Effect {
        private PrDrawable img;
        private Rectangle bounds;

        PassThrough(PrDrawable img, Rectangle bounds) {
            this.img = img;
            this.bounds = bounds;
        }

        @Override
        public ImageData filter(FilterContext fctx,
                                BaseTransform transform,
                                Rectangle outputClip,
                                Object renderHelper,
                                Effect defaultInput)
        {
            img.lock();
            ImageData id = new ImageData(fctx, img, new Rectangle(bounds));
            id.setReusable(true);
            return id;
        }

        @Override
        public RectBounds getBounds(BaseTransform transform,
                                  Effect defaultInput)
        {
            return new RectBounds(bounds);
        }

        @Override
        public AccelType getAccelType(FilterContext fctx) {
            return AccelType.INTRINSIC;
        }

        @Override
        public boolean reducesOpaquePixels() {
            return false;
        }

        @Override
        public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
            return null; //Never called
        }
    }

    /***************************************************************************
     *                                                                         *
     * Stuff                                                                   *
     *                                                                         *
     **************************************************************************/

    public void release() {
    }

    @Override public String toString() {
        return name == null ? super.toString() : name;
    }

    public void applyTransform(final BaseTransform tx, DirtyRegionContainer drc) {
        for (int i = 0; i &lt; drc.size(); i++) {
            drc.setDirtyRegion(i, (RectBounds) tx.transform(drc.getDirtyRegion(i), drc.getDirtyRegion(i)));
            if (drc.checkAndClearRegion(i)) {
                --i;
            }
        }
    }

    public void applyClip(final BaseBounds clipBounds, DirtyRegionContainer drc) {
        for (int i = 0; i &lt; drc.size(); i++) {
            drc.getDirtyRegion(i).intersectWith(clipBounds);
            if (drc.checkAndClearRegion(i)) {
                --i;
            }
        }
    }

    public void applyEffect(final EffectFilter effectFilter, DirtyRegionContainer drc, DirtyRegionPool regionPool) {
        Effect effect = effectFilter.getEffect();
        EffectDirtyBoundsHelper helper = EffectDirtyBoundsHelper.getInstance();
        helper.setInputBounds(contentBounds);
        helper.setDirtyRegions(drc);
        final DirtyRegionContainer effectDrc = effect.getDirtyRegions(helper, regionPool);
        drc.deriveWithNewContainer(effectDrc);
        regionPool.checkIn(effectDrc);
    }

    private static class EffectDirtyBoundsHelper extends Effect {
        private BaseBounds bounds;
        private static EffectDirtyBoundsHelper instance = null;
        private DirtyRegionContainer drc;

        public void setInputBounds(BaseBounds inputBounds) {
            bounds = inputBounds;
        }

        @Override
        public ImageData filter(FilterContext fctx,
                BaseTransform transform,
                Rectangle outputClip,
                Object renderHelper,
                Effect defaultInput) {
            throw new UnsupportedOperationException();
        }

        @Override
        public BaseBounds getBounds(BaseTransform transform, Effect defaultInput) {
            if (bounds.getBoundsType() == BaseBounds.BoundsType.RECTANGLE) {
                return bounds;
            } else {
                //RT-29453 - CCE: in case we get 3D bounds we need to &quot;flatten&quot; them
                return new RectBounds(bounds.getMinX(), bounds.getMinY(), bounds.getMaxX(), bounds.getMaxY());
            }
        }

        @Override
        public Effect.AccelType getAccelType(FilterContext fctx) {
            return null;
        }

        public static EffectDirtyBoundsHelper getInstance() {
            if (instance == null) {
                instance = new EffectDirtyBoundsHelper();
            }
            return instance;
        }

        @Override
        public boolean reducesOpaquePixels() {
            return true;
        }

        private void setDirtyRegions(DirtyRegionContainer drc) {
            this.drc = drc;
        }

        @Override
        public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
            DirtyRegionContainer ret = regionPool.checkOut();
            ret.deriveWithNewContainer(drc);

            return ret;
        }

    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/sg/prism/NGPath.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.sg.prism;

import javafx.scene.shape.FillRule;
import com.sun.javafx.geom.Arc2D;
import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.PathIterator;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.transform.BaseTransform;

/**
 */
public class NGPath extends NGShape {

    private Path2D p = new Path2D();

    public void reset() {
        p.reset();
    }

    public void update() {
        geometryChanged();
    }

    private int toWindingRule(FillRule rule) {
        if (rule == FillRule.NON_ZERO) {
            return Path2D.WIND_NON_ZERO;
        } else {
            return Path2D.WIND_EVEN_ODD;
        }
<A NAME="47"></A>    }

    public void setFillRule(FillRule fillRule) {
        p.setWindingRule(<FONT color="#d16587"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#47',2,'match31-top.html#47',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>toWindingRule(fillRule));
    }

    public float getCurrentX() {
        return p.getCurrentPoint().x;
    }

    public float getCurrentY() {
        return p.getCurrentPoint().y;
    }

    public void addClosePath() {
        p.closePath();
    }

    public void addMoveTo(float x</B></FONT>, float y) {
        p.moveTo(x, y);
    }

    public void addLineTo(float x, float y) {
        p.lineTo(x, y);
    }

    public void addQuadTo(float ctrlx, float ctrly, float x, float y) {
        p.quadTo(ctrlx, ctrly, x, y);
    }

    public void addCubicTo(float ctrlx1, float ctrly1,
                           float ctrlx2, float ctrly2,
                           float x, float y)
    {
        p.curveTo(ctrlx1, ctrly1, ctrlx2, ctrly2, x, y);
    }

    public void addArcTo(float arcX, float arcY, float arcW, float arcH,
                         float arcStart, float arcExtent, float xAxisRotation)
    {
        Arc2D arc = new Arc2D(arcX, arcY, arcW, arcH, arcStart, arcExtent, Arc2D.OPEN);
        BaseTransform xform = xAxisRotation == 0.0 ? null :
                BaseTransform.getRotateInstance(xAxisRotation,
                                                arc.getCenterX(), arc.getCenterY());
        PathIterator pi = arc.getPathIterator(xform);
        // RT-8926, append(true) converts the initial moveTo into a
        // lineTo which can generate huge miter joins if the segment
        // is small enough.  So, we manually skip it here instead.
        pi.next();
        p.append(pi, true);
    }

    public Path2D getGeometry() {
        return p;
    }

    @Override
    public Shape getShape() {
        return p;
    }

    public boolean acceptsPath2dOnUpdate() {
        return true;
    }

    public void updateWithPath2d(Path2D path) {
        p.setTo(path);
        geometryChanged();
    }


}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/sg/prism/NGRegion.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.sg.prism;

import javafx.geometry.Insets;
import javafx.geometry.Side;
import javafx.scene.layout.Background;
import javafx.scene.layout.BackgroundFill;
import javafx.scene.layout.BackgroundImage;
import javafx.scene.layout.BackgroundPosition;
import javafx.scene.layout.BackgroundRepeat;
import javafx.scene.layout.BackgroundSize;
import javafx.scene.layout.Border;
import javafx.scene.layout.BorderImage;
import javafx.scene.layout.BorderRepeat;
import javafx.scene.layout.BorderStroke;
import javafx.scene.layout.BorderStrokeStyle;
import javafx.scene.layout.BorderWidths;
import javafx.scene.layout.CornerRadii;
import javafx.scene.paint.Color;
import javafx.scene.paint.LinearGradient;
import javafx.scene.shape.StrokeLineCap;
import javafx.scene.shape.StrokeLineJoin;
import javafx.scene.shape.StrokeType;

import java.util.Collections;
import java.util.List;
import java.util.WeakHashMap;

import com.sun.glass.ui.Screen;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.logging.PulseLogger;
import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.tk.Toolkit;
import com.sun.prism.BasicStroke;
import com.sun.prism.Graphics;
import com.sun.prism.Image;
import com.sun.prism.RTTexture;
import com.sun.prism.Texture;
import com.sun.prism.impl.PrismSettings;
import com.sun.prism.paint.ImagePattern;
import com.sun.prism.paint.Paint;
import com.sun.scenario.effect.Offset;

/**
 * Implementation of the Region peer. This behaves like an NGGroup, in that
 * it has children, but like a leaf node, in that it also draws itself if it has
 * a Background or Border which contains non-transparent fills / strokes / images.
 */
public class NGRegion extends NGGroup {
    /**
     * This scratch transform is used when transforming shapes. Because this is
     * a static variable, it is only intended to be used from a single thread,
     * the render thread in this case.
     */
    private static final Affine2D SCRATCH_AFFINE = new Affine2D();

    /**
     * Temporary rect for general use. Because this is a static variable,
     * it is only intended to be used from a single thread, the render thread
     * in this case.
     */
    private static final Rectangle TEMP_RECT = new Rectangle();

    /**
     * Screen to RegionImageCache mapping. This mapping is required as textures
     * are only valid in graphics context used to create them (relies on a one
     * to one mapping between Screen and GraphicsContext).
     */
    private static WeakHashMap&lt;Screen, RegionImageCache&gt; imageCacheMap = new WeakHashMap&lt;&gt;();

    /**
     * Indicates the cached image can be sliced vertically.
     */
    private static final int CACHE_SLICE_V = 0x1;

    /**
     * Indicates the cached image can be sliced horizontally.
     */
    private static final int CACHE_SLICE_H = 0x2;

    /**
     * The background to use for drawing. Since this is an immutable object, I can simply refer to
     * its fields / methods directly when rendering. I will make sure this is not ever null at
     * the time that we do the sync, so that the code in this class can assume non-null.
     */
    private Background background = Background.EMPTY;

    /**
     * The combined insets of all the backgrounds. As of right now, Background doesn't store
     * this information itself, although it probably could (and probably should).
     */
    private Insets backgroundInsets = Insets.EMPTY;

    /**
     * The border to use for drawing. Similar to background, this is not-null and immutable.
     */
    private Border border = Border.EMPTY;

    /**
     * The normalized list of CornerRadii have been precomputed at the FX layer to
     * properly account for percentages, insets and radii scaling to prevent
     * the radii from overflowing the dimensions of the region.
     * The List objects are shared with the FX layer and are therefore
     * unmodifiable.  If the normalized list is null then it means that all
     * of the raw radii in the list were already absolute and non-overflowing
     * and so the originals can be used from the arrays of strokes and fills.
     */
    private List&lt;CornerRadii&gt; normalizedFillCorners;
    private List&lt;CornerRadii&gt; normalizedStrokeCorners;

    /**
     * The shape of the region. Usually this will be null (except for things like check box
     * checks, scroll bar down arrows / up arrows, etc). If this is not null, it determines
     * the shape of the region to draw. If it is null, then the assumed shape of the region is
     * one of a rounded rectangle. This shape is a com.sun.javafx.geom.Shape, and is not
     * touched by the FX scene graph except during synchronization, so it is safe to access
     * on the render thread.
     */
    private Shape shape;
    private NGShape ngShape;

    /**
     * Whether we should scale the shape to match the bounds of the region. Only applies
     * if the shape is not null.
     */
    private boolean scaleShape = true;

    /**
     * Whether we should center the shape within the bounds of the region. Only applies
     * if the shape is not null.
     */
    private boolean centerShape = true;

    /**
     * Whether we should attempt to use region caching for a region with a shape.
     */
    private boolean cacheShape = false;

    /**
     * A cached set of the opaque insets as given to us during synchronization. We hold
     * on to this so that we can determine the opaque insets in the computeOpaqueRegion method.
     */
    private float opaqueTop = Float.NaN,
            opaqueRight = Float.NaN,
            opaqueBottom = Float.NaN,
            opaqueLeft = Float.NaN;

    /**
     * The width and height of the region.
     */
    private float width, height;

    /**
     * Determined when a background is set on the region, this flag indicates whether this
     * background can be cached. As of this time, the only backgrounds which can be cached
     * are those where there are only solid fills or linear gradients.
     */
    private int cacheMode;

    /**
     * Is the key into the image cache that identifies the required background
     * for the region.
     */
    private Integer cacheKey;

    /**
     * Simple Helper Function for cleanup.
     */
    static Paint getPlatformPaint(javafx.scene.paint.Paint paint) {
        return (Paint)Toolkit.getPaintAccessor().getPlatformPaint(paint);
    }

    // We create a class instance of a no op. Effect internally to handle 3D
    // transform if user didn't use Effect for 3D Transformed Region. This will
    // automatically forces Region rendering path to use the Effect path.
    private static final Offset nopEffect = new Offset(0, 0, null);
    private EffectFilter nopEffectFilter;

    /**************************************************************************
     *                                                                        *
     * Methods used during synchronization only.                              *
     *                                                                        *
     *************************************************************************/

    /**
     * Called by the Region during synchronization. The Region *should* ensure that this is only
     * called when one of these properties has changed. The cost of calling it excessively is
     * only that the opaque region is invalidated excessively. Updating the shape and
     * associated booleans is actually a very cheap operation.
     *
     * @param shape    The shape, may be null.
     * @param scaleShape whether to scale the shape
     * @param positionShape whether to center the shape
     */
    public void updateShape(Object shape, boolean scaleShape, boolean positionShape, boolean cacheShape) {
        this.ngShape = shape == null ? null : NodeHelper.getPeer(((javafx.scene.shape.Shape)shape));
        this.shape = shape == null ? null : ngShape.getShape();
        this.scaleShape = scaleShape;
        this.centerShape = positionShape;
        this.cacheShape = cacheShape;
        // Technically I don't think this is needed because whenever the shape changes, setOpaqueInsets
        // is also called, so this will get invalidated twice.
        invalidateOpaqueRegion();
        cacheKey = null;
        visualsChanged();
    }

    /**
     * Called by the Region whenever the width or height of the region has changed.
     * The Region *should* only call this when the width or height have actually changed.
     *
     * @param width     The width of the region, not including insets or outsets
     * @param height    The height of the region, not including insets or outsets
     */
    public void setSize(float width, float height) {
        this.width = width;
        this.height = height;
        invalidateOpaqueRegion();
        cacheKey = null;
        visualsChanged();
        // We only have to clear the background insets when the size changes if the
        // background has fills who's insets are dependent on the size (as would be
        // true only if a CornerRadii of any background fill on the background had
        // a percentage based radius).
        if (background != null &amp;&amp; background.isFillPercentageBased()) {
            backgroundInsets = null;
        }
    }

    /**
     * Called by Region whenever an image that was being loaded in the background has
     * finished loading. Nothing changes in terms of metrics or sizes or caches, but
     * we do need to repaint everything.
     */
    public void imagesUpdated() {
        visualsChanged();
    }

    /**
     * Called by the Region when the Border is changed. The Region *must* only call
     * this method if the border object has actually changed, or excessive work may be done.
     *
     * @param b Border, of type javafx.scene.layout.Border
     */
    public void updateBorder(Border b) {
        // Make sure that the border instance we store on this NGRegion is never null
        final Border old = border;
        border = b == null ? Border.EMPTY : b;

        // Determine whether the geometry has changed, or if only the visuals have
        // changed. Geometry changes will require more work, and an equals check
        // on the border objects is generally very fast (either for identity or
        // for !equals. It is a bit longer for when they really are equal, but faster
        // than a geometryChanged!)
        if (!border.getOutsets().equals(old.getOutsets())) {
            geometryChanged();
        } else {
            visualsChanged();
        }
    }

    /**
     * Called by the Region when any parameters are changed.
     * It is only technically needed when a parameter that affects the size
     * of any percentage or overflowing corner radii is changed, but since
     * the data is not processed here in NGRegion, it is set on every update
     * of the peers for any reason.
     * A null value means that the raw radii in the BorderStroke objects
     * themselves were already absolute and non-overflowing.
     *
     * @param normalizedStrokeCorners a precomputed copy of the radii in the
     *        BorderStroke objects that are not percentages and do not overflow
     */
    public void updateStrokeCorners(List&lt;CornerRadii&gt; normalizedStrokeCorners) {
        this.normalizedStrokeCorners = normalizedStrokeCorners;
    }

    /**
     * Returns the normalized (non-percentage, non-overflowing) radii for the
     * selected index into the BorderStroke objects.
     * If a List was synchronized from the Region object, the value from that
     * List, otherwise the raw radii are fetched from the indicated BorderStroke
     * object.
     *
     * @param index the index of the BorderStroke object being processed
<A NAME="5"></A>     * @return the normalized radii for the indicated BorderStroke object
     */
    private CornerRadii getNormalizedStrokeRadii(int index) {
        return (<FONT color="#c8c2a7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#5',2,'match31-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>normalizedStrokeCorners == null
                ? border.getStrokes().get(index).getRadii()
                : normalizedStrokeCorners.get(index));
    }

    /**
     * Called by the Region when the Background has changed. The Region *must* only call
     * this method if the background object has actually changed, or excessive work may be done.
     *
     * @param b    Background, of type javafx.scene.layout.Background. Can be null.
     */
    public void updateBackground(Background b) {
        // NOTE: We don't explicitly invalidate the opaque region in this method, because the
        // Region will always call setOpaqueInsets whenever the background is changed, and
        // setOpaqueInsets always invalidates the opaque region. So we don't have to do it
        // again here. This wasn't immediately obvious and it might be better to combine
        // the updateBackground and setOpaqueInsets methods into one call, so that we
        // can more easily ensure that the opaque region is updated correctly.

        // Make sure that the background instance we store on this NGRegion is never null
        final Background old = background</B></FONT>;
        background = b == null ? Background.EMPTY : b;

        final List&lt;BackgroundFill&gt; fills = background.getFills();
        cacheMode = 0;
        if (!PrismSettings.disableRegionCaching &amp;&amp; !fills.isEmpty() &amp;&amp; (shape == null || cacheShape)) {
            cacheMode = CACHE_SLICE_H | CACHE_SLICE_V;
            for (int i=0, max=fills.size(); i&lt;max &amp;&amp; cacheMode != 0; i++) {
                // We need to now inspect the paint to determine whether we can use a cache for this background.
                // If a shape is being used, we don't care about gradients (we cache 'em both), but for a rectangle
                // fill we omit these (so we can do 3-patch scaling). An ImagePattern is deadly to either
                // (well, only deadly to a shape if it turns out to be a writable image).
                final BackgroundFill fill = fills.get(i);
                javafx.scene.paint.Paint paint = fill.getFill();
                if (shape == null) {
                    if (paint instanceof LinearGradient) {
                        LinearGradient linear = (LinearGradient) paint;
                        if (linear.getStartX() != linear.getEndX()) {
                            cacheMode &amp;= ~CACHE_SLICE_H;
                        }
                        if (linear.getStartY() != linear.getEndY()) {
                            cacheMode &amp;= ~CACHE_SLICE_V;
                        }
                    } else if (!(paint instanceof Color)) {
                        //Either radial gradient or image pattern
                        cacheMode = 0;
                    }
                } else if (paint instanceof javafx.scene.paint.ImagePattern) {
                    cacheMode = 0;
                }
            }
        }
        backgroundInsets = null;
        cacheKey = null;

        // Only update the geom if the new background is geometrically different from the old
        if (!background.getOutsets().equals(old.getOutsets())) {
            geometryChanged();
        } else {
            visualsChanged();
        }
    }

    /**
     * Called by the Region when any parameters are changed.
     * It is only technically needed when a parameter that affects the size
     * of any percentage or overflowing corner radii is changed, but since
     * the data is not processed here in NGRegion, it is set on every update
     * of the peers for any reason.
     * A null value means that the raw radii in the BackgroundFill objects
     * themselves were already absolute and non-overflowing.
     *
     * @param normalizedStrokeCorners a precomputed copy of the radii in the
     *        BackgroundFill objects that are not percentages and do not overflow
     */
    public void updateFillCorners(List&lt;CornerRadii&gt; normalizedFillCorners) {
        this.normalizedFillCorners = normalizedFillCorners;
    }

    /**
     * Returns the normalized (non-percentage, non-overflowing) radii for the
     * selected index into the BackgroundFill objects.
     * If a List was synchronized from the Region object, the value from that
     * List, otherwise the raw radii are fetched from the indicated BackgroundFill
     * object.
     *
     * @param index the index of the BackgroundFill object being processed
     * @return the normalized radii for the indicated BackgroundFill object
     */
    private CornerRadii getNormalizedFillRadii(int index) {
        return (normalizedFillCorners == null
                ? background.getFills().get(index).getRadii()
                : normalizedFillCorners.get(index));
    }

    /**
     * Called by the Region whenever it knows that the opaque insets have changed. The
     * Region &lt;strong&gt;must&lt;/strong&gt; make sure that these opaque insets include the opaque
     * inset information from the Border and Background as well, the NGRegion will not
     * recompute this information. This is done because Border and Background are immutable,
     * and as such this information is computed once and stored rather than recomputed
     * each time we have to render. Any developer supplied opaque insets must be combined
     * with the Border / Background intrinsic opaque insets prior to this call and passed
     * as the arguments to this method.
     *
     * @param top       The top, if NaN then there is no opaque inset at all
     * @param right     The right, must not be NaN or Infinity, etc.
     * @param bottom    The bottom, must not be NaN or Infinity, etc.
     * @param left      The left, must not be NaN or Infinity, etc.
     */
    public void setOpaqueInsets(float top, float right, float bottom, float left) {
        opaqueTop = top;
        opaqueRight = right;
        opaqueBottom = bottom;
        opaqueLeft = left;
        invalidateOpaqueRegion();
    }

    /**
     * When cleaning the dirty tree, we also have to keep in mind
     * the NGShape used by the NGRegion
     */
    @Override public void clearDirtyTree() {
        super.clearDirtyTree();
        if (ngShape != null) {
            ngShape.clearDirtyTree();
        }
    }

    /**************************************************************************
     *                                                                        *
     * Implementations of methods defined in the parent classes, with the     *
     * exception of rendering methods.                                        *
     *                                                                        *
     *************************************************************************/

    private RegionImageCache getImageCache(final Graphics g) {
        final Screen screen = g.getAssociatedScreen();
        RegionImageCache cache = imageCacheMap.get(screen);
        if (cache != null) {
            RTTexture tex = cache.getBackingStore();
            if (tex.isSurfaceLost()) {
                imageCacheMap.remove(screen);
                cache = null;
            }
        }
        if (cache == null) {
            cache = new RegionImageCache(g.getResourceFactory());
            imageCacheMap.put(screen, cache);
        }
        return cache;
    }

    private Integer getCacheKey(int w, int h) {
        if (cacheKey == null) {
            int key = 31 * w;
            key = key * 37 + h;
            key = key * 47 + background.hashCode();
            if (shape != null) {
                key = key * 73 + shape.hashCode();
            }
            cacheKey = key;
        }
        return cacheKey;
    }

    @Override protected boolean supportsOpaqueRegions() { return true; }

    @Override
    protected boolean hasOpaqueRegion() {
        return super.hasOpaqueRegion() &amp;&amp;
                !Float.isNaN(opaqueTop) &amp;&amp; !Float.isNaN(opaqueRight) &amp;&amp;
                !Float.isNaN(opaqueBottom) &amp;&amp; !Float.isNaN(opaqueLeft);
    }

    /**
     * The opaque region of an NGRegion takes into account the opaque insets
     * specified by the Region during synchronization. It also takes into
     * account the clip and the effect.
     *
     * @param opaqueRegion
     * @return
     */
    @Override protected RectBounds computeOpaqueRegion(RectBounds opaqueRegion) {
        // TODO what to do if the opaqueRegion has negative width or height due to excessive opaque insets? (RT-26979)
        return (RectBounds) opaqueRegion.deriveWithNewBounds(opaqueLeft, opaqueTop, 0, width - opaqueRight, height - opaqueBottom, 0);
    }

    @Override protected RenderRootResult computeRenderRoot(NodePath path, RectBounds dirtyRegion,
                                                           int cullingIndex, BaseTransform tx,
                                                           GeneralTransform3D pvTx) {

        RenderRootResult result = super.computeRenderRoot(path, dirtyRegion, cullingIndex, tx, pvTx);
        if (result == RenderRootResult.NO_RENDER_ROOT){
            result = computeNodeRenderRoot(path, dirtyRegion, cullingIndex, tx, pvTx);
        }
        return result;
    }

    @Override protected boolean hasVisuals() {
        // This isn't entirely accurate -- the background might
        // not be empty but still not draw anything since a BackgroundFill
        // might be TRANSPARENT. The same is true of the border, which
        // might have BorderStrokes but perhaps none of them draw.
        return !border.isEmpty() || !background.isEmpty();
    }

    @Override protected boolean hasOverlappingContents() {
        // It may be that this can be optimized further, but I'm a bit
        // worried about it as I would have to check that the children do not
        // overlap with the strokes, and the strokes don't overlap each other,
        // and there are no backgrounds, etc. So there are a few fast paths
        // that could be used, but not sure it is really of any benefit in
        // the real cases.
        return true;
    }

    /**************************************************************************
     *                                                                        *
     * Region drawing.                                                        *
     *                                                                        *
     *************************************************************************/

    @Override protected void renderContent(Graphics g) {
        // Use Effect to render a 3D transformed Region that does not contain 3D
        // transformed children. This is done in order to render the Region's
        // content and children into an image in local coordinates using the identity
        // transform. The resulting image will then be correctly transformed in 3D by
        // the composite transform used to render this Region.
        // However, we avoid doing this for Regions whose children have a 3D
        // transform, because it will flatten the transforms of those children
        // and not look correct.
        if (!g.getTransformNoClone().is2D() &amp;&amp; this.isContentBounds2D()) {
            assert (getEffectFilter() == null);

            // Use Effect to render 3D transformed Region.
            // We will need to use a no op. Effect internally since user
            // didn't use Effect for this Region
            if (nopEffectFilter == null) {
                nopEffectFilter = new EffectFilter(nopEffect, this);
            }
            nopEffectFilter.render(g);

            return;
        }

        // If the shape is not null, then the shape will define what we need to draw for
        // this region. If the shape is null, then the &quot;shape&quot; of the region is just a
        // rectangle (or rounded rectangle, depending on the Background).
        if (shape != null) {
            renderAsShape(g);
        } else if (width &gt; 0 &amp;&amp; height &gt; 0) {
            renderAsRectangle(g);
        }

        // Paint the children
        super.renderContent(g);
    }

    /**************************************************************************
     *                                                                        *
     * Drawing a region background and borders when the Region has been       *
     * specified to have a shape. This is typically used to render some       *
     * portions of a UI Control, such as the tick on a CheckBox, the dot on a *
     * RadioButton, or the disclosure node arrow on a TreeView. In these      *
     * cases, the overall region size is typically very small and can         *
     * therefore easily be cached.                                            *
     *                                                                        *
     *************************************************************************/

    private void renderAsShape(Graphics g) {
        if (!background.isEmpty()) {
            // Note: resizeShape is not cheap. This should be refactored so that we only invoke
            // it if we absolutely have to. Specifically, if the background, shape, and size of the region
            // has not changed since the last time we rendered we could skip all this and render
            // directly out of a cache.
            final Insets outsets = background.getOutsets();
            final Shape outsetShape = resizeShape((float) -outsets.getTop(), (float) -outsets.getRight(),
                                                  (float) -outsets.getBottom(), (float) -outsets.getLeft());
            final RectBounds outsetShapeBounds = outsetShape.getBounds();
            final int textureWidth = Math.round(outsetShapeBounds.getWidth()),
                      textureHeight = Math.round(outsetShapeBounds.getHeight());

            final int border = 1;
            // See if we have a cached representation for this region background already. In UI controls,
            // the arrow in a scroll bar button or the dot in a radio button or the tick in a check box are
            // all examples of cases where we'd like to reuse a cached image for performance reasons rather
            // than re-drawing everything each time.

            RTTexture cached = null;
            Rectangle rect = null;
            // RT-25013: We need to make sure that we do not use a cached image in the case of a
            // scaled region, or things won't look right (they'll looked scaled instead of vector-resized).
            if (cacheMode != 0 &amp;&amp; g.getTransformNoClone().isTranslateOrIdentity()) {
                final RegionImageCache imageCache = getImageCache(g);
                if (imageCache.isImageCachable(textureWidth, textureHeight)) {
                    final Integer key = getCacheKey(textureWidth, textureHeight);
                    rect = TEMP_RECT;
                    rect.setBounds(0, 0, textureWidth + border, textureHeight + border);
                    boolean render = imageCache.getImageLocation(key, rect, background, shape, g);
                    if (!rect.isEmpty()) {
                        // An empty rect indicates a failure occurred in the imageCache
                        cached = imageCache.getBackingStore();
                    }
                    if (cached != null &amp;&amp; render) {
                        Graphics cachedGraphics = cached.createGraphics();

                        // Have to move the origin such that when rendering to x=0, we actually end up rendering
                        // at x=bounds.getMinX(). Otherwise anything rendered to the left of the origin would be lost
                        cachedGraphics.translate(rect.x - outsetShapeBounds.getMinX(),
                                                 rect.y - outsetShapeBounds.getMinY());
                        renderBackgroundShape(cachedGraphics);
                        if (PULSE_LOGGING_ENABLED) {
                            PulseLogger.incrementCounter(&quot;Rendering region shape image to cache&quot;);
                        }
                    }
                }
            }

            // &quot;cached&quot; might not be null if either there was a cached image, or we just created one.
            // In either case, we need to now render from the cached texture to the graphics
            if (cached != null) {
                // We just draw exactly what it was we have cached
                final float dstX1 = outsetShapeBounds.getMinX();
                final float dstY1 = outsetShapeBounds.getMinY();
                final float dstX2 = outsetShapeBounds.getMaxX();
                final float dstY2 = outsetShapeBounds.getMaxY();

                final float srcX1 = rect.x;
                final float srcY1 = rect.y;
                final float srcX2 = srcX1 + textureWidth;
                final float srcY2 = srcY1 + textureHeight;

                g.drawTexture(cached, dstX1, dstY1, dstX2, dstY2, srcX1, srcY1, srcX2, srcY2);
                if (PULSE_LOGGING_ENABLED) {
                    PulseLogger.incrementCounter(&quot;Cached region shape image used&quot;);
                }
            } else {
                // no cache, rendering backgrounds directly to graphics
                renderBackgroundShape(g);
            }
        }

        // Note that if you use borders, you're going to pay a premium in performance.
        // I don't think this is strictly necessary (since we won't stretch a cached
        // region shape anyway), so really this code should some how be combined
        // with the caching code that happened above for backgrounds.
        if (!border.isEmpty()) {
            // We only deal with stroke borders, we never deal with ImageBorders when
            // painting a shape on a Region. This is primarily because we don't know
            // how to handle a 9-patch image on a random shape. We'll have to implement
            // this at some point, but today is not that day.
            final List&lt;BorderStroke&gt; strokes = border.getStrokes();
            for (int i = 0, max = strokes.size(); i &lt; max; i++) {
                // Get the BorderStroke. When stroking a shape, we only honor the
                // topStroke, topStyle, widths.top, and insets.
                final BorderStroke stroke = strokes.get(i);
                // We're stroking a path, so there is no point trying to figure out the length.
                // Instead, we just pass -1, telling setBorderStyle to just do a simple stroke
                setBorderStyle(g, stroke, -1, false);
                final Insets insets = stroke.getInsets();
                g.draw(resizeShape((float) insets.getTop(), (float) insets.getRight(),
                                   (float) insets.getBottom(), (float) insets.getLeft()));
            }
        }
    }

    private void renderBackgroundShape(Graphics g) {
        if (PULSE_LOGGING_ENABLED) {
            PulseLogger.incrementCounter(&quot;NGRegion renderBackgroundShape slow path&quot;);
            PulseLogger.addMessage(&quot;Slow shape path for &quot; + getName());
        }

        // We first need to draw each background fill. We don't pay any attention
        // to the radii of the BackgroundFill, but we do honor the insets and
        // the fill paint itself.
        final List&lt;BackgroundFill&gt; fills = background.getFills();
        for (int i = 0, max = fills.size(); i &lt; max; i++) {
            final BackgroundFill fill = fills.get(i);
            // Get the paint for this BackgroundFill. It should not be possible
            // for it to ever be null
            final Paint paint = getPlatformPaint(fill.getFill());
            assert paint != null;
            g.setPaint(paint);
            // Adjust the box within which we will fit the shape based on the
            // insets. The resize shape method will resize the shape to fit
            final Insets insets = fill.getInsets();
            g.fill(resizeShape((float) insets.getTop(), (float) insets.getRight(),
                               (float) insets.getBottom(), (float) insets.getLeft()));
        }

        // We now need to draw each background image. Only the &quot;cover&quot; property
        // of BackgroundImage, and the &quot;image&quot; property itself, have any impact
        // on how the image is applied to a Shape.
        final List&lt;BackgroundImage&gt; images = background.getImages();
        for (int i = 0, max = images.size(); i &lt; max; i++) {
            final BackgroundImage image = images.get(i);
            final Image prismImage = (Image) Toolkit.getImageAccessor().getPlatformImage(image.getImage());
            if (prismImage == null) {
                // The prismImage might be null if the Image has not completed loading.
                // In that case, we simply must skip rendering of that layer this
                // time around.
                continue;
            }
            // We need to translate the shape based on 0 insets. This will for example
            // center and / or position the shape if necessary.
            final Shape translatedShape = resizeShape(0, 0, 0, 0);
            // Now ensure that the ImagePattern is based on the x/y position of the
            // shape and not on the 0,0 position of the region.
            final RectBounds bounds = translatedShape.getBounds();
            ImagePattern pattern = image.getSize().isCover() ?
                    new ImagePattern(prismImage, bounds.getMinX(), bounds.getMinY(),
                                     bounds.getWidth(), bounds.getHeight(), false, false) :
                    new ImagePattern(prismImage, bounds.getMinX(), bounds.getMinY(),
                                     prismImage.getWidth(), prismImage.getHeight(), false, false);
            g.setPaint(pattern);
            // Go ahead and finally fill!
            g.fill(translatedShape);
        }
    }

    /**************************************************************************
     *                                                                        *
     * Drawing a region background and borders when the Region has no defined *
     * shape, and is therefore treated as a rounded rectangle. This is the    *
     * most common code path for UI Controls.                                 *
     *                                                                        *
     *************************************************************************/

    private void renderAsRectangle(Graphics g) {
        if (!background.isEmpty()) {
            renderBackgroundRectangle(g);
        }

        if (!border.isEmpty()) {
            renderBorderRectangle(g);
        }
    }

    private void renderBackgroundRectangle(Graphics g) {
        // TODO a big chunk of this only makes sense to do if there actually are background fills,
        // and we should guard against that.

        // cacheWidth is the width of the region used within the cached image. For example,
        // perhaps normally the width of a region is 200px. But instead I will render the
        // region as though it is 20px wide into the cached image. 20px in this case is
        // the cache width. Although it may draw into more pixels than this (for example,
        // drawing the focus rectangle extends beyond the width of the region).
        // left + right background insets give us the left / right slice locations, plus 1 pixel for the center.
        // Round the whole thing up to be a whole number.
        if (backgroundInsets == null) updateBackgroundInsets();
        final double leftInset = backgroundInsets.getLeft() + 1;
        final double rightInset = backgroundInsets.getRight() + 1;
        final double topInset = backgroundInsets.getTop() + 1;
        final double bottomInset = backgroundInsets.getBottom() + 1;

        // If the insets are too large, then we want to use the width of the region instead of the
        // computed cacheWidth. RadioButton, for example, enters this case
        int cacheWidth = roundUp(width);
        if ((cacheMode &amp; CACHE_SLICE_H) != 0) {
            cacheWidth = Math.min(cacheWidth, (int) (leftInset + rightInset));
        }
        int cacheHeight = roundUp(height);
        if ((cacheMode &amp; CACHE_SLICE_V) != 0) {
            cacheHeight = Math.min(cacheHeight, (int) (topInset + bottomInset));
        }

        final Insets outsets = background.getOutsets();
        final int outsetsTop = roundUp(outsets.getTop());
        final int outsetsRight = roundUp(outsets.getRight());
        final int outsetsBottom = roundUp(outsets.getBottom());
        final int outsetsLeft = roundUp(outsets.getLeft());

        // The textureWidth / textureHeight is the width/height of the actual image. This needs to be rounded
        // up to the next whole pixel value.
        final int textureWidth = outsetsLeft + cacheWidth + outsetsRight;
        final int textureHeight = outsetsTop + cacheHeight + outsetsBottom;

        // See if we have a cached representation for this region background already.
        // RT-25013: We need to make sure that we do not use a cached image in the case of a
        // scaled region, or things won't look right (they'll looked scaled instead of vector-resized).
        // RT-25049: Need to only use the cache for pixel aligned regions or the result
        // will not look the same as though drawn by vector
        final boolean cache =
                background.getFills().size() &gt; 1 &amp;&amp; // Not worth the overhead otherwise
                cacheMode != 0 &amp;&amp;
                g.getTransformNoClone().isTranslateOrIdentity();
        final int border = 1;
        RTTexture cached = null;
        Rectangle rect = null;
        if (cache) {
            RegionImageCache imageCache = getImageCache(g);
            if (imageCache.isImageCachable(textureWidth, textureHeight)) {
                final Integer key = getCacheKey(textureWidth, textureHeight);
                rect = TEMP_RECT;
                rect.setBounds(0, 0, textureWidth + border, textureHeight + border);
                boolean render = imageCache.getImageLocation(key, rect, background, shape, g);
                if (!rect.isEmpty()) {
                    // An empty rect indicates a failure occurred in the imageCache
                    cached = imageCache.getBackingStore();
                }
                if (cached != null &amp;&amp; render) {
                    Graphics cacheGraphics = cached.createGraphics();

                    // Have to move the origin such that when rendering to x=0, we actually end up rendering
                    // at x=outsets.getLeft(). Otherwise anything rendered to the left of the origin would be lost
                    // Round up to the nearest pixel
                    cacheGraphics.translate(rect.x + outsetsLeft, rect.y + outsetsTop);

                    // Rendering backgrounds to the cache
                    renderBackgroundRectanglesDirectly(cacheGraphics, cacheWidth, cacheHeight);

                    if (PULSE_LOGGING_ENABLED) {
                        PulseLogger.incrementCounter(&quot;Rendering region background image to cache&quot;);
                    }
                }
            }
        }

        // &quot;cached&quot; might not be null if either there was a cached image, or we just created one.
        // In either case, we need to now render from the cached texture to the graphics
        if (cached != null) {
            renderBackgroundRectangleFromCache(
                    g, cached, rect, textureWidth, textureHeight,
                    topInset, rightInset, bottomInset, leftInset,
                    outsetsTop, outsetsRight, outsetsBottom, outsetsLeft);
        } else {
            // no cache, rendering backgrounds directly to graphics
            renderBackgroundRectanglesDirectly(g, width, height);
        }

        final List&lt;BackgroundImage&gt; images = background.getImages();
        for (int i = 0, max = images.size(); i &lt; max; i++) {
            final BackgroundImage image = images.get(i);
            Image prismImage = (Image) Toolkit.getImageAccessor().getPlatformImage(image.getImage());
            if (prismImage == null) {
                // The prismImage might be null if the Image has not completed loading.
                // In that case, we simply must skip rendering of that layer this
                // time around.
                continue;
            }

            final int imgUnscaledWidth = (int)image.getImage().getWidth();
            final int imgUnscaledHeight = (int)image.getImage().getHeight();
            final int imgWidth = prismImage.getWidth();
            final int imgHeight = prismImage.getHeight();
            // TODO need to write tests where we use a writable image and draw to it a lot. (RT-26978)
            if (imgWidth != 0 &amp;&amp; imgHeight != 0) {
                final BackgroundSize size = image.getSize();
                if (size.isCover()) {
                    // When &quot;cover&quot; is true, we can ignore most properties on the BackgroundSize and
                    // BackgroundRepeat and BackgroundPosition. Because the image will be stretched to
                    // fill the entire space, there is no need to know the repeat or position or
                    // size width / height.
                    final float scale = Math.max(width / imgWidth,height / imgHeight);
                    final Texture texture =
                        g.getResourceFactory().getCachedTexture(prismImage, Texture.WrapMode.CLAMP_TO_EDGE);
                    g.drawTexture(texture,
                            0, 0, width, height,
                            0, 0, width/scale, height/scale
                    );
                    texture.unlock();
                } else {
                    // Other than &quot;cover&quot;, all other modes need to pay attention to the repeat,
                    // size, and position in order to determine how to render. This next block
                    // of code is responsible for determining the width and height of the area
                    // that we are going to fill. The size might be percentage based, in which
                    // case we need to multiply by the width or height.
                    final double w = size.isWidthAsPercentage() ? size.getWidth() * width : size.getWidth();
                    final double h = size.isHeightAsPercentage() ? size.getHeight() * height : size.getHeight();

                    // Now figure out the width and height of each tile to be drawn. The actual image
                    // dimensions may be one thing, but we need to figure out what the size of the image
                    // in the destination is going to be.
                    final double tileWidth, tileHeight;
                    if (size.isContain()) {
                        // In the case of &quot;contain&quot;, we compute the destination size based on the largest
                        // possible scale such that the aspect ratio is maintained, yet one side of the
                        // region is completely filled.
                        final float scaleX = width / imgUnscaledWidth;
                        final float scaleY = height / imgUnscaledHeight;
                        final float scale = Math.min(scaleX, scaleY);
                        tileWidth = Math.ceil(scale * imgUnscaledWidth);
                        tileHeight = Math.ceil(scale * imgUnscaledHeight);
                    } else if (size.getWidth() &gt;= 0 &amp;&amp; size.getHeight() &gt;= 0) {
                        // The width and height have been expressly defined. Note that AUTO is -1,
                        // and all other negative values are disallowed, so by checking &gt;= 0, we
                        // are essentially saying &quot;if neither is AUTO&quot;
                        tileWidth = w;
                        tileHeight = h;
                    } else if (w &gt;= 0) {
                        // In this case, the width is specified, but the height is AUTO
                        tileWidth = w;
                        final double scale = tileWidth / imgUnscaledWidth;
                        tileHeight = imgUnscaledHeight * scale;
                    } else if (h &gt;= 0) {
                        // Here the height is specified and the width is AUTO
                        tileHeight = h;
                        final double scale = tileHeight / imgUnscaledHeight;
                        tileWidth = imgUnscaledWidth * scale;
                    } else {
                        // Both are auto.
                        tileWidth = imgUnscaledWidth;
                        tileHeight = imgUnscaledHeight;
                    }

                    // Now figure out where we are going to place the images within the region.
                    // For example, the developer can ask for 20px or 20%, and we need to first
                    // determine where to place the image. This starts by figuring out the pixel
                    // based value for the position.
                    final BackgroundPosition pos = image.getPosition();
                    final double tileX, tileY;

                    if (pos.getHorizontalSide() == Side.LEFT) {
                        final double position = pos.getHorizontalPosition();
                        if (pos.isHorizontalAsPercentage()) {
                            tileX = (position * width) - (position * tileWidth);
                        } else {
                            tileX = position;
                        }
                    } else {
                        if (pos.isHorizontalAsPercentage()) {
                            final double position = 1 - pos.getHorizontalPosition();
                            tileX = (position * width) - (position * tileWidth);
                        } else {
                            tileX = width - tileWidth- pos.getHorizontalPosition();
                        }
                    }

                    if (pos.getVerticalSide() == Side.TOP) {
                        final double position = pos.getVerticalPosition();
                        if (pos.isVerticalAsPercentage()) {
                            tileY = (position * height) - (position * tileHeight);
                        } else {
                            tileY = position;
                        }
                    } else {
                        if (pos.isVerticalAsPercentage()) {
                            final double position = 1 - pos.getVerticalPosition();
                            tileY = (position * height) - (position * tileHeight);
                        } else {
                            tileY = height - tileHeight - pos.getVerticalPosition();
                        }
                    }

                    // Now that we have acquired or computed all the data, we'll let paintTiles
                    // do the actual rendering operation.
                    paintTiles(g, prismImage, image.getRepeatX(), image.getRepeatY(),
                               pos.getHorizontalSide(), pos.getVerticalSide(),
                               0, 0, width, height, // the region area to fill with the image
                               0, 0, imgWidth, imgHeight, // The entire image is used
                               (float) tileX, (float) tileY, (float) tileWidth, (float) tileHeight);
                }
            }
        }
    }

    private void renderBackgroundRectangleFromCache(
            Graphics g, RTTexture cached, Rectangle rect, int textureWidth, int textureHeight,
            double topInset, double rightInset, double bottomInset, double leftInset,
            int outsetsTop, int outsetsRight, int outsetsBottom, int outsetsLeft) {

        // All cache operations are padded by (just shy of) half a pixel so
        // that as we are translated by sub-pixel amounts we continue to sample
        // all of the cached pixels out until they become transparent at (or
        // 1-bit worth of non-zero alhpa from) the center of the border pixel
        // around the cache.  If there is an integer translation, then our
        // padding should come up just shy of including new rows/columns of
        // pixels in the rendering and thus have no impact on pixel fill rates.
        final float pad = 0.5f - 1f/256f;
        final float dstWidth = outsetsLeft + width + outsetsRight;
        final float dstHeight = outsetsTop + height + outsetsBottom;
        final boolean sameWidth = textureWidth == dstWidth;
        final boolean sameHeight = textureHeight == dstHeight;
        final float dstX1 = -outsetsLeft - pad;
        final float dstY1 = -outsetsTop - pad;
        final float dstX2 = width + outsetsRight + pad;
        final float dstY2 = height + outsetsBottom + pad;
        final float srcX1 = rect.x - pad;
        final float srcY1 = rect.y - pad;
        final float srcX2 = rect.x + textureWidth + pad;
        final float srcY2 = rect.y + textureHeight + pad;

        // If total destination width is &lt; the source width, then we need to start
        // shrinking the left and right sides to accommodate. Likewise in the other dimension.
        double adjustedLeftInset = leftInset;
        double adjustedRightInset = rightInset;
        double adjustedTopInset = topInset;
        double adjustedBottomInset = bottomInset;
        if (leftInset + rightInset &gt; width) {
            double fraction = width / (leftInset + rightInset);
            adjustedLeftInset *= fraction;
            adjustedRightInset *= fraction;
        }
        if (topInset + bottomInset &gt; height) {
            double fraction = height / (topInset + bottomInset);
            adjustedTopInset *= fraction;
            adjustedBottomInset *= fraction;
        }

        if (sameWidth &amp;&amp; sameHeight) {
            g.drawTexture(cached, dstX1, dstY1, dstX2, dstY2, srcX1, srcY1, srcX2, srcY2);
        } else if (sameHeight) {
            // We do 3-patch rendering fixed height
            final float left  = pad + (float) (adjustedLeftInset  + outsetsLeft);
            final float right = pad + (float) (adjustedRightInset + outsetsRight);

            final float dstLeftX = dstX1 + left;
            final float dstRightX = dstX2 - right;
            final float srcLeftX = srcX1 + left;
            final float srcRightX = srcX2 - right;

            g.drawTexture3SliceH(cached,
                                 dstX1, dstY1, dstX2, dstY2,
                                 srcX1, srcY1, srcX2, srcY2,
                                 dstLeftX, dstRightX, srcLeftX, srcRightX);
        } else if (sameWidth) {
            // We do 3-patch rendering fixed width
            final float top    = pad + (float) (adjustedTopInset    + outsetsTop);
            final float bottom = pad + (float) (adjustedBottomInset + outsetsBottom);

            final float dstTopY = dstY1 + top;
            final float dstBottomY = dstY2 - bottom;
            final float srcTopY = srcY1 + top;
            final float srcBottomY = srcY2 - bottom;

            g.drawTexture3SliceV(cached,
                                 dstX1, dstY1, dstX2, dstY2,
                                 srcX1, srcY1, srcX2, srcY2,
                                 dstTopY, dstBottomY, srcTopY, srcBottomY);
        } else {
            // We do 9-patch rendering
            final float left   = pad + (float) (adjustedLeftInset   + outsetsLeft);
            final float top    = pad + (float) (adjustedTopInset    + outsetsTop);
            final float right  = pad + (float) (adjustedRightInset  + outsetsRight);
            final float bottom = pad + (float) (adjustedBottomInset + outsetsBottom);

            final float dstLeftX = dstX1 + left;
            final float dstRightX = dstX2 - right;
            final float srcLeftX = srcX1 + left;
            final float srcRightX = srcX2 - right;
            final float dstTopY = dstY1 + top;
            final float dstBottomY = dstY2 - bottom;
            final float srcTopY = srcY1 + top;
            final float srcBottomY = srcY2 - bottom;

            g.drawTexture9Slice(cached,
                                dstX1, dstY1, dstX2, dstY2,
                                srcX1, srcY1, srcX2, srcY2,
                                dstLeftX, dstTopY, dstRightX, dstBottomY,
                                srcLeftX, srcTopY, srcRightX, srcBottomY);
        }

        if (PULSE_LOGGING_ENABLED) {
            PulseLogger.incrementCounter(&quot;Cached region background image used&quot;);
        }
    }

    private void renderBackgroundRectanglesDirectly(Graphics g, float width, float height) {
        final List&lt;BackgroundFill&gt; fills = background.getFills();
        for (int i = 0, max = fills.size(); i &lt; max; i++) {
            final BackgroundFill fill = fills.get(i);
            final Insets insets = fill.getInsets();
            final float t = (float) insets.getTop(),
                    l = (float) insets.getLeft(),
                    b = (float) insets.getBottom(),
                    r = (float) insets.getRight();
            // w and h is the width and height of the area to be filled (width and height less insets)
            float w = width - l - r;
            float h = height - t - b;
            // Only setup and paint for those areas which have positive width and height. This means, if
            // the insets are such that the right edge is left of the left edge, then we have a negative
            // width and will not paint it. TODO we need to document this fact (RT-26924)
            if (w &gt; 0 &amp;&amp; h &gt; 0) {
                // Could optimize this such that if paint is transparent then we go no further.
                final Paint paint = getPlatformPaint(fill.getFill());
                g.setPaint(paint);
                final CornerRadii radii = getNormalizedFillRadii(i);
                // This is a workaround for RT-28435 so we use path rasterizer for small radius's We are
                // keeping old rendering. We do not apply workaround when using Caspian or Embedded
                if (radii.isUniform() &amp;&amp;
                        !(!PlatformImpl.isCaspian() &amp;&amp; !(PlatformUtil.isEmbedded() || PlatformUtil.isIOS()) &amp;&amp; radii.getTopLeftHorizontalRadius() &gt; 0 &amp;&amp; radii.getTopLeftHorizontalRadius() &lt;= 4)) {
                    // If the radii is uniform then we know every corner matches, so we can do some
                    // faster rendering paths.
                    float tlhr = (float) radii.getTopLeftHorizontalRadius();
                    float tlvr = (float) radii.getTopLeftVerticalRadius();
                    if (tlhr == 0 &amp;&amp; tlvr == 0) {
                        // The edges are square, so we can do a simple fill rect
                        g.fillRect(l, t, w, h);
                    } else {
                        // The edges are rounded, so we need to compute the arc width and arc height
                        // and fill a round rect
                        float arcWidth = tlhr + tlhr;
                        float arcHeight = tlvr + tlvr;
                        // If the arc width and arc height are so large as to exceed the width / height of
                        // the region, then we clamp to the width / height of the region (which will give
                        // the look of a circle on that corner)
                        if (arcWidth &gt; w) arcWidth = w;
                        if (arcHeight &gt; h) arcHeight = h;
                        g.fillRoundRect(l, t, w, h, arcWidth, arcHeight);
                    }
                } else {
                    if (PULSE_LOGGING_ENABLED) {
                        PulseLogger.incrementCounter(&quot;NGRegion renderBackgrounds slow path&quot;);
                        PulseLogger.addMessage(&quot;Slow background path for &quot; + getName());
                    }
                    // The edges are not uniform, so we have to render each edge independently
                    // TODO document the issue number which will give us a fast path for rendering
                    // non-uniform corners, and that we want to implement that instead of createPath2
                    // below in such cases. (RT-26979)
                    g.fill(createPath(width, height, t, l, b, r, radii));
                }
            }
        }
    }

    private void renderBorderRectangle(Graphics g) {
        final List&lt;BorderImage&gt; images = border.getImages();
        final List&lt;BorderStroke&gt; strokes = images.isEmpty() ? border.getStrokes() : Collections.emptyList();
        for (int i = 0, max = strokes.size(); i &lt; max; i++) {
            final BorderStroke stroke = strokes.get(i);
            final BorderWidths widths = stroke.getWidths();
            final CornerRadii radii = getNormalizedStrokeRadii(i);
            final Insets insets = stroke.getInsets();

            final javafx.scene.paint.Paint topStroke = stroke.getTopStroke();
            final javafx.scene.paint.Paint rightStroke = stroke.getRightStroke();
            final javafx.scene.paint.Paint bottomStroke = stroke.getBottomStroke();
            final javafx.scene.paint.Paint leftStroke = stroke.getLeftStroke();

            final float topInset = (float) insets.getTop();
            final float rightInset = (float) insets.getRight();
            final float bottomInset = (float) insets.getBottom();
            final float leftInset = (float) insets.getLeft();

            final float topWidth = (float) (widths.isTopAsPercentage() ? height * widths.getTop() : widths.getTop());
            final float rightWidth = (float) (widths.isRightAsPercentage() ? width * widths.getRight() : widths.getRight());
            final float bottomWidth = (float) (widths.isBottomAsPercentage() ? height * widths.getBottom() : widths.getBottom());
            final float leftWidth = (float) (widths.isLeftAsPercentage() ? width * widths.getLeft() : widths.getLeft());

            final BorderStrokeStyle topStyle = stroke.getTopStyle();
            final BorderStrokeStyle rightStyle = stroke.getRightStyle();
            final BorderStrokeStyle bottomStyle = stroke.getBottomStyle();
            final BorderStrokeStyle leftStyle = stroke.getLeftStyle();

            final StrokeType topType = topStyle.getType();
            final StrokeType rightType = rightStyle.getType();
            final StrokeType bottomType = bottomStyle.getType();
            final StrokeType leftType = leftStyle.getType();

            // The Prism Graphics logic can stroke lines only CENTERED and doesn't know what to do with
            // INSIDE or OUTSIDE strokes for lines. The only way to deal with those is
            // to compensate for them here. So we will adjust the bounds that we are going
            // to stroke to take into account the insets (obviously), and also where we
            // want the stroked line to appear (inside, or outside, or centered).
            final float t = topInset +
                    (topType == StrokeType.OUTSIDE ? -topWidth / 2 :
                     topType == StrokeType.INSIDE ? topWidth / 2 : 0);
            final float l = leftInset +
                    (leftType == StrokeType.OUTSIDE ? -leftWidth / 2 :
                     leftType == StrokeType.INSIDE ? leftWidth / 2 : 0);
            final float b = bottomInset +
                    (bottomType == StrokeType.OUTSIDE ? -bottomWidth / 2 :
                     bottomType == StrokeType.INSIDE ? bottomWidth / 2 : 0);
            final float r = rightInset +
                    (rightType == StrokeType.OUTSIDE ? -rightWidth / 2 :
                     rightType == StrokeType.INSIDE ? rightWidth / 2 : 0);

            // If the radii are uniform, then reading any one value is sufficient to
            // know what the radius is for all values
            final float radius = (float) radii.getTopLeftHorizontalRadius();
            if (stroke.isStrokeUniform()) {
                // If the stroke is uniform, then that means that the style, width, and stroke of
                // all four sides is the same.
                if (!(topStroke instanceof Color &amp;&amp; ((Color)topStroke).getOpacity() == 0f) &amp;&amp; topStyle != BorderStrokeStyle.NONE) {
                    float w = width - l - r;
                    float h = height - t - b;
                    // The length of each side of the path we're going to stroke
                    final double di = 2 * radii.getTopLeftHorizontalRadius();
                    final double circle = di*Math.PI;
                    final double totalLineLength =
                            circle +
                            2 * (w - di) +
                            2 * (h - di);

                    if (w &gt;= 0 &amp;&amp; h &gt;= 0) {
                        setBorderStyle(g, stroke, totalLineLength, true);
                        if (radii.isUniform() &amp;&amp; radius == 0) {
                            // We're just drawing a squared stroke on all four sides of the same style
                            // and width and color, so a simple drawRect call is all that is needed.
                            g.drawRect(l, t, w, h);
                        } else if (radii.isUniform()) {
                            // The radii are uniform, but are not squared up, so we have to
                            // draw a rounded rectangle.
                            float ar = radius + radius;
                            if (ar &gt; w) ar = w;
                            if (ar &gt; h) ar = h;
                            g.drawRoundRect(l, t, w, h, ar, ar);
                        } else {
                            // We do not have uniform radii, so we need to create a path that represents
                            // the stroke and then draw that.
                            g.draw(createPath(width, height, t, l, b, r, radii));
                        }
                    }
                }
            } else if (radii.isUniform() &amp;&amp; radius == 0) {

                // We have different styles, or widths, or strokes on one or more sides, and
                // therefore we have to draw each side independently. However, the corner radii
                // are all 0, so we don't have to go to the trouble of constructing some complicated
                // path to represent the border, we just draw each line independently.
                // Note that in each of these checks, if the stroke is identity equal to the TRANSPARENT
                // Color or the style is identity equal to BorderStrokeStyle.NONE, then we skip that
                // side. It is possible however to have a Color as the stroke which is effectively
                // TRANSPARENT and a style that is effectively NONE, but we are not checking for those
                // cases and will in those cases be doing more work than necessary.
                // TODO make sure CSS uses TRANSPARENT and NONE when possible (RT-26943)
                if (!(topStroke instanceof Color &amp;&amp; ((Color)topStroke).getOpacity() == 0f) &amp;&amp; topStyle != BorderStrokeStyle.NONE) {
                    g.setPaint(getPlatformPaint(topStroke));
                    if (BorderStrokeStyle.SOLID == topStyle) {
                        g.fillRect(leftInset, topInset, width - leftInset - rightInset, topWidth);
                    } else {
                        g.setStroke(createStroke(topStyle, topWidth, width, true));
                        g.drawLine(l, t, width - r, t);
                    }
                }

                if (!(rightStroke instanceof Color &amp;&amp; ((Color)rightStroke).getOpacity() == 0f) &amp;&amp; rightStyle != BorderStrokeStyle.NONE) {
                    g.setPaint(getPlatformPaint(rightStroke));
                    if (BorderStrokeStyle.SOLID == rightStyle) {
                        g.fillRect(width - rightInset - rightWidth, topInset,
                                   rightWidth, height - topInset - bottomInset);
                    } else {
                        g.setStroke(createStroke(rightStyle, rightWidth, height, true));
                        g.drawLine(width - r, t, width - r, height - b);
                    }
                }

                if (!(bottomStroke instanceof Color &amp;&amp; ((Color)bottomStroke).getOpacity() == 0f) &amp;&amp; bottomStyle != BorderStrokeStyle.NONE) {
                    g.setPaint(getPlatformPaint(bottomStroke));
                    if (BorderStrokeStyle.SOLID == bottomStyle) {
                        g.fillRect(leftInset, height - bottomInset - bottomWidth,
                                width - leftInset - rightInset, bottomWidth);
                    } else {
                        g.setStroke(createStroke(bottomStyle, bottomWidth, width, true));
                        g.drawLine(l, height - b, width - r, height - b);
                    }
                }

                if (!(leftStroke instanceof Color &amp;&amp; ((Color)leftStroke).getOpacity() == 0f) &amp;&amp; leftStyle != BorderStrokeStyle.NONE) {
                    g.setPaint(getPlatformPaint(leftStroke));
                    if (BorderStrokeStyle.SOLID == leftStyle) {
                        g.fillRect(leftInset, topInset, leftWidth, height - topInset - bottomInset);
                    } else {
                        g.setStroke(createStroke(leftStyle, leftWidth, height, true));
                        g.drawLine(l, t, l, height - b);
                    }
                }
            } else {
                // In this case, we have different styles and/or strokes and/or widths on one or
                // more sides, and either the radii are not uniform, or they are uniform but greater
                // than 0. In this case we have to take a much slower rendering path by turning this
                // stroke into a path (or in the current implementation, an array of paths).
                Shape[] paths = createPaths(t, l, b, r, radii);
                if (topStyle != BorderStrokeStyle.NONE) {
                    double rsum = radii.getTopLeftHorizontalRadius() + radii.getTopRightHorizontalRadius();
                    double topLineLength = width + rsum * (Math.PI / 4 - 1);
                    g.setStroke(createStroke(topStyle, topWidth, topLineLength, true));
                    g.setPaint(getPlatformPaint(topStroke));
                    g.draw(paths[0]);
                }
                if (rightStyle != BorderStrokeStyle.NONE) {
                    double rsum = radii.getTopRightVerticalRadius() + radii.getBottomRightVerticalRadius();
                    double rightLineLength = height + rsum * (Math.PI / 4 - 1);
                    g.setStroke(createStroke(rightStyle, rightWidth, rightLineLength, true));
                    g.setPaint(getPlatformPaint(rightStroke));
                    g.draw(paths[1]);
                }
                if (bottomStyle != BorderStrokeStyle.NONE) {
                    double rsum = radii.getBottomLeftHorizontalRadius() + radii.getBottomRightHorizontalRadius();
                    double bottomLineLength = width + rsum * (Math.PI / 4 - 1);
                    g.setStroke(createStroke(bottomStyle, bottomWidth, bottomLineLength, true));
                    g.setPaint(getPlatformPaint(bottomStroke));
                    g.draw(paths[2]);
                }
                if (leftStyle != BorderStrokeStyle.NONE) {
                    double rsum = radii.getTopLeftVerticalRadius() + radii.getBottomLeftVerticalRadius();
                    double leftLineLength = height + rsum * (Math.PI / 4 - 1);
                    g.setStroke(createStroke(leftStyle, leftWidth, leftLineLength, true));
                    g.setPaint(getPlatformPaint(leftStroke));
                    g.draw(paths[3]);
                }
            }
        }

        for (int i = 0, max = images.size(); i &lt; max; i++) {
            final BorderImage ib = images.get(i);
            final Image prismImage = (Image) Toolkit.getImageAccessor().getPlatformImage(ib.getImage());
            if (prismImage == null) {
                // The prismImage might be null if the Image has not completed loading.
                // In that case, we simply must skip rendering of that layer this
                // time around.
                continue;
            }
            final int imgWidth = prismImage.getWidth();
            final int imgHeight = prismImage.getHeight();
            final float imgScale = prismImage.getPixelScale();
            final BorderWidths widths = ib.getWidths();
            final Insets insets = ib.getInsets();
            final BorderWidths slices = ib.getSlices();

            // we will get gaps if we don't round to pixel boundaries
            final int topInset = (int) Math.round(insets.getTop());
            final int rightInset = (int) Math.round(insets.getRight());
            final int bottomInset = (int) Math.round(insets.getBottom());
            final int leftInset = (int) Math.round(insets.getLeft());

            final int topWidth = widthSize(widths.isTopAsPercentage(), widths.getTop(), height);
            final int rightWidth = widthSize(widths.isRightAsPercentage(), widths.getRight(), width);
            final int bottomWidth = widthSize(widths.isBottomAsPercentage(), widths.getBottom(), height);
            final int leftWidth = widthSize(widths.isLeftAsPercentage(), widths.getLeft(), width);

            final int topSlice = sliceSize(slices.isTopAsPercentage(), slices.getTop(), imgHeight, imgScale);
            final int rightSlice = sliceSize(slices.isRightAsPercentage(), slices.getRight(), imgWidth, imgScale);
            final int bottomSlice = sliceSize(slices.isBottomAsPercentage(), slices.getBottom(), imgHeight, imgScale);
            final int leftSlice = sliceSize(slices.isLeftAsPercentage(), slices.getLeft(), imgWidth, imgScale);

            // handle case where region is too small to fit in borders
            if ((leftInset + leftWidth + rightInset + rightWidth) &gt; width
                    || (topInset + topWidth + bottomInset + bottomWidth) &gt; height) {
                continue;
            }

            // calculate some things we can share
            final int centerMinX = leftInset + leftWidth;
            final int centerMinY = topInset + topWidth;
            final int centerW = Math.round(width) - rightInset - rightWidth - centerMinX;
            final int centerH = Math.round(height) - bottomInset - bottomWidth - centerMinY;
            final int centerMaxX = centerW + centerMinX;
            final int centerMaxY = centerH + centerMinY;
            final int centerSliceWidth = imgWidth - leftSlice - rightSlice;
            final int centerSliceHeight = imgHeight - topSlice - bottomSlice;
            // paint top left corner
            paintTiles(g, prismImage, BorderRepeat.STRETCH, BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
                       leftInset, topInset, leftWidth, topWidth, // target bounds
                       0, 0, leftSlice, topSlice, // src image bounds
                       0, 0, leftWidth, topWidth); // tile bounds
            // paint top slice
            float tileWidth = (ib.getRepeatX() == BorderRepeat.STRETCH) ?
                    centerW : (topSlice &gt; 0 ? (centerSliceWidth * topWidth) / topSlice : 0);
            float tileHeight = topWidth;
            paintTiles(
                    g, prismImage, ib.getRepeatX(), BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
                    centerMinX, topInset, centerW, topWidth,
                    leftSlice, 0, centerSliceWidth, topSlice,
                    (centerW - tileWidth) / 2, 0, tileWidth, tileHeight);
            // paint top right corner
            paintTiles(g, prismImage, BorderRepeat.STRETCH, BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
                       centerMaxX, topInset, rightWidth, topWidth,
                       (imgWidth - rightSlice), 0, rightSlice, topSlice,
                       0, 0, rightWidth, topWidth);
            // paint left slice
            tileWidth = leftWidth;
            tileHeight = (ib.getRepeatY() == BorderRepeat.STRETCH) ?
                    centerH : (leftSlice &gt; 0 ? (leftWidth * centerSliceHeight) / leftSlice : 0);
            paintTiles(g, prismImage, BorderRepeat.STRETCH, ib.getRepeatY(), Side.LEFT, Side.TOP,
                       leftInset, centerMinY, leftWidth, centerH,
                       0, topSlice, leftSlice, centerSliceHeight,
                       0, (centerH - tileHeight) / 2, tileWidth, tileHeight);
            // paint right slice
            tileWidth = rightWidth;
            tileHeight = (ib.getRepeatY() == BorderRepeat.STRETCH) ?
                    centerH : (rightSlice &gt; 0 ? (rightWidth * centerSliceHeight) / rightSlice : 0);
            paintTiles(g, prismImage, BorderRepeat.STRETCH, ib.getRepeatY(), Side.LEFT, Side.TOP,
                       centerMaxX, centerMinY, rightWidth, centerH,
                       imgWidth - rightSlice, topSlice, rightSlice, centerSliceHeight,
                       0, (centerH - tileHeight) / 2, tileWidth, tileHeight);
            // paint bottom left corner
            paintTiles(g, prismImage, BorderRepeat.STRETCH, BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
                       leftInset, centerMaxY, leftWidth, bottomWidth,
                       0, imgHeight - bottomSlice, leftSlice, bottomSlice,
                       0, 0, leftWidth, bottomWidth);
            // paint bottom slice
            tileWidth = (ib.getRepeatX() == BorderRepeat.STRETCH) ?
                    centerW : (bottomSlice &gt; 0 ? (centerSliceWidth * bottomWidth) / bottomSlice : 0);
            tileHeight = bottomWidth;
            paintTiles(g, prismImage, ib.getRepeatX(), BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
                       centerMinX, centerMaxY, centerW, bottomWidth,
                       leftSlice, imgHeight - bottomSlice, centerSliceWidth, bottomSlice,
                       (centerW - tileWidth) / 2, 0, tileWidth, tileHeight);
            // paint bottom right corner
            paintTiles(g, prismImage, BorderRepeat.STRETCH, BorderRepeat.STRETCH, Side.LEFT, Side.TOP,
                       centerMaxX, centerMaxY, rightWidth, bottomWidth,
                       imgWidth - rightSlice, imgHeight - bottomSlice, rightSlice, bottomSlice,
                       0, 0, rightWidth, bottomWidth);
            // paint the center slice
            if (ib.isFilled()) {
                // handle no repeat as stretch
                final float imgW = (ib.getRepeatX() == BorderRepeat.STRETCH) ? centerW : centerSliceWidth;
                final float imgH = (ib.getRepeatY() == BorderRepeat.STRETCH) ? centerH : centerSliceHeight;
                paintTiles(g, prismImage, ib.getRepeatX(), ib.getRepeatY(), Side.LEFT, Side.TOP,
                           centerMinX, centerMinY, centerW, centerH,
                           leftSlice, topSlice, centerSliceWidth, centerSliceHeight,
                           0, 0, imgW, imgH);
            }
        }
    }

    /**
     * Visits each of the background fills and takes their radii into account to determine the insets.
     * The backgroundInsets variable is cleared whenever the fills change, or whenever the size of the
     * region has changed (because if the size of the region changed and a radius is percentage based
     * then we need to recompute the insets).
     */
    private void updateBackgroundInsets() {
        float top=0, right=0, bottom=0, left=0;
        final List&lt;BackgroundFill&gt; fills = background.getFills();
        for (int i=0, max=fills.size(); i&lt;max; i++) {
            // We need to now inspect the paint to determine whether we can use a cache for this background.
            // If a shape is being used, we don't care about gradients (we cache 'em both), but for a rectangle
            // fill we omit these (so we can do 3-patch scaling). An ImagePattern is deadly to either
            // (well, only deadly to a shape if it turns out to be a writable image).
            final BackgroundFill fill = fills.get(i);
            final Insets insets = fill.getInsets();
            final CornerRadii radii = getNormalizedFillRadii(i);
            top = (float) Math.max(top, insets.getTop() + Math.max(radii.getTopLeftVerticalRadius(), radii.getTopRightVerticalRadius()));
            right = (float) Math.max(right, insets.getRight() + Math.max(radii.getTopRightHorizontalRadius(), radii.getBottomRightHorizontalRadius()));
            bottom = (float) Math.max(bottom, insets.getBottom() + Math.max(radii.getBottomRightVerticalRadius(), radii.getBottomLeftVerticalRadius()));
            left = (float) Math.max(left, insets.getLeft() + Math.max(radii.getTopLeftHorizontalRadius(), radii.getBottomLeftHorizontalRadius()));
        }
        backgroundInsets = new Insets(roundUp(top), roundUp(right), roundUp(bottom), roundUp(left));
    }

    private int widthSize(boolean isPercent, double sliceSize, float objSize) {
        //Not strictly correct. See RT-34051
        return (int) Math.round(isPercent ? sliceSize * objSize : sliceSize);
    }

    private int sliceSize(boolean isPercent, double sliceSize, float objSize, float scale) {
        if (isPercent) sliceSize *= objSize;
        if (sliceSize &gt; objSize) sliceSize = objSize;
        return (int) Math.round(sliceSize * scale);
    }

    private int roundUp(double d) {
        return (d - (int)d) == 0 ? (int) d : (int) (d + 1);
    }


    /**
     * Creates a Prism BasicStroke based on the stroke style, width, and line length.
     *
     * @param sb             The BorderStrokeStyle
     * @param strokeWidth    The width of the stroke we're going to draw
     * @param lineLength     The total linear length of this stroke. This is needed for
     *                       handling &quot;dashed&quot; and &quot;dotted&quot; cases, otherwise, it is ignored.
     * @param forceCentered  When this is set to true, the stroke is always centered.
     *                       The &quot;outer/inner&quot; stroking has to be done by moving the line
     * @return A prism BasicStroke
     */
    private BasicStroke createStroke(BorderStrokeStyle sb,
                                     double strokeWidth,
                                     double lineLength,
                                     boolean forceCentered) {
        int cap;
        if (sb.getLineCap() == StrokeLineCap.BUTT) {
            cap = BasicStroke.CAP_BUTT;
        } else if (sb.getLineCap() == StrokeLineCap.SQUARE) {
            cap = BasicStroke.CAP_SQUARE;
        } else {
            cap = BasicStroke.CAP_ROUND;
        }

        int join;
        if (sb.getLineJoin() == StrokeLineJoin.BEVEL) {
            join = BasicStroke.JOIN_BEVEL;
        } else if (sb.getLineJoin() == StrokeLineJoin.MITER) {
            join = BasicStroke.JOIN_MITER;
        } else {
            join = BasicStroke.JOIN_ROUND;
        }

        int type;
        if (forceCentered) {
            type = BasicStroke.TYPE_CENTERED;
        } else if (scaleShape) {
            // Note: this is just a workaround that allows us to avoid shape bounds computation with the given stroke.
            // By using inner stroke, we know the shape bounds and the shape will be scaled correctly, but the size of
            // the stroke after the scale will be slightly different, but this should be visible only with big stroke widths
            // See https://javafx-jira.kenai.com/browse/RT-38384
            type = BasicStroke.TYPE_INNER;
        } else {
            switch (sb.getType()) {
                case INSIDE:
                    type = BasicStroke.TYPE_INNER;
                    break;
                case OUTSIDE:
                    type = BasicStroke.TYPE_OUTER;
                    break;
                case CENTERED:
                default:
                    type = BasicStroke.TYPE_CENTERED;
                    break;
            }
        }

        BasicStroke bs;
        if (sb == BorderStrokeStyle.NONE) {
            throw new AssertionError(&quot;Should never have been asked to draw a border with NONE&quot;);
        } else if (strokeWidth &lt;= 0) {
            // The stroke essentially disappears in this case, but some of the
            // dashing calculations below can produce degenerate dash arrays
            // that are problematic when the strokeWidth is 0.

            // Ideally the calling code would not even be trying to perform a
            // stroke under these conditions, but there are so many unchecked
            // calls to createStroke() in the code that pass the result directly
            // to a Graphics and then use it, that we need to return something
            // valid, even if it represents a NOP.

            bs = new BasicStroke((float) strokeWidth, cap, join,
                    (float) sb.getMiterLimit());
        } else if (sb.getDashArray().size() &gt; 0) {
            List&lt;Double&gt; dashArray = sb.getDashArray();
            double[] array;
            float dashOffset;
            if (dashArray == BorderStrokeStyle.DOTTED.getDashArray()) {
                // NOTE: IF line length is &gt; 0, then we are going to do some math to try to make the resulting
                // dots look pleasing. It is set to -1 if we are stroking a random path (vs. a rounded rect), in
                // which case we are going to just scale the dotting pattern based on the stroke width, but we won't
                // try to adjust the phase to make it look better.
                if (lineLength &gt; 0) {
                    // For DOTTED we want the dash array to be 0, val, where the &quot;val&quot; is as close to strokewidth*2 as
                    // possible, but we want the spacing to be such that we get an even spacing between all dots around
                    // the edge.
                    double remainder = lineLength % (strokeWidth * 2);
                    double numSpaces = lineLength / (strokeWidth * 2);
                    double spaceWidth = (strokeWidth * 2) + (remainder / numSpaces);
                    array = new double[] {0, spaceWidth};
                    dashOffset = 0;
                } else {
                    array = new double[] {0, strokeWidth * 2};
                    dashOffset = 0;
                }
            } else if (dashArray == BorderStrokeStyle.DASHED.getDashArray()) {
                // NOTE: IF line length is &gt; 0, then we are going to do some math to try to make the resulting
                // dash look pleasing. It is set to -1 if we are stroking a random path (vs. a rounded rect), in
                // which case we are going to just scale the dashing pattern based on the stroke width, but we won't
                // try to adjust the phase to make it look better.
                if (lineLength &gt; 0) {
                    // For DASHED we want the dash array to be 2*strokewidth, val where &quot;val&quot; is as close to
                    // 1.4*strokewidth as possible, but we want the spacing to be such that we get an even spacing between
                    // all dashes around the edge. Maybe we can start with the dash phase at half the dash length.
                    final double dashLength = strokeWidth * 2;
                    double gapLength = strokeWidth * 1.4;
                    final double segmentLength = dashLength + gapLength;
                    final double divided = lineLength / segmentLength;
                    final double numSegments = (int) divided;
                    if (numSegments &gt; 0) {
                        final double dashCumulative = numSegments * dashLength;
                        gapLength = (lineLength - dashCumulative) / numSegments;
                    }
                    array = new double[] {dashLength, gapLength};
                    dashOffset = (float) (dashLength*.6);
                } else {
                    array = new double[] {2 * strokeWidth, 1.4 * strokeWidth};
                    dashOffset = 0;
                }
            } else {
                // If we are not DASHED or DOTTED or we're stroking a path and not a basic rounded rectangle
                // so we just take what we've been given.
                array = new double[dashArray.size()];
                for (int i=0; i&lt;array.length; i++) {
                    array[i] = dashArray.get(i);
                }
                dashOffset = (float) sb.getDashOffset();
            }

            bs = new BasicStroke(type, (float) strokeWidth, cap, join,
                    (float) sb.getMiterLimit(),
                    array, dashOffset);
        } else {
            bs = new BasicStroke(type, (float) strokeWidth, cap, join,
                    (float) sb.getMiterLimit());
        }

        return bs;
    }

    private void setBorderStyle(Graphics g, BorderStroke sb, double length, boolean forceCentered) {
        // Any one of, or all of, the sides could be 'none'.
        // Take the first side that isn't.
        final BorderWidths widths = sb.getWidths();
        BorderStrokeStyle bs = sb.getTopStyle();
        double sbWidth = widths.isTopAsPercentage() ? height * widths.getTop() : widths.getTop();
        Paint sbFill = getPlatformPaint(sb.getTopStroke());
        if (bs == null) {
            bs = sb.getLeftStyle();
            sbWidth = widths.isLeftAsPercentage() ? width * widths.getLeft() : widths.getLeft();
            sbFill = getPlatformPaint(sb.getLeftStroke());
            if (bs == null) {
                bs = sb.getBottomStyle();
                sbWidth = widths.isBottomAsPercentage() ? height * widths.getBottom() : widths.getBottom();
                sbFill = getPlatformPaint(sb.getBottomStroke());
                if (bs == null) {
                    bs = sb.getRightStyle();
                    sbWidth = widths.isRightAsPercentage() ? width * widths.getRight() : widths.getRight();
                    sbFill = getPlatformPaint(sb.getRightStroke());
                }
            }
        }
        if (bs == null || bs == BorderStrokeStyle.NONE) {
            return;
        }

        g.setStroke(createStroke(bs, sbWidth, length, forceCentered));
        g.setPaint(sbFill);
    }

    /**
     * Inserts geometry into the specified Path2D object for the specified
     * corner of a general rounded rectangle.
     *
     * The corner drawn is specified by the quadrant parameter, whose least
     * significant 2 bits specify the following corners and the associated
     * start, corner, and end points (which are always drawn clockwise):
     *
     * 0 - Top Left:      X + 0 , Y + VR,      X, Y,      X + HR, Y + 0
     * 1 - Top Right:     X - HR, Y + 0 ,      X, Y,      X + 0 , Y + VR
     * 2 - Bottom Right:  X + 0 , Y - VR,      X, Y,      X - HR, Y + 0
     * 3 - Bottom Left:   X + HR, Y + 0 ,      X, Y,      X + 0 , Y - VR
     *
     * The associated horizontal and vertical radii are fetched from the
     * indicated CornerRadii object which is assumed to be absolute (not
     * percentage based) and already scaled so that no pair of radii are
     * larger than the indicated width/height of the rounded rectangle being
     * expressed.
     *
     * The tstart and tend parameters specify what portion of the rounded
     * corner should be drawn with 0f =&gt; 1f being the entire rounded corner.
     *
     * The newPath parameter indicates whether the path should reach the
     * starting point with a moveTo() command or a lineTo() segment.
     *
     * @param path
     * @param radii
     * @param x
     * @param y
     * @param quadrant
     * @param tstart
     * @param tend
     * @param newPath
     */
    private void doCorner(Path2D path, CornerRadii radii,
                          float x, float y, int quadrant,
                          float tstart, float tend, boolean newPath)
    {
        float dx0, dy0, dx1, dy1;
        float hr, vr;
        switch (quadrant &amp; 0x3) {
            case 0:
                hr = (float) radii.getTopLeftHorizontalRadius();
                vr = (float) radii.getTopLeftVerticalRadius();
                // 0 - Top Left:      X + 0 , Y + VR,      X, Y,      X + HR, Y + 0
                dx0 =  0f;  dy0 =  vr;    dx1 =  hr;  dy1 =  0f;
                break;
            case 1:
                hr = (float) radii.getTopRightHorizontalRadius();
                vr = (float) radii.getTopRightVerticalRadius();
                // 1 - Top Right:     X - HR, Y + 0 ,      X, Y,      X + 0 , Y + VR
                dx0 = -hr;  dy0 =  0f;    dx1 =  0f;  dy1 =  vr;
                break;
            case 2:
                hr = (float) radii.getBottomRightHorizontalRadius();
                vr = (float) radii.getBottomRightVerticalRadius();
                // 2 - Bottom Right:  X + 0 , Y - VR,      X, Y,      X - HR, Y + 0
                dx0 =  0f;  dy0 = -vr;    dx1 = -hr;  dy1 = 0f;
                break;
            case 3:
                hr = (float) radii.getBottomLeftHorizontalRadius();
                vr = (float) radii.getBottomLeftVerticalRadius();
                // 3 - Bottom Left:   X + HR, Y + 0 ,      X, Y,      X + 0 , Y - VR
                dx0 =  hr;  dy0 =  0f;    dx1 =  0f;  dy1 = -vr;
                break;
            default: return; // Can never happen
        }
        if (hr &gt; 0 &amp;&amp; vr &gt; 0) {
            path.appendOvalQuadrant(x + dx0, y + dy0, x, y, x + dx1, y + dy1, tstart, tend,
                                    (newPath)
                                        ? Path2D.CornerPrefix.MOVE_THEN_CORNER
                                        : Path2D.CornerPrefix.LINE_THEN_CORNER);
        } else if (newPath) {
            path.moveTo(x, y);
        } else {
            path.lineTo(x, y);
        }
    }

    /**
     * Creates a rounded rectangle path with our width and height, different corner radii,
     * offset with given offsets
     */
    private Path2D createPath(float width, float height, float t, float l, float bo, float ro, CornerRadii radii) {
        float r = width - ro;
        float b = height - bo;
        Path2D path = new Path2D();
        doCorner(path, radii, l, t, 0, 0f, 1f, true);
        doCorner(path, radii, r, t, 1, 0f, 1f, false);
        doCorner(path, radii, r, b, 2, 0f, 1f, false);
        doCorner(path, radii, l, b, 3, 0f, 1f, false);
        path.closePath();
        return path;
    }

    private Path2D makeRoundedEdge(CornerRadii radii,
                                   float x0, float y0, float x1, float y1,
                                   int quadrant)
    {
        Path2D path = new Path2D();
        doCorner(path, radii, x0, y0, quadrant,   0.5f, 1.0f, true);
        doCorner(path, radii, x1, y1, quadrant+1, 0.0f, 0.5f, false);
        return path;
    }

    /**
     * Creates a rounded rectangle path with our width and height, different corner radii, offset with given offsets.
     * Each side as a separate path.  The sides are returned in the CSS standard
     * order of top, right, bottom, left.
     */
    private Path2D[] createPaths(float t, float l, float bo, float ro, CornerRadii radii)
    {
        float r = width - ro;
        float b = height - bo;
        return new Path2D[] {
            makeRoundedEdge(radii, l, t, r, t, 0), // top
            makeRoundedEdge(radii, r, t, r, b, 1), // right
            makeRoundedEdge(radii, r, b, l, b, 2), // bottom
            makeRoundedEdge(radii, l, b, l, t, 3), // left
        };
    }

    /**
     * Create a bigger or smaller version of shape. If not scaleShape then the shape is just centered rather
     * than resized. Proportions are not maintained when resizing. This is necessary so as to ensure
     * that the fill never looks scaled. For example, a tile-imaged based background will look stretched
     * if we were to render a scaled shape. Instead, we produce a new shape based on the scaled size and
     * then fill that shape without additional transforms.
     */
    private Shape resizeShape(float topOffset, float rightOffset, float bottomOffset, float leftOffset) {
        // The bounds of the shape, before any centering / scaling takes place
        final RectBounds bounds = shape.getBounds();
        if (scaleShape) {
            // First we need to modify the transform to scale the shape so that it will fit
            // within the insets.
            SCRATCH_AFFINE.setToIdentity();
            SCRATCH_AFFINE.translate(leftOffset, topOffset);
            // width &amp; height are the width and height of the region. w &amp; h are the width and height
            // of the box within which the new shape must fit.
            final float w = width - leftOffset - rightOffset;
            final float h = height - topOffset - bottomOffset;
            SCRATCH_AFFINE.scale(w / bounds.getWidth(), h / bounds.getHeight());
            // If we also need to center it, we need to adjust the transform so as to place
            // the shape in the center of the bounds
            if (centerShape) {
                SCRATCH_AFFINE.translate(-bounds.getMinX(), -bounds.getMinY());
            }
            return SCRATCH_AFFINE.createTransformedShape(shape);
        } else if (centerShape) {
            // We are only centering. In this case, what we want is for the
            // original shape to be centered. If there are offsets (insets)
            // then we must pre-scale about the center to account for it.
            final float boundsWidth = bounds.getWidth();
            final float boundsHeight = bounds.getHeight();
            float newW = boundsWidth - leftOffset - rightOffset;
            float newH = boundsHeight - topOffset - bottomOffset;
            SCRATCH_AFFINE.setToIdentity();
            SCRATCH_AFFINE.translate(leftOffset + (width - boundsWidth)/2 - bounds.getMinX(),
                                     topOffset + (height - boundsHeight)/2 - bounds.getMinY());
            if (newH != boundsHeight || newW != boundsWidth) {
                SCRATCH_AFFINE.translate(bounds.getMinX(), bounds.getMinY());
                SCRATCH_AFFINE.scale(newW / boundsWidth, newH / boundsHeight);
                SCRATCH_AFFINE.translate(-bounds.getMinX(), -bounds.getMinY());
            }
            return SCRATCH_AFFINE.createTransformedShape(shape);
        } else if (topOffset != 0 || rightOffset != 0 || bottomOffset != 0 || leftOffset != 0) {
            // We are neither centering nor scaling, but we still have to resize the
            // shape because we have to fit within the bounds defined by the offsets
            float newW = bounds.getWidth() - leftOffset - rightOffset;
            float newH = bounds.getHeight() - topOffset - bottomOffset;
            SCRATCH_AFFINE.setToIdentity();
            SCRATCH_AFFINE.translate(leftOffset, topOffset);
            SCRATCH_AFFINE.translate(bounds.getMinX(), bounds.getMinY());
            SCRATCH_AFFINE.scale(newW / bounds.getWidth(), newH / bounds.getHeight());
            SCRATCH_AFFINE.translate(-bounds.getMinX(), -bounds.getMinY());
            return SCRATCH_AFFINE.createTransformedShape(shape);
        } else {
            // Nothing has changed, so we can simply return!
            return shape;
        }
    }

    private void paintTiles(Graphics g, Image img, BorderRepeat repeatX, BorderRepeat repeatY, Side horizontalSide, Side verticalSide,
            final float regionX, final float regionY, final float regionWidth, final float regionHeight,
            final int srcX, final int srcY, final int srcW, final int srcH,
            float tileX, float tileY, float tileWidth, float tileHeight)
    {
        BackgroundRepeat rx = null;
        BackgroundRepeat ry = null;

        switch (repeatX) {
            case REPEAT: rx = BackgroundRepeat.REPEAT; break;
            case STRETCH: rx = BackgroundRepeat.NO_REPEAT; break;
            case ROUND: rx = BackgroundRepeat.ROUND; break;
            case SPACE: rx = BackgroundRepeat.SPACE; break;
        }

        switch (repeatY) {
            case REPEAT: ry = BackgroundRepeat.REPEAT; break;
            case STRETCH: ry = BackgroundRepeat.NO_REPEAT; break;
            case ROUND: ry = BackgroundRepeat.ROUND; break;
            case SPACE: ry = BackgroundRepeat.SPACE; break;
        }

        paintTiles(g, img, rx, ry, horizontalSide, verticalSide, regionX, regionY, regionWidth, regionHeight,
                   srcX, srcY, srcW, srcH, tileX, tileY, tileWidth, tileHeight);
    }

    /**
     * Paints a subsection (srcX,srcY,srcW,srcH) of an image tiled or stretched to fill the destination area
     * (regionWidth,regionHeight). It is assumed we are pre-transformed to the correct origin, top left or destination area. When
     * tiling the first tile is positioned within the rectangle (tileX,tileY,tileW,tileH).
     *
     * Drawing two images next to each other on a non-pixel boundary can not be done simply so we use integers here. This
     * assumption may be wrong when drawing though a scale transform.
     *
     * @param g        The graphics context to draw image into
     * @param img       The image to draw
     * @param repeatX   The horizontal repeat style for filling the area with the src image
     * @param repeatY   The vertical repeat style for filling the area with the src image
     * @param horizontalSide The left or right
     * @param verticalSide The top or bottom
     * @param regionX      The top left corner X of the area of the graphics context to fill with our img
     * @param regionY      The top left corner Y of the area of the graphics context to fill with our img
     * @param regionWidth      The width of the area of the graphics context to fill with our img
     * @param regionHeight      The height of the area of the graphics context to fill with our img
     * @param srcX      The top left corner X of the area of the image to paint with
     * @param srcY      The top left corner Y of the area of the image to paint with
     * @param srcW      The width of the area of the image to paint with, -1 to use the original image width
     * @param srcH      The height of the area of the image to paint with, -1 to use the original image height
     * @param tileX     The top left corner X of the area of the first tile within the destination rectangle. In some
     *                  cases we begin by drawing the center tile, and working to the left &amp; right (for example), so
     *                  this value is not always the same as regionX.
     * @param tileY     The top left corner Y of the area of the first tile within the destination rectangle
     * @param tileWidth The width of the area of the first tile within the destination rectangle, if &lt;= 0, then the use intrinsic value
     * @param tileHeight The height of the area of the first tile within the destination rectangle, if &lt;= 0, then the use intrinsic value
     */
    private void paintTiles(Graphics g, Image img, BackgroundRepeat repeatX, BackgroundRepeat repeatY, Side horizontalSide, Side verticalSide,
            final float regionX, final float regionY, final float regionWidth, final float regionHeight,
            final int srcX, final int srcY, final int srcW, final int srcH,
            float tileX, float tileY, float tileWidth, float tileHeight)
    {
        // If the destination width/height is 0 or the src width / height is 0 then we have
        // nothing to draw, so we can just bail.
        if (regionWidth &lt;= 0 || regionHeight &lt;= 0 || srcW &lt;= 0 || srcH &lt;= 0) return;

        // At this point we should have real values for the image source coordinates
        assert srcX &gt;= 0 &amp;&amp; srcY &gt;= 0 &amp;&amp; srcW &gt; 0 &amp;&amp; srcH &gt; 0;

        // If we are repeating in both the x &amp; y directions, then we can take a fast path and just
        // use the ImagePattern directly instead of having to issue a large number of drawTexture calls.
        // This is the generally common case where we are tiling the background in both dimensions.
        // Note that this only works if the anchor point is the top-left, otherwise the ImagePattern would
        // not give the correct expected results.
        if (tileX == 0 &amp;&amp; tileY == 0 &amp;&amp; repeatX == BackgroundRepeat.REPEAT &amp;&amp; repeatY == BackgroundRepeat.REPEAT) {
            if (srcX != 0 || srcY != 0 || srcW != img.getWidth() || srcH != img.getHeight()) {
                img = img.createSubImage(srcX, srcY, srcW, srcH);
            }
            g.setPaint(new ImagePattern(img, 0, 0, tileWidth, tileHeight, false, false));
            g.fillRect(regionX, regionY, regionWidth, regionHeight);
        } else {
            // If SPACE repeat mode is being used, then we need to take special action if there is not enough
            // space to have more than one tile. Basically, it needs to act as NO_REPEAT in that case (see
            // section 3.4 of the spec for details under rules for SPACE).
            if (repeatX == BackgroundRepeat.SPACE &amp;&amp; (regionWidth &lt; (tileWidth * 2))) {
                repeatX = BackgroundRepeat.NO_REPEAT;
            }

            if (repeatY == BackgroundRepeat.SPACE &amp;&amp; (regionHeight &lt; (tileHeight * 2))) {
                repeatY = BackgroundRepeat.NO_REPEAT;
            }

            // The following variables are computed and used in order to lay out the tiles in the x and y directions.
            // &quot;count&quot; is used to keep track of the number of tiles to lay down in the x and y directions.
            final int countX, countY;
            // The amount to increment the dstX and dstY by during the rendering loop. This may be positive or
            //negative and will include any space between tiles.
            final float xIncrement, yIncrement;

            // Based on the repeat mode, populate the above variables
            if (repeatX == BackgroundRepeat.REPEAT) {
                // In some cases we have a large positive offset but are in repeat mode. What we need
                // to do is tile, but we want to do so in such a way that we are &quot;anchored&quot; to the center,
                // or right, or whatnot. That is what offsetX will be used for.
                float offsetX = 0;
                if (tileX != 0) {
                    float mod = tileX % tileWidth;
                    tileX = mod == 0 ? 0 : tileX &lt; 0 ? mod : mod - tileWidth;
                    offsetX = tileX;
                }
                countX = (int) Math.max(1, Math.ceil((regionWidth - offsetX) / tileWidth));
                xIncrement = horizontalSide == Side.RIGHT ? -tileWidth : tileWidth;
            } else if (repeatX == BackgroundRepeat.SPACE) {
                tileX = 0; // Space will always start from the top left
                countX = (int) (regionWidth / tileWidth);
                float remainder = (regionWidth % tileWidth);
                xIncrement = tileWidth + (remainder / (countX - 1));
            } else if (repeatX == BackgroundRepeat.ROUND) {
                tileX = 0; // Round will always start from the top left
                countX = (int) (regionWidth / tileWidth);
                tileWidth = regionWidth / (int)(regionWidth / tileWidth);
                xIncrement = tileWidth;
            } else { // no repeat
                countX = 1;
                xIncrement = horizontalSide == Side.RIGHT ? -tileWidth : tileWidth;
            }

            if (repeatY == BackgroundRepeat.REPEAT) {
                float offsetY = 0;
                if (tileY != 0) {
                    float mod = tileY % tileHeight;
                    tileY = mod == 0 ? 0 : tileY &lt; 0 ? mod : mod - tileHeight;
                    offsetY = tileY;
                }
                countY = (int) Math.max(1, Math.ceil((regionHeight - offsetY) / tileHeight));
                yIncrement = verticalSide == Side.BOTTOM ? -tileHeight : tileHeight;
            } else if (repeatY == BackgroundRepeat.SPACE) {
                tileY = 0; // Space will always start from the top left
                countY = (int) (regionHeight / tileHeight);
                float remainder = (regionHeight % tileHeight);
                yIncrement = tileHeight + (remainder / (countY - 1));
            } else if (repeatY == BackgroundRepeat.ROUND) {
                tileY = 0; // Round will always start from the top left
                countY = (int) (regionHeight / tileHeight);
                tileHeight = regionHeight / (int)(regionHeight / tileHeight);
                yIncrement = tileHeight;
            } else { // no repeat
                countY = 1;
                yIncrement = verticalSide == Side.BOTTOM ? -tileHeight : tileHeight;
            }

            // paint loop
            final Texture texture =
                g.getResourceFactory().getCachedTexture(img, Texture.WrapMode.CLAMP_TO_EDGE);
            final int srcX2 = srcX + srcW;
            final int srcY2 = srcY + srcH;
            final float regionX2 = regionX + regionWidth;
            final float regionY2 = regionY + regionHeight;

            float dstY = regionY + tileY;
            for (int y = 0; y &lt; countY; y++) {
                float dstY2 = dstY + tileHeight;
                float dstX = regionX + tileX;
                for (int x = 0; x &lt; countX; x++) {
                    float dstX2 = dstX + tileWidth;
                    // We don't want to end up rendering if we find that the destination rect is completely
                    // off of the region rendering area
                    boolean skipRender = false;
                    float dx1 = dstX &lt; regionX ? regionX : dstX;
                    float dy1 = dstY &lt; regionY ? regionY : dstY;
                    if (dx1 &gt; regionX2 || dy1 &gt; regionY2) skipRender = true;

                    float dx2 = dstX2 &gt; regionX2 ? regionX2 : dstX2;
                    float dy2 = dstY2 &gt; regionY2 ? regionY2 : dstY2;
                    if (dx2 &lt; regionX || dy2 &lt; regionY) skipRender = true;

                    if (!skipRender) {
                        // We know that dstX, dstY, dstX2, dstY2 overlap the region drawing area. Now we need
                        // to compute the source rectangle, and then draw.
                        float sx1 = dstX &lt; regionX ? srcX + srcW * (-tileX / tileWidth) : srcX;
                        float sy1 = dstY &lt; regionY ? srcY + srcH * (-tileY / tileHeight) : srcY;
                        float sx2 = dstX2 &gt; regionX2 ? srcX2 - srcW * ((dstX2 - regionX2) / tileWidth) : srcX2;
                        float sy2 = dstY2 &gt; regionY2 ? srcY2 - srcH * ((dstY2 - regionY2) / tileHeight) : srcY2;
//                        System.out.println(&quot;g.drawTexture(texture, &quot; + dx1 + &quot;, &quot; + dy1 + &quot;, &quot; + dx2 + &quot;, &quot; + dy2 + &quot;, &quot; + sx1 + &quot;, &quot; + sy1 + &quot;, &quot; + sx2 + &quot;, &quot; + sy2 + &quot;)&quot;);
                        g.drawTexture(texture, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2);
                    }
                    dstX += xIncrement;
                }
                dstY += yIncrement;
            }
            texture.unlock();
        }
    }

    final Border getBorder() {
        return border;
    }

    final Background getBackground() {
        return background;
    }

    final float getWidth() {
        return width;
    }

    final float getHeight() {
        return height;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/sg/prism/ShapeEvaluator.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.sg.prism;

import java.util.Vector;
import com.sun.javafx.geom.FlatteningPathIterator;
import com.sun.javafx.geom.IllegalPathStateException;
import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.PathIterator;
import com.sun.javafx.geom.Point2D;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.Shape;
import com.sun.javafx.geom.transform.BaseTransform;

/**
 * A {@link KeyFrame} {@link Evaluator} for {@link Shape} objects.
 * This {@code Evaluator} can be used to morph between the geometries
 * of two relatively arbitrary shapes with the only restrictions being
 * that the two different numbers of subpaths or two shapes with
 * disparate winding rules may not blend together in a pleasing
 * manner.
 * The ShapeEvaluator will do the best job it can if the shapes do
 * not match in winding rule or number of subpaths, but the geometry
 * of the shapes may need to be adjusted by other means to make the
 * shapes more like each other for best aesthetic effect.
 * &lt;p&gt;
 * Note that the process of comparing two geometries and finding similar
 * structures between them to blend for the morphing operation can be
 * expensive.
 * Instances of {@code ShapeEvaluator} will properly perform the necessary
 * geometric analysis of their arguments on every method call and attempt
 * to cache the information so that they can operate more quickly if called
 * multiple times in a row on the same pair of {@code Shape} objects.
 * As a result attempting to mutate a {@code Shape} object that is stored
 * in one of their keyframes may not have any effect if the associated
 * {@code ShapeEvaluator} has already cached the geometry.
 * Also, it is advisable to use different instances of {@code ShapeEvaluator}
 * for every pair of keyframes being morphed so that the cached information
 * can be reused as much as possible.
 * &lt;p&gt;
 * An example of proper usage:
 * &lt;pre&gt;
 *     SGShape s = ...;
 *     Shape s0 = ...;
 *     Shape s1 = ...;
 *     Shape s2 = ...;
 *     KeyFrame k0 = KeyFrame.create(0.0f, s0, new ShapeEvaluator());
 *     KeyFrame k1 = KeyFrame.create(0.6f, s1, new ShapeEvaluator());
 *     KeyFrame k2 = KeyFrame.create(1.0f, s2, new ShapeEvaluator());
 *     KeyFrames morphFrames = KeyFrames.create(s, &quot;shape&quot;, k0, k1, k2);
 *     Clip.create(5000, 1, morphFrames).start();
 * &lt;/pre&gt;
 *
 */
class ShapeEvaluator {
    private Shape savedv0;
    private Shape savedv1;
    private Geometry geom0;
    private Geometry geom1;

    public Shape evaluate(Shape v0, Shape v1, float fraction) {
        if (savedv0 != v0 || savedv1 != v1) {
            if (savedv0 == v1 &amp;&amp; savedv1 == v0) {
                // Just swap the geometries
                Geometry gtmp = geom0;
                geom0 = geom1;
                geom1 = gtmp;
            } else {
                recalculate(v0, v1);
            }
            savedv0 = v0;
            savedv1 = v1;
        }
        return getShape(fraction);
    }

    private void recalculate(Shape v0, Shape v1) {
        geom0 = new Geometry(v0);
        geom1 = new Geometry(v1);
        float tvals0[] = geom0.getTvals();
        float tvals1[] = geom1.getTvals();
        float masterTvals[] = mergeTvals(tvals0, tvals1);
        geom0.setTvals(masterTvals);
        geom1.setTvals(masterTvals);
    }

    private Shape getShape(float fraction) {
        return new MorphedShape(geom0, geom1, fraction);
    }

    private static float[] mergeTvals(float tvals0[], float tvals1[]) {
        int count = sortTvals(tvals0, tvals1, null);
        float newtvals[] = new float[count];
        sortTvals(tvals0, tvals1, newtvals);
        return newtvals;
    }

    private static int sortTvals(float tvals0[],
                                 float tvals1[],
                                 float newtvals[])
    {
        int i0 = 0;
        int i1 = 0;
        int numtvals = 0;
        while (i0 &lt; tvals0.length &amp;&amp; i1 &lt; tvals1.length) {
            float t0 = tvals0[i0];
            float t1 = tvals1[i1];
            if (t0 &lt;= t1) {
                if (newtvals != null) newtvals[numtvals] = t0;
                i0++;
            }
            if (t1 &lt;= t0) {
                if (newtvals != null) newtvals[numtvals] = t1;
                i1++;
            }
            numtvals++;
        }
        return numtvals;
    }

    private static float interp(float v0, float v1, float t) {
        return (v0 + ((v1 - v0) * t));
    }

    private static class Geometry {
        static final float THIRD = (1f / 3f);
        static final float MIN_LEN = 0.001f;
        float bezierCoords[];
        int numCoords;
        int windingrule;
        float myTvals[];

        public Geometry(Shape s) {
            // Multiple of 6 plus 2 more for initial moveto
            bezierCoords = new float[20];
            PathIterator pi = s.getPathIterator(null);
            windingrule = pi.getWindingRule();
            if (pi.isDone()) {
                // We will have 1 segment and it will be all zeros
                // It will have 8 coordinates (2 for moveto, 6 for cubic)
                numCoords = 8;
            }
            float coords[] = new float[6];
            int type = pi.currentSegment(coords);
            pi.next();
            if (type != PathIterator.SEG_MOVETO) {
                throw new IllegalPathStateException(&quot;missing initial moveto&quot;);
            }
            float curx, cury, movx, movy;
            bezierCoords[0] = curx = movx = coords[0];
            bezierCoords[1] = cury = movy = coords[1];
            float newx, newy;
            Vector&lt;Point2D&gt; savedpathendpoints = new Vector&lt;Point2D&gt;();
            numCoords = 2;
            while (!pi.isDone()) {
                switch (pi.currentSegment(coords)) {
                case PathIterator.SEG_MOVETO:
                    if (curx != movx || cury != movy) {
                        appendLineTo(curx, cury, movx, movy);
                        curx = movx;
                        cury = movy;
                    }
                    newx = coords[0];
                    newy = coords[1];
                    if (curx != newx || cury != newy) {
                        savedpathendpoints.add(new Point2D(movx, movy));
                        appendLineTo(curx, cury, newx, newy);
                        curx = movx = newx;
                        cury = movy = newy;
                    }
                    break;
                case PathIterator.SEG_CLOSE:
                    if (curx != movx || cury != movy) {
                        appendLineTo(curx, cury, movx, movy);
                        curx = movx;
                        cury = movy;
                    }
                    break;
                case PathIterator.SEG_LINETO:
                    newx = coords[0];
                    newy = coords[1];
                    appendLineTo(curx, cury, newx, newy);
                    curx = newx;
                    cury = newy;
                    break;
                case PathIterator.SEG_QUADTO:
                    float ctrlx = coords[0];
                    float ctrly = coords[1];
                    newx = coords[2];
                    newy = coords[3];
                    appendQuadTo(curx, cury, ctrlx, ctrly, newx, newy);
                    curx = newx;
                    cury = newy;
                    break;
                case PathIterator.SEG_CUBICTO:
                    appendCubicTo(coords[0], coords[1],
                                  coords[2], coords[3],
                                  curx = coords[4], cury = coords[5]);
                    break;
                }
                pi.next();
            }
            // Add closing segment if either:
            // - we only have initial moveto - expand it to an empty cubic
            // - or we are not back to the starting point
            if ((numCoords &lt; 8) || curx != movx || cury != movy) {
                appendLineTo(curx, cury, movx, movy);
                curx = movx;
                cury = movy;
            }
            // Now retrace our way back through all of the connecting
            // inter-subpath segments
            for (int i = savedpathendpoints.size()-1; i &gt;= 0; i--) {
                Point2D p = savedpathendpoints.get(i);
                newx = p.x;
                newy = p.y;
                if (curx != newx || cury != newy) {
                    appendLineTo(curx, cury, newx, newy);
                    curx = newx;
                    cury = newy;
                }
            }
            // Now find the segment endpoint with the smallest Y coordinate
            int minPt = 0;
            float minX = bezierCoords[0];
            float minY = bezierCoords[1];
            for (int ci = 6; ci &lt; numCoords; ci += 6) {
                float x = bezierCoords[ci];
                float y = bezierCoords[ci + 1];
                if (y &lt; minY || (y == minY &amp;&amp; x &lt; minX)) {
                    minPt = ci;
                    minX = x;
                    minY = y;
                }
            }
            // If the smallest Y coordinate is not the first coordinate,
            // rotate the points so that it is...
            if (minPt &gt; 0) {
                // Keep in mind that first 2 coords == last 2 coords
                float newCoords[] = new float[numCoords];
                // Copy all coordinates from minPt to the end of the
                // array to the beginning of the new array
                System.arraycopy(bezierCoords, minPt,
                                 newCoords, 0,
                                 numCoords - minPt);
                // Now we do not want to copy 0,1 as they are duplicates
                // of the last 2 coordinates which we just copied.  So
                // we start the source copy at index 2, but we still
                // copy a full minPt coordinates which copies the two
                // coordinates that were at minPt to the last two elements
                // of the array, thus ensuring that thew new array starts
                // and ends with the same pair of coordinates...
                System.arraycopy(bezierCoords, 2,
                                 newCoords, numCoords - minPt,
                                 minPt);
                bezierCoords = newCoords;
            }
            /* Clockwise enforcement:
             * - This technique is based on the formula for calculating
             *   the area of a Polygon.  The standard formula is:
             *   Area(Poly) = 1/2 * sum(x[i]*y[i+1] - x[i+1]y[i])
             * - The returned area is negative if the polygon is
             *   &quot;mostly clockwise&quot; and positive if the polygon is
             *   &quot;mostly counter-clockwise&quot;.
             * - One failure mode of the Area calculation is if the
             *   Polygon is self-intersecting.  This is due to the
             *   fact that the areas on each side of the self-intersection
             *   are bounded by segments which have opposite winding
             *   direction.  Thus, those areas will have opposite signs
             *   on the acccumulation of their area summations and end
             *   up canceling each other out partially.
             * - This failure mode of the algorithm in determining the
             *   exact magnitude of the area is not actually a big problem
             *   for our needs here since we are only using the sign of
             *   the resulting area to figure out the overall winding
             *   direction of the path.  If self-intersections cause
             *   different parts of the path to disagree as to the
             *   local winding direction, that is no matter as we just
             *   wait for the final answer to tell us which winding
             *   direction had greater representation.  If the final
             *   result is zero then the path was equal parts clockwise
             *   and counter-clockwise and we do not care about which
             *   way we order it as either way will require half of the
             *   path to unwind and re-wind itself.
             */
            float area = 0;
            // Note that first and last points are the same so we
            // do not need to process coords[0,1] against coords[n-2,n-1]
            curx = bezierCoords[0];
            cury = bezierCoords[1];
            for (int i = 2; i &lt; numCoords; i += 2) {
                newx = bezierCoords[i];
                newy = bezierCoords[i + 1];
                area += curx * newy - newx * cury;
                curx = newx;
                cury = newy;
            }
            if (area &lt; 0) {
                /* The area is negative so the shape was clockwise
                 * in a Euclidean sense.  But, our screen coordinate
                 * systems have the origin in the upper left so they
                 * are flipped.  Thus, this path &quot;looks&quot; ccw on the
                 * screen so we are flipping it to &quot;look&quot; clockwise.
                 * Note that the first and last points are the same
                 * so we do not need to swap them.
                 * (Not that it matters whether the paths end up cw
                 *  or ccw in the end as long as all of them are the
                 *  same, but above we called this section &quot;Clockwise
                 *  Enforcement&quot;, so we do not want to be liars. ;-)
                 */
                // Note that [0,1] do not need to be swapped with [n-2,n-1]
                // So first pair to swap is [2,3] and [n-4,n-3]
                int i = 2;
                int j = numCoords - 4;
                while (i &lt; j) {
                    curx = bezierCoords[i];
                    cury = bezierCoords[i + 1];
                    bezierCoords[i] = bezierCoords[j];
                    bezierCoords[i + 1] = bezierCoords[j + 1];
                    bezierCoords[j] = curx;
                    bezierCoords[j + 1] = cury;
                    i += 2;
                    j -= 2;
                }
            }
        }

        private void appendLineTo(float x0, float y0,
                                  float x1, float y1)
        {
            appendCubicTo(// A third of the way from xy0 to xy1:
                        interp(x0, x1, THIRD),
                        interp(y0, y1, THIRD),
                        // A third of the way from xy1 back to xy0:
                        interp(x1, x0, THIRD),
                        interp(y1, y0, THIRD),
                        x1, y1);
        }

        private void appendQuadTo(float x0, float y0,
                                  float ctrlx, float ctrly,
                                  float x1, float y1)
        {
            appendCubicTo(// A third of the way from ctrlxy back to xy0:
                        interp(ctrlx, x0, THIRD),
                        interp(ctrly, y0, THIRD),
                        // A third of the way from ctrlxy to xy1:
                        interp(ctrlx, x1, THIRD),
                        interp(ctrly, y1, THIRD),
                        x1, y1);
        }

        private void appendCubicTo(float ctrlx1, float ctrly1,
                                   float ctrlx2, float ctrly2,
                                   float x1, float y1)
        {
            if (numCoords + 6 &gt; bezierCoords.length) {
                // Keep array size to a multiple of 6 plus 2
                int newsize = (numCoords - 2) * 2 + 2;
                float newCoords[] = new float[newsize];
                System.arraycopy(bezierCoords, 0, newCoords, 0, numCoords);
                bezierCoords = newCoords;
            }
            bezierCoords[numCoords++] = ctrlx1;
            bezierCoords[numCoords++] = ctrly1;
            bezierCoords[numCoords++] = ctrlx2;
            bezierCoords[numCoords++] = ctrly2;
            bezierCoords[numCoords++] = x1;
            bezierCoords[numCoords++] = y1;
        }

        public int getWindingRule() {
            return windingrule;
        }

        public int getNumCoords() {
            return numCoords;
        }

        public float getCoord(int i) {
            return bezierCoords[i];
        }

        public float[] getTvals() {
            if (myTvals != null) {
                return myTvals;
            }

            // assert(numCoords &gt;= 8);
            // assert(((numCoords - 2) % 6) == 0);
            float tvals[] = new float[(numCoords - 2) / 6 + 1];

            // First calculate total &quot;length&quot; of path
            // Length of each segment is averaged between
            // the length between the endpoints (a lower bound for a cubic)
            // and the length of the control polygon (an upper bound)
            float segx = bezierCoords[0];
            float segy = bezierCoords[1];
            float tlen = 0;
            int ci = 2;
            int ti = 0;
            while (ci &lt; numCoords) {
                float prevx, prevy, newx, newy;
                prevx = segx;
                prevy = segy;
                newx = bezierCoords[ci++];
                newy = bezierCoords[ci++];
                prevx -= newx;
                prevy -= newy;
                float len = (float) Math.sqrt(prevx * prevx + prevy * prevy);
                prevx = newx;
                prevy = newy;
                newx = bezierCoords[ci++];
                newy = bezierCoords[ci++];
                prevx -= newx;
                prevy -= newy;
                len += (float) Math.sqrt(prevx * prevx + prevy * prevy);
                prevx = newx;
                prevy = newy;
                newx = bezierCoords[ci++];
                newy = bezierCoords[ci++];
                prevx -= newx;
                prevy -= newy;
                len += (float) Math.sqrt(prevx * prevx + prevy * prevy);
                // len is now the total length of the control polygon
                segx -= newx;
                segy -= newy;
                len += (float) Math.sqrt(segx * segx + segy * segy);
                // len is now sum of linear length and control polygon length
                len /= 2;
                // len is now average of the two lengths

                /* If the result is zero length then we will have problems
                 * below trying to do the math and bookkeeping to split
                 * the segment or pair it against the segments in the
                 * other shape.  Since these lengths are just estimates
                 * to map the segments of the two shapes onto corresponding
                 * segments of &quot;approximately the same length&quot;, we will
                 * simply modify the length of this segment to be at least
                 * a minimum value and it will simply grow from zero or
                 * near zero length to a non-trivial size as it morphs.
                 */
                if (len &lt; MIN_LEN) {
                    len = MIN_LEN;
                }
                tlen += len;
                tvals[ti++] = tlen;
                segx = newx;
                segy = newy;
            }

            // Now set tvals for each segment to its proportional
            // part of the length
            float prevt = tvals[0];
            tvals[0] = 0;
            for (ti = 1; ti &lt; tvals.length - 1; ti++) {
                float nextt = tvals[ti];
                tvals[ti] = prevt / tlen;
                prevt = nextt;
            }
            tvals[ti] = 1;
            return (myTvals = tvals);
        }

        public void setTvals(float newTvals[]) {
            float oldCoords[] = bezierCoords;
            float newCoords[] = new float[2 + (newTvals.length - 1) * 6];
            float oldTvals[] = getTvals();
            int oldci = 0;
            float x0, xc0, xc1, x1;
            float y0, yc0, yc1, y1;
            x0 = xc0 = xc1 = x1 = oldCoords[oldci++];
            y0 = yc0 = yc1 = y1 = oldCoords[oldci++];
            int newci = 0;
            newCoords[newci++] = x0;
            newCoords[newci++] = y0;
            float t0 = 0;
            float t1 = 0;
            int oldti = 1;
            int newti = 1;
            while (newti &lt; newTvals.length) {
                if (t0 &gt;= t1) {
                    x0 = x1;
                    y0 = y1;
                    xc0 = oldCoords[oldci++];
                    yc0 = oldCoords[oldci++];
                    xc1 = oldCoords[oldci++];
                    yc1 = oldCoords[oldci++];
                    x1 = oldCoords[oldci++];
                    y1 = oldCoords[oldci++];
                    t1 = oldTvals[oldti++];
                }
                float nt = newTvals[newti++];
                // assert(nt &gt; t0);
                if (nt &lt; t1) {
                    // Make nt proportional to [t0 =&gt; t1] range
                    float relt = (nt - t0) / (t1 - t0);
                    newCoords[newci++] = x0 = interp(x0, xc0, relt);
                    newCoords[newci++] = y0 = interp(y0, yc0, relt);
                    xc0 = interp(xc0, xc1, relt);
                    yc0 = interp(yc0, yc1, relt);
                    xc1 = interp(xc1, x1, relt);
                    yc1 = interp(yc1, y1, relt);
                    newCoords[newci++] = x0 = interp(x0, xc0, relt);
                    newCoords[newci++] = y0 = interp(y0, yc0, relt);
                    xc0 = interp(xc0, xc1, relt);
                    yc0 = interp(yc0, yc1, relt);
                    newCoords[newci++] = x0 = interp(x0, xc0, relt);
                    newCoords[newci++] = y0 = interp(y0, yc0, relt);
                } else {
                    newCoords[newci++] = xc0;
                    newCoords[newci++] = yc0;
                    newCoords[newci++] = xc1;
                    newCoords[newci++] = yc1;
                    newCoords[newci++] = x1;
                    newCoords[newci++] = y1;
                }
                t0 = nt;
            }
            bezierCoords = newCoords;
            numCoords = newCoords.length;
            myTvals = newTvals;
        }
    }

    private static class MorphedShape extends Shape {
        Geometry geom0;
        Geometry geom1;
        float t;

        MorphedShape(Geometry geom0, Geometry geom1, float t) {
            this.geom0 = geom0;
            this.geom1 = geom1;
            this.t = t;
        }

        public Rectangle getRectangle() {
            return new Rectangle(getBounds());
        }

        public RectBounds getBounds() {
            int n = geom0.getNumCoords();
            float xmin, ymin, xmax, ymax;
            xmin = xmax = interp(geom0.getCoord(0), geom1.getCoord(0), t);
            ymin = ymax = interp(geom0.getCoord(1), geom1.getCoord(1), t);
            for (int i = 2; i &lt; n; i += 2) {
                float x = interp(geom0.getCoord(i), geom1.getCoord(i), t);
                float y = interp(geom0.getCoord(i+1), geom1.getCoord(i+1), t);
                if (xmin &gt; x) {
                    xmin = x;
                }
                if (ymin &gt; y) {
                    ymin = y;
                }
                if (xmax &lt; x) {
                    xmax = x;
                }
                if (ymax &lt; y) {
                    ymax = y;
                }
            }
            return new RectBounds(xmin, ymin, xmax, ymax);
        }

        public boolean contains(float x, float y) {
            return Path2D.contains(getPathIterator(null), x, y);
        }

        public boolean intersects(float x, float y, float w, float h) {
            return Path2D.intersects(getPathIterator(null), x, y, w, h);
        }

        public boolean contains(float x, float y, float width, float height) {
            return Path2D.contains(getPathIterator(null), x, y, width, height);
        }

        public PathIterator getPathIterator(BaseTransform at) {
            return new Iterator(at, geom0, geom1, t);
        }

        public PathIterator getPathIterator(BaseTransform at, float flatness) {
            return new FlatteningPathIterator(getPathIterator(at), flatness);
        }

        public Shape copy() {
            return new Path2D(this);
        }
    }

    private static class Iterator implements PathIterator {
        BaseTransform at;
        Geometry g0;
        Geometry g1;
        float t;
        int cindex;

        public Iterator(BaseTransform at,
                        Geometry g0, Geometry g1,
                        float t) {
            this.at = at;
            this.g0 = g0;
            this.g1 = g1;
            this.t = t;
        }

        /**
         * @{inheritDoc}
         */
        public int getWindingRule() {
            return (t &lt; 0.5 ? g0.getWindingRule() : g1.getWindingRule());
        }

        /**
         * @{inheritDoc}
         */
        public boolean isDone() {
            return (cindex &gt; g0.getNumCoords());
        }

<A NAME="41"></A>        /**
         * @{inheritDoc}
         */
        public void next() <FONT color="#f87a17"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#41',2,'match31-top.html#41',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
            if (cindex == 0) {
                cindex = 2;
            } else {
                cindex += 6;
            }
        }

        /**
         * @{inheritDoc}
         */
        public int currentSegment(float coords[]) {</B></FONT>
            int type;
            int n;
            if (cindex == 0) {
                type = SEG_MOVETO;
                n = 2;
            } else if (cindex &gt;= g0.getNumCoords()) {
                type = SEG_CLOSE;
                n = 0;
            } else {
                type = SEG_CUBICTO;
                n = 6;
            }
            if (n &gt; 0) {
                for (int i = 0; i &lt; n; i++) {
                    coords[i] = (float) interp(g0.getCoord(cindex + i),
                                               g1.getCoord(cindex + i),
                                               t);
                }
                if (at != null) {
                    at.transform(coords, 0, coords, 0, n / 2);
                }
            }
            return type;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/stage/WindowHelper.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.stage;

import com.sun.javafx.tk.TKStage;
import com.sun.javafx.util.Utils;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.stage.Screen;
import javafx.stage.Window;

import java.security.AccessControlContext;

/**
 * Used to access internal window methods.
 */
public class WindowHelper {
    private static final WindowHelper theInstance;
    private static WindowAccessor windowAccessor;

    static {
        theInstance = new WindowHelper();
        Utils.forceInit(Window.class);
    }

    protected WindowHelper() {
    }

    private static WindowHelper getInstance() {
        return theInstance;
    }

    public static void initHelper(Window window) {
        setHelper(window, getInstance());
    }

    private static WindowHelper getHelper(Window window) {
        return windowAccessor.getHelper(window);
<A NAME="20"></A>    }

    protected static void setHelper(Window window, WindowHelper windowHelper) {
        <FONT color="#d4a017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#20',2,'match31-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>windowAccessor.setHelper(window, windowHelper);
    }

    /*
     * Static helper methods for cases where the implementation is done in an
     * instance method that is overridden by subclasses.
     * These methods exist in the base class only.
     */
    public static void visibleChanging(Window window, boolean visible) {
        getHelper(window).visibleChangingImpl(window, visible);
    }

    public static void visibleChanged(Window window, boolean visible) {
        getHelper(window).visibleChangedImpl(window, visible);
    }

    /*
     * Methods that will be overridden by subclasses
     */
    protected void visibleChangingImpl(Window window, boolean visible</B></FONT>) {
        windowAccessor.doVisibleChanging(window, visible);
    }

    protected void visibleChangedImpl(Window window, boolean visible) {
        windowAccessor.doVisibleChanged(window, visible);
    }

    /*
     * Methods used by Window (base) class only
     */

    public static TKStage getPeer(Window window) {
        return windowAccessor.getPeer(window);
    }

    public static void setPeer(Window window, TKStage peer) {
        windowAccessor.setPeer(window, peer);
    }

    public static WindowPeerListener getPeerListener(Window window) {
        return windowAccessor.getPeerListener(window);
    }

    public static void setPeerListener(Window window, WindowPeerListener peerListener) {
        windowAccessor.setPeerListener(window, peerListener);
    }

    public static void setFocused(Window window, boolean value) {
        windowAccessor.setFocused(window, value);
    }

    public static void notifyLocationChanged(final Window window,
                                             final double x,
                                             final double y) {
        windowAccessor.notifyLocationChanged(window, x, y);
    }

    public static void notifySizeChanged(final Window window,
                                         final double width,
                                         final double height) {
        windowAccessor.notifySizeChanged(window, width, height);
    }

    public static void notifyScaleChanged(final Window window,
                                          final double newOutputScaleX,
                                          final double newOutputScaleY) {
        windowAccessor.notifyScaleChanged(window, newOutputScaleX, newOutputScaleY);
    }

    static AccessControlContext getAccessControlContext(Window window) {
        return windowAccessor.getAccessControlContext(window);
    }

    public static void setWindowAccessor(final WindowAccessor newAccessor) {
        if (windowAccessor != null) {
            throw new IllegalStateException();
        }

        windowAccessor = newAccessor;
    }

    public static WindowAccessor getWindowAccessor() {
        return windowAccessor;
    }

    public interface WindowAccessor {
        WindowHelper getHelper(Window window);
        void setHelper(Window window, WindowHelper windowHelper);
        void doVisibleChanging(Window window, boolean visible);
        void doVisibleChanged(Window window, boolean visible);
        TKStage getPeer(Window window);
        void setPeer(Window window, TKStage peer);
        WindowPeerListener getPeerListener(Window window);
        void setPeerListener(Window window, WindowPeerListener peerListener);
        void setFocused(Window window, boolean value);
        void notifyLocationChanged(Window window, double x, double y);

        void notifySizeChanged(Window window, double width, double height);

        void notifyScreenChanged(Window window, Object from, Object to);

        float getPlatformScaleX(Window window);
        float getPlatformScaleY(Window window);

        void notifyScaleChanged(Window window, double newOutputScaleX, double newOutputScaleY);

        ReadOnlyObjectProperty&lt;Screen&gt; screenProperty(Window window);

        AccessControlContext getAccessControlContext(Window window);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/openpisces/Stroker.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.openpisces;

import com.sun.javafx.geom.PathConsumer2D;
import java.util.Arrays;
import java.util.Iterator;

// TODO: some of the arithmetic here is too verbose and prone to hard to
// debug typos. We should consider making a small Point/Vector class that
// has methods like plus(Point), minus(Point), dot(Point), cross(Point)and such
// (RT-26922)
public final class Stroker implements PathConsumer2D {

    private static final int MOVE_TO = 0;
    private static final int DRAWING_OP_TO = 1; // ie. curve, line, or quad
    private static final int CLOSE = 2;

    /**
     * Constant value for join style.
     */
    public static final int JOIN_MITER = 0;

    /**
     * Constant value for join style.
     */
    public static final int JOIN_ROUND = 1;

    /**
     * Constant value for join style.
     */
    public static final int JOIN_BEVEL = 2;

    /**
     * Constant value for end cap style.
     */
    public static final int CAP_BUTT = 0;

    /**
     * Constant value for end cap style.
     */
    public static final int CAP_ROUND = 1;

    /**
     * Constant value for end cap style.
     */
    public static final int CAP_SQUARE = 2;

    private PathConsumer2D out;

    private int capStyle;
    private int joinStyle;

    private float lineWidth2;

    private final float[][] offset = new float[3][2];
    private final float[] miter = new float[2];
    private float miterLimitSq;

    private int prev;

    // The starting point of the path, and the slope there.
    private float sx0, sy0, sdx, sdy;
    // the current point and the slope there.
    private float cx0, cy0, cdx, cdy; // c stands for current
    // vectors that when added to (sx0,sy0) and (cx0,cy0) respectively yield the
    // first and last points on the left parallel path. Since this path is
    // parallel, it's slope at any point is parallel to the slope of the
    // original path (thought they may have different directions), so these
    // could be computed from sdx,sdy and cdx,cdy (and vice versa), but that
    // would be error prone and hard to read, so we keep these anyway.
    private float smx, smy, cmx, cmy;

    private final PolyStack reverse = new PolyStack();

    /**
     * Constructs a &lt;code&gt;Stroker&lt;/code&gt;.
     *
     * @param pc2d an output &lt;code&gt;PathConsumer2D&lt;/code&gt;.
     * @param lineWidth the desired line width in pixels
     * @param capStyle the desired end cap style, one of
     * &lt;code&gt;CAP_BUTT&lt;/code&gt;, &lt;code&gt;CAP_ROUND&lt;/code&gt; or
     * &lt;code&gt;CAP_SQUARE&lt;/code&gt;.
     * @param joinStyle the desired line join style, one of
     * &lt;code&gt;JOIN_MITER&lt;/code&gt;, &lt;code&gt;JOIN_ROUND&lt;/code&gt; or
     * &lt;code&gt;JOIN_BEVEL&lt;/code&gt;.
     * @param miterLimit the desired miter limit
     */
    public Stroker(PathConsumer2D pc2d,
                   float lineWidth,
                   int capStyle,
                   int joinStyle,
                   float miterLimit)
    {
        this(pc2d);

        reset(lineWidth, capStyle, joinStyle, miterLimit);
    }

    public Stroker(PathConsumer2D pc2d) {
        setConsumer(pc2d);
    }

    public void setConsumer(PathConsumer2D pc2d) {
        this.out = pc2d;
    }

    public void reset(float lineWidth, int capStyle, int joinStyle,
                      float miterLimit) {
        this.lineWidth2 = lineWidth / 2;
        this.capStyle = capStyle;
        this.joinStyle = joinStyle;

        float limit = miterLimit * lineWidth2;
        this.miterLimitSq = limit*limit;

        this.prev = CLOSE;
    }

    private static void computeOffset(final float lx, final float ly,
                                      final float w, final float[] m)
    {
        final float len = (float)Math.sqrt(lx*lx + ly*ly);
        if (len == 0) {
            m[0] = m[1] = 0;
        } else {
            m[0] = (ly * w)/len;
            m[1] = -(lx * w)/len;
        }
    }

    // Returns true if the vectors (dx1, dy1) and (dx2, dy2) are
    // clockwise (if dx1,dy1 needs to be rotated clockwise to close
    // the smallest angle between it and dx2,dy2).
    // This is equivalent to detecting whether a point q is on the right side
    // of a line passing through points p1, p2 where p2 = p1+(dx1,dy1) and
    // q = p2+(dx2,dy2), which is the same as saying p1, p2, q are in a
    // clockwise order.
    // NOTE: &quot;clockwise&quot; here assumes coordinates with 0,0 at the bottom left.
    private static boolean isCW(final float dx1, final float dy1,
                                final float dx2, final float dy2)
    {
        return dx1 * dy2 &lt;= dy1 * dx2;
    }

    // pisces used to use fixed point arithmetic with 16 decimal digits. I
    // didn't want to change the values of the constant below when I converted
    // it to floating point, so that's why the divisions by 2^16 are there.
    private static final float ROUND_JOIN_THRESHOLD = 1000/65536f;

    private void drawRoundJoin(float x, float y,
                               float omx, float omy, float mx, float my,
                               boolean rev,
                               float threshold)
    {
        if ((omx == 0 &amp;&amp; omy == 0) || (mx == 0 &amp;&amp; my == 0)) {
            return;
        }

        float domx = omx - mx;
        float domy = omy - my;
        float len = domx*domx + domy*domy;
        if (len &lt; threshold) {
            return;
        }

        if (rev) {
            omx = -omx;
            omy = -omy;
            mx = -mx;
            my = -my;
        }
        drawRoundJoin(x, y, omx, omy, mx, my, rev);
    }

    private void drawRoundJoin(float cx, float cy,
                               float omx, float omy,
                               float mx, float my,
                               boolean rev)
    {
        // The sign of the dot product of mx,my and omx,omy is equal to the
        // the sign of the cosine of ext
        // (ext is the angle between omx,omy and mx,my).
        double cosext = omx * mx + omy * my;
        // If it is &gt;=0, we know that abs(ext) is &lt;= 90 degrees, so we only
        // need 1 curve to approximate the circle section that joins omx,omy
        // and mx,my.
        final int numCurves = cosext &gt;= 0 ? 1 : 2;

        switch (numCurves) {
        case 1:
            drawBezApproxForArc(cx, cy, omx, omy, mx, my, rev);
            break;
        case 2:
            // we need to split the arc into 2 arcs spanning the same angle.
            // The point we want will be one of the 2 intersections of the
            // perpendicular bisector of the chord (omx,omy)-&gt;(mx,my) and the
            // circle. We could find this by scaling the vector
            // (omx+mx, omy+my)/2 so that it has length=lineWidth2 (and thus lies
            // on the circle), but that can have numerical problems when the angle
            // between omx,omy and mx,my is close to 180 degrees. So we compute a
            // normal of (omx,omy)-(mx,my). This will be the direction of the
            // perpendicular bisector. To get one of the intersections, we just scale
            // this vector that its length is lineWidth2 (this works because the
            // perpendicular bisector goes through the origin). This scaling doesn't
            // have numerical problems because we know that lineWidth2 divided by
            // this normal's length is at least 0.5 and at most sqrt(2)/2 (because
            // we know the angle of the arc is &gt; 90 degrees).
            float nx = my - omy, ny = omx - mx;
            float nlen = (float)Math.sqrt(nx*nx + ny*ny);
            float scale = lineWidth2/nlen;
            float mmx = nx * scale, mmy = ny * scale;

            // if (isCW(omx, omy, mx, my) != isCW(mmx, mmy, mx, my)) then we've
            // computed the wrong intersection so we get the other one.
            // The test above is equivalent to if (rev).
            if (rev) {
                mmx = -mmx;
                mmy = -mmy;
            }
            drawBezApproxForArc(cx, cy, omx, omy, mmx, mmy, rev);
            drawBezApproxForArc(cx, cy, mmx, mmy, mx, my, rev);
            break;
        }
    }

    // the input arc defined by omx,omy and mx,my must span &lt;= 90 degrees.
    private void drawBezApproxForArc(final float cx, final float cy,
                                     final float omx, final float omy,
                                     final float mx, final float my,
                                     boolean rev)
    {
        float cosext2 = (omx * mx + omy * my) / (2 * lineWidth2 * lineWidth2);
        // cv is the length of P1-P0 and P2-P3 divided by the radius of the arc
        // (so, cv assumes the arc has radius 1). P0, P1, P2, P3 are the points that
        // define the bezier curve we're computing.
        // It is computed using the constraints that P1-P0 and P3-P2 are parallel
        // to the arc tangents at the endpoints, and that |P1-P0|=|P3-P2|.
        float cv = (float)((4.0 / 3.0) * Math.sqrt(0.5-cosext2) /
                           (1.0 + Math.sqrt(cosext2+0.5)));
        // if clockwise, we need to negate cv.
        if (rev) { // rev is equivalent to isCW(omx, omy, mx, my)
            cv = -cv;
        }
        final float x1 = cx + omx;
        final float y1 = cy + omy;
        final float x2 = x1 - cv * omy;
        final float y2 = y1 + cv * omx;

        final float x4 = cx + mx;
        final float y4 = cy + my;
        final float x3 = x4 + cv * my;
        final float y3 = y4 - cv * mx;

        emitCurveTo(x1, y1, x2, y2, x3, y3, x4, y4, rev);
    }

    private void drawRoundCap(float cx, float cy, float mx, float my) {
        final float C = 0.5522847498307933f;
        // the first and second arguments of the following two calls
        // are really will be ignored by emitCurveTo (because of the false),
        // but we put them in anyway, as opposed to just giving it 4 zeroes,
        // because it's just 4 additions and it's not good to rely on this
        // sort of assumption (right now it's true, but that may change).
        emitCurveTo(cx+mx,      cy+my,
                    cx+mx-C*my, cy+my+C*mx,
                    cx-my+C*mx, cy+mx+C*my,
                    cx-my,      cy+mx,
                    false);
        emitCurveTo(cx-my,      cy+mx,
                    cx-my-C*mx, cy+mx-C*my,
                    cx-mx-C*my, cy-my+C*mx,
                    cx-mx,      cy-my,
                    false);
    }

    // Return the intersection point of the lines (x0, y0) -&gt; (x1, y1)
    // and (x0p, y0p) -&gt; (x1p, y1p) in m[0] and m[1]
    private void computeMiter(final float x0, final float y0,
                              final float x1, final float y1,
                              final float x0p, final float y0p,
                              final float x1p, final float y1p,
                              final float[] m, int off)
    {
        float x10 = x1 - x0;
        float y10 = y1 - y0;
        float x10p = x1p - x0p;
        float y10p = y1p - y0p;

        // if this is 0, the lines are parallel. If they go in the
        // same direction, there is no intersection so m[off] and
        // m[off+1] will contain infinity, so no miter will be drawn.
        // If they go in the same direction that means that the start of the
        // current segment and the end of the previous segment have the same
        // tangent, in which case this method won't even be involved in
        // miter drawing because it won't be called by drawMiter (because
        // (mx == omx &amp;&amp; my == omy) will be true, and drawMiter will return
        // immediately).
        float den = x10*y10p - x10p*y10;
        float t = x10p*(y0-y0p) - y10p*(x0-x0p);
        t /= den;
        m[off++] = x0 + t*x10;
        m[off] = y0 + t*y10;
    }

    // Return the intersection point of the lines (x0, y0) -&gt; (x1, y1)
    // and (x0p, y0p) -&gt; (x1p, y1p) in m[0] and m[1]
    private void safecomputeMiter(final float x0, final float y0,
                                  final float x1, final float y1,
                                  final float x0p, final float y0p,
                                  final float x1p, final float y1p,
                                  final float[] m, int off)
    {
        float x10 = x1 - x0;
        float y10 = y1 - y0;
        float x10p = x1p - x0p;
        float y10p = y1p - y0p;

        // if this is 0, the lines are parallel. If they go in the
        // same direction, there is no intersection so m[off] and
        // m[off+1] will contain infinity, so no miter will be drawn.
        // If they go in the same direction that means that the start of the
        // current segment and the end of the previous segment have the same
        // tangent, in which case this method won't even be involved in
        // miter drawing because it won't be called by drawMiter (because
        // (mx == omx &amp;&amp; my == omy) will be true, and drawMiter will return
        // immediately).
        float den = x10*y10p - x10p*y10;
        if (den == 0) {
            m[off++] = (x0 + x0p) / 2.0f;
            m[off] = (y0 + y0p) / 2.0f;
            return;
        }
        float t = x10p*(y0-y0p) - y10p*(x0-x0p);
        t /= den;
        m[off++] = x0 + t*x10;
        m[off] = y0 + t*y10;
    }

    private void drawMiter(final float pdx, final float pdy,
                           final float x0, final float y0,
                           final float dx, final float dy,
                           float omx, float omy, float mx, float my,
                           boolean rev)
    {
        if ((mx == omx &amp;&amp; my == omy) ||
            (pdx == 0 &amp;&amp; pdy == 0) ||
            (dx == 0 &amp;&amp; dy == 0)) {
            return;
        }

        if (rev) {
            omx = -omx;
            omy = -omy;
            mx = -mx;
            my = -my;
        }

        computeMiter((x0 - pdx) + omx, (y0 - pdy) + omy, x0 + omx, y0 + omy,
                     (dx + x0) + mx, (dy + y0) + my, x0 + mx, y0 + my,
                     miter, 0);

        float lenSq = (miter[0]-x0)*(miter[0]-x0) + (miter[1]-y0)*(miter[1]-y0);

        if (lenSq &lt; miterLimitSq) {
            emitLineTo(miter[0], miter[1], rev);
        }
    }

    public void moveTo(float x0, float y0) {
        if (prev == DRAWING_OP_TO) {
            finish();
        }
        this.sx0 = this.cx0 = x0;
        this.sy0 = this.cy0 = y0;
        this.cdx = this.sdx = 1;
        this.cdy = this.sdy = 0;
        this.prev = MOVE_TO;
    }

    public void lineTo(float x1, float y1) {
        float dx = x1 - cx0;
        float dy = y1 - cy0;
        if (dx == 0f &amp;&amp; dy == 0f) {
            dx = 1;
        }
        computeOffset(dx, dy, lineWidth2, offset[0]);
        float mx = offset[0][0];
        float my = offset[0][1];

        drawJoin(cdx, cdy, cx0, cy0, dx, dy, cmx, cmy, mx, my);

        emitLineTo(cx0 + mx, cy0 + my);
        emitLineTo(x1 + mx, y1 + my);

        emitLineTo(cx0 - mx, cy0 - my, true);
        emitLineTo(x1 - mx, y1 - my, true);

        this.cmx = mx;
        this.cmy = my;
        this.cdx = dx;
        this.cdy = dy;
        this.cx0 = x1;
        this.cy0 = y1;
        this.prev = DRAWING_OP_TO;
    }

    public void closePath() {
        if (prev != DRAWING_OP_TO) {
            if (prev == CLOSE) {
                return;
            }
            emitMoveTo(cx0, cy0 - lineWidth2);
            this.cmx = this.smx = 0;
            this.cmy = this.smy = -lineWidth2;
            this.cdx = this.sdx = 1;
            this.cdy = this.sdy = 0;
            finish();
            return;
        }

        if (cx0 != sx0 || cy0 != sy0) {
            lineTo(sx0, sy0);
        }

        drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy);

        emitLineTo(sx0 + smx, sy0 + smy);

        emitMoveTo(sx0 - smx, sy0 - smy);
        emitReverse();

        this.prev = CLOSE;
        emitClose();
    }

    private void emitReverse() {
        while(!reverse.isEmpty()) {
            reverse.pop(out);
        }
    }

    public void pathDone() {
        if (prev == DRAWING_OP_TO) {
            finish();
        }

        out.pathDone();
        // this shouldn't matter since this object won't be used
        // after the call to this method.
        this.prev = CLOSE;
    }

    private void finish() {
        if (capStyle == CAP_ROUND) {
            drawRoundCap(cx0, cy0, cmx, cmy);
        } else if (capStyle == CAP_SQUARE) {
            emitLineTo(cx0 - cmy + cmx, cy0 + cmx + cmy);
            emitLineTo(cx0 - cmy - cmx, cy0 + cmx - cmy);
        }

        emitReverse();

        if (capStyle == CAP_ROUND) {
            drawRoundCap(sx0, sy0, -smx, -smy);
        } else if (capStyle == CAP_SQUARE) {
            emitLineTo(sx0 + smy - smx, sy0 - smx - smy);
            emitLineTo(sx0 + smy + smx, sy0 - smx + smy);
        }

        emitClose();
    }

    private void emitMoveTo(final float x0, final float y0) {
        out.moveTo(x0, y0);
    }

    private void emitLineTo(final float x1, final float y1) {
        out.lineTo(x1, y1);
    }

    private void emitLineTo(final float x1, final float y1,
                            final boolean rev)
    {
        if (rev) {
            reverse.pushLine(x1, y1);
        } else {
            emitLineTo(x1, y1);
        }
    }

    private void emitQuadTo(final float x0, final float y0,
                            final float x1, final float y1,
                            final float x2, final float y2, final boolean rev)
    {
        if (rev) {
            reverse.pushQuad(x0, y0, x1, y1);
        } else {
            out.quadTo(x1, y1, x2, y2);
        }
    }

    private void emitCurveTo(final float x0, final float y0,
                             final float x1, final float y1,
                             final float x2, final float y2,
                             final float x3, final float y3, final boolean rev)
    {
        if (rev) {
            reverse.pushCubic(x0, y0, x1, y1, x2, y2);
        } else {
            out.curveTo(x1, y1, x2, y2, x3, y3);
        }
    }

    private void emitClose() {
        out.closePath();
    }

    private void drawJoin(float pdx, float pdy,
                          float x0, float y0,
                          float dx, float dy,
                          float omx, float omy,
                          float mx, float my)
    {
        if (prev != DRAWING_OP_TO) {
            emitMoveTo(x0 + mx, y0 + my);
            this.sdx = dx;
            this.sdy = dy;
            this.smx = mx;
            this.smy = my;
        } else {
            boolean cw = isCW(pdx, pdy, dx, dy);
            if (joinStyle == JOIN_MITER) {
                drawMiter(pdx, pdy, x0, y0, dx, dy, omx, omy, mx, my, cw);
            } else if (joinStyle == JOIN_ROUND) {
                drawRoundJoin(x0, y0,
                              omx, omy,
                              mx, my, cw,
                              ROUND_JOIN_THRESHOLD);
            }
            emitLineTo(x0, y0, !cw);
        }
        prev = DRAWING_OP_TO;
    }

    private static boolean within(final float x1, final float y1,
                                  final float x2, final float y2,
                                  final float ERR)
    {
        assert ERR &gt; 0 : &quot;&quot;;
        // compare taxicab distance. ERR will always be small, so using
        // true distance won't give much benefit
        return (Helpers.within(x1, x2, ERR) &amp;&amp;  // we want to avoid calling Math.abs
                Helpers.within(y1, y2, ERR)); // this is just as good.
    }

    private void getLineOffsets(float x1, float y1,
                                float x2, float y2,
                                float[] left, float[] right) {
        computeOffset(x2 - x1, y2 - y1, lineWidth2, offset[0]);
        left[0] = x1 + offset[0][0];
        left[1] = y1 + offset[0][1];
        left[2] = x2 + offset[0][0];
        left[3] = y2 + offset[0][1];
        right[0] = x1 - offset[0][0];
        right[1] = y1 - offset[0][1];
        right[2] = x2 - offset[0][0];
        right[3] = y2 - offset[0][1];
    }

    private int computeOffsetCubic(float[] pts, final int off,
                                   float[] leftOff, float[] rightOff)
    {
        // if p1=p2 or p3=p4 it means that the derivative at the endpoint
        // vanishes, which creates problems with computeOffset. Usually
        // this happens when this stroker object is trying to winden
        // a curve with a cusp. What happens is that curveTo splits
        // the input curve at the cusp, and passes it to this function.
        // because of inaccuracies in the splitting, we consider points
        // equal if they're very close to each other.
        final float x1 = pts[off + 0], y1 = pts[off + 1];
        final float x2 = pts[off + 2], y2 = pts[off + 3];
        final float x3 = pts[off + 4], y3 = pts[off + 5];
        final float x4 = pts[off + 6], y4 = pts[off + 7];

        float dx4 = x4 - x3;
        float dy4 = y4 - y3;
        float dx1 = x2 - x1;
        float dy1 = y2 - y1;

        // if p1 == p2 &amp;&amp; p3 == p4: draw line from p1-&gt;p4, unless p1 == p4,
        // in which case ignore if p1 == p2
        final boolean p1eqp2 = within(x1,y1,x2,y2, 6 * Math.ulp(y2));
        final boolean p3eqp4 = within(x3,y3,x4,y4, 6 * Math.ulp(y4));
<A NAME="32"></A>        if (p1eqp2 &amp;&amp; p3eqp4) {
            getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);
            return 4;
        <FONT color="#82cafa"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#32',2,'match31-top.html#32',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>} else if (p1eqp2) {
            dx1 = x3 - x1;
            dy1 = y3 - y1;
        } else if (p3eqp4) {
            d</B></FONT>x4 = x4 - x2;
            dy4 = y4 - y2;
        }

        // if p2-p1 and p4-p3 are parallel, that must mean this curve is a line
        float dotsq = (dx1 * dx4 + dy1 * dy4);
        dotsq = dotsq * dotsq;
        float l1sq = dx1 * dx1 + dy1 * dy1, l4sq = dx4 * dx4 + dy4 * dy4;
        if (Helpers.within(dotsq, l1sq * l4sq, 4 * Math.ulp(dotsq))) {
            getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);
            return 4;
        }

//      What we're trying to do in this function is to approximate an ideal
//      offset curve (call it I) of the input curve B using a bezier curve Bp.
//      The constraints I use to get the equations are:
//
//      1. The computed curve Bp should go through I(0) and I(1). These are
//      x1p, y1p, x4p, y4p, which are p1p and p4p. We still need to find
//      4 variables: the x and y components of p2p and p3p (i.e. x2p, y2p, x3p, y3p).
//
//      2. Bp should have slope equal in absolute value to I at the endpoints. So,
//      (by the way, the operator || in the comments below means &quot;aligned with&quot;.
//      It is defined on vectors, so when we say I'(0) || Bp'(0) we mean that
//      vectors I'(0) and Bp'(0) are aligned, which is the same as saying
//      that the tangent lines of I and Bp at 0 are parallel. Mathematically
//      this means (I'(t) || Bp'(t)) &lt;==&gt; (I'(t) = c * Bp'(t)) where c is some
//      nonzero constant.)
//      I'(0) || Bp'(0) and I'(1) || Bp'(1). Obviously, I'(0) || B'(0) and
//      I'(1) || B'(1); therefore, Bp'(0) || B'(0) and Bp'(1) || B'(1).
//      We know that Bp'(0) || (p2p-p1p) and Bp'(1) || (p4p-p3p) and the same
//      is true for any bezier curve; therefore, we get the equations
//          (1) p2p = c1 * (p2-p1) + p1p
//          (2) p3p = c2 * (p4-p3) + p4p
//      We know p1p, p4p, p2, p1, p3, and p4; therefore, this reduces the number
//      of unknowns from 4 to 2 (i.e. just c1 and c2).
//      To eliminate these 2 unknowns we use the following constraint:
//
//      3. Bp(0.5) == I(0.5). Bp(0.5)=(x,y) and I(0.5)=(xi,yi), and I should note
//      that I(0.5) is *the only* reason for computing dxm,dym. This gives us
//          (3) Bp(0.5) = (p1p + 3 * (p2p + p3p) + p4p)/8, which is equivalent to
//          (4) p2p + p3p = (Bp(0.5)*8 - p1p - p4p) / 3
//      We can substitute (1) and (2) from above into (4) and we get:
//          (5) c1*(p2-p1) + c2*(p4-p3) = (Bp(0.5)*8 - p1p - p4p)/3 - p1p - p4p
//      which is equivalent to
//          (6) c1*(p2-p1) + c2*(p4-p3) = (4/3) * (Bp(0.5) * 2 - p1p - p4p)
//
//      The right side of this is a 2D vector, and we know I(0.5), which gives us
//      Bp(0.5), which gives us the value of the right side.
//      The left side is just a matrix vector multiplication in disguise. It is
//
//      [x2-x1, x4-x3][c1]
//      [y2-y1, y4-y3][c2]
//      which, is equal to
//      [dx1, dx4][c1]
//      [dy1, dy4][c2]
//      At this point we are left with a simple linear system and we solve it by
//      getting the inverse of the matrix above. Then we use [c1,c2] to compute
//      p2p and p3p.

        float x = 0.125f * (x1 + 3 * (x2 + x3) + x4);
        float y = 0.125f * (y1 + 3 * (y2 + y3) + y4);
        // (dxm,dym) is some tangent of B at t=0.5. This means it's equal to
        // c*B'(0.5) for some constant c.
        float dxm = x3 + x4 - x1 - x2, dym = y3 + y4 - y1 - y2;

        // this computes the offsets at t=0, 0.5, 1, using the property that
        // for any bezier curve the vectors p2-p1 and p4-p3 are parallel to
        // the (dx/dt, dy/dt) vectors at the endpoints.
        computeOffset(dx1, dy1, lineWidth2, offset[0]);
        computeOffset(dxm, dym, lineWidth2, offset[1]);
        computeOffset(dx4, dy4, lineWidth2, offset[2]);
        float x1p = x1 + offset[0][0]; // start
        float y1p = y1 + offset[0][1]; // point
        float xi  = x + offset[1][0]; // interpolation
        float yi  = y + offset[1][1]; // point
        float x4p = x4 + offset[2][0]; // end
        float y4p = y4 + offset[2][1]; // point

        float invdet43 = 4f / (3f * (dx1 * dy4 - dy1 * dx4));

        float two_pi_m_p1_m_p4x = 2*xi - x1p - x4p;
        float two_pi_m_p1_m_p4y = 2*yi - y1p - y4p;
        float c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);
        float c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);

        float x2p, y2p, x3p, y3p;
        x2p = x1p + c1*dx1;
        y2p = y1p + c1*dy1;
        x3p = x4p + c2*dx4;
        y3p = y4p + c2*dy4;

        leftOff[0] = x1p; leftOff[1] = y1p;
        leftOff[2] = x2p; leftOff[3] = y2p;
        leftOff[4] = x3p; leftOff[5] = y3p;
        leftOff[6] = x4p; leftOff[7] = y4p;

        x1p = x1 - offset[0][0]; y1p = y1 - offset[0][1];
        xi = xi - 2 * offset[1][0]; yi = yi - 2 * offset[1][1];
        x4p = x4 - offset[2][0]; y4p = y4 - offset[2][1];

        two_pi_m_p1_m_p4x = 2*xi - x1p - x4p;
        two_pi_m_p1_m_p4y = 2*yi - y1p - y4p;
        c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);
        c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);

        x2p = x1p + c1*dx1;
        y2p = y1p + c1*dy1;
        x3p = x4p + c2*dx4;
        y3p = y4p + c2*dy4;

        rightOff[0] = x1p; rightOff[1] = y1p;
        rightOff[2] = x2p; rightOff[3] = y2p;
        rightOff[4] = x3p; rightOff[5] = y3p;
        rightOff[6] = x4p; rightOff[7] = y4p;
        return 8;
    }

    // compute offset curves using bezier spline through t=0.5 (i.e.
    // ComputedCurve(0.5) == IdealParallelCurve(0.5))
    // return the kind of curve in the right and left arrays.
    private int computeOffsetQuad(float[] pts, final int off,
                                  float[] leftOff, float[] rightOff)
    {
        final float x1 = pts[off + 0], y1 = pts[off + 1];
        final float x2 = pts[off + 2], y2 = pts[off + 3];
        final float x3 = pts[off + 4], y3 = pts[off + 5];

        float dx3 = x3 - x2;
        float dy3 = y3 - y2;
        float dx1 = x2 - x1;
        float dy1 = y2 - y1;

        // if p1=p2 or p3=p4 it means that the derivative at the endpoint
        // vanishes, which creates problems with computeOffset. Usually
        // this happens when this stroker object is trying to winden
        // a curve with a cusp. What happens is that curveTo splits
        // the input curve at the cusp, and passes it to this function.
        // because of inaccuracies in the splitting, we consider points
        // equal if they're very close to each other.

        // if p1 == p2 &amp;&amp; p3 == p4: draw line from p1-&gt;p4, unless p1 == p4,
        // in which case ignore.
        final boolean p1eqp2 = within(x1,y1,x2,y2, 6 * Math.ulp(y2));
        final boolean p2eqp3 = within(x2,y2,x3,y3, 6 * Math.ulp(y3));
        if (p1eqp2 || p2eqp3) {
            getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);
            return 4;
        }

        // if p2-p1 and p4-p3 are parallel, that must mean this curve is a line
        float dotsq = (dx1 * dx3 + dy1 * dy3);
        dotsq = dotsq * dotsq;
        float l1sq = dx1 * dx1 + dy1 * dy1, l3sq = dx3 * dx3 + dy3 * dy3;
        if (Helpers.within(dotsq, l1sq * l3sq, 4 * Math.ulp(dotsq))) {
            getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);
            return 4;
        }

        // this computes the offsets at t=0, 0.5, 1, using the property that
        // for any bezier curve the vectors p2-p1 and p4-p3 are parallel to
        // the (dx/dt, dy/dt) vectors at the endpoints.
        computeOffset(dx1, dy1, lineWidth2, offset[0]);
        computeOffset(dx3, dy3, lineWidth2, offset[1]);
        float x1p = x1 + offset[0][0]; // start
        float y1p = y1 + offset[0][1]; // point
        float x3p = x3 + offset[1][0]; // end
        float y3p = y3 + offset[1][1]; // point

        safecomputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, leftOff, 2);
        leftOff[0] = x1p; leftOff[1] = y1p;
        leftOff[4] = x3p; leftOff[5] = y3p;
        x1p = x1 - offset[0][0]; y1p = y1 - offset[0][1];
        x3p = x3 - offset[1][0]; y3p = y3 - offset[1][1];
        safecomputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, rightOff, 2);
        rightOff[0] = x1p; rightOff[1] = y1p;
        rightOff[4] = x3p; rightOff[5] = y3p;
        return 6;
    }

    // This is where the curve to be processed is put. We give it
    // enough room to store 2 curves: one for the current subdivision, the
    // other for the rest of the curve.
    private float[] middle = new float[MAX_N_CURVES*8];
    private float[] lp = new float[8];
    private float[] rp = new float[8];
    private static final int MAX_N_CURVES = 11;
    private float[] subdivTs = new float[MAX_N_CURVES - 1];

    // If this class is compiled with ecj, then Hotspot crashes when OSR
    // compiling this function. See bugs 7004570 and 6675699
    // TODO: until those are fixed, we should work around that by
    // manually inlining this into curveTo and quadTo.
/******************************* WORKAROUND **********************************
    private void somethingTo(final int type) {
        // need these so we can update the state at the end of this method
        final float xf = middle[type-2], yf = middle[type-1];
        float dxs = middle[2] - middle[0];
        float dys = middle[3] - middle[1];
        float dxf = middle[type - 2] - middle[type - 4];
        float dyf = middle[type - 1] - middle[type - 3];
        switch(type) {
        case 6:
            if ((dxs == 0f &amp;&amp; dys == 0f) ||
                (dxf == 0f &amp;&amp; dyf == 0f)) {
               dxs = dxf = middle[4] - middle[0];
               dys = dyf = middle[5] - middle[1];
            }
            break;
        case 8:
            boolean p1eqp2 = (dxs == 0f &amp;&amp; dys == 0f);
            boolean p3eqp4 = (dxf == 0f &amp;&amp; dyf == 0f);
            if (p1eqp2) {
                dxs = middle[4] - middle[0];
                dys = middle[5] - middle[1];
                if (dxs == 0f &amp;&amp; dys == 0f) {
                    dxs = middle[6] - middle[0];
                    dys = middle[7] - middle[1];
                }
            }
            if (p3eqp4) {
                dxf = middle[6] - middle[2];
                dyf = middle[7] - middle[3];
                if (dxf == 0f &amp;&amp; dyf == 0f) {
                    dxf = middle[6] - middle[0];
                    dyf = middle[7] - middle[1];
                }
            }
        }
        if (dxs == 0f &amp;&amp; dys == 0f) {
            // this happens iff the &quot;curve&quot; is just a point
            lineTo(middle[0], middle[1]);
            return;
        }
        // if these vectors are too small, normalize them, to avoid future
        // precision problems.
        if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {
            float len = (float)Math.sqrt(dxs*dxs + dys*dys);
            dxs /= len;
            dys /= len;
        }
        if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {
            float len = (float)Math.sqrt(dxf*dxf + dyf*dyf);
            dxf /= len;
            dyf /= len;
        }

        computeOffset(dxs, dys, lineWidth2, offset[0]);
        final float mx = offset[0][0];
        final float my = offset[0][1];
        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);

        int nSplits = findSubdivPoints(middle, subdivTs, type, lineWidth2);

        int kind = 0;
        Iterator&lt;Integer&gt; it = Curve.breakPtsAtTs(middle, type, subdivTs, nSplits);
        while(it.hasNext()) {
            int curCurveOff = it.next();

            kind = 0;
            switch (type) {
            case 8:
                kind = computeOffsetCubic(middle, curCurveOff, lp, rp);
                break;
            case 6:
                kind = computeOffsetQuad(middle, curCurveOff, lp, rp);
                break;
            }
            if (kind != 0) {
                emitLineTo(lp[0], lp[1]);
                switch(kind) {
                case 8:
                    emitCurveTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], false);
                    emitCurveTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], true);
                    break;
                case 6:
                    emitQuadTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], false);
                    emitQuadTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], true);
                    break;
                case 4:
                    emitLineTo(lp[2], lp[3]);
                    emitLineTo(rp[0], rp[1], true);
                    break;
                }
                emitLineTo(rp[kind - 2], rp[kind - 1], true);
            }
        }

        this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
        this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
        this.cdx = dxf;
        this.cdy = dyf;
        this.cx0 = xf;
        this.cy0 = yf;
        this.prev = DRAWING_OP_TO;
    }
****************************** END WORKAROUND *******************************/

    // finds values of t where the curve in pts should be subdivided in order
    // to get good offset curves a distance of w away from the middle curve.
    // Stores the points in ts, and returns how many of them there were.
    private static Curve c = new Curve();
    private static int findSubdivPoints(float[] pts, float[] ts,
                                        final int type, final float w)
    {
        final float x12 = pts[2] - pts[0];
        final float y12 = pts[3] - pts[1];
        // if the curve is already parallel to either axis we gain nothing
        // from rotating it.
        if (y12 != 0f &amp;&amp; x12 != 0f) {
            // we rotate it so that the first vector in the control polygon is
            // parallel to the x-axis. This will ensure that rotated quarter
            // circles won't be subdivided.
            final float hypot = (float)Math.sqrt(x12 * x12 + y12 * y12);
            final float cos = x12 / hypot;
            final float sin = y12 / hypot;
            final float x1 = cos * pts[0] + sin * pts[1];
            final float y1 = cos * pts[1] - sin * pts[0];
            final float x2 = cos * pts[2] + sin * pts[3];
            final float y2 = cos * pts[3] - sin * pts[2];
            final float x3 = cos * pts[4] + sin * pts[5];
            final float y3 = cos * pts[5] - sin * pts[4];
            switch(type) {
            case 8:
                final float x4 = cos * pts[6] + sin * pts[7];
                final float y4 = cos * pts[7] - sin * pts[6];
                c.set(x1, y1, x2, y2, x3, y3, x4, y4);
                break;
            case 6:
                c.set(x1, y1, x2, y2, x3, y3);
                break;
            }
        } else {
            c.set(pts, type);
        }

        int ret = 0;
        // we subdivide at values of t such that the remaining rotated
        // curves are monotonic in x and y.
        ret += c.dxRoots(ts, ret);
        ret += c.dyRoots(ts, ret);
        // subdivide at inflection points.
        if (type == 8) {
            // quadratic curves can't have inflection points
            ret += c.infPoints(ts, ret);
        }

        // now we must subdivide at points where one of the offset curves will have
        // a cusp. This happens at ts where the radius of curvature is equal to w.
        ret += c.rootsOfROCMinusW(ts, ret, w, 0.0001f);

        ret = Helpers.filterOutNotInAB(ts, 0, ret, 0.0001f, 0.9999f);
        Helpers.isort(ts, 0, ret);
        return ret;
    }

    @Override public void curveTo(float x1, float y1,
                                  float x2, float y2,
                                  float x3, float y3)
    {
        middle[0] = cx0; middle[1] = cy0;
        middle[2] = x1;  middle[3] = y1;
        middle[4] = x2;  middle[5] = y2;
        middle[6] = x3;  middle[7] = y3;

        // inlined version of somethingTo(8);
        // See the TODO on somethingTo
        // (JDK-6675699)

        // need these so we can update the state at the end of this method
        final float xf = middle[6], yf = middle[7];
        float dxs = middle[2] - middle[0];
        float dys = middle[3] - middle[1];
        float dxf = middle[6] - middle[4];
        float dyf = middle[7] - middle[5];

        boolean p1eqp2 = (dxs == 0f &amp;&amp; dys == 0f);
        boolean p3eqp4 = (dxf == 0f &amp;&amp; dyf == 0f);
        if (p1eqp2) {
            dxs = middle[4] - middle[0];
            dys = middle[5] - middle[1];
            if (dxs == 0f &amp;&amp; dys == 0f) {
                dxs = middle[6] - middle[0];
                dys = middle[7] - middle[1];
            }
        }
        if (p3eqp4) {
            dxf = middle[6] - middle[2];
            dyf = middle[7] - middle[3];
            if (dxf == 0f &amp;&amp; dyf == 0f) {
                dxf = middle[6] - middle[0];
                dyf = middle[7] - middle[1];
            }
        }
        if (dxs == 0f &amp;&amp; dys == 0f) {
            // this happens iff the &quot;curve&quot; is just a point
            lineTo(middle[0], middle[1]);
            return;
        }

        // if these vectors are too small, normalize them, to avoid future
        // precision problems.
        if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {
            float len = (float)Math.sqrt(dxs*dxs + dys*dys);
            dxs /= len;
            dys /= len;
        }
        if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {
            float len = (float)Math.sqrt(dxf*dxf + dyf*dyf);
            dxf /= len;
            dyf /= len;
        }

        computeOffset(dxs, dys, lineWidth2, offset[0]);
        final float mx = offset[0][0];
        final float my = offset[0][1];
        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);

        int nSplits = findSubdivPoints(middle, subdivTs, 8, lineWidth2);
        float prevT = 0f;
        for (int i = 0; i &lt; nSplits; i++) {
            float t = subdivTs[i];
            Helpers.subdivideCubicAt((t - prevT) / (1 - prevT),
                                     middle, i*6,
                                     middle, i*6,
                                     middle, i*6+6);
            prevT = t;
        }

        int kind = 0;
        for (int i = 0; i &lt;= nSplits; i++) {
            kind = computeOffsetCubic(middle, i*6, lp, rp);
            if (kind != 0) {
                emitLineTo(lp[0], lp[1]);
                switch(kind) {
                case 8:
                    emitCurveTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], false);
                    emitCurveTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], true);
                    break;
                case 4:
                    emitLineTo(lp[2], lp[3]);
                    emitLineTo(rp[0], rp[1], true);
                    break;
                }
                emitLineTo(rp[kind - 2], rp[kind - 1], true);
            }
        }

        this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
        this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
        this.cdx = dxf;
        this.cdy = dyf;
        this.cx0 = xf;
        this.cy0 = yf;
        this.prev = DRAWING_OP_TO;
    }

    @Override public void quadTo(float x1, float y1, float x2, float y2) {
        middle[0] = cx0; middle[1] = cy0;
        middle[2] = x1;  middle[3] = y1;
        middle[4] = x2;  middle[5] = y2;

        // inlined version of somethingTo(8);
        // See the TODO on somethingTo
        // (JDK-6675699)

        // need these so we can update the state at the end of this method
        final float xf = middle[4], yf = middle[5];
        float dxs = middle[2] - middle[0];
        float dys = middle[3] - middle[1];
        float dxf = middle[4] - middle[2];
        float dyf = middle[5] - middle[3];
        if ((dxs == 0f &amp;&amp; dys == 0f) || (dxf == 0f &amp;&amp; dyf == 0f)) {
            dxs = dxf = middle[4] - middle[0];
            dys = dyf = middle[5] - middle[1];
        }
        if (dxs == 0f &amp;&amp; dys == 0f) {
            // this happens iff the &quot;curve&quot; is just a point
            lineTo(middle[0], middle[1]);
            return;
        }
        // if these vectors are too small, normalize them, to avoid future
        // precision problems.
        if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {
            float len = (float)Math.sqrt(dxs*dxs + dys*dys);
            dxs /= len;
            dys /= len;
        }
        if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {
            float len = (float)Math.sqrt(dxf*dxf + dyf*dyf);
            dxf /= len;
            dyf /= len;
        }

        computeOffset(dxs, dys, lineWidth2, offset[0]);
        final float mx = offset[0][0];
        final float my = offset[0][1];
        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);

        int nSplits = findSubdivPoints(middle, subdivTs, 6, lineWidth2);
        float prevt = 0f;
        for (int i = 0; i &lt; nSplits; i++) {
            float t = subdivTs[i];
            Helpers.subdivideQuadAt((t - prevt) / (1 - prevt),
                                    middle, i*4,
                                    middle, i*4,
                                    middle, i*4+4);
            prevt = t;
        }

        int kind = 0;
        for (int i = 0; i &lt;= nSplits; i++) {
            kind = computeOffsetQuad(middle, i*4, lp, rp);
            if (kind != 0) {
                emitLineTo(lp[0], lp[1]);
                switch(kind) {
                case 6:
                    emitQuadTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], false);
                    emitQuadTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], true);
                    break;
                case 4:
                    emitLineTo(lp[2], lp[3]);
                    emitLineTo(rp[0], rp[1], true);
                    break;
                }
                emitLineTo(rp[kind - 2], rp[kind - 1], true);
            }
        }

        this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
        this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
        this.cdx = dxf;
        this.cdy = dyf;
        this.cx0 = xf;
        this.cy0 = yf;
        this.prev = DRAWING_OP_TO;
    }

//    @Override public long getNativeConsumer() {
//        throw new InternalError(&quot;Stroker doesn't use a native consumer&quot;);
//    }

    // a stack of polynomial curves where each curve shares endpoints with
    // adjacent ones.
    private static final class PolyStack {
        float[] curves;
        int end;
        int[] curveTypes;
        int numCurves;

        private static final int INIT_SIZE = 50;

        PolyStack() {
            curves = new float[8 * INIT_SIZE];
            curveTypes = new int[INIT_SIZE];
            end = 0;
            numCurves = 0;
        }

        public boolean isEmpty() {
            return numCurves == 0;
        }

        private void ensureSpace(int n) {
            if (end + n &gt;= curves.length) {
                int newSize = (end + n) * 2;
                curves = Arrays.copyOf(curves, newSize);
            }
            if (numCurves &gt;= curveTypes.length) {
                int newSize = numCurves * 2;
                curveTypes = Arrays.copyOf(curveTypes, newSize);
            }
        }

        public void pushCubic(float x0, float y0,
                              float x1, float y1,
                              float x2, float y2)
        {
            ensureSpace(6);
            curveTypes[numCurves++] = 8;
            // assert(x0 == lastX &amp;&amp; y0 == lastY)

            // we reverse the coordinate order to make popping easier
            curves[end++] = x2;    curves[end++] = y2;
            curves[end++] = x1;    curves[end++] = y1;
            curves[end++] = x0;    curves[end++] = y0;
        }

        public void pushQuad(float x0, float y0,
                             float x1, float y1)
        {
            ensureSpace(4);
            curveTypes[numCurves++] = 6;
            // assert(x0 == lastX &amp;&amp; y0 == lastY)
            curves[end++] = x1;    curves[end++] = y1;
            curves[end++] = x0;    curves[end++] = y0;
        }

        public void pushLine(float x, float y) {
            ensureSpace(2);
            curveTypes[numCurves++] = 4;
            // assert(x0 == lastX &amp;&amp; y0 == lastY)
            curves[end++] = x;    curves[end++] = y;
        }

        @SuppressWarnings(&quot;unused&quot;)
        public int pop(float[] pts) {
            int ret = curveTypes[numCurves - 1];
            numCurves--;
            end -= (ret - 2);
            System.arraycopy(curves, end, pts, 0, ret - 2);
            return ret;
        }

        public void pop(PathConsumer2D io) {
            numCurves--;
            int type = curveTypes[numCurves];
            end -= (type - 2);
            switch(type) {
            case 8:
                io.curveTo(curves[end+0], curves[end+1],
                           curves[end+2], curves[end+3],
                           curves[end+4], curves[end+5]);
                break;
            case 6:
                io.quadTo(curves[end+0], curves[end+1],
                           curves[end+2], curves[end+3]);
                 break;
            case 4:
                io.lineTo(curves[end], curves[end+1]);
            }
        }

        @Override
        public String toString() {
            String ret = &quot;&quot;;
            int nc = numCurves;
            int last = this.end;
            while (nc &gt; 0) {
                nc--;
                int type = curveTypes[numCurves];
                last -= (type - 2);
                switch(type) {
                case 8:
                    ret += &quot;cubic: &quot;;
                    break;
                case 6:
                    ret += &quot;quad: &quot;;
                    break;
                case 4:
                    ret += &quot;line: &quot;;
                    break;
                }
                ret += Arrays.toString(Arrays.copyOfRange(curves, last, last+type-2)) + &quot;\n&quot;;
            }
            return ret;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/d3d/D3DShader.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.d3d;

import com.sun.prism.impl.BufferUtil;
import com.sun.prism.ps.Shader;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.Map;

final class D3DShader extends D3DResource implements Shader {

    private static IntBuffer itmp;
    private static FloatBuffer ftmp;
    private final Map&lt;String, Integer&gt; registers;
    private boolean valid;

    D3DShader(D3DContext context, long pData, Map&lt;String, Integer&gt; registers) {
        super(new D3DRecord(context, pData));
        this.valid = (pData != 0L);
        this.registers = registers;
    }

    static native long init(long pCtx, ByteBuffer buf,
            int maxTexCoordIndex, boolean isPixcoordUsed, boolean isPerVertexColorUsed);

    private static native int enable(long pCtx, long pData);
    private static native int disable(long pCtx, long pData);
    private static native int setConstantsF(long pCtx, long pData, int register,
                                             FloatBuffer buf, int off,
                                             int count);
    private static native int setConstantsI(long pCtx, long pData, int register,
                                             IntBuffer buf, int off,
                                             int count);

    private static native int nGetRegister(long pCtx, long pData, String name);

    public void enable() {
        // res &gt;= 0 is equivalent to D3D's SUCCEEDED(res) macro
        int res = enable(d3dResRecord.getContext().getContextHandle(),
                          d3dResRecord.getResource());
        valid &amp;= res &gt;= 0;
        d3dResRecord.getContext().validate(res);
    }

    public void disable() {
        int res = disable(d3dResRecord.getContext().getContextHandle(),
                           d3dResRecord.getResource());
        valid &amp;= res &gt;= 0;
        d3dResRecord.getContext().validate(res);
    }

    private static void checkTmpIntBuf() {
        if (itmp == null) {
            itmp = BufferUtil.newIntBuffer(4);
        }
        itmp.clear();
    }

    public void setConstant(String name, int i0) {
        // NOTE: see HLSLBackend for an explanation of why we're using
        // floats here instead of ints...
        /*
        checkTmpIntBuf();
        itmp.put(i0);
        setConstants(name, itmp, 0, 1);
         */
        setConstant(name, (float)i0);
    }

    public void setConstant(String name, int i0, int i1) {
        /*
        checkTmpIntBuf();
        itmp.put(i0);
        itmp.put(i1);
        setConstants(name, itmp, 0, 1);
         */
        setConstant(name, (float)i0, (float)i1);
    }

    public void setConstant(String name, int i0, int i1, int i2) {
        /*
        checkTmpIntBuf();
        itmp.put(i0);
        itmp.put(i1);
        itmp.put(i2);
        setConstants(name, itmp, 0, 1);
         */
        setConstant(name, (float)i0, (float)i1, (float)i2);
    }

    public void setConstant(String name, int i0, int i1, int i2, int i3) {
        /*
        checkTmpIntBuf();
        itmp.put(i0);
        itmp.put(i1);
        itmp.put(i2);
        itmp.put(i3);
        setConstants(name, itmp, 0, 1);
         */
        setConstant(name, (float)i0, (float)i1, (float)i2, (float)i3);
    }

    public void setConstants(String name, IntBuffer buf, int off, int count) {
        // NOTE: see HLSLBackend for an explanation of why we need to use
        // floats instead of ints; for now this codepath is disabled...
        //setConstantsI(pData, getRegister(name), buf, off, count);
        throw new InternalError(&quot;Not yet implemented&quot;);
    }

    private static void checkTmpFloatBuf() {
        if (ftmp == null) {
            ftmp = BufferUtil.newFloatBuffer(4);
        }
        ftmp.clear();
    }

    public void setConstant(String name, float f0) {
        checkTmpFloatBuf();
        ftmp.put(f0);
        setConstants(name, ftmp, 0, 1);
    }

    public void setConstant(String name, float f0, float f1) {
        checkTmpFloatBuf();
        ftmp.put(f0);
        ftmp.put(f1);
        setConstants(name, ftmp, 0, 1);
    }
<A NAME="28"></A>
    public void setConstant(String name, float f0, float f1, float f2) {
        checkTmpFloatBuf();
        <FONT color="#717d7d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#28',2,'match31-top.html#28',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>ftmp.put(f0);
        ftmp.put(f1);
        ftmp.put(f2);
        setConstants(name, ftmp, 0, 1);
    }

    public void setConstant(String name, float f0, float f1, float f2, float f3) {
        checkTmpFloatBuf();
        ftmp.put</B></FONT>(f0);
        ftmp.put(f1);
        ftmp.put(f2);
        ftmp.put(f3);
        setConstants(name, ftmp, 0, 1);
    }

    public void setConstants(String name, FloatBuffer buf, int off, int count) {
            int res = setConstantsF(d3dResRecord.getContext().getContextHandle(),
                                     d3dResRecord.getResource(),
                                     getRegister(name), buf, off, count);
            valid &amp;= res &gt;= 0;
            d3dResRecord.getContext().validate(res);
    }

    private int getRegister(String name) {
        Integer reg = registers.get(name);
        if (reg == null) {
            // if we did not find the register in the map, we add it
            // it hapens when a shader is compiled in run-time
            int nRegister = nGetRegister(
                    d3dResRecord.getContext().getContextHandle(),
                    d3dResRecord.getResource(), name);
            if (nRegister &lt; 0) {
            throw new IllegalArgumentException(&quot;Register not found for: &quot; +
                                               name);

            }

            registers.put(name, nRegister);
            return nRegister;
        }
        return reg;
    }

    @Override
    public boolean isValid() {
        return valid;
    }

    @Override
    public void dispose() {
        super.dispose();
        valid = false;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/image/CompoundCoords.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.image;

import com.sun.prism.Graphics;
import com.sun.prism.ResourceFactory;
import com.sun.prism.Texture;

public class CompoundCoords {
    // position in the sub-Image matrix
    private int xImg0, xImg1;
    private int yImg0, yImg1;
    private Coords tileCoords[];

    public CompoundCoords(CompoundImage t, Coords crd) {
        int xImg0 = find1(fastFloor(crd.u0), t.uSubdivision);
        int xImg1 = find2(fastCeil(crd.u1),  t.uSubdivision);
        int yImg0 = find1(fastFloor(crd.v0), t.vSubdivision);
        int yImg1 = find2(fastCeil(crd.v1),  t.vSubdivision);

        // exit if uv`s are outside of the grid
        if (xImg0 &lt; 0 || xImg1 &lt; 0 || yImg0 &lt; 0 || yImg1 &lt; 0) return;

        this.xImg0 = xImg0;  this.xImg1 = xImg1;
        this.yImg0 = yImg0;  this.yImg1 = yImg1;
        tileCoords = new Coords[(xImg1 - xImg0 + 1) * (yImg1 - yImg0 + 1)];

        float xMedian[] = new float[xImg1-xImg0];
        float yMedian[] = new float[yImg1-yImg0];

        for (int x = xImg0; x &lt; xImg1; ++x) {
            xMedian[x - xImg0] = crd.getX(t.uSubdivision[x + 1]);
        }
        for (int y = yImg0; y &lt; yImg1; ++y) {
            yMedian[y - yImg0] = crd.getY(t.vSubdivision[y + 1]);
        }

        int idx = 0;
        for (int y = yImg0; y &lt;= yImg1; ++y) {
            float v0 = (y == yImg0 ? crd.v0 : t.vSubdivision[y]) - t.v0[y];
            float v1 = (y == yImg1 ? crd.v1 : t.vSubdivision[y + 1]) - t.v0[y];
            float y0 = y == yImg0 ? crd.y0 : yMedian[y - yImg0 - 1];
            float y1 = y == yImg1 ? crd.y1 : yMedian[y - yImg0];

            for (int x = xImg0; x &lt;= xImg1; ++x) {
                Coords segment = new Coords();
                segment.v0 = v0;
                segment.v1 = v1;
                segment.y0 = y0;
                segment.y1 = y1;

                segment.u0 = (x == xImg0 ? crd.u0 : t.uSubdivision[x]) - t.u0[x];
                segment.u1 = (x == xImg1 ? crd.u1 : t.uSubdivision[x + 1]) - t.u0[x];
                segment.x0 = x == xImg0 ? crd.x0 : xMedian[x - xImg0-1];
                segment.x1 = x == xImg1 ? crd.x1 : xMedian[x - xImg0];

                tileCoords[idx++] = segment;
            }
        }
    }

    public void draw(Graphics g, CompoundImage t, float xS, float yS) {
        if (tileCoords == null) return;

        ResourceFactory factory = g.getResourceFactory();

<A NAME="25"></A>        int idx = 0;
        for (int y = yImg0; y &lt;= yImg1; ++y) {
            for (int x = xImg0; x &lt;= xImg1; ++x) {
                Texture tex = <FONT color="#87f717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#25',2,'match31-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>t.getTile(x, y, factory);
                tileCoords[idx++].draw(tex, g, xS, yS);
                tex.unlock();
            }
        }
    }

    // find n that : array[n] &lt;= x &lt; array[n+1]
    private static int find1(int x, int array[]</B></FONT>) {
        // RT-27419
        // TODO: we may use b-search, probably later
        // since the length is really small, plain 'for' is OK for now
        for (int i = 0; i &lt; array.length - 1; ++i) {
            if (array[i] &lt;= x &amp;&amp; x &lt; array[i + 1]) {
                return i;
            }
        }
        return -1;
    }

    // find n that : array[n] &lt; x &lt;= array[n+1]
    private static int find2(int x, int array[]) {
        // RT-27419
        // TODO: we may use b-search, probably later
        // since the length is really small, plain 'for' is OK for now
        for (int i = 0; i &lt; array.length - 1; ++i) {
            if (array[i] &lt; x &amp;&amp; x &lt;= array[i + 1]) {
                return i;
            }
        }
        return -1;
    }

    private static int fastFloor(float x) {
        int ix = (int) x;
        return (ix &lt;= x) ? ix : ix - 1;
    }

    private static int fastCeil(float x) {
        int ix = (int) x;
        return (ix &gt;= x) ? ix : ix + 1;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/impl/VertexBuffer.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2009, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.impl;

import com.sun.javafx.geom.transform.AffineBase;
import com.sun.prism.paint.Color;
import java.util.Arrays;

public final class VertexBuffer {

    protected static final int VERTS_PER_QUAD  = 4;

    protected static final int FLOATS_PER_TC   = 2;
    protected static final int FLOATS_PER_VC   = 3;
    protected static final int FLOATS_PER_VERT = FLOATS_PER_VC + (2 * FLOATS_PER_TC);

    protected static final int BYTES_PER_VERT = 4;

    protected static final int VCOFF = 0;
    protected static final int TC1OFF = VCOFF  + FLOATS_PER_VC;
    protected static final int TC2OFF = TC1OFF + FLOATS_PER_TC;

    protected int capacity, index;

    protected byte r, g, b, a;

    protected byte  colorArray[];
    protected float coordArray[];

    private final BaseContext ownerCtx;

    public VertexBuffer(BaseContext owner, int maxQuads) {
        this.ownerCtx = owner;
        capacity = maxQuads * VERTS_PER_QUAD;
        index = 0;

        colorArray = new byte [capacity * BYTES_PER_VERT];
        coordArray = new float[capacity * FLOATS_PER_VERT];
    }

    public final void setPerVertexColor(Color c, float extraAlpha) {
        float ca = c.getAlpha() * extraAlpha;
        r = (byte)(c.getRed()   * ca * 0xff);
        g = (byte)(c.getGreen() * ca * 0xff);
        b = (byte)(c.getBlue()  * ca * 0xff);
        a = (byte)(               ca * 0xff);
    }

    public final void setPerVertexColor(float extraAlpha) {
        r = g = b = a = (byte)(extraAlpha * 0xff);
    }

    public final void updateVertexColors(int numVerts) {
        for (int i=0; i!=numVerts; ++i) {
            putColor(i);
        }
    }

    private void putColor(int idx) {
        int i = idx * BYTES_PER_VERT;
        colorArray[i+0] = r;
        colorArray[i+1] = g;
        colorArray[i+2] = b;
        colorArray[i+3] = a;
    }

    /**
     * Flushes (renders) all pending vertices (triangles) in the buffer to the
     * owner BaseContext.  This operation only applies to heavyweight
     * buffers; calling flush() on a lightweight buffer will result in an
     * exception.
     */
    public final void flush() {
        if (index &gt; 0) {
            ownerCtx.drawQuads(coordArray, colorArray, index);
            index = 0;
        }
    }

    public final void rewind() {
        index = 0;
    }

    private void grow() {
        capacity *= 2;
        colorArray = Arrays.copyOf(colorArray, capacity * BYTES_PER_VERT);
        coordArray = Arrays.copyOf(coordArray, capacity * FLOATS_PER_VERT);
    }

    public final void addVert(float x, float y) {
        // unlike the other (private) addVert() variants, this checks capacity
        if (index == capacity) {
            grow();
        }

        int i = FLOATS_PER_VERT * index;
        coordArray[i+0] = x;
        coordArray[i+1] = y;
        coordArray[i+2] = 0f;
        putColor(index);
        index++;
    }

    public final void addVert(float x, float y, float tx, float ty) {
        // unlike the (private) addVert() variants, this checks capacity
        if (index == capacity) {
            grow();
        }

        int i = FLOATS_PER_VERT * index;
        coordArray[i+0] = x;
        coordArray[i+1] = y;
        coordArray[i+2] = 0f;
        coordArray[i+3] = tx;
        coordArray[i+4] = ty;
        putColor(index);
        index++;
    }

    public final void addVert(float x, float y, float t0x, float t0y, float t1x, float t1y) {
        // unlike the (private) addVert() variants, this checks capacity
        if (index == capacity) {
            grow();
        }

        int i = FLOATS_PER_VERT * index;
        coordArray[i+0] = x;
        coordArray[i+1] = y;
        coordArray[i+2] = 0f;
        coordArray[i+3] = t0x;
        coordArray[i+4] = t0y;
        coordArray[i+5] = t1x;
        coordArray[i+6] = t1y;
        putColor(index);
        index++;
    }

    private void addVertNoCheck(float x, float y) {
        // note: assumes caller has already checked capacity
        int i = FLOATS_PER_VERT * index;
        coordArray[i+0] = x;
        coordArray[i+1] = y;
        coordArray[i+2] = 0f;
        putColor(index);
        index++;
    }

    private void addVertNoCheck(float x, float y, float tx, float ty) {
        // note: assumes caller has already checked capacity
        int i = FLOATS_PER_VERT * index;
        coordArray[i+0] = x;
        coordArray[i+1] = y;
        coordArray[i+2] = 0f;
        coordArray[i+3] = tx;
        coordArray[i+4] = ty;
        putColor(index);
        index++;
    }

    private void addVertNoCheck(float x, float y, float t0x, float t0y, float t1x, float t1y) {
        // note: assumes caller has already checked capacity
        int i = FLOATS_PER_VERT * index;
        coordArray[i+0] = x;
        coordArray[i+1] = y;
        coordArray[i+2] = 0f;
        coordArray[i+3] = t0x;
        coordArray[i+4] = t0y;
        coordArray[i+5] = t1x;
        coordArray[i+6] = t1y;
        putColor(index);
        index++;
    }

    private void ensureCapacityForQuad() {
        if (index + VERTS_PER_QUAD &gt; capacity) {
            ownerCtx.drawQuads(coordArray, colorArray, index);
            index = 0;
        }
    }

    public final void addQuad(float dx1, float dy1, float dx2, float dy2) {
        ensureCapacityForQuad();

        addVertNoCheck(dx1, dy1);
        addVertNoCheck(dx1, dy2);
        addVertNoCheck(dx2, dy1);
        addVertNoCheck(dx2, dy2);
<A NAME="27"></A>    }

    public final void addQuad(
            float dx1, float dy1, float dx2, <FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#27',2,'match31-top.html#27',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>float dy2,
            float t1x1, float t1y1, float t1x2, float t1y2,
            float t2x1, float t2y1, float t2x2, float t2y2)
    {
        ensureCapacityForQuad();

        addVertNoCheck(dx1, dy1, t1x1, t1y1, t2x1, t2y1);
        addVertNoCheck(dx1, dy2, t1x1, t1y2, t2x1, t2y2);
        addVertNoCheck(dx2, dy1, t1x2, t1y1, t2x2, t2y1);
        addVertNoCheck(dx2, dy2, t1x2, t1y2, t2x2, t2y2);
    }

    public final void addMappedQuad(
            float dx1, float dy1, float dx2, float dy2,
            float tx11, float ty11, float tx21</B></FONT>, float ty21,
            float tx12, float ty12, float tx22, float ty22)
    {
        ensureCapacityForQuad();

        addVertNoCheck(dx1, dy1, tx11, ty11);
        addVertNoCheck(dx1, dy2, tx12, ty12);
        addVertNoCheck(dx2, dy1, tx21, ty21);
        addVertNoCheck(dx2, dy2, tx22, ty22);
    }

    public final void addMappedQuad(
            float dx1, float dy1, float dx2, float dy2,
            float ux11, float uy11, float ux21, float uy21,
            float ux12, float uy12, float ux22, float uy22,
            float vx11, float vy11, float vx21, float vy21,
            float vx12, float vy12, float vx22, float vy22)
    {
        ensureCapacityForQuad();

        addVertNoCheck(dx1, dy1, ux11, uy11, vx11, vy11);
        addVertNoCheck(dx1, dy2, ux12, uy12, vx12, vy12);
        addVertNoCheck(dx2, dy1, ux21, uy21, vx21, vy21);
        addVertNoCheck(dx2, dy2, ux22, uy22, vx22, vy22);
    }

    public final void addQuad(
            float dx1, float dy1, float dx2, float dy2,
            float tx1, float ty1, float tx2, float ty2,
            AffineBase tx)
    {
        addQuad(dx1, dy1, dx2, dy2, tx1, ty1, tx2, ty2);

        if (tx != null) {
            int i = FLOATS_PER_VERT * index - FLOATS_PER_VERT;
            tx.transform(coordArray, i+VCOFF, coordArray, i+TC2OFF, 1);
            i -= FLOATS_PER_VERT;
            tx.transform(coordArray, i+VCOFF, coordArray, i+TC2OFF, 1);
            i -= FLOATS_PER_VERT;
            tx.transform(coordArray, i+VCOFF, coordArray, i+TC2OFF, 1);
            i -= FLOATS_PER_VERT;
            tx.transform(coordArray, i+VCOFF, coordArray, i+TC2OFF, 1);
        }
    }

    public final void addSuperQuad(
            float dx1, float dy1, float dx2, float dy2,
            float tx1, float ty1, float tx2, float ty2,
            boolean isText)
    {
//        ensureCapacityForQuad();
        int idx = index;
        if (idx + VERTS_PER_QUAD &gt; capacity) {
            ownerCtx.drawQuads(coordArray, colorArray, idx);
            idx = index = 0;
        }

        int i = FLOATS_PER_VERT * idx;
        float farr[] = coordArray;

        float text = isText ? 1 : 0;
        float image = isText ? 0 : 1;

//        addVertNoCheck(dx1, dy1, tx1, ty1);
        farr[  i] = dx1; farr[++i] = dy1; farr[++i] = 0;
        farr[++i] = tx1; farr[++i] = ty1;
        farr[++i] = image; farr[++i] = text; i++;
//        addVertNoCheck(dx1, dy2, tx1, ty2);
        farr[  i] = dx1; farr[++i] = dy2; farr[++i] = 0;
        farr[++i] = tx1; farr[++i] = ty2;
        farr[++i] = image; farr[++i] = text; i++;
//        addVertNoCheck(dx2, dy1, tx2, ty1);
        farr[  i] = dx2; farr[++i] = dy1; farr[++i] = 0;
        farr[++i] = tx2; farr[++i] = ty1;
        farr[++i] = image; farr[++i] = text; i++;
//        addVertNoCheck(dx2, dy2, tx2, ty2);
        farr[  i] = dx2; farr[++i] = dy2; farr[++i] = 0;
        farr[++i] = tx2; farr[++i] = ty2;
        farr[++i] = image; farr[++i] = text; i++;

        byte barr[] = colorArray;
        byte r = this.r, g = this.g, b = this.b, a = this.a;
        int j = BYTES_PER_VERT * idx;
        barr[  j] = r; barr[++j] = g; barr[++j] = b; barr[++j] = a;
        barr[++j] = r; barr[++j] = g; barr[++j] = b; barr[++j] = a;
        barr[++j] = r; barr[++j] = g; barr[++j] = b; barr[++j] = a;
        barr[++j] = r; barr[++j] = g; barr[++j] = b; barr[++j] = a;

        index = idx + VERTS_PER_QUAD;
    }

    public final void addQuad(
            float dx1, float dy1, float dx2, float dy2,
            float tx1, float ty1, float tx2, float ty2)
    {
//        ensureCapacityForQuad();
        int idx = index;
        if (idx + VERTS_PER_QUAD &gt; capacity) {
            ownerCtx.drawQuads(coordArray, colorArray, idx);
            idx = index = 0;
        }

        int i = FLOATS_PER_VERT * idx;
        float farr[] = coordArray;

//        addVertNoCheck(dx1, dy1, tx1, ty1);
        farr[  i] = dx1; farr[++i] = dy1; farr[++i] = 0;
        farr[++i] = tx1; farr[++i] = ty1;
        i += 3;
//        addVertNoCheck(dx1, dy2, tx1, ty2);
        farr[  i] = dx1; farr[++i] = dy2; farr[++i] = 0;
        farr[++i] = tx1; farr[++i] = ty2;
        i += 3;
//        addVertNoCheck(dx2, dy1, tx2, ty1);
        farr[  i] = dx2; farr[++i] = dy1; farr[++i] = 0;
        farr[++i] = tx2; farr[++i] = ty1;
        i += 3;
//        addVertNoCheck(dx2, dy2, tx2, ty2);
        farr[  i] = dx2; farr[++i] = dy2; farr[++i] = 0;
        farr[++i] = tx2; farr[++i] = ty2;

        byte barr[] = colorArray;
        byte r = this.r, g = this.g, b = this.b, a = this.a;
        int j = BYTES_PER_VERT * idx;
        barr[  j] = r; barr[++j] = g; barr[++j] = b; barr[++j] = a;
        barr[++j] = r; barr[++j] = g; barr[++j] = b; barr[++j] = a;
        barr[++j] = r; barr[++j] = g; barr[++j] = b; barr[++j] = a;
        barr[++j] = r; barr[++j] = g; barr[++j] = b; barr[++j] = a;

        index = idx + VERTS_PER_QUAD;
    }

    public final void addQuadVO(float topopacity, float botopacity,
            float dx1, float dy1, float dx2, float dy2,
            float tx1, float ty1, float tx2, float ty2)
    {
        int idx = index;
        if (idx + VERTS_PER_QUAD &gt; capacity) {
            ownerCtx.drawQuads(coordArray, colorArray, idx);
            idx = index = 0;
        }

        int i = FLOATS_PER_VERT * idx;
        float farr[] = coordArray;

        // addVertNoCheck(dx1, dy1, tx1, ty1, topopacity);
        farr[  i] = dx1; farr[++i] = dy1; farr[++i] = 0;
        farr[++i] = tx1; farr[++i] = ty1;
        i += 3;

        // addVertNoCheck(dx1, dy2, tx1, ty2, botopacity);
        farr[  i] = dx1; farr[++i] = dy2; farr[++i] = 0;
        farr[++i] = tx1; farr[++i] = ty2;
        i += 3;

        // addVertNoCheck(dx2, dy1, tx2, ty1, topopacity);
        farr[  i] = dx2; farr[++i] = dy1; farr[++i] = 0;
        farr[++i] = tx2; farr[++i] = ty1;
        i += 3;

        // addVertNoCheck(dx2, dy2, tx2, ty2, botopacity);
        farr[  i] = dx2; farr[++i] = dy2; farr[++i] = 0;
        farr[++i] = tx2; farr[++i] = ty2;

        byte barr[] = colorArray;
        int j = BYTES_PER_VERT * idx;

        byte to = (byte)(topopacity * 0xff);
        byte bo = (byte)(botopacity * 0xff);

        barr[  j] = to; barr[++j] = to; barr[++j] = to; barr[++j] = to;
        barr[++j] = bo; barr[++j] = bo; barr[++j] = bo; barr[++j] = bo;
        barr[++j] = to; barr[++j] = to; barr[++j] = to; barr[++j] = to;
        barr[++j] = bo; barr[++j] = bo; barr[++j] = bo; barr[++j] = bo;

        index = idx + VERTS_PER_QUAD;
    }

    public final void addMappedPgram(
            float dx11, float dy11, float dx21, float dy21,
            float dx12, float dy12, float dx22, float dy22,
            float ux11, float uy11, float ux21, float uy21,
            float ux12, float uy12, float ux22, float uy22,
            float vx11, float vy11, float vx22, float vy22,
            AffineBase tx)
    {
        addMappedPgram(dx11, dy11, dx21, dy21, dx12, dy12, dx22, dy22,
                       ux11, uy11, ux21, uy21, ux12, uy12, ux22, uy22,
                       vx11, vy11, vx22, vy11, vx11, vy22, vx22, vy22);

        int i = FLOATS_PER_VERT * index - FLOATS_PER_VERT;
        tx.transform(coordArray, i+TC2OFF, coordArray, i+TC2OFF, 1);
        i -= FLOATS_PER_VERT;
        tx.transform(coordArray, i+TC2OFF, coordArray, i+TC2OFF, 1);
        i -= FLOATS_PER_VERT;
        tx.transform(coordArray, i+TC2OFF, coordArray, i+TC2OFF, 1);
        i -= FLOATS_PER_VERT;
        tx.transform(coordArray, i+TC2OFF, coordArray, i+TC2OFF, 1);
    }

    public final void addMappedPgram(
            float dx11, float dy11, float dx21, float dy21,
            float dx12, float dy12, float dx22, float dy22,
            float ux11, float uy11, float ux21, float uy21,
            float ux12, float uy12, float ux22, float uy22,
            float vx, float vy)
    {
        int idx = index;
        if (idx + VERTS_PER_QUAD &gt; capacity) {
            ownerCtx.drawQuads(coordArray, colorArray, idx);
            idx = index = 0;
        }

        int i = FLOATS_PER_VERT * idx;
        float farr[] = coordArray;

        //addVertNoCheck(dx11, dy11, ux11, uy11, vx, vy);
        farr[i]   = dx11; farr[++i] = dy11; farr[++i] = 0;
        farr[++i] = ux11; farr[++i] = uy11;
        farr[++i] = vx; farr[++i] = vy;

        //addVertNoCheck(dx12, dy12, ux12, uy12, vx, vy);
        farr[++i] = dx12; farr[++i] = dy12; farr[++i] = 0;
        farr[++i] = ux12; farr[++i] = uy12;
        farr[++i] = vx; farr[++i] = vy;

        //addVertNoCheck(dx21, dy21, ux21, uy21, vx, vy);
        farr[++i] = dx21; farr[++i] = dy21; farr[++i] = 0;
        farr[++i] = ux21; farr[++i] = uy21;
        farr[++i] = vx; farr[++i] = vy;

            //addVertNoCheck(dx22, dy22, ux22, uy22, vx, vy);
        farr[++i] = dx22; farr[++i] = dy22; farr[++i] = 0;
        farr[++i] = ux22; farr[++i] = uy22;
        farr[++i] = vx; farr[++i] = vy;

        byte barr[] = colorArray;
        byte r = this.r, g = this.g, b = this.b, a = this.a;
        int j = BYTES_PER_VERT * idx;
        barr[  j] = r; barr[++j] = g; barr[++j] = b; barr[++j] = a;
        barr[++j] = r; barr[++j] = g; barr[++j] = b; barr[++j] = a;
        barr[++j] = r; barr[++j] = g; barr[++j] = b; barr[++j] = a;
        barr[++j] = r; barr[++j] = g; barr[++j] = b; barr[++j] = a;

        index = idx + VERTS_PER_QUAD;
    }

    public final void addMappedPgram(
            float dx11, float dy11, float dx21, float dy21,
            float dx12, float dy12, float dx22, float dy22,
            float ux11, float uy11, float ux21, float uy21,
            float ux12, float uy12, float ux22, float uy22,
            float vx11, float vy11, float vx21, float vy21,
            float vx12, float vy12, float vx22, float vy22)
    {
        int idx = index;
        if (idx + VERTS_PER_QUAD &gt; capacity) {
            ownerCtx.drawQuads(coordArray, colorArray, idx);
            idx = index = 0;
        }

        int i = FLOATS_PER_VERT * idx;
        float farr[] = coordArray;

        //addVertNoCheck(dx11, dy11, ux11, uy11, vx, vy);
        farr[i]   = dx11; farr[++i] = dy11; farr[++i] = 0;
        farr[++i] = ux11; farr[++i] = uy11;
        farr[++i] = vx11; farr[++i] = vy11;

        //addVertNoCheck(dx12, dy12, ux12, uy12, vx, vy);
        farr[++i] = dx12; farr[++i] = dy12; farr[++i] = 0;
        farr[++i] = ux12; farr[++i] = uy12;
        farr[++i] = vx12; farr[++i] = vy12;

        //addVertNoCheck(dx21, dy21, ux21, uy21, vx, vy);
        farr[++i] = dx21; farr[++i] = dy21; farr[++i] = 0;
        farr[++i] = ux21; farr[++i] = uy21;
        farr[++i] = vx21; farr[++i] = vy21;

        //addVertNoCheck(dx22, dy22, ux22, uy22, vx, vy);
        farr[++i] = dx22; farr[++i] = dy22; farr[++i] = 0;
        farr[++i] = ux22; farr[++i] = uy22;
        farr[++i] = vx22; farr[++i] = vy22;

        byte barr[] = colorArray;
        byte r = this.r, g = this.g, b = this.b, a = this.a;
        int j = BYTES_PER_VERT * idx;
        barr[  j] = r; barr[++j] = g; barr[++j] = b; barr[++j] = a;
        barr[++j] = r; barr[++j] = g; barr[++j] = b; barr[++j] = a;
        barr[++j] = r; barr[++j] = g; barr[++j] = b; barr[++j] = a;
        barr[++j] = r; barr[++j] = g; barr[++j] = b; barr[++j] = a;

        index = idx + VERTS_PER_QUAD;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/scenario/animation/AnimationPulse.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2007, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.scenario.animation;

import java.util.Iterator;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

import com.sun.javafx.tk.Toolkit;


public class AnimationPulse implements AnimationPulseMBean {
    public static AnimationPulse getDefaultBean() {
        return AnimationPulseHolder.holder;
    }
    private static class AnimationPulseHolder {
        private static final AnimationPulse holder = new AnimationPulse();
    }

    private static class PulseData {
        private final long startNanos;
        private final long scheduledNanos;

        private long animationEndNanos = Long.MIN_VALUE;
        private long paintingStartNanos = Long.MIN_VALUE;
        private long paintingEndNanos = Long.MIN_VALUE;
        private long scenePaintingStartNanos = Long.MIN_VALUE;
        private long scenePaintingEndNanos = Long.MIN_VALUE;
        private long endNanos = Long.MIN_VALUE;

        PulseData(long shiftNanos) {
            startNanos = Toolkit.getToolkit().getMasterTimer().nanos();
            scheduledNanos = startNanos + shiftNanos;
        }

        //time from the scheduledNanos
        long getPulseStart(TimeUnit unit) {
            return unit.convert(startNanos - scheduledNanos, TimeUnit.NANOSECONDS);
        }

        void recordAnimationEnd() {
            animationEndNanos = Toolkit.getToolkit().getMasterTimer().nanos();
        }

        long getAnimationDuration(TimeUnit unit) {
            return (animationEndNanos &gt; Long.MIN_VALUE)
              ? unit.convert(animationEndNanos - startNanos, TimeUnit.NANOSECONDS)
              : 0;
        }

        long getPaintingDuration(TimeUnit unit) {
            return (paintingEndNanos &gt; Long.MIN_VALUE &amp;&amp; paintingStartNanos &gt; Long.MIN_VALUE)
              ? unit.convert(paintingEndNanos - paintingStartNanos, TimeUnit.NANOSECONDS)
              : 0;
        }

        long getScenePaintingDuration(TimeUnit unit) {
            return (scenePaintingEndNanos &gt; Long.MIN_VALUE &amp;&amp; scenePaintingStartNanos &gt; Long.MIN_VALUE)
              ? unit.convert(scenePaintingEndNanos - scenePaintingStartNanos, TimeUnit.NANOSECONDS)
              : 0;
        }

        long getPaintingFinalizationDuration(TimeUnit unit) {
            return (scenePaintingEndNanos &gt; Long.MIN_VALUE &amp;&amp; paintingEndNanos &gt; Long.MIN_VALUE)
              ? unit.convert(paintingEndNanos - scenePaintingEndNanos, TimeUnit.NANOSECONDS)
              : 0;
        }

        void recordEnd() {
            endNanos = Toolkit.getToolkit().getMasterTimer().nanos();
        }

        long getPulseDuration(TimeUnit unit) {
            return unit.convert(endNanos - startNanos, TimeUnit.NANOSECONDS);
        }

        //time from the scheduledNanos
        long getPulseEnd(TimeUnit unit) {
            return unit
                    .convert(endNanos - scheduledNanos, TimeUnit.NANOSECONDS);
        }

        long getPulseStartFromNow(TimeUnit unit) {
            return unit.convert(Toolkit.getToolkit().getMasterTimer().nanos() - startNanos,
                    TimeUnit.NANOSECONDS);
        }

        long getSkippedPulses() {
            return getPulseEnd(TimeUnit.MILLISECONDS)
              / AnimationPulse.getDefaultBean().getPULSE_DURATION();
        }

        static interface Accessor {
            public long get(PulseData pulseData, TimeUnit unit);
        }

        static final Accessor PulseStartAccessor = (pulseData1, unit) -&gt; pulseData1.getPulseStart(unit);

        static final Accessor AnimationDurationAccessor = (pulseData1, unit) -&gt; pulseData1.getAnimationDuration(unit);

        static final Accessor PaintingDurationAccessor = (pulseData1, unit) -&gt; pulseData1.getPaintingDuration(unit);

        static final Accessor ScenePaintingDurationAccessor = (pulseData1, unit) -&gt; pulseData1.getScenePaintingDuration(unit);

        static final Accessor PulseDurationAccessor = (pulseData1, unit) -&gt; pulseData1.getPulseDuration(unit);

        static final Accessor PulseEndAccessor = (pulseData1, unit) -&gt; pulseData1.getPulseEnd(unit);

        static final Accessor PaintingPreparationDuration = (pulseData1, unit) -&gt; pulseData1.getPaintingDuration(unit);

        static final Accessor PaintingFinalizationDuration = (pulseData1, unit) -&gt; pulseData1.getPaintingFinalizationDuration(unit);

//        @Override
//        public String toString() {
//            StringBuilder sb = new StringBuilder(super.toString());
//            TimeUnit unit = TimeUnit.MILLISECONDS;
//            sb.append(&quot; start: &quot;).append(getPulseStart(unit))
//            .append(&quot; animation: &quot;).append(getAnimationDuration(unit))
//            .append(&quot; painting: &quot;).append(getPaintingDuration(unit))
//            .append(&quot; pulseDuration: &quot;).append(getPulseDuration(unit))
//            .append(&quot; pulseEnd: &quot;).append(getPulseEnd(unit));
//            return sb.toString();
//        }
    }

    private final Queue&lt;PulseData&gt; pulseDataQueue = new ConcurrentLinkedQueue&lt;&gt;();

    //to be accessed from the EDT
    private PulseData pulseData = null;



    private volatile boolean isEnabled = false;
    @Override
    public boolean getEnabled() {
        return isEnabled;
    }

    @Override
    public void setEnabled(boolean enabled) {
        if (enabled == isEnabled) {
            return;
        }
        isEnabled = enabled;
        //we may want to clean the state on setEanbled(false)
    }

    @Override
    public long getPULSE_DURATION() {
        return Toolkit.getToolkit().getMasterTimer().getPulseDuration(1000);
    }


    @Override
    public long getSkippedPulses() {
        return skippedPulses.get();
    }

    @Override
    public long getSkippedPulsesIn1Sec() {
        long rv = 0;
        for (PulseData pulseData : pulseDataQueue) {
            if (pulseData.getPulseStartFromNow(TimeUnit.SECONDS) == 0) {
                rv += pulseData.getSkippedPulses();
            }
        }
        return rv;
    }


    public void recordStart(long shiftMillis) {
        if (! getEnabled()) {
            return;
        }
        pulseData = new PulseData(TimeUnit.MILLISECONDS.toNanos(shiftMillis));
    }

    // cleans items older than 1sec from the queue
    private void purgeOldPulseData() {
        Iterator&lt;PulseData&gt; iterator = pulseDataQueue.iterator();
        while (iterator.hasNext()
                &amp;&amp; iterator.next().getPulseStartFromNow(TimeUnit.SECONDS) &gt; 1) {
            iterator.remove();
        }
    }

    private final AtomicLong pulseCounter = new AtomicLong();

    private final AtomicLong startMax = new AtomicLong();
    private final AtomicLong startSum = new AtomicLong();
    private final AtomicLong startAv = new AtomicLong();

    private final AtomicLong endMax = new AtomicLong();
    private final AtomicLong endSum = new AtomicLong();
    private final AtomicLong endAv = new AtomicLong();

    private final AtomicLong animationDurationMax = new AtomicLong();
    private final AtomicLong animationDurationSum = new AtomicLong();
    private final AtomicLong animationDurationAv = new AtomicLong();
<A NAME="2"></A>
    private final AtomicLong paintingDurationMax = new AtomicLong();
    private final AtomicLong paintingDurationSum = new AtomicLong();
    private final AtomicLong paintingDurationAv = <FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#2',2,'match31-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new AtomicLong();

    private final AtomicLong pulseDurationMax = new AtomicLong();
    private final AtomicLong pulseDurationSum = new AtomicLong();
    private final AtomicLong pulseDurationAv = new AtomicLong();

    private final AtomicLong[] maxAndAv = new</B></FONT> AtomicLong[] {
            startMax, startSum, startAv,
            endMax, endSum, endAv,
            animationDurationMax, animationDurationSum, animationDurationAv,
            paintingDurationMax, paintingDurationSum, paintingDurationAv,
            pulseDurationMax, pulseDurationSum, pulseDurationAv
    };
    private final PulseData.Accessor[] maxAndAvAccessors = new PulseData.Accessor[] {
            PulseData.PulseStartAccessor,
            PulseData.PulseEndAccessor,
            PulseData.AnimationDurationAccessor,
            PulseData.PaintingDurationAccessor,
            PulseData.PulseDurationAccessor
    };

    private void updateMaxAndAv() {
        long pulseCounterLong = pulseCounter.incrementAndGet();
        for (int i = 0; i &lt; maxAndAvAccessors.length; i++) {
            int j = i * 3;
            long tmpLong = maxAndAvAccessors[i].get(pulseData, TimeUnit.MILLISECONDS);
            maxAndAv[j].set(Math.max(maxAndAv[j].get(), tmpLong));
            maxAndAv[j + 1].addAndGet(tmpLong);
            maxAndAv[j + 2].set(maxAndAv[j + 1].get() / pulseCounterLong);
        }
    }

    private final AtomicLong skippedPulses = new AtomicLong();

    private int skipPulses = 100;
    public void recordEnd() {
        if (! getEnabled()) {
            return;
        }
        if (skipPulses &gt; 0) {
            //do not gather data for the first 'skipPulses' pulses
            //let the application to warm up
            skipPulses--;
            pulseData = null;
            return;
        }
        pulseData.recordEnd();
        purgeOldPulseData();
        updateMaxAndAv();
        skippedPulses.addAndGet(pulseData.getSkippedPulses());
        pulseDataQueue.add(pulseData);
        pulseData = null;
    }

    /*
     * implementation detail: I wish we had deque in 1.5 but we do not so here we
     * iterate over the whole thing.
     */
    private long getAv(PulseData.Accessor accessor, long timeOut, TimeUnit unit) {
        if (! getEnabled()) {
            return 0;
        }
        long time = 0;
        long items = 0;
        for (PulseData currentPulseData : pulseDataQueue) {
            if (currentPulseData.getPulseStartFromNow(unit) &lt;= timeOut) {
                time += accessor.get(currentPulseData, unit);
                items++;
            }
        }
        return (items == 0) ? 0 : time / items;
    }

    private long getMax(PulseData.Accessor accessor, long timeOut, TimeUnit unit) {
        if (! getEnabled()) {
            return 0;
        }
        long max = 0;
        for (PulseData currentPulseData : pulseDataQueue) {
            if (currentPulseData.getPulseStartFromNow(unit) &lt;= timeOut) {
                max = Math.max(accessor.get(currentPulseData, unit), max);
            }
        }
        return max;
    }

    @Override
    public long getStartMax() {
        return startMax.get();
    }

    @Override
    public long getStartAv() {
        return startAv.get();
    }

    @Override
    public long getStartMaxIn1Sec() {
        return getMax(PulseData.PulseStartAccessor, 1000, TimeUnit.MILLISECONDS);
    }

    @Override
    public long getStartAvIn100Millis() {
        return getAv(PulseData.PulseStartAccessor, 100, TimeUnit.MILLISECONDS);
    }

    @Override
    public long getEndMax() {
        return endMax.get();
    }

    @Override
    public long getEndMaxIn1Sec() {
        return getMax(PulseData.PulseEndAccessor, 1000, TimeUnit.MILLISECONDS);
    }

    @Override
    public long getEndAv() {
        return endAv.get();
    }

    @Override
    public long getEndAvIn100Millis() {
        return getAv(PulseData.PulseEndAccessor, 100, TimeUnit.MILLISECONDS);
    }

    public void recordAnimationEnd() {
        if (getEnabled() &amp;&amp; pulseData != null) {
            pulseData.recordAnimationEnd();
        }
    }

    @Override
    public long getAnimationDurationMax() {
        return animationDurationMax.get();
    }

    @Override
    public long getAnimationMaxIn1Sec() {
        return getMax(PulseData.AnimationDurationAccessor, 1000, TimeUnit.MILLISECONDS);
    }

    @Override
    public long getAnimationDurationAv() {
        return animationDurationAv.get();
    }

    @Override
    public long getAnimationDurationAvIn100Millis() {
        return getAv(PulseData.AnimationDurationAccessor, 100, TimeUnit.MILLISECONDS);
    }

    @Override
    public long getPaintingDurationMax() {
        return paintingDurationMax.get();
    }

    @Override
    public long getPaintingDurationMaxIn1Sec() {
        return getMax(PulseData.PaintingDurationAccessor, 1000, TimeUnit.MILLISECONDS);
    }

    @Override
    public long getPaintingDurationAv() {
        return paintingDurationAv.get();
    }

    @Override
    public long getPaintingDurationAvIn100Millis() {
        return getAv(PulseData.PaintingDurationAccessor, 100, TimeUnit.MILLISECONDS);
    }

    @Override
    public long getScenePaintingDurationMaxIn1Sec() {
        return getMax(PulseData.ScenePaintingDurationAccessor, 1000, TimeUnit.MILLISECONDS);
    }

    @Override
    public long getPulseDurationMax() {
        return pulseDurationMax.get();
    }

    @Override
    public long getPulseDurationMaxIn1Sec() {
        return getMax(PulseData.PulseDurationAccessor, 1000, TimeUnit.MILLISECONDS);
    }

    @Override
    public long getPulseDurationAv() {
        return pulseDurationAv.get();
    }

    @Override
    public long getPulseDurationAvIn100Millis() {
        return getAv(PulseData.PulseDurationAccessor, 100, TimeUnit.MILLISECONDS);
    }

    @Override
    public long getPaintingPreparationDurationMaxIn1Sec() {
        return getMax(PulseData.PaintingPreparationDuration, 1000, TimeUnit.MILLISECONDS);
    }

    @Override
    public long getPaintingFinalizationDurationMaxIn1Sec() {
        return getMax(PulseData.PaintingFinalizationDuration, 1000, TimeUnit.MILLISECONDS);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/Camera.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.geometry.Point2D;
import javafx.geometry.Point3D;
import javafx.scene.transform.Transform;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.BoxBounds;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.Vec3d;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.GeneralTransform3D;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.javafx.scene.CameraHelper;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.transform.TransformHelper;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.logging.PlatformLogger;


/**
 * Base class for a camera used to render a scene.
 * The camera defines the mapping of the scene coordinate space onto the window.
 * Camera is an abstract class with two concrete subclasses:
 * {@link ParallelCamera} and {@link PerspectiveCamera}.
 *
 * &lt;p&gt;
 * The default camera is positioned in the scene such that its projection plane
 * in the scene coordinate space is at Z = 0, and it is looking into the screen in
 * the positive Z direction. The distance in Z from the camera to the projection
 * plane is determined by the {@code width} and {@code height} of the Scene to
 * which it is attached and its {@code fieldOfView}.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The {@code nearClip} and {@code farClip} of this camera are specified in the
 * eye coordinate space. This space is defined such that the eye is at its
 * origin and the projection plane is one unit in front of the eye in the
 * positive Z direction.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The following pseudo code is the math used to compute the near and far clip
 * distances in the scene coordinate space:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * final double tanOfHalfFOV = Math.tan(Math.toRadians(FOV) / 2.0);
 * final double halfHeight = HEIGHT / 2;
 * final double focalLenght = halfHeight / tanOfHalfFOV;
 * final double eyePositionZ = -1.0 * focalLenght;
 * final double nearClipDistance = focalLenght * NEAR + eyePositionZ;
 * final double farClipDistance = focalLenght * FAR + eyePositionZ;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * where {@code FOV} is {@code fieldOfView} in degrees,
 * {@code NEAR} is {@code nearClip} specified in eye space,
 * and {@code FAR} is {@code farClip} specified in eye space.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Note: Since the ParallelCamera class has no {@code fieldOfView} property, a
 * 30 degrees vertical field of view is used.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Note: For the case of a PerspectiveCamera where the fixedEyeAtCameraZero
 * attribute is true, the scene coordinate space is normalized in order to fit
 * into the view frustum (see {@link PerspectiveCamera} for more details). In
 * this mode, the eye coordinate space is the same as this Camera node's local
 * coordinate space. Hence the conversion formula mentioned above is not used.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * An application should not extend the Camera class directly. Doing so may lead to
 * an UnsupportedOperationException being thrown.
 * &lt;/p&gt;
 *
 * @since JavaFX 2.0
 */
public abstract class Camera extends Node {
    static {
         // This is used by classes in different packages to get access to
         // private and package private methods.
        CameraHelper.setCameraAccessor(new CameraHelper.CameraAccessor() {
            @Override
            public void doMarkDirty(Node node, DirtyBits dirtyBit) {
                ((Camera) node).doMarkDirty(dirtyBit);
            }

            @Override
            public void doUpdatePeer(Node node) {
                ((Camera) node).doUpdatePeer();
            }

            @Override
            public BaseBounds doComputeGeomBounds(Node node,
                    BaseBounds bounds, BaseTransform tx) {
                return ((Camera) node).doComputeGeomBounds(bounds, tx);
            }

            @Override
            public boolean doComputeContains(Node node, double localX, double localY) {
                return ((Camera) node).doComputeContains(localX, localY);
            }

            @Override
            public Point2D project(Camera camera, Point3D p) {
                return camera.project(p);
            }

            @Override
            public Point2D pickNodeXYPlane(Camera camera, Node node, double x, double y) {
                return camera.pickNodeXYPlane(node, x, y);
            }

            @Override
            public Point3D pickProjectPlane(Camera camera, double x, double y) {
                return camera.pickProjectPlane(x, y);
            }
        });
    }

    private Affine3D localToSceneTx = new Affine3D();

    {
        // To initialize the class helper at the begining each constructor of this class
        CameraHelper.initHelper(this);
    }

    protected Camera() {
        InvalidationListener dirtyTransformListener = observable
                -&gt; NodeHelper.markDirty(this, DirtyBits.NODE_CAMERA_TRANSFORM);

        this.localToSceneTransformProperty().addListener(dirtyTransformListener);
        // if camera is removed from scene it needs to stop using its transforms
        this.sceneProperty().addListener(dirtyTransformListener);
    }

    // NOTE: farClipInScene and nearClipInScene are valid only if there is no rotation
    private double farClipInScene;
    private double nearClipInScene;

    // only one of them can be non-null at a time
    private Scene ownerScene = null;
    private SubScene ownerSubScene = null;

    private GeneralTransform3D projViewTx = new GeneralTransform3D();
    private GeneralTransform3D projTx = new GeneralTransform3D();
    private Affine3D viewTx = new Affine3D();
    private double viewWidth = 1.0;
    private double viewHeight = 1.0;
    private Vec3d position = new Vec3d();

<A NAME="35"></A>    private boolean clipInSceneValid = false;
    private boolean projViewTxValid = false;
    private boolean localToSceneValid = false;
    <FONT color="#41a317"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#35',2,'match31-top.html#35',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>private boolean sceneToLocalValid = false;

    double getFarClipInScene() {
        updateClipPlane();
        return farClipInScene;
    }

    double getNearClipInScene() {</B></FONT>
        updateClipPlane();
        return nearClipInScene;
    }

    private void updateClipPlane() {
        if (!clipInSceneValid) {
            final Transform localToSceneTransform = getLocalToSceneTransform();
            nearClipInScene = localToSceneTransform.transform(0, 0, getNearClip()).getZ();
            farClipInScene = localToSceneTransform.transform(0, 0, getFarClip()).getZ();
            clipInSceneValid = true;
        }
    }

    /**
     * An affine transform that holds the computed scene-to-local transform.
     * It is used to convert node to camera coordinate when rotation is involved.
     */
    private Affine3D sceneToLocalTx = new Affine3D();

    Affine3D getSceneToLocalTransform() {
        if (!sceneToLocalValid) {
            sceneToLocalTx.setTransform(getCameraTransform());
            try {
                sceneToLocalTx.invert();
            } catch (NoninvertibleTransformException ex) {
                String logname = Camera.class.getName();
                PlatformLogger.getLogger(logname).severe(&quot;getSceneToLocalTransform&quot;, ex);
                sceneToLocalTx.setToIdentity();
            }
            sceneToLocalValid = true;
        }

        return sceneToLocalTx;
    }

    /**
     * Specifies the distance from the eye of the near clipping plane of
     * this {@code Camera} in the eye coordinate space.
     * Objects closer to the eye than {@code nearClip} are not drawn.
     * {@code nearClip} is specified as a value greater than zero. A value less
     * than or equal to zero is treated as a very small positive number.
     *
     * @defaultValue 0.1
     * @since JavaFX 8.0
     */
    private DoubleProperty nearClip;

    public final void setNearClip(double value){
        nearClipProperty().set(value);
    }

    public final double getNearClip() {
        return nearClip == null ? 0.1 : nearClip.get();
    }

    public final DoubleProperty nearClipProperty() {
        if (nearClip == null) {
            nearClip = new SimpleDoubleProperty(Camera.this, &quot;nearClip&quot;, 0.1) {
                @Override
                protected void invalidated() {
                    clipInSceneValid = false;
                    NodeHelper.markDirty(Camera.this, DirtyBits.NODE_CAMERA);
                }
            };
        }
        return nearClip;
    }

    /**
     * Specifies the distance from the eye of the far clipping plane of
     * this {@code Camera} in the eye coordinate space.
     * Objects farther away from the eye than {@code farClip} are not
     * drawn.
     * {@code farClip} is specified as a value greater than {@code nearClip}.
     * A value less than or equal to {@code nearClip} is treated as
     * {@code nearClip} plus a very small positive number.
     *
     * @defaultValue 100.0
     * @since JavaFX 8.0
     */
    private DoubleProperty farClip;

    public final void setFarClip(double value){
        farClipProperty().set(value);
    }

    public final double getFarClip() {
        return farClip == null ? 100.0 : farClip.get();
    }

    public final DoubleProperty farClipProperty() {
        if (farClip == null) {
            farClip = new SimpleDoubleProperty(Camera.this, &quot;farClip&quot;, 100.0) {
                @Override
                protected void invalidated() {
                    clipInSceneValid = false;
                    NodeHelper.markDirty(Camera.this, DirtyBits.NODE_CAMERA);
                }
            };
        }
        return farClip;
    }

    Camera copy() {
        return this;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        NGCamera peer = getPeer();
        if (!NodeHelper.isDirtyEmpty(this)) {
            if (isDirty(DirtyBits.NODE_CAMERA)) {
                peer.setNearClip((float) getNearClip());
                peer.setFarClip((float) getFarClip());
                peer.setViewWidth(getViewWidth());
                peer.setViewHeight(getViewHeight());
            }
            if (isDirty(DirtyBits.NODE_CAMERA_TRANSFORM)) {
                // TODO: 3D - For now, we are treating the scene as world.
                // This may need to change for the fixed eye position case.
                peer.setWorldTransform(getCameraTransform());
            }

            peer.setProjViewTransform(getProjViewTransform());

            position = computePosition(position);
            getCameraTransform().transform(position, position);
            peer.setPosition(position);
        }
    }

    void setViewWidth(double width) {
        this.viewWidth = width;
        NodeHelper.markDirty(this, DirtyBits.NODE_CAMERA);
    }

    double getViewWidth() {
        return viewWidth;
    }

    void setViewHeight(double height) {
        this.viewHeight = height;
        NodeHelper.markDirty(this, DirtyBits.NODE_CAMERA);
    }

    double getViewHeight() {
        return viewHeight;
    }

    void setOwnerScene(Scene s) {
        if (s == null) {
            ownerScene = null;
        } else if (s != ownerScene) {
            if (ownerScene != null || ownerSubScene != null) {
                throw new IllegalArgumentException(this
                        + &quot;is already set as camera in other scene or subscene&quot;);
            }
            ownerScene = s;
            markOwnerDirty();
        }
    }

    void setOwnerSubScene(SubScene s) {
        if (s == null) {
            ownerSubScene = null;
        } else if (s != ownerSubScene) {
            if (ownerScene != null || ownerSubScene != null) {
                throw new IllegalArgumentException(this
                        + &quot;is already set as camera in other scene or subscene&quot;);
            }
            ownerSubScene = s;
            markOwnerDirty();
        }
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doMarkDirty(DirtyBits dirtyBit) {
        if (dirtyBit == DirtyBits.NODE_CAMERA_TRANSFORM) {
            localToSceneValid = false;
            sceneToLocalValid = false;
            clipInSceneValid = false;
            projViewTxValid = false;
        } else if (dirtyBit == DirtyBits.NODE_CAMERA) {
            projViewTxValid = false;
        }
        markOwnerDirty();
    }

    private void markOwnerDirty() {
        // if the camera is part of the scene/subScene, we will need to notify
        // the owner to mark the entire scene/subScene dirty.
        if (ownerScene != null) {
            ownerScene.markCameraDirty();
        }
        if (ownerSubScene != null) {
            ownerSubScene.markContentDirty();
        }
    }

    /**
     * Returns the local-to-scene transform of this camera.
     * Package private, for use in our internal subclasses.
     * Returns directly the internal instance, it must not be altered.
     */
    Affine3D getCameraTransform() {
        if (!localToSceneValid) {
            localToSceneTx.setToIdentity();
            TransformHelper.apply(getLocalToSceneTransform(), localToSceneTx);
            localToSceneValid = true;
        }
        return localToSceneTx;
    }

    abstract void computeProjectionTransform(GeneralTransform3D proj);
    abstract void computeViewTransform(Affine3D view);

    /**
     * Returns the projView transform of this camera.
     * Package private, for internal use.
     * Returns directly the internal instance, it must not be altered.
     */
    GeneralTransform3D getProjViewTransform() {
        if (!projViewTxValid) {
            computeProjectionTransform(projTx);
            computeViewTransform(viewTx);

            projViewTx.set(projTx);
            projViewTx.mul(viewTx);
            projViewTx.mul(getSceneToLocalTransform());

            projViewTxValid = true;
        }

        return projViewTx;
    }

    /**
     * Transforms the given 3D point to the flat projected coordinates.
     */
    private Point2D project(Point3D p) {

        final Vec3d vec = getProjViewTransform().transform(new Vec3d(
                p.getX(), p.getY(), p.getZ()));

        final double halfViewWidth = getViewWidth() / 2.0;
        final double halfViewHeight = getViewHeight() / 2.0;

        return new Point2D(
                halfViewWidth * (1 + vec.x),
                halfViewHeight * (1 - vec.y));
    }

    /**
     * Computes intersection point of the pick ray cast by the given coordinates
     * and the node's local XY plane.
     */
    private Point2D pickNodeXYPlane(Node node, double x, double y) {
        final PickRay ray = computePickRay(x, y, null);

        final Affine3D localToScene = new Affine3D();
        TransformHelper.apply(node.getLocalToSceneTransform(), localToScene);

        final Vec3d o = ray.getOriginNoClone();
        final Vec3d d = ray.getDirectionNoClone();

        try {
            localToScene.inverseTransform(o, o);
            localToScene.inverseDeltaTransform(d, d);
        } catch (NoninvertibleTransformException e) {
            return null;
        }

        if (almostZero(d.z)) {
            return null;
        }

        final double t = -o.z / d.z;
        return new Point2D(o.x + (d.x * t), o.y + (d.y * t));
    }

    /**
     * Computes intersection point of the pick ray cast by the given coordinates
     * and the projection plane.
     */
    Point3D pickProjectPlane(double x, double y) {
        final PickRay ray = computePickRay(x, y, null);
        final Vec3d p = new Vec3d();
        p.add(ray.getOriginNoClone(), ray.getDirectionNoClone());

        return new Point3D(p.x, p.y, p.z);
    }


    /**
     * Computes pick ray for the content rendered by this camera.
     * @param x horizontal coordinate of the pick ray in the projected
     *               view, usually mouse cursor position
     * @param y vertical coordinate of the pick ray in the projected
     *               view, usually mouse cursor position
     * @param pickRay pick ray to be reused. New instance is created in case
     *                of null.
     * @return The PickRay instance computed based on this camera and the given
     *         arguments.
     */
    abstract PickRay computePickRay(double x, double y, PickRay pickRay);

    /**
     * Computes local position of the camera in the scene.
     * @param position Position to be reused. New instance is created in case
     *                 of null.
     * @return The position of the camera in the scene in camera local coords
     */
    abstract Vec3d computePosition(Vec3d position);

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {
        return new BoxBounds(0, 0, 0, 0, 0, 0);
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeContains(double localX, double localY) {
        return false;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/canvas/GraphicsContext.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.canvas;

import com.sun.javafx.geom.Arc2D;
import com.sun.javafx.geom.IllegalPathStateException;
import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.PathIterator;
import com.sun.javafx.geom.transform.Affine2D;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.javafx.image.*;
import com.sun.javafx.image.impl.ByteBgraPre;
import com.sun.javafx.sg.prism.GrowableDataBuffer;
import com.sun.javafx.sg.prism.NGCanvas;
import com.sun.javafx.scene.text.FontHelper;
import com.sun.javafx.tk.Toolkit;
import com.sun.scenario.effect.EffectHelper;
import javafx.geometry.NodeOrientation;
import javafx.geometry.VPos;
import javafx.scene.effect.Blend;
import javafx.scene.effect.BlendMode;
import javafx.scene.effect.Effect;
import javafx.scene.image.Image;
import javafx.scene.image.PixelFormat;
import javafx.scene.image.PixelReader;
import javafx.scene.image.PixelWriter;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.scene.shape.ArcType;
import javafx.scene.shape.FillRule;
import javafx.scene.shape.StrokeLineCap;
import javafx.scene.shape.StrokeLineJoin;
import javafx.scene.text.Font;
import javafx.scene.text.TextAlignment;
import javafx.scene.transform.Affine;

import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.util.Arrays;
import java.util.LinkedList;
import javafx.scene.text.FontSmoothingType;

/**
 * This class is used to issue draw calls to a {@link Canvas} using a buffer.
 * &lt;p&gt;
 * Each call pushes the necessary parameters onto the buffer
 * where they will be later rendered onto the image of the {@code Canvas} node
 * by the rendering thread at the end of a pulse.
 * &lt;p&gt;
 * A {@code Canvas} only contains one {@code GraphicsContext}, and only one buffer.
 * If it is not attached to any scene, then it can be modified by any thread,
 * as long as it is only used from one thread at a time. Once a {@code Canvas}
 * node is attached to a scene, it must be modified on the JavaFX Application
 * Thread.
 * &lt;p&gt;
 * Calling any method on the {@code GraphicsContext} is considered modifying
 * its corresponding {@code Canvas} and is subject to the same threading
 * rules.
 * &lt;p&gt;
 * A {@code GraphicsContext} also manages a stack of state objects that can
 * be saved or restored at anytime.
 * &lt;p&gt;
 * The {@code GraphicsContext} maintains the following rendering attributes
 * which affect various subsets of the rendering methods:
 * &lt;table class=&quot;overviewSummary&quot; style=&quot;width:80%; margin-left:auto; margin-right:auto&quot;&gt;
 * &lt;caption&gt;List of Rendering Attributes&lt;/caption&gt;
 * &lt;tr&gt;
 * &lt;th class=&quot;colLast&quot; style=&quot;width:15%&quot; scope=&quot;col&quot;&gt;Attribute&lt;/th&gt;
 * &lt;th class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot; scope=&quot;col&quot;&gt;Save/Restore?&lt;/th&gt;
 * &lt;th class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot; scope=&quot;col&quot;&gt;Default value&lt;/th&gt;
 * &lt;th class=&quot;colLast&quot; scope=&quot;col&quot;&gt;Description&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th colspan=&quot;3&quot; scope=&quot;row&quot;&gt;&lt;a id=&quot;comm-attr&quot;&gt;Common Rendering Attributes&lt;/a&gt;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #clip() Clip}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;No clipping&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * An anti-aliased intersection of various clip paths to which rendering
 * is restricted.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setGlobalAlpha(double) Global Alpha}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@code 1.0}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * An opacity value that controls the visibility or fading of each rendering
 * operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setGlobalBlendMode(javafx.scene.effect.BlendMode) Global Blend Mode}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link BlendMode#SRC_OVER SRC_OVER}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * A {@link BlendMode} enum value that controls how pixels from each rendering
 * operation are composited into the existing image.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setTransform(javafx.scene.transform.Affine) Transform}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@code Identity}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * A 3x2 2D affine transformation matrix that controls how coordinates are
 * mapped onto the logical pixels of the canvas image.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setEffect(javafx.scene.effect.Effect) Effect}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@code null}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * An {@link Effect} applied individually to each rendering operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th colspan=&quot;3&quot; scope=&quot;row&quot;&gt;&lt;a id=&quot;fill-attr&quot;&gt;Fill Attributes&lt;/a&gt;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setFill(javafx.scene.paint.Paint) Fill Paint}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link Color#BLACK BLACK}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The {@link Paint} to be applied to the interior of shapes in a
 * fill operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th colspan=&quot;3&quot; scope=&quot;row&quot;&gt;&lt;a id=&quot;strk-attr&quot;&gt;Stroke Attributes&lt;/a&gt;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setStroke(javafx.scene.paint.Paint) Stroke Paint}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link Color#BLACK BLACK}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The {@link Paint} to be applied to the boundary of shapes in a
 * stroke operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setLineWidth(double) Line Width}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@code 1.0}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The width of the stroke applied to the boundary of shapes in a
 * stroke operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setLineCap(javafx.scene.shape.StrokeLineCap) Line Cap}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link StrokeLineCap#SQUARE SQUARE}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The style of the end caps applied to the beginnings and ends of each
 * dash and/or subpath in a stroke operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setLineJoin(javafx.scene.shape.StrokeLineJoin) Line Join}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link StrokeLineJoin#MITER MITER}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The style of the joins applied between individual segments in the boundary
 * paths of shapes in a stroke operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setMiterLimit(double) Miter Limit}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@code 10.0}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The ratio limit of how far a {@link StrokeLineJoin#MITER MITER} line join
 * may extend in the direction of a sharp corner between segments in the
 * boundary path of a shape, relative to the line width, before it is truncated
 * to a {@link StrokeLineJoin#BEVEL BEVEL} join in a stroke operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setLineDashes(double...) Dashes}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@code null}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The array of dash lengths to be applied to the segments in the boundary
 * of shapes in a stroke operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setLineDashOffset(double) Dash Offset}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@code 0.0}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The distance offset into the array of dash lengths at which to start the
 * dashing of the segments in the boundary of shapes in a stroke operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th colspan=&quot;3&quot; scope=&quot;row&quot;&gt;&lt;a id=&quot;text-attr&quot;&gt;Text Attributes&lt;/a&gt;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setFont(javafx.scene.text.Font) Font}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link Font#getDefault() Default Font}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The font used for all fill and stroke text operations.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setTextAlign(javafx.scene.text.TextAlignment) Text Align}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link TextAlignment#LEFT LEFT}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The horizontal alignment of text with respect to the {@code X} coordinate
 * specified in the text operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setTextBaseline(javafx.geometry.VPos) Text Baseline}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link VPos#BASELINE BASELINE}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The vertical position of the text relative to the {@code Y} coordinate
 * specified in the text operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setFontSmoothingType(javafx.scene.text.FontSmoothingType) Font Smoothing}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link FontSmoothingType#GRAY GRAY}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The type of smoothing (antialiasing) applied to the glyphs in the font
 * for all fill text operations.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th colspan=&quot;3&quot; scope=&quot;row&quot;&gt;&lt;a id=&quot;path-attr&quot;&gt;Path Attributes&lt;/a&gt;&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #beginPath() Current Path}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;Empty path&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The path constructed using various path construction methods to be used
 * in various path filling, stroking, or clipping operations.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:15%&quot;&gt;{@link #setFillRule(javafx.scene.shape.FillRule) Fill Rule}&lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:10%; text-align:center&quot;&gt;{@link FillRule#NON_ZERO NON_ZERO}&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot;&gt;
 * The method used to determine the interior of paths for a path fill or
 * clip operation.
 * &lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;p&gt;
 * &lt;a id=&quot;attr-ops-table&quot;&gt;
 * The various rendering methods on the {@code GraphicsContext} use the
 * following sets of rendering attributes:
 * &lt;/a&gt;
 * &lt;table class=&quot;overviewSummary&quot; style=&quot;width:80%; margin-left:auto; margin-right:auto&quot;&gt;
 * &lt;caption&gt;Rendering Attributes Table&lt;/caption&gt;
 * &lt;tr&gt;
 * &lt;th scope=&quot;col&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;Method&lt;/th&gt;
 * &lt;th scope=&quot;col&quot; class=&quot;colLast&quot; style=&quot;width:15%; text-align:center&quot;&gt;&lt;a href=&quot;#comm-attr&quot;&gt;Common Rendering Attributes&lt;/a&gt;&lt;/th&gt;
 * &lt;th scope=&quot;col&quot; class=&quot;colLast&quot; style=&quot;width:15%; text-align:center&quot;&gt;&lt;a href=&quot;#fill-attr&quot;&gt;Fill Attributes&lt;/a&gt;&lt;/th&gt;
 * &lt;th scope=&quot;col&quot; class=&quot;colLast&quot; style=&quot;width:15%; text-align:center&quot;&gt;&lt;a href=&quot;#strk-attr&quot;&gt;Stroke Attributes&lt;/a&gt;&lt;/th&gt;
 * &lt;th scope=&quot;col&quot; class=&quot;colLast&quot; style=&quot;width:15%; text-align:center&quot;&gt;&lt;a href=&quot;#text-attr&quot;&gt;Text Attributes&lt;/a&gt;&lt;/th&gt;
 * &lt;th scope=&quot;col&quot; class=&quot;colLast&quot; style=&quot;width:15%; text-align:center&quot;&gt;&lt;a href=&quot;#path-attr&quot;&gt;Path Attributes&lt;/a&gt;&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th colspan=&quot;1&quot; scope=&quot;row&quot;&gt;Basic Shape Rendering&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #fillRect(double, double, double, double) fillRect()},
 * {@link #fillRoundRect(double, double, double, double, double, double) fillRoundRect()},
 * {@link #fillOval(double, double, double, double) fillOval()},
 * {@link #fillArc(double, double, double, double, double, double, javafx.scene.shape.ArcType) fillArc()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #strokeLine(double, double, double, double) strokeLine()},
 * {@link #strokeRect(double, double, double, double) strokeRect()},
 * {@link #strokeRoundRect(double, double, double, double, double, double) strokeRoundRect()},
 * {@link #strokeOval(double, double, double, double) strokeOval()},
 * {@link #strokeArc(double, double, double, double, double, double, javafx.scene.shape.ArcType) strokeArc()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #clearRect(double, double, double, double) clearRect()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes &lt;a href=&quot;#base-fn-1&quot;&gt;[1]&lt;/a&gt;&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #fillPolygon(double[], double[], int) fillPolygon()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes &lt;a href=&quot;#base-fn-2&quot;&gt;[2]&lt;/a&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #strokePolygon(double[], double[], int) strokePolygon()},
 * {@link #strokePolyline(double[], double[], int) strokePolyline()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot; colspan=&quot;6&quot;&gt;
 * &lt;a id=&quot;base-fn-1&quot;&gt;[1]&lt;/a&gt; Only the Transform, Clip, and Effect apply to clearRect()&lt;br&gt;
 * &lt;a id=&quot;base-fn-2&quot;&gt;[2]&lt;/a&gt; Only the Fill Rule applies to fillPolygon(), the current path is left unchanged
 * &lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th colspan=&quot;1&quot; scope=&quot;row&quot;&gt;Text Rendering&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #fillText(java.lang.String, double, double) fillText()},
 * {@link #fillText(java.lang.String, double, double, double) fillText(with maxWidth)}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes &lt;a href=&quot;#text-fn-3&quot;&gt;[3]&lt;/a&gt;&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #strokeText(java.lang.String, double, double) strokeText()},
 * {@link #strokeText(java.lang.String, double, double, double) strokeText(with maxWidth)}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes &lt;a href=&quot;#text-fn-3&quot;&gt;[3]&lt;/a&gt;&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot; colspan=&quot;6&quot;&gt;
 * &lt;a id=&quot;text-fn-3&quot;&gt;[3]&lt;/a&gt; The Font Smoothing attribute only applies to filled text
 * &lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th colspan=&quot;1&quot; scope=&quot;row&quot;&gt;Path Rendering&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #beginPath() beginPath()},
 * {@link #moveTo(double, double) moveTo()},
 * {@link #lineTo(double, double) lineTo()},
 * {@link #quadraticCurveTo(double, double, double, double) quadraticCurveTo()},
 * {@link #bezierCurveTo(double, double, double, double, double, double) bezierCurveTo()},
 * {@link #arc(double, double, double, double, double, double) arc()},
 * {@link #arcTo(double, double, double, double, double) arcTo()},
 * {@link #appendSVGPath(java.lang.String) appendSVGPath()},
 * {@link #closePath() closePath()},
 * {@link #rect(double, double, double, double) rect()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes &lt;a href=&quot;#path-fn-4&quot;&gt;[4]&lt;/a&gt;&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #fill() fill()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes &lt;a href=&quot;#path-fn-4&quot;&gt;[4]&lt;/a&gt;&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #stroke() stroke()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes &lt;a href=&quot;#path-fn-4&quot;&gt;[4]&lt;/a&gt;&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes &lt;a href=&quot;#path-fn-5&quot;&gt;[5]&lt;/a&gt;&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #clip() clip()}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot; colspan=&quot;6&quot;&gt;
 * &lt;a id=&quot;path-fn-4&quot;&gt;[4]&lt;/a&gt; Transform applied only during path construction&lt;br&gt;
 * &lt;a id=&quot;path-fn-5&quot;&gt;[5]&lt;/a&gt; Fill Rule only used for fill() and clip()
 * &lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot; colspan=&quot;1&quot;&gt;Image Rendering&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #drawImage(javafx.scene.image.Image, double, double) drawImage(all forms)}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#0c0&quot;&gt;Yes&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot; colspan=&quot;1&quot;&gt;Miscellaneous&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;th scope=&quot;row&quot; class=&quot;colLast&quot; style=&quot;width:25%&quot;&gt;
 * {@link #applyEffect(javafx.scene.effect.Effect) applyEffect()},
 * {@link #getPixelWriter() PixelWriter methods}
 * &lt;/th&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;td class=&quot;colLast&quot; style=&quot;width:15%; text-align:center; color:#c00&quot;&gt;No&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;p&gt;Example:&lt;/p&gt;
 *
 * &lt;pre&gt;
 * import javafx.scene.*;
 * import javafx.scene.paint.*;
 * import javafx.scene.canvas.*;
 *
 * Group root = new Group();
 * Scene s = new Scene(root, 300, 300, Color.BLACK);
 *
 * final Canvas canvas = new Canvas(250,250);
 * GraphicsContext gc = canvas.getGraphicsContext2D();
 *
 * gc.setFill(Color.BLUE);
 * gc.fillRect(75,75,100,100);
 *
 * root.getChildren().add(canvas);
 * &lt;/pre&gt;
 *
 * @see Canvas
 * @since JavaFX 2.2
 */
public final class GraphicsContext {
    Canvas theCanvas;
    Path2D path;
    boolean pathDirty;

    State curState;
    LinkedList&lt;State&gt; stateStack;
    LinkedList&lt;Path2D&gt; clipStack;

    GraphicsContext(Canvas theCanvas) {
        this.theCanvas = theCanvas;
        this.path = new Path2D();
        pathDirty = true;

        this.curState = new State();
        this.stateStack = new LinkedList&lt;State&gt;();
        this.clipStack = new LinkedList&lt;Path2D&gt;();
    }

    static class State {
        double globalAlpha;
        BlendMode blendop;
        Affine2D transform;
        Paint fill;
        Paint stroke;
        double linewidth;
        StrokeLineCap linecap;
        StrokeLineJoin linejoin;
        double miterlimit;
        double dashes[];
        double dashOffset;
        int numClipPaths;
        Font font;
        FontSmoothingType fontsmoothing;
        TextAlignment textalign;
        VPos textbaseline;
        Effect effect;
        FillRule fillRule;

        State() {
            init();
        }

        final void init() {
            set(1.0, BlendMode.SRC_OVER,
                new Affine2D(),
                Color.BLACK, Color.BLACK,
                1.0, StrokeLineCap.SQUARE, StrokeLineJoin.MITER, 10.0,
                null, 0.0,
                0,
                Font.getDefault(), FontSmoothingType.GRAY,
                TextAlignment.LEFT, VPos.BASELINE,
                null, FillRule.NON_ZERO);
        }

        State(State copy) {
            set(copy.globalAlpha, copy.blendop,
                new Affine2D(copy.transform),
                copy.fill, copy.stroke,
                copy.linewidth, copy.linecap, copy.linejoin, copy.miterlimit,
                copy.dashes, copy.dashOffset,
                copy.numClipPaths,
                copy.font, copy.fontsmoothing, copy.textalign, copy.textbaseline,
                copy.effect, copy.fillRule);
        }

        final void set(double globalAlpha, BlendMode blendop,
                       Affine2D transform, Paint fill, Paint stroke,
                       double linewidth, StrokeLineCap linecap,
                       StrokeLineJoin linejoin, double miterlimit,
                       double dashes[], double dashOffset,
                       int numClipPaths,
                       Font font, FontSmoothingType smoothing,
                       TextAlignment align, VPos baseline,
                       Effect effect, FillRule fillRule)
        {
            this.globalAlpha = globalAlpha;
            this.blendop = blendop;
            this.transform = transform;
            this.fill = fill;
            this.stroke = stroke;
            this.linewidth = linewidth;
            this.linecap = linecap;
            this.linejoin = linejoin;
            this.miterlimit = miterlimit;
            this.dashes = dashes;
            this.dashOffset = dashOffset;
            this.numClipPaths = numClipPaths;
            this.font = font;
            this.fontsmoothing = smoothing;
            this.textalign = align;
            this.textbaseline = baseline;
            this.effect = effect;
            this.fillRule = fillRule;
        }

        State copy() {
            return new State(this);
        }

        void restore(GraphicsContext ctx) {
            ctx.setGlobalAlpha(globalAlpha);
            ctx.setGlobalBlendMode(blendop);
            ctx.setTransform(transform.getMxx(), transform.getMyx(),
                             transform.getMxy(), transform.getMyy(),
                             transform.getMxt(), transform.getMyt());
            ctx.setFill(fill);
            ctx.setStroke(stroke);
            ctx.setLineWidth(linewidth);
            ctx.setLineCap(linecap);
            ctx.setLineJoin(linejoin);
            ctx.setMiterLimit(miterlimit);
            ctx.setLineDashes(dashes);
            ctx.setLineDashOffset(dashOffset);
            GrowableDataBuffer buf = ctx.getBuffer();
            while (ctx.curState.numClipPaths &gt; numClipPaths) {
                ctx.curState.numClipPaths--;
                ctx.clipStack.removeLast();
                buf.putByte(NGCanvas.POP_CLIP);
            }
            ctx.setFillRule(fillRule);
            ctx.setFont(font);
            ctx.setFontSmoothingType(fontsmoothing);
            ctx.setTextAlign(textalign);
            ctx.setTextBaseline(textbaseline);
            ctx.setEffect(effect);
        }
    }

    private GrowableDataBuffer getBuffer() {
        return theCanvas.getBuffer();
    }

    private float coords[] = new float[6];
    private static final byte pgtype[] = {
        NGCanvas.MOVETO,
        NGCanvas.LINETO,
        NGCanvas.QUADTO,
        NGCanvas.CUBICTO,
        NGCanvas.CLOSEPATH,
    };
    private static final int numsegs[] = { 2, 2, 4, 6, 0, };

    private void markPathDirty() {
        pathDirty = true;
    }

    private void writePath(byte command) {
        updateTransform();
        GrowableDataBuffer buf = getBuffer();
        if (pathDirty) {
            buf.putByte(NGCanvas.PATHSTART);
            PathIterator pi = path.getPathIterator(null);
            while (!pi.isDone()) {
                int pitype = pi.currentSegment(coords);
                buf.putByte(pgtype[pitype]);
                for (int i = 0; i &lt; numsegs[pitype]; i++) {
                    buf.putFloat(coords[i]);
                }
                pi.next();
            }
            buf.putByte(NGCanvas.PATHEND);
            pathDirty = false;
        }
        buf.putByte(command);
    }

    private void writePaint(Paint p, byte command) {
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(command);
        buf.putObject(Toolkit.getPaintAccessor().getPlatformPaint(p));
    }

    private void writeArcType(ArcType closure) {
        byte type;
        switch (closure) {
            case OPEN:  type = NGCanvas.ARC_OPEN;  break;
            case CHORD: type = NGCanvas.ARC_CHORD; break;
            case ROUND: type = NGCanvas.ARC_PIE;   break;
            default: return;  // ignored for consistency with other attributes
        }
        writeParam(type, NGCanvas.ARC_TYPE);
    }

    private void writeRectParams(GrowableDataBuffer buf,
                                 double x, double y, double w, double h,
                                 byte command)
    {
        buf.putByte(command);
        buf.putFloat((float) x);
        buf.putFloat((float) y);
        buf.putFloat((float) w);
        buf.putFloat((float) h);
    }

    private void writeOp4(double x, double y, double w, double h, byte command) {
        updateTransform();
        writeRectParams(getBuffer(), x, y, w, h, command);
    }

    private void writeOp6(double x, double y, double w, double h,
                          double v1, double v2, byte command)
    {
        updateTransform();
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(command);
        buf.putFloat((float) x);
        buf.putFloat((float) y);
        buf.putFloat((float) w);
        buf.putFloat((float) h);
        buf.putFloat((float) v1);
        buf.putFloat((float) v2);
    }

    private float polybuf[] = new float[512];
    private void flushPolyBuf(GrowableDataBuffer buf,
                              float polybuf[], int n, byte command)
    {
        curState.transform.transform(polybuf, 0, polybuf, 0, n/2);
        for (int i = 0; i &lt; n; i += 2) {
            buf.putByte(command);
            buf.putFloat(polybuf[i]);
            buf.putFloat(polybuf[i+1]);
            command = NGCanvas.LINETO;
        }
    }
    private void writePoly(double xPoints[], double yPoints[], int nPoints,
                           boolean close, byte command)
    {
        if (xPoints == null || yPoints == null) return;
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(NGCanvas.PATHSTART);
        int pos = 0;
        byte polycmd = NGCanvas.MOVETO;
        for (int i = 0; i &lt; nPoints; i++) {
            if (pos &gt;= polybuf.length) {
                flushPolyBuf(buf, polybuf, pos, polycmd);
                pos = 0;
                polycmd = NGCanvas.LINETO;
            }
            polybuf[pos++] = (float) xPoints[i];
            polybuf[pos++] = (float) yPoints[i];
        }
        flushPolyBuf(buf, polybuf, pos, polycmd);
        if (close) {
            buf.putByte(NGCanvas.CLOSEPATH);
        }
        buf.putByte(NGCanvas.PATHEND);
        // Transform needs to be updated for rendering attributes even though
        // we have already transformed the points as we sent them.
        updateTransform();
        buf.putByte(command);
        // Now that we have changed the PG layer path, we need to mark our path dirty.
        markPathDirty();
    }

    private void writeImage(Image img,
                            double dx, double dy, double dw, double dh)
    {
        if (img == null || img.getProgress() &lt; 1.0) return;
        Object platformImg = Toolkit.getImageAccessor().getPlatformImage(img);
        if (platformImg == null) return;
        updateTransform();
        GrowableDataBuffer buf = getBuffer();
        writeRectParams(buf, dx, dy, dw, dh, NGCanvas.DRAW_IMAGE);
        buf.putObject(platformImg);
    }

    private void writeImage(Image img,
                            double dx, double dy, double dw, double dh,
                            double sx, double sy, double sw, double sh)
    {
        if (img == null || img.getProgress() &lt; 1.0) return;
        Object platformImg = Toolkit.getImageAccessor().getPlatformImage(img);
        if (platformImg == null) return;
        updateTransform();
        GrowableDataBuffer buf = getBuffer();
        writeRectParams(buf, dx, dy, dw, dh, NGCanvas.DRAW_SUBIMAGE);
        buf.putFloat((float) sx);
        buf.putFloat((float) sy);
        buf.putFloat((float) sw);
        buf.putFloat((float) sh);
        buf.putObject(platformImg);
    }

    private void writeText(String text, double x, double y, double maxWidth,
                           byte command)
    {
        if (text == null) return;
        updateTransform();
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(command);
        buf.putFloat((float) x);
        buf.putFloat((float) y);
        buf.putFloat((float) maxWidth);
        buf.putBoolean(theCanvas.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT);
        buf.putObject(text);
    }

    void writeParam(double v, byte command) {
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(command);
        buf.putFloat((float) v);
    }

    private void writeParam(byte v, byte command) {
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(command);
        buf.putByte(v);
    }

    private boolean txdirty;
    private void updateTransform() {
        if (txdirty) {
            txdirty = false;
            GrowableDataBuffer buf = getBuffer();
            buf.putByte(NGCanvas.TRANSFORM);
            buf.putDouble(curState.transform.getMxx());
            buf.putDouble(curState.transform.getMxy());
            buf.putDouble(curState.transform.getMxt());
            buf.putDouble(curState.transform.getMyx());
            buf.putDouble(curState.transform.getMyy());
            buf.putDouble(curState.transform.getMyt());
        }
    }

    void updateDimensions() {
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(NGCanvas.SET_DIMS);
        buf.putFloat((float) theCanvas.getWidth());
        buf.putFloat((float) theCanvas.getHeight());
    }

    private void reset() {
        GrowableDataBuffer buf = getBuffer();
        // Only reset if we have a significant amount of data to omit,
        // this prevents a common occurrence of &quot;setFill(bg); fillRect();&quot;
        // at the start of a session from invoking a reset.
        // But, do a reset anyway if the rendering layer has been falling
        // behind because that lets the synchronization step throw out the
        // older buffers that have been backing up.
        if (buf.writeValuePosition() &gt; Canvas.DEFAULT_VAL_BUF_SIZE ||
            theCanvas.isRendererFallingBehind())
        {
            buf.reset();
            buf.putByte(NGCanvas.RESET);
            updateDimensions();
            txdirty = true;
            pathDirty = true;
            State s = this.curState;
            int numClipPaths = this.curState.numClipPaths;
            this.curState = new State();
            for (int i = 0; i &lt; numClipPaths; i++) {
                Path2D clip = clipStack.get(i);
                buf.putByte(NGCanvas.PUSH_CLIP);
                buf.putObject(clip);
            }
            this.curState.numClipPaths = numClipPaths;
            s.restore(this);
        }
    }

    private void resetIfCovers(Paint p, double x, double y, double w, double h) {
        Affine2D tx = this.curState.transform;
        if (tx.isTranslateOrIdentity()) {
            x += tx.getMxt();
            y += tx.getMyt();
            if (x &gt; 0 || y &gt; 0 ||
                (x+w) &lt; theCanvas.getWidth() ||
                (y+h) &lt; theCanvas.getHeight())
            {
                return;
            }
        } else {
//          quad test for coverage...?
            return;
        }
        if (p != null) {
            if (this.curState.blendop != BlendMode.SRC_OVER) return;
            if (!p.isOpaque() || this.curState.globalAlpha &lt; 1.0) return;
        }
        if (this.curState.numClipPaths &gt; 0) return;
        if (this.curState.effect != null) return;
        reset();
    }

    /**
    * Gets the {@code Canvas} that the {@code GraphicsContext} is issuing draw
    * commands to. There is only ever one {@code Canvas} for a
    * {@code GraphicsContext}.
    *
    * @return Canvas the canvas that this {@code GraphicsContext} is issuing draw
    * commands to.
    */
    public Canvas getCanvas() {
        return theCanvas;
    }

    /**
     * Saves the following attributes onto a stack.
     * &lt;ul&gt;
     *     &lt;li&gt;Global Alpha&lt;/li&gt;
     *     &lt;li&gt;Global Blend Operation&lt;/li&gt;
     *     &lt;li&gt;Transform&lt;/li&gt;
     *     &lt;li&gt;Fill Paint&lt;/li&gt;
     *     &lt;li&gt;Stroke Paint&lt;/li&gt;
     *     &lt;li&gt;Line Width&lt;/li&gt;
     *     &lt;li&gt;Line Cap&lt;/li&gt;
     *     &lt;li&gt;Line Join&lt;/li&gt;
     *     &lt;li&gt;Miter Limit&lt;/li&gt;
     *     &lt;li&gt;Clip&lt;/li&gt;
     *     &lt;li&gt;Font&lt;/li&gt;
     *     &lt;li&gt;Text Align&lt;/li&gt;
     *     &lt;li&gt;Text Baseline&lt;/li&gt;
     *     &lt;li&gt;Effect&lt;/li&gt;
     *     &lt;li&gt;Fill Rule&lt;/li&gt;
     * &lt;/ul&gt;
     * This method does NOT alter the current state in any way. Also, note that
     * the current path is not saved.
     */
    public void save() {
        stateStack.push(curState.copy());
    }

    /**
     * Pops the state off of the stack, setting the following attributes to their
     * value at the time when that state was pushed onto the stack. If the stack
     * is empty then nothing is changed.
     *
     * &lt;ul&gt;
     *     &lt;li&gt;Global Alpha&lt;/li&gt;
     *     &lt;li&gt;Global Blend Operation&lt;/li&gt;
     *     &lt;li&gt;Transform&lt;/li&gt;
     *     &lt;li&gt;Fill Paint&lt;/li&gt;
     *     &lt;li&gt;Stroke Paint&lt;/li&gt;
     *     &lt;li&gt;Line Width&lt;/li&gt;
     *     &lt;li&gt;Line Cap&lt;/li&gt;
     *     &lt;li&gt;Line Join&lt;/li&gt;
     *     &lt;li&gt;Miter Limit&lt;/li&gt;
     *     &lt;li&gt;Clip&lt;/li&gt;
     *     &lt;li&gt;Font&lt;/li&gt;
     *     &lt;li&gt;Text Align&lt;/li&gt;
     *     &lt;li&gt;Text Baseline&lt;/li&gt;
     *     &lt;li&gt;Effect&lt;/li&gt;
     *     &lt;li&gt;Fill Rule&lt;/li&gt;
     * &lt;/ul&gt;
     * Note that the current path is not restored.
     */
    public void restore() {
        if (!stateStack.isEmpty()) {
            State savedState = stateStack.pop();
            savedState.restore(this);
            txdirty = true;
        }
    }

    /**
     * Translates the current transform by x, y.
     * @param x value to translate along the x axis.
     * @param y value to translate along the y axis.
     */
    public void translate(double x, double y) {
        curState.transform.translate(x, y);
        txdirty = true;
    }

    /**
     * Scales the current transform by x, y.
     * @param x value to scale in the x axis.
     * @param y value to scale in the y axis.
     */
    public void scale(double x, double y) {
        curState.transform.scale(x, y);
        txdirty = true;
    }

    /**
     * Rotates the current transform in degrees.
     * @param degrees value in degrees to rotate the current transform.
     */
    public void rotate(double degrees) {
        curState.transform.rotate(Math.toRadians(degrees));
        txdirty = true;
    }

    /**
     * Concatenates the input with the current transform.
     *
     * @param mxx - the X coordinate scaling element of the 3x4 matrix
     * @param myx - the Y coordinate shearing element of the 3x4 matrix
     * @param mxy - the X coordinate shearing element of the 3x4 matrix
     * @param myy - the Y coordinate scaling element of the 3x4 matrix
     * @param mxt - the X coordinate translation element of the 3x4 matrix
     * @param myt - the Y coordinate translation element of the 3x4 matrix
     */
    public void transform(double mxx, double myx,
                          double mxy, double myy,
                          double mxt, double myt)
    {
        curState.transform.concatenate(mxx, mxy, mxt,
                                       myx, myy, myt);
        txdirty = true;
    }

    /**
     * Concatenates the input with the current transform. Only 2D transforms are
     * supported. The only values used are the X and Y scaling, translation, and
     * shearing components of a transform. A {@code null} value is treated as identity.
     *
     * @param xform The affine to be concatenated with the current transform or null.
     */
    public void transform(Affine xform) {
        if (xform == null) return;
        curState.transform.concatenate(xform.getMxx(), xform.getMxy(), xform.getTx(),
                                       xform.getMyx(), xform.getMyy(), xform.getTy());
        txdirty = true;
    }

    /**
     * Sets the current transform.
     * @param mxx - the X coordinate scaling element of the 3x4 matrix
     * @param myx - the Y coordinate shearing element of the 3x4 matrix
     * @param mxy - the X coordinate shearing element of the 3x4 matrix
     * @param myy - the Y coordinate scaling element of the 3x4 matrix
     * @param mxt - the X coordinate translation element of the 3x4 matrix
     * @param myt - the Y coordinate translation element of the 3x4 matrix
     */
    public void setTransform(double mxx, double myx,
                             double mxy, double myy,
                             double mxt, double myt)
    {
        curState.transform.setTransform(mxx, myx,
                                        mxy, myy,
                                        mxt, myt);
        txdirty = true;
    }

    /**
     * Sets the current transform. Only 2D transforms are supported. The only
     * values used are the X and Y scaling, translation, and shearing components
     * of a transform.
     *
     * @param xform The affine to be copied and used as the current transform.
     */
    public void setTransform(Affine xform) {
        curState.transform.setTransform(xform.getMxx(), xform.getMyx(),
                                        xform.getMxy(), xform.getMyy(),
                                        xform.getTx(), xform.getTy());
        txdirty = true;
    }

    /**
     * Copies the current transform into the supplied object, creating
     * a new {@link Affine} object if it is null, and returns the object
     * containing the copy.
     *
     * @param xform A transform object that will be used to hold the result.
     * If xform is non null, then this method will copy the current transform
     * into that object. If xform is null a new transform object will be
     * constructed. In either case, the return value is a copy of the current
     * transform.
     *
     * @return A copy of the current transform.
     */
    public Affine getTransform(Affine xform) {
        if (xform == null) {
            xform = new Affine();
        }

        xform.setMxx(curState.transform.getMxx());
        xform.setMxy(curState.transform.getMxy());
        xform.setMxz(0);
        xform.setTx(curState.transform.getMxt());
        xform.setMyx(curState.transform.getMyx());
        xform.setMyy(curState.transform.getMyy());
        xform.setMyz(0);
        xform.setTy(curState.transform.getMyt());
        xform.setMzx(0);
        xform.setMzy(0);
        xform.setMzz(1);
        xform.setTz(0);

        return xform;
    }

    /**
     * Returns a copy of the current transform.
     *
     * @return a copy of the transform of the current state.
     */
    public Affine getTransform() {
        return getTransform(null);
    }

    /**
     * Sets the global alpha of the current state.
     * The default value is {@code 1.0}.
     * Any valid double can be set, but only values in the range
     * {@code [0.0, 1.0]} are valid and the nearest value in that
     * range will be used for rendering.
     * The global alpha is a &lt;a href=&quot;#comm-attr&quot;&gt;common attribute&lt;/a&gt;
     * used for nearly all rendering methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @param alpha the new alpha value, clamped to {@code [0.0, 1.0]}
     *              during actual use.
     */
    public void setGlobalAlpha(double alpha) {
        if (curState.globalAlpha != alpha) {
            curState.globalAlpha = alpha;
            alpha = (alpha &gt; 1.0) ? 1.0 : (alpha &lt; 0.0) ? 0.0 : alpha;
            writeParam(alpha, NGCanvas.GLOBAL_ALPHA);
        }
    }

    /**
     * Gets the current global alpha.
     * The default value is {@code 1.0}.
     * The global alpha is a &lt;a href=&quot;#comm-attr&quot;&gt;common attribute&lt;/a&gt;
     * used for nearly all rendering methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return the current global alpha.
     */
    public double getGlobalAlpha() {
        return curState.globalAlpha;
    }

    /**
     * Sets the global blend mode.
     * The default value is {@link BlendMode#SRC_OVER SRC_OVER}.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     * The blend mode is a &lt;a href=&quot;#comm-attr&quot;&gt;common attribute&lt;/a&gt;
     * used for nearly all rendering methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @param op the {@code BlendMode} that will be set or null.
     */
    public void setGlobalBlendMode(BlendMode op) {
        if (op != null &amp;&amp; op != curState.blendop) {
            GrowableDataBuffer buf = getBuffer();
            curState.blendop = op;
            buf.putByte(NGCanvas.COMP_MODE);
            buf.putObject(EffectHelper.getToolkitBlendMode(op));
        }
    }

    /**
     * Gets the global blend mode.
     * The default value is {@link BlendMode#SRC_OVER SRC_OVER}.
     * The blend mode is a &lt;a href=&quot;#comm-attr&quot;&gt;common attribute&lt;/a&gt;
     * used for nearly all rendering methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return the global {@code BlendMode} of the current state.
     */
    public BlendMode getGlobalBlendMode() {
        return curState.blendop;
    }

    /**
     * Sets the current fill paint attribute.
     * The default value is {@link Color#BLACK BLACK}.
     * The fill paint is a &lt;a href=&quot;#fill-attr&quot;&gt;fill attribute&lt;/a&gt;
     * used for any of the fill methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     *
     * @param p The {@code Paint} to be used as the fill {@code Paint} or null.
     */
    public void setFill(Paint p) {
        if (p != null &amp;&amp; curState.fill != p) {
            curState.fill = p;
            writePaint(p, NGCanvas.FILL_PAINT);
        }
    }

    /**
     * Gets the current fill paint attribute.
     * The default value is {@link Color#BLACK BLACK}.
     * The fill paint is a &lt;a href=&quot;#fill-attr&quot;&gt;fill attribute&lt;/a&gt;
     * used for any of the fill methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return p The {@code Paint} to be used as the fill {@code Paint}.
     */
    public Paint getFill() {
        return curState.fill;
    }

    /**
     * Sets the current stroke paint attribute.
     * The default value is {@link Color#BLACK BLACK}.
     * The stroke paint is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     *
     * @param p The Paint to be used as the stroke Paint or null.
     */
    public void setStroke(Paint p) {
        if (p != null &amp;&amp; curState.stroke != p) {
            curState.stroke = p;
            writePaint(p, NGCanvas.STROKE_PAINT);
        }
    }

    /**
     * Gets the current stroke.
     * The default value is {@link Color#BLACK BLACK}.
     * The stroke paint is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return the {@code Paint} to be used as the stroke {@code Paint}.
     */
    public Paint getStroke() {
        return curState.stroke;
    }

    /**
     * Sets the current line width.
     * The default value is {@code 1.0}.
     * The line width is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * An infinite or non-positive value outside of the range {@code (0, +inf)}
     * will be ignored and the current value will remain unchanged.
     *
     * @param lw value in the range {0-positive infinity}, with any other value
     * being ignored and leaving the value unchanged.
     */
    public void setLineWidth(double lw) {
        // Per W3C spec: On setting, zero, negative, infinite, and NaN
        // values must be ignored, leaving the value unchanged
        if (lw &gt; 0 &amp;&amp; lw &lt; Double.POSITIVE_INFINITY) {
            if (curState.linewidth != lw) {
                curState.linewidth = lw;
                writeParam(lw, NGCanvas.LINE_WIDTH);
            }
        }
    }

    /**
     * Gets the current line width.
     * The default value is {@code 1.0}.
     * The line width is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return value between 0 and infinity.
     */
    public double getLineWidth() {
        return curState.linewidth;
    }

    /**
     * Sets the current stroke line cap.
     * The default value is {@link StrokeLineCap#SQUARE SQUARE}.
     * The line cap is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     *
     * @param cap {@code StrokeLineCap} with a value of Butt, Round, or Square or null.
     */
    public void setLineCap(StrokeLineCap cap) {
        if (cap != null &amp;&amp; curState.linecap != cap) {
            byte v;
            switch (cap) {
                case BUTT: v = NGCanvas.CAP_BUTT; break;
                case ROUND: v = NGCanvas.CAP_ROUND; break;
                case SQUARE: v = NGCanvas.CAP_SQUARE; break;
                default: return;
            }
            curState.linecap = cap;
            writeParam(v, NGCanvas.LINE_CAP);
        }
    }

    /**
     * Gets the current stroke line cap.
     * The default value is {@link StrokeLineCap#SQUARE SQUARE}.
     * The line cap is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return {@code StrokeLineCap} with a value of Butt, Round, or Square.
     */
    public StrokeLineCap getLineCap() {
        return curState.linecap;
    }

    /**
     * Sets the current stroke line join.
     * The default value is {@link StrokeLineJoin#MITER}.
     * The line join is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     *
     * @param join {@code StrokeLineJoin} with a value of Miter, Bevel, or Round or null.
     */
    public void setLineJoin(StrokeLineJoin join) {
        if (join != null &amp;&amp; curState.linejoin != join) {
            byte v;
            switch (join) {
                case MITER: v = NGCanvas.JOIN_MITER; break;
                case BEVEL: v = NGCanvas.JOIN_BEVEL; break;
                case ROUND: v = NGCanvas.JOIN_ROUND; break;
                default: return;
            }
            curState.linejoin = join;
            writeParam(v, NGCanvas.LINE_JOIN);
        }
    }

    /**
     * Gets the current stroke line join.
     * The default value is {@link StrokeLineJoin#MITER}.
     * The line join is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return {@code StrokeLineJoin} with a value of Miter, Bevel, or Round.
     */
    public StrokeLineJoin getLineJoin() {
        return curState.linejoin;
    }

    /**
     * Sets the current miter limit.
     * The default value is {@code 10.0}.
     * The miter limit is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * An infinite or non-positive value outside of the range {@code (0, +inf)}
     * will be ignored and the current value will remain unchanged.
     *
     * @param ml miter limit value between 0 and positive infinity with
     * any other value being ignored and leaving the value unchanged.
     */
    public void setMiterLimit(double ml) {
        // Per W3C spec: On setting, zero, negative, infinite, and NaN
        // values must be ignored, leaving the value unchanged
        if (ml &gt; 0.0 &amp;&amp; ml &lt; Double.POSITIVE_INFINITY) {
            if (curState.miterlimit != ml) {
                curState.miterlimit = ml;
                writeParam(ml, NGCanvas.MITER_LIMIT);
            }
        }
    }

    /**
     * Gets the current miter limit.
     * The default value is {@code 10.0}.
     * The miter limit is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return the miter limit value in the range {@code 0.0-positive infinity}
     */
    public double getMiterLimit() {
        return curState.miterlimit;
    }

    /**
     * Sets the current stroke line dash pattern to a normalized copy of
     * the argument.
     * The default value is {@code null}.
     * The line dash array is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * If the array is {@code null} or empty or contains all {@code 0} elements
     * then dashing will be disabled and the current dash array will be set
     * to {@code null}.
     * If any of the elements of the array are a negative, infinite, or NaN
     * value outside the range {@code [0, +inf)} then the entire array will
     * be ignored and the current dash array will remain unchanged.
     * If the array is an odd length then it will be treated as if it
     * were two copies of the array appended to each other.
     *
     * @param dashes the array of finite non-negative dash lengths
     * @since JavaFX 8u40
     */
    public void setLineDashes(double... dashes) {
        if (dashes == null || dashes.length == 0) {
            if (curState.dashes == null) {
                return;
            }
            curState.dashes = null;
        } else {
            boolean allZeros = true;
            for (int i = 0; i &lt; dashes.length; i++) {
                double d = dashes[i];
                if (d &gt;= 0.0 &amp;&amp; d &lt; Double.POSITIVE_INFINITY) {
                    // Non-NaN, finite, non-negative
                    // Test cannot be inverted or it will not implicitly test for NaN
                    if (d &gt; 0) {
                        allZeros = false;
                    }
                } else {
                    return;
                }
            }
            if (allZeros) {
                if (curState.dashes == null) {
                    return;
                }
                curState.dashes = null;
            } else {
                int dashlen = dashes.length;
                if ((dashlen &amp; 1) == 0) {
                    curState.dashes = Arrays.copyOf(dashes, dashlen);
                } else {
                    curState.dashes = Arrays.copyOf(dashes, dashlen * 2);
                    System.arraycopy(dashes, 0, curState.dashes, dashlen, dashlen);
                }
            }
        }
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(NGCanvas.DASH_ARRAY);
        buf.putObject(curState.dashes);
    }

    /**
     * Gets a copy of the current line dash array.
     * The default value is {@code null}.
     * The array may be normalized by the validation tests in the
     * {@link #setLineDashes(double...)} method.
     * The line dash array is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return a copy of the current line dash array.
     * @since JavaFX 8u40
     */
    public double[] getLineDashes() {
        if (curState.dashes == null) {
            return null;
        }
        return Arrays.copyOf(curState.dashes, curState.dashes.length);
    }

    /**
     * Sets the line dash offset.
     * The default value is {@code 0.0}.
     * The line dash offset is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * An infinite or NaN value outside of the range {@code (-inf, +inf)}
     * will be ignored and the current value will remain unchanged.
     *
     * @param dashOffset the line dash offset in the range {@code (-inf, +inf)}
     * @since JavaFX 8u40
     */
    public void setLineDashOffset(double dashOffset) {
        // Per W3C spec: On setting, infinite, and NaN
        // values must be ignored, leaving the value unchanged
        if (dashOffset &gt; Double.NEGATIVE_INFINITY &amp;&amp; dashOffset &lt; Double.POSITIVE_INFINITY) {
            curState.dashOffset = dashOffset;
            writeParam(dashOffset, NGCanvas.DASH_OFFSET);
        }
    }

    /**
     * Gets the current line dash offset.
     * The default value is {@code 0.0}.
     * The line dash offset is a &lt;a href=&quot;#strk-attr&quot;&gt;stroke attribute&lt;/a&gt;
     * used for any of the stroke methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return the line dash offset in the range {@code (-inf, +inf)}
     * @since JavaFX 8u40
     */
    public double getLineDashOffset() {
        return curState.dashOffset;
    }

    /**
     * Sets the current Font.
     * The default value is specified by {@link Font#getDefault()}.
     * The font is a &lt;a href=&quot;#text-attr&quot;&gt;text attribute&lt;/a&gt;
     * used for any of the text methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     *
     * @param f the Font or null.
     */
    public void setFont(Font f) {
        if (f != null &amp;&amp; curState.font != f) {
            curState.font = f;
            GrowableDataBuffer buf = getBuffer();
            buf.putByte(NGCanvas.FONT);
            buf.putObject(FontHelper.getNativeFont(f));
        }
    }

    /**
     * Gets the current Font.
     * The default value is specified by {@link Font#getDefault()}.
     * The font is a &lt;a href=&quot;#text-attr&quot;&gt;text attribute&lt;/a&gt;
     * used for any of the text methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return the Font
     */
    public Font getFont() {
        return curState.font;
    }

    /**
     * Sets the current Font Smoothing Type.
     * The default value is {@link FontSmoothingType#GRAY GRAY}.
     * The font smoothing type is a &lt;a href=&quot;#text-attr&quot;&gt;text attribute&lt;/a&gt;
     * used for any of the text methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     * &lt;p&gt;
     * &lt;b&gt;Note&lt;/b&gt; that the {@code FontSmoothingType} value of
     * {@link FontSmoothingType#LCD LCD} is only supported over an opaque
     * background.  {@code LCD} text will generally appear as {@code GRAY}
     * text over transparent or partially transparent pixels, and in some
     * implementations it may not be supported at all on a {@link Canvas}
     * because the required support does not exist for surfaces which contain
     * an alpha channel as all {@code Canvas} objects do.
     *
     * @param fontsmoothing the {@link FontSmoothingType} or null
     * @since JavaFX 8u40
     */
    public void setFontSmoothingType(FontSmoothingType fontsmoothing) {
        if (fontsmoothing != null &amp;&amp; fontsmoothing != curState.fontsmoothing) {
            curState.fontsmoothing = fontsmoothing;
            writeParam((byte) fontsmoothing.ordinal(), NGCanvas.FONT_SMOOTH);
        }
    }

    /**
     * Gets the current Font Smoothing Type.
     * The default value is {@link FontSmoothingType#GRAY GRAY}.
     * The font smoothing type is a &lt;a href=&quot;#text-attr&quot;&gt;text attribute&lt;/a&gt;
     * used for any of the text methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return the {@link FontSmoothingType}
     * @since JavaFX 8u40
     */
    public FontSmoothingType getFontSmoothingType() {
        return curState.fontsmoothing;
    }

    /**
     * Defines horizontal text alignment, relative to the text {@code x} origin.
     * The default value is {@link TextAlignment#LEFT LEFT}.
     * The text alignment is a &lt;a href=&quot;#text-attr&quot;&gt;text attribute&lt;/a&gt;
     * used for any of the text methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;p&gt;
     * Let horizontal bounds represent the logical width of a single line of
     * text. Where each line of text has a separate horizontal bounds.
     * &lt;p&gt;
     * Then TextAlignment is specified as:
     * &lt;ul&gt;
     * &lt;li&gt;Left: the left edge of the horizontal bounds will be at {@code x}.
     * &lt;li&gt;Center: the center, halfway between left and right edge, of the
     * horizontal bounds will be at {@code x}.
     * &lt;li&gt;Right: the right edge of the horizontal bounds will be at {@code x}.
     * &lt;/ul&gt;
     * &lt;p&gt;
     *
     * Note: Canvas does not support line wrapping, therefore the text
     * alignment Justify is identical to left aligned text.
     * &lt;p&gt;
     * A {@code null} value will be ignored and the current value will remain unchanged.
     *
     * @param align {@code TextAlignment} with values of Left, Center, Right or null.
     */
    public void setTextAlign(TextAlignment align) {
        if (align != null &amp;&amp; curState.textalign != align) {
            byte a;
            switch (align) {
                case LEFT: a = NGCanvas.ALIGN_LEFT; break;
                case CENTER: a = NGCanvas.ALIGN_CENTER; break;
                case RIGHT: a = NGCanvas.ALIGN_RIGHT; break;
                case JUSTIFY: a = NGCanvas.ALIGN_JUSTIFY; break;
                default: return;
            }
            curState.textalign = align;
            writeParam(a, NGCanvas.TEXT_ALIGN);
        }
    }

    /**
     * Gets the current {@code TextAlignment}.
     * The default value is {@link TextAlignment#LEFT LEFT}.
     * The text alignment is a &lt;a href=&quot;#text-attr&quot;&gt;text attribute&lt;/a&gt;
     * used for any of the text methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return {@code TextAlignment} with values of Left, Center, Right, or
     * Justify.
     */
    public TextAlignment getTextAlign() {
        return curState.textalign;
    }

    /**
     * Sets the current Text Baseline.
     * The default value is {@link VPos#BASELINE BASELINE}.
     * The text baseline is a &lt;a href=&quot;#text-attr&quot;&gt;text attribute&lt;/a&gt;
     * used for any of the text methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     *
     * @param baseline {@code VPos} with values of Top, Center, Baseline, or Bottom or null.
     */
    public void setTextBaseline(VPos baseline) {
        if (baseline != null &amp;&amp; curState.textbaseline != baseline) {
            byte b;
            switch (baseline) {
                case TOP: b = NGCanvas.BASE_TOP; break;
                case CENTER: b = NGCanvas.BASE_MIDDLE; break;
                case BASELINE: b = NGCanvas.BASE_ALPHABETIC; break;
                case BOTTOM: b = NGCanvas.BASE_BOTTOM; break;
                default: return;
            }
            curState.textbaseline = baseline;
            writeParam(b, NGCanvas.TEXT_BASELINE);
        }
    }

    /**
     * Gets the current Text Baseline.
     * The default value is {@link VPos#BASELINE BASELINE}.
     * The text baseline is a &lt;a href=&quot;#text-attr&quot;&gt;text attribute&lt;/a&gt;
     * used for any of the text methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return {@code VPos} with values of Top, Center, Baseline, or Bottom
     */
    public VPos getTextBaseline() {
        return curState.textbaseline;
    }

    /**
     * Fills the given string of text at position x, y
     * with the current fill paint attribute.
     * A {@code null} text value will be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;,
     * &lt;a href=&quot;#fill-attr&quot;&gt;fill&lt;/a&gt;,
     * or &lt;a href=&quot;#text-attr&quot;&gt;text&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param text the string of text or null.
     * @param x position on the x axis.
     * @param y position on the y axis.
     */
    public void fillText(String text, double x, double y) {
        writeText(text, x, y, 0, NGCanvas.FILL_TEXT);
    }

    /**
     * Draws the given string of text at position x, y
     * with the current stroke paint attribute.
     * A {@code null} text value will be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;,
     * &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;,
     * or &lt;a href=&quot;#text-attr&quot;&gt;text&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param text the string of text or null.
     * @param x position on the x axis.
     * @param y position on the y axis.
     */
    public void strokeText(String text, double x, double y) {
        writeText(text, x, y, 0, NGCanvas.STROKE_TEXT);
    }

    /**
     * Fills text and includes a maximum width of the string.
     * If the width of the text extends past max width, then it will be sized
     * to fit.
     * A {@code null} text value will be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;,
     * &lt;a href=&quot;#fill-attr&quot;&gt;fill&lt;/a&gt;,
     * or &lt;a href=&quot;#text-attr&quot;&gt;text&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param text the string of text or null.
     * @param x position on the x axis.
     * @param y position on the y axis.
     * @param maxWidth  maximum width the text string can have.
     */
    public void fillText(String text, double x, double y, double maxWidth) {
        if (maxWidth &lt;= 0) return;
        writeText(text, x, y, maxWidth, NGCanvas.FILL_TEXT);
    }

    /**
     * Draws text with stroke paint and includes a maximum width of the string.
     * If the width of the text extends past max width, then it will be sized
     * to fit.
     * A {@code null} text value will be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;,
     * &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;,
     * or &lt;a href=&quot;#text-attr&quot;&gt;text&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param text the string of text or null.
     * @param x position on the x axis.
     * @param y position on the y axis.
     * @param maxWidth  maximum width the text string can have.
     */
    public void strokeText(String text, double x, double y, double maxWidth) {
        if (maxWidth &lt;= 0) return;
        writeText(text, x, y, maxWidth, NGCanvas.STROKE_TEXT);
    }


    /**
     * Set the filling rule attribute for determining the interior of paths
     * in fill or clip operations.
     * The default value is {@code FillRule.NON_ZERO}.
     * A {@code null} value will be ignored and the current value will remain unchanged.
     * The fill rule is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the fill or clip path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @param fillRule {@code FillRule} with a value of  Even_odd or Non_zero or null.
     */
     public void setFillRule(FillRule fillRule) {
         if (fillRule != null &amp;&amp; curState.fillRule != fillRule) {
            byte b;
            if (fillRule == FillRule.EVEN_ODD) {
                b = NGCanvas.FILL_RULE_EVEN_ODD;
            } else {
                b = NGCanvas.FILL_RULE_NON_ZERO;
            }
            curState.fillRule = fillRule;
            writeParam(b, NGCanvas.FILL_RULE);
        }
     }

    /**
     * Get the filling rule attribute for determining the interior of paths
     * in fill and clip operations.
     * The default value is {@code FillRule.NON_ZERO}.
     * The fill rule is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the fill or clip path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @return current fill rule.
     */
     public FillRule getFillRule() {
         return curState.fillRule;
     }

    /**
     * Resets the current path to empty.
     * The default path is empty.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     */
    public void beginPath() {
        path.reset();
        markPathDirty();
    }

    /**
     * Issues a move command for the current path to the given x,y coordinate.
     * The coordinates are transformed by the current transform as they are
     * added to the path and unaffected by subsequent changes to the transform.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     *
     * @param x0 the X position for the move to command.
     * @param y0 the Y position for the move to command.
     */
    public void moveTo(double x0, double y0) {
        coords[0] = (float) x0;
        coords[1] = (float) y0;
        curState.transform.transform(coords, 0, coords, 0, 1);
        path.moveTo(coords[0], coords[1]);
        markPathDirty();
    }

    /**
     * Adds segments to the current path to make a line to the given x,y
     * coordinate.
     * The coordinates are transformed by the current transform as they are
     * added to the path and unaffected by subsequent changes to the transform.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     *
     * @param x1 the X coordinate of the ending point of the line.
     * @param y1 the Y coordinate of the ending point of the line.
     */
    public void lineTo(double x1, double y1) {
        coords[0] = (float) x1;
        coords[1] = (float) y1;
        curState.transform.transform(coords, 0, coords, 0, 1);
        if (path.getNumCommands() == 0) {
            path.moveTo(coords[0], coords[1]);
        }
        path.lineTo(coords[0], coords[1]);
        markPathDirty();
    }

    /**
     * Adds segments to the current path to make a quadratic Bezier curve.
     * The coordinates are transformed by the current transform as they are
     * added to the path and unaffected by subsequent changes to the transform.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     *
     * @param xc the X coordinate of the control point
     * @param yc the Y coordinate of the control point
     * @param x1 the X coordinate of the end point
     * @param y1 the Y coordinate of the end point
     */
    public void quadraticCurveTo(double xc, double yc, double x1, double y1) {
        coords[0] = (float) xc;
        coords[1] = (float) yc;
        coords[2] = (float) x1;
        coords[3] = (float) y1;
        curState.transform.transform(coords, 0, coords, 0, 2);
        if (path.getNumCommands() == 0) {
            path.moveTo(coords[0], coords[1]);
        }
        path.quadTo(coords[0], coords[1], coords[2], coords[3]);
        markPathDirty();
    }

    /**
     * Adds segments to the current path to make a cubic Bezier curve.
     * The coordinates are transformed by the current transform as they are
     * added to the path and unaffected by subsequent changes to the transform.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     *
     * @param xc1 the X coordinate of first Bezier control point.
     * @param yc1 the Y coordinate of the first Bezier control point.
     * @param xc2 the X coordinate of the second Bezier control point.
     * @param yc2 the Y coordinate of the second Bezier control point.
     * @param x1  the X coordinate of the end point.
     * @param y1  the Y coordinate of the end point.
     */
    public void bezierCurveTo(double xc1, double yc1, double xc2, double yc2, double x1, double y1) {
        coords[0] = (float) xc1;
        coords[1] = (float) yc1;
        coords[2] = (float) xc2;
        coords[3] = (float) yc2;
        coords[4] = (float) x1;
        coords[5] = (float) y1;
        curState.transform.transform(coords, 0, coords, 0, 3);
        if (path.getNumCommands() == 0) {
            path.moveTo(coords[0], coords[1]);
        }
        path.curveTo(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
        markPathDirty();
    }

    /**
     * Adds segments to the current path to make an arc.
     * The coordinates are transformed by the current transform as they are
     * added to the path and unaffected by subsequent changes to the transform.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     * &lt;p&gt;
     * If {@code p0} is the current point in the path and {@code p1} is the
     * point specified by {@code (x1, y1)} and {@code p2} is the point
     * specified by {@code (x2, y2)}, then the arc segments appended will
     * be segments along the circumference of a circle of the specified
     * radius touching and inscribed into the convex (interior) side of
     * {@code p0-&gt;p1-&gt;p2}.  The path will contain a line segment (if
     * needed) to the tangent point between that circle and {@code p0-&gt;p1}
     * followed by circular arc segments to reach the tangent point between
     * the circle and {@code p1-&gt;p2} and will end with the current point at
     * that tangent point (not at {@code p2}).
     * Note that the radius and circularity of the arc segments will be
     * measured or considered relative to the current transform, but the
     * resulting segments that are computed from those untransformed
     * points will then be transformed when they are added to the path.
     * Since all computation is done in untransformed space, but the
     * pre-existing path segments are all transformed, the ability to
     * correctly perform the computation may implicitly depend on being
     * able to inverse transform the current end of the current path back
     * into untransformed coordinates.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If there is no way to compute and inscribe the indicated circle
     * for any reason then the entire operation will simply append segments
     * to force a line to point {@code p1}.  Possible reasons that the
     * computation may fail include:
     * &lt;ul&gt;
     * &lt;li&gt;The current path is empty.&lt;/li&gt;
     * &lt;li&gt;The segments {@code p0-&gt;p1-&gt;p2} are colinear.&lt;/li&gt;
     * &lt;li&gt;the current transform is non-invertible so that the current end
     * point of the current path cannot be untransformed for computation.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param x1 the X coordinate of the first point of the arc.
     * @param y1 the Y coordinate of the first point of the arc.
     * @param x2 the X coordinate of the second point of the arc.
     * @param y2 the Y coordinate of the second point of the arc.
     * @param radius the radius of the arc in the range {0.0-positive infinity}.
     */
    public void arcTo(double x1, double y1, double x2, double y2, double radius) {
        if (path.getNumCommands() == 0) {
            moveTo(x1, y1);
            lineTo(x1, y1);
        } else if (!tryArcTo((float) x1, (float) y1, (float) x2, (float) y2,
                             (float) radius))
        {
            lineTo(x1, y1);
        }
    }

    private static double lenSq(double x0, double y0, double x1, double y1) {
        x1 -= x0;
        y1 -= y0;
        return x1 * x1 + y1 * y1;
    }

    private boolean tryArcTo(float x1, float y1, float x2, float y2, float radius) {
        float x0, y0;
        if (curState.transform.isTranslateOrIdentity()) {
            x0 = (float) (path.getCurrentX() - curState.transform.getMxt());
            y0 = (float) (path.getCurrentY() - curState.transform.getMyt());
        } else {
            coords[0] = path.getCurrentX();
            coords[1] = path.getCurrentY();
            try {
                curState.transform.inverseTransform(coords, 0, coords, 0, 1);
            } catch (NoninvertibleTransformException e) {
                return false;
            }
            x0 = coords[0];
            y0 = coords[1];
        }
        // call x1,y1 the corner point
        // If 2*theta is the angle described by p0-&gt;p1-&gt;p2
        // then theta is the angle described by p0-&gt;p1-&gt;centerpt and
        // centerpt-&gt;p1-&gt;p2
        // We know that the distance from the arc center to the tangent points
        // is r, and if A is the distance from the corner to the tangent point
        // then we know:
        // tan(theta) = r/A
        // A = r / sin(theta)
        // B = A * cos(theta) = r * (sin/cos) = r * tan
        // We use the cosine rule on the triangle to get the 2*theta angle:
        // cosB = (a^2 + c^2 - b^2) / (2ac)
        // where a and c are the adjacent sides and b is the opposite side
        // i.e. a = p0-&gt;p1, c=p1-&gt;p2, b=p0-&gt;p2
        // Then we can use the tan^2 identity to compute B:
        // tan^2 = (1 - cos(2theta)) / (1 + cos(2theta))
        double lsq01 = lenSq(x0, y0, x1, y1);
        double lsq12 = lenSq(x1, y1, x2, y2);
        double lsq02 = lenSq(x0, y0, x2, y2);
        double len01 = Math.sqrt(lsq01);
        double len12 = Math.sqrt(lsq12);
        double cosnum = lsq01 + lsq12 - lsq02;
        double cosden = 2.0 * len01 * len12;
        if (cosden == 0.0 || radius &lt;= 0f) {
            return false;
        }
        double cos_2theta = cosnum / cosden;
        double tansq_den = (1.0 + cos_2theta);
        if (tansq_den == 0.0) {
            return false;
        }
        double tansq_theta = (1.0 - cos_2theta) / tansq_den;
        double A = radius / Math.sqrt(tansq_theta);
        double tx0 = x1 + (A / len01) * (x0 - x1);
        double ty0 = y1 + (A / len01) * (y0 - y1);
        double tx1 = x1 + (A / len12) * (x2 - x1);
        double ty1 = y1 + (A / len12) * (y2 - y1);
        // The midpoint between the two tangent points
        double mx = (tx0 + tx1) / 2.0;
        double my = (ty0 + ty1) / 2.0;
        // similar triangles tell us that:
        // len(m,center)/len(m,tangent) = len(m,tangent)/len(corner,m)
        // len(m,center) = lensq(m,tangent)/len(corner,m)
        // center = m + (m - p1) * len(m,center) / len(corner,m)
        //   = m + (m - p1) * (lensq(m,tangent) / lensq(corner,m))
        double lenratioden = lenSq(mx, my, x1, y1);
        if (lenratioden == 0.0) {
            return false;
        }
        double lenratio = lenSq(mx, my, tx0, ty0) / lenratioden;
        double cx = mx + (mx - x1) * lenratio;
        double cy = my + (my - y1) * lenratio;
        if (!(cx == cx &amp;&amp; cy == cy)) {
            return false;
        }
        // Looks like we are good to draw, first we have to get to the
        // initial tangent point with a line segment.
        if (tx0 != x0 || ty0 != y0) {
            lineTo(tx0, ty0);
        }
        // We need sin(arc/2), cos(arc/2)
        // and possibly sin(arc/4), cos(arc/4) if we need 2 cubic beziers
        // We have tan(theta) = tan(tri/2)
        // arc = 180-tri
        // arc/2 = (180-tri)/2 = 90-(tri/2)
        // sin(arc/2) = sin(90-(tri/2)) = cos(tri/2)
        // cos(arc/2) = cos(90-(tri/2)) = sin(tri/2)
        // 2theta = tri, therefore theta = tri/2
        // cos(tri/2)^2 = (1+cos(tri)) / 2.0 = (1+cos_2theta)/2.0
        // sin(tri/2)^2 = (1-cos(tri)) / 2.0 = (1-cos_2theta)/2.0
        // sin(arc/2) = cos(tri/2) = sqrt((1+cos_2theta)/2.0)
        // cos(arc/2) = sin(tri/2) = sqrt((1-cos_2theta)/2.0)
        // We compute cos(arc/2) here as we need it in either case below
        double coshalfarc = Math.sqrt((1.0 - cos_2theta) / 2.0);
        boolean ccw = (ty0 - cy) * (tx1 - cx) &gt; (ty1 - cy) * (tx0 - cx);
        // If the arc covers more than 90 degrees then we must use 2
        // cubic beziers to get a decent approximation.
        // arc = 180-tri
        // arc = 180-2*theta
        // arc &gt; 90 implies 2*theta &lt; 90
        // 2*theta &lt; 90 implies cos_2theta &gt; 0
        // So, we need 2 cubics if cos_2theta &gt; 0
        if (cos_2theta &lt;= 0.0) {
            // 1 cubic bezier
            double sinhalfarc = Math.sqrt((1.0 + cos_2theta) / 2.0);
            double cv = 4.0 / 3.0 * sinhalfarc / (1.0 + coshalfarc);
            if (ccw) cv = -cv;
            double cpx0 = tx0 - cv * (ty0 - cy);
            double cpy0 = ty0 + cv * (tx0 - cx);
            double cpx1 = tx1 + cv * (ty1 - cy);
            double cpy1 = ty1 - cv * (tx1 - cx);
            bezierCurveTo(cpx0, cpy0, cpx1, cpy1, tx1, ty1);
        } else {
            // 2 cubic beziers
            // We need sin(arc/4) and cos(arc/4)
            // We computed cos(arc/2), so we can compute them as follows:
            // sin(arc/4) = sqrt((1 - cos(arc/2)) / 2)
            // cos(arc/4) = sart((1 + cos(arc/2)) / 2)
            double sinqtrarc = Math.sqrt((1.0 - coshalfarc) / 2.0);
            double cosqtrarc = Math.sqrt((1.0 + coshalfarc) / 2.0);
            double cv = 4.0 / 3.0 * sinqtrarc / (1.0 + cosqtrarc);
            if (ccw) cv = -cv;
            double midratio = radius / Math.sqrt(lenratioden);
            double midarcx = cx + (x1 - mx) * midratio;
            double midarcy = cy + (y1 - my) * midratio;
            double cpx0 = tx0 - cv * (ty0 - cy);
            double cpy0 = ty0 + cv * (tx0 - cx);
            double cpx1 = midarcx + cv * (midarcy - cy);
            double cpy1 = midarcy - cv * (midarcx - cx);
            bezierCurveTo(cpx0, cpy0, cpx1, cpy1, midarcx, midarcy);
            cpx0 = midarcx - cv * (midarcy - cy);
            cpy0 = midarcy + cv * (midarcx - cx);
            cpx1 = tx1 + cv * (ty1 - cy);
            cpy1 = ty1 - cv * (tx1 - cx);
            bezierCurveTo(cpx0, cpy0, cpx1, cpy1, tx1, ty1);
        }
        return true;
    }

    /**
     * Adds path elements to the current path to make an arc that uses Euclidean
     * degrees. This Euclidean orientation sweeps from East to North, then West,
     * then South, then back to East.
     * The coordinates are transformed by the current transform as they are
     * added to the path and unaffected by subsequent changes to the transform.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     *
     * @param centerX the center x position of the arc.
     * @param centerY the center y position of the arc.
     * @param radiusX the x radius of the arc.
     * @param radiusY the y radius of the arc.
     * @param startAngle the starting angle of the arc in the range {@code 0-360.0}
     * @param length  the length of the baseline of the arc.
     */
    public void arc(double centerX, double centerY,
                    double radiusX, double radiusY,
                    double startAngle, double length)
    {
        Arc2D arc = new Arc2D((float) (centerX - radiusX), // x
                              (float) (centerY - radiusY), // y
                              (float) (radiusX * 2.0), // w
                              (float) (radiusY * 2.0), // h
                              (float) startAngle,
                              (float) length,
                              Arc2D.OPEN);
        path.append(arc.getPathIterator(curState.transform), true);
        markPathDirty();
    }

    /**
     * Adds path elements to the current path to make a rectangle.
     * The coordinates are transformed by the current transform as they are
     * added to the path and unaffected by subsequent changes to the transform.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     *
     * @param x x position of the upper left corner of the rectangle.
     * @param y y position of the upper left corner of the rectangle.
     * @param w width of the rectangle.
     * @param h height of the rectangle.
     */
    public void rect(double x, double y, double w, double h) {
        coords[0] = (float) x;
        coords[1] = (float) y;
        coords[2] = (float) w;
        coords[3] = (float) 0;
        coords[4] = (float) 0;
        coords[5] = (float) h;
        curState.transform.deltaTransform(coords, 0, coords, 0, 3);
        float x0 = coords[0] + (float) curState.transform.getMxt();
        float y0 = coords[1] + (float) curState.transform.getMyt();
        float dx1 = coords[2];
        float dy1 = coords[3];
        float dx2 = coords[4];
        float dy2 = coords[5];
        path.moveTo(x0, y0);
        path.lineTo(x0+dx1, y0+dy1);
        path.lineTo(x0+dx1+dx2, y0+dy1+dy2);
        path.lineTo(x0+dx2, y0+dy2);
        path.closePath();
        markPathDirty();
//        path.moveTo(x0, y0); // not needed, closepath leaves pen at moveto
    }

    /**
     * Appends an SVG Path string to the current path. If there is no current
     * path the string must then start with either type of move command.
     * A {@code null} value or incorrect SVG path will be ignored.
     * The coordinates are transformed by the current transform as they are
     * added to the path and unaffected by subsequent changes to the transform.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     *
     * @param svgpath the SVG Path string.
     */
    public void appendSVGPath(String svgpath) {
        if (svgpath == null) return;
        boolean prependMoveto = true;
        boolean skipMoveto = true;
        for (int i = 0; i &lt; svgpath.length(); i++) {
            switch (svgpath.charAt(i)) {
                case ' ':
                case '\t':
                case '\r':
                case '\n':
                    continue;
                case 'M':
                    prependMoveto = skipMoveto = false;
                    break;
                case 'm':
                    if (path.getNumCommands() == 0) {
                        // An initial relative moveTo becomes absolute
                        prependMoveto = false;
                    }
                    // Even if we prepend an initial moveTo in the temp
                    // path, we do not want to delete the resulting initial
                    // moveTo because the relative moveto will be folded
                    // into it by an optimization in the Path2D object.
                    skipMoveto = false;
                    break;
            }
            break;
        }
        Path2D p2d = new Path2D();
        if (prependMoveto &amp;&amp; path.getNumCommands() &gt; 0) {
            float x0, y0;
            if (curState.transform.isTranslateOrIdentity()) {
                x0 = (float) (path.getCurrentX() - curState.transform.getMxt());
                y0 = (float) (path.getCurrentY() - curState.transform.getMyt());
            } else {
                coords[0] = path.getCurrentX();
                coords[1] = path.getCurrentY();
                try {
                    curState.transform.inverseTransform(coords, 0, coords, 0, 1);
                } catch (NoninvertibleTransformException e) {
                }
                x0 = coords[0];
                y0 = coords[1];
            }
            p2d.moveTo(x0, y0);
        } else {
            skipMoveto = false;
        }
        try {
            p2d.appendSVGPath(svgpath);
            PathIterator pi = p2d.getPathIterator(curState.transform);
            if (skipMoveto) {
                // We need to delete the initial moveto and let the path
                // extend from the actual existing geometry.
                pi.next();
            }
            path.append(pi, false);
        } catch (IllegalArgumentException | IllegalPathStateException ex) {
            //Ignore incorrect path
        }
    }

    /**
     * Closes the path.
     * The current path is a &lt;a href=&quot;#path-attr&quot;&gt;path attribute&lt;/a&gt;
     * used for any of the path methods as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;
     * and &lt;b&gt;is not affected&lt;/b&gt; by the {@link #save()} and
     * {@link #restore()} operations.
     */
    public void closePath() {
        if (path.getNumCommands() &gt; 0) {
            path.closePath();
            markPathDirty();
        }
    }

    /**
     * Fills the path with the current fill paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;,
     * &lt;a href=&quot;#fill-attr&quot;&gt;fill&lt;/a&gt;,
     * or &lt;a href=&quot;#path-attr&quot;&gt;path&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * Note that the path segments were transformed as they were originally
     * added to the current path so the current transform will not affect
     * those path segments again, but it may affect other attributes in
     * affect at the time of the {@code fill()} operation.
     * &lt;/p&gt;
     */
    public void fill() {
        writePath(NGCanvas.FILL_PATH);
    }

    /**
     * Strokes the path with the current stroke paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;,
     * &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;,
     * or &lt;a href=&quot;#path-attr&quot;&gt;path&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * Note that the path segments were transformed as they were originally
     * added to the current path so the current transform will not affect
     * those path segments again, but it may affect other attributes in
     * affect at the time of the {@code stroke()} operation.
     * &lt;/p&gt;
     */
    public void stroke() {
        writePath(NGCanvas.STROKE_PATH);
    }

    /**
     * Intersects the current clip with the current path and applies it to
     * subsequent rendering operation as an anti-aliased mask.
     * The current clip is a &lt;a href=&quot;#comm-attr&quot;&gt;common attribute&lt;/a&gt;
     * used for nearly all rendering operations as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;p&gt;
     * This method will itself be affected only by the
     * &lt;a href=&quot;#path-attr&quot;&gt;path&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * Note that the path segments were transformed as they were originally
     * added to the current path so the current transform will not affect
     * those path segments again, but it may affect other attributes in
     * affect at the time of the {@code stroke()} operation.
<A NAME="7"></A>     * &lt;/p&gt;
     */
    public void clip() {
        Path2D clip = <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#7',2,'match31-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new Path2D(path);
        clipStack.addLast(clip);
        curState.numClipPaths++;
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(NGCanvas.PUSH_CLIP);
        buf.putObject(clip);
    }

    /**
     * Returns true if the the given x,y point is inside the path.
     *
     * @param x the X coordinate to use for the check.
     * @param y the Y coordinate to use for the check.
     * @return true if the point given is inside the path, false
     * otherwise.
     */
    public boolean isPointInPath(double x</B></FONT>, double y) {
        // TODO: HTML5 considers points on the path to be inside, but we
        // implement a halfin-halfout approach...
        return path.contains((float) x, (float) y);
    }

    /**
     * Clears a portion of the canvas with a transparent color value.
     * &lt;p&gt;
     * This method will be affected only by the current transform, clip,
     * and effect.
     * &lt;/p&gt;
     *
     * @param x X position of the upper left corner of the rectangle.
     * @param y Y position of the upper left corner of the rectangle.
     * @param w width of the rectangle.
     * @param h height of the rectangle.
     */
    public void clearRect(double x, double y, double w, double h) {
        if (w != 0 &amp;&amp; h != 0) {
            resetIfCovers(null, x, y, w, h);
            writeOp4(x, y, w, h, NGCanvas.CLEAR_RECT);
        }
    }

    /**
     * Fills a rectangle using the current fill paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#fill-attr&quot;&gt;fill&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x the X position of the upper left corner of the rectangle.
     * @param y the Y position of the upper left corner of the rectangle.
     * @param w the width of the rectangle.
     * @param h the height of the rectangle.
     */
    public void fillRect(double x, double y, double w, double h) {
        if (w != 0 &amp;&amp; h != 0) {
            resetIfCovers(this.curState.fill, x, y, w, h);
            writeOp4(x, y, w, h, NGCanvas.FILL_RECT);
        }
    }

    /**
     * Strokes a rectangle using the current stroke paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x the X position of the upper left corner of the rectangle.
     * @param y the Y position of the upper left corner of the rectangle.
     * @param w the width of the rectangle.
     * @param h the height of the rectangle.
     */
    public void strokeRect(double x, double y, double w, double h) {
        if (w != 0 || h != 0) {
            writeOp4(x, y, w, h, NGCanvas.STROKE_RECT);
        }
    }

    /**
     * Fills an oval using the current fill paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#fill-attr&quot;&gt;fill&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x the X coordinate of the upper left bound of the oval.
     * @param y the Y coordinate of the upper left bound of the oval.
     * @param w the width at the center of the oval.
     * @param h the height at the center of the oval.
     */
    public void fillOval(double x, double y, double w, double h) {
        if (w != 0 &amp;&amp; h != 0) {
            writeOp4(x, y, w, h, NGCanvas.FILL_OVAL);
        }
    }

    /**
     * Strokes an oval using the current stroke paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x the X coordinate of the upper left bound of the oval.
     * @param y the Y coordinate of the upper left bound of the oval.
     * @param w the width at the center of the oval.
     * @param h the height at the center of the oval.
     */
    public void strokeOval(double x, double y, double w, double h) {
        if (w != 0 || h != 0) {
            writeOp4(x, y, w, h, NGCanvas.STROKE_OVAL);
        }
    }

    /**
     * Fills an arc using the current fill paint. A {@code null} ArcType or
     * non positive width or height will cause the render command to be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#fill-attr&quot;&gt;fill&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x the X coordinate of the arc.
     * @param y the Y coordinate of the arc.
     * @param w the width of the arc.
     * @param h the height of the arc.
     * @param startAngle the starting angle of the arc in degrees.
     * @param arcExtent the angular extent of the arc in degrees.
     * @param closure closure type (Round, Chord, Open) or null.
     */
    public void fillArc(double x, double y, double w, double h,
                        double startAngle, double arcExtent, ArcType closure)
    {
        if (w != 0 &amp;&amp; h != 0 &amp;&amp; closure != null) {
            writeArcType(closure);
            writeOp6(x, y, w, h, startAngle, arcExtent, NGCanvas.FILL_ARC);
        }
    }

    /**
     * Strokes an Arc using the current stroke paint. A {@code null} ArcType or
     * non positive width or height will cause the render command to be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x the X coordinate of the arc.
     * @param y the Y coordinate of the arc.
     * @param w the width of the arc.
     * @param h the height of the arc.
     * @param startAngle the starting angle of the arc in degrees.
     * @param arcExtent arcExtent the angular extent of the arc in degrees.
     * @param closure closure type (Round, Chord, Open) or null
     */
    public void strokeArc(double x, double y, double w, double h,
                        double startAngle, double arcExtent, ArcType closure)
    {
        if (w != 0 &amp;&amp; h != 0 &amp;&amp; closure != null) {
            writeArcType(closure);
            writeOp6(x, y, w, h, startAngle, arcExtent, NGCanvas.STROKE_ARC);
        }
    }

    /**
     * Fills a rounded rectangle using the current fill paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#fill-attr&quot;&gt;fill&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x the X coordinate of the upper left bound of the oval.
     * @param y the Y coordinate of the upper left bound of the oval.
     * @param w the width at the center of the oval.
     * @param h the height at the center of the oval.
     * @param arcWidth the arc width of the rectangle corners.
     * @param arcHeight the arc height of the rectangle corners.
     */
    public void fillRoundRect(double x, double y, double w, double h,
                              double arcWidth, double arcHeight)
    {
        if (w != 0 &amp;&amp; h != 0) {
            writeOp6(x, y, w, h, arcWidth, arcHeight, NGCanvas.FILL_ROUND_RECT);
        }
    }

    /**
     * Strokes a rounded rectangle using the current stroke paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x the X coordinate of the upper left bound of the oval.
     * @param y the Y coordinate of the upper left bound of the oval.
     * @param w the width at the center of the oval.
     * @param h the height at the center of the oval.
     * @param arcWidth the arc width of the rectangle corners.
     * @param arcHeight the arc height of the rectangle corners.
     */
    public void strokeRoundRect(double x, double y, double w, double h,
                              double arcWidth, double arcHeight)
    {
        if (w != 0 &amp;&amp; h != 0) {
            writeOp6(x, y, w, h, arcWidth, arcHeight, NGCanvas.STROKE_ROUND_RECT);
        }
    }

    /**
     * Strokes a line using the current stroke paint.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param x1 the X coordinate of the starting point of the line.
     * @param y1 the Y coordinate of the starting point of the line.
     * @param x2 the X coordinate of the ending point of the line.
     * @param y2 the Y coordinate of the ending point of the line.
     */
    public void strokeLine(double x1, double y1, double x2, double y2) {
        writeOp4(x1, y1, x2, y2, NGCanvas.STROKE_LINE);
    }

    /**
     * Fills a polygon with the given points using the currently set fill paint.
     * A {@code null} value for any of the arrays will be ignored and nothing will be drawn.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;,
     * &lt;a href=&quot;#fill-attr&quot;&gt;fill&lt;/a&gt;,
     * or &lt;a href=&quot;#path-attr&quot;&gt;Fill Rule&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param xPoints array containing the x coordinates of the polygon's points or null.
     * @param yPoints array containing the y coordinates of the polygon's points or null.
     * @param nPoints the number of points that make the polygon.
     */
    public void fillPolygon(double xPoints[], double yPoints[], int nPoints) {
        if (nPoints &gt;= 3) {
            writePoly(xPoints, yPoints, nPoints, true, NGCanvas.FILL_PATH);
        }
    }

    /**
     * Strokes a polygon with the given points using the currently set stroke paint.
     * A {@code null} value for any of the arrays will be ignored and nothing will be drawn.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param xPoints array containing the x coordinates of the polygon's points or null.
     * @param yPoints array containing the y coordinates of the polygon's points or null.
     * @param nPoints the number of points that make the polygon.
     */
    public void strokePolygon(double xPoints[], double yPoints[], int nPoints) {
        if (nPoints &gt;= 2) {
            writePoly(xPoints, yPoints, nPoints, true, NGCanvas.STROKE_PATH);
        }
    }

    /**
     * Strokes a polyline with the given points using the currently set stroke
     * paint attribute.
     * A {@code null} value for any of the arrays will be ignored and nothing will be drawn.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * or &lt;a href=&quot;#strk-attr&quot;&gt;stroke&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param xPoints array containing the x coordinates of the polyline's points or null.
     * @param yPoints array containing the y coordinates of the polyline's points or null.
     * @param nPoints the number of points that make the polyline.
     */
    public void strokePolyline(double xPoints[], double yPoints[], int nPoints) {
        if (nPoints &gt;= 2) {
            writePoly(xPoints, yPoints, nPoints, false, NGCanvas.STROKE_PATH);
        }
    }

    /**
     * Draws an image at the given x, y position using the width
     * and height of the given image.
     * A {@code null} image value or an image still in progress will be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param img the image to be drawn or null.
     * @param x the X coordinate on the destination for the upper left of the image.
     * @param y the Y coordinate on the destination for the upper left of the image.
     */
    public void drawImage(Image img, double x, double y) {
        if (img == null) return;
        double sw = img.getWidth();
        double sh = img.getHeight();
        writeImage(img, x, y, sw, sh);
    }

    /**
     * Draws an image into the given destination rectangle of the canvas. The
     * Image is scaled to fit into the destination rectangle.
     * A {@code null} image value or an image still in progress will be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param img the image to be drawn or null.
     * @param x the X coordinate on the destination for the upper left of the image.
     * @param y the Y coordinate on the destination for the upper left of the image.
     * @param w the width of the destination rectangle.
     * @param h the height of the destination rectangle.
     */
    public void drawImage(Image img, double x, double y, double w, double h) {
        writeImage(img, x, y, w, h);
    }

    /**
     * Draws the specified source rectangle of the given image to the given
     * destination rectangle of the Canvas.
     * A {@code null} image value or an image still in progress will be ignored.
     * &lt;p&gt;
     * This method will be affected by any of the
     * &lt;a href=&quot;#comm-attr&quot;&gt;global common&lt;/a&gt;
     * attributes as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param img the image to be drawn or null.
     * @param sx the source rectangle's X coordinate position.
     * @param sy the source rectangle's Y coordinate position.
     * @param sw the source rectangle's width.
     * @param sh the source rectangle's height.
     * @param dx the destination rectangle's X coordinate position.
     * @param dy the destination rectangle's Y coordinate position.
     * @param dw the destination rectangle's width.
     * @param dh the destination rectangle's height.
     */
    public void drawImage(Image img,
                          double sx, double sy, double sw, double sh,
                          double dx, double dy, double dw, double dh)
    {
        writeImage(img, dx, dy, dw, dh, sx, sy, sw, sh);
    }

    private PixelWriter writer;
    /**
     * Returns a {@link PixelWriter} object that can be used to modify
     * the pixels of the {@link Canvas} associated with this
     * {@code GraphicsContext}.
     * All coordinates in the {@code PixelWriter} methods on the returned
     * object will be in device space since they refer directly to pixels
     * and no other rendering attributes will be applied when modifying
     * pixels using this object.
     *
     * @return the {@code PixelWriter} for modifying the pixels of this
     *         {@code Canvas}
     */
    public PixelWriter getPixelWriter() {
        if (writer == null) {
            writer = new PixelWriter() {
                @Override
                public PixelFormat&lt;ByteBuffer&gt; getPixelFormat() {
                    return PixelFormat.getByteBgraPreInstance();
                }

                private BytePixelSetter getSetter() {
                    return ByteBgraPre.setter;
                }

                @Override
                public void setArgb(int x, int y, int argb) {
                    GrowableDataBuffer buf = getBuffer();
                    buf.putByte(NGCanvas.PUT_ARGB);
                    buf.putInt(x);
                    buf.putInt(y);
                    buf.putInt(argb);
                }

                @Override
                public void setColor(int x, int y, Color c) {
                    if (c == null) throw new NullPointerException(&quot;Color cannot be null&quot;);
                    int a = (int) Math.round(c.getOpacity() * 255.0);
                    int r = (int) Math.round(c.getRed() * 255.0);
                    int g = (int) Math.round(c.getGreen() * 255.0);
                    int b = (int) Math.round(c.getBlue() * 255.0);
                    setArgb(x, y, (a &lt;&lt; 24) | (r &lt;&lt; 16) | (g &lt;&lt; 8) | b);
                }

                private void writePixelBuffer(int x, int y, int w, int h,
                                              byte[] pixels)
                {
                    GrowableDataBuffer buf = getBuffer();
                    buf.putByte(NGCanvas.PUT_ARGBPRE_BUF);
                    buf.putInt(x);
                    buf.putInt(y);
                    buf.putInt(w);
                    buf.putInt(h);
                    buf.putObject(pixels);
                }

                private int[] checkBounds(int x, int y, int w, int h,
                                          PixelFormat&lt;? extends Buffer&gt; pf,
                                          int scan)
                {
                    // assert (w &gt;= 0 &amp;&amp; h &gt;= 0) - checked by caller
                    int cw = (int) Math.ceil(theCanvas.getWidth());
                    int ch = (int) Math.ceil(theCanvas.getHeight());
                    if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x+w &lt;= cw &amp;&amp; y+h &lt;= ch) {
                        return null;
                    }
                    int offset = 0;
                    if (x &lt; 0) {
                        w += x;
                        if (w &lt; 0) return null;
                        if (pf != null) {
                            switch (pf.getType()) {
                                case BYTE_BGRA:
                                case BYTE_BGRA_PRE:
                                    offset -= x * 4;
                                    break;
                                case BYTE_RGB:
                                    offset -= x * 3;
                                    break;
                                case BYTE_INDEXED:
                                case INT_ARGB:
                                case INT_ARGB_PRE:
                                    offset -= x;
                                    break;
                                default:
                                    throw new InternalError(&quot;unknown Pixel Format&quot;);
                            }
                        }
                        x = 0;
                    }
                    if (y &lt; 0) {
                        h += y;
                        if (h &lt; 0) return null;
                        offset -= y * scan;
                        y = 0;
                    }
                    if (x + w &gt; cw) {
                        w = cw - x;
                        if (w &lt; 0) return null;
                    }
                    if (y + h &gt; ch) {
                        h = ch - y;
                        if (h &lt; 0) return null;
                    }
                    return new int[] {
                        x, y, w, h, offset
                    };
                }

                @Override
                public &lt;T extends Buffer&gt; void
                    setPixels(int x, int y, int w, int h,
                              PixelFormat&lt;T&gt; pixelformat,
                              T buffer, int scan)
                {
                    if (pixelformat == null) throw new NullPointerException(&quot;PixelFormat cannot be null&quot;);
                    if (buffer == null) throw new NullPointerException(&quot;Buffer cannot be null&quot;);
                    if (w &lt;= 0 || h &lt;= 0) return;
                    int offset = buffer.position();
                    int adjustments[] = checkBounds(x, y, w, h,
                                                    pixelformat, scan);
                    if (adjustments != null) {
                        x = adjustments[0];
                        y = adjustments[1];
                        w = adjustments[2];
                        h = adjustments[3];
                        offset += adjustments[4];
                    }

                    byte pixels[] = new byte[w * h * 4];
                    ByteBuffer dst = ByteBuffer.wrap(pixels);

                    PixelGetter&lt;T&gt; getter = PixelUtils.getGetter(pixelformat);
                    PixelConverter&lt;T, ByteBuffer&gt; converter =
                        PixelUtils.getConverter(getter, getSetter());
                    converter.convert(buffer, offset, scan,
                                      dst, 0, w * 4,
                                      w, h);
                    writePixelBuffer(x, y, w, h, pixels);
                }

                @Override
                public void setPixels(int x, int y, int w, int h,
                                      PixelFormat&lt;ByteBuffer&gt; pixelformat,
                                      byte[] buffer, int offset, int scanlineStride)
                {
                    if (pixelformat == null) throw new NullPointerException(&quot;PixelFormat cannot be null&quot;);
                    if (buffer == null) throw new NullPointerException(&quot;Buffer cannot be null&quot;);
                    if (w &lt;= 0 || h &lt;= 0) return;
                    int adjustments[] = checkBounds(x, y, w, h,
                                                    pixelformat, scanlineStride);
                    if (adjustments != null) {
                        x = adjustments[0];
                        y = adjustments[1];
                        w = adjustments[2];
                        h = adjustments[3];
                        offset += adjustments[4];
                    }

                    byte pixels[] = new byte[w * h * 4];

                    BytePixelGetter getter = PixelUtils.getByteGetter(pixelformat);
                    ByteToBytePixelConverter converter =
                        PixelUtils.getB2BConverter(getter, getSetter());
                    converter.convert(buffer, offset, scanlineStride,
                                      pixels, 0, w * 4,
                                      w, h);
                    writePixelBuffer(x, y, w, h, pixels);
                }

                @Override
                public void setPixels(int x, int y, int w, int h,
                                      PixelFormat&lt;IntBuffer&gt; pixelformat,
                                      int[] buffer, int offset, int scanlineStride)
                {
                    if (pixelformat == null) throw new NullPointerException(&quot;PixelFormat cannot be null&quot;);
                    if (buffer == null) throw new NullPointerException(&quot;Buffer cannot be null&quot;);
                    if (w &lt;= 0 || h &lt;= 0) return;
                    int adjustments[] = checkBounds(x, y, w, h,
                                                    pixelformat, scanlineStride);
                    if (adjustments != null) {
                        x = adjustments[0];
                        y = adjustments[1];
                        w = adjustments[2];
                        h = adjustments[3];
                        offset += adjustments[4];
                    }

                    byte pixels[] = new byte[w * h * 4];

                    IntPixelGetter getter = PixelUtils.getIntGetter(pixelformat);
                    IntToBytePixelConverter converter =
                        PixelUtils.getI2BConverter(getter, getSetter());
                    converter.convert(buffer, offset, scanlineStride,
                                      pixels, 0, w * 4,
                                      w, h);
                    writePixelBuffer(x, y, w, h, pixels);
                }

                @Override
                public void setPixels(int dstx, int dsty, int w, int h,
                                      PixelReader reader, int srcx, int srcy)
                {
                    if (reader == null) throw new NullPointerException(&quot;Reader cannot be null&quot;);
                    if (w &lt;= 0 || h &lt;= 0) return;
                    int adjustments[] = checkBounds(dstx, dsty, w, h, null, 0);
                    if (adjustments != null) {
                        int newx = adjustments[0];
                        int newy = adjustments[1];
                        srcx += newx - dstx;
                        srcy += newy - dsty;
                        dstx = newx;
                        dsty = newy;
                        w = adjustments[2];
                        h = adjustments[3];
                    }

                    byte pixels[] = new byte[w * h * 4];
                    reader.getPixels(srcx, srcy, w, h,
                                     PixelFormat.getByteBgraPreInstance(),
                                     pixels, 0, w * 4);
                    writePixelBuffer(dstx, dsty, w, h, pixels);
                }
            };
        }
        return writer;
    }

    /**
     * Sets the effect to be applied after the next draw call, or null to
     * disable effects.
     * The current effect is a &lt;a href=&quot;#comm-attr&quot;&gt;common attribute&lt;/a&gt;
     * used for nearly all rendering operations as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @param e the effect to use, or null to disable effects
     */
    public void setEffect(Effect e) {
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(NGCanvas.EFFECT);
        if (e == null) {
            curState.effect = null;
            buf.putObject(null);
        } else {
            curState.effect = EffectHelper.copy(e);
            EffectHelper.sync(curState.effect);
            buf.putObject(EffectHelper.getPeer(curState.effect));
        }
    }

    /**
     * Gets a copy of the effect to be applied after the next draw call.
     * A null return value means that no effect will be applied after subsequent
     * rendering calls.
     * The current effect is a &lt;a href=&quot;#comm-attr&quot;&gt;common attribute&lt;/a&gt;
     * used for nearly all rendering operations as specified in the
     * &lt;a href=&quot;#attr-ops-table&quot;&gt;Rendering Attributes Table&lt;/a&gt;.
     *
     * @param e an {@code Effect} object that may be used to store the
     *        copy of the current effect, if it is of a compatible type
     * @return the current effect used for all rendering calls,
     *         or null if there is no current effect
     */
    public Effect getEffect(Effect e) {
        return curState.effect == null ? null : EffectHelper.copy(curState.effect);
    }

    /**
     * Applies the given effect to the entire bounds of the canvas and stores
     * the result back into the same canvas.
     * A {@code null} value will be ignored.
     * The effect will be applied without any other rendering attributes and
     * under an Identity coordinate transform.
     * Since the effect is applied to the entire bounds of the canvas, some
     * effects may have a confusing result, such as a Reflection effect
     * that will apply its reflection off of the bottom of the canvas even if
     * only a portion of the canvas has been rendered to and will not be
     * visible unless a negative offset is used to bring the reflection back
     * into view.
     *
     * @param e the effect to apply onto the entire destination or null.
     */
    public void applyEffect(Effect e) {
        if (e == null) return;
        GrowableDataBuffer buf = getBuffer();
        buf.putByte(NGCanvas.FX_APPLY_EFFECT);
        Effect effect = EffectHelper.copy(e);
        EffectHelper.sync(effect);
        buf.putObject(EffectHelper.getPeer(effect));
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/input/Dragboard.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.input;

import java.security.Permission;
import java.util.Set;

import com.sun.javafx.scene.input.DragboardHelper;
import com.sun.javafx.tk.PermissionHelper;
import com.sun.javafx.tk.TKClipboard;
import com.sun.javafx.tk.TKScene;
import javafx.scene.image.Image;

/**
 * A drag and drop specific {@link Clipboard}.
 * @since JavaFX 2.0
 */
public final class Dragboard extends Clipboard {

    /**
     * Whether access to the data requires a permission.
     */
    private boolean dataAccessRestricted = true;

    Dragboard(TKClipboard peer) {
        super(peer);
    }

    @Override
    Object getContentImpl(DataFormat dataFormat) {
        if (dataAccessRestricted) {
            PermissionHelper.checkClipboardPermission();
        }
        return super.getContentImpl(dataFormat);
    }

    /**
     * Gets set of transport modes supported by source of this drag opeation.
     * @return set of supported transfer modes
     */
    public final Set&lt;TransferMode&gt; getTransferModes() {
        return peer.getTransferModes();
    }

    TKClipboard getPeer() {
        return peer;
    }

    static Dragboard createDragboard(TKClipboard peer) {
        return new Dragboard(peer);
    }

    // PENDING_DOC_REVIEW
    /**
     * Sets the visual representation of data being transfered
     * in a drag and drop gesture.
     * Uses the given image for the drag view with the offsetX and offsetY
     * specifying cursor position over the image.
     * This method should be called only when starting drag and drop operation
     * in the DRAG_DETECTED handler, calling it at other times
     * doesn't have any effect.
     * @param image image to use for the drag view
     * @param offsetX x position of the cursor over the image
     * @param offsetY y position of the cursor over the image
<A NAME="9"></A>     * @since JavaFX 8.0
     */
    public void setDragView(Image image, double offsetX, double offsetY) {
        <FONT color="#f88017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#9',2,'match31-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>peer.setDragView(image);
        peer.setDragViewOffsetX(offsetX);
        peer.setDragViewOffsetY(offsetY);
    }

    /**
     * Sets the visual representation of data being transfered
     * in a drag and drop gesture.
     * This method should be called only when starting drag and drop operation
     * in the DRAG_DETECTED handler, calling it at other times
     * doesn't have any effect.
     * @param image image to use for the drag view
     * @since JavaFX 8.0
     */
    public void setDragView(Image image) {
        peer.setDragView(image);
    }

    /**
     * Sets the x position of the cursor of the drag view image.
     * This method should be called only when starting drag and drop operation
     * in the DRAG_DETECTED handler, calling it at other times
     * doesn't have any effect.
     * @param offsetX x position of the cursor over the image
     * @since JavaFX 8.0
     */
    public void setDragViewOffsetX(double offsetX) {
        peer.setDragViewOffsetX(offsetX);
    }

    /**
     * Sets the y position of the cursor of the drag view image.
     * This method should be called only when starting drag and drop operation
     * in the DRAG_DETECTED handler, calling it at other times
     * doesn't have any effect.
     * @param offsetY y position of the cursor over the image
     * @since JavaFX 8.0
     */
    public void setDragViewOffsetY(double offsetY) {</B></FONT>
        peer.setDragViewOffsetY(offsetY);
    }

    /**
     * Gets the image used as a drag view.
     * This method returns meaningful value only when starting drag and drop
     * operation in the DRAG_DETECTED handler, it returns null at other times.
     * @return the image used as a drag view
     * @since JavaFX 8.0
     */
    public Image getDragView() {
        return peer.getDragView();
    }

    /**
     * Gets the x position of the cursor of the drag view image.
     * This method returns meaningful value only when starting drag and drop
     * operation in the DRAG_DETECTED handler, it returns 0 at other times.
     * @return x position of the cursor over the image
     * @since JavaFX 8.0
     */
    public double getDragViewOffsetX() {
        return peer.getDragViewOffsetX();
    }

    /**
     * Gets the y position of the cursor of the drag view image.
     * This method returns meaningful value only when starting drag and drop
     * operation in the DRAG_DETECTED handler, it returns 0 at other times.
     * @return y position of the cursor over the image
     * @since JavaFX 8.0
     */
    public double getDragViewOffsetY() {
        return peer.getDragViewOffsetY();
    }

    static {
        // This is used by classes in different packages to get access to
        // private and package private methods.
        DragboardHelper.setDragboardAccessor(new DragboardHelper.DragboardAccessor() {

            @Override
            public void setDataAccessRestriction(Dragboard dragboard, boolean restricted) {
                dragboard.dataAccessRestricted = restricted;
            }

            @Override
            public TKClipboard getPeer(Dragboard dragboard) {
                return dragboard.getPeer();
            }

            @Override
            public Dragboard createDragboard(TKClipboard peer) {
                return Dragboard.createDragboard(peer);
            }
        });
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/layout/GridPane.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.layout;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.collections.ListChangeListener.Change;
import javafx.collections.ObservableList;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.geometry.Orientation;
import javafx.geometry.Pos;
import javafx.geometry.VPos;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import com.sun.javafx.collections.TrackableObservableList;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableObjectProperty;
import javafx.css.CssMetaData;
import javafx.css.converter.BooleanConverter;
import javafx.css.converter.EnumConverter;
import javafx.css.converter.SizeConverter;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.TreeSet;

import javafx.beans.Observable;
import javafx.css.Styleable;
import javafx.css.StyleableProperty;
import javafx.geometry.BoundingBox;
import javafx.geometry.Bounds;
import javafx.util.Callback;



/**
 * GridPane lays out its children within a flexible grid of rows and columns.
 * If a border and/or padding is set, then its content will be laid out within
 * those insets.
 * &lt;p&gt;
 * A child may be placed anywhere within the grid and may span multiple
 * rows/columns.  Children may freely overlap within rows/columns and their
 * stacking order will be defined by the order of the gridpane's children list
 * (0th node in back, last node in front).
 * &lt;p&gt;
 * GridPane may be styled with backgrounds and borders using CSS.  See
 * {@link javafx.scene.layout.Region Region} superclass for details.&lt;/p&gt;
 *
 * &lt;h3&gt;Grid Constraints&lt;/h3&gt;
 * &lt;p&gt;
 * A child's placement within the grid is defined by it's layout constraints:
 * &lt;/p&gt;
 *
 * &lt;table border=&quot;1&quot;&gt;
 * &lt;caption&gt;Grid Constraint Table&lt;/caption&gt;
 * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Constraint&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Type&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;columnIndex&lt;/th&gt;&lt;td&gt;integer&lt;/td&gt;&lt;td&gt;column where child's layout area starts.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;rowIndex&lt;/th&gt;&lt;td&gt;integer&lt;/td&gt;&lt;td&gt;row where child's layout area starts.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;columnSpan&lt;/th&gt;&lt;td&gt;integer&lt;/td&gt;&lt;td&gt;the number of columns the child's layout area spans horizontally.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;rowSpan&lt;/th&gt;&lt;td&gt;integer&lt;/td&gt;&lt;td&gt;the number of rows the child's layout area spans vertically.&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;p&gt;
 * If the row/column indices are not explicitly set, then the child will be placed
 * in the first row/column.  If row/column spans are not set, they will default to 1.
 * A child's placement constraints can be changed dynamically and the gridpane
 * will update accordingly.
 * &lt;p&gt;
 * The total number of rows/columns does not need to be specified up front as the
 * gridpane will automatically expand/contract the grid to accommodate the content.
 * &lt;p&gt;
 * To use the GridPane, an application needs to set the layout constraints on
 * the children and add those children to the gridpane instance.
 * Constraints are set on the children using static setter methods on the GridPane
 * class:
 * &lt;pre&gt;&lt;code&gt;     GridPane gridpane = new GridPane();
 *
 *     // Set one constraint at a time...
 *     // Places the button at the first row and second column
 *     Button button = new Button();
 *     &lt;b&gt;GridPane.setRowIndex(button, 0);
 *     GridPane.setColumnIndex(button, 1);&lt;/b&gt;
 *
 *     // or convenience methods set more than one constraint at once...
 *     Label label = new Label();
 *     &lt;b&gt;GridPane.setConstraints(label, 2, 0);&lt;/b&gt; // column=2 row=0
 *
 *     // don't forget to add children to gridpane
 *     &lt;b&gt;gridpane.getChildren().addAll(button, label);&lt;/b&gt;
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * Applications may also use convenience methods which combine the steps of
 * setting the constraints and adding the children:
 * &lt;pre&gt;&lt;code&gt;
 *     GridPane gridpane = new GridPane();
 *     &lt;b&gt;gridpane.add(new Button(), 1, 0);&lt;/b&gt; // column=1 row=0
 *     &lt;b&gt;gridpane.add(new Label(), 2, 0);&lt;/b&gt;  // column=2 row=0
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 * &lt;h3&gt;Row/Column Sizing&lt;/h3&gt;
 *
 * By default, rows and columns will be sized to fit their content;
 * a column will be wide enough to accommodate the widest child, a
 * row tall enough to fit the tallest child.However, if an application needs
 * to explicitly control the size of rows or columns, it may do so by adding
 * RowConstraints and ColumnConstraints objects to specify those metrics.
 * For example, to create a grid with two fixed-width columns:
 * &lt;pre&gt;&lt;code&gt;
 *     GridPane gridpane = new GridPane();
 *     &lt;b&gt;gridpane.getColumnConstraints().add(new ColumnConstraints(100));&lt;/b&gt; // column 0 is 100 wide
 *     &lt;b&gt;gridpane.getColumnConstraints().add(new ColumnConstraints(200));&lt;/b&gt; // column 1 is 200 wide
 * &lt;/code&gt;&lt;/pre&gt;
 * By default the gridpane will resize rows/columns to their preferred sizes (either
 * computed from content or fixed), even if the gridpane is resized larger than
 * its preferred size.   If an application needs a particular row or column to
 * grow if there is extra space, it may set its grow priority on the RowConstraints
 * or ColumnConstraints object.  For example:
 * &lt;pre&gt;&lt;code&gt;
 *     GridPane gridpane = new GridPane();
 *     ColumnConstraints column1 = new ColumnConstraints(100,100,Double.MAX_VALUE);
 *     &lt;b&gt;column1.setHgrow(Priority.ALWAYS);&lt;/b&gt;
 *     ColumnConstraints column2 = new ColumnConstraints(100);
 *     gridpane.getColumnConstraints().addAll(column1, column2); // first column gets any extra width
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 * Note: Nodes spanning multiple rows/columns will be also size to the preferred sizes.
 * The affected rows/columns are resized by the following priority: grow priorities, last row.
 * This is with respect to row/column constraints.
 *
 * &lt;h3&gt;Percentage Sizing&lt;/h3&gt;
 *
 * Alternatively, RowConstraints and ColumnConstraints allow the size to be specified
 * as a percentage of gridpane's available space:
 * &lt;pre&gt;&lt;code&gt;
 *     GridPane gridpane = new GridPane();
 *     ColumnConstraints column1 = new ColumnConstraints();
 *     &lt;b&gt;column1.setPercentWidth(50);&lt;/b&gt;
 *     ColumnConstraints column2 = new ColumnConstraints();
 *     &lt;b&gt;column2.setPercentWidth(50);&lt;/b&gt;
 *     gridpane.getColumnConstraints().addAll(column1, column2); // each get 50% of width
 * &lt;/code&gt;&lt;/pre&gt;
 * If a percentage value is set on a row/column, then that value takes precedent and the
 * row/column's min, pref, max, and grow constraints will be ignored.
 * &lt;p&gt;
 * Note that if the sum of the widthPercent (or heightPercent) values total greater than 100, the values will
 * be treated as weights.  e.g.  if 3 columns are each given a widthPercent of 50,
 * then each will be allocated 1/3 of the gridpane's available width (50/(50+50+50)).
 *
 * &lt;h3&gt;Mixing Size Types&lt;/h3&gt;
 *
 * An application may freely mix the size-types of rows/columns (computed from content, fixed,
 * or percentage).  The percentage rows/columns will always be allocated space first
 * based on their percentage of the gridpane's available space (size minus insets and gaps).
 * The remaining space will be allocated to rows/columns given their minimum, preferred,
 * and maximum sizes and grow priorities.
 *
 * &lt;h3&gt;Resizable Range&lt;/h3&gt;
 * &lt;p&gt;
 * A gridpane's parent will resize the gridpane within the gridpane's resizable range
 * during layout.   By default the gridpane computes this range based on its content
 * and row/column constraints as outlined in the table below.
 * &lt;/p&gt;
 *
 * &lt;table border=&quot;1&quot;&gt;
 * &lt;caption&gt;GridPane Resize Table&lt;/caption&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;th scope=&quot;col&quot;&gt;width&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;height&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;minimum&lt;/th&gt;
 * &lt;td&gt;left/right insets plus the sum of each column's min width.&lt;/td&gt;
 * &lt;td&gt;top/bottom insets plus the sum of each row's min height.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;preferred&lt;/th&gt;
 * &lt;td&gt;left/right insets plus the sum of each column's pref width.&lt;/td&gt;
 * &lt;td&gt;top/bottom insets plus the sum of each row's pref height.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;maximum&lt;/th&gt;
 * &lt;td&gt;Double.MAX_VALUE&lt;/td&gt;&lt;td&gt;Double.MAX_VALUE&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;p&gt;
 * A gridpane's unbounded maximum width and height are an indication to the parent that
 * it may be resized beyond its preferred size to fill whatever space is assigned
 * to it.
 * &lt;p&gt;
 * GridPane provides properties for setting the size range directly.  These
 * properties default to the sentinel value USE_COMPUTED_SIZE, however the
 * application may set them to other values as needed:
 * &lt;pre&gt;&lt;code&gt;     &lt;b&gt;gridpane.setPrefSize(300, 300);&lt;/b&gt;
 *     // never size the gridpane larger than its preferred size:
 *     &lt;b&gt;gridpane.setMaxSize(Region.USE_COMPUTED_SIZE, Region.USE_COMPUTED_SIZE);&lt;/b&gt;
 * &lt;/code&gt;&lt;/pre&gt;
 * Applications may restore the computed values by setting these properties back
 * to USE_COMPUTED_SIZE.
 * &lt;p&gt;
 * GridPane does not clip its content by default, so it is possible that children's
 * bounds may extend outside its own bounds if a child's min size prevents it from
 * being fit within it space.&lt;/p&gt;
 *
 * &lt;h3&gt;Optional Layout Constraints&lt;/h3&gt;
 *
 * &lt;p&gt;
 * An application may set additional constraints on children to customize how the
 * child is sized and positioned within the layout area established by it's row/column
 * indices/spans:
 * &lt;/p&gt;
 *
 * &lt;table border=&quot;1&quot;&gt;
 * &lt;caption&gt;GridPane Constraint Table&lt;/caption&gt;
 * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Constraint&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Type&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;halignment&lt;/th&gt;&lt;td&gt;javafx.geometry.HPos&lt;/td&gt;&lt;td&gt;The horizontal alignment of the child within its layout area.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;valignment&lt;/th&gt;&lt;td&gt;javafx.geometry.VPos&lt;/td&gt;&lt;td&gt;The vertical alignment of the child within its layout area.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;hgrow&lt;/th&gt;&lt;td&gt;javafx.scene.layout.Priority&lt;/td&gt;&lt;td&gt;The horizontal grow priority of the child.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;vgrow&lt;/th&gt;&lt;td&gt;javafx.scene.layout.Priority&lt;/td&gt;&lt;td&gt;The vertical grow priority of the child.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;margin&lt;/th&gt;&lt;td&gt;javafx.geometry.Insets&lt;/td&gt;&lt;td&gt;Margin space around the outside of the child.&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;p&gt;
 * By default the alignment of a child within its layout area is defined by the
 * alignment set for the row and column.  If an individual alignment constraint is
 * set on a child, that alignment will override the row/column alignment only
 * for that child.  Alignment of other children in the same row or column will
 * not be affected.
 * &lt;p&gt;
 * Grow priorities, on the other hand, can only be applied to entire rows or columns.
 * Therefore, if a grow priority constraint is set on a single child, it will be
 * used to compute the default grow priority of the encompassing row/column.  If
 * a grow priority is set directly on a RowConstraint or ColumnConstraint object,
 * it will override the value computed from content.
 *
 *
 * @since JavaFX 2.0
 */
public class GridPane extends Pane {

    /**
     * Sentinel value which may be set on a child's row/column span constraint to
     * indicate that it should span the remaining rows/columns.
     */
    public static final int REMAINING = Integer.MAX_VALUE;

    /********************************************************************
     *  BEGIN static methods
     ********************************************************************/
    private static final String MARGIN_CONSTRAINT = &quot;gridpane-margin&quot;;
    private static final String HALIGNMENT_CONSTRAINT = &quot;gridpane-halignment&quot;;
    private static final String VALIGNMENT_CONSTRAINT = &quot;gridpane-valignment&quot;;
    private static final String HGROW_CONSTRAINT = &quot;gridpane-hgrow&quot;;
    private static final String VGROW_CONSTRAINT = &quot;gridpane-vgrow&quot;;
    private static final String ROW_INDEX_CONSTRAINT = &quot;gridpane-row&quot;;
    private static final String COLUMN_INDEX_CONSTRAINT = &quot;gridpane-column&quot;;
    private static final String ROW_SPAN_CONSTRAINT = &quot;gridpane-row-span&quot;;
    private static final String COLUMN_SPAN_CONSTRAINT = &quot;gridpane-column-span&quot;;
    private static final String FILL_WIDTH_CONSTRAINT = &quot;gridpane-fill-width&quot;;
    private static final String FILL_HEIGHT_CONSTRAINT = &quot;gridpane-fill-height&quot;;

    /**
     * Sets the row index for the child when contained by a gridpane
     * so that it will be positioned starting in that row of the gridpane.
     * If a gridpane child has no row index set, it will be positioned in the
     * first row.
     * Setting the value to null will remove the constraint.
     * @param child the child node of a gridpane
     * @param value the row index of the child
     */
    public static void setRowIndex(Node child, Integer value) {
        if (value != null &amp;&amp; value &lt; 0) {
            throw new IllegalArgumentException(&quot;rowIndex must be greater or equal to 0, but was &quot;+value);
        }
        setConstraint(child, ROW_INDEX_CONSTRAINT, value);
    }

    /**
     * Returns the child's row index constraint if set.
     * @param child the child node of a gridpane
     * @return the row index for the child or null if no row index was set
     */
    public static Integer getRowIndex(Node child) {
        return (Integer)getConstraint(child, ROW_INDEX_CONSTRAINT);
    }

    /**
     * Sets the column index for the child when contained by a gridpane
     * so that it will be positioned starting in that column of the gridpane.
     * If a gridpane child has no column index set, it will be positioned in
     * the first column.
     * Setting the value to null will remove the constraint.
     * @param child the child node of a gridpane
     * @param value the column index of the child
     */
    public static void setColumnIndex(Node child, Integer value) {
        if (value != null &amp;&amp; value &lt; 0) {
            throw new IllegalArgumentException(&quot;columnIndex must be greater or equal to 0, but was &quot;+value);
        }
        setConstraint(child, COLUMN_INDEX_CONSTRAINT, value);
    }

    /**
     * Returns the child's column index constraint if set.
     * @param child the child node of a gridpane
     * @return the column index for the child or null if no column index was set
     */
    public static Integer getColumnIndex(Node child) {
        return (Integer)getConstraint(child, COLUMN_INDEX_CONSTRAINT);
    }

    /**
     * Sets the row span for the child when contained by a gridpane
     * so that it will span that number of rows vertically.  This may be
     * set to REMAINING, which will cause the span to extend across all the remaining
     * rows.
     * &lt;p&gt;
     * If a gridpane child has no row span set, it will default to spanning one row.
     * Setting the value to null will remove the constraint.
     * @param child the child node of a gridpane
     * @param value the row span of the child
     */
    public static void setRowSpan(Node child, Integer value) {
        if (value != null &amp;&amp; value &lt; 1) {
            throw new IllegalArgumentException(&quot;rowSpan must be greater or equal to 1, but was &quot;+value);
        }
        setConstraint(child, ROW_SPAN_CONSTRAINT, value);
    }

    /**
     * Returns the child's row-span constraint if set.
     * @param child the child node of a gridpane
     * @return the row span for the child or null if no row span was set
     */
    public static Integer getRowSpan(Node child) {
        return (Integer)getConstraint(child, ROW_SPAN_CONSTRAINT);
    }

    /**
     * Sets the column span for the child when contained by a gridpane
     * so that it will span that number of columns horizontally.   This may be
     * set to REMAINING, which will cause the span to extend across all the remaining
     * columns.
     * &lt;p&gt;
     * If a gridpane child has no column span set, it will default to spanning one column.
     * Setting the value to null will remove the constraint.
     * @param child the child node of a gridpane
     * @param value the column span of the child
     */
    public static void setColumnSpan(Node child, Integer value) {
        if (value != null &amp;&amp; value &lt; 1) {
            throw new IllegalArgumentException(&quot;columnSpan must be greater or equal to 1, but was &quot;+value);
        }
        setConstraint(child, COLUMN_SPAN_CONSTRAINT, value);
    }

    /**
     * Returns the child's column-span constraint if set.
     * @param child the child node of a gridpane
     * @return the column span for the child or null if no column span was set
     */
    public static Integer getColumnSpan(Node child) {
        return (Integer)getConstraint(child, COLUMN_SPAN_CONSTRAINT);
    }

    /**
     * Sets the margin for the child when contained by a gridpane.
     * If set, the gridpane will lay it out with the margin space around it.
     * Setting the value to null will remove the constraint.
     * @param child the child node of a gridpane
     * @param value the margin of space around the child
     */
    public static void setMargin(Node child, Insets value) {
        setConstraint(child, MARGIN_CONSTRAINT, value);
    }

    /**
     * Returns the child's margin constraint if set.
     * @param child the child node of a gridpane
     * @return the margin for the child or null if no margin was set
     */
    public static Insets getMargin(Node child) {
        return (Insets)getConstraint(child, MARGIN_CONSTRAINT);
    }

    private double getBaselineComplementForChild(Node child) {
        if (isNodePositionedByBaseline(child)) {
            return rowMinBaselineComplement[getNodeRowIndex(child)];
        }
        return -1;
    }

    private static final Callback&lt;Node, Insets&gt; marginAccessor = n -&gt; getMargin(n);

    /**
     * Sets the horizontal alignment for the child when contained by a gridpane.
     * If set, will override the gridpane's default horizontal alignment.
     * Setting the value to null will remove the constraint.
     * @param child the child node of a gridpane
     * @param value the hozizontal alignment for the child
     */
    public static void setHalignment(Node child, HPos value) {
        setConstraint(child, HALIGNMENT_CONSTRAINT, value);
    }

    /**
     * Returns the child's halignment constraint if set.
     * @param child the child node of a gridpane
     * @return the horizontal alignment for the child or null if no alignment was set
     */
    public static HPos getHalignment(Node child) {
        return (HPos)getConstraint(child, HALIGNMENT_CONSTRAINT);
    }

    /**
     * Sets the vertical alignment for the child when contained by a gridpane.
     * If set, will override the gridpane's default vertical alignment.
     * Setting the value to null will remove the constraint.
     * @param child the child node of a gridpane
     * @param value the vertical alignment for the child
     */
    public static void setValignment(Node child, VPos value) {
        setConstraint(child, VALIGNMENT_CONSTRAINT, value);
    }

    /**
     * Returns the child's valignment constraint if set.
     * @param child the child node of a gridpane
     * @return the vertical alignment for the child or null if no alignment was set
     */
    public static VPos getValignment(Node child) {
        return (VPos)getConstraint(child, VALIGNMENT_CONSTRAINT);
    }

    /**
     * Sets the horizontal grow priority for the child when contained by a gridpane.
     * If set, the gridpane will use the priority to allocate the child additional
     * horizontal space if the gridpane is resized larger than it's preferred width.
     * Setting the value to null will remove the constraint.
     * @param child the child of a gridpane
     * @param value the horizontal grow priority for the child
     */
    public static void setHgrow(Node child, Priority value) {
        setConstraint(child, HGROW_CONSTRAINT, value);
    }

    /**
     * Returns the child's hgrow constraint if set.
     * @param child the child node of a gridpane
     * @return the horizontal grow priority for the child or null if no priority was set
     */
    public static Priority getHgrow(Node child) {
        return (Priority)getConstraint(child, HGROW_CONSTRAINT);
    }

    /**
     * Sets the vertical grow priority for the child when contained by a gridpane.
     * If set, the gridpane will use the priority to allocate the child additional
     * vertical space if the gridpane is resized larger than it's preferred height.
     * Setting the value to null will remove the constraint.
     * @param child the child of a gridpane
     * @param value the vertical grow priority for the child
     */
    public static void setVgrow(Node child, Priority value) {
        setConstraint(child, VGROW_CONSTRAINT, value);
    }

    /**
     * Returns the child's vgrow constraint if set.
     * @param child the child node of a gridpane
     * @return the vertical grow priority for the child or null if no priority was set
     */
    public static Priority getVgrow(Node child) {
        return (Priority)getConstraint(child, VGROW_CONSTRAINT);
    }

    /**
     * Sets the horizontal fill policy for the child when contained by a gridpane.
     * If set, the gridpane will use the policy to determine whether node
     * should be expanded to fill the column or resized to its preferred width.
     * Setting the value to null will remove the constraint.
     * If not value is specified for the node nor for the column, the default value is true.
     * @param child the child node of a gridpane
     * @param value the horizontal fill policy or null for unset
     * @since JavaFX 8.0
     */
    public static void setFillWidth(Node child, Boolean value) {
        setConstraint(child, FILL_WIDTH_CONSTRAINT, value);
    }

    /**
     * Returns the child's horizontal fill policy if set
     * @param child the child node of a gridpane
     * @return the horizontal fill policy for the child or null if no policy was set
     * @since JavaFX 8.0
     */
    public static Boolean isFillWidth(Node child) {
        return (Boolean) getConstraint(child, FILL_WIDTH_CONSTRAINT);
    }

    /**
     * Sets the vertical fill policy for the child when contained by a gridpane.
     * If set, the gridpane will use the policy to determine whether node
     * should be expanded to fill the row or resized to its preferred height.
     * Setting the value to null will remove the constraint.
     * If not value is specified for the node nor for the row, the default value is true.
     * @param child the child node of a gridpane
     * @param value the vertical fill policy or null for unset
     * @since JavaFX 8.0
     */
    public static void setFillHeight(Node child, Boolean value) {
        setConstraint(child, FILL_HEIGHT_CONSTRAINT, value);
    }

    /**
     * Returns the child's vertical fill policy if set
     * @param child the child node of a gridpane
     * @return the vertical fill policy for the child or null if no policy was set
     * @since JavaFX 8.0
     */
    public static Boolean isFillHeight(Node child) {
        return (Boolean) getConstraint(child, FILL_HEIGHT_CONSTRAINT);
    }

    /**
     * Sets the column,row indeces for the child when contained in a gridpane.
     * @param child the child node of a gridpane
     * @param columnIndex the column index position for the child
     * @param rowIndex the row index position for the child
     */
    public static void setConstraints(Node child, int columnIndex, int rowIndex) {
        setRowIndex(child, rowIndex);
        setColumnIndex(child, columnIndex);
    }

    /**
     * Sets the column, row, column-span, and row-span value for the child when
     * contained in a gridpane.
     * @param child the child node of a gridpane
     * @param columnIndex the column index position for the child
     * @param rowIndex the row index position for the child
     * @param columnspan the number of columns the child should span
     * @param rowspan the number of rows the child should span
     */
    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan) {
        setRowIndex(child, rowIndex);
        setColumnIndex(child, columnIndex);
        setRowSpan(child, rowspan);
        setColumnSpan(child, columnspan);
    }

    /**
     * Sets the grid position, spans, and alignment for the child when contained in a gridpane.
     * @param child the child node of a gridpane
     * @param columnIndex the column index position for the child
     * @param rowIndex the row index position for the child
     * @param columnspan the number of columns the child should span
     * @param rowspan the number of rows the child should span
<A NAME="21"></A>     * @param halignment the horizontal alignment of the child
     * @param valignment the vertical alignment of the child
     */
    public static void setConstraints(<FONT color="#00ff00"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#21',2,'match31-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Node child, int columnIndex, int rowIndex, int columnspan, int rowspan,
            HPos halignment, VPos valignment) {
        setRowIndex(child, rowIndex);
        setColumnIndex(child, columnIndex);
        setRowSpan(child, rowspan);
        setColumnSpan(child, columnspan);
        setHalignment(child, halignment);
        setValignment(child, valignment);
    }

    /**
     * Sets the grid position, spans, and alignment for the child when contained in a gridpane.
     * @param child the child node of a gridpane
     * @param columnIndex the column index position for the child
     * @param rowIndex the row index position for the child
     * @param columnspan the number of columns the child should span
     * @param rowspan the number of rows the child should span
     * @param halignment the horizontal alignment of the child
     * @param valignment the vertical alignment of the child
     * @param hgrow the horizontal grow priority of the child
     * @param vgrow the vertical grow priority of the child
     */
    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan,
            HPos halignment, VPos valignment, Priority hgrow</B></FONT>, Priority vgrow) {
        setRowIndex(child, rowIndex);
        setColumnIndex(child, columnIndex);
        setRowSpan(child, rowspan);
        setColumnSpan(child, columnspan);
        setHalignment(child, halignment);
        setValignment(child, valignment);
        setHgrow(child, hgrow);
        setVgrow(child, vgrow);
    }

    /**
     * Sets the grid position, spans, alignment, grow priorities, and margin for
     * the child when contained in a gridpane.
     * @param child the child node of a gridpane
     * @param columnIndex the column index position for the child
     * @param rowIndex the row index position for the child
     * @param columnspan the number of columns the child should span
     * @param rowspan the number of rows the child should span
     * @param halignment the horizontal alignment of the child
     * @param valignment the vertical alignment of the child
     * @param hgrow the horizontal grow priority of the child
     * @param vgrow the vertical grow priority of the child
     * @param margin the margin of space around the child
     */
    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan,
            HPos halignment, VPos valignment, Priority hgrow, Priority vgrow, Insets margin) {
        setRowIndex(child, rowIndex);
        setColumnIndex(child, columnIndex);
        setRowSpan(child, rowspan);
        setColumnSpan(child, columnspan);
        setHalignment(child, halignment);
        setValignment(child, valignment);
        setHgrow(child, hgrow);
        setVgrow(child, vgrow);
        setMargin(child, margin);
    }

    /**
     * Removes all gridpane constraints from the child node.
     * @param child the child node
     */
    public static void clearConstraints(Node child) {
        setRowIndex(child, null);
        setColumnIndex(child, null);
        setRowSpan(child, null);
        setColumnSpan(child, null);
        setHalignment(child, null);
        setValignment(child, null);
        setHgrow(child, null);
        setVgrow(child, null);
        setMargin(child, null);
    }


    private static final Color GRID_LINE_COLOR = Color.rgb(30, 30, 30);
    private static final double GRID_LINE_DASH = 3;

    static void createRow(int rowIndex, int columnIndex, Node... nodes) {
        for (int i = 0; i &lt; nodes.length; i++) {
            setConstraints(nodes[i], columnIndex + i, rowIndex);
        }
    }

    static void createColumn(int columnIndex, int rowIndex, Node... nodes) {
        for (int i = 0; i &lt; nodes.length; i++) {
            setConstraints(nodes[i], columnIndex, rowIndex + i);
        }
    }

    static int getNodeRowIndex(Node node) {
        Integer rowIndex = getRowIndex(node);
        return rowIndex != null? rowIndex : 0;
    }

    private static int getNodeRowSpan(Node node) {
        Integer rowspan = getRowSpan(node);
        return rowspan != null? rowspan : 1;
    }

    static int getNodeRowEnd(Node node) {
        int rowSpan = getNodeRowSpan(node);
        return rowSpan != REMAINING? getNodeRowIndex(node) + rowSpan - 1 : REMAINING;
    }

    static int getNodeColumnIndex(Node node) {
        Integer columnIndex = getColumnIndex(node);
        return columnIndex != null? columnIndex : 0;
    }

    private static int getNodeColumnSpan(Node node) {
        Integer colspan = getColumnSpan(node);
        return colspan != null? colspan : 1;
    }

    static int getNodeColumnEnd(Node node) {
        int columnSpan = getNodeColumnSpan(node);
        return columnSpan != REMAINING? getNodeColumnIndex(node) + columnSpan - 1 : REMAINING;
    }

    private static Priority getNodeHgrow(Node node) {
        Priority hgrow = getHgrow(node);
        return hgrow != null? hgrow : Priority.NEVER;
    }

    private static Priority getNodeVgrow(Node node) {
        Priority vgrow = getVgrow(node);
        return vgrow != null? vgrow : Priority.NEVER;
    }

    private static Priority[] createPriorityArray(int length, Priority value) {
        Priority[] array = new Priority[length];
        Arrays.fill(array, value);
        return array;
    }

    /********************************************************************
     *  END static methods
     ********************************************************************/

    /**
     * Creates a GridPane layout with hgap/vgap = 0 and TOP_LEFT alignment.
     */
    public GridPane() {
        super();
        getChildren().addListener((Observable o) -&gt; requestLayout());
    }

    /**
     * The width of the horizontal gaps between columns.
     * @return the width of the horizontal gaps between columns
     */
    public final DoubleProperty hgapProperty() {
        if (hgap == null) {
            hgap = new StyleableDoubleProperty(0) {
                @Override
                public void invalidated() {
                    requestLayout();
                }

                @Override
                public CssMetaData&lt;GridPane, Number&gt; getCssMetaData() {
                    return StyleableProperties.HGAP;
                }

                @Override
                public Object getBean() {
                    return GridPane.this;
                }

                @Override
                public String getName() {
                    return &quot;hgap&quot;;
                }
            };
        }
        return hgap;
    }

    private DoubleProperty hgap;
    public final void setHgap(double value) { hgapProperty().set(value); }
    public final double getHgap() { return hgap == null ? 0 : hgap.get(); }

    /**
     * The height of the vertical gaps between rows.
     * @return the height of the vertical gaps between rows
     */
    public final DoubleProperty vgapProperty() {
        if (vgap == null) {
            vgap = new StyleableDoubleProperty(0) {
                @Override
                public void invalidated() {
                    requestLayout();
                }

                @Override
                public CssMetaData&lt;GridPane, Number&gt; getCssMetaData() {
                    return StyleableProperties.VGAP;
                }

                @Override
                public Object getBean() {
                    return GridPane.this;
                }

                @Override
                public String getName() {
                    return &quot;vgap&quot;;
                }
            };
        }
        return vgap;
    }

    private DoubleProperty vgap;
    public final void setVgap(double value) { vgapProperty().set(value); }
    public final double getVgap() { return vgap == null ? 0 : vgap.get(); }

    /**
     * The alignment of the grid within the gridpane's width and height.
     * @return the alignment of the grid within the gridpane's width and height
     */
    public final ObjectProperty&lt;Pos&gt; alignmentProperty() {
        if (alignment == null) {
            alignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.TOP_LEFT) {
                @Override
                public void invalidated() {
                    requestLayout();
                }

                @Override
                public CssMetaData&lt;GridPane, Pos&gt; getCssMetaData() {
                    return StyleableProperties.ALIGNMENT;
                }

                @Override
                public Object getBean() {
                    return GridPane.this;
                }

                @Override
                public String getName() {
                    return &quot;alignment&quot;;
                }
            };
        }
        return alignment;
    }

    private ObjectProperty&lt;Pos&gt; alignment;
    public final void setAlignment(Pos value) {
        alignmentProperty().set(value);
    }
    public final Pos getAlignment() {
        return alignment == null ? Pos.TOP_LEFT : alignment.get();
    }
    private Pos getAlignmentInternal() {
        Pos localPos = getAlignment();
        return localPos == null ? Pos.TOP_LEFT : localPos;
    }

    /**
     * For debug purposes only: controls whether lines are displayed to show the gridpane's rows and columns.
     * Default is &lt;code&gt;false&lt;/code&gt;.
     * @return true if lines are displayed to show the gridpane's rows and columns
     */
    public final BooleanProperty gridLinesVisibleProperty() {
        if (gridLinesVisible == null) {
            gridLinesVisible = new StyleableBooleanProperty() {
                @Override
                protected void invalidated() {
                    if (get()) {
                        gridLines = new Group();
                        gridLines.setManaged(false);
                        getChildren().add(gridLines);
                    } else {
                        getChildren().remove(gridLines);
                        gridLines = null;
                    }
                    requestLayout();
                }

                @Override
                public CssMetaData&lt;GridPane, Boolean&gt; getCssMetaData() {
                    return StyleableProperties.GRID_LINES_VISIBLE;
                }

                @Override
                public Object getBean() {
                    return GridPane.this;
                }

                @Override
                public String getName() {
                    return &quot;gridLinesVisible&quot;;
                }
            };
        }
        return gridLinesVisible;
    }

    private BooleanProperty gridLinesVisible;
    public final void setGridLinesVisible(boolean value) { gridLinesVisibleProperty().set(value); }
    public final boolean isGridLinesVisible() { return gridLinesVisible == null ? false : gridLinesVisible.get(); }

    /**
     * RowConstraints instances can be added to explicitly control individual row
     * sizing and layout behavior.
     * If not set, row sizing and layout behavior will be computed based on content.
     *
     */
    private final ObservableList&lt;RowConstraints&gt; rowConstraints = new TrackableObservableList&lt;RowConstraints&gt;() {
        @Override
        protected void onChanged(Change&lt;RowConstraints&gt; c) {
            while (c.next()) {
                for (RowConstraints constraints : c.getRemoved()) {
                    if (constraints != null &amp;&amp; !rowConstraints.contains(constraints)) {
                        constraints.remove(GridPane.this);
                    }
                }
                for (RowConstraints constraints : c.getAddedSubList()) {
                    if (constraints != null) {
                        constraints.add(GridPane.this);
                    }
                }
            }
            requestLayout();
        }
    };

    /**
     * Returns list of row constraints. Row constraints can be added to
     * explicitly control individual row sizing and layout behavior.
     * If not set, row sizing and layout behavior is computed based on content.
     *
     * Index in the ObservableList denotes the row number, so the row constraint for the first row
     * is at the position of 0.
     * @return the list of row constraints
     */
    public final ObservableList&lt;RowConstraints&gt; getRowConstraints() { return rowConstraints; }
    /**
     * ColumnConstraints instances can be added to explicitly control individual column
     * sizing and layout behavior.
     * If not set, column sizing and layout behavior will be computed based on content.
     */
    private final ObservableList&lt;ColumnConstraints&gt; columnConstraints = new TrackableObservableList&lt;ColumnConstraints&gt;() {
        @Override
        protected void onChanged(Change&lt;ColumnConstraints&gt; c) {
            while(c.next()) {
                for (ColumnConstraints constraints : c.getRemoved()) {
                    if (constraints != null &amp;&amp; !columnConstraints.contains(constraints)) {
                        constraints.remove(GridPane.this);
                    }
                }
                for (ColumnConstraints constraints : c.getAddedSubList()) {
                    if (constraints != null) {
                        constraints.add(GridPane.this);
                    }
                }
            }
            requestLayout();
        }
    };

    /**
     * Returns list of column constraints. Column constraints can be added to
     * explicitly control individual column sizing and layout behavior.
     * If not set, column sizing and layout behavior is computed based on content.
     *
     * Index in the ObservableList denotes the column number, so the column constraint for the first column
     * is at the position of 0.
     * @return the list of column constraints
     */
    public final ObservableList&lt;ColumnConstraints&gt; getColumnConstraints() { return columnConstraints; }

    /**
     * Adds a child to the gridpane at the specified column,row position.
     * This convenience method will set the gridpane column and row constraints
     * on the child.
     * @param child the node being added to the gridpane
     * @param columnIndex the column index position for the child within the gridpane, counting from 0
     * @param rowIndex the row index position for the child within the gridpane, counting from 0
     */
    public void add(Node child, int columnIndex, int rowIndex) {
        setConstraints(child, columnIndex, rowIndex);
        getChildren().add(child);
    }

    /**
     * Adds a child to the gridpane at the specified column,row position and spans.
     * This convenience method will set the gridpane column, row, and span constraints
     * on the child.
     * @param child the node being added to the gridpane
     * @param columnIndex the column index position for the child within the gridpane, counting from 0
     * @param rowIndex the row index position for the child within the gridpane, counting from 0
     * @param colspan the number of columns the child's layout area should span
     * @param rowspan the number of rows the child's layout area should span
     */
    public void add(Node child, int columnIndex, int rowIndex, int colspan, int rowspan) {
        setConstraints(child, columnIndex, rowIndex, colspan, rowspan);
        getChildren().add(child);
    }

    /**
     * Convenience method for placing the specified nodes sequentially in a given
     * row of the gridpane.    If the row already contains nodes the specified nodes
     * will be appended to the row.  For example, the first node will be positioned at [column,row],
     * the second at [column+1,row], etc.   This method will set the appropriate gridpane
     * row/column constraints on the nodes as well as add the nodes to the gridpane's
     * children sequence.
     *
     * @param rowIndex the row index position for the children within the gridpane
     * @param children the nodes to be added as a row in the gridpane
     */
    public void addRow(int rowIndex, Node... children) {
        int columnIndex = 0;
        final List&lt;Node&gt; managed = getManagedChildren();
        for (int i = 0, size = managed.size(); i &lt; size; i++) {
            Node child = managed.get(i);
            final int nodeRowIndex = getNodeRowIndex(child);
            final int nodeRowEnd = getNodeRowEnd(child);
            if (rowIndex &gt;= nodeRowIndex &amp;&amp;
                    (rowIndex &lt;= nodeRowEnd || nodeRowEnd == REMAINING)) {
                int index = getNodeColumnIndex(child);
                int end = getNodeColumnEnd(child);
                columnIndex = Math.max(columnIndex, (end != REMAINING? end : index) + 1);
            }
        }
        createRow(rowIndex, columnIndex, children);
        getChildren().addAll(children);
    }

    /**
     * Convenience method for placing the specified nodes sequentially in a given
     * column of the gridpane.    If the column already contains nodes the specified nodes
     * will be appended to the column.  For example, the first node will be positioned at [column, row],
     * the second at [column, row+1], etc.   This method will set the appropriate gridpane
     * row/column constraints on the nodes as well as add the nodes to the gridpane's
     * children sequence.
     *
     * @param columnIndex the column index position for the children within the gridpane
     * @param children the nodes to be added as a column in the gridpane
     */
    public void addColumn(int columnIndex, Node... children)  {
        int rowIndex = 0;
        final List&lt;Node&gt; managed = getManagedChildren();
        for (int i = 0, size = managed.size(); i &lt; size; i++) {
            Node child = managed.get(i);
            final int nodeColumnIndex = getNodeColumnIndex(child);
            final int nodeColumnEnd = getNodeColumnEnd(child);
            if (columnIndex &gt;= nodeColumnIndex
                    &amp;&amp; (columnIndex &lt;= nodeColumnEnd || nodeColumnEnd == REMAINING)) {
                int index = getNodeRowIndex(child);
                int end = getNodeRowEnd(child);
                rowIndex = Math.max(rowIndex, (end != REMAINING? end : index) + 1);
            }
        }
        createColumn(columnIndex, rowIndex, children);
        getChildren().addAll(children);
    }

    private Group gridLines;
    private Orientation bias;

    private double[] rowPercentHeight;
    private double rowPercentTotal = 0;

    private CompositeSize rowMinHeight;
    private CompositeSize rowPrefHeight;
    private CompositeSize  rowMaxHeight;
    private List&lt;Node&gt;[] rowBaseline;
    private double[] rowMinBaselineComplement;
    private double[] rowPrefBaselineComplement;
    private double[] rowMaxBaselineComplement;
    private Priority[] rowGrow;

    private double[] columnPercentWidth;
    private double columnPercentTotal = 0;

    private CompositeSize columnMinWidth;
    private CompositeSize columnPrefWidth;
    private CompositeSize columnMaxWidth;
    private Priority[] columnGrow;

    private boolean metricsDirty = true;

    // This is set to true while in layoutChildren and set false on the conclusion.
    // It is used to decide whether to update metricsDirty in requestLayout().
    private boolean performingLayout = false;

    private int numRows;
    private int numColumns;

    private int getNumberOfRows() {
        computeGridMetrics();
        return numRows;
    }

    private int getNumberOfColumns() {
        computeGridMetrics();
        return numColumns;
    }

    private boolean isNodePositionedByBaseline(Node n){
        return (getRowValignment(getNodeRowIndex(n)) == VPos.BASELINE &amp;&amp; getValignment(n) == null)
                || getValignment(n) == VPos.BASELINE;
    }

    private void computeGridMetrics() {
        if (metricsDirty) {
            numRows = rowConstraints.size();
            numColumns = columnConstraints.size();
            final List&lt;Node&gt; managed = getManagedChildren();
            for (int i = 0, size = managed.size(); i &lt; size; i++) {
                Node child = managed.get(i);
                int rowIndex = getNodeRowIndex(child);
                int columnIndex = getNodeColumnIndex(child);
                int rowEnd = getNodeRowEnd(child);
                int columnEnd = getNodeColumnEnd(child);
                numRows = Math.max(numRows, (rowEnd != REMAINING ? rowEnd : rowIndex) + 1);
                numColumns = Math.max(numColumns, (columnEnd != REMAINING ? columnEnd : columnIndex) + 1);
            }
            rowPercentHeight = createDoubleArray(numRows, -1);
            rowPercentTotal = 0;
            columnPercentWidth = createDoubleArray(numColumns, -1);
            columnPercentTotal = 0;
            columnGrow = createPriorityArray(numColumns, Priority.NEVER);
            rowGrow = createPriorityArray(numRows, Priority.NEVER);
            rowMinBaselineComplement = createDoubleArray(numRows, -1);
            rowPrefBaselineComplement = createDoubleArray(numRows, -1);
            rowMaxBaselineComplement = createDoubleArray(numRows, -1);
            rowBaseline = new List[numRows];
            for (int i = 0, sz = numRows; i &lt; sz; ++i) {
                if (i &lt; rowConstraints.size()) {
                    final RowConstraints rc = rowConstraints.get(i);
                    double percentHeight = rc.getPercentHeight();
                    Priority vGrow = rc.getVgrow();
                    if (percentHeight &gt;= 0) {
                        rowPercentHeight[i] = percentHeight;
                    }
                    if (vGrow != null) {
                        rowGrow[i] = vGrow;
                    }
                }

                List&lt;Node&gt; baselineNodes = new ArrayList&lt;&gt;(numColumns);
                for (int j = 0, size = managed.size(); j &lt; size; j++) {
                    Node n = managed.get(j);
                    if (getNodeRowIndex(n) == i &amp;&amp; isNodePositionedByBaseline(n)) {
                        baselineNodes.add(n);
                    }
                }
                rowMinBaselineComplement[i] = getMinBaselineComplement(baselineNodes);
                rowPrefBaselineComplement[i] = getPrefBaselineComplement(baselineNodes);
                rowMaxBaselineComplement[i] = getMaxBaselineComplement(baselineNodes);
                rowBaseline[i] = baselineNodes;

            }
            for (int i = 0, sz = Math.min(numColumns, columnConstraints.size()); i &lt; sz; ++i) {
                final ColumnConstraints cc = columnConstraints.get(i);
                double percentWidth = cc.getPercentWidth();
                Priority hGrow = cc.getHgrow();
                if (percentWidth &gt;= 0)
                    columnPercentWidth[i] = percentWidth;
                if (hGrow != null)
                    columnGrow[i] = hGrow;
            }

            for (int i = 0, size = managed.size(); i &lt; size; i++) {
                Node child = managed.get(i);
                if (getNodeColumnSpan(child) == 1) {
                    Priority hg = getNodeHgrow(child);
                    int idx = getNodeColumnIndex(child);
                    columnGrow[idx] = Priority.max(columnGrow[idx], hg);
                }
                if (getNodeRowSpan(child) == 1) {
                    Priority vg = getNodeVgrow(child);
                    int idx = getNodeRowIndex(child);
                    rowGrow[idx] = Priority.max(rowGrow[idx], vg);
                }
            }

            for (int i = 0; i &lt; rowPercentHeight.length; i++) {
                if (rowPercentHeight[i] &gt; 0) {
                    rowPercentTotal += rowPercentHeight[i];
                }
            }
            if (rowPercentTotal &gt; 100) {
                double weight = 100 / rowPercentTotal;
                for (int i = 0; i &lt; rowPercentHeight.length; i++) {
                    if (rowPercentHeight[i] &gt; 0) {
                        rowPercentHeight[i] *= weight;
                    }
                }
                rowPercentTotal = 100;
            }
            for (int i = 0; i &lt; columnPercentWidth.length; i++) {
                if (columnPercentWidth[i] &gt; 0) {
                    columnPercentTotal += columnPercentWidth[i];
                }
            }
            if (columnPercentTotal &gt; 100) {
                double weight = 100 / columnPercentTotal;
                for (int i = 0; i &lt; columnPercentWidth.length; i++) {
                    if (columnPercentWidth[i] &gt; 0) {
                        columnPercentWidth[i] *= weight;
                    }
                }
                columnPercentTotal = 100;
            }

            bias = null;
            for (int i = 0; i &lt; managed.size(); ++i) {
                final Orientation b = managed.get(i).getContentBias();
                if (b != null) {
                    bias = b;
                    if (b == Orientation.HORIZONTAL) {
                        break;
                    }
                }
            }

            metricsDirty = false;
        }
    }

    @Override protected double computeMinWidth(double height) {
        computeGridMetrics();
        performingLayout = true;
        try {
            final double[] heights = height == -1 ? null : computeHeightsToFit(height).asArray();

            return snapSpaceX(getInsets().getLeft()) +
                    computeMinWidths(heights).computeTotalWithMultiSize() +
                    snapSpaceX(getInsets().getRight());
        } finally {
            performingLayout = false;
        }

    }

    @Override protected double computeMinHeight(double width) {
        computeGridMetrics();
        performingLayout = true;
        try {
            final double[] widths = width == -1 ? null : computeWidthsToFit(width).asArray();

            return snapSpaceY(getInsets().getTop()) +
                    computeMinHeights(widths).computeTotalWithMultiSize() +
                    snapSpaceY(getInsets().getBottom());
        } finally {
            performingLayout = false;
        }
    }

    @Override protected double computePrefWidth(double height) {
        computeGridMetrics();
        performingLayout = true;
        try {
            final double[] heights = height == -1 ? null : computeHeightsToFit(height).asArray();

            return snapSpaceX(getInsets().getLeft()) +
                    computePrefWidths(heights).computeTotalWithMultiSize() +
                    snapSpaceX(getInsets().getRight());
        } finally {
            performingLayout = false;
        }
    }

    @Override protected double computePrefHeight(double width) {
        computeGridMetrics();
        performingLayout = true;
        try {
            final double[] widths = width == -1 ? null : computeWidthsToFit(width).asArray();

            return snapSpaceY(getInsets().getTop()) +
                    computePrefHeights(widths).computeTotalWithMultiSize() +
                    snapSpaceY(getInsets().getBottom());
        } finally {
            performingLayout = false;
        }
    }

    private VPos getRowValignment(int rowIndex) {
        if (rowIndex &lt; getRowConstraints().size()) {
            RowConstraints constraints = getRowConstraints().get(rowIndex);
            if (constraints.getValignment() != null) {
                return constraints.getValignment();
            }
        }
        return VPos.CENTER;
    }

    private HPos getColumnHalignment(int columnIndex) {
        if (columnIndex &lt; getColumnConstraints().size()) {
            ColumnConstraints constraints = getColumnConstraints().get(columnIndex);
            if (constraints.getHalignment() != null) {
                return constraints.getHalignment();
            }
        }
        return HPos.LEFT;
    }

    private double getColumnMinWidth(int columnIndex) {
        if (columnIndex &lt; getColumnConstraints().size()) {
            ColumnConstraints constraints = getColumnConstraints().get(columnIndex);
            return constraints.getMinWidth();

        }
        return USE_COMPUTED_SIZE;
    }

    private double getRowMinHeight(int rowIndex) {
        if (rowIndex &lt; getRowConstraints().size()) {
            RowConstraints constraints = getRowConstraints().get(rowIndex);
            return constraints.getMinHeight();
        }
        return USE_COMPUTED_SIZE;
    }

    private double getColumnMaxWidth(int columnIndex) {
        if (columnIndex &lt; getColumnConstraints().size()) {
            ColumnConstraints constraints = getColumnConstraints().get(columnIndex);
            return constraints.getMaxWidth();

        }
        return USE_COMPUTED_SIZE;
    }

    private double getColumnPrefWidth(int columnIndex) {
        if (columnIndex &lt; getColumnConstraints().size()) {
            ColumnConstraints constraints = getColumnConstraints().get(columnIndex);
            return constraints.getPrefWidth();

        }
        return USE_COMPUTED_SIZE;
    }

    private double getRowPrefHeight(int rowIndex) {
        if (rowIndex &lt; getRowConstraints().size()) {
            RowConstraints constraints = getRowConstraints().get(rowIndex);
            return constraints.getPrefHeight();

        }
        return USE_COMPUTED_SIZE;
    }

    private double getRowMaxHeight(int rowIndex) {
        if (rowIndex &lt; getRowConstraints().size()) {
            RowConstraints constraints = getRowConstraints().get(rowIndex);
            return constraints.getMaxHeight();
        }
        return USE_COMPUTED_SIZE;
    }

    private boolean shouldRowFillHeight(int rowIndex) {
        if (rowIndex &lt; getRowConstraints().size()) {
            return getRowConstraints().get(rowIndex).isFillHeight();
        }
        return true;
    }

    private boolean shouldColumnFillWidth(int columnIndex) {
        if (columnIndex &lt; getColumnConstraints().size()) {
            return getColumnConstraints().get(columnIndex).isFillWidth();
        }
        return true;
    }

    private double getTotalWidthOfNodeColumns(Node child, double[] widths) {
        if (getNodeColumnSpan(child) == 1) {
            return widths[getNodeColumnIndex(child)];
        } else {
            double total = 0;
            for (int i = getNodeColumnIndex(child), last = getNodeColumnEndConvertRemaining(child); i &lt;= last; ++i) {
                total += widths[i];
            }
            return total;
        }
    }

    private CompositeSize computeMaxHeights() {
        if (rowMaxHeight == null) {
            rowMaxHeight = createCompositeRows(Double.MAX_VALUE); // Do not restrict the row (to allow grow). The
                                                                  // Nodes will be restricted to their computed size
                                                                  // in Region.layoutInArea call
            final ObservableList&lt;RowConstraints&gt; rowConstr = getRowConstraints();
            CompositeSize prefHeights = null;
            for (int i = 0; i &lt; rowConstr.size(); ++i) {
                final RowConstraints curConstraint = rowConstr.get(i);
                final double constrMaxH = curConstraint.getMaxHeight();
                if (constrMaxH == USE_PREF_SIZE) {
                    if (prefHeights == null) {
                        prefHeights = computePrefHeights(null);
                    }
                    rowMaxHeight.setPresetSize(i, prefHeights.getSize(i));
                } else if (constrMaxH != USE_COMPUTED_SIZE) {
                    final double maxRowHeight = snapSizeY(constrMaxH);
                    final double constrMinH = curConstraint.getMinHeight();
                    if (constrMinH &gt;= 0 ) {
                        final double min = snapSizeY(curConstraint.getMinHeight());
                        rowMaxHeight.setPresetSize(i, boundedSize(min, maxRowHeight, maxRowHeight));
                    } else {
                        rowMaxHeight.setPresetSize(i, maxRowHeight);
                    }
                }
            }
        }
        return rowMaxHeight;
    }

    private CompositeSize computePrefHeights(double[] widths) {
        CompositeSize result;
        if (widths == null) {
            if (rowPrefHeight != null) {
                return rowPrefHeight;
            }
            rowPrefHeight = createCompositeRows(0);
            result = rowPrefHeight;
        } else {
            result = createCompositeRows(0);
        }

        final ObservableList&lt;RowConstraints&gt; rowConstr = getRowConstraints();
        for (int i = 0; i &lt; rowConstr.size(); ++i) {
            final RowConstraints curConstraint = rowConstr.get(i);
            final double constrMinH = curConstraint.getMinHeight();
            final double constrPrefH = curConstraint.getPrefHeight();
            if (constrPrefH != USE_COMPUTED_SIZE) {
                final double prefRowHeight = snapSizeY(constrPrefH);
                final double constrMaxH = curConstraint.getMaxHeight();
                if (constrMinH &gt;= 0 || constrMaxH &gt;= 0) {
                    final double min = (constrMinH &lt; 0 ? 0 : snapSizeY(constrMinH));
                    final double max = (constrMaxH &lt; 0 ? Double.POSITIVE_INFINITY : snapSizeY(constrMaxH));
                    result.setPresetSize(i, boundedSize(min, prefRowHeight, max));
                } else {
                    result.setPresetSize(i, prefRowHeight);
                }
            } else if (constrMinH &gt; 0){
                result.setSize(i, snapSizeY(constrMinH));
            }
        }
        List&lt;Node&gt; managed = getManagedChildren();
        for (int i = 0, size = managed.size(); i &lt; size; i++) {
            Node child = managed.get(i);
            int start = getNodeRowIndex(child);
            int end = getNodeRowEndConvertRemaining(child);
            double childPrefAreaHeight = computeChildPrefAreaHeight(child, isNodePositionedByBaseline(child) ? rowPrefBaselineComplement[start] : -1, getMargin(child),
                    widths == null ? -1 : getTotalWidthOfNodeColumns(child, widths));
            if (start == end &amp;&amp; !result.isPreset(start)) {
                double min = getRowMinHeight(start);
                double max = getRowMaxHeight(start);
                result.setMaxSize(start, boundedSize(min &lt; 0 ? 0 : min, childPrefAreaHeight, max &lt; 0 ? Double.MAX_VALUE : max));
            } else if (start != end){
                result.setMaxMultiSize(start, end + 1, childPrefAreaHeight);
            }
        }
        return result;
    }

    private CompositeSize computeMinHeights(double[] widths) {
        CompositeSize result;
        if (widths == null) {
            if (rowMinHeight != null) {
                return rowMinHeight;
            }
            rowMinHeight = createCompositeRows(0);
            result = rowMinHeight;
        } else {
            result = createCompositeRows(0);
        }

        final ObservableList&lt;RowConstraints&gt; rowConstr = getRowConstraints();
        CompositeSize prefHeights = null;
        for (int i = 0; i &lt; rowConstr.size(); ++i) {
            final double constrMinH = rowConstr.get(i).getMinHeight();
            if (constrMinH == USE_PREF_SIZE) {
                if (prefHeights == null) {
                    prefHeights = computePrefHeights(widths);
                }
                result.setPresetSize(i, prefHeights.getSize(i));
            } else if (constrMinH != USE_COMPUTED_SIZE) {
                result.setPresetSize(i, snapSizeY(constrMinH));
            }
        }
        List&lt;Node&gt; managed = getManagedChildren();
        for (int i = 0, size = managed.size(); i &lt; size; i++) {
            Node child = managed.get(i);
            int start = getNodeRowIndex(child);
            int end = getNodeRowEndConvertRemaining(child);
            double childMinAreaHeight = computeChildMinAreaHeight(child, isNodePositionedByBaseline(child) ? rowMinBaselineComplement[start] : -1, getMargin(child),
                             widths == null ? -1 : getTotalWidthOfNodeColumns(child, widths));
            if (start == end &amp;&amp; !result.isPreset(start)) {
                result.setMaxSize(start, childMinAreaHeight);
            } else if (start != end){
                result.setMaxMultiSize(start, end + 1, childMinAreaHeight);
            }
        }
        return result;
    }

    private double getTotalHeightOfNodeRows(Node child, double[] heights) {
        if (getNodeRowSpan(child) == 1) {
            return heights[getNodeRowIndex(child)];
        } else {
            double total = 0;
            for (int i = getNodeRowIndex(child), last = getNodeRowEndConvertRemaining(child); i &lt;= last; ++i) {
                total += heights[i];
            }
            return total;
        }
    }

    private CompositeSize computeMaxWidths() {
        if (columnMaxWidth == null) {
            columnMaxWidth = createCompositeColumns(Double.MAX_VALUE);// Do not restrict the column (to allow grow). The
                                                                      // Nodes will be restricted to their computed size
                                                                      // in Region.layoutInArea call
            final ObservableList&lt;ColumnConstraints&gt; columnConstr = getColumnConstraints();
            CompositeSize prefWidths = null;
            for (int i = 0; i &lt; columnConstr.size(); ++i) {
                final ColumnConstraints curConstraint = columnConstr.get(i);
                final double constrMaxW = curConstraint.getMaxWidth();
                if (constrMaxW == USE_PREF_SIZE) {
                    if (prefWidths == null) {
                        prefWidths = computePrefWidths(null);
                    }
                    columnMaxWidth.setPresetSize(i, prefWidths.getSize(i));
                } else if (constrMaxW != USE_COMPUTED_SIZE) {
                    double maxColumnWidth = snapSizeX(constrMaxW);
                    final double constrMinW = curConstraint.getMinWidth();
                    if (constrMinW &gt;= 0) {
                        final double min = snapSizeX(constrMinW);
                        columnMaxWidth.setPresetSize(i, boundedSize(min, maxColumnWidth, maxColumnWidth));
                    } else {
                        columnMaxWidth.setPresetSize(i, maxColumnWidth);
                    }
                }
            }
        }
        return columnMaxWidth;
    }

    private CompositeSize computePrefWidths(double[] heights) {
        CompositeSize result;
        if (heights == null) {
            if (columnPrefWidth != null) {
                return columnPrefWidth;
            }
            columnPrefWidth = createCompositeColumns(0);
            result = columnPrefWidth;
        } else {
            result = createCompositeColumns(0);
        }

        final ObservableList&lt;ColumnConstraints&gt; columnConstr = getColumnConstraints();
        for (int i = 0; i &lt; columnConstr.size(); ++i) {
            final ColumnConstraints curConstraint = columnConstr.get(i);
            final double constrPrefW = curConstraint.getPrefWidth();
            final double constrMinW = curConstraint.getMinWidth();
            if (constrPrefW != USE_COMPUTED_SIZE) {
                final double prefColumnWidth = snapSizeX(constrPrefW);
                final double constrMaxW = curConstraint.getMaxWidth();
                if (constrMinW &gt;= 0 || constrMaxW &gt;= 0) {
                    double min = (constrMinW &lt; 0 ? 0 : snapSizeX(constrMinW));
                    final double max = (constrMaxW &lt; 0 ? Double.POSITIVE_INFINITY : snapSizeX(constrMaxW));
                    result.setPresetSize(i, boundedSize(min &lt; 0 ? 0 : min,
                            prefColumnWidth,
                            max &lt; 0 ? Double.POSITIVE_INFINITY : max));
                } else {
                    result.setPresetSize(i, prefColumnWidth);
                }
            } else if (constrMinW &gt; 0){
                result.setSize(i, snapSizeX(constrMinW));
            }
        }
        List&lt;Node&gt; managed = getManagedChildren();
        for (int i = 0, size = managed.size(); i &lt; size; i++) {
            Node child = managed.get(i);
            int start = getNodeColumnIndex(child);
            int end = getNodeColumnEndConvertRemaining(child);
            if (start == end &amp;&amp; !result.isPreset(start)) {
                double min = getColumnMinWidth(start);
                double max = getColumnMaxWidth(start);
                result.setMaxSize(start, boundedSize(min &lt; 0 ? 0 : min, computeChildPrefAreaWidth(child,
                        getBaselineComplementForChild(child), getMargin(child),
                        heights == null ? -1 : getTotalHeightOfNodeRows(child, heights), false),
                        max &lt; 0 ? Double.MAX_VALUE : max));
            } else if (start != end) {
                result.setMaxMultiSize(start, end + 1, computeChildPrefAreaWidth(child, getBaselineComplementForChild(child),
                        getMargin(child),
                        heights == null ? -1 : getTotalHeightOfNodeRows(child, heights), false));
            }
        }
        return result;
    }

    private CompositeSize computeMinWidths(double[] heights) {
        CompositeSize result;
        if (heights == null) {
            if (columnMinWidth != null) {
                return columnMinWidth;
            }
            columnMinWidth = createCompositeColumns(0);
            result = columnMinWidth;
        } else {
            result = createCompositeColumns(0);
        }

        final ObservableList&lt;ColumnConstraints&gt; columnConstr = getColumnConstraints();
        CompositeSize prefWidths = null;
        for (int i = 0; i &lt; columnConstr.size(); ++i) {
            final double constrMinW = columnConstr.get(i).getMinWidth();
            if (constrMinW == USE_PREF_SIZE) {
                if (prefWidths == null) {
                    prefWidths = computePrefWidths(heights);
                }
                result.setPresetSize(i, prefWidths.getSize(i));
            } else if (constrMinW != USE_COMPUTED_SIZE) {
                result.setPresetSize(i, snapSizeX(constrMinW));
            }
        }
        List&lt;Node&gt; managed = getManagedChildren();
        for (int i = 0, size = managed.size(); i &lt; size; i++) {
            Node child = managed.get(i);
            int start = getNodeColumnIndex(child);
            int end = getNodeColumnEndConvertRemaining(child);
            if (start == end &amp;&amp; !result.isPreset(start)) {
                result.setMaxSize(start, computeChildMinAreaWidth(child, getBaselineComplementForChild(child),
                        getMargin(child),
                        heights == null ? -1 : getTotalHeightOfNodeRows(child, heights),false));
            } else if (start != end){
                result.setMaxMultiSize(start, end + 1, computeChildMinAreaWidth(child, getBaselineComplementForChild(child),
                        getMargin(child),
                        heights == null ? -1 : getTotalHeightOfNodeRows(child, heights), false));
            }
        }
        return result;
    }

    private CompositeSize computeHeightsToFit(double height) {
        assert(height != -1);
        final CompositeSize heights;
        if (rowPercentTotal == 100) {
            // all rows defined by percentage, no need to compute pref heights
            heights = createCompositeRows(0);
        } else {
            heights = (CompositeSize) computePrefHeights(null).clone();
        }
        adjustRowHeights(heights, height);
        return heights;
    }

    private CompositeSize computeWidthsToFit(double width) {
        assert(width != -1);
        final CompositeSize widths;
        if (columnPercentTotal == 100) {
            // all columns defined by percentage, no need to compute pref widths
            widths = createCompositeColumns(0);
        } else {
            widths = (CompositeSize) computePrefWidths(null).clone();
        }
        adjustColumnWidths(widths, width);
        return widths;
    }

    /**
     *
     * @return null unless one of its children has a content bias.
     */
    @Override public Orientation getContentBias() {
        computeGridMetrics();
        return bias;
    }

    @Override public void requestLayout() {
        // RT-18878: Do not update metrics dirty if we are performing layout.
        // If metricsDirty is set true during a layout pass the next call to computeGridMetrics()
        // will clear all the cell bounds resulting in out of date info until the
        // next layout pass.
        if (performingLayout) {
            return;
        } else if (metricsDirty) {
            super.requestLayout();
            return;
        }
        metricsDirty = true;
        bias = null;
        rowGrow = null;
        rowMinHeight = rowPrefHeight = rowMaxHeight = null;
        columnGrow = null;
        columnMinWidth = columnPrefWidth = columnMaxWidth = null;
        rowMinBaselineComplement = rowPrefBaselineComplement = rowMaxBaselineComplement = null;
        super.requestLayout();
    }

    @Override protected void layoutChildren() {
        performingLayout = true;
        try {
            final double snaphgap = snapSpaceX(getHgap());
            final double snapvgap = snapSpaceY(getVgap());
            final double top = snapSpaceY(getInsets().getTop());
            final double bottom = snapSpaceY(getInsets().getBottom());
            final double left = snapSpaceX(getInsets().getLeft());
            final double right = snapSpaceX(getInsets().getRight());

            final double width = getWidth();
            final double height = getHeight();
            final double contentHeight = height - top - bottom;
            final double contentWidth = width - left - right;
            double columnTotal;
            double rowTotal;
            computeGridMetrics();

            Orientation contentBias = getContentBias();
            CompositeSize heights;
            final CompositeSize widths;
            if (contentBias == null) {
                heights = (CompositeSize) computePrefHeights(null).clone();
                widths = (CompositeSize) computePrefWidths(null).clone();
                rowTotal = adjustRowHeights(heights, height);
                columnTotal = adjustColumnWidths(widths, width);
            } else if (contentBias == Orientation.HORIZONTAL) {
                widths = (CompositeSize) computePrefWidths(null).clone();
                columnTotal = adjustColumnWidths(widths, width);
                heights = computePrefHeights(widths.asArray());
                rowTotal = adjustRowHeights(heights, height);
            } else {
                heights = (CompositeSize) computePrefHeights(null).clone();
                rowTotal = adjustRowHeights(heights, height);
                widths = computePrefWidths(heights.asArray());
                columnTotal = adjustColumnWidths(widths, width);
            }

            final double x = left + computeXOffset(contentWidth, columnTotal, getAlignmentInternal().getHpos());
            final double y = top + computeYOffset(contentHeight, rowTotal, getAlignmentInternal().getVpos());
            final List&lt;Node&gt; managed = getManagedChildren();

            double[] baselineOffsets = createDoubleArray(numRows, -1);

            for (int i = 0, size = managed.size(); i &lt; size; i++) {
                final Node child = managed.get(i);
                final int rowIndex = getNodeRowIndex(child);
                int columnIndex = getNodeColumnIndex(child);
                int colspan = getNodeColumnSpan(child);
                if (colspan == REMAINING) {
                    colspan = widths.getLength() - columnIndex;
                }
                int rowspan = getNodeRowSpan(child);
                if (rowspan == REMAINING) {
                    rowspan = heights.getLength() - rowIndex;
                }
                double areaX = x;
                for (int j = 0; j &lt; columnIndex; j++) {
                    areaX += widths.getSize(j) + snaphgap;
                }
                double areaY = y;
                for (int j = 0; j &lt; rowIndex; j++) {
                    areaY += heights.getSize(j) + snapvgap;
                }
                double areaW = widths.getSize(columnIndex);
                for (int j = 2; j &lt;= colspan; j++) {
                    areaW += widths.getSize(columnIndex + j - 1) + snaphgap;
                }
                double areaH = heights.getSize(rowIndex);
                for (int j = 2; j &lt;= rowspan; j++) {
                    areaH += heights.getSize(rowIndex + j - 1) + snapvgap;
                }

                HPos halign = getHalignment(child);
                VPos valign = getValignment(child);
                Boolean fillWidth = isFillWidth(child);
                Boolean fillHeight = isFillHeight(child);

                if (halign == null) {
                    halign = getColumnHalignment(columnIndex);
                }
                if (valign == null) {
                    valign = getRowValignment(rowIndex);
                }
                if (fillWidth == null) {
                    fillWidth = shouldColumnFillWidth(columnIndex);
                }
                if (fillHeight == null) {
                    fillHeight = shouldRowFillHeight(rowIndex);
                }

                double baselineOffset = 0;
                if (valign == VPos.BASELINE) {
                    if (baselineOffsets[rowIndex] == -1) {
                        baselineOffsets[rowIndex] = getAreaBaselineOffset(rowBaseline[rowIndex],
                                marginAccessor,
                                t -&gt; {
                                    Node n = rowBaseline[rowIndex].get(t);
                                    int c = getNodeColumnIndex(n);
                                    int cs = getNodeColumnSpan(n);
                                    if (cs == REMAINING) {
                                        cs = widths.getLength() - c;
                                    }
                                    double w = widths.getSize(c);
                                    for (int j = 2; j &lt;= cs; j++) {
                                        w += widths.getSize(c + j - 1) + snaphgap;
                                    }
                                    return w;
                                },
                                areaH,
                                t -&gt; {
                                    Boolean b = isFillHeight(child);
                                    if (b != null) {
                                        return b;
                                    }
                                    return shouldRowFillHeight(getNodeRowIndex(child));
                                }, rowMinBaselineComplement[rowIndex]
                        );
                    }
                    baselineOffset = baselineOffsets[rowIndex];
                }

                Insets margin = getMargin(child);
                layoutInArea(child, areaX, areaY, areaW, areaH,
                        baselineOffset,
                        margin,
                        fillWidth, fillHeight,
                        halign, valign);
            }
            layoutGridLines(widths, heights, x, y, rowTotal, columnTotal);
            currentHeights = heights;
            currentWidths = widths;
        } finally {
            performingLayout = false;
        }
    }

    private double adjustRowHeights(final CompositeSize heights, double height) {
        assert(height != -1);
        final double snapvgap = snapSpaceY(getVgap());
        final double top = snapSpaceY(getInsets().getTop());
        final double bottom = snapSpaceY(getInsets().getBottom());
        final double vgaps = snapvgap * (getNumberOfRows() - 1);
        final double contentHeight = height - top - bottom;

        // if there are percentage rows, give them their percentages first
        if (rowPercentTotal &gt; 0) {
            double remainder = 0;
            for (int i = 0; i &lt; rowPercentHeight.length; i++) {
                if (rowPercentHeight[i] &gt;= 0) {
                    double size = (contentHeight - vgaps) * (rowPercentHeight[i]/100);
                    double floor = Math.floor(size);
                    remainder += size - floor;

                    // snap size to integer boundary based on the computed remainder as we loop through the rows.
                    size = floor;
                    if (remainder &gt;= 0.5) {
                        size++;
                        remainder = (-1.0) + remainder;
                    }
                    heights.setSize(i, size);
                }
            }
        }
        double rowTotal = heights.computeTotal();
        if (rowPercentTotal &lt; 100) {
            double heightAvailable = height - top - bottom - rowTotal;
            // now that both fixed and percentage rows have been computed, divy up any surplus or deficit
            if (heightAvailable != 0) {
                // maybe grow or shrink row heights
                double remaining = growToMultiSpanPreferredHeights(heights, heightAvailable);
                remaining = growOrShrinkRowHeights(heights, Priority.ALWAYS, remaining);
                remaining = growOrShrinkRowHeights(heights, Priority.SOMETIMES, remaining);
                rowTotal += (heightAvailable - remaining);
            }
        }

        return rowTotal;
    }

    private double growToMultiSpanPreferredHeights(CompositeSize heights, double extraHeight) {
        if (extraHeight &lt;= 0) {
            return extraHeight;
        }

        Set&lt;Integer&gt; rowsAlways = new TreeSet&lt;&gt;();
        Set&lt;Integer&gt; rowsSometimes = new TreeSet&lt;&gt;();
        Set&lt;Integer&gt; lastRows = new TreeSet&lt;&gt;();
        for (Entry&lt;Interval, Double&gt; ms : heights.multiSizes()) {
            final Interval interval = ms.getKey();
            for (int i = interval.begin; i &lt; interval.end; ++i) {
                if (rowPercentHeight[i] &lt; 0) {
                    switch (rowGrow[i]) {
                        case ALWAYS:
                            rowsAlways.add(i);
                            break;
                        case SOMETIMES:
                            rowsSometimes.add(i);
                            break;
                    }
                }
            }
            if (rowPercentHeight[interval.end - 1] &lt; 0) {
                lastRows.add(interval.end - 1);
            }
        }

        double remaining = extraHeight;

        while (rowsAlways.size() &gt; 0 &amp;&amp; remaining &gt; rowsAlways.size()) {
            double rowPortion = Math.floor(remaining / rowsAlways.size());
            for (Iterator&lt;Integer&gt; it = rowsAlways.iterator(); it.hasNext();) {
                int i = it.next();
                double maxOfRow = getRowMaxHeight(i);
                double prefOfRow = getRowPrefHeight(i);
                double actualPortion = rowPortion;

                for (Entry&lt;Interval, Double&gt; ms : heights.multiSizes()) {
                    final Interval interval = ms.getKey();
                    if (interval.contains(i)) {
                        int intervalRows = 0;
                        for (int j = interval.begin; j &lt; interval.end; ++j) {
                            if (rowsAlways.contains(j)) {
                                intervalRows++;
                            }
                        }
                        double curLength = heights.computeTotal(interval.begin, interval.end);
                        actualPortion = Math.min(Math.floor(Math.max(0, (ms.getValue() - curLength) / intervalRows)),
                                actualPortion);
                    }
                }

                final double current = heights.getSize(i);
                double bounded = maxOfRow &gt;= 0 ? boundedSize(0, current + actualPortion, maxOfRow) :
                        maxOfRow == USE_PREF_SIZE &amp;&amp; prefOfRow &gt; 0 ? boundedSize(0, current + actualPortion, prefOfRow) :
                        current + actualPortion;
                final double portionUsed = bounded - current;
                remaining -= portionUsed;
                if (portionUsed != actualPortion || portionUsed == 0) {
                    it.remove();
                }
                heights.setSize(i, bounded);
            }
        }

        while (rowsSometimes.size() &gt; 0 &amp;&amp; remaining &gt; rowsSometimes.size()) {
            double colPortion = Math.floor(remaining / rowsSometimes.size());
            for (Iterator&lt;Integer&gt; it = rowsSometimes.iterator(); it.hasNext();) {
                int i = it.next();
                double maxOfRow = getRowMaxHeight(i);
                double prefOfRow = getRowPrefHeight(i);
                double actualPortion = colPortion;

                for (Entry&lt;Interval, Double&gt; ms : heights.multiSizes()) {
                    final Interval interval = ms.getKey();
                    if (interval.contains(i)) {
                        int intervalRows = 0;
                        for (int j = interval.begin; j &lt; interval.end; ++j) {
                            if (rowsSometimes.contains(j)) {
                                intervalRows++;
                            }
                        }
                        double curLength = heights.computeTotal(interval.begin, interval.end);
                        actualPortion = Math.min(Math.floor(Math.max(0, (ms.getValue() - curLength) / intervalRows)),
                                actualPortion);
                    }
                }

                final double current = heights.getSize(i);
                double bounded = maxOfRow &gt;= 0 ? boundedSize(0, current + actualPortion, maxOfRow) :
                        maxOfRow == USE_PREF_SIZE &amp;&amp; prefOfRow &gt; 0 ? boundedSize(0, current + actualPortion, prefOfRow) :
                        current + actualPortion;
                final double portionUsed = bounded - current;
                remaining -= portionUsed;
                if (portionUsed != actualPortion || portionUsed == 0) {
                    it.remove();
                }
                heights.setSize(i, bounded);
            }
        }


        while (lastRows.size() &gt; 0 &amp;&amp; remaining &gt; lastRows.size()) {
            double colPortion = Math.floor(remaining / lastRows.size());
            for (Iterator&lt;Integer&gt; it = lastRows.iterator(); it.hasNext();) {
                int i = it.next();
                double maxOfRow = getRowMaxHeight(i);
                double prefOfRow = getRowPrefHeight(i);
                double actualPortion = colPortion;

                for (Entry&lt;Interval, Double&gt; ms : heights.multiSizes()) {
                    final Interval interval = ms.getKey();
                    if (interval.end - 1 == i) {
                        double curLength = heights.computeTotal(interval.begin, interval.end);
                        actualPortion = Math.min(Math.max(0, ms.getValue() - curLength),
                                actualPortion);
                    }
                }

                final double current = heights.getSize(i);
                double bounded = maxOfRow &gt;= 0 ? boundedSize(0, current + actualPortion, maxOfRow) :
                        maxOfRow == USE_PREF_SIZE &amp;&amp; prefOfRow &gt; 0 ? boundedSize(0, current + actualPortion, prefOfRow) :
                        current + actualPortion;
                final double portionUsed = bounded - current;
                remaining -= portionUsed;
                if (portionUsed != actualPortion || portionUsed == 0) {
                    it.remove();
                }
                heights.setSize(i, bounded);
            }
        }
        return remaining;
    }

    private double growOrShrinkRowHeights(CompositeSize heights, Priority priority, double extraHeight) {
        final boolean shrinking = extraHeight &lt; 0;
        List&lt;Integer&gt; adjusting = new ArrayList&lt;&gt;();

        for (int i = 0; i &lt; rowGrow.length; i++) {
            if (rowPercentHeight[i] &lt; 0 &amp;&amp; (shrinking || rowGrow[i] == priority)) {
                adjusting.add(i);
            }
        }

        double available = extraHeight; // will be negative in shrinking case
        boolean handleRemainder = false;
        double portion = 0;

        // RT-25684: We have to be careful that when subtracting change
        // that we don't jump right past 0 - this leads to an infinite
        // loop
        final boolean wasPositive = available &gt;= 0.0;
        boolean isPositive = wasPositive;

        CompositeSize limitSize = shrinking? computeMinHeights(null) :
                            computeMaxHeights();
        while (available != 0 &amp;&amp; wasPositive == isPositive &amp;&amp; adjusting.size() &gt; 0) {
            if (!handleRemainder) {
                portion = available &gt; 0 ? Math.floor(available / adjusting.size()) :
                        Math.ceil(available / adjusting.size()); // negative in shrinking case
            }
            if (portion != 0) {
                for (Iterator&lt;Integer&gt; i = adjusting.iterator(); i.hasNext();) {
                    final int index = i.next();
                    double limit = snapSpaceY(limitSize.getProportionalMinOrMaxSize(index, shrinking))
                            - heights.getSize(index); // negative in shrinking case
                    if (shrinking &amp;&amp; limit &gt; 0
                            || !shrinking &amp;&amp; limit &lt; 0) { // Limit completely if current size
                                                 // (originally based on preferred) already passed the computed limit
                        limit = 0;
                    }
                    final double change = Math.abs(limit) &lt;= Math.abs(portion)? limit : portion;
                    heights.addSize(index, change);
                    available -= change;
                    isPositive = available &gt;= 0.0;
                    if (Math.abs(change) &lt; Math.abs(portion)) {
                        i.remove();
                    }
                    if (available == 0) {
                        break;
                    }
                }
             } else {
                // Handle the remainder
                portion = (int)(available) % adjusting.size();
                if (portion == 0) {
                    break;
                } else {
                    // We have a remainder evenly distribute it.
                    portion = shrinking ? -1 : 1;
                    handleRemainder = true;
                }
            }
        }

        return available; // might be negative in shrinking case
    }

    private double adjustColumnWidths(final CompositeSize widths, double width) {
        assert(width != -1);
        final double snaphgap = snapSpaceX(getHgap());
        final double left = snapSpaceX(getInsets().getLeft());
        final double right = snapSpaceX(getInsets().getRight());
        final double hgaps = snaphgap * (getNumberOfColumns() - 1);
        final double contentWidth = width - left - right;

        // if there are percentage rows, give them their percentages first
        if (columnPercentTotal &gt; 0) {
            double remainder = 0;
            for (int i = 0; i &lt; columnPercentWidth.length; i++) {
                if (columnPercentWidth[i] &gt;= 0) {
                    double size = (contentWidth - hgaps) * (columnPercentWidth[i]/100);
                    double floor = Math.floor(size);
                    remainder += size - floor;

                    // snap size to integer boundary based on the computed remainder as we loop through the columns.
                    size = floor;
                    if (remainder &gt;= 0.5) {
                        size++;
                        remainder = (-1.0) + remainder;
                    }
                    widths.setSize(i, size);
                }
            }
        }

        double columnTotal = widths.computeTotal();
        if (columnPercentTotal &lt; 100) {
            double widthAvailable = width - left - right - columnTotal;
            // now that both fixed and percentage rows have been computed, divy up any surplus or deficit
            if (widthAvailable != 0) {
                // maybe grow or shrink row heights
                double remaining = growToMultiSpanPreferredWidths(widths, widthAvailable);
                remaining = growOrShrinkColumnWidths(widths, Priority.ALWAYS, remaining);
                remaining = growOrShrinkColumnWidths(widths, Priority.SOMETIMES, remaining);
                columnTotal += (widthAvailable - remaining);
            }
        }
        return columnTotal;
    }

    private double growToMultiSpanPreferredWidths(CompositeSize widths, double extraWidth) {
        if (extraWidth &lt;= 0) {
            return extraWidth;
        }

        Set&lt;Integer&gt; columnsAlways = new TreeSet&lt;&gt;();
        Set&lt;Integer&gt; columnsSometimes = new TreeSet&lt;&gt;();
        Set&lt;Integer&gt; lastColumns = new TreeSet&lt;&gt;();
        for (Entry&lt;Interval, Double&gt; ms : widths.multiSizes()) {
            final Interval interval = ms.getKey();
            for (int i = interval.begin; i &lt; interval.end; ++i) {
                if (columnPercentWidth[i] &lt; 0) {
                    switch (columnGrow[i]) {
                        case ALWAYS:
                            columnsAlways.add(i);
                            break;
                        case SOMETIMES:
                            columnsSometimes.add(i);
                            break;
                    }
                }
            }
            if (columnPercentWidth[interval.end - 1] &lt; 0) {
                lastColumns.add(interval.end - 1);
            }
        }

        double remaining = extraWidth;

        while (columnsAlways.size() &gt; 0 &amp;&amp; remaining &gt; columnsAlways.size()) {
            double colPortion = Math.floor(remaining / columnsAlways.size());
            for (Iterator&lt;Integer&gt; it = columnsAlways.iterator(); it.hasNext();) {
                int i = it.next();
                double maxOfColumn = getColumnMaxWidth(i);
                double prefOfColumn = getColumnPrefWidth(i);
                double actualPortion = colPortion;

                for (Entry&lt;Interval, Double&gt; ms : widths.multiSizes()) {
                    final Interval interval = ms.getKey();
                    if (interval.contains(i)) {
                        int intervalColumns = 0;
                        for (int j = interval.begin; j &lt; interval.end; ++j) {
                            if (columnsAlways.contains(j)) {
                                intervalColumns++;
                            }
                        }
                        double curLength = widths.computeTotal(interval.begin, interval.end);
                        actualPortion = Math.min(Math.floor(Math.max(0, (ms.getValue() - curLength) / intervalColumns)),
                                actualPortion);
                    }
                }

                final double current = widths.getSize(i);
                double bounded = maxOfColumn &gt;= 0 ? boundedSize(0, current + actualPortion, maxOfColumn) :
                        maxOfColumn == USE_PREF_SIZE &amp;&amp; prefOfColumn &gt; 0 ? boundedSize(0, current + actualPortion, prefOfColumn) :
                        current + actualPortion;
                final double portionUsed = bounded - current;
                remaining -= portionUsed;
                if (portionUsed != actualPortion || portionUsed == 0) {
                    it.remove();
                }
                widths.setSize(i, bounded);
            }
        }

        while (columnsSometimes.size() &gt; 0 &amp;&amp; remaining &gt; columnsSometimes.size()) {
            double colPortion = Math.floor(remaining / columnsSometimes.size());
            for (Iterator&lt;Integer&gt; it = columnsSometimes.iterator(); it.hasNext();) {
                int i = it.next();
                double maxOfColumn = getColumnMaxWidth(i);
                double prefOfColumn = getColumnPrefWidth(i);
                double actualPortion = colPortion;

                for (Entry&lt;Interval, Double&gt; ms : widths.multiSizes()) {
                    final Interval interval = ms.getKey();
                    if (interval.contains(i)) {
                        int intervalColumns = 0;
                        for (int j = interval.begin; j &lt; interval.end; ++j) {
                            if (columnsSometimes.contains(j)) {
                                intervalColumns++;
                            }
                        }
                        double curLength = widths.computeTotal(interval.begin, interval.end);
                        actualPortion = Math.min(Math.floor(Math.max(0, (ms.getValue() - curLength) / intervalColumns)),
                                actualPortion);
                    }
                }

                final double current = widths.getSize(i);
                double bounded = maxOfColumn &gt;= 0 ? boundedSize(0, current + actualPortion, maxOfColumn) :
                        maxOfColumn == USE_PREF_SIZE &amp;&amp; prefOfColumn &gt; 0 ? boundedSize(0, current + actualPortion, prefOfColumn) :
                        current + actualPortion;
                final double portionUsed = bounded - current;
                remaining -= portionUsed;
                if (portionUsed != actualPortion || portionUsed == 0) {
                    it.remove();
                }
                widths.setSize(i, bounded);
            }
        }


        while (lastColumns.size() &gt; 0 &amp;&amp; remaining &gt; lastColumns.size()) {
            double colPortion = Math.floor(remaining / lastColumns.size());
            for (Iterator&lt;Integer&gt; it = lastColumns.iterator(); it.hasNext();) {
                int i = it.next();
                double maxOfColumn = getColumnMaxWidth(i);
                double prefOfColumn = getColumnPrefWidth(i);
                double actualPortion = colPortion;

                for (Entry&lt;Interval, Double&gt; ms : widths.multiSizes()) {
                    final Interval interval = ms.getKey();
                    if (interval.end - 1 == i) {
                        double curLength = widths.computeTotal(interval.begin, interval.end);
                        actualPortion = Math.min(Math.max(0, ms.getValue() - curLength),
                                actualPortion);
                    }
                }

                final double current = widths.getSize(i);
                double bounded = maxOfColumn &gt;= 0 ? boundedSize(0, current + actualPortion, maxOfColumn) :
                        maxOfColumn == USE_PREF_SIZE &amp;&amp; prefOfColumn &gt; 0 ? boundedSize(0, current + actualPortion, prefOfColumn) :
                        current + actualPortion;
                final double portionUsed = bounded - current;
                remaining -= portionUsed;
                if (portionUsed != actualPortion || portionUsed == 0) {
                    it.remove();
                }
                widths.setSize(i, bounded);
            }
        }
        return remaining;
    }

    private double growOrShrinkColumnWidths(CompositeSize widths, Priority priority, double extraWidth) {
        if (extraWidth == 0) {
            return 0;
        }
        final boolean shrinking = extraWidth &lt; 0;
        List&lt;Integer&gt; adjusting = new ArrayList&lt;&gt;();

        for (int i = 0; i &lt; columnGrow.length; i++) {
            if (columnPercentWidth[i] &lt; 0 &amp;&amp; (shrinking || columnGrow[i] == priority)) {
                adjusting.add(i);
            }
        }

        double available = extraWidth; // will be negative in shrinking case
        boolean handleRemainder = false;
        double portion = 0;

        // RT-25684: We have to be careful that when subtracting change
        // that we don't jump right past 0 - this leads to an infinite
        // loop
        final boolean wasPositive = available &gt;= 0.0;
        boolean isPositive = wasPositive;

        CompositeSize limitSize = shrinking? computeMinWidths(null) :
                            computeMaxWidths();
        while (available != 0 &amp;&amp; wasPositive == isPositive &amp;&amp; adjusting.size() &gt; 0) {
            if (!handleRemainder) {
                portion = available &gt; 0 ? Math.floor(available / adjusting.size()) :
                        Math.ceil(available / adjusting.size()); // negative in shrinking case
            }
            if (portion != 0) {
                for (Iterator&lt;Integer&gt; i = adjusting.iterator(); i.hasNext();) {
                    final int index = i.next();
                    double limit = snapSpaceX(limitSize.getProportionalMinOrMaxSize(index, shrinking))
                            - widths.getSize(index); // negative in shrinking case
                    if (shrinking &amp;&amp; limit &gt; 0
                            || !shrinking &amp;&amp; limit &lt; 0) { // Limit completely if current size
                                                 // (originally based on preferred) already passed the computed limit
                        limit = 0;
                    }
                    final double change = Math.abs(limit) &lt;= Math.abs(portion)? limit : portion;
                    widths.addSize(index, change);
                    available -= change;
                    isPositive = available &gt;= 0.0;
                    if (Math.abs(change) &lt; Math.abs(portion)) {
                        i.remove();
                    }
                    if (available == 0) {
                        break;
                    }
                }
            } else {
                // Handle the remainder
                portion = (int)(available) % adjusting.size();
                if (portion == 0) {
                    break;
                } else {
                    // We have a remainder evenly distribute it.
                    portion = shrinking ? -1 : 1;
                    handleRemainder = true;
                }
            }
        }

        return available; // might be negative in shrinking case
    }

    private void layoutGridLines(CompositeSize columnWidths, CompositeSize rowHeights, double x, double y, double columnHeight, double rowWidth) {
        if (!isGridLinesVisible()) {
            return;
        }
        if (!gridLines.getChildren().isEmpty()) {
            gridLines.getChildren().clear();
        }
        double hGap = snapSpaceX(getHgap());
        double vGap = snapSpaceY(getVgap());

        // create vertical lines
        double linex = x;
        double liney = y;
        for (int i = 0; i &lt;= columnWidths.getLength(); i++) {
             gridLines.getChildren().add(createGridLine(linex, liney, linex, liney + columnHeight));
             if (i &gt; 0 &amp;&amp; i &lt; columnWidths.getLength() &amp;&amp; hGap != 0) {
                 linex += hGap;
                 gridLines.getChildren().add(createGridLine(linex, liney, linex, liney + columnHeight));
             }
             if (i &lt; columnWidths.getLength()) {
                 linex += columnWidths.getSize(i);
             }
        }
        // create horizontal lines
        linex = x;
        for (int i = 0; i &lt;= rowHeights.getLength(); i++) {
            gridLines.getChildren().add(createGridLine(linex, liney, linex + rowWidth, liney));
            if (i &gt; 0 &amp;&amp; i &lt; rowHeights.getLength() &amp;&amp; vGap != 0) {
                liney += vGap;
                gridLines.getChildren().add(createGridLine(linex, liney, linex + rowWidth, liney));
            }
            if (i &lt; rowHeights.getLength()) {
                liney += rowHeights.getSize(i);
            }
        }
    }

    private Line createGridLine(double startX, double startY, double endX, double endY) {
         Line line = new Line();
         line.setStartX(startX);
         line.setStartY(startY);
         line.setEndX(endX);
         line.setEndY(endY);
         line.setStroke(GRID_LINE_COLOR);
         line.setStrokeDashOffset(GRID_LINE_DASH);

         return line;
    }

    /**
     * Returns a string representation of this {@code GridPane} object.
     * @return a string representation of this {@code GridPane} object.
     */
    @Override public String toString() {
        return &quot;Grid hgap=&quot;+getHgap()+&quot;, vgap=&quot;+getVgap()+&quot;, alignment=&quot;+getAlignment();
    }

    private CompositeSize createCompositeRows(double initSize) {
        return new CompositeSize(getNumberOfRows(), rowPercentHeight, rowPercentTotal,
                snapSpaceY(getVgap()), initSize);
    }

    private CompositeSize createCompositeColumns(double initSize) {
        return new CompositeSize(getNumberOfColumns(), columnPercentWidth, columnPercentTotal,
                snapSpaceX(getHgap()), initSize);
    }

    private int getNodeRowEndConvertRemaining(Node child) {
        int rowSpan = getNodeRowSpan(child);
        return rowSpan != REMAINING? getNodeRowIndex(child) + rowSpan - 1 : getNumberOfRows() - 1;
    }

    private int getNodeColumnEndConvertRemaining(Node child) {
        int columnSpan = getNodeColumnSpan(child);
        return columnSpan != REMAINING? getNodeColumnIndex(child) + columnSpan - 1 : getNumberOfColumns() - 1;
    }


    // This methods are inteded to be used by GridPaneDesignInfo
    private CompositeSize currentHeights;
    private CompositeSize currentWidths;

    double[][] getGrid() {
        if (currentHeights == null || currentWidths == null) {
            return null;
        }
        return new double[][] {currentWidths.asArray(), currentHeights.asArray()};
    }

    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/

    /*
     * Super-lazy instantiation pattern from Bill Pugh.
     */
     private static class StyleableProperties {

         private static final CssMetaData&lt;GridPane,Boolean&gt; GRID_LINES_VISIBLE =
             new CssMetaData&lt;GridPane,Boolean&gt;(&quot;-fx-grid-lines-visible&quot;,
                 BooleanConverter.getInstance(), Boolean.FALSE) {

            @Override
            public boolean isSettable(GridPane node) {
                return node.gridLinesVisible == null ||
                        !node.gridLinesVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(GridPane node) {
                return (StyleableProperty&lt;Boolean&gt;)node.gridLinesVisibleProperty();
            }
         };

         private static final CssMetaData&lt;GridPane,Number&gt; HGAP =
             new CssMetaData&lt;GridPane,Number&gt;(&quot;-fx-hgap&quot;,
                 SizeConverter.getInstance(), 0.0){

            @Override
            public boolean isSettable(GridPane node) {
                return node.hgap == null || !node.hgap.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(GridPane node) {
                return (StyleableProperty&lt;Number&gt;)node.hgapProperty();
            }

         };

         private static final CssMetaData&lt;GridPane,Pos&gt; ALIGNMENT =
             new CssMetaData&lt;GridPane,Pos&gt;(&quot;-fx-alignment&quot;,
                 new EnumConverter&lt;Pos&gt;(Pos.class), Pos.TOP_LEFT) {

            @Override
            public boolean isSettable(GridPane node) {
                return node.alignment == null || !node.alignment.isBound();
            }

            @Override
            public StyleableProperty&lt;Pos&gt; getStyleableProperty(GridPane node) {
                return (StyleableProperty&lt;Pos&gt;)node.alignmentProperty();
            }

         };

         private static final CssMetaData&lt;GridPane,Number&gt; VGAP =
             new CssMetaData&lt;GridPane,Number&gt;(&quot;-fx-vgap&quot;,
                 SizeConverter.getInstance(), 0.0){

            @Override
            public boolean isSettable(GridPane node) {
                return node.vgap == null || !node.vgap.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(GridPane node) {
                return (StyleableProperty&lt;Number&gt;)node.vgapProperty();
            }

         };

         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
         static {

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                    new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());
            styleables.add(GRID_LINES_VISIBLE);
            styleables.add(HGAP);
            styleables.add(ALIGNMENT);
            styleables.add(VGAP);

            STYLEABLES = Collections.unmodifiableList(styleables);
         }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     *
     * @since JavaFX 8.0
     */


    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    private static final class Interval implements Comparable&lt;Interval&gt; {

        public final int begin;
        public final int end;

        public Interval(int begin, int end) {
            this.begin = begin;
            this.end = end;
        }

        @Override
        public int compareTo(Interval o) {
            return begin != o.begin ? begin - o.begin : end - o.end;
        }

        private boolean contains(int position) {
            return begin &lt;= position &amp;&amp; position &lt; end;
        }

        private int size() {
            return end - begin;
        }

    }

    private static final class CompositeSize implements Cloneable {

        // These variables will be modified during the computations
        double singleSizes[];
        private SortedMap&lt;Interval, Double&gt; multiSizes;
        private BitSet preset;

        // Preset metrics for this dimension
        private final double fixedPercent[];
        private final double totalFixedPercent;
        private final double gap;

        public CompositeSize(int capacity, double fixedPercent[], double totalFixedPercent, double gap, double initSize) {
            singleSizes = new double[capacity];
            Arrays.fill(singleSizes, initSize);

            this.fixedPercent = fixedPercent;
            this.totalFixedPercent = totalFixedPercent;
            this.gap = gap;
        }

        private void setSize(int position, double size) {
            singleSizes[position] = size;
        }

        private void setPresetSize(int position, double size) {
            setSize(position, size);
            if (preset == null) {
                preset = new BitSet(singleSizes.length);
            }
            preset.set(position);
        }

        private boolean isPreset(int position) {
            if (preset == null) {
                return false;
            }
            return preset.get(position);
        }

        private void addSize(int position, double change) {
            singleSizes[position] = singleSizes[position] + change;
        }

        private double getSize(int position) {
            return singleSizes[position];
        }

        private void setMaxSize(int position, double size) {
            singleSizes[position] = Math.max(singleSizes[position], size);
        }

        private void setMultiSize(int startPosition, int endPosition, double size) {
            if (multiSizes == null) {
                multiSizes = new TreeMap&lt;&gt;();
            }
            Interval i = new Interval(startPosition, endPosition);
            multiSizes.put(i, size);
        }

        private Iterable&lt;Entry&lt;Interval, Double&gt;&gt; multiSizes() {
            if (multiSizes == null) {
                return Collections.EMPTY_LIST;
            }
            return multiSizes.entrySet();
        }

        private void setMaxMultiSize(int startPosition, int endPosition, double size) {
            if (multiSizes == null) {
                multiSizes = new TreeMap&lt;&gt;();
            }
            Interval i = new Interval(startPosition, endPosition);
            Double sz = multiSizes.get(i);
            if (sz == null) {
                multiSizes.put(i, size);
            } else {
                multiSizes.put(i, Math.max(size, sz));
            }
        }

        private double getProportionalMinOrMaxSize(int position, boolean min) {
            double result = singleSizes[position];
            if (!isPreset(position) &amp;&amp; multiSizes != null) {
                for (Interval i : multiSizes.keySet()) {
                    if (i.contains(position)) {
                        double segment = multiSizes.get(i) / i.size();
                        double propSize = segment;
                        for (int j = i.begin; j &lt; i.end; ++j) {
                            if (j != position) {
                                if (min ? singleSizes[j] &gt; segment : singleSizes[j] &lt; segment) {
                                    propSize += segment - singleSizes[j];
                                }
                            }
                        }
                        result = min ? Math.max(result, propSize) : Math.min(result, propSize);
                    }
                }
            }
            return result;
        }

        private double computeTotal(final int from, final int to) {
            double total = gap * (to - from - 1);
            for (int i = from; i &lt; to; ++i) {
                total += singleSizes[i];
            }
            return total;
        }

        private double computeTotal() {
            return computeTotal(0, singleSizes.length);
        }

        private boolean allPreset(int begin, int end) {
            if (preset == null) {
                return false;
            }
            for (int i = begin; i &lt; end; ++i) {
                if (!preset.get(i)) {
                    return false;
                }
            }
            return true;
        }

        private double computeTotalWithMultiSize() {
            double total = computeTotal();
            if (multiSizes != null) {
                for (Entry&lt;Interval, Double&gt; e: multiSizes.entrySet()) {
                    final Interval i = e.getKey();
                    if (!allPreset(i.begin, i.end)) {
                        double subTotal = computeTotal(i.begin, i.end);
                        if (e.getValue() &gt; subTotal) {
                            total += e.getValue() - subTotal;
                        }
                    }
                }
            }
            if (totalFixedPercent &gt; 0) {
                double totalNotFixed = 0;
                // First, remove the sizes that are fixed to be 0
                for (int i = 0; i &lt; fixedPercent.length; ++i) {
                    if (fixedPercent[i] == 0) {
                        total -= singleSizes[i];
                    }
                }
                for (int i = 0; i &lt; fixedPercent.length; ++i) {
                    if (fixedPercent[i] &gt; 0) {
                        // Grow the total so that every size at it's value corresponds at least to it's fixedPercent of the total
                        // i.e. total * fixedPercent[i] &gt;= singleSizes[i]
                        total = Math.max(total, singleSizes[i] * (100 / fixedPercent[i]));
                    } else if (fixedPercent[i] &lt; 0){
                        totalNotFixed += singleSizes[i];
                    }
                }
                if (totalFixedPercent &lt; 100) {
                    total = Math.max(total, totalNotFixed * 100 / (100 - totalFixedPercent));
                }
            }
            return total;
        }

        private int getLength() {
            return singleSizes.length;
        }

        @Override
        protected Object clone() {
            try {
            CompositeSize clone = (CompositeSize) super.clone();
            clone.singleSizes = clone.singleSizes.clone();
            if (multiSizes != null)
                clone.multiSizes = new TreeMap&lt;&gt;(clone.multiSizes);
            return clone;
            } catch (CloneNotSupportedException ex) {
                throw new RuntimeException(ex);
            }
        }

        private double[] asArray() {
            return singleSizes;
        }

    }

    /**
     * Returns the number of rows in this GridPane.
     *
     * @return the row count
     * @since 9
     */
    public final int getRowCount() {
        int nRows = this.getRowConstraints().size();
        for (int i = 0; i &lt; this.getChildren().size(); i++) {
            Node child = this.getChildren().get(i);
            if (child.isManaged()) {
                int rowIndex = GridPane.getNodeRowIndex(child);
                int rowEnd = GridPane.getNodeRowEnd(child);
                nRows = Math.max(nRows, (rowEnd != GridPane.REMAINING? rowEnd : rowIndex) + 1);
            }
        }
        return nRows;
    }

    /**
     * Returns the number of columns in this GridPane.
     *
     * @return the column count
     * @since 9
     */
    public final int getColumnCount() {
        int nColumns = this.getColumnConstraints().size();
        for (int i = 0; i &lt; this.getChildren().size(); i++) {
            Node child = this.getChildren().get(i);
            if (child.isManaged()) {
                int columnIndex = GridPane.getNodeColumnIndex(child);
                int columnEnd = GridPane.getNodeColumnEnd(child);
                nColumns = Math.max(nColumns, (columnEnd != GridPane.REMAINING? columnEnd : columnIndex) + 1);
            }
        }
        return nColumns;
    }

    /**
     * Returns the bounds of the cell at the specified column and row position.
     *
     * @param columnIndex the column index position for the cell within this
     * GridPane, counting from 0
     * @param rowIndex the row index position for the cell within this GridPane,
     * counting from 0
     * @return the bounds of the cell at columnIndex and rowIndex.
     * @since 9
     */
    public final Bounds getCellBounds(int columnIndex, int rowIndex) {
        final double snaphgap = this.snapSpaceX(this.getHgap());
        final double snapvgap = this.snapSpaceY(this.getVgap());
        final double top = this.snapSpaceY(this.getInsets().getTop());
        final double right = this.snapSpaceX(this.getInsets().getRight());
        final double bottom = this.snapSpaceY(this.getInsets().getBottom());
        final double left = this.snapSpaceX(this.getInsets().getLeft());
        final double gridPaneHeight = this.snapSizeY(this.getHeight()) - (top + bottom);
        final double gridPaneWidth = this.snapSizeX(this.getWidth()) - (left + right);

        // Compute grid. ResultView contains two double arrays, first for columns, second for rows
        double[] columnWidths;
        double[] rowHeights;

        double[][] grid = this.getGrid();
        if (grid == null) {
            rowHeights = new double[] {0};
            rowIndex = 0;
            columnWidths = new double[] {0};
            columnIndex = 0;
        } else {
            columnWidths = grid[0];
            rowHeights = grid[1];
        }

        // Compute the total row height
        double rowTotal = 0;
        for (int i = 0; i &lt; rowHeights.length; i++) {
            rowTotal += rowHeights[i];
        }
        rowTotal += ((rowHeights.length - 1) * snapvgap);

        // Adjust for alignment
        double minY = top + Region.computeYOffset(gridPaneHeight, rowTotal, this.getAlignment().getVpos());
        double height = rowHeights[rowIndex];
        for (int j = 0; j &lt; rowIndex; j++) {
            minY += rowHeights[j] + snapvgap;
        }

        // Compute the total column width
        double columnTotal = 0;
        for (int i = 0; i &lt; columnWidths.length; i++) {
            columnTotal += columnWidths[i];
        }
        columnTotal += ((columnWidths.length - 1) * snaphgap);

        // Adjust for alignment
        double minX = left + Region.computeXOffset(gridPaneWidth, columnTotal, this.getAlignment().getHpos());
        double width = columnWidths[columnIndex];
        for (int j = 0; j &lt; columnIndex; j++) {
            minX += columnWidths[j] + snaphgap;
        }

        return new BoundingBox(minX, minY, width, height);
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/layout/Region.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.layout;

import javafx.beans.InvalidationListener;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyDoubleProperty;
import javafx.beans.property.ReadOnlyDoubleWrapper;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectPropertyBase;
import javafx.beans.value.ChangeListener;
import javafx.collections.ObservableList;
import javafx.css.CssMetaData;
import javafx.css.Styleable;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.geometry.BoundingBox;
import javafx.geometry.Bounds;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.geometry.Orientation;
import javafx.geometry.VPos;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.image.Image;
import javafx.scene.shape.Shape;
import javafx.scene.shape.StrokeLineCap;
import javafx.scene.shape.StrokeLineJoin;
import javafx.scene.shape.StrokeType;
import javafx.util.Callback;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Arrays;
import java.util.List;
import java.util.function.Function;
import com.sun.javafx.util.Logging;
import com.sun.javafx.util.TempState;
import com.sun.javafx.binding.ExpressionHelper;
import javafx.css.converter.BooleanConverter;
import javafx.css.converter.InsetsConverter;
import javafx.css.converter.ShapeConverter;
import javafx.css.converter.SizeConverter;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.Vec2d;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.ParentHelper;
import com.sun.javafx.scene.input.PickResultChooser;
import com.sun.javafx.scene.layout.RegionHelper;
import com.sun.javafx.scene.shape.ShapeHelper;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.sg.prism.NGRegion;
import com.sun.javafx.tk.Toolkit;
import javafx.scene.Scene;
import javafx.stage.Window;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;

/**
 * Region is the base class for all JavaFX Node-based UI Controls, and all layout containers.
 * It is a resizable Parent node which can be styled from CSS. It can have multiple backgrounds
 * and borders. It is designed to support as much of the CSS3 specification for backgrounds
 * and borders as is relevant to JavaFX.
 * The full specification is available at &lt;a href=&quot;http://www.w3.org/TR/2012/CR-css3-background-20120724/&quot;&gt;the W3C&lt;/a&gt;.
 * &lt;p&gt;
 * Every Region has its layout bounds, which are specified to be (0, 0, width, height). A Region might draw outside
 * these bounds. The content area of a Region is the area which is occupied for the layout of its children.
 * This area is, by default, the same as the layout bounds of the Region, but can be modified by either the
 * properties of a border (either with BorderStrokes or BorderImages), and by padding. The padding can
 * be negative, such that the content area of a Region might extend beyond the layout bounds of the Region,
 * but does not affect the layout bounds.
 * &lt;p&gt;
 * A Region has a Background, and a Border, although either or both of these might be empty. The Background
 * of a Region is made up of zero or more BackgroundFills, and zero or more BackgroundImages. Likewise, the
 * border of a Region is defined by its Border, which is made up of zero or more BorderStrokes and
 * zero or more BorderImages. All BackgroundFills are drawn first, followed by BackgroundImages, BorderStrokes,
 * and finally BorderImages. The content is drawn above all backgrounds and borders. If a BorderImage is
 * present (and loaded all images properly), then no BorderStrokes are actually drawn, although they are
 * considered for computing the position of the content area (see the stroke width property of a BorderStroke).
 * These semantics are in line with the CSS 3 specification. The purpose of these semantics are to allow an
 * application to specify a fallback BorderStroke to be displayed in the case that an ImageStroke fails to
 * download or load.
 * &lt;p&gt;
 * By default a Region appears as a Rectangle. A BackgroundFill radii might cause the Rectangle to appear rounded.
 * This affects not only making the visuals look like a rounded rectangle, but it also causes the picking behavior
 * of the Region to act like a rounded rectangle, such that locations outside the corner radii are ignored. A
 * Region can be made to use any shape, however, by specifying the {@code shape} property. If a shape is specified,
 * then all BackgroundFills, BackgroundImages, and BorderStrokes will be applied to the shape. BorderImages are
 * not used for Regions which have a shape specified.
 * &lt;p&gt;
 * Although the layout bounds of a Region are not influenced by any Border or Background, the content area
 * insets and the picking area of the Region are. The {@code insets} of the Region define the distance
 * between the edge of the layout bounds and the edge of the content area. For example, if the Region
 * layout bounds are (x=0, y=0, width=200, height=100), and the insets are (top=10, right=20, bottom=30, left=40),
 * then the content area bounds will be (x=40, y=10, width=140, height=60). A Region subclass which is laying
 * out its children should compute and honor these content area bounds.
 * &lt;p&gt;
 * By default a Region inherits the layout behavior of its superclass, {@link Parent},
 * which means that it will resize any resizable child nodes to their preferred
 * size, but will not reposition them.  If an application needs more specific
 * layout behavior, then it should use one of the Region subclasses:
 * {@link StackPane}, {@link HBox}, {@link VBox}, {@link TilePane}, {@link FlowPane},
 * {@link BorderPane}, {@link GridPane}, or {@link AnchorPane}.
 * &lt;p&gt;
 * To implement a more custom layout, a Region subclass must override
 * {@link #computePrefWidth(double) computePrefWidth}, {@link #computePrefHeight(double) computePrefHeight}, and
 * {@link #layoutChildren() layoutChildren}. Note that {@link #layoutChildren() layoutChildren} is called automatically
 * by the scene graph while executing a top-down layout pass and it should not be invoked directly by the
 * region subclass.
 * &lt;p&gt;
 * Region subclasses which layout their children will position nodes by setting
 * {@link #setLayoutX(double) layoutX}/{@link #setLayoutY(double) layoutY} and do not alter
 * {@link #setTranslateX(double) translateX}/{@link #setTranslateY(double) translateY}, which are reserved for
 * adjustments and animation.
 * @since JavaFX 2.0
 */
public class Region extends Parent {
    static {
        RegionHelper.setRegionAccessor(new RegionHelper.RegionAccessor() {
            @Override
            public NGNode doCreatePeer(Node node) {
                return ((Region) node).doCreatePeer();
            }

            @Override
            public void doUpdatePeer(Node node) {
                ((Region) node).doUpdatePeer();
            }

            @Override
            public Bounds doComputeLayoutBounds(Node node) {
                return ((Region) node).doComputeLayoutBounds();
            }

            @Override
            public BaseBounds doComputeGeomBounds(Node node,
                    BaseBounds bounds, BaseTransform tx) {
                return ((Region) node).doComputeGeomBounds(bounds, tx);
            }

            @Override
            public boolean doComputeContains(Node node, double localX, double localY) {
                return ((Region) node).doComputeContains(localX, localY);
            }

            @Override
            public void doNotifyLayoutBoundsChanged(Node node) {
                ((Region) node).doNotifyLayoutBoundsChanged();
            }

            @Override
            public void doPickNodeLocal(Node node, PickRay localPickRay,
                    PickResultChooser result) {
                ((Region) node).doPickNodeLocal(localPickRay, result);
            }
        });
    }

    /**
     * Sentinel value which can be passed to a region's
     * {@link #setMinWidth(double) setMinWidth},
     * {@link #setMinHeight(double) setMinHeight},
     * {@link #setMaxWidth(double) setMaxWidth} or
     * {@link #setMaxHeight(double) setMaxHeight}
     * methods to indicate that the preferred dimension should be used for that max and/or min constraint.
     */
    public static final double USE_PREF_SIZE = Double.NEGATIVE_INFINITY;

    /**
     * Sentinel value which can be passed to a region's
     * {@link #setMinWidth(double) setMinWidth},
     * {@link #setMinHeight(double) setMinHeight},
     * {@link #setPrefWidth(double) setPrefWidth},
     * {@link #setPrefHeight(double) setPrefHeight},
     * {@link #setMaxWidth(double) setMaxWidth},
     * {@link #setMaxHeight(double) setMaxHeight} methods
     * to reset the region's size constraint back to it's intrinsic size returned
     * by {@link #computeMinWidth(double) computeMinWidth}, {@link #computeMinHeight(double) computeMinHeight},
     * {@link #computePrefWidth(double) computePrefWidth}, {@link #computePrefHeight(double) computePrefHeight},
     * {@link #computeMaxWidth(double) computeMaxWidth}, or {@link #computeMaxHeight(double) computeMaxHeight}.
     */
    public static final double USE_COMPUTED_SIZE = -1;

    static Vec2d TEMP_VEC2D = new Vec2d();

    /***************************************************************************
     *                                                                         *
     * Static convenience methods for layout                                   *
     *                                                                         *
     **************************************************************************/

    /**
     * Computes the value based on the given min and max values. We encode in this
     * method the logic surrounding various edge cases, such as when the min is
     * specified as greater than the max, or the max less than the min, or a pref
     * value that exceeds either the max or min in their extremes.
     * &lt;p/&gt;
     * If the min is greater than the max, then we want to make sure the returned
     * value is the min. In other words, in such a case, the min becomes the only
     * acceptable return value.
     * &lt;p/&gt;
     * If the min and max values are well ordered, and the pref is less than the min
     * then the min is returned. Likewise, if the values are well ordered and the
     * pref is greater than the max, then the max is returned. If the pref lies
     * between the min and the max, then the pref is returned.
     *
     *
     * @param min The minimum bound
     * @param pref The value to be clamped between the min and max
     * @param max the maximum bound
     * @return the size bounded by min, pref, and max.
     */
    static double boundedSize(double min, double pref, double max) {
        double a = pref &gt;= min ? pref : min;
        double b = min &gt;= max ? min : max;
        return a &lt;= b ? a : b;
    }

    double adjustWidthByMargin(double width, Insets margin) {
        if (margin == null || margin == Insets.EMPTY) {
            return width;
        }
        boolean isSnapToPixel = isSnapToPixel();
        return width - snapSpaceX(margin.getLeft(), isSnapToPixel) - snapSpaceX(margin.getRight(), isSnapToPixel);
    }

    double adjustHeightByMargin(double height, Insets margin) {
        if (margin == null || margin == Insets.EMPTY) {
            return height;
        }
        boolean isSnapToPixel = isSnapToPixel();
        return height - snapSpaceY(margin.getTop(), isSnapToPixel) - snapSpaceY(margin.getBottom(), isSnapToPixel);
    }

    private static double getSnapScaleX(Node n) {
        return _getSnapScaleXimpl(n.getScene());
    }
    private static double _getSnapScaleXimpl(Scene scene) {
        if (scene == null) return 1.0;
        Window window = scene.getWindow();
        if (window == null) return 1.0;
        return window.getRenderScaleX();
    }

    private static double getSnapScaleY(Node n) {
        return _getSnapScaleYimpl(n.getScene());
    }
    private static double _getSnapScaleYimpl(Scene scene) {
        if (scene == null) return 1.0;
        Window window = scene.getWindow();
        if (window == null) return 1.0;
        return window.getRenderScaleY();
    }

    private double getSnapScaleX() {
        return _getSnapScaleXimpl(getScene());
    }

    private double getSnapScaleY() {
        return _getSnapScaleYimpl(getScene());
    }

    private static double scaledRound(double value, double scale) {
        return Math.round(value * scale) / scale;
    }

    private static double scaledFloor(double value, double scale) {
        return Math.floor(value * scale) / scale;
    }

    private static double scaledCeil(double value, double scale) {
        return Math.ceil(value * scale) / scale;
    }

    /**
     * If snapToPixel is true, then the value is rounded using Math.round. Otherwise,
     * the value is simply returned. This method will surely be JIT'd under normal
     * circumstances, however on an interpreter it would be better to inline this
     * method. However the use of Math.round here, and Math.ceil in snapSize is
     * not obvious, and so for code maintenance this logic is pulled out into
     * a separate method.
     *
     * @param value The value that needs to be snapped
     * @param snapToPixel Whether to snap to pixel
     * @return value either as passed in or rounded based on snapToPixel
     */
    private double snapSpaceX(double value, boolean snapToPixel) {
        return snapToPixel ? scaledRound(value, getSnapScaleX()) : value;
    }
    private double snapSpaceY(double value, boolean snapToPixel) {
        return snapToPixel ? scaledRound(value, getSnapScaleY()) : value;
    }

    private static double snapSpace(double value, boolean snapToPixel, double snapScale) {
        return snapToPixel ? scaledRound(value, snapScale) : value;
    }

    /**
     * If snapToPixel is true, then the value is ceil'd using Math.ceil. Otherwise,
     * the value is simply returned.
     *
     * @param value The value that needs to be snapped
     * @param snapToPixel Whether to snap to pixel
     * @return value either as passed in or ceil'd based on snapToPixel
     */
    private double snapSizeX(double value, boolean snapToPixel) {
        return snapToPixel ? scaledCeil(value, getSnapScaleX()) : value;
    }
    private double snapSizeY(double value, boolean snapToPixel) {
        return snapToPixel ? scaledCeil(value, getSnapScaleY()) : value;
    }

    private static double snapSize(double value, boolean snapToPixel, double snapScale) {
        return snapToPixel ? scaledCeil(value, snapScale) : value;
    }

    /**
     * If snapToPixel is true, then the value is rounded using Math.round. Otherwise,
     * the value is simply returned.
     *
     * @param value The value that needs to be snapped
     * @param snapToPixel Whether to snap to pixel
     * @return value either as passed in or rounded based on snapToPixel
     */
    private double snapPositionX(double value, boolean snapToPixel) {
        return snapToPixel ? scaledRound(value, getSnapScaleX()) : value;
    }
    private double snapPositionY(double value, boolean snapToPixel) {
        return snapToPixel ? scaledRound(value, getSnapScaleY()) : value;
    }

    private static double snapPosition(double value, boolean snapToPixel, double snapScale) {
        return snapToPixel ? scaledRound(value, snapScale) : value;
    }

    private double snapPortionX(double value, boolean snapToPixel) {
        if (!snapToPixel || value == 0) return value;
        double s = getSnapScaleX();
        value *= s;
        if (value &gt; 0) {
            value = Math.max(1, Math.floor(value));
        } else {
            value = Math.min(-1, Math.ceil(value));
        }
        return value / s;
    }
    private double snapPortionY(double value, boolean snapToPixel) {
        if (!snapToPixel || value == 0) return value;
        double s = getSnapScaleY();
        value *= s;
        if (value &gt; 0) {
            value = Math.max(1, Math.floor(value));
        } else {
            value = Math.min(-1, Math.ceil(value));
        }
        return value / s;
    }

    double getAreaBaselineOffset(List&lt;Node&gt; children, Callback&lt;Node, Insets&gt; margins,
                                        Function&lt;Integer, Double&gt; positionToWidth,
                                        double areaHeight, boolean fillHeight) {
        return getAreaBaselineOffset(children, margins, positionToWidth, areaHeight, fillHeight, isSnapToPixel());
    }

    static double getAreaBaselineOffset(List&lt;Node&gt; children, Callback&lt;Node, Insets&gt; margins,
            Function&lt;Integer, Double&gt; positionToWidth,
            double areaHeight, boolean fillHeight, boolean snapToPixel) {
        return getAreaBaselineOffset(children, margins, positionToWidth, areaHeight, fillHeight,
                getMinBaselineComplement(children), snapToPixel);
    }

    double getAreaBaselineOffset(List&lt;Node&gt; children, Callback&lt;Node, Insets&gt; margins,
                                 Function&lt;Integer, Double&gt; positionToWidth,
                                 double areaHeight, final boolean fillHeight, double minComplement) {
        return getAreaBaselineOffset(children, margins, positionToWidth, areaHeight, fillHeight, minComplement, isSnapToPixel());
    }

    static double getAreaBaselineOffset(List&lt;Node&gt; children, Callback&lt;Node, Insets&gt; margins,
            Function&lt;Integer, Double&gt; positionToWidth,
            double areaHeight, final boolean fillHeight, double minComplement, boolean snapToPixel) {
        return getAreaBaselineOffset(children, margins, positionToWidth, areaHeight, t -&gt; fillHeight, minComplement, snapToPixel);
    }

    double getAreaBaselineOffset(List&lt;Node&gt; children, Callback&lt;Node, Insets&gt; margins,
                                 Function&lt;Integer, Double&gt; positionToWidth,
                                 double areaHeight, Function&lt;Integer, Boolean&gt; fillHeight, double minComplement) {
        return getAreaBaselineOffset(children, margins, positionToWidth, areaHeight, fillHeight, minComplement, isSnapToPixel());
    }

    /**
     * Returns the baseline offset of provided children, with respect to the minimum complement, computed
     * by {@link #getMinBaselineComplement(java.util.List)} from the same set of children.
     * @param children the children with baseline alignment
     * @param margins their margins (callback)
     * @param positionToWidth callback for children widths (can return -1 if no bias is used)
     * @param areaHeight height of the area to layout in
     * @param fillHeight callback to specify children that has fillHeight constraint
     * @param minComplement minimum complement
     */
    static double getAreaBaselineOffset(List&lt;Node&gt; children, Callback&lt;Node, Insets&gt; margins,
            Function&lt;Integer, Double&gt; positionToWidth,
            double areaHeight, Function&lt;Integer, Boolean&gt; fillHeight, double minComplement, boolean snapToPixel) {
        double b = 0;
        double snapScaleV = 0.0;
        for (int i = 0;i &lt; children.size(); ++i) {
            Node n = children.get(i);
            // Note: all children should be coming from the same parent so they should all have the same snapScale
            if (snapToPixel &amp;&amp; i == 0) snapScaleV = getSnapScaleY(n.getParent());
            Insets margin = margins.call(n);
            double top = margin != null ? snapSpace(margin.getTop(), snapToPixel, snapScaleV) : 0;
            double bottom = (margin != null ? snapSpace(margin.getBottom(), snapToPixel, snapScaleV) : 0);
            final double bo = n.getBaselineOffset();
            if (bo == BASELINE_OFFSET_SAME_AS_HEIGHT) {
                double alt = -1;
                if (n.getContentBias() == Orientation.HORIZONTAL) {
                    alt = positionToWidth.apply(i);
                }
                if (fillHeight.apply(i)) {
                    // If the children fills it's height, than it's &quot;preferred&quot; height is the area without the complement and insets
                    b = Math.max(b, top + boundedSize(n.minHeight(alt), areaHeight - minComplement - top - bottom,
                            n.maxHeight(alt)));
                } else {
                    // Otherwise, we must use the area without complement and insets as a maximum for the Node
                    b = Math.max(b, top + boundedSize(n.minHeight(alt), n.prefHeight(alt),
                            Math.min(n.maxHeight(alt), areaHeight - minComplement - top - bottom)));
                }
            } else {
                b = Math.max(b, top + bo);
            }
        }
        return b;
    }

    /**
     * Return the minimum complement of baseline
     * @param children
     * @return
     */
    static double getMinBaselineComplement(List&lt;Node&gt; children) {
        return getBaselineComplement(children, true, false);
    }

    /**
     * Return the preferred complement of baseline
     * @param children
     * @return
     */
    static double getPrefBaselineComplement(List&lt;Node&gt; children) {
        return getBaselineComplement(children, false, false);
    }

    /**
     * Return the maximal complement of baseline
     * @param children
     * @return
     */
    static double getMaxBaselineComplement(List&lt;Node&gt; children) {
        return getBaselineComplement(children, false, true);
    }

    private static double getBaselineComplement(List&lt;Node&gt; children, boolean min, boolean max) {
        double bc = 0;
        for (Node n : children) {
            final double bo = n.getBaselineOffset();
            if (bo == BASELINE_OFFSET_SAME_AS_HEIGHT) {
                continue;
            }
            if (n.isResizable()) {
                bc = Math.max(bc, (min ? n.minHeight(-1) : max ? n.maxHeight(-1) : n.prefHeight(-1)) - bo);
            } else {
                bc = Math.max(bc, n.getLayoutBounds().getHeight() - bo);
            }
        }
        return bc;
    }


    static double computeXOffset(double width, double contentWidth, HPos hpos) {
        switch(hpos) {
            case LEFT:
                return 0;
            case CENTER:
                return (width - contentWidth) / 2;
            case RIGHT:
                return width - contentWidth;
            default:
                throw new AssertionError(&quot;Unhandled hPos&quot;);
        }
    }

    static double computeYOffset(double height, double contentHeight, VPos vpos) {
        switch(vpos) {
            case BASELINE:
            case TOP:
                return 0;
            case CENTER:
                return (height - contentHeight) / 2;
            case BOTTOM:
                return height - contentHeight;
            default:
                throw new AssertionError(&quot;Unhandled vPos&quot;);
        }
    }

    static double[] createDoubleArray(int length, double value) {
        double[] array = new double[length];
        for (int i = 0; i &lt; length; i++) {
            array[i] = value;
        }
        return array;
    }

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * At the time that a Background or Border is set on a Region, we inspect any
     * BackgroundImage or BorderImage objects, to see if the Image backing them
     * is background loading and not yet complete, or is animated. In such cases
     * we attach the imageChangeListener to them, so that when the image finishes,
     * the Region will be redrawn. If the particular image object is not animating
     * (but was just background loading), then we also remove the listener.
     * We also are sure to remove this listener from any old BackgroundImage or
     * BorderImage images in the background and border property invalidation code.
     */
    private InvalidationListener imageChangeListener = observable -&gt; {
        final ReadOnlyObjectPropertyBase imageProperty = (ReadOnlyObjectPropertyBase) observable;
        final Image image = (Image) imageProperty.getBean();
        final Toolkit.ImageAccessor acc = Toolkit.getImageAccessor();
        if (image.getProgress() == 1 &amp;&amp; !acc.isAnimation(image)) {
            // We can go ahead and remove the listener since loading is done.
            removeImageListener(image);
        }
        // Cause the region to repaint
        NodeHelper.markDirty(this, DirtyBits.NODE_CONTENTS);
    };

    {
        // To initialize the class helper at the beginning each constructor of this class
        RegionHelper.initHelper(this);
    }

    /**
     * Creates a new Region with an empty Background and and empty Border. The
     * Region defaults to having pickOnBounds set to true, meaning that any pick
     * (mouse picking or touch picking etc) that occurs within the bounds in local
     * of the Region will return true, regardless of whether the Region is filled
     * or transparent.
     */
    public Region() {
        super();
        setPickOnBounds(true);
    }

    /***************************************************************************
     *                                                                         *
     * Region properties                                                       *
     *                                                                         *
     **************************************************************************/

    /**
     * Defines whether this region adjusts position, spacing, and size values of
     * its children to pixel boundaries. This defaults to true, which is generally
     * the expected behavior in order to have crisp user interfaces. A value of
     * false will allow for fractional alignment, which may lead to &quot;fuzzy&quot;
     * looking borders.
     */
    private BooleanProperty snapToPixel;
    /**
     * I'm using a super-lazy property pattern here, so as to only create the
     * property object when needed for listeners or when being set from CSS,
     * but also making sure that we only call requestParentLayout in the case
     * that the snapToPixel value has actually changed, whether set via the setter
     * or set via the property object.
     */
    private boolean _snapToPixel = true;
    public final boolean isSnapToPixel() { return _snapToPixel; }
    public final void setSnapToPixel(boolean value) {
        if (snapToPixel == null) {
            if (_snapToPixel != value) {
                _snapToPixel = value;
                updateSnappedInsets();
                requestParentLayout();
            }
        } else {
            snapToPixel.set(value);
        }
    }
    public final BooleanProperty snapToPixelProperty() {
        // Note: snapToPixel is virtually never set, and never listened to.
        // Because of this, it works reasonably well as a lazy property,
        // since this logic is just about never going to be called.
        if (snapToPixel == null) {
            snapToPixel = new StyleableBooleanProperty(_snapToPixel) {
                @Override public Object getBean() { return Region.this; }
                @Override public String getName() { return &quot;snapToPixel&quot;; }
                @Override public CssMetaData&lt;Region, Boolean&gt; getCssMetaData() {
                    return StyleableProperties.SNAP_TO_PIXEL;
                }
                @Override public void invalidated() {
                    boolean value = get();
                    if (_snapToPixel != value) {
                        _snapToPixel = value;
                        updateSnappedInsets();
                        requestParentLayout();
                    }
                }
            };
        }
        return snapToPixel;
    }

    /**
     * The top, right, bottom, and left padding around the region's content.
     * This space will be included in the calculation of the region's
     * minimum and preferred sizes. By default padding is Insets.EMPTY. Setting the
     * value to null should be avoided.
     */
    private ObjectProperty&lt;Insets&gt; padding = new StyleableObjectProperty&lt;Insets&gt;(Insets.EMPTY) {
        // Keep track of the last valid value for the sake of
        // rollback in case padding is set to null. Note that
        // Richard really does not like this pattern because
        // it essentially means that binding the padding property
        // is not possible since a binding expression could very
        // easily produce an intermediate null value.

        // Also note that because padding is set virtually everywhere via CSS, and CSS
        // requires a property object in order to set it, there is no benefit to having
        // lazy initialization here.

        private Insets lastValidValue = Insets.EMPTY;

        @Override public Object getBean() { return Region.this; }
        @Override public String getName() { return &quot;padding&quot;; }
        @Override public CssMetaData&lt;Region, Insets&gt; getCssMetaData() {
            return StyleableProperties.PADDING;
        }
        @Override public void invalidated() {
            final Insets newValue = get();
            if (newValue == null) {
                // rollback
                if (isBound()) {
                    unbind();
                }
                set(lastValidValue);
                throw new NullPointerException(&quot;cannot set padding to null&quot;);
            } else if (!newValue.equals(lastValidValue)) {
                lastValidValue = newValue;
                insets.fireValueChanged();
            }
        }
    };
    public final void setPadding(Insets value) { padding.set(value); }
    public final Insets getPadding() { return padding.get(); }
    public final ObjectProperty&lt;Insets&gt; paddingProperty() { return padding; }

    /**
     * The background of the Region, which is made up of zero or more BackgroundFills, and
     * zero or more BackgroundImages. It is possible for a Background to be empty, where it
     * has neither fills nor images, and is semantically equivalent to null.
     * @since JavaFX 8.0
     */
    private final ObjectProperty&lt;Background&gt; background = new StyleableObjectProperty&lt;Background&gt;(null) {
        private Background old = null;
        @Override public Object getBean() { return Region.this; }
        @Override public String getName() { return &quot;background&quot;; }
        @Override public CssMetaData&lt;Region, Background&gt; getCssMetaData() {
            return StyleableProperties.BACKGROUND;
        }

        @Override protected void invalidated() {
            final Background b = get();
            if(old != null ? !old.equals(b) : b != null) {
                // They are different! Both cannot be null
                if (old == null || b == null || !old.getOutsets().equals(b.getOutsets())) {
                    // We have determined that the outsets of these two different background
                    // objects is different, and therefore the bounds have changed.
                    NodeHelper.geomChanged(Region.this);
                    insets.fireValueChanged();
                }

                // If the Background is made up of any BackgroundImage objects, then we must
                // inspect the images of those BackgroundImage objects to see if they are still
                // being loaded in the background or if they are animated. If so, then we need
                // to attach a listener, so that when the image finishes loading or changes,
                // we can repaint the region.
                if (b != null) {
                    for (BackgroundImage i : b.getImages()) {
                        final Image image = i.image;
                        final Toolkit.ImageAccessor acc = Toolkit.getImageAccessor();
                        if (acc.isAnimation(image) || image.getProgress() &lt; 1) {
                            addImageListener(image);
                        }
                    }
                }

                // And we must remove this listener from any old images
                if (old != null) {
                    for (BackgroundImage i : old.getImages()) {
                        removeImageListener(i.image);
                    }
                }

                // No matter what, the fill has changed, so we have to update it
                NodeHelper.markDirty(Region.this, DirtyBits.SHAPE_FILL);
                cornersValid = false;
                old = b;
            }
        }
    };
    public final void setBackground(Background value) { background.set(value); }
    public final Background getBackground() { return background.get(); }
    public final ObjectProperty&lt;Background&gt; backgroundProperty() { return background; }

    /**
     * The border of the Region, which is made up of zero or more BorderStrokes, and
     * zero or more BorderImages. It is possible for a Border to be empty, where it
     * has neither strokes nor images, and is semantically equivalent to null.
     * @since JavaFX 8.0
     */
    private final ObjectProperty&lt;Border&gt; border = new StyleableObjectProperty&lt;Border&gt;(null) {
        private Border old = null;
        @Override public Object getBean() { return Region.this; }
        @Override public String getName() { return &quot;border&quot;; }
        @Override public CssMetaData&lt;Region, Border&gt; getCssMetaData() {
            return StyleableProperties.BORDER;
        }
        @Override protected void invalidated() {
            final Border b = get();
            if(old != null ? !old.equals(b) : b != null) {
                // They are different! Both cannot be null
                if (old == null || b == null || !old.getOutsets().equals(b.getOutsets())) {
                    // We have determined that the outsets of these two different border
                    // objects is different, and therefore the bounds have changed.
                    NodeHelper.geomChanged(Region.this);
                }
                if (old == null || b == null || !old.getInsets().equals(b.getInsets())) {
                    insets.fireValueChanged();
                }

                // If the Border is made up of any BorderImage objects, then we must
                // inspect the images of those BorderImage objects to see if they are still
                // being loaded in the background or if they are animated. If so, then we need
                // to attach a listener, so that when the image finishes loading or changes,
                // we can repaint the region.
                if (b != null) {
                    for (BorderImage i : b.getImages()) {
                        final Image image = i.image;
                        final Toolkit.ImageAccessor acc = Toolkit.getImageAccessor();
                        if (acc.isAnimation(image) || image.getProgress() &lt; 1) {
                            addImageListener(image);
                        }
                    }
                }

                // And we must remove this listener from any old images
                if (old != null) {
                    for (BorderImage i : old.getImages()) {
                        removeImageListener(i.image);
                    }
                }

                // No matter what, the fill has changed, so we have to update it
                NodeHelper.markDirty(Region.this, DirtyBits.SHAPE_STROKE);
                cornersValid = false;
                old = b;
            }
        }
    };
    public final void setBorder(Border value) { border.set(value); }
    public final Border getBorder() { return border.get(); }
    public final ObjectProperty&lt;Border&gt; borderProperty() { return border; }

    /**
     * Adds the imageChangeListener to this image. This method was broken out and made
     * package private for testing purposes.
     *
     * @param image a non-null image
     */
    void addImageListener(Image image) {
        final Toolkit.ImageAccessor acc = Toolkit.getImageAccessor();
        acc.getImageProperty(image).addListener(imageChangeListener);
    }

    /**
     * Removes the imageChangeListener from this image. This method was broken out and made
     * package private for testing purposes.
     *
     * @param image a non-null image
     */
    void removeImageListener(Image image) {
        final Toolkit.ImageAccessor acc = Toolkit.getImageAccessor();
        acc.getImageProperty(image).removeListener(imageChangeListener);
    }

    /**
     * Defines the area of the region within which completely opaque pixels
     * are drawn. This is used for various performance optimizations.
     * The pixels within this area MUST BE fully opaque, or rendering
     * artifacts will result. It is the responsibility of the application, either
     * via code or via CSS, to ensure that the opaqueInsets is correct for
     * a Region based on the backgrounds and borders of that region. The values
     * for each of the insets must be real numbers, not NaN or Infinity. If
     * no known insets exist, then the opaqueInsets should be set to null.
     * @return the opaque insets property
     * @since JavaFX 8.0
     */
    public final ObjectProperty&lt;Insets&gt; opaqueInsetsProperty() {
        if (opaqueInsets == null) {
            opaqueInsets = new StyleableObjectProperty&lt;Insets&gt;() {
                @Override public Object getBean() { return Region.this; }
                @Override public String getName() { return &quot;opaqueInsets&quot;; }
                @Override public CssMetaData&lt;Region, Insets&gt; getCssMetaData() {
                    return StyleableProperties.OPAQUE_INSETS;
                }
                @Override protected void invalidated() {
                    // This causes the background to be updated, which
                    // is the code block where we also compute the opaque insets
                    // since updating the background is super fast even when
                    // nothing has changed.
                    NodeHelper.markDirty(Region.this, DirtyBits.SHAPE_FILL);
                }
            };
        }
        return opaqueInsets;
    }
    private ObjectProperty&lt;Insets&gt; opaqueInsets;
    public final void setOpaqueInsets(Insets value) { opaqueInsetsProperty().set(value); }
    public final Insets getOpaqueInsets() { return opaqueInsets == null ? null : opaqueInsets.get(); }

    /**
     * The insets of the Region define the distance from the edge of the region (its layout bounds,
     * or (0, 0, width, height)) to the edge of the content area. All child nodes should be laid out
     * within the content area. The insets are computed based on the Border which has been specified,
     * if any, and also the padding.
     * @since JavaFX 8.0
     */
    private final InsetsProperty insets = new InsetsProperty();
    public final Insets getInsets() { return insets.get(); }
    public final ReadOnlyObjectProperty&lt;Insets&gt; insetsProperty() { return insets; }
    private final class InsetsProperty extends ReadOnlyObjectProperty&lt;Insets&gt; {
        private Insets cache = null;
        private ExpressionHelper&lt;Insets&gt; helper = null;

        @Override public Object getBean() { return Region.this; }
        @Override public String getName() { return &quot;insets&quot;; }

        @Override public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override public void addListener(ChangeListener&lt;? super Insets&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override public void removeListener(ChangeListener&lt;? super Insets&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        void fireValueChanged() {
            cache = null;
            updateSnappedInsets();
            requestLayout();
            ExpressionHelper.fireValueChangedEvent(helper);
        }

        @Override public Insets get() {
            // If a shape is specified, then we don't really care whether there are any borders
            // specified, since borders of shapes do not contribute to the insets.
            if (_shape != null) return getPadding();

            // If there is no border or the border has no insets itself, then the only thing
            // affecting the insets is the padding, so we can just return it directly.
            final Border b = getBorder();
            if (b == null || Insets.EMPTY.equals(b.getInsets())) {
                return getPadding();
            }

            // There is a border with some non-zero insets and we do not have a _shape, so we need
            // to take the border's insets into account
            if (cache == null) {
                // Combine the padding and the border insets.
                // TODO note that negative border insets were being ignored, but
                // I'm not sure that that made sense or was reasonable, so I have
                // changed it so that we just do simple math.
                // TODO Stroke borders should NOT contribute to the insets. Ensure via tests.
                final Insets borderInsets = b.getInsets();
                final Insets paddingInsets = getPadding();
                cache = new Insets(
                        borderInsets.getTop() + paddingInsets.getTop(),
                        borderInsets.getRight() + paddingInsets.getRight(),
                        borderInsets.getBottom() + paddingInsets.getBottom(),
                        borderInsets.getLeft() + paddingInsets.getLeft()
                );
            }
            return cache;
        }
    };

    /**
     * cached results of snapped insets, this are used a lot during layout so makes sense
     * to keep fast access cached copies here.
     */
    private double snappedTopInset = 0;
    private double snappedRightInset = 0;
    private double snappedBottomInset = 0;
    private double snappedLeftInset = 0;

    /** Called to update the cached snapped insets */
    private void updateSnappedInsets() {
        final Insets insets = getInsets();
        if (_snapToPixel) {
            snappedTopInset = Math.ceil(insets.getTop());
            snappedRightInset = Math.ceil(insets.getRight());
            snappedBottomInset = Math.ceil(insets.getBottom());
            snappedLeftInset = Math.ceil(insets.getLeft());
        } else {
            snappedTopInset = insets.getTop();
            snappedRightInset = insets.getRight();
            snappedBottomInset = insets.getBottom();
            snappedLeftInset = insets.getLeft();
        }
    }

    /**
    * The width of this resizable node.  This property is set by the region's parent
    * during layout and may not be set by the application.  If an application
    * needs to explicitly control the size of a region, it should override its
    * preferred size range by setting the &lt;code&gt;minWidth&lt;/code&gt;, &lt;code&gt;prefWidth&lt;/code&gt;,
    * and &lt;code&gt;maxWidth&lt;/code&gt; properties.
    */
    private ReadOnlyDoubleWrapper width;

    /**
     * Because the width is very often set and very often read but only sometimes
     * listened to, it is beneficial to use the super-lazy pattern property, where we
     * only inflate the property object when widthProperty() is explicitly invoked.
     */
    private double _width;

    // Note that it is OK for this method to be protected so long as the width
    // property is never bound. Only Region could do so because only Region has
    // access to a writable property for &quot;width&quot;, but since there is now a protected
    // set method, it is impossible for Region to ever bind this property.
    protected void setWidth(double value) {
        if(width == null) {
            widthChanged(value);
        } else {
            width.set(value);
        }
    }

    private void widthChanged(double value) {
        // It is possible that somebody sets the width of the region to a value which
        // it previously held. If this is the case, we want to avoid excessive layouts.
        // Note that I have biased this for layout over binding, because the widthProperty
        // is now going to recompute the width eagerly. The cost of excessive and
        // unnecessary bounds changes, however, is relatively high.
        if (value != _width) {
            _width = value;
            cornersValid = false;
            boundingBox = null;
            NodeHelper.layoutBoundsChanged(this);
            NodeHelper.geomChanged(this);
            NodeHelper.markDirty(this, DirtyBits.NODE_GEOMETRY);
            setNeedsLayout(true);
            requestParentLayout();
        }
    }

    public final double getWidth() { return width == null ? _width : width.get(); }

    public final ReadOnlyDoubleProperty widthProperty() {
        if (width == null) {
            width = new ReadOnlyDoubleWrapper(_width) {
                @Override protected void invalidated() { widthChanged(get()); }
                @Override public Object getBean() { return Region.this; }
                @Override public String getName() { return &quot;width&quot;; }
            };
        }
        return width.getReadOnlyProperty();
    }

    /**
     * The height of this resizable node.  This property is set by the region's parent
     * during layout and may not be set by the application.  If an application
     * needs to explicitly control the size of a region, it should override its
     * preferred size range by setting the &lt;code&gt;minHeight&lt;/code&gt;, &lt;code&gt;prefHeight&lt;/code&gt;,
     * and &lt;code&gt;maxHeight&lt;/code&gt; properties.
     */
    private ReadOnlyDoubleWrapper height;

    /**
     * Because the height is very often set and very often read but only sometimes
     * listened to, it is beneficial to use the super-lazy pattern property, where we
     * only inflate the property object when heightProperty() is explicitly invoked.
     */
    private double _height;

    // Note that it is OK for this method to be protected so long as the height
    // property is never bound. Only Region could do so because only Region has
    // access to a writable property for &quot;height&quot;, but since there is now a protected
    // set method, it is impossible for Region to ever bind this property.
    protected void setHeight(double value) {
        if (height == null) {
            heightChanged(value);
        } else {
            height.set(value);
        }
    }

    private void heightChanged(double value) {
        if (_height != value) {
            _height = value;
            cornersValid = false;
            // It is possible that somebody sets the height of the region to a value which
            // it previously held. If this is the case, we want to avoid excessive layouts.
            // Note that I have biased this for layout over binding, because the heightProperty
            // is now going to recompute the height eagerly. The cost of excessive and
            // unnecessary bounds changes, however, is relatively high.
            boundingBox = null;
            // Note: although NodeHelper.geomChanged will usually also invalidate the
            // layout bounds, that is not the case for Regions, and both must
            // be called separately.
            NodeHelper.geomChanged(this);
            NodeHelper.layoutBoundsChanged(this);
            // We use &quot;NODE_GEOMETRY&quot; to mean that the bounds have changed and
            // need to be sync'd with the render tree
            NodeHelper.markDirty(this, DirtyBits.NODE_GEOMETRY);
            // Change of the height (or width) won't change the preferred size.
            // So we don't need to flush the cache. We should however mark this node
            // as needs layout to be internally layouted.
            setNeedsLayout(true);
            // This call is only needed when this was not called from the parent during the layout.
            // Otherwise it would flush the cache of the parent, which is not necessary
            requestParentLayout();
        }
    }

    public final double getHeight() { return height == null ? _height : height.get(); }

    public final ReadOnlyDoubleProperty heightProperty() {
        if (height == null) {
            height = new ReadOnlyDoubleWrapper(_height) {
                @Override protected void invalidated() { heightChanged(get()); }
                @Override public Object getBean() { return Region.this; }
                @Override public String getName() { return &quot;height&quot;; }
            };
        }
        return height.getReadOnlyProperty();
    }

    /**
     * This class is reused for the min, pref, and max properties since
     * they all performed the same function (to call requestParentLayout).
     */
    private final class MinPrefMaxProperty extends StyleableDoubleProperty {
        private final String name;
        private final CssMetaData&lt;? extends Styleable, Number&gt; cssMetaData;

        MinPrefMaxProperty(String name, double initialValue, CssMetaData&lt;? extends Styleable, Number&gt; cssMetaData) {
            super(initialValue);
            this.name = name;
            this.cssMetaData = cssMetaData;
        }

        @Override public void invalidated() { requestParentLayout(); }
        @Override public Object getBean() { return Region.this; }
        @Override public String getName() { return name; }

        @Override
        public CssMetaData&lt;? extends Styleable, Number&gt; getCssMetaData() {
            return cssMetaData;
        }
    }

    /**
     * Property for overriding the region's computed minimum width.
     * This should only be set if the region's internally computed minimum width
     * doesn't meet the application's layout needs.
     * &lt;p&gt;
     * Defaults to the &lt;code&gt;USE_COMPUTED_SIZE&lt;/code&gt; flag, which means that
     * &lt;code&gt;minWidth(forHeight)&lt;/code&gt; will return the region's internally
     * computed minimum width.
     * &lt;p&gt;
     * Setting this value to the &lt;code&gt;USE_PREF_SIZE&lt;/code&gt; flag will cause
     * &lt;code&gt;minWidth(forHeight)&lt;/code&gt; to return the region's preferred width,
     * enabling applications to easily restrict the resizability of the region.
     */
    private DoubleProperty minWidth;
    private double _minWidth = USE_COMPUTED_SIZE;
    public final void setMinWidth(double value) {
        if (minWidth == null) {
            _minWidth = value;
            requestParentLayout();
        } else {
            minWidth.set(value);
        }
    }
    public final double getMinWidth() { return minWidth == null ? _minWidth : minWidth.get(); }
    public final DoubleProperty minWidthProperty() {
        if (minWidth == null) minWidth = new MinPrefMaxProperty(&quot;minWidth&quot;, _minWidth, StyleableProperties.MIN_WIDTH);
        return minWidth;
    }

    /**
     * Property for overriding the region's computed minimum height.
     * This should only be set if the region's internally computed minimum height
     * doesn't meet the application's layout needs.
     * &lt;p&gt;
     * Defaults to the &lt;code&gt;USE_COMPUTED_SIZE&lt;/code&gt; flag, which means that
     * &lt;code&gt;minHeight(forWidth)&lt;/code&gt; will return the region's internally
     * computed minimum height.
     * &lt;p&gt;
     * Setting this value to the &lt;code&gt;USE_PREF_SIZE&lt;/code&gt; flag will cause
     * &lt;code&gt;minHeight(forWidth)&lt;/code&gt; to return the region's preferred height,
     * enabling applications to easily restrict the resizability of the region.
     *
     */
    private DoubleProperty minHeight;
    private double _minHeight = USE_COMPUTED_SIZE;
    public final void setMinHeight(double value) {
        if (minHeight == null) {
            _minHeight = value;
            requestParentLayout();
        } else {
            minHeight.set(value);
        }
    }
    public final double getMinHeight() { return minHeight == null ? _minHeight : minHeight.get(); }
    public final DoubleProperty minHeightProperty() {
        if (minHeight == null) minHeight = new MinPrefMaxProperty(&quot;minHeight&quot;, _minHeight, StyleableProperties.MIN_HEIGHT);
        return minHeight;
    }

    /**
     * Convenience method for overriding the region's computed minimum width and height.
     * This should only be called if the region's internally computed minimum size
     * doesn't meet the application's layout needs.
     *
     * @see #setMinWidth
     * @see #setMinHeight
     * @param minWidth  the override value for minimum width
     * @param minHeight the override value for minimum height
     */
    public void setMinSize(double minWidth, double minHeight) {
        setMinWidth(minWidth);
        setMinHeight(minHeight);
    }

    /**
     * Property for overriding the region's computed preferred width.
     * This should only be set if the region's internally computed preferred width
     * doesn't meet the application's layout needs.
     * &lt;p&gt;
     * Defaults to the &lt;code&gt;USE_COMPUTED_SIZE&lt;/code&gt; flag, which means that
     * &lt;code&gt;getPrefWidth(forHeight)&lt;/code&gt; will return the region's internally
     * computed preferred width.
     */
    private DoubleProperty prefWidth;
    private double _prefWidth = USE_COMPUTED_SIZE;
    public final void setPrefWidth(double value) {
        if (prefWidth == null) {
            _prefWidth = value;
            requestParentLayout();
        } else {
            prefWidth.set(value);
        }
    }
    public final double getPrefWidth() { return prefWidth == null ? _prefWidth : prefWidth.get(); }
    public final DoubleProperty prefWidthProperty() {
        if (prefWidth == null) prefWidth = new MinPrefMaxProperty(&quot;prefWidth&quot;, _prefWidth, StyleableProperties.PREF_WIDTH);
        return prefWidth;
    }

    /**
     * Property for overriding the region's computed preferred height.
     * This should only be set if the region's internally computed preferred height
     * doesn't meet the application's layout needs.
     * &lt;p&gt;
     * Defaults to the &lt;code&gt;USE_COMPUTED_SIZE&lt;/code&gt; flag, which means that
     * &lt;code&gt;getPrefHeight(forWidth)&lt;/code&gt; will return the region's internally
     * computed preferred width.
     */
    private DoubleProperty prefHeight;
    private double _prefHeight = USE_COMPUTED_SIZE;
    public final void setPrefHeight(double value) {
        if (prefHeight == null) {
            _prefHeight = value;
            requestParentLayout();
        } else {
            prefHeight.set(value);
        }
    }
    public final double getPrefHeight() { return prefHeight == null ? _prefHeight : prefHeight.get(); }
    public final DoubleProperty prefHeightProperty() {
        if (prefHeight == null) prefHeight = new MinPrefMaxProperty(&quot;prefHeight&quot;, _prefHeight, StyleableProperties.PREF_HEIGHT);
        return prefHeight;
    }

    /**
     * Convenience method for overriding the region's computed preferred width and height.
     * This should only be called if the region's internally computed preferred size
     * doesn't meet the application's layout needs.
     *
     * @see #setPrefWidth
     * @see #setPrefHeight
     * @param prefWidth the override value for preferred width
     * @param prefHeight the override value for preferred height
     */
    public void setPrefSize(double prefWidth, double prefHeight) {
        setPrefWidth(prefWidth);
        setPrefHeight(prefHeight);
    }

    /**
     * Property for overriding the region's computed maximum width.
     * This should only be set if the region's internally computed maximum width
     * doesn't meet the application's layout needs.
     * &lt;p&gt;
     * Defaults to the &lt;code&gt;USE_COMPUTED_SIZE&lt;/code&gt; flag, which means that
     * &lt;code&gt;getMaxWidth(forHeight)&lt;/code&gt; will return the region's internally
     * computed maximum width.
     * &lt;p&gt;
     * Setting this value to the &lt;code&gt;USE_PREF_SIZE&lt;/code&gt; flag will cause
     * &lt;code&gt;getMaxWidth(forHeight)&lt;/code&gt; to return the region's preferred width,
     * enabling applications to easily restrict the resizability of the region.
     */
    private DoubleProperty maxWidth;
    private double _maxWidth = USE_COMPUTED_SIZE;
    public final void setMaxWidth(double value) {
        if (maxWidth == null) {
            _maxWidth = value;
            requestParentLayout();
        } else {
            maxWidth.set(value);
        }
    }
    public final double getMaxWidth() { return maxWidth == null ? _maxWidth : maxWidth.get(); }
    public final DoubleProperty maxWidthProperty() {
        if (maxWidth == null) maxWidth = new MinPrefMaxProperty(&quot;maxWidth&quot;, _maxWidth, StyleableProperties.MAX_WIDTH);
        return maxWidth;
    }

    /**
     * Property for overriding the region's computed maximum height.
     * This should only be set if the region's internally computed maximum height
     * doesn't meet the application's layout needs.
     * &lt;p&gt;
     * Defaults to the &lt;code&gt;USE_COMPUTED_SIZE&lt;/code&gt; flag, which means that
     * &lt;code&gt;getMaxHeight(forWidth)&lt;/code&gt; will return the region's internally
     * computed maximum height.
     * &lt;p&gt;
     * Setting this value to the &lt;code&gt;USE_PREF_SIZE&lt;/code&gt; flag will cause
     * &lt;code&gt;getMaxHeight(forWidth)&lt;/code&gt; to return the region's preferred height,
     * enabling applications to easily restrict the resizability of the region.
     */
    private DoubleProperty maxHeight;
    private double _maxHeight = USE_COMPUTED_SIZE;
    public final void setMaxHeight(double value) {
        if (maxHeight == null) {
            _maxHeight = value;
            requestParentLayout();
        } else {
            maxHeight.set(value);
        }
    }
    public final double getMaxHeight() { return maxHeight == null ? _maxHeight : maxHeight.get(); }
    public final DoubleProperty maxHeightProperty() {
        if (maxHeight == null) maxHeight = new MinPrefMaxProperty(&quot;maxHeight&quot;, _maxHeight, StyleableProperties.MAX_HEIGHT);
        return maxHeight;
    }

    /**
     * Convenience method for overriding the region's computed maximum width and height.
     * This should only be called if the region's internally computed maximum size
     * doesn't meet the application's layout needs.
     *
     * @see #setMaxWidth
     * @see #setMaxHeight
     * @param maxWidth  the override value for maximum width
     * @param maxHeight the override value for maximum height
     */
    public void setMaxSize(double maxWidth, double maxHeight) {
        setMaxWidth(maxWidth);
        setMaxHeight(maxHeight);
    }

    /**
     * When specified, the {@code Shape} will cause the region to be
     * rendered as the specified shape rather than as a rounded rectangle.
     * When null, the Region is rendered as a rounded rectangle. When rendered
     * as a Shape, any Background is used to fill the shape, although any
     * background insets are ignored as are background radii. Any BorderStrokes
     * defined are used for stroking the shape. Any BorderImages are ignored.
     *
     * @defaultValue null
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;Shape&gt; shape = null;
    private Shape _shape;
    public final Shape getShape() { return shape == null ? _shape : shape.get(); }
    public final void setShape(Shape value) { shapeProperty().set(value); }
    public final ObjectProperty&lt;Shape&gt; shapeProperty() {
        if (shape == null) {
            shape = new ShapeProperty();
        }
        return shape;
    }

    /**
     * An implementation for the ShapeProperty. This is also a ShapeChangeListener.
     */
    private final class ShapeProperty extends StyleableObjectProperty&lt;Shape&gt; implements Runnable {
        @Override public Object getBean() { return Region.this; }
        @Override public String getName() { return &quot;shape&quot;; }
        @Override public CssMetaData&lt;Region, Shape&gt; getCssMetaData() {
            return StyleableProperties.SHAPE;
        }
        @Override protected void invalidated() {
            final Shape value = get();
            if (_shape != value) {
                // The shape has changed. We need to add/remove listeners
                if (_shape != null) ShapeHelper.setShapeChangeListener(_shape, null);
                if (value != null) ShapeHelper.setShapeChangeListener(value, this);
                // Invalidate the bounds and such
                run();
                if (_shape == null || value == null) {
                    // It either was null before, or is null now. In either case,
                    // the result of the insets computation will have changed, and
                    // we therefore need to fire that the insets value may have changed.
                    insets.fireValueChanged();
                }
                // Update our reference to the old shape
                _shape = value;
            }
        }

        @Override public void run() {
            NodeHelper.geomChanged(Region.this);
            NodeHelper.markDirty(Region.this, DirtyBits.REGION_SHAPE);
        }
    };

    /**
     * Specifies whether the shape, if defined, is scaled to match the size of the Region.
     * {@code true} means the shape is scaled to fit the size of the Region, {@code false}
     * means the shape is at its source size, its positioning depends on the value of
     * {@code centerShape}.
     *
     * @defaultValue true
     * @since JavaFX 8.0
     */
    private BooleanProperty scaleShape = null;
    public final void setScaleShape(boolean value) { scaleShapeProperty().set(value); }
    public final boolean isScaleShape() { return scaleShape == null ? true : scaleShape.get(); }
    public final BooleanProperty scaleShapeProperty() {
        if (scaleShape == null) {
            scaleShape = new StyleableBooleanProperty(true) {
                @Override public Object getBean() { return Region.this; }
                @Override public String getName() { return &quot;scaleShape&quot;; }
                @Override public CssMetaData&lt;Region, Boolean&gt; getCssMetaData() {
                    return StyleableProperties.SCALE_SHAPE;
                }
                @Override public void invalidated() {
                    NodeHelper.geomChanged(Region.this);
                    NodeHelper.markDirty(Region.this, DirtyBits.REGION_SHAPE);
                }
            };
        }
        return scaleShape;
    }

    /**
     * Defines whether the shape is centered within the Region's width or height.
     * {@code true} means the shape centered within the Region's width and height,
     * {@code false} means the shape is positioned at its source position.
     *
     * @defaultValue true
     * @since JavaFX 8.0
     */
    private BooleanProperty centerShape = null;
    public final void setCenterShape(boolean value) { centerShapeProperty().set(value); }
    public final boolean isCenterShape() { return centerShape == null ? true : centerShape.get(); }
    public final BooleanProperty centerShapeProperty() {
        if (centerShape == null) {
            centerShape = new StyleableBooleanProperty(true) {
                @Override public Object getBean() { return Region.this; }
                @Override public String getName() { return &quot;centerShape&quot;; }
                @Override public CssMetaData&lt;Region, Boolean&gt; getCssMetaData() {
                    return StyleableProperties.POSITION_SHAPE;
                }
                @Override public void invalidated() {
                    NodeHelper.geomChanged(Region.this);
                    NodeHelper.markDirty(Region.this, DirtyBits.REGION_SHAPE);
                }
            };
        }
        return centerShape;
    }

    /**
     * Defines a hint to the system indicating that the Shape used to define the region's
     * background is stable and would benefit from caching.
     *
     * @defaultValue true
     * @since JavaFX 8.0
     */
    private BooleanProperty cacheShape = null;
    public final void setCacheShape(boolean value) { cacheShapeProperty().set(value); }
    public final boolean isCacheShape() { return cacheShape == null ? true : cacheShape.get(); }
    public final BooleanProperty cacheShapeProperty() {
        if (cacheShape == null) {
            cacheShape = new StyleableBooleanProperty(true) {
                @Override public Object getBean() { return Region.this; }
                @Override public String getName() { return &quot;cacheShape&quot;; }
                @Override public CssMetaData&lt;Region, Boolean&gt; getCssMetaData() {
                    return StyleableProperties.CACHE_SHAPE;
                }
            };
        }
        return cacheShape;
    }

    /***************************************************************************
     *                                                                         *
     * Layout                                                                  *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; since all Regions are resizable.
     * @return whether this node can be resized by its parent during layout
     */
    @Override public boolean isResizable() {
        return true;
    }

    /**
     * Invoked by the region's parent during layout to set the region's
     * width and height.  &lt;b&gt;Applications should not invoke this method directly&lt;/b&gt;.
     * If an application needs to directly set the size of the region, it should
     * override its size constraints by calling &lt;code&gt;setMinSize()&lt;/code&gt;,
     *  &lt;code&gt;setPrefSize()&lt;/code&gt;, or &lt;code&gt;setMaxSize()&lt;/code&gt; and it's parent
     * will honor those overrides during layout.
     *
     * @param width the target layout bounds width
     * @param height the target layout bounds height
     */
    @Override public void resize(double width, double height) {
        setWidth(width);
        setHeight(height);
        PlatformLogger logger = Logging.getLayoutLogger();
        if (logger.isLoggable(Level.FINER)) {
            logger.finer(this.toString() + &quot; resized to &quot; + width + &quot; x &quot; + height);
        }
    }

    /**
     * Called during layout to determine the minimum width for this node.
     * Returns the value from &lt;code&gt;computeMinWidth(forHeight)&lt;/code&gt; unless
     * the application overrode the minimum width by setting the minWidth property.
     *
     * @see #setMinWidth(double)
     * @return the minimum width that this node should be resized to during layout
     */
    @Override public final double minWidth(double height) {
        final double override = getMinWidth();
        if (override == USE_COMPUTED_SIZE) {
            return super.minWidth(height);
        } else if (override == USE_PREF_SIZE) {
            return prefWidth(height);
        }
        return Double.isNaN(override) || override &lt; 0 ? 0 : override;
    }

    /**
     * Called during layout to determine the minimum height for this node.
     * Returns the value from &lt;code&gt;computeMinHeight(forWidth)&lt;/code&gt; unless
     * the application overrode the minimum height by setting the minHeight property.
     *
     * @see #setMinHeight
     * @return the minimum height that this node should be resized to during layout
     */
    @Override public final double minHeight(double width) {
        final double override = getMinHeight();
        if (override == USE_COMPUTED_SIZE) {
            return super.minHeight(width);
        } else if (override == USE_PREF_SIZE) {
            return prefHeight(width);
        }
        return Double.isNaN(override) || override &lt; 0 ? 0 : override;
    }

    /**
     * Called during layout to determine the preferred width for this node.
     * Returns the value from &lt;code&gt;computePrefWidth(forHeight)&lt;/code&gt; unless
     * the application overrode the preferred width by setting the prefWidth property.
     *
     * @see #setPrefWidth
     * @return the preferred width that this node should be resized to during layout
     */
    @Override public final double prefWidth(double height) {
        final double override = getPrefWidth();
        if (override == USE_COMPUTED_SIZE) {
            return super.prefWidth(height);
        }
        return Double.isNaN(override) || override &lt; 0 ? 0 : override;
    }

    /**
     * Called during layout to determine the preferred height for this node.
     * Returns the value from &lt;code&gt;computePrefHeight(forWidth)&lt;/code&gt; unless
     * the application overrode the preferred height by setting the prefHeight property.
     *
     * @see #setPrefHeight
     * @return the preferred height that this node should be resized to during layout
     */
    @Override public final double prefHeight(double width) {
        final double override = getPrefHeight();
        if (override == USE_COMPUTED_SIZE) {
            return super.prefHeight(width);
        }
        return Double.isNaN(override) || override &lt; 0 ? 0 : override;
    }

    /**
     * Called during layout to determine the maximum width for this node.
     * Returns the value from &lt;code&gt;computeMaxWidth(forHeight)&lt;/code&gt; unless
     * the application overrode the maximum width by setting the maxWidth property.
     *
     * @see #setMaxWidth
     * @return the maximum width that this node should be resized to during layout
     */
    @Override public final double maxWidth(double height) {
        final double override = getMaxWidth();
        if (override == USE_COMPUTED_SIZE) {
            return computeMaxWidth(height);
        } else if (override == USE_PREF_SIZE) {
            return prefWidth(height);
        }
        return Double.isNaN(override) || override &lt; 0 ? 0 : override;
    }

    /**
     * Called during layout to determine the maximum height for this node.
     * Returns the value from &lt;code&gt;computeMaxHeight(forWidth)&lt;/code&gt; unless
     * the application overrode the maximum height by setting the maxHeight property.
     *
     * @see #setMaxHeight
     * @return the maximum height that this node should be resized to during layout
     */
    @Override public final double maxHeight(double width) {
        final double override = getMaxHeight();
        if (override == USE_COMPUTED_SIZE) {
            return computeMaxHeight(width);
        } else if (override == USE_PREF_SIZE) {
            return prefHeight(width);
        }
        return Double.isNaN(override) || override &lt; 0 ? 0 : override;
    }

    /**
     * Computes the minimum width of this region.
     * Returns the sum of the left and right insets by default.
     * region subclasses should override this method to return an appropriate
     * value based on their content and layout strategy.  If the subclass
     * doesn't have a VERTICAL content bias, then the height parameter can be
     * ignored.
     *
     * @return the computed minimum width of this region
     */
    @Override protected double computeMinWidth(double height) {
        return getInsets().getLeft() + getInsets().getRight();
    }

    /**
     * Computes the minimum height of this region.
     * Returns the sum of the top and bottom insets by default.
     * Region subclasses should override this method to return an appropriate
     * value based on their content and layout strategy.  If the subclass
     * doesn't have a HORIZONTAL content bias, then the width parameter can be
     * ignored.
     *
     * @return the computed minimum height for this region
     */
    @Override protected double computeMinHeight(double width) {
        return getInsets().getTop() + getInsets().getBottom();
    }

    /**
     * Computes the preferred width of this region for the given height.
     * Region subclasses should override this method to return an appropriate
     * value based on their content and layout strategy.  If the subclass
     * doesn't have a VERTICAL content bias, then the height parameter can be
     * ignored.
     *
     * @return the computed preferred width for this region
     */
    @Override protected double computePrefWidth(double height) {
        final double w = super.computePrefWidth(height);
        return getInsets().getLeft() + w + getInsets().getRight();
    }

    /**
     * Computes the preferred height of this region for the given width;
     * Region subclasses should override this method to return an appropriate
     * value based on their content and layout strategy.  If the subclass
     * doesn't have a HORIZONTAL content bias, then the width parameter can be
     * ignored.
     *
     * @return the computed preferred height for this region
     */
    @Override protected double computePrefHeight(double width) {
        final double h = super.computePrefHeight(width);
        return getInsets().getTop() + h + getInsets().getBottom();
    }

    /**
     * Computes the maximum width for this region.
     * Returns Double.MAX_VALUE by default.
     * Region subclasses may override this method to return an different
     * value based on their content and layout strategy.  If the subclass
     * doesn't have a VERTICAL content bias, then the height parameter can be
     * ignored.
     *
     * @param height The height of the Region, in case this value might dictate
     * the maximum width
     * @return the computed maximum width for this region
     */
    protected double computeMaxWidth(double height) {
        return Double.MAX_VALUE;
    }

    /**
     * Computes the maximum height of this region.
     * Returns Double.MAX_VALUE by default.
     * Region subclasses may override this method to return a different
     * value based on their content and layout strategy.  If the subclass
     * doesn't have a HORIZONTAL content bias, then the width parameter can be
     * ignored.
     *
     * @param width The width of the Region, in case this value might dictate
     * the maximum height
     * @return the computed maximum height for this region
     */
    protected double computeMaxHeight(double width) {
        return Double.MAX_VALUE;
    }

    /**
     * If this region's snapToPixel property is false, this method returns the
     * same value, else it tries to return a value rounded to the nearest
     * pixel, but since there is no indication if the value is a vertical
     * or horizontal measurement then it may be snapped to the wrong pixel
     * size metric on screens with different horizontal and vertical scales.
     * @param value the space value to be snapped
     * @return value rounded to nearest pixel
     * @deprecated replaced by {@code snapSpaceX()} and {@code snapSpaceY()}
     */
    @Deprecated(since=&quot;9&quot;)
    protected double snapSpace(double value) {
        return snapSpaceX(value, isSnapToPixel());
    }

    /**
     * If this region's snapToPixel property is true, returns a value rounded
     * to the nearest pixel in the horizontal direction, else returns the
     * same value.
     * @param value the space value to be snapped
     * @return value rounded to nearest pixel
     * @since 9
     */
    public double snapSpaceX(double value) {
        return snapSpaceX(value, isSnapToPixel());
    }

    /**
     * If this region's snapToPixel property is true, returns a value rounded
     * to the nearest pixel in the vertical direction, else returns the
     * same value.
     * @param value the space value to be snapped
     * @return value rounded to nearest pixel
     * @since 9
     */
    public double snapSpaceY(double value) {
        return snapSpaceY(value, isSnapToPixel());
    }

    /**
     * If this region's snapToPixel property is false, this method returns the
     * same value, else it tries to return a value ceiled to the nearest
     * pixel, but since there is no indication if the value is a vertical
     * or horizontal measurement then it may be snapped to the wrong pixel
     * size metric on screens with different horizontal and vertical scales.
     * @param value the size value to be snapped
     * @return value ceiled to nearest pixel
     * @deprecated replaced by {@code snapSizeX()} and {@code snapSizeY()}
     */
    @Deprecated(since=&quot;9&quot;)
    protected double snapSize(double value) {
        return snapSizeX(value, isSnapToPixel());
    }

    /**
     * If this region's snapToPixel property is true, returns a value ceiled
     * to the nearest pixel in the horizontal direction, else returns the
     * same value.
     * @param value the size value to be snapped
     * @return value ceiled to nearest pixel
     * @since 9
     */
    public double snapSizeX(double value) {
        return snapSizeX(value, isSnapToPixel());
    }

    /**
     * If this region's snapToPixel property is true, returns a value ceiled
     * to the nearest pixel in the vertical direction, else returns the
     * same value.
     * @param value the size value to be snapped
     * @return value ceiled to nearest pixel
     * @since 9
     */
    public double snapSizeY(double value) {
        return snapSizeY(value, isSnapToPixel());
    }

    /**
     * If this region's snapToPixel property is false, this method returns the
     * same value, else it tries to return a value rounded to the nearest
     * pixel, but since there is no indication if the value is a vertical
     * or horizontal measurement then it may be snapped to the wrong pixel
     * size metric on screens with different horizontal and vertical scales.
     * @param value the position value to be snapped
     * @return value rounded to nearest pixel
     * @deprecated replaced by {@code snapPositionX()} and {@code snapPositionY()}
     */
    @Deprecated(since=&quot;9&quot;)
    protected double snapPosition(double value) {
        return snapPositionX(value, isSnapToPixel());
    }

    /**
     * If this region's snapToPixel property is true, returns a value rounded
     * to the nearest pixel in the horizontal direction, else returns the
     * same value.
     * @param value the position value to be snapped
     * @return value rounded to nearest pixel
     * @since 9
     */
    public double snapPositionX(double value) {
        return snapPositionX(value, isSnapToPixel());
    }

    /**
     * If this region's snapToPixel property is true, returns a value rounded
     * to the nearest pixel in the vertical direction, else returns the
     * same value.
     * @param value the position value to be snapped
     * @return value rounded to nearest pixel
     * @since 9
     */
    public double snapPositionY(double value) {
        return snapPositionY(value, isSnapToPixel());
    }

    double snapPortionX(double value) {
        return snapPortionX(value, isSnapToPixel());
    }
    double snapPortionY(double value) {
        return snapPortionY(value, isSnapToPixel());
    }


    /**
     * Utility method to get the top inset which includes padding and border
     * inset. Then snapped to whole pixels if isSnapToPixel() is true.
     *
     * @since JavaFX 8.0
     * @return Rounded up insets top
     */
    public final double snappedTopInset() {
        return snappedTopInset;
    }

    /**
     * Utility method to get the bottom inset which includes padding and border
     * inset. Then snapped to whole pixels if isSnapToPixel() is true.
     *
     * @since JavaFX 8.0
     * @return Rounded up insets bottom
     */
    public final double snappedBottomInset() {
        return snappedBottomInset;
    }

    /**
     * Utility method to get the left inset which includes padding and border
     * inset. Then snapped to whole pixels if isSnapToPixel() is true.
     *
     * @since JavaFX 8.0
     * @return Rounded up insets left
     */
    public final double snappedLeftInset() {
        return snappedLeftInset;
    }

    /**
     * Utility method to get the right inset which includes padding and border
     * inset. Then snapped to whole pixels if isSnapToPixel() is true.
     *
     * @since JavaFX 8.0
     * @return Rounded up insets right
     */
    public final double snappedRightInset() {
        return snappedRightInset;
    }


    double computeChildMinAreaWidth(Node child, Insets margin) {
        return computeChildMinAreaWidth(child, -1, margin, -1, false);
    }

    double computeChildMinAreaWidth(Node child, double baselineComplement, Insets margin, double height, boolean fillHeight) {
        final boolean snap = isSnapToPixel();
        double left = margin != null? snapSpaceX(margin.getLeft(), snap) : 0;
        double right = margin != null? snapSpaceX(margin.getRight(), snap) : 0;
        double alt = -1;
        if (height != -1 &amp;&amp; child.isResizable() &amp;&amp; child.getContentBias() == Orientation.VERTICAL) { // width depends on height
            double top = margin != null? snapSpaceY(margin.getTop(), snap) : 0;
            double bottom = (margin != null? snapSpaceY(margin.getBottom(), snap) : 0);
            double bo = child.getBaselineOffset();
            final double contentHeight = bo == BASELINE_OFFSET_SAME_AS_HEIGHT &amp;&amp; baselineComplement != -1 ?
                    height - top - bottom - baselineComplement :
                     height - top - bottom;
            if (fillHeight) {
                alt = snapSizeY(boundedSize(
                        child.minHeight(-1), contentHeight,
                        child.maxHeight(-1)));
            } else {
                alt = snapSizeY(boundedSize(
                        child.minHeight(-1),
                        child.prefHeight(-1),
                        Math.min(child.maxHeight(-1), contentHeight)));
            }
        }
        return left + snapSizeX(child.minWidth(alt)) + right;
    }

    double computeChildMinAreaHeight(Node child, Insets margin) {
        return computeChildMinAreaHeight(child, -1, margin, -1);
    }

    double computeChildMinAreaHeight(Node child, double minBaselineComplement, Insets margin, double width) {
        final boolean snap = isSnapToPixel();
        double top =margin != null? snapSpaceY(margin.getTop(), snap) : 0;
        double bottom = margin != null? snapSpaceY(margin.getBottom(), snap) : 0;

        double alt = -1;
        if (child.isResizable() &amp;&amp; child.getContentBias() == Orientation.HORIZONTAL) { // height depends on width
            double left = margin != null? snapSpaceX(margin.getLeft(), snap) : 0;
            double right = margin != null? snapSpaceX(margin.getRight(), snap) : 0;
            alt = snapSizeX(width != -1? boundedSize(child.minWidth(-1), width - left - right, child.maxWidth(-1)) :
                    child.maxWidth(-1));
        }

        // For explanation, see computeChildPrefAreaHeight
        if (minBaselineComplement != -1) {
            double baseline = child.getBaselineOffset();
            if (child.isResizable() &amp;&amp; baseline == BASELINE_OFFSET_SAME_AS_HEIGHT) {
                return top + snapSizeY(child.minHeight(alt)) + bottom
                        + minBaselineComplement;
            } else {
                return baseline + minBaselineComplement;
            }
        } else {
            return top + snapSizeY(child.minHeight(alt)) + bottom;
        }
    }

    double computeChildPrefAreaWidth(Node child, Insets margin) {
        return computeChildPrefAreaWidth(child, -1, margin, -1, false);
    }

    double computeChildPrefAreaWidth(Node child, double baselineComplement, Insets margin, double height, boolean fillHeight) {
        final boolean snap = isSnapToPixel();
        double left = margin != null? snapSpaceX(margin.getLeft(), snap) : 0;
        double right = margin != null? snapSpaceX(margin.getRight(), snap) : 0;
        double alt = -1;
        if (height != -1 &amp;&amp; child.isResizable() &amp;&amp; child.getContentBias() == Orientation.VERTICAL) { // width depends on height
            double top = margin != null? snapSpaceY(margin.getTop(), snap) : 0;
            double bottom = margin != null? snapSpaceY(margin.getBottom(), snap) : 0;
            double bo = child.getBaselineOffset();
            final double contentHeight = bo == BASELINE_OFFSET_SAME_AS_HEIGHT &amp;&amp; baselineComplement != -1 ?
                    height - top - bottom - baselineComplement :
                     height - top - bottom;
            if (fillHeight) {
                alt = snapSizeY(boundedSize(
                        child.minHeight(-1), contentHeight,
                        child.maxHeight(-1)));
            } else {
                alt = snapSizeY(boundedSize(
                        child.minHeight(-1),
                        child.prefHeight(-1),
                        Math.min(child.maxHeight(-1), contentHeight)));
            }
        }
        return left + snapSizeX(boundedSize(child.minWidth(alt), child.prefWidth(alt), child.maxWidth(alt))) + right;
    }

    double computeChildPrefAreaHeight(Node child, Insets margin) {
        return computeChildPrefAreaHeight(child, -1, margin, -1);
    }

    double computeChildPrefAreaHeight(Node child, double prefBaselineComplement, Insets margin, double width) {
        final boolean snap = isSnapToPixel();
        double top = margin != null? snapSpaceY(margin.getTop(), snap) : 0;
        double bottom = margin != null? snapSpaceY(margin.getBottom(), snap) : 0;

        double alt = -1;
        if (child.isResizable() &amp;&amp; child.getContentBias() == Orientation.HORIZONTAL) { // height depends on width
            double left = margin != null ? snapSpaceX(margin.getLeft(), snap) : 0;
            double right = margin != null ? snapSpaceX(margin.getRight(), snap) : 0;
            alt = snapSizeX(boundedSize(
                    child.minWidth(-1), width != -1 ? width - left - right
                    : child.prefWidth(-1), child.maxWidth(-1)));
        }

        if (prefBaselineComplement != -1) {
            double baseline = child.getBaselineOffset();
            if (child.isResizable() &amp;&amp; baseline == BASELINE_OFFSET_SAME_AS_HEIGHT) {
                // When baseline is same as height, the preferred height of the node will be above the baseline, so we need to add
                // the preferred complement to it
                return top + snapSizeY(boundedSize(child.minHeight(alt), child.prefHeight(alt), child.maxHeight(alt))) + bottom
                        + prefBaselineComplement;
            } else {
                // For all other Nodes, it's just their baseline and the complement.
                // Note that the complement already contain the Node's preferred (or fixed) height
                return top + baseline + prefBaselineComplement + bottom;
            }
        } else {
            return top + snapSizeY(boundedSize(child.minHeight(alt), child.prefHeight(alt), child.maxHeight(alt))) + bottom;
        }
    }

    double computeChildMaxAreaWidth(Node child, double baselineComplement, Insets margin, double height, boolean fillHeight) {
        double max = child.maxWidth(-1);
        if (max == Double.MAX_VALUE) {
            return max;
        }
        final boolean snap = isSnapToPixel();
        double left = margin != null? snapSpaceX(margin.getLeft(), snap) : 0;
        double right = margin != null? snapSpaceX(margin.getRight(), snap) : 0;
        double alt = -1;
        if (height != -1 &amp;&amp; child.isResizable() &amp;&amp; child.getContentBias() == Orientation.VERTICAL) { // width depends on height
            double top = margin != null? snapSpaceY(margin.getTop(), snap) : 0;
            double bottom = (margin != null? snapSpaceY(margin.getBottom(), snap) : 0);
            double bo = child.getBaselineOffset();
            final double contentHeight = bo == BASELINE_OFFSET_SAME_AS_HEIGHT &amp;&amp; baselineComplement != -1 ?
                    height - top - bottom - baselineComplement :
                     height - top - bottom;
            if (fillHeight) {
                alt = snapSizeY(boundedSize(
                        child.minHeight(-1), contentHeight,
                        child.maxHeight(-1)));
            } else {
                alt = snapSizeY(boundedSize(
                        child.minHeight(-1),
                        child.prefHeight(-1),
                        Math.min(child.maxHeight(-1), contentHeight)));
            }
            max = child.maxWidth(alt);
        }
        // if min &gt; max, min wins, so still need to call boundedSize()
        return left + snapSizeX(boundedSize(child.minWidth(alt), max, Double.MAX_VALUE)) + right;
    }

    double computeChildMaxAreaHeight(Node child, double maxBaselineComplement, Insets margin, double width) {
        double max = child.maxHeight(-1);
        if (max == Double.MAX_VALUE) {
            return max;
        }

        final boolean snap = isSnapToPixel();
        double top = margin != null? snapSpaceY(margin.getTop(), snap) : 0;
        double bottom = margin != null? snapSpaceY(margin.getBottom(), snap) : 0;
        double alt = -1;
        if (child.isResizable() &amp;&amp; child.getContentBias() == Orientation.HORIZONTAL) { // height depends on width
            double left = margin != null? snapSpaceX(margin.getLeft(), snap) : 0;
            double right = margin != null? snapSpaceX(margin.getRight(), snap) : 0;
            alt = snapSizeX(width != -1? boundedSize(child.minWidth(-1), width - left - right, child.maxWidth(-1)) :
                child.minWidth(-1));
            max = child.maxHeight(alt);
        }
        // For explanation, see computeChildPrefAreaHeight
        if (maxBaselineComplement != -1) {
            double baseline = child.getBaselineOffset();
            if (child.isResizable() &amp;&amp; baseline == BASELINE_OFFSET_SAME_AS_HEIGHT) {
                return top + snapSizeY(boundedSize(child.minHeight(alt), child.maxHeight(alt), Double.MAX_VALUE)) + bottom
                        + maxBaselineComplement;
            } else {
                return top + baseline + maxBaselineComplement + bottom;
            }
        } else {
            // if min &gt; max, min wins, so still need to call boundedSize()
            return top + snapSizeY(boundedSize(child.minHeight(alt), max, Double.MAX_VALUE)) + bottom;
        }
    }

    /* Max of children's minimum area widths */

    double computeMaxMinAreaWidth(List&lt;Node&gt; children, Callback&lt;Node, Insets&gt; margins) {
        return getMaxAreaWidth(children, margins, new double[] { -1 }, false, true);
    }

    double computeMaxMinAreaWidth(List&lt;Node&gt; children, Callback&lt;Node, Insets&gt; margins, double height, boolean fillHeight) {
        return getMaxAreaWidth(children, margins, new double[] { height }, fillHeight, true);
    }

    double computeMaxMinAreaWidth(List&lt;Node&gt; children, Callback&lt;Node, Insets&gt; childMargins, double childHeights[], boolean fillHeight) {
        return getMaxAreaWidth(children, childMargins, childHeights, fillHeight, true);
    }

    /* Max of children's minimum area heights */

    double computeMaxMinAreaHeight(List&lt;Node&gt;children, Callback&lt;Node, Insets&gt; margins, VPos valignment) {
        return getMaxAreaHeight(children, margins, null, valignment, true);
    }

    double computeMaxMinAreaHeight(List&lt;Node&gt;children, Callback&lt;Node, Insets&gt; margins, VPos valignment, double width) {
        return getMaxAreaHeight(children, margins, new double[] { width }, valignment, true);
    }

    double computeMaxMinAreaHeight(List&lt;Node&gt;children, Callback&lt;Node, Insets&gt; childMargins, double childWidths[], VPos valignment) {
        return getMaxAreaHeight(children, childMargins, childWidths, valignment, true);
    }

    /* Max of children's pref area widths */

    double computeMaxPrefAreaWidth(List&lt;Node&gt;children, Callback&lt;Node, Insets&gt; margins) {
        return getMaxAreaWidth(children, margins, new double[] { -1 }, false, false);
    }

    double computeMaxPrefAreaWidth(List&lt;Node&gt;children, Callback&lt;Node, Insets&gt; margins, double height,
            boolean fillHeight) {
        return getMaxAreaWidth(children, margins, new double[] { height }, fillHeight, false);
    }

    double computeMaxPrefAreaWidth(List&lt;Node&gt;children, Callback&lt;Node, Insets&gt; childMargins,
            double childHeights[], boolean fillHeight) {
        return getMaxAreaWidth(children, childMargins, childHeights, fillHeight, false);
    }

    /* Max of children's pref area heights */

    double computeMaxPrefAreaHeight(List&lt;Node&gt;children, Callback&lt;Node, Insets&gt; margins, VPos valignment) {
        return getMaxAreaHeight(children, margins, null, valignment, false);
    }

    double computeMaxPrefAreaHeight(List&lt;Node&gt;children, Callback&lt;Node, Insets&gt; margins, double width, VPos valignment) {
        return getMaxAreaHeight(children, margins, new double[] { width }, valignment, false);
    }

    double computeMaxPrefAreaHeight(List&lt;Node&gt;children, Callback&lt;Node, Insets&gt; childMargins, double childWidths[], VPos valignment) {
        return getMaxAreaHeight(children, childMargins, childWidths, valignment, false);
    }

    /**
     * Returns the size of a Node that should be placed in an area of the specified size,
     * bounded in it's min/max size, respecting bias.
     *
     * @param node the node
     * @param areaWidth the width of the bounding area where the node is going to be placed
     * @param areaHeight the height of the bounding area where the node is going to be placed
     * @param fillWidth if Node should try to fill the area width
     * @param fillHeight if Node should try to fill the area height
     * @param result Vec2d object for the result or null if new one should be created
     * @return Vec2d object with width(x parameter) and height (y parameter)
     */
    static Vec2d boundedNodeSizeWithBias(Node node, double areaWidth, double areaHeight,
            boolean fillWidth, boolean fillHeight, Vec2d result) {
        if (result == null) {
            result = new Vec2d();
        }

        Orientation bias = node.getContentBias();

        double childWidth = 0;
        double childHeight = 0;

        if (bias == null) {
            childWidth = boundedSize(
                    node.minWidth(-1), fillWidth ? areaWidth
                    : Math.min(areaWidth, node.prefWidth(-1)),
                    node.maxWidth(-1));
            childHeight = boundedSize(
                    node.minHeight(-1), fillHeight ? areaHeight
                    : Math.min(areaHeight, node.prefHeight(-1)),
                    node.maxHeight(-1));

        } else if (bias == Orientation.HORIZONTAL) {
            childWidth = boundedSize(
                    node.minWidth(-1), fillWidth ? areaWidth
                    : Math.min(areaWidth, node.prefWidth(-1)),
                    node.maxWidth(-1));
            childHeight = boundedSize(
                    node.minHeight(childWidth), fillHeight ? areaHeight
                    : Math.min(areaHeight, node.prefHeight(childWidth)),
                    node.maxHeight(childWidth));

        } else { // bias == VERTICAL
            childHeight = boundedSize(
                    node.minHeight(-1), fillHeight ? areaHeight
                    : Math.min(areaHeight, node.prefHeight(-1)),
                    node.maxHeight(-1));
            childWidth = boundedSize(
                    node.minWidth(childHeight), fillWidth ? areaWidth
                    : Math.min(areaWidth, node.prefWidth(childHeight)),
                    node.maxWidth(childHeight));
        }

        result.set(childWidth, childHeight);
        return result;
    }

    /* utility method for computing the max of children's min or pref heights, taking into account baseline alignment */
    private double getMaxAreaHeight(List&lt;Node&gt; children, Callback&lt;Node,Insets&gt; childMargins,  double childWidths[], VPos valignment, boolean minimum) {
        final double singleChildWidth = childWidths == null ? -1 : childWidths.length == 1 ? childWidths[0] : Double.NaN;
        if (valignment == VPos.BASELINE) {
            double maxAbove = 0;
            double maxBelow = 0;
            for (int i = 0, maxPos = children.size(); i &lt; maxPos; i++) {
                final Node child = children.get(i);
                final double childWidth = Double.isNaN(singleChildWidth) ? childWidths[i] : singleChildWidth;
                Insets margin = childMargins.call(child);
                final double top = margin != null? snapSpaceY(margin.getTop()) : 0;
                final double bottom = margin != null? snapSpaceY(margin.getBottom()) : 0;
                final double baseline = child.getBaselineOffset();

                final double childHeight = minimum? snapSizeY(child.minHeight(childWidth)) : snapSizeY(child.prefHeight(childWidth));
                if (baseline == BASELINE_OFFSET_SAME_AS_HEIGHT) {
                    maxAbove = Math.max(maxAbove, childHeight + top);
                } else {
                    maxAbove = Math.max(maxAbove, baseline + top);
                    maxBelow = Math.max(maxBelow,
                            snapSpaceY(minimum?snapSizeY(child.minHeight(childWidth)) : snapSizeY(child.prefHeight(childWidth))) -
                            baseline + bottom);
                }
            }
            return maxAbove + maxBelow; //remind(aim): ceil this value?
        } else {
            double max = 0;
            for (int i = 0, maxPos = children.size(); i &lt; maxPos; i++) {
                final Node child = children.get(i);
                Insets margin = childMargins.call(child);
                final double childWidth = Double.isNaN(singleChildWidth) ? childWidths[i] : singleChildWidth;
                max = Math.max(max, minimum?
                    computeChildMinAreaHeight(child, -1, margin, childWidth) :
                        computeChildPrefAreaHeight(child, -1, margin, childWidth));
            }
            return max;
        }
    }

    /* utility method for computing the max of children's min or pref width, horizontal alignment is ignored for now */
    private double getMaxAreaWidth(List&lt;javafx.scene.Node&gt; children,
            Callback&lt;Node, Insets&gt; childMargins, double childHeights[], boolean fillHeight, boolean minimum) {
        final double singleChildHeight = childHeights == null ? -1 : childHeights.length == 1 ? childHeights[0] : Double.NaN;

        double max = 0;
        for (int i = 0, maxPos = children.size(); i &lt; maxPos; i++) {
            final Node child = children.get(i);
            final Insets margin = childMargins.call(child);
            final double childHeight = Double.isNaN(singleChildHeight) ? childHeights[i] : singleChildHeight;
            max = Math.max(max, minimum?
                computeChildMinAreaWidth(children.get(i), -1, margin, childHeight, fillHeight) :
                    computeChildPrefAreaWidth(child, -1, margin, childHeight, fillHeight));
        }
        return max;
    }

    /**
     * Utility method which positions the child within an area of this
     * region defined by {@code areaX}, {@code areaY}, {@code areaWidth} x {@code areaHeight},
     * with a baseline offset relative to that area.
     * &lt;p&gt;
     * This function does &lt;i&gt;not&lt;/i&gt; resize the node and uses the node's layout bounds
     * width and height to determine how it should be positioned within the area.
     * &lt;p&gt;
     * If the vertical alignment is {@code VPos.BASELINE} then it
     * will position the node so that its own baseline aligns with the passed in
     * {@code baselineOffset},  otherwise the baseline parameter is ignored.
     * &lt;p&gt;
     * If {@code snapToPixel} is {@code true} for this region, then the x/y position
     * values will be rounded to their nearest pixel boundaries.
     *
     * @param child the child being positioned within this region
     * @param areaX the horizontal offset of the layout area relative to this region
     * @param areaY the vertical offset of the layout area relative to this region
     * @param areaWidth  the width of the layout area
     * @param areaHeight the height of the layout area
     * @param areaBaselineOffset the baseline offset to be used if VPos is BASELINE
     * @param halignment the horizontal alignment for the child within the area
     * @param valignment the vertical alignment for the child within the area
     *
     */
    protected void positionInArea(Node child, double areaX, double areaY, double areaWidth, double areaHeight,
                               double areaBaselineOffset, HPos halignment, VPos valignment) {
        positionInArea(child, areaX, areaY, areaWidth, areaHeight, areaBaselineOffset,
                Insets.EMPTY, halignment, valignment, isSnapToPixel());
    }

    /**
     * Utility method which positions the child within an area of this
     * region defined by {@code areaX}, {@code areaY}, {@code areaWidth} x {@code areaHeight},
     * with a baseline offset relative to that area.
     * &lt;p&gt;
     * This function does &lt;i&gt;not&lt;/i&gt; resize the node and uses the node's layout bounds
     * width and height to determine how it should be positioned within the area.
     * &lt;p&gt;
     * If the vertical alignment is {@code VPos.BASELINE} then it
     * will position the node so that its own baseline aligns with the passed in
     * {@code baselineOffset},  otherwise the baseline parameter is ignored.
     * &lt;p&gt;
     * If {@code snapToPixel} is {@code true} for this region, then the x/y position
     * values will be rounded to their nearest pixel boundaries.
     * &lt;p&gt;
     * If {@code margin} is non-null, then that space will be allocated around the
     * child within the layout area.  margin may be null.
     *
     * @param child the child being positioned within this region
     * @param areaX the horizontal offset of the layout area relative to this region
     * @param areaY the vertical offset of the layout area relative to this region
     * @param areaWidth  the width of the layout area
     * @param areaHeight the height of the layout area
     * @param areaBaselineOffset the baseline offset to be used if VPos is BASELINE
     * @param margin the margin of space to be allocated around the child
     * @param halignment the horizontal alignment for the child within the area
     * @param valignment the vertical alignment for the child within the area
     * @param isSnapToPixel whether to snap size and position to pixels
     *
     * @since JavaFX 8.0
     */
    public static void positionInArea(Node child, double areaX, double areaY, double areaWidth, double areaHeight,
                               double areaBaselineOffset, Insets margin, HPos halignment, VPos valignment, boolean isSnapToPixel) {
        Insets childMargin = margin != null? margin : Insets.EMPTY;
        double snapScaleX = isSnapToPixel ? getSnapScaleX(child) : 1.0;
        double snapScaleY = isSnapToPixel ? getSnapScaleY(child) : 1.0;

        position(child, areaX, areaY, areaWidth, areaHeight, areaBaselineOffset,
                snapSpace(childMargin.getTop(), isSnapToPixel, snapScaleY),
                snapSpace(childMargin.getRight(), isSnapToPixel, snapScaleX),
                snapSpace(childMargin.getBottom(), isSnapToPixel, snapScaleY),
                snapSpace(childMargin.getLeft(), isSnapToPixel, snapScaleX),
                halignment, valignment, isSnapToPixel);
    }

    /**
     * Utility method which lays out the child within an area of this
     * region defined by {@code areaX}, {@code areaY}, {@code areaWidth} x {@code areaHeight},
     * with a baseline offset relative to that area.
     * &lt;p&gt;
     * If the child is resizable, this method will resize it to fill the specified
     * area unless the node's maximum size prevents it.  If the node's maximum
     * size preference is less than the area size, the maximum size will be used.
     * If node's maximum is greater than the area size, then the node will be
     * resized to fit within the area, unless its minimum size prevents it.
     * &lt;p&gt;
     * If the child has a non-null contentBias, then this method will use it when
     * resizing the child.  If the contentBias is horizontal, it will set its width
     * first to the area's width (up to the child's max width limit) and then pass
     * that value to compute the child's height.  If child's contentBias is vertical,
     * then it will set its height to the area height (up to child's max height limit)
     * and pass that height to compute the child's width.  If the child's contentBias
     * is null, then it's width and height have no dependencies on each other.
     * &lt;p&gt;
     * If the child is not resizable (Shape, Group, etc) then it will only be
     * positioned and not resized.
     * &lt;p&gt;
     * If the child's resulting size differs from the area's size (either
     * because it was not resizable or it's sizing preferences prevented it), then
     * this function will align the node relative to the area using horizontal and
     * vertical alignment values.
     * If valignment is {@code VPos.BASELINE} then the node's baseline will be aligned
     * with the area baseline offset parameter, otherwise the baseline parameter
     * is ignored.
     * &lt;p&gt;
     * If {@code snapToPixel} is {@code true} for this region, then the resulting x,y
     * values will be rounded to their nearest pixel boundaries and the
     * width/height values will be ceiled to the next pixel boundary.
     *
     * @param child the child being positioned within this region
     * @param areaX the horizontal offset of the layout area relative to this region
     * @param areaY the vertical offset of the layout area relative to this region
     * @param areaWidth  the width of the layout area
     * @param areaHeight the height of the layout area
     * @param areaBaselineOffset the baseline offset to be used if VPos is BASELINE
     * @param halignment the horizontal alignment for the child within the area
     * @param valignment the vertical alignment for the child within the area
     *
     */
    protected void layoutInArea(Node child, double areaX, double areaY,
                               double areaWidth, double areaHeight,
                               double areaBaselineOffset,
                               HPos halignment, VPos valignment) {
        layoutInArea(child, areaX, areaY, areaWidth, areaHeight, areaBaselineOffset,
                Insets.EMPTY, halignment, valignment);
    }

    /**
     * Utility method which lays out the child within an area of this
     * region defined by {@code areaX}, {@code areaY}, {@code areaWidth} x {@code areaHeight},
     * with a baseline offset relative to that area.
     * &lt;p&gt;
     * If the child is resizable, this method will resize it to fill the specified
     * area unless the node's maximum size prevents it.  If the node's maximum
     * size preference is less than the area size, the maximum size will be used.
     * If node's maximum is greater than the area size, then the node will be
     * resized to fit within the area, unless its minimum size prevents it.
     * &lt;p&gt;
     * If the child has a non-null contentBias, then this method will use it when
     * resizing the child.  If the contentBias is horizontal, it will set its width
     * first to the area's width (up to the child's max width limit) and then pass
     * that value to compute the child's height.  If child's contentBias is vertical,
     * then it will set its height to the area height (up to child's max height limit)
     * and pass that height to compute the child's width.  If the child's contentBias
     * is null, then it's width and height have no dependencies on each other.
     * &lt;p&gt;
     * If the child is not resizable (Shape, Group, etc) then it will only be
     * positioned and not resized.
     * &lt;p&gt;
     * If the child's resulting size differs from the area's size (either
     * because it was not resizable or it's sizing preferences prevented it), then
     * this function will align the node relative to the area using horizontal and
     * vertical alignment values.
     * If valignment is {@code VPos.BASELINE} then the node's baseline will be aligned
     * with the area baseline offset parameter, otherwise the baseline parameter
     * is ignored.
     * &lt;p&gt;
     * If {@code margin} is non-null, then that space will be allocated around the
     * child within the layout area.  margin may be null.
     * &lt;p&gt;
     * If {@code snapToPixel} is {@code true} for this region, then the resulting x,y
     * values will be rounded to their nearest pixel boundaries and the
     * width/height values will be ceiled to the next pixel boundary.
     *
     * @param child the child being positioned within this region
     * @param areaX the horizontal offset of the layout area relative to this region
     * @param areaY the vertical offset of the layout area relative to this region
     * @param areaWidth  the width of the layout area
     * @param areaHeight the height of the layout area
     * @param areaBaselineOffset the baseline offset to be used if VPos is BASELINE
     * @param margin the margin of space to be allocated around the child
     * @param halignment the horizontal alignment for the child within the area
     * @param valignment the vertical alignment for the child within the area
     */
    protected void layoutInArea(Node child, double areaX, double areaY,
                               double areaWidth, double areaHeight,
                               double areaBaselineOffset,
                               Insets margin,
                               HPos halignment, VPos valignment) {
        layoutInArea(child, areaX, areaY, areaWidth, areaHeight,
                areaBaselineOffset, margin, true, true, halignment, valignment);
    }

    /**
     * Utility method which lays out the child within an area of this
     * region defined by {@code areaX}, {@code areaY}, {@code areaWidth} x {@code areaHeight},
     * with a baseline offset relative to that area.
     * &lt;p&gt;
     * If the child is resizable, this method will use {@code fillWidth} and {@code fillHeight}
     * to determine whether to resize it to fill the area or keep the child at its
     * preferred dimension.  If fillWidth/fillHeight are true, then this method
     * will only resize the child up to its max size limits.  If the node's maximum
     * size preference is less than the area size, the maximum size will be used.
     * If node's maximum is greater than the area size, then the node will be
     * resized to fit within the area, unless its minimum size prevents it.
     * &lt;p&gt;
     * If the child has a non-null contentBias, then this method will use it when
     * resizing the child.  If the contentBias is horizontal, it will set its width
     * first and then pass that value to compute the child's height.  If child's
     * contentBias is vertical, then it will set its height first
     * and pass that value to compute the child's width.  If the child's contentBias
     * is null, then it's width and height have no dependencies on each other.
     * &lt;p&gt;
     * If the child is not resizable (Shape, Group, etc) then it will only be
     * positioned and not resized.
     * &lt;p&gt;
     * If the child's resulting size differs from the area's size (either
     * because it was not resizable or it's sizing preferences prevented it), then
     * this function will align the node relative to the area using horizontal and
     * vertical alignment values.
     * If valignment is {@code VPos.BASELINE} then the node's baseline will be aligned
     * with the area baseline offset parameter, otherwise the baseline parameter
     * is ignored.
     * &lt;p&gt;
     * If {@code margin} is non-null, then that space will be allocated around the
     * child within the layout area.  margin may be null.
     * &lt;p&gt;
     * If {@code snapToPixel} is {@code true} for this region, then the resulting x,y
     * values will be rounded to their nearest pixel boundaries and the
     * width/height values will be ceiled to the next pixel boundary.
     *
     * @param child the child being positioned within this region
     * @param areaX the horizontal offset of the layout area relative to this region
     * @param areaY the vertical offset of the layout area relative to this region
     * @param areaWidth  the width of the layout area
     * @param areaHeight the height of the layout area
     * @param areaBaselineOffset the baseline offset to be used if VPos is BASELINE
     * @param margin the margin of space to be allocated around the child
     * @param fillWidth whether or not the child should be resized to fill the area width or kept to its preferred width
     * @param fillHeight whether or not the child should e resized to fill the area height or kept to its preferred height
     * @param halignment the horizontal alignment for the child within the area
     * @param valignment the vertical alignment for the child within the area
     */
    protected void layoutInArea(Node child, double areaX, double areaY,
                               double areaWidth, double areaHeight,
                               double areaBaselineOffset,
                               Insets margin, boolean fillWidth, boolean fillHeight,
                               HPos halignment, VPos valignment) {
        layoutInArea(child, areaX, areaY, areaWidth, areaHeight, areaBaselineOffset, margin, fillWidth, fillHeight, halignment, valignment, isSnapToPixel());
    }

    /**
     * Utility method which lays out the child within an area of it's
     * parent defined by {@code areaX}, {@code areaY}, {@code areaWidth} x {@code areaHeight},
     * with a baseline offset relative to that area.
     * &lt;p&gt;
     * If the child is resizable, this method will use {@code fillWidth} and {@code fillHeight}
     * to determine whether to resize it to fill the area or keep the child at its
     * preferred dimension.  If fillWidth/fillHeight are true, then this method
     * will only resize the child up to its max size limits.  If the node's maximum
     * size preference is less than the area size, the maximum size will be used.
     * If node's maximum is greater than the area size, then the node will be
     * resized to fit within the area, unless its minimum size prevents it.
     * &lt;p&gt;
     * If the child has a non-null contentBias, then this method will use it when
     * resizing the child.  If the contentBias is horizontal, it will set its width
     * first and then pass that value to compute the child's height.  If child's
     * contentBias is vertical, then it will set its height first
     * and pass that value to compute the child's width.  If the child's contentBias
     * is null, then it's width and height have no dependencies on each other.
     * &lt;p&gt;
     * If the child is not resizable (Shape, Group, etc) then it will only be
     * positioned and not resized.
     * &lt;p&gt;
     * If the child's resulting size differs from the area's size (either
     * because it was not resizable or it's sizing preferences prevented it), then
     * this function will align the node relative to the area using horizontal and
     * vertical alignment values.
     * If valignment is {@code VPos.BASELINE} then the node's baseline will be aligned
     * with the area baseline offset parameter, otherwise the baseline parameter
     * is ignored.
     * &lt;p&gt;
     * If {@code margin} is non-null, then that space will be allocated around the
     * child within the layout area.  margin may be null.
     * &lt;p&gt;
     * If {@code snapToPixel} is {@code true} for this region, then the resulting x,y
     * values will be rounded to their nearest pixel boundaries and the
     * width/height values will be ceiled to the next pixel boundary.
     *
     * @param child the child being positioned within this region
     * @param areaX the horizontal offset of the layout area relative to this region
     * @param areaY the vertical offset of the layout area relative to this region
     * @param areaWidth  the width of the layout area
     * @param areaHeight the height of the layout area
     * @param areaBaselineOffset the baseline offset to be used if VPos is BASELINE
     * @param margin the margin of space to be allocated around the child
     * @param fillWidth whether or not the child should be resized to fill the area width or kept to its preferred width
     * @param fillHeight whether or not the child should e resized to fill the area height or kept to its preferred height
     * @param halignment the horizontal alignment for the child within the area
     * @param valignment the vertical alignment for the child within the area
     * @param isSnapToPixel whether to snap size and position to pixels
     * @since JavaFX 8.0
     */
    public static void layoutInArea(Node child, double areaX, double areaY,
                               double areaWidth, double areaHeight,
                               double areaBaselineOffset,
                               Insets margin, boolean fillWidth, boolean fillHeight,
                               HPos halignment, VPos valignment, boolean isSnapToPixel) {

        Insets childMargin = margin != null ? margin : Insets.EMPTY;
        double snapScaleX = isSnapToPixel ? getSnapScaleX(child) : 1.0;
        double snapScaleY = isSnapToPixel ? getSnapScaleY(child) : 1.0;

        double top = snapSpace(childMargin.getTop(), isSnapToPixel, snapScaleY);
        double bottom = snapSpace(childMargin.getBottom(), isSnapToPixel, snapScaleY);
        double left = snapSpace(childMargin.getLeft(), isSnapToPixel, snapScaleX);
        double right = snapSpace(childMargin.getRight(), isSnapToPixel, snapScaleX);

        if (valignment == VPos.BASELINE) {
            double bo = child.getBaselineOffset();
            if (bo == BASELINE_OFFSET_SAME_AS_HEIGHT) {
                if (child.isResizable()) {
                    // Everything below the baseline is like an &quot;inset&quot;. The Node with BASELINE_OFFSET_SAME_AS_HEIGHT cannot
                    // be resized to this area
                    bottom += snapSpace(areaHeight - areaBaselineOffset, isSnapToPixel, snapScaleY);
                } else {
                    top = snapSpace(areaBaselineOffset - child.getLayoutBounds().getHeight(), isSnapToPixel, snapScaleY);
                }
            } else {
                top = snapSpace(areaBaselineOffset - bo, isSnapToPixel, snapScaleY);
            }
        }


        if (child.isResizable()) {
            Vec2d size = boundedNodeSizeWithBias(child, areaWidth - left - right, areaHeight - top - bottom,
                    fillWidth, fillHeight, TEMP_VEC2D);
            child.resize(snapSize(size.x, isSnapToPixel, snapScaleX),
                         snapSize(size.y, isSnapToPixel, snapScaleX));
        }
        position(child, areaX, areaY, areaWidth, areaHeight, areaBaselineOffset,
                top, right, bottom, left, halignment, valignment, isSnapToPixel);
    }

    private static void position(Node child, double areaX, double areaY, double areaWidth, double areaHeight,
                          double areaBaselineOffset,
                          double topMargin, double rightMargin, double bottomMargin, double leftMargin,
                          HPos hpos, VPos vpos, boolean isSnapToPixel) {
        final double xoffset = leftMargin + computeXOffset(areaWidth - leftMargin - rightMargin,
                                                     child.getLayoutBounds().getWidth(), hpos);
        final double yoffset;
        if (vpos == VPos.BASELINE) {
            double bo = child.getBaselineOffset();
            if (bo == BASELINE_OFFSET_SAME_AS_HEIGHT) {
                // We already know the layout bounds at this stage, so we can use them
                yoffset = areaBaselineOffset - child.getLayoutBounds().getHeight();
            } else {
                yoffset = areaBaselineOffset - bo;
            }
        } else {
            yoffset = topMargin + computeYOffset(areaHeight - topMargin - bottomMargin,
                                         child.getLayoutBounds().getHeight(), vpos);
        }
        double x = areaX + xoffset;
        double y = areaY + yoffset;
        if (isSnapToPixel) {
            x = snapPosition(x, true, getSnapScaleX(child));
            y = snapPosition(y, true, getSnapScaleY(child));
        }

        child.relocate(x,y);
    }

     /**************************************************************************
     *                                                                         *
     * PG Implementation                                                       *
     *                                                                         *
     **************************************************************************/

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        // TODO I think we have a bug, where if you create a Region with an Image that hasn't
        // been loaded, we have no listeners on that image so as to cause a pulse &amp; repaint
        // to happen once the image is loaded. We just assume the image has been loaded
        // (since when the image is created using new Image(url) or CSS it happens eagerly).
        if (_shape != null) NodeHelper.syncPeer(_shape);
        NGRegion pg = NodeHelper.getPeer(this);

        if (!cornersValid) {
            validateCorners();
        }

        final boolean sizeChanged = NodeHelper.isDirty(this, DirtyBits.NODE_GEOMETRY);
        if (sizeChanged) {
            pg.setSize((float)getWidth(), (float)getHeight());
        }

        // NOTE: The order here is very important. There is logic in NGRegion which determines
        // whether we can cache an image representing this region, and for this to work correctly,
        // the shape must be specified before the background which is before the border.
        final boolean shapeChanged = NodeHelper.isDirty(this, DirtyBits.REGION_SHAPE);
        if (shapeChanged) {
            pg.updateShape(_shape, isScaleShape(), isCenterShape(), isCacheShape());
        }

        // The normalized corners can always be updated since they require no
        // processing at the NG layer.
        pg.updateFillCorners(normalizedFillCorners);
        final boolean backgroundChanged = NodeHelper.isDirty(this, DirtyBits.SHAPE_FILL);
        final Background bg = getBackground();
        if (backgroundChanged) {
            pg.updateBackground(bg);
        }

        // This will be true if an image that makes up the background or border of this
        // region has changed, such that we need to redraw the region.
        if (NodeHelper.isDirty(this, DirtyBits.NODE_CONTENTS)) {
            pg.imagesUpdated();
        }

        // The normalized corners can always be updated since they require no
        // processing at the NG layer.
        pg.updateStrokeCorners(normalizedStrokeCorners);
        if (NodeHelper.isDirty(this, DirtyBits.SHAPE_STROKE)) {
            pg.updateBorder(getBorder());
        }

        // TODO given the note above, this *must* be called when an image which makes up the
        // background images and border images changes (is loaded) if it was being loaded asynchronously
        // Also note, one day we can add support for automatic opaque insets determination for border images.
        // However right now it is impractical because the image pixel format is almost undoubtedly going
        // to have alpha, and so without inspecting the source image's actual pixels for the filled center
        // we can't automatically determine whether the interior is filled.
        if (sizeChanged || backgroundChanged || shapeChanged) {
            // These are the opaque insets, as specified by the developer in code or CSS. If null,
            // then we must compute the opaque insets. If not null, then we will still compute the
            // opaque insets and combine them with these insets, as appropriate. We do ignore these
            // developer specified insets in cases where we know without a doubt that the developer
            // gave us bad data.
            final Insets i = getOpaqueInsets();

            // If the background is determined by a shape, then we don't attempt to calculate the
            // opaque insets. If the developer specified opaque insets, we will use them, otherwise
            // we will make sure the opaque insets are cleared
            if (_shape != null) {
                if (i != null) {
                    pg.setOpaqueInsets((float) i.getTop(), (float) i.getRight(),
                                       (float) i.getBottom(), (float) i.getLeft());
                } else {
                    pg.setOpaqueInsets(Float.NaN, Float.NaN, Float.NaN, Float.NaN);
                }
            } else {
                // This is a rectangle (not shape) region. The opaque insets must be calculated,
                // even if the developer has supplied their own opaque insets. The first (and cheapest)
                // check is whether the region has any backgrounds at all. If not, then
                // we will ignore the developer supplied insets because they are clearly wrong.
                if (bg == null || bg.isEmpty()) {
                    pg.setOpaqueInsets(Float.NaN, Float.NaN, Float.NaN, Float.NaN);
                } else {
                    // There is a background, so it is conceivable that there are
                    // opaque insets. From this point on, we have to honor the developer's supplied
                    // insets, only expanding them if we know for certain the opaque insets are
                    // bigger than what was supplied by the developer. Start by defining our initial
                    // values for top, right, bottom, and left. If the developer supplied us
                    // insets, use those. Otherwise initialize to NaN. Note that the developer may
                    // also have given us NaN values (so we'd have to check for these anyway). We use
                    // NaN to mean &quot;not defined&quot;.
                    final double[] trbl = new double[4];
                    bg.computeOpaqueInsets(getWidth(), getHeight(), trbl);

                    if (i != null) {
                        trbl[0] = Double.isNaN(trbl[0]) ? i.getTop() : Double.isNaN(i.getTop()) ? trbl[0] : Math.min(trbl[0], i.getTop());
                        trbl[1] = Double.isNaN(trbl[1]) ? i.getRight() : Double.isNaN(i.getRight()) ? trbl[1] : Math.min(trbl[1], i.getRight());
                        trbl[2] = Double.isNaN(trbl[2]) ? i.getBottom() : Double.isNaN(i.getBottom()) ? trbl[2] : Math.min(trbl[2], i.getBottom());
                        trbl[3] = Double.isNaN(trbl[3]) ? i.getLeft() : Double.isNaN(i.getLeft()) ? trbl[3] : Math.min(trbl[3], i.getLeft());
                    }

                    // Now set the insets onto the peer. Passing NaN here is perfectly
                    // acceptable (even encouraged, to mean &quot;unknown&quot; or &quot;disabled&quot;).
                    pg.setOpaqueInsets((float) trbl[0], (float) trbl[1], (float) trbl[2], (float) trbl[3]);
                }
            }
        }
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private NGNode doCreatePeer() {
        return new NGRegion();
    }

    /**
     * Transform x, y in local Region coordinates to local coordinates of scaled/centered shape and
     * check if the shape contains the coordinates.
     * The transformations here are basically an inversion of transformations being done in NGShape#resizeShape.
     */
    private boolean shapeContains(com.sun.javafx.geom.Shape shape,
            final double x, final double y,
            double topOffset, double rightOffset, double bottomOffset, double leftOffset) {
        double resX = x;
        double resY = y;
        // The bounds of the shape, before any centering / scaling takes place
        final RectBounds bounds = shape.getBounds();
        if (isScaleShape()) {
            // Modify the transform to scale the shape so that it will fit
            // within the insets.
            resX -= leftOffset;
            resY -= topOffset;

            //denominator represents the width and height of the box within which the new shape must fit.
            resX *= bounds.getWidth() / (getWidth() - leftOffset - rightOffset);
            resY *= bounds.getHeight() / (getHeight() - topOffset - bottomOffset);

            // If we also need to center it, we need to adjust the transform so as to place
            // the shape in the center of the bounds
            if (isCenterShape()) {
                resX += bounds.getMinX();
                resY += bounds.getMinY();
            }
        } else if (isCenterShape()) {
            // We are only centering. In this case, what we want is for the
            // original shape to be centered. If there are offsets (insets)
            // then we must pre-scale about the center to account for it.

            double boundsWidth = bounds.getWidth();
            double boundsHeight = bounds.getHeight();

            double scaleFactorX = boundsWidth / (boundsWidth - leftOffset - rightOffset);
            double scaleFactorY = boundsHeight / (boundsHeight - topOffset - bottomOffset);

            //This is equivalent to:
            // translate(bounds.getMinX(), bounds.getMinY())
            // scale(scaleFactorX, scaleFactorY)
            // translate(-bounds.getMinX(), -bounds.getMinY())
            // translate(-leftOffset - (getWidth() - boundsWidth)/2 + bounds.getMinX(),
            //                            -topOffset - (getHeight() - boundsHeight)/2 + bounds.getMinY());
            // which is an inversion of an transformation done to the shape
            // This gives us
            //
            //resX = resX * scaleFactorX - scaleFactorX * bounds.getMinX() - scaleFactorX * (leftOffset + (getWidth() - boundsWidth) / 2 - bounds.getMinX()) + bounds.getMinX();
            //resY = resY * scaleFactorY - scaleFactorY * bounds.getMinY() - scaleFactorY * (topOffset + (getHeight() - boundsHeight) / 2 - bounds.getMinY()) + bounds.getMinY();
            //
            // which can further reduced to

            resX = scaleFactorX * (resX -(leftOffset + (getWidth() - boundsWidth) / 2)) + bounds.getMinX();
            resY = scaleFactorY * (resY -(topOffset + (getHeight() - boundsHeight) / 2)) + bounds.getMinY();

        } else if (topOffset != 0 || rightOffset != 0 || bottomOffset != 0 || leftOffset != 0) {
            // We are neither centering nor scaling, but we still have to resize the
            // shape because we have to fit within the bounds defined by the offsets
            double scaleFactorX = bounds.getWidth() / (bounds.getWidth() - leftOffset - rightOffset);
            double scaleFactorY = bounds.getHeight() / (bounds.getHeight() - topOffset - bottomOffset);

            // This is equivalent to:
            // translate(bounds.getMinX(), bounds.getMinY())
            // scale(scaleFactorX, scaleFactorY)
            // translate(-bounds.getMinX(), -bounds.getMinY())
            // translate(-leftOffset, -topOffset)
            //
            // which is an inversion of an transformation done to the shape
            // This gives us
            //
            //resX = resX * scaleFactorX - scaleFactorX * leftOffset - scaleFactorX * bounds.getMinX() + bounds.getMinX();
            //resY = resY * scaleFactorY - scaleFactorY * topOffset - scaleFactorY * bounds.getMinY() + bounds.getMinY();
            //
            // which can be further reduceD to
<A NAME="33"></A>            resX = scaleFactorX * (resX - leftOffset - bounds.getMinX()) + bounds.getMinX();
            resY = scaleFactorY * (resY - topOffset - bounds.getMinY()) + bounds.getMinY();

        <FONT color="#736aff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#33',2,'match31-top.html#33',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
        return shape.contains((float)resX, (float)resY);
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean d</B></FONT>oComputeContains(double localX, double localY) {
        // NOTE: This method only gets called if a quick check of bounds has already
        // occurred, so there is no need to test against bound again. We know that the
        // point (localX, localY) falls within the bounds of this node, now we need
        // to determine if it falls within the geometry of this node.
        // Also note that because Region defaults pickOnBounds to true, this code is
        // not usually executed. It will only be executed if pickOnBounds is set to false.

        final double x2 = getWidth();
        final double y2 = getHeight();

        final Background background = getBackground();
        // First check the shape. Shape could be impacted by scaleShape &amp; positionShape properties.
        if (_shape != null) {
            if (background != null &amp;&amp; !background.getFills().isEmpty()) {
                final List&lt;BackgroundFill&gt; fills = background.getFills();
                double topO = Double.MAX_VALUE;
                double leftO = Double.MAX_VALUE;
                double bottomO = Double.MAX_VALUE;
                double rightO = Double.MAX_VALUE;
                for (int i = 0, max = fills.size(); i &lt; max; i++) {
                    BackgroundFill bf = fills.get(0);
                    topO = Math.min(topO, bf.getInsets().getTop());
                    leftO = Math.min(leftO, bf.getInsets().getLeft());
                    bottomO = Math.min(bottomO, bf.getInsets().getBottom());
                    rightO = Math.min(rightO, bf.getInsets().getRight());
                }
                return shapeContains(ShapeHelper.configShape(_shape), localX, localY, topO, leftO, bottomO, rightO);
            }
            return false;
        }

        // OK, there was no background shape, so I'm going to work on the principle of
        // nested rounded rectangles. We'll start by checking the backgrounds. The
        // first background which passes the test is good enough for us!
        if (background != null) {
            final List&lt;BackgroundFill&gt; fills = background.getFills();
            for (int i = 0, max = fills.size(); i &lt; max; i++) {
                final BackgroundFill bgFill = fills.get(i);
                if (contains(localX, localY, 0, 0, x2, y2, bgFill.getInsets(), getNormalizedFillCorner(i))) {
                    return true;
                }
            }
        }

        // If we are here then either there were no background fills or there were no background
        // fills which contained the point, and the region is not defined by a shape.
        final Border border = getBorder();
        if (border != null) {
            // Check all the stroke borders first. If the pick occurs on any stroke border
            // then we consider the contains test to have passed. Semantically we will treat a Region
            // with a border as if it were a rectangle with a stroke but no fill.
            final List&lt;BorderStroke&gt; strokes = border.getStrokes();
            for (int i=0, max=strokes.size(); i&lt;max; i++) {
                final BorderStroke strokeBorder = strokes.get(i);
                if (contains(localX, localY, 0, 0, x2, y2, strokeBorder.getWidths(), false, strokeBorder.getInsets(),
                             getNormalizedStrokeCorner(i))) {
                    return true;
                }
            }

            // Check the image borders. We treat the image border as though it is opaque.
            final List&lt;BorderImage&gt; images = border.getImages();
            for (int i = 0, max = images.size(); i &lt; max; i++) {
                final BorderImage borderImage = images.get(i);
                if (contains(localX, localY, 0, 0, x2, y2, borderImage.getWidths(), borderImage.isFilled(),
                             borderImage.getInsets(), CornerRadii.EMPTY)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Basically we will perform two contains tests. For a point to be on the stroke, it must
     * be within the outermost edge of the stroke, but outside the innermost edge of the stroke.
     * Unless it is filled, in which case it is really just a normal contains test.
     *
     * @param px        The x position of the point to test
     * @param py        The y position of the point to test
     * @param x1        The x1 position of the bounds to test
     * @param y1        The y1 position of the bounds to test
     * @param x2        The x2 position of the bounds to test
     * @param y2        The y2 position of the bounds to test
     * @param widths    The widths of the stroke on each side
     * @param filled    Whether the area is filled or is just stroked
     * @param insets    The insets to apply to (x1,y1)-(x2,y2) to get the final bounds to test
     * @param rad       The corner radii to test with. Must not be null.
     * @param maxRadius The maximum possible radius value
     * @return True if (px, py) is within the stroke, taking into account insets and corner radii.
     */
    private boolean contains(final double px, final double py,
                             final double x1, final double y1, final double x2, final double y2,
                             BorderWidths widths, boolean filled,
                             final Insets insets, final CornerRadii rad) {
        if (filled) {
            if (contains(px, py, x1, y1, x2, y2, insets, rad)) {
                return true;
            }
        } else {
            boolean insideOuterEdge = contains(px, py, x1, y1, x2, y2, insets, rad);
            if (insideOuterEdge) {
                boolean outsideInnerEdge = !contains(px, py,
                    x1 + (widths.isLeftAsPercentage() ? getWidth() * widths.getLeft() : widths.getLeft()),
                    y1 + (widths.isTopAsPercentage() ? getHeight() * widths.getTop() : widths.getTop()),
                    x2 - (widths.isRightAsPercentage() ? getWidth() * widths.getRight() : widths.getRight()),
                    y2 - (widths.isBottomAsPercentage() ? getHeight() * widths.getBottom() : widths.getBottom()),
                    insets, rad);
                if (outsideInnerEdge) return true;
            }
        }
        return false;
    }

    /**
     * Determines whether the point (px, py) is contained within the the bounds (x1, y1)-(x2, y2),
     * after taking into account the insets and the corner radii.
     *
     * @param px        The x position of the point to test
     * @param py        The y position of the point to test
     * @param x1        The x1 position of the bounds to test
     * @param y1        The y1 position of the bounds to test
     * @param x2        The x2 position of the bounds to test
     * @param y2        The y2 position of the bounds to test
     * @param insets    The insets to apply to (x1,y1)-(x2,y2) to get the final bounds to test
     * @param rad       The corner radii to test with. Must not be null.
     * @param maxRadius The maximum possible radius value
     * @return True if (px, py) is within the bounds, taking into account insets and corner radii.
     */
    private boolean contains(final double px, final double py,
                             final double x1, final double y1, final double x2, final double y2,
                             final Insets insets, CornerRadii rad) {
        // These four values are the x0, y0, x1, y1 bounding box after
        // having taken into account the insets of this particular
        // background fill.
        final double rrx0 = x1 + insets.getLeft();
        final double rry0 = y1 + insets.getTop();
        final double rrx1 = x2 - insets.getRight();
        final double rry1 = y2 - insets.getBottom();

//        assert rad.hasPercentBasedRadii == false;

        // Check for trivial rejection - point is inside bounding rectangle
        if (px &gt;= rrx0 &amp;&amp; py &gt;= rry0 &amp;&amp; px &lt;= rrx1 &amp;&amp; py &lt;= rry1) {
            // The point was within the index bounding box. Now we need to analyze the
            // corner radii to see if the point lies within the corners or not. If the
            // point is within a corner then we reject this one.
            final double tlhr = rad.getTopLeftHorizontalRadius();
            if (rad.isUniform() &amp;&amp; tlhr == 0) {
                // This is a simple square! Since we know the point is already within
                // the insets of this fill, we can simply return true.
                return true;
            } else {
                final double tlvr = rad.getTopLeftVerticalRadius();
                final double trhr = rad.getTopRightHorizontalRadius();
                final double trvr = rad.getTopRightVerticalRadius();
                final double blhr = rad.getBottomLeftHorizontalRadius();
                final double blvr = rad.getBottomLeftVerticalRadius();
                final double brhr = rad.getBottomRightHorizontalRadius();
                final double brvr = rad.getBottomRightVerticalRadius();

                // The four corners can each be described as a quarter of an ellipse
                double centerX, centerY, a, b;

                if (px &lt;= rrx0 + tlhr &amp;&amp; py &lt;= rry0 + tlvr) {
                    // Point is in the top left corner
                    centerX = rrx0 + tlhr;
                    centerY = rry0 + tlvr;
                    a = tlhr;
                    b = tlvr;
                } else if (px &gt;= rrx1 - trhr &amp;&amp; py &lt;= rry0 + trvr) {
                    // Point is in the top right corner
                    centerX = rrx1 - trhr;
                    centerY = rry0 + trvr;
                    a = trhr;
                    b = trvr;
                } else if (px &gt;= rrx1 - brhr &amp;&amp; py &gt;= rry1 - brvr) {
                    // Point is in the bottom right corner
                    centerX = rrx1 - brhr;
                    centerY = rry1 - brvr;
                    a = brhr;
                    b = brvr;
                } else if (px &lt;= rrx0 + blhr &amp;&amp; py &gt;= rry1 - blvr) {
                    // Point is in the bottom left corner
                    centerX = rrx0 + blhr;
                    centerY = rry1 - blvr;
                    a = blhr;
                    b = blvr;
                } else {
                    // The point must have been in the solid body someplace
                    return true;
                }

                double x = px - centerX;
                double y = py - centerY;
                double result = ((x*x)/(a*a) + (y*y)/(b*b));
                // The .0000001 is fudge to help in cases where double arithmetic isn't quite right
                if (result - .0000001 &lt;= 1) return true;
            }
        }
        return false;
    }

    /*
     * The normalized corner radii are unmodifiable List objects shared between
     * the NG layer and the FX layer.  As cached shadow copies of the objects
     * in the BackgroundFill and BorderStroke objects they should be considered
     * read-only and will only be updated by replacing the original objects
     * when validation is needed.
     */
    private boolean cornersValid; // = false
    private List&lt;CornerRadii&gt; normalizedFillCorners; // = null
    private List&lt;CornerRadii&gt; normalizedStrokeCorners; // = null

    /**
     * Returns the normalized absolute radii for the indicated BackgroundFill,
     * taking the current size of the region into account to eliminate any
     * percentage-based measurements and to scale the radii to prevent
     * overflowing the width or height.
     *
     * @param i the index of the BackgroundFill whose radii will be normalized.
     * @return the normalized (non-percentage, non-overflowing) radii
     */
    private CornerRadii getNormalizedFillCorner(int i) {
        if (!cornersValid) {
            validateCorners();
        }
        return (normalizedFillCorners == null
                ? getBackground().getFills().get(i).getRadii()
                : normalizedFillCorners.get(i));
    }

    /**
     * Returns the normalized absolute radii for the indicated BorderStroke,
     * taking the current size of the region into account to eliminate any
     * percentage-based measurements and to scale the radii to prevent
     * overflowing the width or height.
     *
     * @param i the index of the BorderStroke whose radii will be normalized.
     * @return the normalized (non-percentage, non-overflowing) radii
     */
    private CornerRadii getNormalizedStrokeCorner(int i) {
        if (!cornersValid) {
            validateCorners();
        }
        return (normalizedStrokeCorners == null
                ? getBorder().getStrokes().get(i).getRadii()
                : normalizedStrokeCorners.get(i));
    }

    /**
     * This method validates all CornerRadii objects in both the set of
     * BackgroundFills and BorderStrokes and saves the normalized values
     * into the private fields above.
     */
    private void validateCorners() {
        final double width = getWidth();
        final double height = getHeight();
        List&lt;CornerRadii&gt; newFillCorners = null;
        List&lt;CornerRadii&gt; newStrokeCorners = null;
        final Background background = getBackground();
        final List&lt;BackgroundFill&gt; fills = background == null ? Collections.EMPTY_LIST : background.getFills();
        for (int i = 0; i &lt; fills.size(); i++) {
            final BackgroundFill fill = fills.get(i);
            final CornerRadii origRadii = fill.getRadii();
            final Insets origInsets = fill.getInsets();
            final CornerRadii newRadii = normalize(origRadii, origInsets, width, height);
            if (origRadii != newRadii) {
                if (newFillCorners == null) {
                    newFillCorners = Arrays.asList(new CornerRadii[fills.size()]);
                }
                newFillCorners.set(i, newRadii);
            }
        }
        final Border border = getBorder();
        final List&lt;BorderStroke&gt; strokes = (border == null ? Collections.EMPTY_LIST : border.getStrokes());
        for (int i = 0; i &lt; strokes.size(); i++) {
            final BorderStroke stroke = strokes.get(i);
            final CornerRadii origRadii = stroke.getRadii();
            final Insets origInsets = stroke.getInsets();
            final CornerRadii newRadii = normalize(origRadii, origInsets, width, height);
            if (origRadii != newRadii) {
                if (newStrokeCorners == null) {
                    newStrokeCorners = Arrays.asList(new CornerRadii[strokes.size()]);
                }
                newStrokeCorners.set(i, newRadii);
            }
        }
        if (newFillCorners != null) {
            for (int i = 0; i &lt; fills.size(); i++) {
                if (newFillCorners.get(i) == null) {
                    newFillCorners.set(i, fills.get(i).getRadii());
                }
            }
            newFillCorners = Collections.unmodifiableList(newFillCorners);
        }
        if (newStrokeCorners != null) {
            for (int i = 0; i &lt; strokes.size(); i++) {
                if (newStrokeCorners.get(i) == null) {
                    newStrokeCorners.set(i, strokes.get(i).getRadii());
                }
            }
            newStrokeCorners = Collections.unmodifiableList(newStrokeCorners);
        }
        normalizedFillCorners = newFillCorners;
        normalizedStrokeCorners = newStrokeCorners;
        cornersValid = true;
    }

    /**
     * Return a version of the radii that is not percentage based and is scaled to
     * fit the indicated inset rectangle without overflow.
     * This method may return the original CornerRadii if none of the radii
     * values in the given object are percentages or require scaling.
     *
     * @param radii    The radii.
     * @param insets   The insets for the associated background or stroke.
     * @param width    The width of the region before insets are applied.
     * @param height   The height of the region before insets are applied.
     * @return Normalized radii.
     */
    private static CornerRadii normalize(CornerRadii radii, Insets insets, double width, double height) {
        width  -= insets.getLeft() + insets.getRight();
        height -= insets.getTop() + insets.getBottom();
        if (width &lt;= 0 || height &lt;= 0) return CornerRadii.EMPTY;
        double tlvr = radii.getTopLeftVerticalRadius();
        double tlhr = radii.getTopLeftHorizontalRadius();
        double trvr = radii.getTopRightVerticalRadius();
        double trhr = radii.getTopRightHorizontalRadius();
        double brvr = radii.getBottomRightVerticalRadius();
        double brhr = radii.getBottomRightHorizontalRadius();
        double blvr = radii.getBottomLeftVerticalRadius();
        double blhr = radii.getBottomLeftHorizontalRadius();
        if (radii.hasPercentBasedRadii) {
            if (radii.isTopLeftVerticalRadiusAsPercentage())       tlvr *= height;
            if (radii.isTopLeftHorizontalRadiusAsPercentage())     tlhr *= width;
            if (radii.isTopRightVerticalRadiusAsPercentage())      trvr *= height;
            if (radii.isTopRightHorizontalRadiusAsPercentage())    trhr *= width;
            if (radii.isBottomRightVerticalRadiusAsPercentage())   brvr *= height;
            if (radii.isBottomRightHorizontalRadiusAsPercentage()) brhr *= width;
            if (radii.isBottomLeftVerticalRadiusAsPercentage())    blvr *= height;
            if (radii.isBottomLeftHorizontalRadiusAsPercentage())  blhr *= width;
        }
        double scale = 1.0;
        if (tlhr + trhr &gt; width)  { scale = Math.min(scale, width  / (tlhr + trhr)); }
        if (blhr + brhr &gt; width)  { scale = Math.min(scale, width  / (blhr + brhr)); }
        if (tlvr + blvr &gt; height) { scale = Math.min(scale, height / (tlvr + blvr)); }
        if (trvr + brvr &gt; height) { scale = Math.min(scale, height / (trvr + brvr)); }
        if (scale &lt; 1.0) {
            tlvr *= scale;  tlhr *= scale;
            trvr *= scale;  trhr *= scale;
            brvr *= scale;  brhr *= scale;
            blvr *= scale;  blhr *= scale;
        }
        if (radii.hasPercentBasedRadii || scale &lt; 1.0) {
            return new CornerRadii(tlhr,  tlvr,  trvr,  trhr,  brhr,  brvr,  blvr,  blhr,
                                   false, false, false, false, false, false, false, false);
        }
        return radii;
    }

    /**
     * Some skins relying on this
     *
     * Note: This method MUST only be called via its accessor method.
     */
    private void doPickNodeLocal(PickRay pickRay, PickResultChooser result) {
         double boundsDistance = NodeHelper.intersectsBounds(this, pickRay);

        if (!Double.isNaN(boundsDistance) &amp;&amp; ParentHelper.pickChildrenNode(this, pickRay, result)) {
            NodeHelper.intersects(this, pickRay, result);
        }
    }

    private Bounds boundingBox;

    /**
     * The layout bounds of this region: {@code 0, 0  width x height}
     */
    private Bounds doComputeLayoutBounds() {
        if (boundingBox == null) {
            // we reuse the bounding box if the width and height haven't changed.
            boundingBox = new BoundingBox(0, 0, 0, getWidth(), getHeight(), 0);
        }
        return boundingBox;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doNotifyLayoutBoundsChanged() {
        // override Node's default behavior of having a geometric bounds change
        // trigger a change in layoutBounds. For Resizable nodes, layoutBounds
        // is unrelated to geometric bounds.
    }

    private BaseBounds computeShapeBounds(BaseBounds bounds)
    {
        com.sun.javafx.geom.Shape s = ShapeHelper.configShape(_shape);

        float[] bbox = {
                Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY,
                Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY,
        };

        Background bg = getBackground();
        if (bg != null) {
            final RectBounds sBounds = s.getBounds();
            final Insets bgOutsets = bg.getOutsets();
            bbox[0] = sBounds.getMinX() - (float) bgOutsets.getLeft();
            bbox[1] = sBounds.getMinY() - (float) bgOutsets.getTop();
            bbox[2] = sBounds.getMaxX() + (float) bgOutsets.getBottom();
            bbox[3] = sBounds.getMaxY() + (float) bgOutsets.getRight();
        }

        final Border b = getBorder();
        if (b != null &amp;&amp; b.getStrokes().size() &gt; 0) {
            for (BorderStroke bs : b.getStrokes()) {
                // This order of border strokes is used in NGRegion.renderAsShape/setBorderStyle
                BorderStrokeStyle bss = bs.getTopStyle() != null ? bs.getTopStyle() :
                        bs.getLeftStyle() != null ? bs.getLeftStyle() :
                                bs.getBottomStyle() != null ? bs.getBottomStyle() :
                                        bs.getRightStyle() != null ? bs.getRightStyle() : null;

                if (bss == null || bss == BorderStrokeStyle.NONE) {
                    continue;
                }

                final StrokeType type = bss.getType();
                double sw = Math.max(bs.getWidths().top, 0d);
                StrokeLineCap cap = bss.getLineCap();
                StrokeLineJoin join = bss.getLineJoin();
                float miterlimit = (float) Math.max(bss.getMiterLimit(), 1d);
                Toolkit.getToolkit().accumulateStrokeBounds(
                        s,
                        bbox, type, sw,
                        cap, join, miterlimit, BaseTransform.IDENTITY_TRANSFORM);

            }
        }

        if (bbox[2] &lt; bbox[0] || bbox[3] &lt; bbox[1]) {
            return bounds.makeEmpty();
        }

        return bounds.deriveWithNewBounds(bbox[0], bbox[1], 0.0f,
                bbox[2], bbox[3], 0.0f);
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {
        // Unlike Group, a Region has its own intrinsic geometric bounds, even if it has no children.
        // The bounds of the Region must take into account any backgrounds and borders and how
        // they are used to draw the Region. The geom bounds must always take into account
        // all pixels drawn (because the geom bounds forms the basis of the dirty regions).
        // Note that the layout bounds of a Region is not based on the geom bounds.

        // Define some variables to hold the top-left and bottom-right corners of the bounds
        double bx1 = 0;
        double by1 = 0;
        double bx2 = getWidth();
        double by2 = getHeight();

        // If the shape is defined, then the top-left and bottom-right corner positions
        // need to be redefined
        if (_shape != null &amp;&amp; isScaleShape() == false) {
            // We will hijack the bounds here temporarily just to compute the shape bounds
            final BaseBounds shapeBounds = computeShapeBounds(bounds);
            final double shapeWidth = shapeBounds.getWidth();
            final double shapeHeight = shapeBounds.getHeight();
            if (isCenterShape()) {
                bx1 = (bx2 - shapeWidth) / 2;
                by1 = (by2 - shapeHeight) / 2;
                bx2 = bx1 + shapeWidth;
                by2 = by1 + shapeHeight;
            } else {
                bx1 = shapeBounds.getMinX();
                by1 = shapeBounds.getMinY();
                bx2 = shapeBounds.getMaxX();
                by2 = shapeBounds.getMaxY();
            }
        } else {
            // Expand the bounds to include the outsets from the background and border.
            // The outsets are the opposite of insets -- a measure of distance from the
            // edge of the Region outward. The outsets cannot, however, be negative.
            final Background background = getBackground();
            final Border border = getBorder();
            final Insets backgroundOutsets = background == null ? Insets.EMPTY : background.getOutsets();
            final Insets borderOutsets = border == null ? Insets.EMPTY : border.getOutsets();
            bx1 -= Math.max(backgroundOutsets.getLeft(), borderOutsets.getLeft());
            by1 -= Math.max(backgroundOutsets.getTop(), borderOutsets.getTop());
            bx2 += Math.max(backgroundOutsets.getRight(), borderOutsets.getRight());
            by2 += Math.max(backgroundOutsets.getBottom(), borderOutsets.getBottom());
        }
        // NOTE: Okay to call RegionHelper.superComputeGeomBounds with tx even in the 3D case
        // since Parent's computeGeomBounds does handle 3D correctly.
        BaseBounds cb = RegionHelper.superComputeGeomBounds(this, bounds, tx);
        /*
         * This is a work around for RT-7680. Parent returns invalid bounds from
         * computeGeomBoundsImpl when it has no children or if all its children
         * have invalid bounds. If RT-7680 were fixed, then we could omit this
         * first branch of the if and only use the else since the correct value
         * would be computed.
         */
        if (cb.isEmpty()) {
            // There are no children bounds, so
            bounds = bounds.deriveWithNewBounds(
                    (float)bx1, (float)by1, 0.0f,
                    (float)bx2, (float)by2, 0.0f);
            bounds = tx.transform(bounds, bounds);
            return bounds;
        } else {
            // Union with children's bounds
            BaseBounds tempBounds = TempState.getInstance().bounds;
            tempBounds = tempBounds.deriveWithNewBounds(
                    (float)bx1, (float)by1, 0.0f,
                    (float)bx2, (float)by2, 0.0f);
            BaseBounds bb = tx.transform(tempBounds, tempBounds);
            cb = cb.deriveWithUnion(bb);
            return cb;
        }
    }

    /***************************************************************************
     *                                                                         *
     * CSS                                                                     *
     *                                                                         *
     **************************************************************************/

    /**
     * An implementation may specify its own user-agent styles for this Region, and its children,
     * by overriding this method. These styles are used in addition to whatever user-agent stylesheets
     * are in use. This provides a mechanism for third parties to introduce styles for custom controls.
     * &lt;p&gt;
     * The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
     * does not have a [scheme:] component, the URL is considered to be the [path] component only.
     * Any leading '/' character of the [path] is ignored and the [path] is treated as a path relative to
     * the root of the application's classpath.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Subclasses overriding this method should not assume any particular implementation approach as to
     * the number and frequency with which it is called. For this reason, attempting any kind of
     * dynamic implementation (i.e. returning different user agent stylesheet values) based on some
     * state change is highly discouraged, as there is no guarantee when, or even if, this method will
     * be called. Some JavaFX CSS implementations may choose to cache this response for an indefinite
     * period of time, and therefore there should be no expectation around when this method is called.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;&lt;code&gt;
     *
     * package com.example.javafx.app;
     *
     * import javafx.application.Application;
     * import javafx.scene.Group;
     * import javafx.scene.Scene;
     * import javafx.stage.Stage;
     *
     * public class MyApp extends Application {
     *
     *     {@literal @}Override public void start(Stage stage) {
     *         Scene scene = new Scene(new Group());
     *         scene.getStylesheets().add(&quot;/com/example/javafx/app/mystyles.css&quot;);
     *         stage.setScene(scene);
     *         stage.show();
     *     }
     *
     *     public static void main(String[] args) {
     *         launch(args);
     *     }
     * }
     * &lt;/code&gt;&lt;/pre&gt;
     * For additional information about using CSS with the scene graph,
     * see the &lt;a href=&quot;../doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
     *
     * @return A string URL
     * @since JavaFX 8u40
     */
    public String getUserAgentStylesheet() {
        return null;
    }

    /*
     * Super-lazy instantiation pattern from Bill Pugh.
     */
     private static class StyleableProperties {
         private static final CssMetaData&lt;Region,Insets&gt; PADDING =
             new CssMetaData&lt;Region,Insets&gt;(&quot;-fx-padding&quot;,
                 InsetsConverter.getInstance(), Insets.EMPTY) {

            @Override public boolean isSettable(Region node) {
                return node.padding == null || !node.padding.isBound();
            }

            @Override public StyleableProperty&lt;Insets&gt; getStyleableProperty(Region node) {
                return (StyleableProperty&lt;Insets&gt;)node.paddingProperty();
            }
         };

         private static final CssMetaData&lt;Region,Insets&gt; OPAQUE_INSETS =
                 new CssMetaData&lt;Region,Insets&gt;(&quot;-fx-opaque-insets&quot;,
                         InsetsConverter.getInstance(), null) {

                     @Override
                     public boolean isSettable(Region node) {
                         return node.opaqueInsets == null || !node.opaqueInsets.isBound();
                     }

                     @Override
                     public StyleableProperty&lt;Insets&gt; getStyleableProperty(Region node) {
                         return (StyleableProperty&lt;Insets&gt;)node.opaqueInsetsProperty();
                     }

                 };

         private static final CssMetaData&lt;Region,Background&gt; BACKGROUND =
             new CssMetaData&lt;Region,Background&gt;(&quot;-fx-region-background&quot;,
                 BackgroundConverter.INSTANCE,
                 null,
                 false,
                 Background.getClassCssMetaData()) {

            @Override public boolean isSettable(Region node) {
                return !node.background.isBound();
            }

            @Override public StyleableProperty&lt;Background&gt; getStyleableProperty(Region node) {
                return (StyleableProperty&lt;Background&gt;)node.background;
            }
         };

         private static final CssMetaData&lt;Region,Border&gt; BORDER =
             new CssMetaData&lt;Region,Border&gt;(&quot;-fx-region-border&quot;,
                     BorderConverter.getInstance(),
                     null,
                     false,
                     Border.getClassCssMetaData()) {

                 @Override public boolean isSettable(Region node) {
                     return !node.border.isBound();
                 }

                 @Override public StyleableProperty&lt;Border&gt; getStyleableProperty(Region node) {
                     return (StyleableProperty&lt;Border&gt;)node.border;
                 }
             };

         private static final CssMetaData&lt;Region,Shape&gt; SHAPE =
             new CssMetaData&lt;Region,Shape&gt;(&quot;-fx-shape&quot;,
                 ShapeConverter.getInstance()) {

            @Override public boolean isSettable(Region node) {
                // isSettable depends on node.shape, not node.shapeContent
                return node.shape == null || !node.shape.isBound();
            }

            @Override public StyleableProperty&lt;Shape&gt; getStyleableProperty(Region node) {
                return (StyleableProperty&lt;Shape&gt;)node.shapeProperty();
            }
         };

         private static final CssMetaData&lt;Region, Boolean&gt; SCALE_SHAPE =
             new CssMetaData&lt;Region,Boolean&gt;(&quot;-fx-scale-shape&quot;,
                 BooleanConverter.getInstance(), Boolean.TRUE){

            @Override public boolean isSettable(Region node) {
                return node.scaleShape == null || !node.scaleShape.isBound();
            }

            @Override public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Region node) {
                return (StyleableProperty&lt;Boolean&gt;)node.scaleShapeProperty();
            }
        };

         private static final CssMetaData&lt;Region,Boolean&gt; POSITION_SHAPE =
             new CssMetaData&lt;Region,Boolean&gt;(&quot;-fx-position-shape&quot;,
                 BooleanConverter.getInstance(), Boolean.TRUE){

            @Override public boolean isSettable(Region node) {
                return node.centerShape == null || !node.centerShape.isBound();
            }

            @Override public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Region node) {
                return (StyleableProperty&lt;Boolean&gt;)node.centerShapeProperty();
            }
        };

         private static final CssMetaData&lt;Region,Boolean&gt; CACHE_SHAPE =
             new CssMetaData&lt;Region,Boolean&gt;(&quot;-fx-cache-shape&quot;,
                 BooleanConverter.getInstance(), Boolean.TRUE){

            @Override public boolean isSettable(Region node) {
                return node.cacheShape == null || !node.cacheShape.isBound();
            }

            @Override public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Region node) {
                return (StyleableProperty&lt;Boolean&gt;)node.cacheShapeProperty();
            }
        };

         private static final CssMetaData&lt;Region, Boolean&gt; SNAP_TO_PIXEL =
             new CssMetaData&lt;Region,Boolean&gt;(&quot;-fx-snap-to-pixel&quot;,
                 BooleanConverter.getInstance(), Boolean.TRUE){

            @Override public boolean isSettable(Region node) {
                return node.snapToPixel == null ||
                        !node.snapToPixel.isBound();
            }

            @Override public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Region node) {
                return (StyleableProperty&lt;Boolean&gt;)node.snapToPixelProperty();
            }
        };

         private static final CssMetaData&lt;Region, Number&gt; MIN_HEIGHT =
             new CssMetaData&lt;Region,Number&gt;(&quot;-fx-min-height&quot;,
                 SizeConverter.getInstance(), USE_COMPUTED_SIZE){

            @Override public boolean isSettable(Region node) {
                return node.minHeight == null ||
                        !node.minHeight.isBound();
            }

            @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(Region node) {
                return (StyleableProperty&lt;Number&gt;)node.minHeightProperty();
            }
        };

         private static final CssMetaData&lt;Region, Number&gt; PREF_HEIGHT =
             new CssMetaData&lt;Region,Number&gt;(&quot;-fx-pref-height&quot;,
                 SizeConverter.getInstance(), USE_COMPUTED_SIZE){

            @Override public boolean isSettable(Region node) {
                return node.prefHeight == null ||
                        !node.prefHeight.isBound();
            }

            @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(Region node) {
                return (StyleableProperty&lt;Number&gt;)node.prefHeightProperty();
            }
        };

         private static final CssMetaData&lt;Region, Number&gt; MAX_HEIGHT =
             new CssMetaData&lt;Region,Number&gt;(&quot;-fx-max-height&quot;,
                 SizeConverter.getInstance(), USE_COMPUTED_SIZE){

            @Override public boolean isSettable(Region node) {
                return node.maxHeight == null ||
                        !node.maxHeight.isBound();
            }

            @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(Region node) {
                return (StyleableProperty&lt;Number&gt;)node.maxHeightProperty();
            }
        };

         private static final CssMetaData&lt;Region, Number&gt; MIN_WIDTH =
             new CssMetaData&lt;Region,Number&gt;(&quot;-fx-min-width&quot;,
                 SizeConverter.getInstance(), USE_COMPUTED_SIZE){

            @Override public boolean isSettable(Region node) {
                return node.minWidth == null ||
                        !node.minWidth.isBound();
            }

            @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(Region node) {
                return (StyleableProperty&lt;Number&gt;)node.minWidthProperty();
            }
        };

         private static final CssMetaData&lt;Region, Number&gt; PREF_WIDTH =
             new CssMetaData&lt;Region,Number&gt;(&quot;-fx-pref-width&quot;,
                 SizeConverter.getInstance(), USE_COMPUTED_SIZE){

            @Override public boolean isSettable(Region node) {
                return node.prefWidth == null ||
                        !node.prefWidth.isBound();
            }

            @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(Region node) {
                return (StyleableProperty&lt;Number&gt;)node.prefWidthProperty();
            }
        };

         private static final CssMetaData&lt;Region, Number&gt; MAX_WIDTH =
             new CssMetaData&lt;Region,Number&gt;(&quot;-fx-max-width&quot;,
                 SizeConverter.getInstance(), USE_COMPUTED_SIZE){

            @Override public boolean isSettable(Region node) {
                return node.maxWidth == null ||
                        !node.maxWidth.isBound();
            }

            @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(Region node) {
                return (StyleableProperty&lt;Number&gt;)node.maxWidthProperty();
            }
        };

         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
         static {

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Parent.getClassCssMetaData());
            styleables.add(PADDING);
            styleables.add(BACKGROUND);
            styleables.add(BORDER);
            styleables.add(OPAQUE_INSETS);
            styleables.add(SHAPE);
            styleables.add(SCALE_SHAPE);
            styleables.add(POSITION_SHAPE);
            styleables.add(SNAP_TO_PIXEL);
            styleables.add(MIN_WIDTH);
            styleables.add(PREF_WIDTH);
            styleables.add(MAX_WIDTH);
            styleables.add(MIN_HEIGHT);
            styleables.add(PREF_HEIGHT);
            styleables.add(MAX_HEIGHT);
            STYLEABLES = Collections.unmodifiableList(styleables);
         }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     *
     * @since JavaFX 8.0
     */


    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/text/Text.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.text;

import javafx.css.converter.BooleanConverter;
import javafx.css.converter.EnumConverter;
import javafx.css.converter.SizeConverter;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.RectBounds;
import com.sun.javafx.geom.TransformedShape;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.shape.ShapeHelper;
import com.sun.javafx.scene.shape.TextHelper;
import com.sun.javafx.scene.text.GlyphList;
import com.sun.javafx.scene.text.TextLayout;
import com.sun.javafx.scene.text.TextLayoutFactory;
import com.sun.javafx.scene.text.TextLine;
import com.sun.javafx.scene.text.TextSpan;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.sg.prism.NGShape;
import com.sun.javafx.sg.prism.NGText;
import com.sun.javafx.scene.text.FontHelper;
import com.sun.javafx.tk.Toolkit;
import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.binding.DoubleBinding;
import javafx.beans.binding.ObjectBinding;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.scene.shape.LineTo;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.PathElement;
import javafx.scene.shape.Shape;
import javafx.scene.shape.StrokeType;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.IntegerPropertyBase;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.ReadOnlyDoubleProperty;
import javafx.beans.property.ReadOnlyDoubleWrapper;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.property.StringPropertyBase;
import javafx.css.CssMetaData;
import javafx.css.FontCssMetaData;
import javafx.css.Styleable;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.geometry.BoundingBox;
import javafx.geometry.Bounds;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Point2D;
import javafx.geometry.VPos;
import javafx.scene.Node;

/**
 * The {@code Text} class defines a node that displays a text.
 *
 * Paragraphs are separated by {@code '\n'} and the text is wrapped on
 * paragraph boundaries.
 *
&lt;PRE&gt;
import javafx.scene.text.*;

Text t = new Text(10, 50, &quot;This is a test&quot;);
t.setFont(new Font(20));
&lt;/PRE&gt;
 *
&lt;PRE&gt;
import javafx.scene.text.*;

Text t = new Text();
text.setFont(new Font(20));
text.setText(&quot;First row\nSecond row&quot;);
&lt;/PRE&gt;
 *
&lt;PRE&gt;
import javafx.scene.text.*;

Text t = new Text();
text.setFont(new Font(20));
text.setWrappingWidth(200);
text.setTextAlignment(TextAlignment.JUSTIFY)
text.setText(&quot;The quick brown fox jumps over the lazy dog&quot;);
&lt;/PRE&gt;
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;text&quot;)
public class Text extends Shape {
    static {
        TextHelper.setTextAccessor(new TextHelper.TextAccessor() {
            @Override
            public NGNode doCreatePeer(Node node) {
                return ((Text) node).doCreatePeer();
            }

            @Override
            public void doUpdatePeer(Node node) {
                ((Text) node).doUpdatePeer();
            }

            @Override
            public Bounds doComputeLayoutBounds(Node node) {
                return ((Text) node).doComputeLayoutBounds();
            }

            @Override
            public BaseBounds doComputeGeomBounds(Node node,
                    BaseBounds bounds, BaseTransform tx) {
                return ((Text) node).doComputeGeomBounds(bounds, tx);
            }

            @Override
            public boolean doComputeContains(Node node, double localX, double localY) {
                return ((Text) node).doComputeContains(localX, localY);
            }

            @Override
            public void doGeomChanged(Node node) {
                ((Text) node).doGeomChanged();
            }

            @Override
            public com.sun.javafx.geom.Shape doConfigShape(Shape shape) {
                return ((Text) shape).doConfigShape();
            }
        });
    }

    private TextLayout layout;
    private static final PathElement[] EMPTY_PATH_ELEMENT_ARRAY = new PathElement[0];

    {
        // To initialize the class helper at the begining each constructor of this class
        TextHelper.initHelper(this);
    }

    /**
     * Creates an empty instance of Text.
     */
    public Text() {
        setAccessibleRole(AccessibleRole.TEXT);
<A NAME="15"></A>        InvalidationListener listener = observable -&gt; checkSpan();
        parentProperty().addListener(listener);
        managedProperty().addListener(listener);
        <FONT color="#3bb9ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#15',2,'match31-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>effectiveNodeOrientationProperty().addListener(observable -&gt; checkOrientation());
        setPickOnBounds(true);
    }

    /**
     * Creates an instance of Text containing the given string.
     * @param text text to be contained in the instance
     */
    public Text(String text) {</B></FONT>
        this();
        setText(text);
    }

    /**
     * Creates an instance of Text on the given coordinates containing the
     * given string.
     * @param x the horizontal position of the text
     * @param y the vertical position of the text
     * @param text text to be contained in the instance
     */
    public Text(double x, double y, String text) {
        this(text);
        setX(x);
        setY(y);
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private NGNode doCreatePeer() {
        return new NGText();
    }

    private boolean isSpan;
    private boolean isSpan() {
        return isSpan;
    }

    private void checkSpan() {
        isSpan = isManaged() &amp;&amp; getParent() instanceof TextFlow;
        if (isSpan() &amp;&amp; !pickOnBoundsProperty().isBound()) {
            /* Documented behavior. See class description for TextFlow */
            setPickOnBounds(false);
        }
    }

    private void checkOrientation() {
        if (!isSpan()) {
            NodeOrientation orientation = getEffectiveNodeOrientation();
            boolean rtl =  orientation == NodeOrientation.RIGHT_TO_LEFT;
            int dir = rtl ? TextLayout.DIRECTION_RTL : TextLayout.DIRECTION_LTR;
            TextLayout layout = getTextLayout();
            if (layout.setDirection(dir)) {
                needsTextLayout();
            }
        }
    }

    @Override
    public boolean usesMirroring() {
        return false;
    }

    private void needsFullTextLayout() {
        if (isSpan()) {
            /* Create new text span every time the font or text changes
             * so the text layout can see that the content has changed.
             */
            textSpan = null;

            /* Relies on NodeHelper.geomChanged(this) to request text flow to relayout */
        } else {
            TextLayout layout = getTextLayout();
            String string = getTextInternal();
            Object font = getFontInternal();
            layout.setContent(string, font);
        }
        needsTextLayout();
    }

    private void needsTextLayout() {
        textRuns = null;
        NodeHelper.geomChanged(this);
        NodeHelper.markDirty(this, DirtyBits.NODE_CONTENTS);
    }

    private TextSpan textSpan;
    TextSpan getTextSpan() {
        if (textSpan == null) {
            textSpan = new TextSpan() {
                @Override public String getText() {
                    return getTextInternal();
                }
                @Override public Object getFont() {
                    return getFontInternal();
                }
                @Override public RectBounds getBounds() {
                    return null;
                }
            };
        }
        return textSpan;
    }

    private TextLayout getTextLayout() {
        if (isSpan()) {
            layout = null;
            TextFlow parent = (TextFlow)getParent();
            return parent.getTextLayout();
        }
        if (layout == null) {
            TextLayoutFactory factory = Toolkit.getToolkit().getTextLayoutFactory();
            layout = factory.createLayout();
            String string = getTextInternal();
            Object font = getFontInternal();
            TextAlignment alignment = getTextAlignment();
            if (alignment == null) alignment = DEFAULT_TEXT_ALIGNMENT;
            layout.setContent(string, font);
            layout.setAlignment(alignment.ordinal());
            layout.setLineSpacing((float)getLineSpacing());
            layout.setWrapWidth((float)getWrappingWidth());
            if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
                layout.setDirection(TextLayout.DIRECTION_RTL);
            } else {
                layout.setDirection(TextLayout.DIRECTION_LTR);
            }
        }
        return layout;
    }

    private GlyphList[] textRuns = null;
    private BaseBounds spanBounds = new RectBounds(); /* relative to the textlayout */
    private boolean spanBoundsInvalid = true;

    void layoutSpan(GlyphList[] runs) {
        TextSpan span = getTextSpan();
        int count = 0;
        for (int i = 0; i &lt; runs.length; i++) {
            GlyphList run = runs[i];
            if (run.getTextSpan() == span) {
                count++;
            }
        }
        textRuns = new GlyphList[count];
        count = 0;
        for (int i = 0; i &lt; runs.length; i++) {
            GlyphList run = runs[i];
            if (run.getTextSpan() == span) {
                textRuns[count++] = run;
            }
        }
        spanBoundsInvalid = true;

        /* Sometimes a property change in the text node will causes layout in
         * text flow. In this case all the dirty bits are already clear and no
         * extra work is necessary. Other times the layout is caused by changes
         * in the text flow object (wrapping width and text alignment for example).
         * In the second case the dirty bits must be set here using
         * NodeHelper.geomChanged(this) and NodeHelper.markDirty(). Note that NodeHelper.geomChanged(this)
         * causes another (undesired) layout request in the parent.
         * In general this is not a problem because shapes are not resizable and
         * region objects do not propagate layout changes to the parent.
         * This is a special case where a shape is resized by the parent during
         * layoutChildren(). See TextFlow#requestLayout() for information how
         * text flow deals with this situation.
         */
        NodeHelper.geomChanged(this);
        NodeHelper.markDirty(this, DirtyBits.NODE_CONTENTS);
    }

    BaseBounds getSpanBounds() {
        if (spanBoundsInvalid) {
            GlyphList[] runs = getRuns();
            if (runs.length != 0) {
                float left = Float.POSITIVE_INFINITY;
                float top = Float.POSITIVE_INFINITY;
                float right = 0;
                float bottom = 0;
                for (int i = 0; i &lt; runs.length; i++) {
                    GlyphList run = runs[i];
                    com.sun.javafx.geom.Point2D location = run.getLocation();
                    float width = run.getWidth();
                    float height = run.getLineBounds().getHeight();
                    left = Math.min(location.x, left);
                    top = Math.min(location.y, top);
                    right = Math.max(location.x + width, right);
                    bottom = Math.max(location.y + height, bottom);
                }
                spanBounds = spanBounds.deriveWithNewBounds(left, top, 0,
                                                            right, bottom, 0);
            } else {
                spanBounds = spanBounds.makeEmpty();
            }
            spanBoundsInvalid = false;
        }
        return spanBounds;
    }

    private GlyphList[] getRuns() {
        if (textRuns != null) return textRuns;
        if (isSpan()) {
            /* List of run is initialized when the TextFlow layout the children */
            getParent().layout();
        } else {
            TextLayout layout = getTextLayout();
            textRuns = layout.getRuns();
        }
        return textRuns;
    }

    private com.sun.javafx.geom.Shape getShape() {
        TextLayout layout = getTextLayout();
        /* TextLayout has the text shape cached */
        int type = TextLayout.TYPE_TEXT;
        if (isStrikethrough()) type |= TextLayout.TYPE_STRIKETHROUGH;
        if (isUnderline()) type |= TextLayout.TYPE_UNDERLINE;

        TextSpan filter = null;
        if (isSpan()) {
            /* Spans are always relative to the top */
            type |= TextLayout.TYPE_TOP;
            filter = getTextSpan();
        } else {
            /* Relative to baseline (first line)
             * This shape can be translate in the y axis according
             * to text origin, see ShapeHelper.configShape().
             */
            type |= TextLayout.TYPE_BASELINE;
        }
        return layout.getShape(type, filter);
    }

    private BaseBounds getVisualBounds() {
        if (ShapeHelper.getMode(this) == NGShape.Mode.FILL || getStrokeType() == StrokeType.INSIDE) {
            int type = TextLayout.TYPE_TEXT;
            if (isStrikethrough()) type |= TextLayout.TYPE_STRIKETHROUGH;
            if (isUnderline()) type |= TextLayout.TYPE_UNDERLINE;
            return getTextLayout().getVisualBounds(type);
        } else {
            return getShape().getBounds();
        }
    }

    private BaseBounds getLogicalBounds() {
        TextLayout layout = getTextLayout();
        /* TextLayout has the bounds cached */
        return layout.getBounds();
    }

    /**
     * Defines text string that is to be displayed.
     *
     * @defaultValue empty string
     */
    private StringProperty text;

    public final void setText(String value) {
        if (value == null) value = &quot;&quot;;
        textProperty().set(value);
    }

    public final String getText() {
        return text == null ? &quot;&quot; : text.get();
    }

    private String getTextInternal() {
        // this might return null in case of bound property
        String localText = getText();
        return localText == null ? &quot;&quot; : localText;
    }

    public final StringProperty textProperty() {
        if (text == null) {
            text = new StringPropertyBase(&quot;&quot;) {
                @Override public Object getBean() { return Text.this; }
                @Override public String getName() { return &quot;text&quot;; }
                @Override  public void invalidated() {
                    needsFullTextLayout();
                    setSelectionStart(-1);
                    setSelectionEnd(-1);
                    setCaretPosition(-1);
                    setCaretBias(true);

                    // MH: Functionality copied from store() method,
                    // which was removed.
                    // Wonder what should happen if text is bound
                    //  and becomes null?
                    final String value = get();
                    if ((value == null) &amp;&amp; !isBound()) {
                        set(&quot;&quot;);
                    }
                    notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);
                }
            };
        }
        return text;
    }

    /**
     * Defines the X coordinate of text origin.
     *
     * @defaultValue 0
     */
    private DoubleProperty x;

    public final void setX(double value) {
        xProperty().set(value);
    }

    public final double getX() {
        return x == null ? 0.0 : x.get();
    }

    public final DoubleProperty xProperty() {
        if (x == null) {
            x = new DoublePropertyBase() {
                @Override public Object getBean() { return Text.this; }
                @Override public String getName() { return &quot;x&quot;; }
                @Override public void invalidated() {
                    NodeHelper.geomChanged(Text.this);
                }
            };
        }
        return x;
    }

    /**
     * Defines the Y coordinate of text origin.
     *
     * @defaultValue 0
     */
    private DoubleProperty y;

    public final void setY(double value) {
        yProperty().set(value);
    }

    public final double getY() {
        return y == null ? 0.0 : y.get();
    }

    public final DoubleProperty yProperty() {
        if (y == null) {
            y = new DoublePropertyBase() {
                @Override public Object getBean() { return Text.this; }
                @Override public String getName() { return &quot;y&quot;; }
                @Override public void invalidated() {
                    NodeHelper.geomChanged(Text.this);
                }
            };
        }
        return y;
    }

    /**
     * Defines the font of text.
     *
     * @defaultValue Font{}
     */
    private ObjectProperty&lt;Font&gt; font;

    public final void setFont(Font value) {
        fontProperty().set(value);
    }

    public final Font getFont() {
        return font == null ? Font.getDefault() : font.get();
    }

    /**
     * Internally used safe version of getFont which never returns null.
     *
     * @return the font
     */
    private Object getFontInternal() {
        Font font = getFont();
        if (font == null) font = Font.getDefault();
        return FontHelper.getNativeFont(font);
    }

    public final ObjectProperty&lt;Font&gt; fontProperty() {
        if (font == null) {
            font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
                @Override public Object getBean() { return Text.this; }
                @Override public String getName() { return &quot;font&quot;; }
                @Override public CssMetaData&lt;Text,Font&gt; getCssMetaData() {
                    return StyleableProperties.FONT;
                }
                @Override public void invalidated() {
                    needsFullTextLayout();
                    NodeHelper.markDirty(Text.this, DirtyBits.TEXT_FONT);
                }
            };
        }
        return font;
    }

    public final void setTextOrigin(VPos value) {
        textOriginProperty().set(value);
    }

    public final VPos getTextOrigin() {
        if (attributes == null || attributes.textOrigin == null) {
            return DEFAULT_TEXT_ORIGIN;
        }
        return attributes.getTextOrigin();
    }

    /**
     * Defines the origin of text coordinate system in local coordinates.
     * Note: in case multiple rows are rendered {@code VPos.BASELINE} and
     * {@code VPos.TOP} define the origin of the top row while
     * {@code VPos.BOTTOM} defines the origin of the bottom row.
     *
     * @return the origin of text coordinate system in local coordinates
     * @defaultValue VPos.BASELINE
     */
    public final ObjectProperty&lt;VPos&gt; textOriginProperty() {
        return getTextAttribute().textOriginProperty();
    }

    /**
     * Determines how the bounds of the text node are calculated.
     * Logical bounds is a more appropriate default for text than
     * the visual bounds. See {@code TextBoundsType} for more information.
     *
     * @defaultValue TextBoundsType.LOGICAL
     */
    private ObjectProperty&lt;TextBoundsType&gt; boundsType;

    public final void setBoundsType(TextBoundsType value) {
        boundsTypeProperty().set(value);
    }

    public final TextBoundsType getBoundsType() {
        return boundsType == null ?
            DEFAULT_BOUNDS_TYPE : boundsTypeProperty().get();
    }

    public final ObjectProperty&lt;TextBoundsType&gt; boundsTypeProperty() {
        if (boundsType == null) {
            boundsType =
               new StyleableObjectProperty&lt;TextBoundsType&gt;(DEFAULT_BOUNDS_TYPE) {
                   @Override public Object getBean() { return Text.this; }
                   @Override public String getName() { return &quot;boundsType&quot;; }
                   @Override public CssMetaData&lt;Text,TextBoundsType&gt; getCssMetaData() {
                       return StyleableProperties.BOUNDS_TYPE;
                   }
                   @Override public void invalidated() {
                       TextLayout layout = getTextLayout();
                       int type = 0;
                       if (boundsType.get() == TextBoundsType.LOGICAL_VERTICAL_CENTER) {
                           type |= TextLayout.BOUNDS_CENTER;
                       }
                       if (layout.setBoundsType(type)) {
                           needsTextLayout();
                       } else {
                           NodeHelper.geomChanged(Text.this);
                       }
                   }
            };
        }
        return boundsType;
    }

    /**
     * Defines a width constraint for the text in user space coordinates,
     * e.g. pixels, not glyph or character count.
     * If the value is {@code &gt; 0} text will be line wrapped as needed
     * to satisfy this constraint.
     *
     * @defaultValue 0
     */
    private DoubleProperty wrappingWidth;

    public final void setWrappingWidth(double value) {
        wrappingWidthProperty().set(value);
    }

    public final double getWrappingWidth() {
        return wrappingWidth == null ? 0 : wrappingWidth.get();
    }

    public final DoubleProperty wrappingWidthProperty() {
        if (wrappingWidth == null) {
            wrappingWidth = new DoublePropertyBase() {
                @Override public Object getBean() { return Text.this; }
                @Override public String getName() { return &quot;wrappingWidth&quot;; }
                @Override public void invalidated() {
                    if (!isSpan()) {
                        TextLayout layout = getTextLayout();
                        if (layout.setWrapWidth((float)get())) {
                            needsTextLayout();
                        } else {
                            NodeHelper.geomChanged(Text.this);
                        }
                    }
                }
            };
        }
        return wrappingWidth;
    }

    public final void setUnderline(boolean value) {
        underlineProperty().set(value);
    }

    public final boolean isUnderline() {
        if (attributes == null || attributes.underline == null) {
            return DEFAULT_UNDERLINE;
        }
        return attributes.isUnderline();
    }

    /**
     * Defines if each line of text should have a line below it.
     *
     * @return if each line of text should have a line below it
     * @defaultValue false
     */
    public final BooleanProperty underlineProperty() {
        return getTextAttribute().underlineProperty();
    }

    public final void setStrikethrough(boolean value) {
        strikethroughProperty().set(value);
    }

    public final boolean isStrikethrough() {
        if (attributes == null || attributes.strikethrough == null) {
            return DEFAULT_STRIKETHROUGH;
        }
        return attributes.isStrikethrough();
    }

    /**
     * Defines if each line of text should have a line through it.
     *
     * @return if each line of text should have a line through it
     * @defaultValue false
     */
    public final BooleanProperty strikethroughProperty() {
        return getTextAttribute().strikethroughProperty();
    }

    public final void setTextAlignment(TextAlignment value) {
        textAlignmentProperty().set(value);
    }

    public final TextAlignment getTextAlignment() {
        if (attributes == null || attributes.textAlignment == null) {
            return DEFAULT_TEXT_ALIGNMENT;
        }
        return attributes.getTextAlignment();
    }

    /**
     * Defines horizontal text alignment in the bounding box.
     *
     * The width of the bounding box is defined by the widest row.
     *
     * Note: In the case of a single line of text, where the width of the
     * node is determined by the width of the text, the alignment setting
     * has no effect.
     *
     * @return the horizontal text alignment in the bounding box
     * @defaultValue TextAlignment.LEFT
     */
    public final ObjectProperty&lt;TextAlignment&gt; textAlignmentProperty() {
        return getTextAttribute().textAlignmentProperty();
    }

    public final void setLineSpacing(double spacing) {
        lineSpacingProperty().set(spacing);
    }

    public final double getLineSpacing() {
        if (attributes == null || attributes.lineSpacing == null) {
            return DEFAULT_LINE_SPACING;
        }
        return attributes.getLineSpacing();
    }

    /**
     * Defines the vertical space in pixel between lines.
     *
     * @return the vertical space in pixel between lines
     * @defaultValue 0
     *
     * @since JavaFX 8.0
     */
    public final DoubleProperty lineSpacingProperty() {
        return getTextAttribute().lineSpacingProperty();
    }

    @Override
    public final double getBaselineOffset() {
        return baselineOffsetProperty().get();
    }

    /**
     * The 'alphabetic' (or roman) baseline offset from the Text node's
     * layoutBounds.minY location.
     * The value typically corresponds to the max ascent of the font.
     * @return the baseline offset from this text node
     */
    public final ReadOnlyDoubleProperty baselineOffsetProperty() {
        return getTextAttribute().baselineOffsetProperty();
    }

    /**
     * Specifies a requested font smoothing type : gray or LCD.
     *
     * The width of the bounding box is defined by the widest row.
     *
     * Note: LCD mode doesn't apply in numerous cases, such as various
     * compositing modes, where effects are applied and very large glyphs.
     *
     * @defaultValue FontSmoothingType.GRAY
     * @since JavaFX 2.1
     */
    private ObjectProperty&lt;FontSmoothingType&gt; fontSmoothingType;

    public final void setFontSmoothingType(FontSmoothingType value) {
        fontSmoothingTypeProperty().set(value);
    }

    public final FontSmoothingType getFontSmoothingType() {
        return fontSmoothingType == null ?
            FontSmoothingType.GRAY : fontSmoothingType.get();
    }

    public final ObjectProperty&lt;FontSmoothingType&gt;
        fontSmoothingTypeProperty() {
        if (fontSmoothingType == null) {
            fontSmoothingType =
                new StyleableObjectProperty&lt;FontSmoothingType&gt;
                                               (FontSmoothingType.GRAY) {
                @Override public Object getBean() { return Text.this; }
                @Override public String getName() { return &quot;fontSmoothingType&quot;; }
                @Override public CssMetaData&lt;Text,FontSmoothingType&gt; getCssMetaData() {
                    return StyleableProperties.FONT_SMOOTHING_TYPE;
                }
                @Override public void invalidated() {
                    NodeHelper.markDirty(Text.this, DirtyBits.TEXT_ATTRS);
                    NodeHelper.geomChanged(Text.this);
                }
            };
        }
        return fontSmoothingType;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doGeomChanged() {
        if (attributes != null) {
            if (attributes.caretBinding != null) {
                attributes.caretBinding.invalidate();
            }
            if (attributes.selectionBinding != null) {
                attributes.selectionBinding.invalidate();
            }
        }
        NodeHelper.markDirty(this, DirtyBits.NODE_GEOMETRY);
    }

    /**
     * Shape of selection in local coordinates.
     *
     * @return the shape of selection in local coordinates
     * @since 9
     */
    public final PathElement[] getSelectionShape() {
        return selectionShapeProperty().get();
    }

    public final ReadOnlyObjectProperty&lt;PathElement[]&gt; selectionShapeProperty() {
        return getTextAttribute().selectionShapeProperty();
    }

    /**
     * Selection start index in the content.
     * Set to {@code -1} to unset selection.
     *
     * @param value the selection start index
     * @since 9
     */
    public final void setSelectionStart(int value) {
        if (value == -1 &amp;&amp;
                (attributes == null || attributes.selectionStart == null)) {
            return;
        }
        selectionStartProperty().set(value);
    }

    public final int getSelectionStart() {
        if (attributes == null || attributes.selectionStart == null) {
            return DEFAULT_SELECTION_START;
        }
        return attributes.getSelectionStart();
    }

    public final IntegerProperty selectionStartProperty() {
        return getTextAttribute().selectionStartProperty();
    }

    /**
     * Selection end index in the content.
     * Set to {@code -1} to unset selection.
     *
     * @param value the selection end index
     * @since 9
     */
    public final void setSelectionEnd(int value) {
        if (value == -1 &amp;&amp;
                (attributes == null || attributes.selectionEnd == null)) {
            return;
        }
        selectionEndProperty().set(value);
    }

    public final int getSelectionEnd() {
        if (attributes == null || attributes.selectionEnd == null) {
            return DEFAULT_SELECTION_END;
        }
        return attributes.getSelectionEnd();
    }

    public final IntegerProperty selectionEndProperty() {
        return getTextAttribute().selectionEndProperty();
    }

    /**
     * The fill color of selected text.
     *
     * @return the fill color of selected text
     * @since 9
     */
    public final ObjectProperty&lt;Paint&gt; selectionFillProperty() {
        return getTextAttribute().selectionFillProperty();
    }

    public final void setSelectionFill(Paint paint) {
        selectionFillProperty().set(paint);
    }
    public final Paint getSelectionFill() {
        return selectionFillProperty().get();
    }

    /**
     * Shape of caret in local coordinates.
     *
     * @return the shape of caret in local coordinates
     * @since 9
     */
    public final PathElement[] getCaretShape() {
        return caretShapeProperty().get();
    }

    public final ReadOnlyObjectProperty&lt;PathElement[]&gt; caretShapeProperty() {
        return getTextAttribute().caretShapeProperty();
    }

    /**
     * Caret index in the content.
     * Set to {@code -1} to unset caret.
     *
     * @param value the caret index in the content
     * @since 9
     */
    public final void setCaretPosition(int value) {
        if (value == -1 &amp;&amp;
                (attributes == null || attributes.caretPosition == null)) {
            return;
        }
        caretPositionProperty().set(value);
    }

    public final int getCaretPosition() {
        if (attributes == null || attributes.caretPosition == null) {
            return DEFAULT_CARET_POSITION;
        }
        return attributes.getCaretPosition();
    }

    public final IntegerProperty caretPositionProperty() {
        return getTextAttribute().caretPositionProperty();
    }

    /**
     * caret bias in the content. {@code true} means a bias towards the leading character edge.
     * (true=leading/false=trailing)
     *
     * @param value the caret bias in the content
     * @since 9
     */
    public final void setCaretBias(boolean value) {
        if (value &amp;&amp; (attributes == null || attributes.caretBias == null)) {
            return;
        }
        caretBiasProperty().set(value);
    }

    public final boolean isCaretBias() {
        if (attributes == null || attributes.caretBias == null) {
            return DEFAULT_CARET_BIAS;
        }
        return getTextAttribute().isCaretBias();
    }

    public final BooleanProperty caretBiasProperty() {
        return getTextAttribute().caretBiasProperty();
    }

    /**
     * Maps local point to index in the content.
     *
     * @param point the specified point to be tested
     * @return a {@code HitInfo} representing the character index found
     * @since 9
     */
    public final HitInfo hitTest(Point2D point) {
        if (point == null) return null;
        TextLayout layout = getTextLayout();
        double x = point.getX() - getX();
        double y = point.getY() - getY() + getYRendering();
        TextLayout.Hit layoutHit = layout.getHitInfo((float)x, (float)y);
        return new HitInfo(layoutHit.getCharIndex(), layoutHit.getInsertionIndex(),
                           layoutHit.isLeading(), getText());
    }

    private PathElement[] getRange(int start, int end, int type) {
        int length = getTextInternal().length();
        if (0 &lt;= start &amp;&amp; start &lt; end  &amp;&amp; end &lt;= length) {
            TextLayout layout = getTextLayout();
            float x = (float)getX();
            float y = (float)getY() - getYRendering();
            return layout.getRange(start, end, type, x, y);
        }
        return EMPTY_PATH_ELEMENT_ARRAY;
    }

    /**
     * Returns shape for the caret at given index and bias.
     *
     * @param charIndex the character index for the caret
     * @param caretBias whether the caret is biased on the leading edge of the character
     * @return an array of {@code PathElement} which can be used to create a {@code Shape}
     * @since 9
     */
    public final PathElement[] caretShape(int charIndex, boolean caretBias) {
        if (0 &lt;= charIndex &amp;&amp; charIndex &lt;= getTextInternal().length()) {
            float x = (float)getX();
            float y = (float)getY() - getYRendering();
            return getTextLayout().getCaretShape(charIndex, caretBias, x, y);
        } else {
            return null;
        }
    }

    /**
     * Returns shape for the range of the text in local coordinates.
     *
     * @param start the beginning character index for the range
     * @param end the end character index (non-inclusive) for the range
     * @return an array of {@code PathElement} which can be used to create a {@code Shape}
     * @since 9
     */
    public final PathElement[] rangeShape(int start, int end) {
        return getRange(start, end, TextLayout.TYPE_TEXT);
    }

    /**
     * Returns shape for the underline in local coordinates.
     *
     * @param start the beginning character index for the range
     * @param end the end character index (non-inclusive) for the range
     * @return an array of {@code PathElement} which can be used to create a {@code Shape}
     * @since 9
     */
    public final PathElement[] underlineShape(int start, int end) {
        return getRange(start, end, TextLayout.TYPE_UNDERLINE);
    }

    private float getYAdjustment(BaseBounds bounds) {
        VPos origin = getTextOrigin();
        if (origin == null) origin = DEFAULT_TEXT_ORIGIN;
        switch (origin) {
        case TOP: return -bounds.getMinY();
        case BASELINE: return 0;
        case CENTER: return -bounds.getMinY() - bounds.getHeight() / 2;
        case BOTTOM: return -bounds.getMinY() - bounds.getHeight();
        default: return 0;
        }
    }

    private float getYRendering() {
        if (isSpan()) return 0;

        /* Always logical for rendering */
        BaseBounds bounds = getLogicalBounds();

        VPos origin = getTextOrigin();
        if (origin == null) origin = DEFAULT_TEXT_ORIGIN;
        if (getBoundsType() == TextBoundsType.VISUAL) {
            BaseBounds vBounds = getVisualBounds();
            float delta = vBounds.getMinY() - bounds.getMinY();
            switch (origin) {
            case TOP: return delta;
            case BASELINE: return -vBounds.getMinY() + delta;
            case CENTER: return vBounds.getHeight() / 2 + delta;
            case BOTTOM: return vBounds.getHeight() + delta;
            default: return 0;
            }
        } else {
            switch (origin) {
            case TOP: return 0;
            case BASELINE: return -bounds.getMinY();
            case CENTER: return bounds.getHeight() / 2;
            case BOTTOM: return bounds.getHeight();
            default: return 0;
            }
        }
    }

    private Bounds doComputeLayoutBounds() {
        if (isSpan()) {
            BaseBounds bounds = getSpanBounds();
            double width = bounds.getWidth();
            double height = bounds.getHeight();
            return new BoundingBox(0, 0, width, height);
        }

        if (getBoundsType() == TextBoundsType.VISUAL) {
            /* In Node the layout bounds is computed based in the geom
             * bounds and in Shape the geom bounds is computed based
             * on the shape (generated here in #configShape()) */
            return TextHelper.superComputeLayoutBounds(this);
        }
        BaseBounds bounds = getLogicalBounds();
        double x = bounds.getMinX() + getX();
        double y = bounds.getMinY() + getY() + getYAdjustment(bounds);
        double width = bounds.getWidth();
        double height = bounds.getHeight();
        double wrappingWidth = getWrappingWidth();
        if (wrappingWidth != 0) width = wrappingWidth;
        return new BoundingBox(x, y, width, height);
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private BaseBounds doComputeGeomBounds(BaseBounds bounds,
                                                   BaseTransform tx) {
        if (isSpan()) {
            if (ShapeHelper.getMode(this) != NGShape.Mode.FILL &amp;&amp; getStrokeType() != StrokeType.INSIDE) {
                return TextHelper.superComputeGeomBounds(this, bounds, tx);
            }
            TextLayout layout = getTextLayout();
            bounds = layout.getBounds(getTextSpan(), bounds);
            BaseBounds spanBounds = getSpanBounds();
            float minX = bounds.getMinX() - spanBounds.getMinX();
            float minY = bounds.getMinY() - spanBounds.getMinY();
            float maxX = minX + bounds.getWidth();
            float maxY = minY + bounds.getHeight();
            bounds = bounds.deriveWithNewBounds(minX, minY, 0, maxX, maxY, 0);
            return tx.transform(bounds, bounds);
        }

       if (getBoundsType() == TextBoundsType.VISUAL) {
            if (getTextInternal().length() == 0 || ShapeHelper.getMode(this) == NGShape.Mode.EMPTY) {
                return bounds.makeEmpty();
            }
            if (ShapeHelper.getMode(this) == NGShape.Mode.FILL || getStrokeType() == StrokeType.INSIDE) {
                /* Optimize for FILL and INNER STROKE: save the cost of shaping each glyph */
                BaseBounds visualBounds = getVisualBounds();
                float x = visualBounds.getMinX() + (float) getX();
                float yadj = getYAdjustment(visualBounds);
                float y = visualBounds.getMinY() + yadj + (float) getY();
                bounds.deriveWithNewBounds(x, y, 0, x + visualBounds.getWidth(),
                        y + visualBounds.getHeight(), 0);
                return tx.transform(bounds, bounds);
            } else {
                /* Let the superclass compute the bounds using shape */
                return TextHelper.superComputeGeomBounds(this, bounds, tx);
            }
        }

        BaseBounds textBounds = getLogicalBounds();
        float x = textBounds.getMinX() + (float)getX();
        float yadj = getYAdjustment(textBounds);
        float y = textBounds.getMinY() + yadj + (float)getY();
        float width = textBounds.getWidth();
        float height = textBounds.getHeight();
        float wrappingWidth = (float)getWrappingWidth();
        if (wrappingWidth &gt; width) {
            width = wrappingWidth;
        } else {
            /* The following adjustment is necessary for the text bounds to be
             * relative to the same location as the mirrored bounds returned
             * by layout.getBounds().
             */
            if (wrappingWidth &gt; 0) {
                NodeOrientation orientation = getEffectiveNodeOrientation();
                if (orientation == NodeOrientation.RIGHT_TO_LEFT) {
                    x -= width - wrappingWidth;
                }
            }
        }
        textBounds = new RectBounds(x, y, x + width, y + height);

        /* handle stroked text */
        if (ShapeHelper.getMode(this) != NGShape.Mode.FILL &amp;&amp; getStrokeType() != StrokeType.INSIDE) {
            bounds = TextHelper.superComputeGeomBounds(this, bounds,
                    BaseTransform.IDENTITY_TRANSFORM);
        } else {
            TextLayout layout = getTextLayout();
            bounds = layout.getBounds(null, bounds);
            x = bounds.getMinX() + (float)getX();
            width = bounds.getWidth();
            bounds = bounds.deriveWithNewBounds(x, y, 0, x + width, y + height, 0);
        }

        bounds = bounds.deriveWithUnion(textBounds);
        return tx.transform(bounds, bounds);
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeContains(double localX, double localY) {
        /* Used for spans, regular text uses bounds based picking */
        double x = localX + getSpanBounds().getMinX();
        double y = localY + getSpanBounds().getMinY();
        GlyphList[] runs = getRuns();
        if (runs.length != 0) {
            for (int i = 0; i &lt; runs.length; i++) {
                GlyphList run = runs[i];
                com.sun.javafx.geom.Point2D location = run.getLocation();
                float width = run.getWidth();
                RectBounds lineBounds = run.getLineBounds();
                float height = lineBounds.getHeight();
                if (location.x &lt;= x &amp;&amp; x &lt; location.x + width &amp;&amp;
                    location.y &lt;= y &amp;&amp; y &lt; location.y + height) {
                        return true;
                }
            }
        }
        return false;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private com.sun.javafx.geom.Shape doConfigShape() {
        if (ShapeHelper.getMode(this) == NGShape.Mode.EMPTY || getTextInternal().length() == 0) {
            return new Path2D();
        }
        com.sun.javafx.geom.Shape shape = getShape();
        float x, y;
        if (isSpan()) {
            BaseBounds bounds = getSpanBounds();
            x = -bounds.getMinX();
            y = -bounds.getMinY();
        } else {
            x = (float)getX();
            y = getYAdjustment(getVisualBounds()) + (float)getY();
        }
        return TransformedShape.translatedShape(shape, x, y);
    }

   /***************************************************************************
    *                                                                         *
    *                            Stylesheet Handling                          *
    *                                                                         *
    **************************************************************************/

    /*
     * Super-lazy instantiation pattern from Bill Pugh.
     */
     private static class StyleableProperties {

         private static final CssMetaData&lt;Text,Font&gt; FONT =
            new FontCssMetaData&lt;Text&gt;(&quot;-fx-font&quot;, Font.getDefault()) {

            @Override
            public boolean isSettable(Text node) {
                return node.font == null || !node.font.isBound();
            }

            @Override
            public StyleableProperty&lt;Font&gt; getStyleableProperty(Text node) {
                return (StyleableProperty&lt;Font&gt;)node.fontProperty();
            }
         };

         private static final CssMetaData&lt;Text,Boolean&gt; UNDERLINE =
            new CssMetaData&lt;Text,Boolean&gt;(&quot;-fx-underline&quot;,
                 BooleanConverter.getInstance(), Boolean.FALSE) {

            @Override
            public boolean isSettable(Text node) {
                return node.attributes == null ||
                       node.attributes.underline == null ||
                      !node.attributes.underline.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Text node) {
                return (StyleableProperty&lt;Boolean&gt;)node.underlineProperty();
            }
         };

         private static final CssMetaData&lt;Text,Boolean&gt; STRIKETHROUGH =
            new CssMetaData&lt;Text,Boolean&gt;(&quot;-fx-strikethrough&quot;,
                 BooleanConverter.getInstance(), Boolean.FALSE) {

            @Override
            public boolean isSettable(Text node) {
                return node.attributes == null ||
                       node.attributes.strikethrough == null ||
                      !node.attributes.strikethrough.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Text node) {
                return (StyleableProperty&lt;Boolean&gt;)node.strikethroughProperty();
            }
         };

         private static final
             CssMetaData&lt;Text,TextAlignment&gt; TEXT_ALIGNMENT =
                 new CssMetaData&lt;Text,TextAlignment&gt;(&quot;-fx-text-alignment&quot;,
                 new EnumConverter&lt;TextAlignment&gt;(TextAlignment.class),
                 TextAlignment.LEFT) {

            @Override
            public boolean isSettable(Text node) {
                return node.attributes == null ||
                       node.attributes.textAlignment == null ||
                      !node.attributes.textAlignment.isBound();
            }

            @Override
            public StyleableProperty&lt;TextAlignment&gt; getStyleableProperty(Text node) {
                return (StyleableProperty&lt;TextAlignment&gt;)node.textAlignmentProperty();
            }
         };

         private static final CssMetaData&lt;Text,VPos&gt; TEXT_ORIGIN =
                 new CssMetaData&lt;Text,VPos&gt;(&quot;-fx-text-origin&quot;,
                 new EnumConverter&lt;VPos&gt;(VPos.class),
                 VPos.BASELINE) {

            @Override
            public boolean isSettable(Text node) {
                return node.attributes == null ||
                       node.attributes.textOrigin == null ||
                      !node.attributes.textOrigin.isBound();
            }

            @Override
            public StyleableProperty&lt;VPos&gt; getStyleableProperty(Text node) {
                return (StyleableProperty&lt;VPos&gt;)node.textOriginProperty();
            }
         };

         private static final CssMetaData&lt;Text,FontSmoothingType&gt;
             FONT_SMOOTHING_TYPE =
             new CssMetaData&lt;Text,FontSmoothingType&gt;(
                 &quot;-fx-font-smoothing-type&quot;,
                 new EnumConverter&lt;FontSmoothingType&gt;(FontSmoothingType.class),
                 FontSmoothingType.GRAY) {

            @Override
            public boolean isSettable(Text node) {
                return node.fontSmoothingType == null ||
                       !node.fontSmoothingType.isBound();
            }

            @Override
            public StyleableProperty&lt;FontSmoothingType&gt;
                                 getStyleableProperty(Text node) {

                return (StyleableProperty&lt;FontSmoothingType&gt;)node.fontSmoothingTypeProperty();
            }
         };

         private static final
             CssMetaData&lt;Text,Number&gt; LINE_SPACING =
                 new CssMetaData&lt;Text,Number&gt;(&quot;-fx-line-spacing&quot;,
                 SizeConverter.getInstance(), 0) {

            @Override
            public boolean isSettable(Text node) {
                return node.attributes == null ||
                       node.attributes.lineSpacing == null ||
                      !node.attributes.lineSpacing.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(Text node) {
                return (StyleableProperty&lt;Number&gt;)node.lineSpacingProperty();
            }
         };

         private static final CssMetaData&lt;Text, TextBoundsType&gt;
             BOUNDS_TYPE =
             new CssMetaData&lt;Text,TextBoundsType&gt;(
                 &quot;-fx-bounds-type&quot;,
                 new EnumConverter&lt;TextBoundsType&gt;(TextBoundsType.class),
                 DEFAULT_BOUNDS_TYPE) {

            @Override
            public boolean isSettable(Text node) {
                return node.boundsType == null || !node.boundsType.isBound();
            }

            @Override
            public StyleableProperty&lt;TextBoundsType&gt; getStyleableProperty(Text node) {
                return (StyleableProperty&lt;TextBoundsType&gt;)node.boundsTypeProperty();
            }
         };

     private final static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
         static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Shape.getClassCssMetaData());
            styleables.add(FONT);
            styleables.add(UNDERLINE);
            styleables.add(STRIKETHROUGH);
            styleables.add(TEXT_ALIGNMENT);
            styleables.add(TEXT_ORIGIN);
            styleables.add(FONT_SMOOTHING_TYPE);
            styleables.add(LINE_SPACING);
            styleables.add(BOUNDS_TYPE);
            STYLEABLES = Collections.unmodifiableList(styleables);
         }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     *
     * @since JavaFX 8.0
     */


    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    @SuppressWarnings(&quot;deprecation&quot;)
    private void updatePGText() {
        final NGText peer = NodeHelper.getPeer(this);
        if (NodeHelper.isDirty(this, DirtyBits.TEXT_ATTRS)) {
            peer.setUnderline(isUnderline());
            peer.setStrikethrough(isStrikethrough());
            FontSmoothingType smoothing = getFontSmoothingType();
            if (smoothing == null) smoothing = FontSmoothingType.GRAY;
            peer.setFontSmoothingType(smoothing.ordinal());
        }
        if (NodeHelper.isDirty(this, DirtyBits.TEXT_FONT)) {
            peer.setFont(getFontInternal());
        }
        if (NodeHelper.isDirty(this, DirtyBits.NODE_CONTENTS)) {
            peer.setGlyphs(getRuns());
        }
        if (NodeHelper.isDirty(this, DirtyBits.NODE_GEOMETRY)) {
            if (isSpan()) {
                BaseBounds spanBounds = getSpanBounds();
                peer.setLayoutLocation(spanBounds.getMinX(), spanBounds.getMinY());
            } else {
                float x = (float)getX();
                float y = (float)getY();
                float yadj = getYRendering();
                peer.setLayoutLocation(-x, yadj - y);
            }
        }
        if (NodeHelper.isDirty(this, DirtyBits.TEXT_SELECTION)) {
            Object fillObj = null;
            int start = getSelectionStart();
            int end = getSelectionEnd();
            int length = getTextInternal().length();
            if (0 &lt;= start &amp;&amp; start &lt; end  &amp;&amp; end &lt;= length) {
                Paint fill = selectionFillProperty().get();
                fillObj = fill != null ? Toolkit.getPaintAccessor().getPlatformPaint(fill) : null;
            }
            peer.setSelection(start, end, fillObj);
        }
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        updatePGText();
    }

    /***************************************************************************
     *                                                                         *
     *                       Seldom Used Properties                            *
     *                                                                         *
     **************************************************************************/

    private TextAttribute attributes;

    private TextAttribute getTextAttribute() {
        if (attributes == null) {
            attributes = new TextAttribute();
        }
        return attributes;
    }

    private static final VPos DEFAULT_TEXT_ORIGIN = VPos.BASELINE;
    private static final TextBoundsType DEFAULT_BOUNDS_TYPE = TextBoundsType.LOGICAL;
    private static final boolean DEFAULT_UNDERLINE = false;
    private static final boolean DEFAULT_STRIKETHROUGH = false;
    private static final TextAlignment DEFAULT_TEXT_ALIGNMENT = TextAlignment.LEFT;
    private static final double DEFAULT_LINE_SPACING = 0;
    private static final int DEFAULT_CARET_POSITION = -1;
    private static final int DEFAULT_SELECTION_START = -1;
    private static final int DEFAULT_SELECTION_END = -1;
    private static final Color DEFAULT_SELECTION_FILL= Color.WHITE;
    private static final boolean DEFAULT_CARET_BIAS = true;

    private final class TextAttribute {

        private ObjectProperty&lt;VPos&gt; textOrigin;

        final VPos getTextOrigin() {
            return textOrigin == null ? DEFAULT_TEXT_ORIGIN : textOrigin.get();
        }

        public final ObjectProperty&lt;VPos&gt; textOriginProperty() {
            if (textOrigin == null) {
                textOrigin = new StyleableObjectProperty&lt;VPos&gt;(DEFAULT_TEXT_ORIGIN) {
                    @Override public Object getBean() { return Text.this; }
                    @Override public String getName() { return &quot;textOrigin&quot;; }
                    @Override public CssMetaData getCssMetaData() {
                        return StyleableProperties.TEXT_ORIGIN;
                    }
                    @Override public void invalidated() {
                        NodeHelper.geomChanged(Text.this);
                    }
                };
            }
            return textOrigin;
        }

        private BooleanProperty underline;

        final boolean isUnderline() {
            return underline == null ? DEFAULT_UNDERLINE : underline.get();
        }

        final BooleanProperty underlineProperty() {
            if (underline == null) {
                underline = new StyleableBooleanProperty() {
                    @Override public Object getBean() { return Text.this; }
                    @Override public String getName() { return &quot;underline&quot;; }
                    @Override public CssMetaData getCssMetaData() {
                        return StyleableProperties.UNDERLINE;
                    }
                    @Override public void invalidated() {
                        NodeHelper.markDirty(Text.this, DirtyBits.TEXT_ATTRS);
                        if (getBoundsType() == TextBoundsType.VISUAL) {
                            NodeHelper.geomChanged(Text.this);
                        }
                    }
                };
            }
            return underline;
        }

        private BooleanProperty strikethrough;

        final boolean isStrikethrough() {
            return strikethrough == null ? DEFAULT_STRIKETHROUGH : strikethrough.get();
        }

        final BooleanProperty strikethroughProperty() {
            if (strikethrough == null) {
                strikethrough = new StyleableBooleanProperty() {
                    @Override public Object getBean() { return Text.this; }
                    @Override public String getName() { return &quot;strikethrough&quot;; }
                    @Override public CssMetaData getCssMetaData() {
                        return StyleableProperties.STRIKETHROUGH;
                    }
                    @Override public void invalidated() {
                        NodeHelper.markDirty(Text.this, DirtyBits.TEXT_ATTRS);
                        if (getBoundsType() == TextBoundsType.VISUAL) {
                            NodeHelper.geomChanged(Text.this);
                        }
                    }
                };
            }
            return strikethrough;
        }

        private ObjectProperty&lt;TextAlignment&gt; textAlignment;

        final TextAlignment getTextAlignment() {
            return textAlignment == null ? DEFAULT_TEXT_ALIGNMENT : textAlignment.get();
        }

        final ObjectProperty&lt;TextAlignment&gt; textAlignmentProperty() {
            if (textAlignment == null) {
                textAlignment =
                    new StyleableObjectProperty&lt;TextAlignment&gt;(DEFAULT_TEXT_ALIGNMENT) {
                    @Override public Object getBean() { return Text.this; }
                    @Override public String getName() { return &quot;textAlignment&quot;; }
                    @Override public CssMetaData getCssMetaData() {
                        return StyleableProperties.TEXT_ALIGNMENT;
                    }
                    @Override public void invalidated() {
                        if (!isSpan()) {
                            TextAlignment alignment = get();
                            if (alignment == null) {
                                alignment = DEFAULT_TEXT_ALIGNMENT;
                            }
                            TextLayout layout = getTextLayout();
                            if (layout.setAlignment(alignment.ordinal())) {
                                needsTextLayout();
                            }
                        }
                    }
                };
            }
            return textAlignment;
        }

        private DoubleProperty lineSpacing;

        final double getLineSpacing() {
            return lineSpacing == null ? DEFAULT_LINE_SPACING : lineSpacing.get();
        }

        final DoubleProperty lineSpacingProperty() {
            if (lineSpacing == null) {
                lineSpacing =
                    new StyleableDoubleProperty(DEFAULT_LINE_SPACING) {
                    @Override public Object getBean() { return Text.this; }
                    @Override public String getName() { return &quot;lineSpacing&quot;; }
                    @Override public CssMetaData getCssMetaData() {
                        return StyleableProperties.LINE_SPACING;
                    }
                    @Override public void invalidated() {
                        if (!isSpan()) {
                            TextLayout layout = getTextLayout();
                            if (layout.setLineSpacing((float)get())) {
                                needsTextLayout();
                            }
                        }
                    }
                };
            }
            return lineSpacing;
        }

        private ReadOnlyDoubleWrapper baselineOffset;

        final ReadOnlyDoubleProperty baselineOffsetProperty() {
            if (baselineOffset == null) {
                baselineOffset = new ReadOnlyDoubleWrapper(Text.this, &quot;baselineOffset&quot;) {
                    {bind(new DoubleBinding() {
                        {bind(fontProperty());}
                        @Override protected double computeValue() {
                            /* This method should never be used for spans.
                             * If it is, it will still returns the ascent
                             * for the first line in the layout */
                            BaseBounds bounds = getLogicalBounds();
                            return -bounds.getMinY();
                        }
                    });}
                };
            }
            return baselineOffset.getReadOnlyProperty();
        }

        private ObjectProperty&lt;PathElement[]&gt; selectionShape;
        private ObjectBinding&lt;PathElement[]&gt; selectionBinding;

        final ReadOnlyObjectProperty&lt;PathElement[]&gt; selectionShapeProperty() {
            if (selectionShape == null) {
                selectionBinding = new ObjectBinding&lt;PathElement[]&gt;() {
                    {bind(selectionStartProperty(), selectionEndProperty());}
                    @Override protected PathElement[] computeValue() {
                        int start = getSelectionStart();
                        int end = getSelectionEnd();
                        return getRange(start, end, TextLayout.TYPE_TEXT);
                    }
              };
              selectionShape = new SimpleObjectProperty&lt;PathElement[]&gt;(Text.this, &quot;selectionShape&quot;);
              selectionShape.bind(selectionBinding);
            }
            return selectionShape;
        }

        private ObjectProperty&lt;Paint&gt; selectionFill;

        final ObjectProperty&lt;Paint&gt; selectionFillProperty() {
            if (selectionFill == null) {
                selectionFill =
                    new ObjectPropertyBase&lt;Paint&gt;(DEFAULT_SELECTION_FILL) {
                        @Override public Object getBean() { return Text.this; }
                        @Override public String getName() { return &quot;selectionFill&quot;; }
                        @Override protected void invalidated() {
                            NodeHelper.markDirty(Text.this, DirtyBits.TEXT_SELECTION);
                        }
                    };
            }
            return selectionFill;
        }

        private IntegerProperty selectionStart;

        final int getSelectionStart() {
            return selectionStart == null ? DEFAULT_SELECTION_START : selectionStart.get();
        }

        final IntegerProperty selectionStartProperty() {
            if (selectionStart == null) {
                selectionStart =
                    new IntegerPropertyBase(DEFAULT_SELECTION_START) {
                        @Override public Object getBean() { return Text.this; }
                        @Override public String getName() { return &quot;selectionStart&quot;; }
                        @Override protected void invalidated() {
                            NodeHelper.markDirty(Text.this, DirtyBits.TEXT_SELECTION);
                            notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_START);
                        }
                };
            }
            return selectionStart;
        }

        private IntegerProperty selectionEnd;

        final int getSelectionEnd() {
            return selectionEnd == null ? DEFAULT_SELECTION_END : selectionEnd.get();
        }

        final IntegerProperty selectionEndProperty() {
            if (selectionEnd == null) {
                selectionEnd =
                    new IntegerPropertyBase(DEFAULT_SELECTION_END) {
                        @Override public Object getBean() { return Text.this; }
                        @Override public String getName() { return &quot;selectionEnd&quot;; }
                        @Override protected void invalidated() {
                            NodeHelper.markDirty(Text.this, DirtyBits.TEXT_SELECTION);
                            notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_END);
                        }
                    };
            }
            return selectionEnd;
        }

        private ObjectProperty&lt;PathElement[]&gt; caretShape;
        private ObjectBinding&lt;PathElement[]&gt; caretBinding;

        final ReadOnlyObjectProperty&lt;PathElement[]&gt; caretShapeProperty() {
            if (caretShape == null) {
                caretBinding = new ObjectBinding&lt;PathElement[]&gt;() {
                    {bind(caretPositionProperty(), caretBiasProperty());}
                    @Override protected PathElement[] computeValue() {
                        int pos = getCaretPosition();
                        int length = getTextInternal().length();
                        if (0 &lt;= pos &amp;&amp; pos &lt;= length) {
                            boolean bias = isCaretBias();
                            float x = (float)getX();
                            float y = (float)getY() - getYRendering();
                            TextLayout layout = getTextLayout();
                            return layout.getCaretShape(pos, bias, x, y);
                        }
                        return EMPTY_PATH_ELEMENT_ARRAY;
                    }
                };
                caretShape = new SimpleObjectProperty&lt;PathElement[]&gt;(Text.this, &quot;caretShape&quot;);
                caretShape.bind(caretBinding);
            }
            return caretShape;
        }

        private IntegerProperty caretPosition;

        final int getCaretPosition() {
            return caretPosition == null ? DEFAULT_CARET_POSITION : caretPosition.get();
        }

        final IntegerProperty caretPositionProperty() {
            if (caretPosition == null) {
                caretPosition =
                    new IntegerPropertyBase(DEFAULT_CARET_POSITION) {
                        @Override public Object getBean() { return Text.this; }
                        @Override public String getName() { return &quot;caretPosition&quot;; }
                        @Override protected void invalidated() {
                            notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_END);
                        }
                    };
            }
            return caretPosition;
        }

        private BooleanProperty caretBias;

        final boolean isCaretBias() {
            return caretBias == null ? DEFAULT_CARET_BIAS : caretBias.get();
        }

        final BooleanProperty caretBiasProperty() {
            if (caretBias == null) {
                caretBias =
                        new SimpleBooleanProperty(Text.this, &quot;caretBias&quot;, DEFAULT_CARET_BIAS);
            }
            return caretBias;
        }
    }

    /**
     * Returns a string representation of this {@code Text} object.
     * @return a string representation of this {@code Text} object.
     */
    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder(&quot;Text[&quot;);

        String id = getId();
        if (id != null) {
            sb.append(&quot;id=&quot;).append(id).append(&quot;, &quot;);
        }

        sb.append(&quot;text=\&quot;&quot;).append(getText()).append(&quot;\&quot;&quot;);
        sb.append(&quot;, x=&quot;).append(getX());
        sb.append(&quot;, y=&quot;).append(getY());
        sb.append(&quot;, alignment=&quot;).append(getTextAlignment());
        sb.append(&quot;, origin=&quot;).append(getTextOrigin());
        sb.append(&quot;, boundsType=&quot;).append(getBoundsType());

        double spacing = getLineSpacing();
        if (spacing != DEFAULT_LINE_SPACING) {
            sb.append(&quot;, lineSpacing=&quot;).append(spacing);
        }

        double wrap = getWrappingWidth();
        if (wrap != 0) {
            sb.append(&quot;, wrappingWidth=&quot;).append(wrap);
        }

        sb.append(&quot;, font=&quot;).append(getFont());
        sb.append(&quot;, fontSmoothingType=&quot;).append(getFontSmoothingType());

        if (isStrikethrough()) {
            sb.append(&quot;, strikethrough&quot;);
        }
        if (isUnderline()) {
            sb.append(&quot;, underline&quot;);
        }

        sb.append(&quot;, fill=&quot;).append(getFill());

        Paint stroke = getStroke();
        if (stroke != null) {
            sb.append(&quot;, stroke=&quot;).append(stroke);
            sb.append(&quot;, strokeWidth=&quot;).append(getStrokeWidth());
        }

        return sb.append(&quot;]&quot;).toString();
    }

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case TEXT: {
                String accText = getAccessibleText();
                if (accText != null &amp;&amp; !accText.isEmpty()) return accText;
                return getText();
            }
            case FONT: return getFont();
            case CARET_OFFSET: {
                int sel = getCaretPosition();
                if (sel &gt;=  0) return sel;
                return getText().length();
            }
            case SELECTION_START: {
                int sel = getSelectionStart();
                if (sel &gt;=  0) return sel;
                sel = getCaretPosition();
                if (sel &gt;=  0) return sel;
                return getText().length();
            }
            case SELECTION_END:  {
                int sel = getSelectionEnd();
                if (sel &gt;=  0) return sel;
                sel = getCaretPosition();
                if (sel &gt;=  0) return sel;
                return getText().length();
            }
            case LINE_FOR_OFFSET: {
                int offset = (Integer)parameters[0];
                if (offset &gt; getTextInternal().length()) return null;
                TextLine[] lines = getTextLayout().getLines();
                int lineIndex = 0;
                for (int i = 1; i &lt; lines.length; i++) {
                    TextLine line = lines[i];
                    if (line.getStart() &gt; offset) break;
                    lineIndex++;
                }
                return lineIndex;
            }
            case LINE_START: {
                int lineIndex = (Integer)parameters[0];
                TextLine[] lines = getTextLayout().getLines();
                if (0 &lt;= lineIndex &amp;&amp; lineIndex &lt; lines.length) {
                    TextLine line = lines[lineIndex];
                    return line.getStart();
                }
                return null;
            }
            case LINE_END: {
                int lineIndex = (Integer)parameters[0];
                TextLine[] lines = getTextLayout().getLines();
                if (0 &lt;= lineIndex &amp;&amp; lineIndex &lt; lines.length) {
                    TextLine line = lines[lineIndex];
                    return line.getStart() + line.getLength();
                }
                return null;
            }
            case OFFSET_AT_POINT: {
                Point2D point = (Point2D)parameters[0];
                point = screenToLocal(point);
                return hitTest(point).getCharIndex();
            }
            case BOUNDS_FOR_RANGE: {
                int start = (Integer)parameters[0];
                int end = (Integer)parameters[1];
                PathElement[] elements = rangeShape(start, end + 1);
                /* Each bounds is defined by a MoveTo (top-left) followed by
                 * 4 LineTo (to top-right, bottom-right, bottom-left, back to top-left).
                 */
                Bounds[] bounds = new Bounds[elements.length / 5];
                int index = 0;
                for (int i = 0; i &lt; bounds.length; i++) {
                    MoveTo topLeft = (MoveTo)elements[index];
                    LineTo topRight = (LineTo)elements[index+1];
                    LineTo bottomRight = (LineTo)elements[index+2];
                    BoundingBox b = new BoundingBox(topLeft.getX(), topLeft.getY(),
                                                    topRight.getX() - topLeft.getX(),
                                                    bottomRight.getY() - topRight.getY());
                    bounds[i] = localToScreen(b);
                    index += 5;
                }
                return bounds;
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/transform/Affine.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.transform;


import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.geometry.Point2D;
import javafx.geometry.Point3D;

// PENDING_DOC_REVIEW of this whole class
/**
 * &lt;p&gt;
 * The {@code Affine} class represents a general affine transform. An affine
 * transform performs a linear mapping from 2D/3D coordinates to other 2D/3D
 * coordinates while preserving the &quot;straightness&quot; and &quot;parallelness&quot;
 * of lines.
 * Affine transformations can be constructed using sequence rotations,
 * translations, scales, and shears.&lt;/p&gt;
 *
 * &lt;p&gt;
 * For simple transformations application developers should use the
 * specific {@code Translate}, {@code Scale}, {@code Rotate}, or {@code Shear}
 * transforms, which are more lightweight and thus more optimal for this simple
 * purpose. The {@code Affine} class, on the other hand, has the advantage
 * of being able to represent a general affine transform and perform matrix
 * operations on it in place, so it fits better for more complex transformation
 * usages.&lt;/p&gt;

 * &lt;p&gt;
 * Such a coordinate transformation can be represented by a 3 row by
 * 4 column matrix. This matrix transforms source coordinates {@code (x,y,z)}
 * into destination coordinates {@code (x',y',z')} by considering
 * them to be a column vector and multiplying the coordinate vector
 * by the matrix according to the following process:&lt;/p&gt;
 *
 * &lt;pre&gt;
 *      [ x']   [  mxx  mxy  mxz  tx  ] [ x ]   [ mxx * x + mxy * y + mxz * z + tx ]
 *      [ y'] = [  myx  myy  myz  ty  ] [ y ] = [ myx * x + myy * y + myz * z + ty ]
 *      [ z']   [  mzx  mzy  mzz  tz  ] [ z ]   [ mzx * x + mzy * y + mzz * z + tz ]
 *                                      [ 1 ]
 * &lt;/pre&gt;
 * @since JavaFX 2.0
 */
public class Affine extends Transform {

    /**
     * Tracks atomic changes of more elements.
     */
    AffineAtomicChange atomicChange = new AffineAtomicChange();

    /**
     * This constant is used for the internal state2d variable to indicate
     * that no calculations need to be performed and that the source
     * coordinates only need to be copied to their destinations to
     * complete the transformation equation of this transform.
     * @see #state2d
     */
    private static final int APPLY_IDENTITY = 0;

    /**
     * This constant is used for the internal state2d and state3d variables
     * that the translation components of the matrix need to be added
     * to complete the transformation equation of this transform.
     * @see #state2d
     * @see #state3d
     */
    private static final int APPLY_TRANSLATE = 1;

    /**
     * This constant is used for the internal state2d and state3d variables
     * to indicate that the scaling components of the matrix need
     * to be factored in to complete the transformation equation of
     * this transform. If the APPLY_SHEAR bit is also set then it
     * indicates that the scaling components are 0.0.  If the
     * APPLY_SHEAR bit is not also set then it indicates that the
     * scaling components are not 1.0. If neither the APPLY_SHEAR
     * nor the APPLY_SCALE bits are set then the scaling components
     * are 1.0, which means that the x and y components contribute
     * to the transformed coordinate, but they are not multiplied by
     * any scaling factor.
     * @see #state2d
     * @see #state3d
     */
    private static final int APPLY_SCALE = 2;

    /**
     * This constant is used for the internal state2d variable to indicate
     * that the shearing components of the matrix (mxy and myx) need
     * to be factored in to complete the transformation equation of this
     * transform.  The presence of this bit in the state variable changes
     * the interpretation of the APPLY_SCALE bit as indicated in its
     * documentation.
     * @see #state2d
     */
    private static final int APPLY_SHEAR = 4;

    /**
     * This constant is used for the internal state3d variable to indicate
     * that the matrix represents a 2D-only transform.
     */
    private static final int APPLY_NON_3D = 0;

    /**
     * This constant is used for the internal state3d variable to indicate
     * that the matrix is not in any of the recognized simple states
     * and therefore needs a full usage of all elements to complete
     * the transformation equation of this transform.
     */
    private static final int APPLY_3D_COMPLEX = 4;

    /**
     * If this is a 2D transform, this field keeps track of which components
     * of the matrix need to be applied when performing a transformation.
     * If this is a 3D transform, its state is store in the state3d variable
     * and value of state2d is undefined.
     * @see #APPLY_IDENTITY
     * @see #APPLY_TRANSLATE
     * @see #APPLY_SCALE
     * @see #APPLY_SHEAR
     * @see #state3d
     * @see #updateState()
     */
    private transient int state2d;

    /**
     * This field keeps track of whether or not this transform is 3D and if so
     * it tracks several simple states that can be treated faster. If the state
     * is equal to APPLY_NON_3D, this is a 2D transform with its state stored
     * in the state2d variable. If the state is equal to APPLY_3D_COMPLEX,
     * the matrix is not in any of the simple states and needs to be fully
     * processed. Otherwise we recognize scale (mxx, myy and mzz
     * are not all equal to 1.0), translation (tx, ty and tz are not all
     * equal to 0.0) and their combination. In one of the simple states
     * all of the other elements of the matrix are equal to 0.0 (not even
     * shear is allowed).
     * @see #APPLY_NON_3D
     * @see #APPLY_TRANSLATE
     * @see #APPLY_SCALE
     * @see #APPLY_3D_COMPLEX
     * @see #state2d
     * @see #updateState()
     */
    private transient int state3d;

    // Variables used for the elements until user requests creation
    // of the heavy-weight properties
    private double xx;
    private double xy;
    private double xz;
    private double yx;
    private double yy;
    private double yz;
    private double zx;
    private double zy;
    private double zz;
    private double xt;
    private double yt;
    private double zt;

    /**
     * Creates a new instance of {@code Affine} containing an identity transform.
     */
    public Affine() {
        xx = yy = zz = 1.0;
    }

    /**
     * Creates a new instance of {@code Affine} filled with the values from
     * the specified transform.
     * @param transform transform whose matrix is to be filled to the new
     *        instance
     * @throws NullPointerException if the specified {@code transform} is null
     * @since JavaFX 8.0
     */
    public Affine(Transform transform) {
        this(transform.getMxx(), transform.getMxy(), transform.getMxz(),
                                                             transform.getTx(),
             transform.getMyx(), transform.getMyy(), transform.getMyz(),
                                                             transform.getTy(),
             transform.getMzx(), transform.getMzy(), transform.getMzz(),
                                                             transform.getTz());
    }

    /**
     * Creates a new instance of {@code Affine} with a 2D transform specified
     * by the element values.
     * @param mxx the X coordinate scaling element
     * @param mxy the XY coordinate element
     * @param tx the X coordinate translation element
     * @param myx the YX coordinate element
     * @param myy the Y coordinate scaling element
     * @param ty the Y coordinate translation element
     * @since JavaFX 8.0
     */
    public Affine(double mxx, double mxy, double tx,
                  double myx, double myy, double ty) {
        xx = mxx;
        xy = mxy;
        xt = tx;

        yx = myx;
        yy = myy;
        yt = ty;

        zz = 1.0;

        updateState2D();
    }

    /**
     * Creates a new instance of {@code Affine} with a transform specified
     * by the element values.
     * @param mxx the X coordinate scaling element
     * @param mxy the XY coordinate element
     * @param mxz the XZ coordinate element
     * @param tx the X coordinate translation element
     * @param myx the YX coordinate element
     * @param myy the Y coordinate scaling element
     * @param myz the YZ coordinate element
     * @param ty the Y coordinate translation element
     * @param mzx the ZX coordinate element
     * @param mzy the ZY coordinate element
     * @param mzz the Z coordinate scaling element
     * @param tz the Z coordinate translation element
     * @since JavaFX 8.0
     */
    public Affine(double mxx, double mxy, double mxz, double tx,
                  double myx, double myy, double myz, double ty,
                  double mzx, double mzy, double mzz, double tz) {
        xx = mxx;
        xy = mxy;
        xz = mxz;
        xt = tx;

        yx = myx;
        yy = myy;
        yz = myz;
        yt = ty;

        zx = mzx;
        zy = mzy;
        zz = mzz;
        zt = tz;

        updateState();
    }

    /**
     * Creates a new instance of {@code Affine} with a transformation matrix
     * specified by an array.
     * @param matrix array containing the flattened transformation matrix
     * @param type type of matrix contained in the array
     * @param offset offset of the first element in the array
     * @throws IndexOutOfBoundsException if the array is too short for
     *         the specified {@code type} and {@code offset}
     * @throws IllegalArgumentException if the specified matrix is not affine
     *         (the last line of a 2D 3x3 matrix is not {@code [0, 0, 1]} or
     *          the last line of a 3D 4x4 matrix is not {@code [0, 0, 0, 1]}.
     * @throws NullPointerException if the specified {@code matrix}
     *         or {@code type} is null
     * @since JavaFX 8.0
     */
    public Affine(double[] matrix, MatrixType type, int offset) {
        if (matrix.length &lt; offset + type.elements()) {
            throw new IndexOutOfBoundsException(&quot;The array is too short.&quot;);
        }

        switch(type) {
            default:
                stateError();
                // cannot reach
            case MT_2D_3x3:
                if (matrix[offset + 6] != 0.0 ||
                        matrix[offset + 7] != 0.0 ||
                        matrix[offset + 8] != 1.0) {
                    throw new IllegalArgumentException(&quot;The matrix is &quot;
                            + &quot;not affine&quot;);
                }
                // fall-through
            case MT_2D_2x3:
                xx = matrix[offset++];
                xy = matrix[offset++];
                xt = matrix[offset++];
                yx = matrix[offset++];
                yy = matrix[offset++];
                yt = matrix[offset];
                zz = 1.0;
                updateState2D();
                return;
            case MT_3D_4x4:
                if (matrix[offset + 12] != 0.0 ||
                        matrix[offset + 13] != 0.0 ||
                        matrix[offset + 14] != 0.0 ||
                        matrix[offset + 15] != 1.0) {
                    throw new IllegalArgumentException(&quot;The matrix is &quot;
                            + &quot;not affine&quot;);
                }
                // fall-through
            case MT_3D_3x4:
                xx = matrix[offset++];
                xy = matrix[offset++];
                xz = matrix[offset++];
                xt = matrix[offset++];
                yx = matrix[offset++];
                yy = matrix[offset++];
                yz = matrix[offset++];
                yt = matrix[offset++];
                zx = matrix[offset++];
                zy = matrix[offset++];
                zz = matrix[offset++];
                zt = matrix[offset];
                updateState();
                return;
        }
    }

    /**
     * Defines the X coordinate scaling element of the 3x4 matrix.
     */
    private AffineElementProperty mxx;


    public final void setMxx(double value) {
        if (mxx == null) {
            if (xx != value) {
                xx = value;
                postProcessChange();
            }
        } else {
            mxxProperty().set(value);
        }
    }

    @Override
    public final double getMxx() {
        return mxx == null ? xx : mxx.get();
    }

    public final DoubleProperty mxxProperty() {
        if (mxx == null) {
            mxx = new AffineElementProperty(xx) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;mxx&quot;;
                }
            };
        }
        return mxx;
    }

    /**
     * Defines the XY coordinate element of the 3x4 matrix.
     */
    private AffineElementProperty mxy;


    public final void setMxy(double value) {
        if (mxy == null) {
            if (xy != value) {
                xy = value;
                postProcessChange();
            }
        } else {
            mxyProperty().set(value);
        }
    }

    @Override
    public final double getMxy() {
        return mxy == null ? xy : mxy.get();
    }

    public final DoubleProperty mxyProperty() {
        if (mxy == null) {
            mxy = new AffineElementProperty(xy) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;mxy&quot;;
                }
            };
        }
        return mxy;
    }

    /**
     * Defines the XZ coordinate element of the 3x4 matrix.
     */
    private AffineElementProperty mxz;


    public final void setMxz(double value) {
        if (mxz == null) {
            if (xz != value) {
                xz = value;
                postProcessChange();
            }
        } else {
            mxzProperty().set(value);
        }
    }

    @Override
    public final double getMxz() {
        return mxz == null ? xz : mxz.get();
    }

    public final DoubleProperty mxzProperty() {
        if (mxz == null) {
            mxz = new AffineElementProperty(xz) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;mxz&quot;;
                }
            };
        }
        return mxz;
    }

    /**
     * Defines the X coordinate translation element of the 3x4 matrix.
     */
    private AffineElementProperty tx;


    public final void setTx(double value) {
        if (tx == null) {
            if (xt != value) {
                xt = value;
                postProcessChange();
            }
        } else {
            txProperty().set(value);
        }
    }

    @Override
    public final double getTx() {
        return tx == null ? xt : tx.get();
    }

    public final DoubleProperty txProperty() {
        if (tx == null) {
            tx = new AffineElementProperty(xt) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;tx&quot;;
                }
            };
        }
        return tx;
    }

    /**
     * Defines the YX coordinate element of the 3x4 matrix.
     */
    private AffineElementProperty myx;


    public final void setMyx(double value) {
        if (myx == null) {
            if (yx != value) {
                yx = value;
                postProcessChange();
            }
        } else {
            myxProperty().set(value);
        }
    }

    @Override
    public final double getMyx() {
        return myx == null ? yx : myx.get();
    }

    public final DoubleProperty myxProperty() {
        if (myx == null) {
            myx = new AffineElementProperty(yx) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;myx&quot;;
                }
            };
        }
        return myx;
    }

    /**
     * Defines the Y coordinate scaling element of the 3x4 matrix.
     */
    private AffineElementProperty myy;


    public final void setMyy(double value) {
        if (myy == null) {
            if (yy != value) {
                yy = value;
                postProcessChange();
            }
        } else{
            myyProperty().set(value);
        }
    }

    @Override
    public final double getMyy() {
        return myy == null ? yy : myy.get();
    }

    public final DoubleProperty myyProperty() {
        if (myy == null) {
            myy = new AffineElementProperty(yy) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;myy&quot;;
                }
            };
        }
        return myy;
    }

    /**
     * Defines the YZ coordinate element of the 3x4 matrix.
     */
    private AffineElementProperty myz;


    public final void setMyz(double value) {
        if (myz == null) {
            if (yz != value) {
                yz = value;
                postProcessChange();
            }
        } else {
            myzProperty().set(value);
        }
    }

    @Override
    public final double getMyz() {
        return myz == null ? yz : myz.get();
    }

    public final DoubleProperty myzProperty() {
        if (myz == null) {
            myz = new AffineElementProperty(yz) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;myz&quot;;
                }
            };
        }
        return myz;
    }

    /**
     * Defines the Y coordinate translation element of the 3x4 matrix.
     */
    private AffineElementProperty ty;


    public final void setTy(double value) {
        if (ty == null) {
            if (yt != value) {
                yt = value;
                postProcessChange();
            }
        } else {
            tyProperty().set(value);
        }
    }

    @Override
    public final double getTy() {
        return ty == null ? yt : ty.get();
    }

    public final DoubleProperty tyProperty() {
        if (ty == null) {
            ty = new AffineElementProperty(yt) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;ty&quot;;
                }
            };
        }
        return ty;
    }

    /**
     * Defines the ZX coordinate element of the 3x4 matrix.
     */
    private AffineElementProperty mzx;


    public final void setMzx(double value) {
        if (mzx == null) {
            if (zx != value) {
                zx = value;
                postProcessChange();
            }
        } else {
            mzxProperty().set(value);
        }
    }

    @Override
    public final double getMzx() {
        return mzx == null ? zx : mzx.get();
    }

    public final DoubleProperty mzxProperty() {
        if (mzx == null) {
            mzx = new AffineElementProperty(zx) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;mzx&quot;;
                }
            };
        }
        return mzx;
    }

    /**
     * Defines the ZY coordinate element of the 3x4 matrix.
     */
    private AffineElementProperty mzy;


    public final void setMzy(double value) {
        if (mzy == null) {
            if (zy != value) {
                zy = value;
                postProcessChange();
            }
        } else {
            mzyProperty().set(value);
        }
    }

    @Override
    public final double getMzy() {
        return mzy == null ? zy : mzy.get();
    }

    public final DoubleProperty mzyProperty() {
        if (mzy == null) {
            mzy = new AffineElementProperty(zy) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;mzy&quot;;
                }
            };
        }
        return mzy;
    }

    /**
     * Defines the Z coordinate scaling element of the 3x4 matrix.
     */
    private AffineElementProperty mzz;


    public final void setMzz(double value) {
        if (mzz == null) {
            if (zz != value) {
                zz = value;
                postProcessChange();
            }
        } else {
            mzzProperty().set(value);
        }
    }

    @Override
    public final double getMzz() {
        return mzz == null ? zz : mzz.get();
    }

    public final DoubleProperty mzzProperty() {
        if (mzz == null) {
            mzz = new AffineElementProperty(zz) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;mzz&quot;;
                }
            };
        }
        return mzz;
    }

    /**
     * Defines the Z coordinate translation element of the 3x4 matrix.
     */
    private AffineElementProperty tz;


    public final void setTz(double value) {
        if (tz == null) {
            if (zt != value) {
                zt = value;
                postProcessChange();
            }
        } else {
            tzProperty().set(value);
        }
    }

    @Override
    public final double getTz() {
        return tz == null ? zt : tz.get();
    }

    public final DoubleProperty tzProperty() {
        if (tz == null) {
            tz = new AffineElementProperty(zt) {
                @Override
                public Object getBean() {
                    return Affine.this;
                }

                @Override
                public String getName() {
                    return &quot;tz&quot;;
                }
            };
        }
        return tz;
    }

    /**
     * Sets the specified element of the transformation matrix.
     * @param type type of matrix to work with
     * @param row zero-based row number
     * @param column zero-based column number
     * @param value new value of the specified transformation matrix element
     * @throws IndexOutOfBoundsException if the indices are not within
     *         the specified matrix type
     * @throws IllegalArgumentException if setting the value would break
     *         transform's affinity (for convenience the method allows to set
     *         the elements of the last line of a 2D 3x3 matrix to
     *         {@code [0, 0, 1]} and the elements of the last line
     *         of a 3D 4x4 matrix to {@code [0, 0, 0, 1]}).
     * @throws NullPointerException if the specified {@code type} is null
     * @since JavaFX 8.0
     */
    public void setElement(MatrixType type, int row, int column, double value) {
        if (row &lt; 0 || row &gt;= type.rows() ||
                column &lt; 0 || column &gt;= type.columns()) {
            throw new IndexOutOfBoundsException(&quot;Index outside of affine &quot;
                    + &quot;matrix &quot; + type + &quot;: [&quot; + row + &quot;, &quot; + column + &quot;]&quot;);
        }
        switch(type) {
            default:
                stateError();
                // cannot reach
            case MT_2D_2x3:
                // fall-through
            case MT_2D_3x3:
                if (!isType2D()) {
                    throw new IllegalArgumentException(&quot;Cannot access 2D matrix &quot;
                            + &quot;of a 3D transform&quot;);
                }
                switch(row) {
                    case 0:
                        switch(column) {
                            case 0: setMxx(value); return;
                            case 1: setMxy(value); return;
                            case 2: setTx(value); return;
                        }
                    case 1:
                        switch(column) {
                            case 0: setMyx(value); return;
                            case 1: setMyy(value); return;
                            case 2: setTy(value); return;
                        }
                    case 2:
                        switch(column) {
                            case 0: if (value == 0.0) return; else break;
                            case 1: if (value == 0.0) return; else break;
                            case 2: if (value == 1.0) return; else break;
                        }
                }
                break;
            case MT_3D_3x4:
                // fall-through
            case MT_3D_4x4:
                switch(row) {
                    case 0:
                        switch(column) {
                            case 0: setMxx(value); return;
                            case 1: setMxy(value); return;
                            case 2: setMxz(value); return;
                            case 3: setTx(value); return;
                        }
                    case 1:
                        switch(column) {
                            case 0: setMyx(value); return;
                            case 1: setMyy(value); return;
                            case 2: setMyz(value); return;
                            case 3: setTy(value); return;
                        }
                    case 2:
                        switch(column) {
                            case 0: setMzx(value); return;
                            case 1: setMzy(value); return;
                            case 2: setMzz(value); return;
                            case 3: setTz(value); return;
                        }
                    case 3:
                        switch(column) {
                            case 0: if (value == 0.0) return; else break;
                            case 1: if (value == 0.0) return; else break;
                            case 2: if (value == 0.0) return; else break;
                            case 3: if (value == 1.0) return; else break;
                        }
                }
                break;
        }
        // reaches here when last line is set to something else than 0 .. 0 1
        throw new IllegalArgumentException(&quot;Cannot set affine matrix &quot; + type +
                &quot; element &quot; + &quot;[&quot; + row + &quot;, &quot; + column + &quot;] to &quot; + value);
    }

    /**
     * Affine element property which handles the atomic changes of more
     * properties.
     */
    private class AffineElementProperty extends SimpleDoubleProperty {

        private boolean needsValueChangedEvent = false;
        private double oldValue;

        public AffineElementProperty(double initialValue) {
            super(initialValue);
        }

        @Override
        public void invalidated() {
            // if an atomic change runs, postpone the change notifications
            if (!atomicChange.runs()) {
                updateState();
                transformChanged();
            }
        }

        @Override
        protected void fireValueChangedEvent() {
            // if an atomic change runs, postpone the change notifications
            if (!atomicChange.runs()) {
                super.fireValueChangedEvent();
            } else {
                needsValueChangedEvent = true;
            }
        }

        /**
         * Called before an atomic change
         */
        private void preProcessAtomicChange() {
            // remember the value before an atomic change
            oldValue = get();
        }

        /**
         * Called after an atomic change
         */
        private void postProcessAtomicChange() {
            // if there was a change notification  during the atomic change,
            // fire it now
            if (needsValueChangedEvent) {
                needsValueChangedEvent = false;
                // the value might have change back an forth
                // (happens quite commonly for transforms with pivot)
                if (oldValue != get()) {
                    super.fireValueChangedEvent();
                }
            }
        }
    }

    /**
     * Called by each element property after value change to
     * update the state variables and call transform change notifications.
     * If an atomic change runs, this is a NOP and the work is done
     * in the end of the entire atomic change.
     */
    private void postProcessChange() {
        if (!atomicChange.runs()) {
            updateState();
            transformChanged();
        }
    }

    /* *************************************************************************
     *                                                                         *
     *                           State getters                                 *
     *                                                                         *
     **************************************************************************/

    @Override
    boolean computeIs2D() {
        return (state3d == APPLY_NON_3D);
    }

    @Override
    boolean computeIsIdentity() {
        return state3d == APPLY_NON_3D &amp;&amp; state2d == APPLY_IDENTITY;
    }

    @Override
    public double determinant() {
        if (state3d == APPLY_NON_3D) {
            return getDeterminant2D();
        } else {
            return getDeterminant3D();
        }
    }

    /**
     * 2D implementation of {@code determinant()}.
     * The behavior is undefined if this is a 3D transform.
     * @return determinant
     */
    private double getDeterminant2D() {
        // assert(state3d == APPLY_NON_3D)
        switch (state2d) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SHEAR | APPLY_SCALE:
                return getMxx() * getMyy() - getMxy() * getMyx();
            case APPLY_SHEAR | APPLY_TRANSLATE:
            case APPLY_SHEAR:
                return -(getMxy() * getMyx());
            case APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SCALE:
                return getMxx() * getMyy();
            case APPLY_TRANSLATE:
            case APPLY_IDENTITY:
                return 1.0;
        }
    }

    /**
     * 3D implementation of {@code determinant()}.
     * The behavior is undefined if this is a 2D transform.
     * @return determinant
     */
    private double getDeterminant3D() {
        // assert(state3d != APPLY_NON_3D)
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_TRANSLATE:
                return 1.0;
            case APPLY_SCALE:
            case APPLY_SCALE | APPLY_TRANSLATE:
                return getMxx() * getMyy() * getMzz();
            case APPLY_3D_COMPLEX:
                final double myx = getMyx();
                final double myy = getMyy();
                final double myz = getMyz();
                final double mzx = getMzx();
                final double mzy = getMzy();
                final double mzz = getMzz();

                return (getMxx() * (myy * mzz - mzy * myz) +
                        getMxy() * (myz * mzx - mzz * myx) +
                        getMxz() * (myx * mzy - mzx * myy));
        }
    }

    /* *************************************************************************
     *                                                                         *
     *                         Transform creators                              *
     *                                                                         *
     **************************************************************************/

    @Override
    public Transform createConcatenation(Transform transform) {
        Affine a = clone();
        a.append(transform);
        return a;
    }

    @Override
    public Affine createInverse() throws NonInvertibleTransformException {
        Affine t = clone();
        t.invert();
        return t;
    }

    @Override
    public Affine clone() {
        return new Affine(this);
    }

    /* *************************************************************************
     *                                                                         *
     *                           Matrix setters                                *
     *                                                                         *
     **************************************************************************/

    /**
     * Sets the values of this instance to the values provided by the specified
     * transform.
     * @param transform transform whose matrix is to be filled to this instance
     * @throws NullPointerException if the specified {@code transform} is null
     * @since JavaFX 8.0
     */
    public void setToTransform(Transform transform) {
        setToTransform(
                transform.getMxx(), transform.getMxy(),
                                         transform.getMxz(), transform.getTx(),
                transform.getMyx(), transform.getMyy(),
                                         transform.getMyz(), transform.getTy(),
                transform.getMzx(), transform.getMzy(),
                                         transform.getMzz(), transform.getTz());
    }

    /**
     * Sets the values of this instance to the 2D transform specified
     * by the element values.
     * @param mxx the X coordinate scaling element
     * @param mxy the XY coordinate element
     * @param tx the X coordinate translation element
     * @param myx the YX coordinate element
     * @param myy the Y coordinate scaling element
     * @param ty the Y coordinate translation element
     * @since JavaFX 8.0
     */
    public void setToTransform(double mxx, double mxy, double tx,
                               double myx, double myy, double ty) {
        setToTransform(mxx, mxy, 0.0, tx,
                myx, myy, 0.0, ty,
                0.0, 0.0, 1.0, 0.0);
    }

    /**
     * Sets the values of this instance to the transform specified
     * by the element values.
     * @param mxx the X coordinate scaling element
     * @param mxy the XY coordinate element
     * @param mxz the XZ coordinate element
     * @param tx the X coordinate translation element
     * @param myx the YX coordinate element
     * @param myy the Y coordinate scaling element
     * @param myz the YZ coordinate element
     * @param ty the Y coordinate translation element
     * @param mzx the ZX coordinate element
     * @param mzy the ZY coordinate element
     * @param mzz the Z coordinate scaling element
     * @param tz the Z coordinate translation element
     * @since JavaFX 8.0
     */
    public void setToTransform(double mxx, double mxy, double mxz, double tx,
                               double myx, double myy, double myz, double ty,
                               double mzx, double mzy, double mzz, double tz)
    {
        atomicChange.start();

        setMxx(mxx);
        setMxy(mxy);
        setMxz(mxz);
        setTx(tx);

        setMyx(myx);
        setMyy(myy);
        setMyz(myz);
        setTy(ty);

        setMzx(mzx);
        setMzy(mzy);
        setMzz(mzz);
        setTz(tz);

        updateState();
        atomicChange.end();
    }

    /**
     * Sets the values of this instance to the transformation matrix
     * specified by an array.
     * @param matrix array containing the flattened transformation matrix
     * @param type type of matrix contained in the array
     * @param offset offset of the first element in the array
     * @throws IndexOutOfBoundsException if the array is too short for
     *         the specified {@code type} and {@code offset}
     * @throws IllegalArgumentException if the specified matrix is not affine
     *         (the last line of a 2D 3x3 matrix is not {@code [0, 0, 1]} or
     *          the last line of a 3D 4x4 matrix is not {@code [0, 0, 0, 1]}.
     * @throws NullPointerException if the specified {@code matrix}
     *         or {@code type} is null
     * @since JavaFX 8.0
     */
    public void setToTransform(double[] matrix, MatrixType type, int offset) {
        if (matrix.length &lt; offset + type.elements()) {
            throw new IndexOutOfBoundsException(&quot;The array is too short.&quot;);
        }

        switch(type) {
            default:
                stateError();
                // cannot reach
            case MT_2D_3x3:
                if (matrix[offset + 6] != 0.0 ||
                        matrix[offset + 7] != 0.0 ||
                        matrix[offset + 8] != 1.0) {
                    throw new IllegalArgumentException(&quot;The matrix is &quot;
                            + &quot;not affine&quot;);
                }
                // fall-through
            case MT_2D_2x3:
                setToTransform(matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++]);
                return;
            case MT_3D_4x4:
                if (matrix[offset + 12] != 0.0 ||
                        matrix[offset + 13] != 0.0 ||
                        matrix[offset + 14] != 0.0 ||
                        matrix[offset + 15] != 1.0) {
                    throw new IllegalArgumentException(&quot;The matrix is &quot;
                            + &quot;not affine&quot;);
                }
                // fall-through
            case MT_3D_3x4:
                setToTransform(matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++]);
                return;
        }
    }

    /**
     * Resets this transform to the identity transform.
     * @since JavaFX 8.0
     */
    public void setToIdentity() {
        atomicChange.start();

        if (state3d != APPLY_NON_3D) {
            setMxx(1.0); setMxy(0.0); setMxz(0.0); setTx(0.0);
            setMyx(0.0); setMyy(1.0); setMyz(0.0); setTy(0.0);
            setMzx(0.0); setMzy(0.0); setMzz(1.0); setTz(0.0);
            state3d = APPLY_NON_3D;
            state2d = APPLY_IDENTITY;
        } else if (state2d != APPLY_IDENTITY) {
            setMxx(1.0); setMxy(0.0); setTx(0.0);
            setMyx(0.0); setMyy(1.0); setTy(0.0);
            state2d = APPLY_IDENTITY;
        }

        atomicChange.end();
    }

    /* *************************************************************************
     *                                                                         *
     *                           Matrix operations                             *
     *                                                                         *
     **************************************************************************/


               /* *************************************************
                *                   Inversion                     *
                **************************************************/

    /**
     * Inverts this transform in place.
     * @throws NonInvertibleTransformException if this transform
     *         cannot be inverted
     * @since JavaFX 8.0
     */
    public void invert() throws NonInvertibleTransformException {
        atomicChange.start();

        if (state3d == APPLY_NON_3D) {
            invert2D();
            updateState2D();
        } else {
            invert3D();
            updateState();
        }

        atomicChange.end();
    }

    /**
     * 2D implementation of {@code invert()}.
     * The behavior is undefined for a 3D transform.
     */
    private void invert2D() throws NonInvertibleTransformException {
        double Mxx, Mxy, Mxt;
        double Myx, Myy, Myt;
        double det;
        // assert(state3d == APPLY_NON_3D)

        switch (state2d) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                Mxx = getMxx(); Mxy = getMxy(); Mxt = getTx();
                Myx = getMyx(); Myy = getMyy(); Myt = getTy();
                det = getDeterminant2D();
                if (det == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                setMxx(Myy / det);
                setMyx(-Myx / det);
                setMxy(-Mxy / det);
                setMyy(Mxx / det);
                setTx((Mxy * Myt - Myy * Mxt) / det);
                setTy((Myx * Mxt - Mxx * Myt) / det);
                return;
            case APPLY_SHEAR | APPLY_SCALE:
                Mxx = getMxx(); Mxy = getMxy();
                Myx = getMyx(); Myy = getMyy();
                det = getDeterminant2D();
                if (det == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                setMxx(Myy / det);
                setMyx(-Myx / det);
                setMxy(-Mxy / det);
                setMyy(Mxx / det);
                return;
            case APPLY_SHEAR | APPLY_TRANSLATE:
                Mxy = getMxy(); Mxt = getTx();
                Myx = getMyx(); Myt = getTy();
                if (Mxy == 0.0 || Myx == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                setMyx(1.0 / Mxy);
                setMxy(1.0 / Myx);
                setTx(-Myt / Myx);
                setTy(-Mxt / Mxy);
                return;
            case APPLY_SHEAR:
                Mxy = getMxy();
                Myx = getMyx();
                if (Mxy == 0.0 || Myx == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                setMyx(1.0 / Mxy);
                setMxy(1.0 / Myx);
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                Mxx = getMxx(); Mxt = getTx();
                Myy = getMyy(); Myt = getTy();
                if (Mxx == 0.0 || Myy == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                setMxx(1.0 / Mxx);
                setMyy(1.0 / Myy);
                setTx(-Mxt / Mxx);
                setTy(-Myt / Myy);
                return;
            case APPLY_SCALE:
                Mxx = getMxx();
                Myy = getMyy();
                if (Mxx == 0.0 || Myy == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                setMxx(1.0 / Mxx);
                setMyy(1.0 / Myy);
                return;
            case APPLY_TRANSLATE:
                setTx(-getTx());
                setTy(-getTy());
                return;
            case APPLY_IDENTITY:
                return;
        }
    }

    /**
     * 3D implementation of {@code invert()}.
     * The behavior is undefined if this is a 2D transform.
     */
    private void invert3D() throws NonInvertibleTransformException {

        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_TRANSLATE:
                setTx(-getTx());
                setTy(-getTy());
                setTz(-getTz());
                return;
            case APPLY_SCALE:
                final double mxx_s = getMxx();
                final double myy_s = getMyy();
                final double mzz_s = getMzz();
                if (mxx_s == 0.0 || myy_s == 0.0 || mzz_s == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                setMxx(1.0 / mxx_s);
                setMyy(1.0 / myy_s);
                setMzz(1.0 / mzz_s);
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                final double mxx_st = getMxx();
                final double tx_st = getTx();
                final double myy_st = getMyy();
                final double ty_st = getTy();
                final double mzz_st = getMzz();
                final double tz_st = getTz();
                if (mxx_st == 0.0 || myy_st == 0.0 || mzz_st == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                setMxx(1.0 / mxx_st);
                setMyy(1.0 / myy_st);
                setMzz(1.0 / mzz_st);
                setTx(-tx_st / mxx_st);
                setTy(-ty_st / myy_st);
                setTz(-tz_st / mzz_st);
                return;
            case APPLY_3D_COMPLEX:

                // InvM = Transpose(Cofactor(M)) / det(M)
                // Cofactor(M) = matrix of cofactors(0..3,0..3)
                // cofactor(r,c) = (-1 if r+c is odd) * minor(r,c)
                // minor(r,c) = det(M with row r and col c removed)
                // For an Affine3D matrix, minor(r, 3) is {0, 0, 0, det}
                // which generates {0, 0, 0, 1} and so can be ignored.

                final double mxx = getMxx();
                final double mxy = getMxy();
                final double mxz = getMxz();
                final double tx = getTx();
                final double myx = getMyx();
                final double myy = getMyy();
                final double myz = getMyz();
                final double ty = getTy();
                final double mzy = getMzy();
                final double mzx = getMzx();
                final double mzz = getMzz();
                final double tz = getTz();

                final double det =
                        mxx * (myy * mzz - mzy * myz) +
                        mxy * (myz * mzx - mzz * myx) +
                        mxz * (myx * mzy - mzx * myy);

                if (det == 0.0) {
                    atomicChange.cancel();
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }

                final double cxx =   myy * mzz - myz * mzy;
                final double cyx = - myx * mzz + myz * mzx;
                final double czx =   myx * mzy - myy * mzx;
                final double cxt = - mxy * (myz * tz - mzz  * ty)
                                   - mxz * (ty  * mzy - tz  * myy)
                                   - tx  * (myy * mzz - mzy * myz);
                final double cxy = - mxy * mzz + mxz * mzy;
                final double cyy =   mxx * mzz - mxz * mzx;
                final double czy = - mxx * mzy + mxy * mzx;
                final double cyt =   mxx * (myz * tz  - mzz * ty)
                                   + mxz * (ty  * mzx - tz  * myx)
                                   + tx  * (myx * mzz - mzx * myz);
                final double cxz =   mxy * myz - mxz * myy;
                final double cyz = - mxx * myz + mxz * myx;
                final double czz =   mxx * myy - mxy * myx;
                final double czt = - mxx * (myy * tz - mzy  * ty)
                                   - mxy * (ty  * mzx - tz  * myx)
                                   - tx  * (myx * mzy - mzx * myy);

                setMxx(cxx / det);
                setMxy(cxy / det);
                setMxz(cxz / det);
                setTx(cxt / det);
                setMyx(cyx / det);
                setMyy(cyy / det);
                setMyz(cyz / det);
                setTy(cyt / det);
                setMzx(czx / det);
                setMzy(czy / det);
                setMzz(czz / det);
                setTz(czt / det);
                return;
        }
    }

               /* *************************************************
                *             General concatenations              *
                **************************************************/

    /**
     * &lt;p&gt;
     * Appends the specified transform to this instance.
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding the two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * {@code transform} second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified transform.
     * &lt;/p&gt;
     *
     * @param transform transform to be appended to this instance
     * @throws NullPointerException if the specified {@code transform} is null
     * @since JavaFX 8.0
     */
    public void append(Transform transform) {
        transform.appendTo(this);
    }

    /**
     * &lt;p&gt;
     * Appends the 2D transform specified by the element values to this instance.
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding the two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * {@code transform} second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified transform.
     * &lt;/p&gt;
     * @param mxx the X coordinate scaling element of the transform to be
     *            appended
     * @param mxy the XY coordinate element of the transform to be appended
     * @param tx the X coordinate translation element of the transform to be
     *            appended
     * @param myx the YX coordinate element of the transform to be appended
     * @param myy the Y coordinate scaling element of the transform to be
     *            appended
     * @param ty the Y coordinate translation element of the transform to be
     *            appended
     * @since JavaFX 8.0
     */
    public void append(double mxx, double mxy, double tx,
                        double myx, double myy, double ty) {

        if (state3d == APPLY_NON_3D) {

            atomicChange.start();

            final double m_xx = getMxx();
            final double m_xy = getMxy();
            final double m_yx = getMyx();
            final double m_yy = getMyy();

            setMxx(m_xx * mxx + m_xy * myx);
            setMxy(m_xx * mxy + m_xy * myy);
            setTx(m_xx * tx + m_xy * ty + getTx());
            setMyx(m_yx * mxx + m_yy * myx);
            setMyy(m_yx * mxy + m_yy * myy);
            setTy(m_yx * tx + m_yy * ty + getTy());

            updateState();
            atomicChange.end();
        } else {
            append(mxx, mxy, 0.0, tx,
                    myx, myy, 0.0, ty,
                    0.0, 0.0, 1.0, 0.0);
        }
    }

    /**
     * &lt;p&gt;
     * Appends the transform specified by the element values to this instance.
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding the two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * {@code transform} second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified transform.
     * &lt;/p&gt;
     *
     * @param mxx the X coordinate scaling element of the transform to be
     *            appended
     * @param mxy the XY coordinate element of the transform to be appended
     * @param mxz the XZ coordinate element of the transform to be appended
     * @param tx the X coordinate translation element of the transform to be
     *            appended
     * @param myx the YX coordinate element of the transform to be appended
     * @param myy the Y coordinate scaling element of the transform to be
     *            appended
     * @param myz the YZ coordinate element of the transform to be appended
     * @param ty the Y coordinate translation element of the transform to be
     *            appended
     * @param mzx the ZX coordinate element of the transform to be appended
     * @param mzy the ZY coordinate element of the transform to be appended
     * @param mzz the Z coordinate scaling element of the transform to be
     *            appended
     * @param tz the Z coordinate translation element of the transform to be
     *            appended
     * @since JavaFX 8.0
     */
    public void append(double mxx, double mxy, double mxz, double tx,
                       double myx, double myy, double myz, double ty,
                       double mzx, double mzy, double mzz, double tz)
    {
        atomicChange.start();

        final double m_xx = getMxx();
        final double m_xy = getMxy();
        final double m_xz = getMxz();
        final double t_x = getTx();
        final double m_yx = getMyx();
        final double m_yy = getMyy();
        final double m_yz = getMyz();
        final double t_y = getTy();
        final double m_zx = getMzx();
        final double m_zy = getMzy();
        final double m_zz = getMzz();
        final double t_z = getTz();

        setMxx(m_xx * mxx + m_xy * myx + m_xz * mzx);
        setMxy(m_xx * mxy + m_xy * myy + m_xz * mzy);
        setMxz(m_xx * mxz + m_xy * myz + m_xz * mzz);
        setTx( m_xx * tx + m_xy * ty + m_xz * tz + t_x);
        setMyx(m_yx * mxx + m_yy * myx + m_yz * mzx);
        setMyy(m_yx * mxy + m_yy * myy + m_yz * mzy);
        setMyz(m_yx * mxz + m_yy * myz + m_yz * mzz);
        setTy( m_yx * tx + m_yy * ty + m_yz * tz + t_y);
        setMzx(m_zx * mxx + m_zy * myx + m_zz * mzx);
        setMzy(m_zx * mxy + m_zy * myy + m_zz * mzy);
        setMzz(m_zx * mxz + m_zy * myz + m_zz * mzz);
        setTz( m_zx * tx + m_zy * ty + m_zz * tz + t_z);

        updateState();
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the transform specified by the array to this instance.
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding the two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * {@code transform} second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified transform.
     * &lt;/p&gt;
     *
     * @param matrix array containing the flattened transformation matrix
     *               to be appended
     * @param type type of matrix contained in the array
     * @param offset offset of the first matrix element in the array
     * @throws IndexOutOfBoundsException if the array is too short for
     *         the specified {@code type} and {@code offset}
     * @throws IllegalArgumentException if the specified matrix is not affine
     *         (the last line of a 2D 3x3 matrix is not {@code [0, 0, 1]} or
     *          the last line of a 3D 4x4 matrix is not {@code [0, 0, 0, 1]}.
     * @throws NullPointerException if the specified {@code matrix}
     *         or {@code type} is null
     * @since JavaFX 8.0
     */
    public void append(double[] matrix, MatrixType type, int offset) {
        if (matrix.length &lt; offset + type.elements()) {
            throw new IndexOutOfBoundsException(&quot;The array is too short.&quot;);
        }

        switch(type) {
            default:
                stateError();
                // cannot reach
            case MT_2D_3x3:
                if (matrix[offset + 6] != 0.0 ||
                        matrix[offset + 7] != 0.0 ||
                        matrix[offset + 8] != 1.0) {
                    throw new IllegalArgumentException(&quot;The matrix is &quot;
                            + &quot;not affine&quot;);
                }
                // fall-through
            case MT_2D_2x3:
                append(matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++]);
                return;
            case MT_3D_4x4:
                if (matrix[offset + 12] != 0.0 ||
                        matrix[offset + 13] != 0.0 ||
                        matrix[offset + 14] != 0.0 ||
                        matrix[offset + 15] != 1.0) {
                    throw new IllegalArgumentException(&quot;The matrix is &quot;
                            + &quot;not affine&quot;);
                }
                // fall-through
            case MT_3D_3x4:
                append(matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++]);
                return;
        }
    }

    @Override
    void appendTo(Affine a) {
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch(state2d) {
                    case APPLY_IDENTITY:
                        return;
                    case APPLY_TRANSLATE:
                        a.appendTranslation(getTx(), getTy());
                        return;
                    case APPLY_SCALE:
                        a.appendScale(getMxx(), getMyy());
                        return;
                    case APPLY_SCALE | APPLY_TRANSLATE:
                        a.appendTranslation(getTx(), getTy());
                        a.appendScale(getMxx(), getMyy());
                        return;
                    default:
                        a.append(getMxx(), getMxy(), getTx(),
                                 getMyx(), getMyy(), getTy());
                        return;
                }
            case APPLY_TRANSLATE:
                a.appendTranslation(getTx(), getTy(), getTz());
                return;
            case APPLY_SCALE:
                a.appendScale(getMxx(), getMyy(), getMzz());
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                a.appendTranslation(getTx(), getTy(), getTz());
                a.appendScale(getMxx(), getMyy(), getMzz());
                return;
            case APPLY_3D_COMPLEX:
                a.append(getMxx(), getMxy(), getMxz(), getTx(),
                         getMyx(), getMyy(), getMyz(), getTy(),
                         getMzx(), getMzy(), getMzz(), getTz());
                return;
        }
    }

    /**
     * &lt;p&gt;
     * Prepends the specified transform to this instance.
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding the two transforms to its
     * {@code getTransforms()} list, the specified {@code transform} first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified transform.
     * &lt;/p&gt;
     *
     * @param transform transform to be prepended to this instance
     * @throws NullPointerException if the specified {@code transform} is null
     * @since JavaFX 8.0
     */
    public void prepend(Transform transform) {
        transform.prependTo(this);
    }

    /**
     * &lt;p&gt;
     * Prepends the 2D transform specified by the element values to this instance.
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding the two transforms to its
     * {@code getTransforms()} list, the specified {@code transform} first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified transform.
     * &lt;/p&gt;
     *
     * @param mxx the X coordinate scaling element of the transform to be
     *            prepended
     * @param mxy the XY coordinate element of the transform to be prepended
     * @param tx the X coordinate translation element of the transform to be
     *            prepended
     * @param myx the YX coordinate element of the transform to be prepended
     * @param myy the Y coordinate scaling element of the transform to be
     *            prepended
     * @param ty the Y coordinate translation element of the transform to be
     *            prepended
     * @since JavaFX 8.0
     */
    public void prepend(double mxx, double mxy, double tx,
                        double myx, double myy, double ty) {

        if (state3d == APPLY_NON_3D) {
            atomicChange.start();

            final double m_xx = getMxx();
            final double m_xy = getMxy();
            final double t_x = getTx();
            final double m_yx = getMyx();
            final double m_yy = getMyy();
            final double t_y = getTy();

            setMxx(mxx * m_xx + mxy * m_yx);
            setMxy(mxx * m_xy + mxy * m_yy);
            setTx(mxx * t_x + mxy * t_y + tx);
            setMyx(myx * m_xx + myy * m_yx);
            setMyy(myx * m_xy + myy * m_yy);
            setTy(myx * t_x + myy * t_y + ty);

            updateState2D();
            atomicChange.end();
        } else {
            prepend(mxx, mxy, 0.0, tx,
                   myx, myy, 0.0, ty,
                   0.0, 0.0, 1.0, 0.0);
        }
    }

    /**
     * &lt;p&gt;
     * Prepends the transform specified by the element values to this instance.
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding the two transforms to its
     * {@code getTransforms()} list, the specified {@code transform} first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified transform.
     * &lt;/p&gt;
     *
     * @param mxx the X coordinate scaling element of the transform to be
     *            prepended
     * @param mxy the XY coordinate element of the transform to be prepended
     * @param mxz the XZ coordinate element of the transform to be prepended
     * @param tx the X coordinate translation element of the transform to be
     *            prepended
     * @param myx the YX coordinate element of the transform to be prepended
     * @param myy the Y coordinate scaling element of the transform to be
     *            prepended
     * @param myz the YZ coordinate element of the transform to be prepended
     * @param ty the Y coordinate translation element of the transform to be
     *            prepended
     * @param mzx the ZX coordinate element of the transform to be prepended
     * @param mzy the ZY coordinate element of the transform to be prepended
     * @param mzz the Z coordinate scaling element of the transform to be
     *            prepended
     * @param tz the Z coordinate translation element of the transform to be
     *            prepended
     * @since JavaFX 8.0
     */
    public void prepend(double mxx, double mxy, double mxz, double tx,
                        double myx, double myy, double myz, double ty,
                        double mzx, double mzy, double mzz, double tz) {
        atomicChange.start();

        final double m_xx = getMxx();
        final double m_xy = getMxy();
        final double m_xz = getMxz();
        final double t_x = getTx();
        final double m_yx = getMyx();
        final double m_yy = getMyy();
        final double m_yz = getMyz();
        final double t_y = getTy();
        final double m_zx = getMzx();
        final double m_zy = getMzy();
        final double m_zz = getMzz();
        final double t_z = getTz();

        setMxx(mxx * m_xx + mxy * m_yx + mxz * m_zx);
        setMxy(mxx * m_xy + mxy * m_yy + mxz * m_zy);
        setMxz(mxx * m_xz + mxy * m_yz + mxz * m_zz);
        setTx( mxx * t_x + mxy * t_y + mxz * t_z + tx);
        setMyx(myx * m_xx + myy * m_yx + myz * m_zx);
        setMyy(myx * m_xy + myy * m_yy + myz * m_zy);
        setMyz(myx * m_xz + myy * m_yz + myz * m_zz);
        setTy( myx * t_x + myy * t_y + myz * t_z + ty);
        setMzx(mzx * m_xx + mzy * m_yx + mzz * m_zx);
        setMzy(mzx * m_xy + mzy * m_yy + mzz * m_zy);
        setMzz(mzx * m_xz + mzy * m_yz + mzz * m_zz);
        setTz( mzx * t_x + mzy * t_y + mzz * t_z + tz);

        updateState();
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the transform specified by the array to this instance.
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding the two transforms to its
     * {@code getTransforms()} list, the specified {@code transform} first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified transform.
     * &lt;/p&gt;
     *
     * @param matrix array containing the flattened transformation matrix
     *               to be prepended
     * @param type type of matrix contained in the array
     * @param offset offset of the first matrix element in the array
     * @throws IndexOutOfBoundsException if the array is too short for
     *         the specified {@code type} and {@code offset}
     * @throws IllegalArgumentException if the specified matrix is not affine
     *         (the last line of a 2D 3x3 matrix is not {@code [0, 0, 1]} or
     *          the last line of a 3D 4x4 matrix is not {@code [0, 0, 0, 1]}.
     * @throws NullPointerException if the specified {@code matrix}
     *         or {@code type} is null
     * @since JavaFX 8.0
     */
    public void prepend(double[] matrix, MatrixType type, int offset) {
        if (matrix.length &lt; offset + type.elements()) {
            throw new IndexOutOfBoundsException(&quot;The array is too short.&quot;);
        }

        switch(type) {
            default:
                stateError();
                // cannot reach
            case MT_2D_3x3:
                if (matrix[offset + 6] != 0.0 ||
                        matrix[offset + 7] != 0.0 ||
                        matrix[offset + 8] != 1.0) {
                    throw new IllegalArgumentException(&quot;The matrix is &quot;
                            + &quot;not affine&quot;);
                }
                // fall-through
            case MT_2D_2x3:
                prepend(matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++]);
                return;
            case MT_3D_4x4:
                if (matrix[offset + 12] != 0.0 ||
                        matrix[offset + 13] != 0.0 ||
                        matrix[offset + 14] != 0.0 ||
                        matrix[offset + 15] != 1.0) {
                    throw new IllegalArgumentException(&quot;The matrix is &quot;
                            + &quot;not affine&quot;);
                }
                // fall-through
            case MT_3D_3x4:
                prepend(matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++],
                        matrix[offset++], matrix[offset++], matrix[offset++]);
                return;
        }
    }

    @Override
    void prependTo(Affine a) {
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch(state2d) {
                    case APPLY_IDENTITY:
                        return;
                    case APPLY_TRANSLATE:
                        a.prependTranslation(getTx(), getTy());
                        return;
                    case APPLY_SCALE:
                        a.prependScale(getMxx(), getMyy());
                        return;
                    case APPLY_SCALE | APPLY_TRANSLATE:
                        a.prependScale(getMxx(), getMyy());
                        a.prependTranslation(getTx(), getTy());
                        return;
                    default:
                        a.prepend(getMxx(), getMxy(), getTx(),
                                  getMyx(), getMyy(), getTy());
                        return;
                }
            case APPLY_TRANSLATE:
                a.prependTranslation(getTx(), getTy(), getTz());
                return;
            case APPLY_SCALE:
                a.prependScale(getMxx(), getMyy(), getMzz());
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                a.prependScale(getMxx(), getMyy(), getMzz());
                a.prependTranslation(getTx(), getTy(), getTz());
                return;
            case APPLY_3D_COMPLEX:
                a.prepend(getMxx(), getMxy(), getMxz(), getTx(),
                          getMyx(), getMyy(), getMyz(), getTy(),
                          getMzx(), getMzy(), getMzz(), getTz());
                return;
        }
    }


               /* *************************************************
                *                    Translate                    *
                **************************************************/

    /**
     * &lt;p&gt;
     * Appends the 2D translation to this instance.
     * It is equivalent to {@code append(new Translate(tx, ty))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * translation second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified translation.
     * &lt;/p&gt;
     * @param tx the X coordinate translation
     * @param ty the Y coordinate translation
     * @since JavaFX 8.0
     */
    public void appendTranslation(double tx, double ty) {
        atomicChange.start();
        translate2D(tx, ty);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the translation to this instance.
     * It is equivalent to {@code append(new Translate(tx, ty, tz))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * translation second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified translation.
     * &lt;/p&gt;
     * @param tx the X coordinate translation
     * @param ty the Y coordinate translation
     * @param tz the Z coordinate translation
     * @since JavaFX 8.0
     */
    public void appendTranslation(double tx, double ty, double tz) {
        atomicChange.start();
        translate3D(tx, ty, tz);
        atomicChange.end();
    }

    /**
     * 2D implementation of {@code appendTranslation()}.
     * If this is a 3D transform, the call is redirected to {@code transalte3D()}.
     */
    private void translate2D(double tx, double ty) {
        if (state3d != APPLY_NON_3D) {
            translate3D(tx, ty, 0.0);
            return;
        }

        switch (state2d) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                setTx(tx * getMxx() + ty * getMxy() + getTx());
                setTy(tx * getMyx() + ty * getMyy() + getTy());
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = APPLY_SHEAR | APPLY_SCALE;
                }
                return;
            case APPLY_SHEAR | APPLY_SCALE:
                setTx(tx * getMxx() + ty * getMxy());
                setTy(tx * getMyx() + ty * getMyy());
                if (getTx() != 0.0 || getTy() != 0.0) {
                    state2d = APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE;
                }
                return;
            case APPLY_SHEAR | APPLY_TRANSLATE:
                setTx(ty * getMxy() + getTx());
                setTy(tx * getMyx() + getTy());
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = APPLY_SHEAR;
                }
                return;
            case APPLY_SHEAR:
                setTx(ty * getMxy());
                setTy(tx * getMyx());
                if (getTx() != 0.0 || getTy() != 0.0) {
                    state2d = APPLY_SHEAR | APPLY_TRANSLATE;
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                setTx(tx * getMxx() + getTx());
                setTy(ty * getMyy() + getTy());
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = APPLY_SCALE;
                }
                return;
            case APPLY_SCALE:
                setTx(tx * getMxx());
                setTy(ty * getMyy());
                if (getTx() != 0.0 || getTy() != 0.0) {
                    state2d = APPLY_SCALE | APPLY_TRANSLATE;
                }
                return;
            case APPLY_TRANSLATE:
                setTx(tx + getTx());
                setTy(ty + getTy());
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = APPLY_IDENTITY;
                }
                return;
            case APPLY_IDENTITY:
                setTx(tx);
                setTy(ty);
                if (tx != 0.0 || ty != 0.0) {
                    state2d = APPLY_TRANSLATE;
                }
                return;
        }
    }

    /**
     * 3D implementation of {@code appendTranslation()}.
     * Works fine if this is a 2D transform.
     */
    private void translate3D(double tx, double ty, double tz) {
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                translate2D(tx, ty);
                if (tz != 0.0) {
                    setTz(tz);
                    if ((state2d &amp; APPLY_SHEAR) == 0) {
                        state3d = (state2d &amp; APPLY_SCALE) | APPLY_TRANSLATE;
                    } else {
                        state3d = APPLY_3D_COMPLEX;
                    }
                }
                return;
            case APPLY_TRANSLATE:
                setTx(tx + getTx());
                setTy(ty + getTy());
                setTz(tz + getTz());
                if (getTz() == 0.0) {
                    state3d = APPLY_NON_3D;
                    if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                        state2d = APPLY_IDENTITY;
                    } else {
                        state2d = APPLY_TRANSLATE;
                    }
                }
                return;
            case APPLY_SCALE:
                setTx(tx * getMxx());
                setTy(ty * getMyy());
                setTz(tz * getMzz());
                if (getTx() != 0.0 || getTy() != 0.0 || getTz() != 0.0) {
                    state3d |= APPLY_TRANSLATE;
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                setTx(tx * getMxx() + getTx());
                setTy(ty * getMyy() + getTy());
                setTz(tz * getMzz() + getTz());
                if (getTz() == 0.0) {
                    if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                        state3d = APPLY_SCALE;
                    }
                    if (getMzz() == 1.0) {
                        state2d = state3d;
                        state3d = APPLY_NON_3D;
                    }
                }
                return;
            case APPLY_3D_COMPLEX:
                setTx(tx * getMxx() + ty * getMxy() + tz * getMxz() + getTx());
                setTy(tx * getMyx() + ty * getMyy() + tz * getMyz() + getTy());
                setTz(tx * getMzx() + ty * getMzy() + tz * getMzz() + getTz());
                updateState();
                return;
        }
    }

    /**
     * &lt;p&gt;
     * Prepends the translation to this instance.
     * It is equivalent to {@code prepend(new Translate(tx, ty, tz))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified translation first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified translation.
     * &lt;/p&gt;
     * @param tx the X coordinate translation
     * @param ty the Y coordinate translation
     * @param tz the Z coordinate translation
     * @since JavaFX 8.0
     */
    public void prependTranslation(double tx, double ty, double tz) {
        atomicChange.start();
        preTranslate3D(tx, ty, tz);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the 2D translation to this instance.
     * It is equivalent to {@code prepend(new Translate(tx, ty))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified translation first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified translation.
     * &lt;/p&gt;
     * @param tx the X coordinate translation
     * @param ty the Y coordinate translation
     * @since JavaFX 8.0
     */
    public void prependTranslation(double tx, double ty) {
        atomicChange.start();
        preTranslate2D(tx, ty);
        atomicChange.end();
    }

    /**
     * 2D implementation of {@code prependTranslation()}.
     * If this is a 3D transform, the call is redirected to
     * {@code preTransalte3D}.
     * @since JavaFX 8.0
     */
    private void preTranslate2D(double tx, double ty) {
        if (state3d != APPLY_NON_3D) {
            preTranslate3D(tx, ty, 0.0);
            return;
        }

        setTx(getTx() + tx);
        setTy(getTy() + ty);

        if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
            state2d &amp;= ~APPLY_TRANSLATE;
        } else {
            state2d |= APPLY_TRANSLATE;
        }
    }

    /**
     * 3D implementation of {@code prependTranslation()}.
     * Works fine if this is a 2D transform.
     */
    private void preTranslate3D(double tx, double ty, double tz) {
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                preTranslate2D(tx, ty);

                if (tz != 0.0) {
                    setTz(tz);

                    if ((state2d &amp; APPLY_SHEAR) == 0) {
                        state3d = (state2d &amp; APPLY_SCALE) | APPLY_TRANSLATE;
                    } else {
                        state3d = APPLY_3D_COMPLEX;
                    }
                }
                return;
            case APPLY_TRANSLATE:
                setTx(getTx() + tx);
                setTy(getTy() + ty);
                setTz(getTz() + tz);
                if (getTz() == 0.0) {
                    state3d = APPLY_NON_3D;
                    if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                        state2d = APPLY_IDENTITY;
                    } else {
                        state2d = APPLY_TRANSLATE;
                    }
                }
                return;
            case APPLY_SCALE:
                setTx(tx);
                setTy(ty);
                setTz(tz);
                if (tx != 0.0 || ty != 0.0 || tz != 0.0) {
                    state3d |= APPLY_TRANSLATE;
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                setTx(getTx() + tx);
                setTy(getTy() + ty);
                setTz(getTz() + tz);

                if (getTz() == 0.0) {
                    if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                        state3d = APPLY_SCALE;
                    }
                    if (getMzz() == 1.0) {
                        state2d = state3d;
                        state3d = APPLY_NON_3D;
                    }
                }
                return;
            case APPLY_3D_COMPLEX:
                setTx(getTx() + tx);
                setTy(getTy() + ty);
                setTz(getTz() + tz);
                if (getTz() == 0.0 &amp;&amp; getMxz() == 0.0 &amp;&amp; getMyz() == 0.0 &amp;&amp;
                        getMzx() == 0.0 &amp;&amp; getMzy() == 0.0 &amp;&amp; getMzz() == 1.0) {
                    state3d = APPLY_NON_3D;
                    updateState2D();
                } // otherwise state remains COMPLEX
                return;
        }
    }

               /* *************************************************
                *                      Scale                      *
                **************************************************/

    /**
     * &lt;p&gt;
     * Appends the 2D scale to this instance.
     * It is equivalent to {@code append(new Scale(sx, sy))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * scale second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @since JavaFX 8.0
     */
    public void appendScale(double sx, double sy) {
        atomicChange.start();
        scale2D(sx, sy);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the 2D scale with pivot to this instance.
     * It is equivalent to {@code append(new Scale(sx, sy, pivotX, pivotY))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * scale second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param pivotX the X coordinate of the point about which the scale occurs
     * @param pivotY the Y coordinate of the point about which the scale occurs
     * @since JavaFX 8.0
     */
    public void appendScale(double sx, double sy,
            double pivotX, double pivotY) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0) {
            translate2D(pivotX, pivotY);
            scale2D(sx, sy);
            translate2D(-pivotX, -pivotY);
        } else {
            scale2D(sx, sy);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the 2D scale with pivot to this instance.
     * It is equivalent to
     * {@code append(new Scale(sx, sy, pivot.getX(), pivot.getY())}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * scale second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param pivot the point about which the scale occurs
     * @throws NullPointerException if the specified {@code pivot} is null
     * @since JavaFX 8.0
     */
    public void appendScale(double sx, double sy, Point2D pivot) {
        appendScale(sx, sy, pivot.getX(), pivot.getY());
    }

    /**
     * &lt;p&gt;
     * Appends the scale to this instance.
     * It is equivalent to {@code append(new Scale(sx, sy, sz))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * scale second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param sz the Z coordinate scale factor
     * @since JavaFX 8.0
     */
    public void appendScale(double sx, double sy, double sz) {
        atomicChange.start();
        scale3D(sx, sy, sz);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the scale with pivot to this instance.
     * It is equivalent to {@code append(new Scale(sx, sy, sz, pivotX,
     * pivotY, pivotZ))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * scale second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param sz the Z coordinate scale factor
     * @param pivotX the X coordinate of the point about which the scale occurs
     * @param pivotY the Y coordinate of the point about which the scale occurs
     * @param pivotZ the Z coordinate of the point about which the scale occurs
     * @since JavaFX 8.0
     */
    public void appendScale(double sx, double sy, double sz,
            double pivotX, double pivotY, double pivotZ) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0 || pivotZ != 0.0) {
            translate3D(pivotX, pivotY, pivotZ);
            scale3D(sx, sy, sz);
            translate3D(-pivotX, -pivotY, -pivotZ);
        } else {
            scale3D(sx, sy, sz);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the scale with pivot to this instance.
     * It is equivalent to {@code append(new Scale(sx, sy, sz, pivot.getX(),
     * pivot.getY(), pivot.getZ()))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * scale second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param sz the Z coordinate scale factor
     * @param pivot the point about which the scale occurs
     * @throws NullPointerException if the specified {@code pivot} is null
     * @since JavaFX 8.0
     */
    public void appendScale(double sx, double sy, double sz, Point3D pivot) {
        appendScale(sx, sy, sz, pivot.getX(), pivot.getY(), pivot.getZ());
    }

    /**
     * 2D implementation of {@code appendScale()}.
     * If this is a 3D transform, the call is redirected to {@code scale3D()}.
     */
    private void scale2D(double sx, double sy) {
        if (state3d != APPLY_NON_3D) {
            scale3D(sx, sy, 1.0);
            return;
        }

        int mystate = state2d;
        switch (mystate) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SHEAR | APPLY_SCALE:
                setMxx(getMxx() * sx);
                setMyy(getMyy() * sy);
                // fall-through
            case APPLY_SHEAR | APPLY_TRANSLATE:
            case APPLY_SHEAR:
                setMxy(getMxy() * sy);
                setMyx(getMyx() * sx);
                if (getMxy() == 0.0 &amp;&amp; getMyx() == 0.0) {
                    mystate &amp;= APPLY_TRANSLATE;
                    if (getMxx() != 1.0 || getMyy() != 1.0) {
                        mystate |= APPLY_SCALE;
                    }
                    state2d = mystate;
                } else if (getMxx() == 0.0 &amp;&amp; getMyy() == 0.0) {
                    state2d &amp;= ~APPLY_SCALE;
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SCALE:
                setMxx(getMxx() * sx);
                setMyy(getMyy() * sy);
                if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
                    state2d = (mystate &amp;= APPLY_TRANSLATE);
                }
                return;
            case APPLY_TRANSLATE:
            case APPLY_IDENTITY:
                setMxx(sx);
                setMyy(sy);
                if (sx != 1.0 || sy != 1.0) {
                    state2d = (mystate | APPLY_SCALE);
                }
                return;
        }
    }

    /**
     * 3D implementation of {@code appendScale()}.
     * Works fine if this is a 2D transform.
     */
    private void scale3D(double sx, double sy, double sz) {
        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                scale2D(sx, sy);
                if (sz != 1.0) {
                    setMzz(sz);
                    if ((state2d &amp; APPLY_SHEAR) == 0) {
                        state3d = (state2d &amp; APPLY_TRANSLATE) | APPLY_SCALE;
                    } else {
                        state3d = APPLY_3D_COMPLEX;
                    }
                }
                return;
            case APPLY_TRANSLATE:
                setMxx(sx);
                setMyy(sy);
                setMzz(sz);
                if (sx != 1.0 || sy != 1.0 || sz != 1.0) {
                    state3d |= APPLY_SCALE;
                }
                return;
            case APPLY_SCALE:
                setMxx(getMxx() * sx);
                setMyy(getMyy() * sy);
                setMzz(getMzz() * sz);
                if (getMzz() == 1.0) {
                    state3d = APPLY_NON_3D;
                    if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
                        state2d = APPLY_IDENTITY;
                    } else {
                        state2d = APPLY_SCALE;
                    }
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                setMxx(getMxx() * sx);
                setMyy(getMyy() * sy);
                setMzz(getMzz() * sz);

                if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0 &amp;&amp; getMzz() == 1.0) {
                    state3d &amp;= ~APPLY_SCALE;
                }
                if (getTz() == 0.0 &amp;&amp; getMzz() == 1.0) {
                    state2d = state3d;
                    state3d = APPLY_NON_3D;
                }
                return;
            case APPLY_3D_COMPLEX:
                setMxx(getMxx() * sx);
                setMxy(getMxy() * sy);
                setMxz(getMxz() * sz);

                setMyx(getMyx() * sx);
                setMyy(getMyy() * sy);
                setMyz(getMyz() * sz);

                setMzx(getMzx() * sx);
                setMzy(getMzy() * sy);
                setMzz(getMzz() * sz);

                if (sx == 0.0 || sy == 0.0 || sz == 0.0) {
                    updateState();
                } // otherwise state remains COMPLEX
                return;
        }
    }

    /**
     * &lt;p&gt;
     * Prepends the 2D scale to this instance.
     * It is equivalent to {@code prepend(new Scale(sx, sy))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified scale first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @since JavaFX 8.0
     */
    public void prependScale(double sx, double sy) {

        atomicChange.start();
        preScale2D(sx, sy);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the 2D scale with pivot to this instance.
     * It is equivalent to {@code prepend(new Scale(sx, sy, pivotX, pivotY))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified scale first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param pivotX the X coordinate of the point about which the scale occurs
     * @param pivotY the Y coordinate of the point about which the scale occurs
     * @since JavaFX 8.0
     */
    public void prependScale(double sx, double sy,
            double pivotX, double pivotY) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0) {
            preTranslate2D(-pivotX, -pivotY);
            preScale2D(sx, sy);
            preTranslate2D(pivotX, pivotY);
        } else {
            preScale2D(sx, sy);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the 2D scale with pivot to this instance.
     * It is equivalent to {@code prepend(new Scale(sx, sy, pivot.getX(),
     * &lt;/p&gt;pivot.getY()))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified scale first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param pivot the point about which the scale occurs
     * @throws NullPointerException if the specified {@code pivot} is null
     * @since JavaFX 8.0
     */
    public void prependScale(double sx, double sy, Point2D pivot) {
        prependScale(sx, sy, pivot.getX(), pivot.getY());
    }

    /**
     * &lt;p&gt;
     * Prepends the scale to this instance.
     * It is equivalent to {@code prepend(new Scale(sx, sy, sz))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified scale first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param sz the Z coordinate scale factor
     * @since JavaFX 8.0
     */
    public void prependScale(double sx, double sy, double sz) {
        atomicChange.start();
        preScale3D(sx, sy, sz);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the scale with pivot to this instance.
     * It is equivalent to
     * {@code prepend(new Scale(sx, sy, sz, pivotX, pivotY, pivotZ))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified scale first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param sz the Z coordinate scale factor
     * @param pivotX the X coordinate of the point about which the scale occurs
     * @param pivotY the Y coordinate of the point about which the scale occurs
     * @param pivotZ the Z coordinate of the point about which the scale occurs
     * @since JavaFX 8.0
     */
    public void prependScale(double sx, double sy, double sz,
            double pivotX, double pivotY, double pivotZ) {

        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0 || pivotZ != 0.0) {
            preTranslate3D(-pivotX, -pivotY, -pivotZ);
            preScale3D(sx, sy, sz);
            preTranslate3D(pivotX, pivotY, pivotZ);
        } else {
            preScale3D(sx, sy, sz);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the scale with pivot to this instance.
     * It is equivalent to {@code prepend(new Scale(sx, sy, sz, pivot.getX(),
     * pivot.getY(), pivot.getZ()))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified scale first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified scale.
     * &lt;/p&gt;
     * @param sx the X coordinate scale factor
     * @param sy the Y coordinate scale factor
     * @param sz the Z coordinate scale factor
     * @param pivot the point about which the scale occurs
     * @throws NullPointerException if the specified {@code pivot} is null
     * @since JavaFX 8.0
     */
    public void prependScale(double sx, double sy, double sz, Point3D pivot) {
        prependScale(sx, sy, sz, pivot.getX(), pivot.getY(), pivot.getZ());
    }

    /**
     * 2D implementation of {@code prependScale()}.
     * If this is a 3D transform, the call is redirected to {@code preScale3D()}.
     */
    private void preScale2D(double sx, double sy) {

        if (state3d != APPLY_NON_3D) {
            preScale3D(sx, sy, 1.0);
            return;
        }

        int mystate = state2d;
        switch (mystate) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                setTx(getTx() * sx);
                setTy(getTy() * sy);
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    mystate = mystate &amp; ~APPLY_TRANSLATE;
                    state2d = mystate;
                }
                // fall-through
            case APPLY_SHEAR | APPLY_SCALE:
                setMxx(getMxx() * sx);
                setMyy(getMyy() * sy);
                // fall-through
            case APPLY_SHEAR:
                setMxy(getMxy() * sx);
                setMyx(getMyx() * sy);
                if (getMxy() == 0.0 &amp;&amp; getMyx() == 0.0) {
                    mystate &amp;= APPLY_TRANSLATE;
                    if (getMxx() != 1.0 || getMyy() != 1.0) {
                        mystate |= APPLY_SCALE;
                    }
                    state2d = mystate;
                }
                return;
            case APPLY_SHEAR | APPLY_TRANSLATE:
                setTx(getTx() * sx);
                setTy(getTy() * sy);
                setMxy(getMxy() * sx);
                setMyx(getMyx() * sy);
                if (getMxy() == 0.0 &amp;&amp; getMyx() == 0.0) {
                    if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                        state2d = APPLY_SCALE;
                    } else {
                        state2d = APPLY_SCALE | APPLY_TRANSLATE;
                    }
                } else if (getTx() ==0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = APPLY_SHEAR;
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                setTx(getTx() * sx);
                setTy(getTy() * sy);
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    mystate = mystate &amp; ~APPLY_TRANSLATE;
                    state2d = mystate;
                }
                // fall-through
            case APPLY_SCALE:
                setMxx(getMxx() * sx);
                setMyy(getMyy() * sy);
                if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
                    state2d = (mystate &amp;= APPLY_TRANSLATE);
                }
                return;
            case APPLY_TRANSLATE:
                setTx(getTx() * sx);
                setTy(getTy() * sy);
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    mystate = mystate &amp; ~APPLY_TRANSLATE;
                    state2d = mystate;
                }
                // fall-through
            case APPLY_IDENTITY:
                setMxx(sx);
                setMyy(sy);
                if (sx != 1.0 || sy != 1.0) {
                    state2d = mystate | APPLY_SCALE;
                }
                return;
        }
    }

    /**
     * 3D implementation of {@code prependScale()}.
     * Works fine if this is a 2D transform.
     */
    private void preScale3D(double sx, double sy, double sz) {
        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                preScale2D(sx, sy);
                if (sz != 1.0) {
                    setMzz(sz);
                    if ((state2d &amp; APPLY_SHEAR) == 0) {
                        state3d = (state2d &amp; APPLY_TRANSLATE) | APPLY_SCALE;
                    } else {
                        state3d = APPLY_3D_COMPLEX;
                    }
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                setTx(getTx() * sx);
                setTy(getTy() * sy);
                setTz(getTz() * sz);
                setMxx(getMxx() * sx);
                setMyy(getMyy() * sy);
                setMzz(getMzz() * sz);
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0 &amp;&amp; getTz() == 0.0) {
                    state3d &amp;= ~APPLY_TRANSLATE;
                }
                if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0 &amp;&amp; getMzz() == 1.0) {
                    state3d &amp;= ~APPLY_SCALE;
                }
                if (getTz() == 0.0 &amp;&amp; getMzz() == 1.0) {
                    state2d = state3d;
                    state3d = APPLY_NON_3D;
                }
                return;
            case APPLY_SCALE:
                setMxx(getMxx() * sx);
                setMyy(getMyy() * sy);
                setMzz(getMzz() * sz);
                if (getMzz() == 1.0) {
                    state3d = APPLY_NON_3D;
                    if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
                        state2d = APPLY_IDENTITY;
                    } else {
                        state2d = APPLY_SCALE;
                    }
                }
                return;
            case APPLY_TRANSLATE:
                setTx(getTx() * sx);
                setTy(getTy() * sy);
                setTz(getTz() * sz);
                setMxx(sx);
                setMyy(sy);
                setMzz(sz);
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0 &amp;&amp; getTz() == 0.0) {
                    state3d &amp;= ~APPLY_TRANSLATE;
                }
                if (sx != 1.0 || sy != 1.0 || sz != 1.0) {
                    state3d |= APPLY_SCALE;
                }
                return;
            case APPLY_3D_COMPLEX:
                setMxx(getMxx() * sx);
                setMxy(getMxy() * sx);
                setMxz(getMxz() * sx);
                setTx(getTx() * sx);

                setMyx(getMyx() * sy);
                setMyy(getMyy() * sy);
                setMyz(getMyz() * sy);
                setTy(getTy() * sy);

                setMzx(getMzx() * sz);
                setMzy(getMzy() * sz);
                setMzz(getMzz() * sz);
                setTz(getTz() * sz);

                if (sx == 0.0 || sy == 0.0 || sz == 0.0) {
                    updateState();
                } // otherwise state remains COMPLEX
                return;
        }
    }

               /* *************************************************
                *                     Shear                       *
                **************************************************/

    /**
     * &lt;p&gt;
     * Appends the shear to this instance.
     * It is equivalent to {@code append(new Shear(sx, sy))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * shear second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified shear.
     * &lt;/p&gt;
     * @param shx the XY coordinate element
     * @param shy the YX coordinate element
     * @since JavaFX 8.0
     */
    public void appendShear(double shx, double shy) {
        atomicChange.start();
        shear2D(shx, shy);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the shear with pivot to this instance.
     * It is equivalent to {@code append(new Shear(sx, sy, pivotX, pivotY))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * shear second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified shear.
     * &lt;/p&gt;
     * @param shx the XY coordinate element
     * @param shy the YX coordinate element
     * @param pivotX the X coordinate of the shear pivot point
     * @param pivotY the Y coordinate of the shear pivot point
     * @since JavaFX 8.0
     */
    public void appendShear(double shx, double shy,
            double pivotX, double pivotY) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0) {
            translate2D(pivotX, pivotY);
            shear2D(shx, shy);
            translate2D(-pivotX, -pivotY);
        } else {
            shear2D(shx, shy);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the shear with pivot to this instance.
     * It is equivalent to {@code append(new Shear(sx, sy,
     * pivot.getX(), pivot.getY()))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * shear second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified shear.
     * &lt;/p&gt;
     * @param shx the XY coordinate element
     * @param shy the YX coordinate element
     * @param pivot the shear pivot point
     * @throws NullPointerException if the specified {@code pivot} is null
     * @since JavaFX 8.0
     */
    public void appendShear(double shx, double shy, Point2D pivot) {
        appendShear(shx, shy, pivot.getX(), pivot.getY());
    }

    /**
     * 2D implementation of {@code appendShear()}.
     * If this is a 3D transform, the call is redirected to {@code shear3D()}.
     */
    private void shear2D(double shx, double shy) {

        if (state3d != APPLY_NON_3D) {
            shear3D(shx, shy);
            return;
        }

        int mystate = state2d;
        switch (mystate) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SHEAR | APPLY_SCALE:
                double M0, M1;
                M0 = getMxx();
                M1 = getMxy();
                setMxx(M0 + M1 * shy);
                setMxy(M0 * shx + M1);

                M0 = getMyx();
                M1 = getMyy();
                setMyx(M0 + M1 * shy);
                setMyy(M0 * shx + M1);
                updateState2D();
                return;
            case APPLY_SHEAR | APPLY_TRANSLATE:
            case APPLY_SHEAR:
                setMxx(getMxy() * shy);
                setMyy(getMyx() * shx);
                if (getMxx() != 0.0 || getMyy() != 0.0) {
                    state2d = mystate | APPLY_SCALE;
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SCALE:
                setMxy(getMxx() * shx);
                setMyx(getMyy() * shy);
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state2d = mystate | APPLY_SHEAR;
                }
                return;
            case APPLY_TRANSLATE:
            case APPLY_IDENTITY:
                setMxy(shx);
                setMyx(shy);
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state2d = mystate | APPLY_SCALE | APPLY_SHEAR;
                }
                return;
        }
    }

    /**
     * 3D implementation of {@code appendShear()}.
     * Works fine if this is a 2D transform.
     */
    private void shear3D(double shx, double shy) {
        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                // cannot happen because currently there is no 3D appendShear
                // that would call this method directly
                shear2D(shx, shy);
                return;
            case APPLY_TRANSLATE:
                setMxy(shx);
                setMyx(shy);
                if (shx != 0.0 || shy != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_SCALE:
            case APPLY_SCALE | APPLY_TRANSLATE:
                setMxy(getMxx() * shx);
                setMyx(getMyy() * shy);
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_3D_COMPLEX:
                final double m_xx = getMxx();
                final double m_xy = getMxy();
                final double m_yx = getMyx();
                final double m_yy = getMyy();
                final double m_zx = getMzx();
                final double m_zy = getMzy();

                setMxx(m_xx + m_xy * shy);
                setMxy(m_xy + m_xx * shx);
                setMyx(m_yx + m_yy * shy);
                setMyy(m_yy + m_yx * shx);
                setMzx(m_zx + m_zy * shy);
                setMzy(m_zy + m_zx * shx);
                updateState();
                return;
        }
    }

    /**
     * &lt;p&gt;
     * Prepends the shear to this instance.
     * It is equivalent to {@code prepend(new Shear(sx, sy))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified shear first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified shear.
     * &lt;/p&gt;
     * @param shx the XY coordinate element
     * @param shy the YX coordinate element
     * @since JavaFX 8.0
     */
    public void prependShear(double shx, double shy) {
        atomicChange.start();
        preShear2D(shx, shy);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the shear with pivot to this instance.
     * It is equivalent to {@code prepend(new Shear(sx, sy, pivotX, pivotY))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified shear first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified shear.
     * &lt;/p&gt;
     * @param shx the XY coordinate element
     * @param shy the YX coordinate element
     * @param pivotX the X coordinate of the shear pivot point
     * @param pivotY the Y coordinate of the shear pivot point
     * @since JavaFX 8.0
     */
    public void prependShear(double shx, double shy,
            double pivotX, double pivotY) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0) {
            preTranslate2D(-pivotX, -pivotY);
            preShear2D(shx, shy);
            preTranslate2D(pivotX, pivotY);
        } else {
            preShear2D(shx, shy);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the shear with pivot to this instance.
     * It is equivalent to {@code prepend(new Shear(sx, sy, pivot.getX(),
     * pivot.getY()))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified shear first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified shear.
     * &lt;/p&gt;
     * @param shx the XY coordinate element
     * @param shy the YX coordinate element
     * @param pivot the shear pivot point
     * @throws NullPointerException if the specified {@code pivot} is null
     * @since JavaFX 8.0
     */
    public void prependShear(double shx, double shy, Point2D pivot) {
        prependShear(shx, shy, pivot.getX(), pivot.getY());
    }

    /**
     * 2D implementation of {@code prependShear()}.
     * If this is a 3D transform, the call is redirected to {@code preShear3D()}.
     */
    private void preShear2D(double shx, double shy) {

        if (state3d != APPLY_NON_3D) {
            preShear3D(shx, shy);
            return;
        }

        int mystate = state2d;

        switch (mystate) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SHEAR | APPLY_TRANSLATE:
                final double t_x_1 = getTx();
                final double t_y_1 = getTy();
                setTx(t_x_1 + shx * t_y_1);
                setTy(t_y_1 + shy * t_x_1);
                // fall-through
            case APPLY_SHEAR | APPLY_SCALE:
            case APPLY_SHEAR:
                final double m_xx = getMxx();
                final double m_xy = getMxy();
                final double m_yx = getMyx();
                final double m_yy = getMyy();

                setMxx(m_xx + shx * m_yx);
                setMxy(m_xy + shx * m_yy);
                setMyx(shy * m_xx + m_yx);
                setMyy(shy * m_xy + m_yy);
                updateState2D();
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                final double t_x_2 = getTx();
                final double t_y_2 = getTy();
                setTx(t_x_2 + shx * t_y_2);
                setTy(t_y_2 + shy * t_x_2);
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    mystate = mystate &amp; ~APPLY_TRANSLATE;
                    state2d = mystate;
                }
                // fall-through
            case APPLY_SCALE:
                setMxy(shx * getMyy());
                setMyx(shy * getMxx());
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state2d = mystate | APPLY_SHEAR;
                }
                return;
            case APPLY_TRANSLATE:
                final double t_x_3 = getTx();
                final double t_y_3 = getTy();
                setTx(t_x_3 + shx * t_y_3);
                setTy(t_y_3 + shy * t_x_3);
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    mystate = mystate &amp; ~APPLY_TRANSLATE;
                    state2d = mystate;
                }
                // fall-through
            case APPLY_IDENTITY:
                setMxy(shx);
                setMyx(shy);
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state2d = mystate | APPLY_SCALE | APPLY_SHEAR;
                }
                return;
        }
    }

    /**
     * 3D implementation of {@code prependShear()}.
     * Works fine if this is a 2D transform.
     */
    private void preShear3D(double shx, double shy) {

        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                // cannot happen because currently there is no 3D prependShear
                // that would call this method directly
                preShear2D(shx, shy);
                return;
            case APPLY_TRANSLATE:
                final double tx_t = getTx();
                setMxy(shx);
                setTx(tx_t + getTy() * shx);
                setMyx(shy);
                setTy(tx_t * shy + getTy());

                if (shx != 0.0 || shy != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_SCALE:
                setMxy(getMyy() * shx);
                setMyx(getMxx() * shy);

                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                final double tx_st = getTx();
                setMxy(getMyy() * shx);
                setTx(tx_st + getTy() * shx);
                setMyx(getMxx() * shy);
                setTy(tx_st * shy + getTy());

                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_3D_COMPLEX:

                final double m_xx = getMxx();
                final double m_xy = getMxy();
                final double m_yx = getMyx();
                final double t_x = getTx();
                final double m_yy = getMyy();
                final double m_xz = getMxz();
                final double m_yz = getMyz();
                final double t_y = getTy();

                setMxx(m_xx + m_yx * shx);
                setMxy(m_xy + m_yy * shx);
                setMxz(m_xz + m_yz * shx);
                setTx(t_x + t_y * shx);
                setMyx(m_xx * shy + m_yx);
                setMyy(m_xy * shy + m_yy);
                setMyz(m_xz * shy + m_yz);
                setTy(t_x * shy + t_y);

                updateState();
                return;
        }
    }

               /* *************************************************
                *                     Rotate                      *
                **************************************************/

    /**
     * &lt;p&gt;
     * Appends the 2D rotation to this instance.
     * It is equivalent to {@code append(new Rotate(angle))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * rotation second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @since JavaFX 8.0
     */
    public void appendRotation(double angle) {
        atomicChange.start();
        rotate2D(angle);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the 2D rotation with pivot to this instance.
     * It is equivalent to {@code append(new Rotate(angle, pivotX, pivotY))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * rotation second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @since JavaFX 8.0
     */
    public void appendRotation(double angle,
            double pivotX, double pivotY) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0) {
<A NAME="29"></A>            translate2D(pivotX, pivotY);
            rotate2D(angle);
            translate2D(-pivotX, -pivotY);
        } else <FONT color="#faafba"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#29',2,'match31-top.html#29',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
            rotate2D(angle);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the 2D rotation with pivot to this instance.
     * It is equivalent to {@code append(new Rotate(angle, pivot.getX(),
     * pivot.getY()))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * rotation second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivot the rotation pivot point
     * @throws NullPointerException if the specified {@code pivot} is null
     * @since JavaFX 8.0
     */
    public void appendRotation(double angle, Point2D pivot) {
        appendRotation(angle, pivot.getX(), pivot.getY());
    }

    /**
     * &lt;p&gt;
     * Appends the rotation to this instance.
     * It is equivalent to {@code append(new Rotate(angle, pivotX, pivotY,
     * pivotZ, new Point3D(axisX, axisY, axisZ)))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * rotation second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @param pivotZ the Z coordinate of the rotation pivot point
     * @param axisX the X coordinate magnitude of the rotation axis
     * @param axisY the Y coordinate magnitude of the rotation axis
     * @param axisZ the Z coordinate magnitude of the rotation axis
     * @since JavaFX 8.0
     */
    public void appendRotation(double angle,
            double pivotX</B></FONT>, double pivotY, double pivotZ,
            double axisX, double axisY, double axisZ) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0 || pivotZ != 0.0) {
            translate3D(pivotX, pivotY, pivotZ);
            rotate3D(angle, axisX, axisY, axisZ);
            translate3D(-pivotX, -pivotY, -pivotZ);
        } else {
            rotate3D(angle, axisX, axisY, axisZ);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Appends the rotation to this instance.
     * It is equivalent to {@code append(new Rotate(angle, pivotX, pivotY,
     * pivotZ, axis))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * rotation second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @param pivotZ the Z coordinate of the rotation pivot point
     * @param axis the rotation axis
     * @throws NullPointerException if the specified {@code axis} is null
     * @since JavaFX 8.0
     */
    public void appendRotation(double angle,
            double pivotX, double pivotY, double pivotZ,
            Point3D axis) {
        appendRotation(angle, pivotX, pivotY, pivotZ,
                axis.getX(), axis.getY(), axis.getZ());
    }

    /**
     * &lt;p&gt;
     * Appends the rotation to this instance.
     * It is equivalent to {@code append(new Rotate(angle, pivot.getX(),
     * pivot.getY(), pivot.getZ(), axis))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, {@code this} transform first and the specified
     * rotation second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the right by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivot the rotation pivot point
     * @param axis the rotation axis
     * @throws NullPointerException if the specified {@code pivot}
     *         or {@code axis} is null
     * @since JavaFX 8.0
     */
    public void appendRotation(double angle, Point3D pivot, Point3D axis) {
        appendRotation(angle, pivot.getX(), pivot.getY(), pivot.getZ(),
                axis.getX(), axis.getY(), axis.getZ());
    }

    /**
     * Implementation of the {@code appendRotation()} around an arbitrary axis.
     */
    private void rotate3D(double angle, double axisX, double axisY, double axisZ) {
        if (axisX == 0.0 &amp;&amp; axisY == 0.0) {
            if (axisZ &gt; 0.0) {
                rotate3D(angle);
            } else if (axisZ &lt; 0.0) {
                rotate3D(-angle);
            } // else rotating about zero vector - NOP
            return;
        }

        double mag = Math.sqrt(axisX * axisX + axisY * axisY + axisZ * axisZ);

        if (mag == 0.0) {
            return;
        }

        mag = 1.0 / mag;
        final double ax = axisX * mag;
        final double ay = axisY * mag;
        final double az = axisZ * mag;

        final double sinTheta = Math.sin(Math.toRadians(angle));
        final double cosTheta = Math.cos(Math.toRadians(angle));
        final double t = 1.0 - cosTheta;

        final double xz = ax * az;
        final double xy = ax * ay;
        final double yz = ay * az;

        final double Txx = t * ax * ax + cosTheta;
        final double Txy = t * xy - sinTheta * az;
        final double Txz = t * xz + sinTheta * ay;

        final double Tyx = t * xy + sinTheta * az;
        final double Tyy = t * ay * ay + cosTheta;
        final double Tyz = t * yz - sinTheta * ax;

        final double Tzx = t * xz - sinTheta * ay;
        final double Tzy = t * yz + sinTheta * ax;
        final double Tzz = t * az * az + cosTheta;

        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch (state2d) {
                    default:
                        stateError();
                        // cannot reach
                    case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                    case APPLY_SHEAR | APPLY_SCALE:
                        final double xx_sst = getMxx();
                        final double xy_sst = getMxy();
                        final double yx_sst = getMyx();
                        final double yy_sst = getMyy();
                        setMxx(xx_sst * Txx + xy_sst * Tyx);
                        setMxy(xx_sst * Txy + xy_sst * Tyy);
                        setMxz(xx_sst * Txz + xy_sst * Tyz);
                        setMyx(yx_sst * Txx + yy_sst * Tyx);
                        setMyy(yx_sst * Txy + yy_sst * Tyy);
                        setMyz(yx_sst * Txz + yy_sst * Tyz);
                        setMzx(Tzx);
                        setMzy(Tzy);
                        setMzz(Tzz);
                        break;
                    case APPLY_SHEAR | APPLY_TRANSLATE:
                    case APPLY_SHEAR:
                        final double xy_sht = getMxy();
                        final double yx_sht = getMyx();
                        setMxx(xy_sht * Tyx);
                        setMxy(xy_sht * Tyy);
                        setMxz(xy_sht * Tyz);
                        setMyx(yx_sht * Txx);
                        setMyy(yx_sht * Txy);
                        setMyz(yx_sht * Txz);
                        setMzx(Tzx);
                        setMzy(Tzy);
                        setMzz(Tzz);
                        break;
                    case APPLY_SCALE | APPLY_TRANSLATE:
                    case APPLY_SCALE:
                        final double xx_s = getMxx();
                        final double yy_s = getMyy();
                        setMxx(xx_s * Txx);
                        setMxy(xx_s * Txy);
                        setMxz(xx_s * Txz);
                        setMyx(yy_s * Tyx);
                        setMyy(yy_s * Tyy);
                        setMyz(yy_s * Tyz);
                        setMzx(Tzx);
                        setMzy(Tzy);
                        setMzz(Tzz);
                        break;
                    case APPLY_TRANSLATE:
                    case APPLY_IDENTITY:
                        setMxx(Txx);
                        setMxy(Txy);
                        setMxz(Txz);
                        setMyx(Tyx);
                        setMyy(Tyy);
                        setMyz(Tyz);
                        setMzx(Tzx);
                        setMzy(Tzy);
                        setMzz(Tzz);
                        break;
                }
                break;
            case APPLY_TRANSLATE:
                setMxx(Txx);
                setMxy(Txy);
                setMxz(Txz);
                setMyx(Tyx);
                setMyy(Tyy);
                setMyz(Tyz);
                setMzx(Tzx);
                setMzy(Tzy);
                setMzz(Tzz);
                break;
            case APPLY_SCALE:
            case APPLY_SCALE | APPLY_TRANSLATE:
                final double xx_st = getMxx();
                final double yy_st = getMyy();
                final double zz_st = getMzz();
                setMxx(xx_st * Txx);
                setMxy(xx_st * Txy);
                setMxz(xx_st * Txz);
                setMyx(yy_st * Tyx);
                setMyy(yy_st * Tyy);
                setMyz(yy_st * Tyz);
                setMzx(zz_st * Tzx);
                setMzy(zz_st * Tzy);
                setMzz(zz_st * Tzz);
                break;
            case APPLY_3D_COMPLEX:
                final double m_xx = getMxx();
                final double m_xy = getMxy();
                final double m_xz = getMxz();
                final double m_yx = getMyx();
                final double m_yy = getMyy();
                final double m_yz = getMyz();
                final double m_zx = getMzx();
                final double m_zy = getMzy();
                final double m_zz = getMzz();
                setMxx(m_xx * Txx + m_xy * Tyx + m_xz * Tzx /* + mxt * 0.0 */);
                setMxy(m_xx * Txy + m_xy * Tyy + m_xz * Tzy /* + mxt * 0.0 */);
                setMxz(m_xx * Txz + m_xy * Tyz + m_xz * Tzz /* + mxt * 0.0 */);
                setMyx(m_yx * Txx + m_yy * Tyx + m_yz * Tzx /* + myt * 0.0 */);
                setMyy(m_yx * Txy + m_yy * Tyy + m_yz * Tzy /* + myt * 0.0 */);
                setMyz(m_yx * Txz + m_yy * Tyz + m_yz * Tzz /* + myt * 0.0 */);
                setMzx(m_zx * Txx + m_zy * Tyx + m_zz * Tzx /* + mzt * 0.0 */);
                setMzy(m_zx * Txy + m_zy * Tyy + m_zz * Tzy /* + mzt * 0.0 */);
                setMzz(m_zx * Txz + m_zy * Tyz + m_zz * Tzz /* + mzt * 0.0 */);
                break;
        }
        updateState();
    }

    /**
     * Table of 2D state changes during predictable quadrant rotations where
     * the shear and scaleAffine values are swapped and negated.
     */
    private static final int rot90conversion[] = {
        /* IDENTITY =&gt; */        APPLY_SHEAR,
        /* TRANSLATE (TR) =&gt; */  APPLY_SHEAR | APPLY_TRANSLATE,
        /* SCALE (SC) =&gt; */      APPLY_SHEAR,
        /* SC | TR =&gt; */         APPLY_SHEAR | APPLY_TRANSLATE,
        /* SHEAR (SH) =&gt; */      APPLY_SCALE,
        /* SH | TR =&gt; */         APPLY_SCALE | APPLY_TRANSLATE,
        /* SH | SC =&gt; */         APPLY_SHEAR | APPLY_SCALE,
        /* SH | SC | TR =&gt; */    APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE,
    };

    /**
     * 2D implementation of {@code appendRotation}.
     * If this is a 3D transform, the call is redirected to {@code rotate3D()}.
     */
    private void rotate2D(double theta) {
        if (state3d != APPLY_NON_3D) {
            rotate3D(theta);
            return;
        }

        double sin = Math.sin(Math.toRadians(theta));
        if (sin == 1.0) {
            rotate2D_90();
        } else if (sin == -1.0) {
            rotate2D_270();
        } else {
            double cos = Math.cos(Math.toRadians(theta));
            if (cos == -1.0) {
                rotate2D_180();
            } else if (cos != 1.0) {
                double M0, M1;
                M0 = getMxx();
                M1 = getMxy();
                setMxx(cos * M0 + sin * M1);
                setMxy(-sin * M0 + cos * M1);
                M0 = getMyx();
                M1 = getMyy();
                setMyx(cos * M0 + sin * M1);
                setMyy(-sin * M0 + cos * M1);
                updateState2D();
            }
        }
    }

    /**
     * 2D implementation of {@code appendRotation} for 90 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 3D transform.
     */
    private void rotate2D_90() {
        double M0 = getMxx();
        setMxx(getMxy());
        setMxy(-M0);
        M0 = getMyx();
        setMyx(getMyy());
        setMyy(-M0);
        int newstate = rot90conversion[state2d];
        if ((newstate &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SCALE &amp;&amp;
                getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
            newstate -= APPLY_SCALE;
        } else if ((newstate &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SHEAR &amp;&amp;
                getMxy() == 0.0 &amp;&amp; getMyx() == 0.0) {
            newstate = (newstate &amp; ~APPLY_SHEAR | APPLY_SCALE);
        }
        state2d = newstate;
    }

    /**
     * 2D implementation of {@code appendRotation} for 180 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 3D transform.
     */
    private void rotate2D_180() {
        setMxx(-getMxx());
        setMyy(-getMyy());
        int oldstate = state2d;
        if ((oldstate &amp; (APPLY_SHEAR)) != 0) {
            // If there was a shear, then this rotation has no
            // effect on the state.
            setMxy(-getMxy());
            setMyx(-getMyx());
        } else {
            // No shear means the SCALE state may toggle when
            // m00 and m11 are negated.
            if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
                state2d = oldstate &amp; ~APPLY_SCALE;
            } else {
                state2d = oldstate | APPLY_SCALE;
            }
        }
    }

    /**
     * 2D implementation of {@code appendRotation} for 270 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 3D transform.
     */
    private void rotate2D_270() {
        double M0 = getMxx();
        setMxx(-getMxy());
        setMxy(M0);
        M0 = getMyx();
        setMyx(-getMyy());
        setMyy(M0);
        int newstate = rot90conversion[state2d];
        if ((newstate &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SCALE &amp;&amp;
                getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
            newstate -= APPLY_SCALE;
        } else if ((newstate &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SHEAR &amp;&amp;
                getMxy() == 0.0 &amp;&amp; getMyx() == 0.0) {
            newstate = (newstate &amp; ~APPLY_SHEAR | APPLY_SCALE);
        }
        state2d = newstate;
    }

    /**
     * 3D implementation of {@code appendRotation} around Z axis.
     * If this is a 2D transform, the call is redirected to {@code rotate2D()}.
     */
    private void rotate3D(double theta) {
        if (state3d == APPLY_NON_3D) {
            rotate2D(theta);
            return;
        }

        double sin = Math.sin(Math.toRadians(theta));
        if (sin == 1.0) {
            rotate3D_90();
        } else if (sin == -1.0) {
            rotate3D_270();
        } else {
            double cos = Math.cos(Math.toRadians(theta));
            if (cos == -1.0) {
                rotate3D_180();
            } else if (cos != 1.0) {
                double M0, M1;
                M0 = getMxx();
                M1 = getMxy();
                setMxx(cos * M0 + sin * M1);
                setMxy(-sin * M0 + cos * M1);
                M0 = getMyx();
                M1 = getMyy();
                setMyx(cos * M0 + sin * M1);
                setMyy(-sin * M0 + cos * M1);
                M0 = getMzx();
                M1 = getMzy();
                setMzx(cos * M0 + sin * M1);
                setMzy(-sin * M0 + cos * M1);
                updateState();
            }
        }
    }

    /**
     * 3D implementation of {@code appendRotation} for 90 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 2D transform.
     */
    private void rotate3D_90() {
        double M0 = getMxx();
        setMxx(getMxy());
        setMxy(-M0);
        M0 = getMyx();
        setMyx(getMyy());
        setMyy(-M0);
        M0 = getMzx();
        setMzx(getMzy());
        setMzy(-M0);
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_TRANSLATE:
                state3d = APPLY_3D_COMPLEX;
                return;
            case APPLY_SCALE:
            case APPLY_SCALE | APPLY_TRANSLATE:
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_3D_COMPLEX:
                updateState();
                return;
        }
    }

    /**
     * 3D implementation of {@code appendRotation} for 180 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 2D transform.
     */
    private void rotate3D_180() {
        final double mxx = getMxx();
        final double myy = getMyy();
        setMxx(-mxx);
        setMyy(-myy);
        if (state3d == APPLY_3D_COMPLEX) {
            setMxy(-getMxy());
            setMyx(-getMyx());
            setMzx(-getMzx());
            setMzy(-getMzy());
            updateState();
            return;
        }

        if (mxx == -1.0 &amp;&amp; myy == -1.0 &amp;&amp; getMzz() == 1.0) {
            // must have been 3d because of translation, which remained
            state3d &amp;= ~APPLY_SCALE;
        } else {
            state3d |= APPLY_SCALE;
        }
    }

    /**
     * 3D implementation of {@code appendRotation} for 270 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 2D transform.
     */
    private void rotate3D_270() {
        double M0 = getMxx();
        setMxx(-getMxy());
        setMxy(M0);
        M0 = getMyx();
        setMyx(-getMyy());
        setMyy(M0);
        M0 = getMzx();
        setMzx(-getMzy());
        setMzy(M0);
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_TRANSLATE:
                state3d = APPLY_3D_COMPLEX;
                return;
            case APPLY_SCALE:
            case APPLY_SCALE | APPLY_TRANSLATE:
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_3D_COMPLEX:
                updateState();
                return;
        }
    }

    /**
     * &lt;p&gt;
     * Prepends the 2D rotation to this instance.
     * It is equivalent to {@code prepend(new Rotate(angle))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified rotation first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @since JavaFX 8.0
     */
    public void prependRotation(double angle) {
        atomicChange.start();
        preRotate2D(angle);
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the 2D rotation with pivot to this instance.
     * It is equivalent to {@code prepend(new Rotate(angle, pivotX, pivotY))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified rotation first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @since JavaFX 8.0
     */
    public void prependRotation(double angle, double pivotX, double pivotY) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0) {
            preTranslate2D(-pivotX, -pivotY);
            preRotate2D(angle);
            preTranslate2D(pivotX, pivotY);
        } else {
            preRotate2D(angle);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the 2D rotation with pivot to this instance.
     * It is equivalent to {@code prepend(new Rotate(angle, pivot.getX(),
     * pivot.getY()))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified rotation first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivot the rotation pivot point
     * @throws NullPointerException if the specified {@code pivot} is null
     * @since JavaFX 8.0
     */
    public void prependRotation(double angle, Point2D pivot) {
        prependRotation(angle, pivot.getX(), pivot.getY());
    }

    /**
     * &lt;p&gt;
     * Prepends the rotation to this instance.
     * It is equivalent to {@code prepend(new Rotate(angle, pivotX, pivotY,
     * pivotZ, new Point3D(axisX, axisY, axisZ)))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified rotation first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @param pivotZ the Z coordinate of the rotation pivot point
     * @param axisX the X coordinate magnitude of the rotation axis
     * @param axisY the Y coordinate magnitude of the rotation axis
     * @param axisZ the Z coordinate magnitude of the rotation axis
     * @since JavaFX 8.0
     */
    public void prependRotation(double angle,
            double pivotX, double pivotY, double pivotZ,
            double axisX, double axisY, double axisZ) {
        atomicChange.start();
        if (pivotX != 0.0 || pivotY != 0.0 || pivotZ != 0.0) {
            preTranslate3D(-pivotX, -pivotY, -pivotZ);
            preRotate3D(angle, axisX, axisY, axisZ);
            preTranslate3D(pivotX, pivotY, pivotZ);
        } else {
            preRotate3D(angle, axisX, axisY, axisZ);
        }
        atomicChange.end();
    }

    /**
     * &lt;p&gt;
     * Prepends the rotation to this instance.
     * It is equivalent to {@code prepend(new Rotate(angle, pivotX, pivotY,
     * pivotZ, axis))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified rotation first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @param pivotZ the Z coordinate of the rotation pivot point
     * @param axis the rotation axis
     * @throws NullPointerException if the specified {@code axis} is null
     * @since JavaFX 8.0
     */
    public void prependRotation(double angle,
            double pivotX, double pivotY, double pivotZ,
            Point3D axis) {
        prependRotation(angle, pivotX, pivotY, pivotZ,
                axis.getX(), axis.getY(), axis.getZ());
    }

    /**
     * &lt;p&gt;
     * Prepends the rotation to this instance.
     * It is equivalent to {@code prepend(new Rotate(angle, pivot.getX(),
     * pivot.getY(), pivot.getZ(), axis))}.
     * &lt;/p&gt;&lt;p&gt;
     * The operation modifies this transform in a way that applying it to a node
     * has the same effect as adding two transforms to its
     * {@code getTransforms()} list, the specified rotation first
     * and {@code this} transform second.
     * &lt;/p&gt;&lt;p&gt;
     * From the matrix point of view, the transformation matrix of this
     * transform is multiplied on the left by the transformation matrix of
     * the specified rotation.
     * &lt;/p&gt;
     * @param angle the angle of the rotation in degrees
     * @param pivot the rotation pivot point
     * @param axis the rotation axis
     * @throws NullPointerException if the specified {@code pivot}
     *         or {@code axis} is null
     * @since JavaFX 8.0
     */
    public void prependRotation(double angle, Point3D pivot, Point3D axis) {
        prependRotation(angle, pivot.getX(), pivot.getY(), pivot.getZ(),
                axis.getX(), axis.getY(), axis.getZ());
    }

    /**
     * Implementation of the {@code prependRotation()} around an arbitrary axis.
     */
    private void preRotate3D(double angle,
            double axisX, double axisY, double axisZ) {

        if (axisX == 0.0 &amp;&amp; axisY == 0.0) {
            if (axisZ &gt; 0.0) {
                preRotate3D(angle);
            } else if (axisZ &lt; 0.0) {
                preRotate3D(-angle);
            } // else rotating about zero vector - NOP
            return;
        }

        double mag = Math.sqrt(axisX * axisX + axisY * axisY + axisZ * axisZ);

        if (mag == 0.0) {
            return;
        }

        mag = 1.0 / mag;
        final double ax = axisX * mag;
        final double ay = axisY * mag;
        final double az = axisZ * mag;

        final double sinTheta = Math.sin(Math.toRadians(angle));
        final double cosTheta = Math.cos(Math.toRadians(angle));
        final double t = 1.0 - cosTheta;

        final double xz = ax * az;
        final double xy = ax * ay;
        final double yz = ay * az;

        final double Txx = t * ax * ax + cosTheta;
        final double Txy = t * xy - sinTheta * az;
        final double Txz = t * xz + sinTheta * ay;

        final double Tyx = t * xy + sinTheta * az;
        final double Tyy = t * ay * ay + cosTheta;
        final double Tyz = t * yz - sinTheta * ax;

        final double Tzx = t * xz - sinTheta * ay;
        final double Tzy = t * yz + sinTheta * ax;
        final double Tzz = t * az * az + cosTheta;

        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch (state2d) {
                    default:
                        stateError();
                        // cannot reach
                    case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                        final double xx_sst = getMxx();
                        final double xy_sst = getMxy();
                        final double tx_sst = getTx();
                        final double yx_sst = getMyx();
                        final double yy_sst = getMyy();
                        final double ty_sst = getTy();
                        setMxx(Txx * xx_sst + Txy * yx_sst);
                        setMxy(Txx * xy_sst + Txy * yy_sst);
                        setMxz(Txz);
                        setTx( Txx * tx_sst  + Txy * ty_sst);
                        setMyx(Tyx * xx_sst + Tyy * yx_sst);
                        setMyy(Tyx * xy_sst + Tyy * yy_sst);
                        setMyz(Tyz);
                        setTy( Tyx * tx_sst  + Tyy * ty_sst);
                        setMzx(Tzx * xx_sst + Tzy * yx_sst);
                        setMzy(Tzx * xy_sst + Tzy * yy_sst);
                        setMzz(Tzz);
                        setTz( Tzx * tx_sst  + Tzy * ty_sst);
                        break;
                    case APPLY_SHEAR | APPLY_SCALE:
                        final double xx_ss = getMxx();
                        final double xy_ss = getMxy();
                        final double yx_ss = getMyx();
                        final double yy_ss = getMyy();
                        setMxx(Txx * xx_ss + Txy * yx_ss);
                        setMxy(Txx * xy_ss + Txy * yy_ss);
                        setMxz(Txz);
                        setMyx(Tyx * xx_ss + Tyy * yx_ss);
                        setMyy(Tyx * xy_ss + Tyy * yy_ss);
                        setMyz(Tyz);
                        setMzx(Tzx * xx_ss + Tzy * yx_ss);
                        setMzy(Tzx * xy_ss + Tzy * yy_ss);
                        setMzz(Tzz);
                        break;
                    case APPLY_SHEAR | APPLY_TRANSLATE:
                        final double xy_sht = getMxy();
                        final double tx_sht = getTx();
                        final double yx_sht = getMyx();
                        final double ty_sht = getTy();
                        setMxx(Txy * yx_sht);
                        setMxy(Txx * xy_sht);
                        setMxz(Txz);
                        setTx( Txx * tx_sht  + Txy * ty_sht);
                        setMyx(Tyy * yx_sht);
                        setMyy(Tyx * xy_sht);
                        setMyz(Tyz);
                        setTy( Tyx * tx_sht  + Tyy * ty_sht);
                        setMzx(Tzy * yx_sht);
                        setMzy(Tzx * xy_sht);
                        setMzz(Tzz);
                        setTz( Tzx * tx_sht  + Tzy * ty_sht);
                        break;
                    case APPLY_SHEAR:
                        final double xy_sh = getMxy();
                        final double yx_sh = getMyx();
                        setMxx(Txy * yx_sh);
                        setMxy(Txx * xy_sh);
                        setMxz(Txz);
                        setMyx(Tyy * yx_sh);
                        setMyy(Tyx * xy_sh);
                        setMyz(Tyz);
                        setMzx(Tzy * yx_sh);
                        setMzy(Tzx * xy_sh);
                        setMzz(Tzz);
                        break;
                    case APPLY_SCALE | APPLY_TRANSLATE:
                        final double xx_st = getMxx();
                        final double tx_st = getTx();
                        final double yy_st = getMyy();
                        final double ty_st = getTy();
                        setMxx(Txx * xx_st);
                        setMxy(Txy * yy_st);
                        setMxz(Txz);
                        setTx( Txx * tx_st  + Txy * ty_st);
                        setMyx(Tyx * xx_st);
                        setMyy(Tyy * yy_st);
                        setMyz(Tyz);
                        setTy( Tyx * tx_st  + Tyy * ty_st);
                        setMzx(Tzx * xx_st);
                        setMzy(Tzy * yy_st);
                        setMzz(Tzz);
                        setTz( Tzx * tx_st  + Tzy * ty_st);
                        break;
                    case APPLY_SCALE:
                        final double xx_s = getMxx();
                        final double yy_s = getMyy();
                        setMxx(Txx * xx_s);
                        setMxy(Txy * yy_s);
                        setMxz(Txz);
                        setMyx(Tyx * xx_s);
                        setMyy(Tyy * yy_s);
                        setMyz(Tyz);
                        setMzx(Tzx * xx_s);
                        setMzy(Tzy * yy_s);
                        setMzz(Tzz);
                        break;
                    case APPLY_TRANSLATE:
                        final double tx_t = getTx();
                        final double ty_t = getTy();
                        setMxx(Txx);
                        setMxy(Txy);
                        setMxz(Txz);
                        setTx( Txx * tx_t  + Txy * ty_t);
                        setMyx(Tyx);
                        setMyy(Tyy);
                        setMyz(Tyz);
                        setTy( Tyx * tx_t  + Tyy * ty_t);
                        setMzx(Tzx);
                        setMzy(Tzy);
                        setMzz(Tzz);
                        setTz( Tzx * tx_t  + Tzy * ty_t);
                        break;
                    case APPLY_IDENTITY:
                        setMxx(Txx);
                        setMxy(Txy);
                        setMxz(Txz);
                        setMyx(Tyx);
                        setMyy(Tyy);
                        setMyz(Tyz);
                        setMzx(Tzx);
                        setMzy(Tzy);
                        setMzz(Tzz);
                        break;
                }
                break;
            case APPLY_TRANSLATE:
                final double tx_t = getTx();
                final double ty_t = getTy();
                final double tz_t = getTz();
                setMxx(Txx);
                setMxy(Txy);
                setMxz(Txz);
                setMyx(Tyx);
                setMyy(Tyy);
                setMyz(Tyz);
                setMzx(Tzx);
                setMzy(Tzy);
                setMzz(Tzz);
                setTx( Txx * tx_t  + Txy * ty_t  + Txz * tz_t);
                setTy( Tyx * tx_t  + Tyy * ty_t  + Tyz * tz_t);
                setTz( Tzx * tx_t  + Tzy * ty_t  + Tzz * tz_t);
                break;
            case APPLY_SCALE:
                final double xx_s = getMxx();
                final double yy_s = getMyy();
                final double zz_s = getMzz();
                setMxx(Txx * xx_s);
                setMxy(Txy * yy_s);
                setMxz(Txz * zz_s);
                setMyx(Tyx * xx_s);
                setMyy(Tyy * yy_s);
                setMyz(Tyz * zz_s);
                setMzx(Tzx * xx_s);
                setMzy(Tzy * yy_s);
                setMzz(Tzz * zz_s);
                break;
            case APPLY_SCALE | APPLY_TRANSLATE:
                final double xx_st = getMxx();
                final double tx_st = getTx();
                final double yy_st = getMyy();
                final double ty_st = getTy();
                final double zz_st = getMzz();
                final double tz_st = getTz();
                setMxx(Txx * xx_st);
                setMxy(Txy * yy_st);
                setMxz(Txz * zz_st);
                setTx( Txx * tx_st  + Txy * ty_st  + Txz * tz_st);
                setMyx(Tyx * xx_st);
                setMyy(Tyy * yy_st);
                setMyz(Tyz * zz_st);
                setTy( Tyx * tx_st  + Tyy * ty_st  + Tyz * tz_st);
                setMzx(Tzx * xx_st);
                setMzy(Tzy * yy_st);
                setMzz(Tzz * zz_st);
                setTz( Tzx * tx_st  + Tzy * ty_st  + Tzz * tz_st);
                break;
            case APPLY_3D_COMPLEX:
                final double m_xx = getMxx();
                final double m_xy = getMxy();
                final double m_xz = getMxz();
                final double t_x = getTx();
                final double m_yx = getMyx();
                final double m_yy = getMyy();
                final double m_yz = getMyz();
                final double t_y = getTy();
                final double m_zx = getMzx();
                final double m_zy = getMzy();
                final double m_zz = getMzz();
                final double t_z = getTz();
                setMxx(Txx * m_xx + Txy * m_yx + Txz * m_zx /* + Ttx * 0.0 */);
                setMxy(Txx * m_xy + Txy * m_yy + Txz * m_zy /* + Ttx * 0.0 */);
                setMxz(Txx * m_xz + Txy * m_yz + Txz * m_zz /* + Ttx * 0.0 */);
                setTx( Txx * t_x  + Txy * t_y  + Txz * t_z  /* + Ttx * 0.0 */);
                setMyx(Tyx * m_xx + Tyy * m_yx + Tyz * m_zx /* + Tty * 0.0 */);
                setMyy(Tyx * m_xy + Tyy * m_yy + Tyz * m_zy /* + Tty * 0.0 */);
                setMyz(Tyx * m_xz + Tyy * m_yz + Tyz * m_zz /* + Tty * 0.0 */);
                setTy( Tyx * t_x  + Tyy * t_y  + Tyz * t_z  /* + Tty * 0.0 */);
                setMzx(Tzx * m_xx + Tzy * m_yx + Tzz * m_zx /* + Ttz * 0.0 */);
                setMzy(Tzx * m_xy + Tzy * m_yy + Tzz * m_zy /* + Ttz * 0.0 */);
                setMzz(Tzx * m_xz + Tzy * m_yz + Tzz * m_zz /* + Ttz * 0.0 */);
                setTz( Tzx * t_x  + Tzy * t_y  + Tzz * t_z  /* + Ttz * 0.0 */);
                break;
        }

        updateState();
    }

    /**
     * 2D implementation of {@code prependRotation}.
     * If this is a 3D transform, the call is redirected to {@code preRotate3D()}.
     */
    private void preRotate2D(double theta) {

        if (state3d != APPLY_NON_3D) {
            preRotate3D(theta);
            return;
        }

        double sin = Math.sin(Math.toRadians(theta));
        if (sin == 1.0) {
            preRotate2D_90();
        } else if (sin == -1.0) {
            preRotate2D_270();
        } else {
            double cos = Math.cos(Math.toRadians(theta));
            if (cos == -1.0) {
                preRotate2D_180();
            } else if (cos != 1.0) {
                double M0, M1;
                M0 = getMxx();
                M1 = getMyx();
                setMxx(cos * M0 - sin * M1);
                setMyx(sin * M0 + cos * M1);
                M0 = getMxy();
                M1 = getMyy();
                setMxy(cos * M0 - sin * M1);
                setMyy(sin * M0 + cos * M1);
                M0 = getTx();
                M1 = getTy();
                setTx(cos * M0 - sin * M1);
                setTy(sin * M0 + cos * M1);
                updateState2D();
            }
        }
    }

    /**
     * 2D implementation of {@code prependRotation} for 90 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 3D transform.
     */
    private void preRotate2D_90() {
        double M0 = getMxx();
        setMxx(-getMyx());
        setMyx(M0);
        M0 = getMxy();
        setMxy(-getMyy());
        setMyy(M0);
        M0 = getTx();
        setTx(-getTy());
        setTy(M0);

        int newstate = rot90conversion[state2d];
        if ((newstate &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SCALE &amp;&amp;
                getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
            newstate -= APPLY_SCALE;
        } else if ((newstate &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SHEAR &amp;&amp;
                getMxy() == 0.0 &amp;&amp; getMyx() == 0.0) {
            newstate = (newstate &amp; ~APPLY_SHEAR | APPLY_SCALE);
        }
        state2d = newstate;
    }

    /**
     * 2D implementation of {@code prependRotation} for 180 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 3D transform.
     */
    private void preRotate2D_180() {
        setMxx(-getMxx());
        setMxy(-getMxy());
        setTx(-getTx());
        setMyx(-getMyx());
        setMyy(-getMyy());
        setTy(-getTy());

        if ((state2d &amp; APPLY_SHEAR) != 0) {
            if (getMxx() == 0.0 &amp;&amp; getMyy() == 0.0) {
                state2d &amp;= ~APPLY_SCALE;
            } else {
                state2d |= APPLY_SCALE;
            }
        } else {
            if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
                state2d &amp;= ~APPLY_SCALE;
            } else {
                state2d |= APPLY_SCALE;
            }
        }
    }

    /**
     * 2D implementation of {@code prependRotation} for 270 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 3D transform.
     */
    private void preRotate2D_270() {
        double M0 = getMxx();
        setMxx(getMyx());
        setMyx(-M0);
        M0 = getMxy();
        setMxy(getMyy());
        setMyy(-M0);
        M0 = getTx();
        setTx(getTy());
        setTy(-M0);

        int newstate = rot90conversion[state2d];
        if ((newstate &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SCALE &amp;&amp;
                getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
            newstate -= APPLY_SCALE;
        } else if ((newstate &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SHEAR &amp;&amp;
                getMxy() == 0.0 &amp;&amp; getMyx() == 0.0) {
            newstate = (newstate &amp; ~APPLY_SHEAR | APPLY_SCALE);
        }
        state2d = newstate;
    }

    /**
     * 3D implementation of {@code prependRotation} around Z axis.
     * If this is a 2D transform, the call is redirected to {@code preRotate2D()}.
     */
    private void preRotate3D(double theta) {
        if (state3d == APPLY_NON_3D) {
            preRotate2D(theta);
            return;
        }

        double sin = Math.sin(Math.toRadians(theta));
        if (sin == 1.0) {
            preRotate3D_90();
        } else if (sin == -1.0) {
            preRotate3D_270();
        } else {
            double cos = Math.cos(Math.toRadians(theta));
            if (cos == -1.0) {
                preRotate3D_180();
            } else if (cos != 1.0) {
                double M0, M1;
                M0 = getMxx();
                M1 = getMyx();
                setMxx(cos * M0 - sin * M1);
                setMyx(sin * M0 + cos * M1);
                M0 = getMxy();
                M1 = getMyy();
                setMxy(cos * M0 - sin * M1);
                setMyy(sin * M0 + cos * M1);
                M0 = getMxz();
                M1 = getMyz();
                setMxz(cos * M0 - sin * M1);
                setMyz(sin * M0 + cos * M1);
                M0 = getTx();
                M1 = getTy();
                setTx(cos * M0 - sin * M1);
                setTy(sin * M0 + cos * M1);
                updateState();
            }
        }
    }

    /**
     * 3D implementation of {@code prependRotation} for 90 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 2D transform.
     */
    private void preRotate3D_90() {
        double M0 = getMxx();
        setMxx(-getMyx());
        setMyx(M0);
        M0 = getMxy();
        setMxy(-getMyy());
        setMyy(M0);
        M0 = getMxz();
        setMxz(-getMyz());
        setMyz(M0);
        M0 = getTx();
        setTx(-getTy());
        setTy(M0);

        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_TRANSLATE:
                state3d = APPLY_3D_COMPLEX;
                return;
            case APPLY_SCALE:
            case APPLY_SCALE | APPLY_TRANSLATE:
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_3D_COMPLEX:
                updateState();
                return;
        }
    }

    /**
     * 3D implementation of {@code prependRotation} for 180 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 2D transform.
     */
    private void preRotate3D_180() {
        final double mxx = getMxx();
        final double myy = getMyy();
        setMxx(-mxx);
        setMyy(-myy);
        setTx(-getTx());
        setTy(-getTy());

        if (state3d == APPLY_3D_COMPLEX) {
            setMxy(-getMxy());
            setMxz(-getMxz());
            setMyx(-getMyx());
            setMyz(-getMyz());
            updateState();
            return;
        }

        if (mxx == -1.0 &amp;&amp; myy == -1.0 &amp;&amp; getMzz() == 1.0) {
            // must have been 3d because of translation, which remained
            state3d &amp;= ~APPLY_SCALE;
        } else {
            state3d |= APPLY_SCALE;
        }
    }

    /**
     * 3D implementation of {@code prependRotation} for 270 degrees rotation
     * around Z axis.
     * Behaves wrong when called for a 2D transform.
     */
    private void preRotate3D_270() {
        double M0 = getMxx();
        setMxx(getMyx());
        setMyx(-M0);
        M0 = getMxy();
        setMxy(getMyy());
        setMyy(-M0);
        M0 = getMxz();
        setMxz(getMyz());
        setMyz(-M0);
        M0 = getTx();
        setTx(getTy());
        setTy(-M0);

        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_TRANSLATE:
                state3d = APPLY_3D_COMPLEX;
                return;
            case APPLY_SCALE:
            case APPLY_SCALE | APPLY_TRANSLATE:
                if (getMxy() != 0.0 || getMyx() != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
                return;
            case APPLY_3D_COMPLEX:
                updateState();
                return;
        }
    }

    /* *************************************************************************
     *                                                                         *
     *                     Transform, Inverse Transform                        *
     *                                                                         *
     **************************************************************************/

    @Override
    public Point2D transform(double x, double y) {
        ensureCanTransform2DPoint();

        switch (state2d) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                return new Point2D(
                    getMxx() * x + getMxy() * y + getTx(),
                    getMyx() * x + getMyy() * y + getTy());
            case APPLY_SHEAR | APPLY_SCALE:
                return new Point2D(
                    getMxx() * x + getMxy() * y,
                    getMyx() * x + getMyy() * y);
            case APPLY_SHEAR | APPLY_TRANSLATE:
                return new Point2D(
                        getMxy() * y + getTx(),
                        getMyx() * x + getTy());
            case APPLY_SHEAR:
                return new Point2D(getMxy() * y, getMyx() * x);
            case APPLY_SCALE | APPLY_TRANSLATE:
                return new Point2D(
                        getMxx() * x + getTx(),
                        getMyy() * y + getTy());
            case APPLY_SCALE:
                return new Point2D(getMxx() * x, getMyy() * y);
            case APPLY_TRANSLATE:
                return new Point2D(x + getTx(), y + getTy());
            case APPLY_IDENTITY:
                return new Point2D(x, y);
        }
    }

    @Override
    public Point3D transform(double x, double y, double z) {
        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch (state2d) {
                    default:
                        stateError();
                        // cannot reach
                    case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                        return new Point3D(
                            getMxx() * x + getMxy() * y + getTx(),
                            getMyx() * x + getMyy() * y + getTy(), z);
                    case APPLY_SHEAR | APPLY_SCALE:
                        return new Point3D(
                            getMxx() * x + getMxy() * y,
                            getMyx() * x + getMyy() * y, z);
                    case APPLY_SHEAR | APPLY_TRANSLATE:
                        return new Point3D(
                                getMxy() * y + getTx(), getMyx() * x + getTy(),
                                z);
                    case APPLY_SHEAR:
                        return new Point3D(getMxy() * y, getMyx() * x, z);
                    case APPLY_SCALE | APPLY_TRANSLATE:
                        return new Point3D(
                                getMxx() * x + getTx(), getMyy() * y + getTy(),
                                z);
                    case APPLY_SCALE:
                        return new Point3D(getMxx() * x, getMyy() * y, z);
                    case APPLY_TRANSLATE:
                        return new Point3D(x + getTx(), y + getTy(), z);
                    case APPLY_IDENTITY:
                        return new Point3D(x, y, z);
                }
            case APPLY_TRANSLATE:
                return new Point3D(x + getTx(), y + getTy(), z + getTz());
            case APPLY_SCALE:
                return new Point3D(getMxx() * x, getMyy() * y, getMzz() * z);
            case APPLY_SCALE | APPLY_TRANSLATE:
                return new Point3D(
                        getMxx() * x + getTx(),
                        getMyy() * y + getTy(),
                        getMzz() * z + getTz());
            case APPLY_3D_COMPLEX:
                return new Point3D(
                    getMxx() * x + getMxy() * y + getMxz() * z + getTx(),
                    getMyx() * x + getMyy() * y + getMyz() * z + getTy(),
                    getMzx() * x + getMzy() * y + getMzz() * z + getTz());
        }
    }

    @Override
    void transform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {

        double mxx, mxy, tx, myx, myy, ty;

        switch (state2d) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                mxx = getMxx(); mxy = getMxy(); tx = getTx();
                myx = getMyx(); myy = getMyy(); ty = getTy();
                while (--numPts &gt;= 0) {
                    final double x = srcPts[srcOff++];
                    final double y = srcPts[srcOff++];
                    dstPts[dstOff++] = mxx * x + mxy * y + tx;
                    dstPts[dstOff++] = myx * x + myy * y + ty;
                }
                return;
            case APPLY_SHEAR | APPLY_SCALE:
                mxx = getMxx(); mxy = getMxy();
                myx = getMyx(); myy = getMyy();
                while (--numPts &gt;= 0) {
                    final double x = srcPts[srcOff++];
                    final double y = srcPts[srcOff++];
                    dstPts[dstOff++] = mxx * x + mxy * y;
                    dstPts[dstOff++] = myx * x + myy * y;
                }
                return;
            case APPLY_SHEAR | APPLY_TRANSLATE:
                mxy = getMxy(); tx = getTx();
                myx = getMyx(); ty = getTy();
                while (--numPts &gt;= 0) {
                    final double x = srcPts[srcOff++];
                    dstPts[dstOff++] = mxy * srcPts[srcOff++] + tx;
                    dstPts[dstOff++] = myx * x + ty;
                }
                return;
            case APPLY_SHEAR:
                mxy = getMxy();
                myx = getMyx();
                while (--numPts &gt;= 0) {
                    final double x = srcPts[srcOff++];
                    dstPts[dstOff++] = mxy * srcPts[srcOff++];
                    dstPts[dstOff++] = myx * x;
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                mxx = getMxx(); tx = getTx();
                myy = getMyy(); ty = getTy();
                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = mxx * srcPts[srcOff++] + tx;
                    dstPts[dstOff++] = myy * srcPts[srcOff++] + ty;
                }
                return;
            case APPLY_SCALE:
                mxx = getMxx();
                myy = getMyy();
                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = mxx * srcPts[srcOff++];
                    dstPts[dstOff++] = myy * srcPts[srcOff++];
                }
                return;
            case APPLY_TRANSLATE:
                tx = getTx();
                ty = getTy();
                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = srcPts[srcOff++] + tx;
                    dstPts[dstOff++] = srcPts[srcOff++] + ty;
                }
                return;
            case APPLY_IDENTITY:
                if (srcPts != dstPts || srcOff != dstOff) {
                    System.arraycopy(srcPts, srcOff, dstPts, dstOff,
                                     numPts * 2);
                }
                return;
        }
    }

    @Override
    void transform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {

        double mxx, mxy, tx, myx, myy, ty, mzz, tz;

        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch (state2d) {
                    default:
                        stateError();
                        // cannot reach
                    case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                        mxx = getMxx(); mxy = getMxy(); tx = getTx();
                        myx = getMyx(); myy = getMyy(); ty = getTy();
                        while (--numPts &gt;= 0) {
                            final double x = srcPts[srcOff++];
                            final double y = srcPts[srcOff++];
                            dstPts[dstOff++] = mxx * x + mxy * y + tx;
                            dstPts[dstOff++] = myx * x + myy * y + ty;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_SHEAR | APPLY_SCALE:
                        mxx = getMxx(); mxy = getMxy();
                        myx = getMyx(); myy = getMyy();
                        while (--numPts &gt;= 0) {
                            final double x = srcPts[srcOff++];
                            final double y = srcPts[srcOff++];
                            dstPts[dstOff++] = mxx * x + mxy * y;
                            dstPts[dstOff++] = myx * x + myy * y;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_SHEAR | APPLY_TRANSLATE:
                        mxy = getMxy(); tx = getTx();
                        myx = getMyx(); ty = getTy();
                        while (--numPts &gt;= 0) {
                            final double x = srcPts[srcOff++];
                            dstPts[dstOff++] = mxy * srcPts[srcOff++] + tx;
                            dstPts[dstOff++] = myx * x + ty;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_SHEAR:
                        mxy = getMxy();
                        myx = getMyx();
                        while (--numPts &gt;= 0) {
                            final double x = srcPts[srcOff++];
                            dstPts[dstOff++] = mxy * srcPts[srcOff++];
                            dstPts[dstOff++] = myx * x;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_SCALE | APPLY_TRANSLATE:
                        mxx = getMxx(); tx = getTx();
                        myy = getMyy(); ty = getTy();
                        while (--numPts &gt;= 0) {
                            dstPts[dstOff++] = mxx * srcPts[srcOff++] + tx;
                            dstPts[dstOff++] = myy * srcPts[srcOff++] + ty;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_SCALE:
                        mxx = getMxx();
                        myy = getMyy();
                        while (--numPts &gt;= 0) {
                            dstPts[dstOff++] = mxx * srcPts[srcOff++];
                            dstPts[dstOff++] = myy * srcPts[srcOff++];
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_TRANSLATE:
                        tx = getTx();
                        ty = getTy();
                        while (--numPts &gt;= 0) {
                            dstPts[dstOff++] = srcPts[srcOff++] + tx;
                            dstPts[dstOff++] = srcPts[srcOff++] + ty;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_IDENTITY:
                        if (srcPts != dstPts || srcOff != dstOff) {
                            System.arraycopy(srcPts, srcOff, dstPts, dstOff,
                                             numPts * 3);
                        }
                        return;
                }
                // cannot reach
            case APPLY_TRANSLATE:
                tx = getTx();
                ty = getTy();
                tz = getTz();
                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = srcPts[srcOff++] + tx;
                    dstPts[dstOff++] = srcPts[srcOff++] + ty;
                    dstPts[dstOff++] = srcPts[srcOff++] + tz;
                }
                return;
            case APPLY_SCALE:
                mxx = getMxx();
                myy = getMyy();
                mzz = getMzz();
                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = mxx * srcPts[srcOff++];
                    dstPts[dstOff++] = myy * srcPts[srcOff++];
                    dstPts[dstOff++] = mzz * srcPts[srcOff++];
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                mxx = getMxx(); tx = getTx();
                myy = getMyy(); ty = getTy();
                mzz = getMzz(); tz = getTz();
                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = mxx * srcPts[srcOff++] + tx;
                    dstPts[dstOff++] = myy * srcPts[srcOff++] + ty;
                    dstPts[dstOff++] = mzz * srcPts[srcOff++] + tz;
                }
                return;
            case APPLY_3D_COMPLEX:
                mxx = getMxx();
                mxy = getMxy();
                double mxz = getMxz();
                tx = getTx();
                myx = getMyx();
                myy = getMyy();
                double myz = getMyz();
                ty = getTy();
                double mzx = getMzx();
                double mzy = getMzy();
                mzz = getMzz();
                tz = getTz();

                while (--numPts &gt;= 0) {
                    final double x = srcPts[srcOff++];
                    final double y = srcPts[srcOff++];
                    final double z = srcPts[srcOff++];

                    dstPts[dstOff++] = mxx * x + mxy * y + mxz * z + tx;
                    dstPts[dstOff++] = myx * x + myy * y + myz * z + ty;
                    dstPts[dstOff++] = mzx * x + mzy * y + mzz * z + tz;
                }
                return;
        }
    }

    @Override
    public Point2D deltaTransform(double x, double y) {
        ensureCanTransform2DPoint();

        switch (state2d) {
            default:
                stateError();
                // cannot reach
            case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SHEAR | APPLY_SCALE:
                return new Point2D(
                    getMxx() * x + getMxy() * y,
                    getMyx() * x + getMyy() * y);
            case APPLY_SHEAR | APPLY_TRANSLATE:
            case APPLY_SHEAR:
                return new Point2D(getMxy() * y, getMyx() * x);
            case APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SCALE:
                return new Point2D(getMxx() * x, getMyy() * y);
            case APPLY_TRANSLATE:
            case APPLY_IDENTITY:
                return new Point2D(x, y);
        }
    }

    @Override
    public Point3D deltaTransform(double x, double y, double z) {
        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch (state2d) {
                    default:
                        stateError();
                        // cannot reach
                    case APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE:
                    case APPLY_SHEAR | APPLY_SCALE:
                        return new Point3D(
                            getMxx() * x + getMxy() * y,
                            getMyx() * x + getMyy() * y, z);
                    case APPLY_SHEAR | APPLY_TRANSLATE:
                    case APPLY_SHEAR:
                        return new Point3D(getMxy() * y, getMyx() * x, z);
                    case APPLY_SCALE | APPLY_TRANSLATE:
                    case APPLY_SCALE:
                        return new Point3D(getMxx() * x, getMyy() * y, z);
                    case APPLY_TRANSLATE:
                    case APPLY_IDENTITY:
                        return new Point3D(x, y, z);
                }
            case APPLY_TRANSLATE:
                return new Point3D(x, y, z);
            case APPLY_SCALE:
            case APPLY_SCALE | APPLY_TRANSLATE:
                return new Point3D(getMxx() * x, getMyy() * y, getMzz() * z);
            case APPLY_3D_COMPLEX:
                return new Point3D(
                    getMxx() * x + getMxy() * y + getMxz() * z,
                    getMyx() * x + getMyy() * y + getMyz() * z,
                    getMzx() * x + getMzy() * y + getMzz() * z);
        }
    }

    @Override
    public Point2D inverseTransform(double x, double y)
            throws NonInvertibleTransformException {
        ensureCanTransform2DPoint();

        switch (state2d) {
            default:
                return super.inverseTransform(x, y);
            case APPLY_SHEAR | APPLY_TRANSLATE:
                final double mxy_st = getMxy();
                final double myx_st = getMyx();
                if (mxy_st == 0.0 || myx_st == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point2D(
                        (1.0 / myx_st) * y - getTy() / myx_st,
                        (1.0 / mxy_st) * x - getTx() / mxy_st);
            case APPLY_SHEAR:
                final double mxy_s = getMxy();
                final double myx_s = getMyx();
                if (mxy_s == 0.0 || myx_s == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point2D((1.0 / myx_s) * y, (1.0 / mxy_s) * x);
            case APPLY_SCALE | APPLY_TRANSLATE:
                final double mxx_st = getMxx();
                final double myy_st = getMyy();
                if (mxx_st == 0.0 || myy_st == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point2D(
                        (1.0 / mxx_st) * x - getTx() / mxx_st,
                        (1.0 / myy_st) * y - getTy() / myy_st);
            case APPLY_SCALE:
                final double mxx_s = getMxx();
                final double myy_s = getMyy();
                if (mxx_s == 0.0 || myy_s == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point2D((1.0 / mxx_s) * x, (1.0 / myy_s) * y);
            case APPLY_TRANSLATE:
                return new Point2D(x - getTx(), y - getTy());
            case APPLY_IDENTITY:
                return new Point2D(x, y);
        }
    }

    @Override
    public Point3D inverseTransform(double x, double y, double z)
            throws NonInvertibleTransformException {
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch (state2d) {
                    default:
                        return super.inverseTransform(x, y, z);
                    case APPLY_SHEAR | APPLY_TRANSLATE:
                        final double mxy_st = getMxy();
                        final double myx_st = getMyx();
                        if (mxy_st == 0.0 || myx_st == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }
                        return new Point3D(
                                (1.0 / myx_st) * y - getTy() / myx_st,
                                (1.0 / mxy_st) * x - getTx() / mxy_st, z);
                    case APPLY_SHEAR:
                        final double mxy_s = getMxy();
                        final double myx_s = getMyx();
                        if (mxy_s == 0.0 || myx_s == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }
                        return new Point3D(
                                (1.0 / myx_s) * y,
                                (1.0 / mxy_s) * x, z);
                    case APPLY_SCALE | APPLY_TRANSLATE:
                        final double mxx_st = getMxx();
                        final double myy_st = getMyy();
                        if (mxx_st == 0.0 || myy_st == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }
                        return new Point3D(
                                (1.0 / mxx_st) * x - getTx() / mxx_st,
                                (1.0 / myy_st) * y - getTy() / myy_st, z);
                    case APPLY_SCALE:
                        final double mxx_s = getMxx();
                        final double myy_s = getMyy();
                        if (mxx_s == 0.0 || myy_s == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }
                        return new Point3D((1.0 / mxx_s) * x, (1.0 / myy_s) * y, z);
                    case APPLY_TRANSLATE:
                        return new Point3D(x - getTx(), y - getTy(), z);
                    case APPLY_IDENTITY:
                        return new Point3D(x, y, z);
                }
            case APPLY_TRANSLATE:
                return new Point3D(x - getTx(), y - getTy(), z - getTz());
            case APPLY_SCALE:
                final double mxx_s = getMxx();
                final double myy_s = getMyy();
                final double mzz_s = getMzz();
                if (mxx_s == 0.0 || myy_s == 0.0 || mzz_s == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point3D(
                        (1.0 / mxx_s) * x,
                        (1.0 / myy_s) * y,
                        (1.0 / mzz_s) * z);
            case APPLY_SCALE | APPLY_TRANSLATE:
                final double mxx_st = getMxx();
                final double myy_st = getMyy();
                final double mzz_st = getMzz();
                if (mxx_st == 0.0 || myy_st == 0.0 || mzz_st == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point3D(
                        (1.0 / mxx_st) * x - getTx() / mxx_st,
                        (1.0 / myy_st) * y - getTy() / myy_st,
                        (1.0 / mzz_st) * z - getTz() / mzz_st);
            case APPLY_3D_COMPLEX:
                return super.inverseTransform(x, y, z);
        }
    }

    @Override
    void inverseTransform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts)
            throws NonInvertibleTransformException {

        double mxx, mxy, tx, myx, myy, ty, tmp;

        switch (state2d) {
            default:
                super.inverseTransform2DPointsImpl(srcPts, srcOff,
                        dstPts, dstOff, numPts);
                return;

            case APPLY_SHEAR | APPLY_TRANSLATE:
                mxy = getMxy(); tx = getTx();
                myx = getMyx(); ty = getTy();
                if (mxy == 0.0 || myx == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }

                tmp = tx;
                tx = -ty / myx;
                ty = -tmp / mxy;

                tmp = myx;
                myx = 1.0 / mxy;
                mxy = 1.0 / tmp;

                while (--numPts &gt;= 0) {
                    final double x = srcPts[srcOff++];
                    dstPts[dstOff++] = mxy * srcPts[srcOff++] + tx;
                    dstPts[dstOff++] = myx * x + ty;
                }
                return;
            case APPLY_SHEAR:
                mxy = getMxy();
                myx = getMyx();
                if (mxy == 0.0 || myx == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }

                tmp = myx;
                myx = 1.0 / mxy;
                mxy = 1.0 / tmp;

                while (--numPts &gt;= 0) {
                    final double x = srcPts[srcOff++];
                    dstPts[dstOff++] = mxy * srcPts[srcOff++];
                    dstPts[dstOff++] = myx * x;
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                mxx = getMxx(); tx = getTx();
                myy = getMyy(); ty = getTy();
                if (mxx == 0.0 || myy == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }

                tx = -tx / mxx;
                ty = -ty / myy;
                mxx = 1.0 / mxx;
                myy = 1.0 / myy;

                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = mxx * srcPts[srcOff++] + tx;
                    dstPts[dstOff++] = myy * srcPts[srcOff++] + ty;
                }
                return;
            case APPLY_SCALE:
                mxx = getMxx();
                myy = getMyy();
                if (mxx == 0.0 || myy == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }

                mxx = 1.0 / mxx;
                myy = 1.0 / myy;

                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = mxx * srcPts[srcOff++];
                    dstPts[dstOff++] = myy * srcPts[srcOff++];
                }
                return;
            case APPLY_TRANSLATE:
                tx = getTx();
                ty = getTy();
                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = srcPts[srcOff++] - tx;
                    dstPts[dstOff++] = srcPts[srcOff++] - ty;
                }
                return;
            case APPLY_IDENTITY:
                if (srcPts != dstPts || srcOff != dstOff) {
                    System.arraycopy(srcPts, srcOff, dstPts, dstOff,
                                     numPts * 2);
                }
                return;
        }
    }

    @Override
    void inverseTransform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts)
            throws NonInvertibleTransformException {

        double mxx, mxy, tx, myx, myy, ty, mzz, tz, tmp;

        switch (state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch (state2d) {
                    default:
                        super.inverseTransform3DPointsImpl(srcPts, srcOff,
                                dstPts, dstOff, numPts);
                        return;

                    case APPLY_SHEAR | APPLY_TRANSLATE:
                        mxy = getMxy(); tx = getTx();
                        myx = getMyx(); ty = getTy();
                        if (mxy == 0.0 || myx == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }

                        tmp = tx;
                        tx = -ty / myx;
                        ty = -tmp / mxy;

                        tmp = myx;
                        myx = 1.0 / mxy;
                        mxy = 1.0 / tmp;

                        while (--numPts &gt;= 0) {
                            final double x = srcPts[srcOff++];
                            dstPts[dstOff++] = mxy * srcPts[srcOff++] + tx;
                            dstPts[dstOff++] = myx * x + ty;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_SHEAR:
                        mxy = getMxy();
                        myx = getMyx();
                        if (mxy == 0.0 || myx == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }

                        tmp = myx;
                        myx = 1.0 / mxy;
                        mxy = 1.0 / tmp;

                        while (--numPts &gt;= 0) {
                            final double x = srcPts[srcOff++];
                            dstPts[dstOff++] = mxy * srcPts[srcOff++];
                            dstPts[dstOff++] = myx * x;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_SCALE | APPLY_TRANSLATE:
                        mxx = getMxx(); tx = getTx();
                        myy = getMyy(); ty = getTy();
                        if (mxx == 0.0 || myy == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }

                        tx = -tx / mxx;
                        ty = -ty / myy;
                        mxx = 1.0 / mxx;
                        myy = 1.0 / myy;

                        while (--numPts &gt;= 0) {
                            dstPts[dstOff++] = mxx * srcPts[srcOff++] + tx;
                            dstPts[dstOff++] = myy * srcPts[srcOff++] + ty;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_SCALE:
                        mxx = getMxx();
                        myy = getMyy();
                        if (mxx == 0.0 || myy == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }

                        mxx = 1.0 / mxx;
                        myy = 1.0 / myy;

                        while (--numPts &gt;= 0) {
                            dstPts[dstOff++] = mxx * srcPts[srcOff++];
                            dstPts[dstOff++] = myy * srcPts[srcOff++];
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_TRANSLATE:
                        tx = getTx();
                        ty = getTy();
                        while (--numPts &gt;= 0) {
                            dstPts[dstOff++] = srcPts[srcOff++] - tx;
                            dstPts[dstOff++] = srcPts[srcOff++] - ty;
                            dstPts[dstOff++] = srcPts[srcOff++];
                        }
                        return;
                    case APPLY_IDENTITY:
                        if (srcPts != dstPts || srcOff != dstOff) {
                            System.arraycopy(srcPts, srcOff, dstPts, dstOff,
                                             numPts * 3);
                        }
                        return;
                }
                // cannot reach
            case APPLY_TRANSLATE:
                tx = getTx();
                ty = getTy();
                tz = getTz();
                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = srcPts[srcOff++] - tx;
                    dstPts[dstOff++] = srcPts[srcOff++] - ty;
                    dstPts[dstOff++] = srcPts[srcOff++] - tz;
                }
                return;
            case APPLY_SCALE:
                mxx = getMxx();
                myy = getMyy();
                mzz = getMzz();
                if (mxx == 0.0 || myy == 0.0 | mzz == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }

                mxx = 1.0 / mxx;
                myy = 1.0 / myy;
                mzz = 1.0 / mzz;

                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = mxx * srcPts[srcOff++];
                    dstPts[dstOff++] = myy * srcPts[srcOff++];
                    dstPts[dstOff++] = mzz * srcPts[srcOff++];
                }
                return;
            case APPLY_SCALE | APPLY_TRANSLATE:
                mxx = getMxx(); tx = getTx();
                myy = getMyy(); ty = getTy();
                mzz = getMzz(); tz = getTz();
                if (mxx == 0.0 || myy == 0.0 || mzz == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }

                tx = -tx / mxx;
                ty = -ty / myy;
                tz = -tz / mzz;
                mxx = 1.0 / mxx;
                myy = 1.0 / myy;
                mzz = 1.0 / mzz;

                while (--numPts &gt;= 0) {
                    dstPts[dstOff++] = mxx * srcPts[srcOff++] + tx;
                    dstPts[dstOff++] = myy * srcPts[srcOff++] + ty;
                    dstPts[dstOff++] = mzz * srcPts[srcOff++] + tz;
                }
                return;
            case APPLY_3D_COMPLEX:
                super.inverseTransform3DPointsImpl(srcPts, srcOff,
                        dstPts, dstOff, numPts);
                return;
        }
    }

    @Override
    public Point2D inverseDeltaTransform(double x, double y)
            throws NonInvertibleTransformException {
        ensureCanTransform2DPoint();

        switch (state2d) {
            default:
                return super.inverseDeltaTransform(x, y);
            case APPLY_SHEAR | APPLY_TRANSLATE:
            case APPLY_SHEAR:
                final double mxy_s = getMxy();
                final double myx_s = getMyx();
                if (mxy_s == 0.0 || myx_s == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point2D((1.0 / myx_s) * y, (1.0 / mxy_s) * x);
            case APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SCALE:
                final double mxx_s = getMxx();
                final double myy_s = getMyy();
                if (mxx_s == 0.0 || myy_s == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point2D((1.0 / mxx_s) * x, (1.0 / myy_s) * y);
            case APPLY_TRANSLATE:
            case APPLY_IDENTITY:
                return new Point2D(x, y);
        }
    }

    @Override
    public Point3D inverseDeltaTransform(double x, double y, double z)
            throws NonInvertibleTransformException {
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch (state2d) {
                    default:
                        return super.inverseDeltaTransform(x, y, z);
                    case APPLY_SHEAR | APPLY_TRANSLATE:
                    case APPLY_SHEAR:
                        final double mxy_s = getMxy();
                        final double myx_s = getMyx();
                        if (mxy_s == 0.0 || myx_s == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }
                        return new Point3D(
                                (1.0 / myx_s) * y,
                                (1.0 / mxy_s) * x, z);
                    case APPLY_SCALE | APPLY_TRANSLATE:
                    case APPLY_SCALE:
                        final double mxx_s = getMxx();
                        final double myy_s = getMyy();
                        if (mxx_s == 0.0 || myy_s == 0.0) {
                            throw new NonInvertibleTransformException(
                                    &quot;Determinant is 0&quot;);
                        }
                        return new Point3D(
                                (1.0 / mxx_s) * x,
                                (1.0 / myy_s) * y, z);
                    case APPLY_TRANSLATE:
                    case APPLY_IDENTITY:
                        return new Point3D(x, y, z);
                }

            case APPLY_TRANSLATE:
                return new Point3D(x, y, z);
            case APPLY_SCALE | APPLY_TRANSLATE:
            case APPLY_SCALE:
                final double mxx_s = getMxx();
                final double myy_s = getMyy();
                final double mzz_s = getMzz();
                if (mxx_s == 0.0 || myy_s == 0.0 || mzz_s == 0.0) {
                    throw new NonInvertibleTransformException(&quot;Determinant is 0&quot;);
                }
                return new Point3D(
                        (1.0 / mxx_s) * x,
                        (1.0 / myy_s) * y,
                        (1.0 / mzz_s) * z);
            case APPLY_3D_COMPLEX:
                return super.inverseDeltaTransform(x, y, z);
        }
    }

    /* *************************************************************************
     *                                                                         *
     *                               Other API                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns a string representation of this {@code Affine} object.
     * @return a string representation of this {@code Affine} object.
     */
    @Override
    public String toString() {
       final StringBuilder sb = new StringBuilder(&quot;Affine [\n&quot;);

        sb.append(&quot;\t&quot;).append(getMxx());
        sb.append(&quot;, &quot;).append(getMxy());
        sb.append(&quot;, &quot;).append(getMxz());
        sb.append(&quot;, &quot;).append(getTx());
        sb.append('\n');
        sb.append(&quot;\t&quot;).append(getMyx());
        sb.append(&quot;, &quot;).append(getMyy());
        sb.append(&quot;, &quot;).append(getMyz());
        sb.append(&quot;, &quot;).append(getTy());
        sb.append('\n');
        sb.append(&quot;\t&quot;).append(getMzx());
        sb.append(&quot;, &quot;).append(getMzy());
        sb.append(&quot;, &quot;).append(getMzz());
        sb.append(&quot;, &quot;).append(getTz());

        return sb.append(&quot;\n]&quot;).toString();
    }

    /* *************************************************************************
     *                                                                         *
     *                    Internal implementation stuff                        *
     *                                                                         *
     **************************************************************************/

    /**
     * Manually recalculates the state of the transform when the matrix
     * changes too much to predict the effects on the state.
     * The following tables specify what the various settings of the
     * state fields say about the values of the corresponding matrix
     * element fields.
     *
     * &lt;h4&gt;state3d:&lt;/h4&gt;
     * &lt;pre&gt;
     *                     SCALE          TRANSLATE        OTHER ELEMENTS
     *                 mxx, myy, mzz      tx, ty, tz       all remaining
     *
     * TRANSLATE (TR)       1.0           not all 0.0           0.0
     * SCALE (SC)       not all 1.0           0.0               0.0
     * TR | SC          not all 1.0       not all 0.0           0.0
     * 3D_COMPLEX           any               any            not all 0.0
     * NON_3D: mxz, myz, mzx, mzy, tz are 0.0, mzz is 1.0, for the rest
     *         see state2d
     * &lt;/pre&gt;
     *
     * &lt;h4&gt;state2d:&lt;/h4&gt;
     * Contains meaningful value only if state3d == APPLY_NON_3D.
     * Note that the rules governing the SCALE fields are slightly
     * different depending on whether the SHEAR flag is also set.
     * &lt;pre&gt;
     *                     SCALE            SHEAR          TRANSLATE
     *                    mxx/myy          mxy/myx           tx/ty
     *
     * IDENTITY             1.0              0.0              0.0
     * TRANSLATE (TR)       1.0              0.0          not both 0.0
     * SCALE (SC)       not both 1.0         0.0              0.0
     * TR | SC          not both 1.0         0.0          not both 0.0
     * SHEAR (SH)           0.0          not both 0.0         0.0
     * TR | SH              0.0          not both 0.0     not both 0.0
     * SC | SH          not both 0.0     not both 0.0         0.0
     * TR | SC | SH     not both 0.0     not both 0.0     not both 0.0
     * &lt;/pre&gt;
     */
    private void updateState() {
        updateState2D();

        state3d = APPLY_NON_3D;

        if (getMxz() != 0.0 ||
            getMyz() != 0.0 ||
            getMzx() != 0.0 ||
            getMzy() != 0.0)
        {
            state3d = APPLY_3D_COMPLEX;
        } else {
            if ((state2d &amp; APPLY_SHEAR) == 0) {
                if (getTz() != 0.0) {
                    state3d |= APPLY_TRANSLATE;
                }
                if (getMzz() != 1.0) {
                    state3d |= APPLY_SCALE;
                }
                if (state3d != APPLY_NON_3D) {
                    state3d |= (state2d &amp; (APPLY_SCALE | APPLY_TRANSLATE));
                }
            } else {
                if (getMzz() != 1.0 || getTz() != 0.0) {
                    state3d = APPLY_3D_COMPLEX;
                }
            }
        }
    }

    /**
     * 2D part of {@code updateState()}. It is sufficient to call this method
     * when we know this this a 2D transform and the operation was 2D-only
     * so it could not switch the transform to 3D.
     */
    private void updateState2D() {
        if (getMxy() == 0.0 &amp;&amp; getMyx() == 0.0) {
            if (getMxx() == 1.0 &amp;&amp; getMyy() == 1.0) {
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = APPLY_IDENTITY;
                } else {
                    state2d = APPLY_TRANSLATE;
                }
            } else {
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = APPLY_SCALE;
                } else {
                    state2d = (APPLY_SCALE | APPLY_TRANSLATE);
                }
            }
        } else {
            if (getMxx() == 0.0 &amp;&amp; getMyy() == 0.0) {
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = APPLY_SHEAR;
                } else {
                    state2d = (APPLY_SHEAR | APPLY_TRANSLATE);
                }
            } else {
                if (getTx() == 0.0 &amp;&amp; getTy() == 0.0) {
                    state2d = (APPLY_SHEAR | APPLY_SCALE);
                } else {
                    state2d = (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE);
                }
            }
        }
    }

    /**
     * Convenience method used internally to throw exceptions when
     * a case was forgotten in a switch statement.
     */
    private static void stateError() {
        throw new InternalError(&quot;missing case in a switch&quot;);
    }

    @Override
    void apply(final Affine3D trans) {
        trans.concatenate(getMxx(), getMxy(), getMxz(), getTx(),
                          getMyx(), getMyy(), getMyz(), getTy(),
                          getMzx(), getMzy(), getMzz(), getTz());
    }

    @Override
    BaseTransform derive(final BaseTransform trans) {
        switch(state3d) {
            default:
                stateError();
                // cannot reach
            case APPLY_NON_3D:
                switch(state2d) {
                    case APPLY_IDENTITY:
                        return trans;
                    case APPLY_TRANSLATE:
                        return trans.deriveWithTranslation(getTx(), getTy());
                    case APPLY_SCALE:
                        return trans.deriveWithScale(getMxx(), getMyy(), 1.0);
                    case APPLY_SCALE | APPLY_TRANSLATE:
                        // fall through
                    default:
                        return trans.deriveWithConcatenation(
                                getMxx(), getMyx(),
                                getMxy(), getMyy(),
                                getTx(), getTy());
                }
            case APPLY_TRANSLATE:
                return trans.deriveWithTranslation(getTx(), getTy(), getTz());
            case APPLY_SCALE:
                return trans.deriveWithScale(getMxx(), getMyy(), getMzz());
            case APPLY_SCALE | APPLY_TRANSLATE:
                // fall through
            case APPLY_3D_COMPLEX:
                return trans.deriveWithConcatenation(
                        getMxx(), getMxy(), getMxz(), getTx(),
                        getMyx(), getMyy(), getMyz(), getTy(),
                        getMzx(), getMzy(), getMzz(), getTz());
        }
    }

    /**
     * Keeps track of the atomic changes of more elements.
     * Don't forget to end or cancel a running atomic operation
     * when an exception is to be thrown during one.
     */
    private class AffineAtomicChange {
        private boolean running = false;

        private void start() {
            if (running) {
                throw new InternalError(&quot;Affine internal error: &quot;
                        + &quot;trying to run inner atomic operation&quot;);
            }
            if (mxx != null) mxx.preProcessAtomicChange();
            if (mxy != null) mxy.preProcessAtomicChange();
            if (mxz != null) mxz.preProcessAtomicChange();
            if (tx != null) tx.preProcessAtomicChange();
            if (myx != null) myx.preProcessAtomicChange();
            if (myy != null) myy.preProcessAtomicChange();
            if (myz != null) myz.preProcessAtomicChange();
            if (ty != null) ty.preProcessAtomicChange();
            if (mzx != null) mzx.preProcessAtomicChange();
            if (mzy != null) mzy.preProcessAtomicChange();
            if (mzz != null) mzz.preProcessAtomicChange();
            if (tz != null) tz.preProcessAtomicChange();
            running = true;
        }

        private void end() {
            running = false;
            transformChanged();
            if (mxx != null) mxx.postProcessAtomicChange();
            if (mxy != null) mxy.postProcessAtomicChange();
            if (mxz != null) mxz.postProcessAtomicChange();
            if (tx != null) tx.postProcessAtomicChange();
            if (myx != null) myx.postProcessAtomicChange();
            if (myy != null) myy.postProcessAtomicChange();
            if (myz != null) myz.postProcessAtomicChange();
            if (ty != null) ty.postProcessAtomicChange();
            if (mzx != null) mzx.postProcessAtomicChange();
            if (mzy != null) mzy.postProcessAtomicChange();
            if (mzz != null) mzz.postProcessAtomicChange();
            if (tz != null) tz.postProcessAtomicChange();
        }

        private void cancel() {
            running = false;
        }

        private boolean runs() {
            return running;
        }
    }

    /**
     * Used only by tests to check the 2d matrix state
     */
    int getState2d() {
        return state2d;
    }

    /**
     * Used only by tests to check the 3d matrix state
     */
    int getState3d() {
        return state3d;
    }

    /**
     * Used only by tests to check the atomic operation state
     */
    boolean atomicChangeRuns() {
        return atomicChange.runs();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/transform/Rotate.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.transform;

import javafx.beans.property.DoubleProperty;
import javafx.beans.property.DoublePropertyBase;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.geometry.Point3D;

import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.geom.transform.BaseTransform;
import javafx.geometry.Point2D;


/**
 * This class represents an {@code Affine} object that rotates coordinates
 * around an anchor point. This operation is equivalent to translating the
 * coordinates so that the anchor point is at the origin (S1), then rotating them
 * about the new origin (S2), and finally translating so that the
 * intermediate origin is restored to the coordinates of the original
 * anchor point (S3).
 * &lt;p&gt;
 * The matrix representing the rotation transformation around an axis {@code (x,y,z)}
 * by an angle {@code t} is as follows:
 * &lt;pre&gt;
 *              [   cos(t)   -sin(t)   0   x-x*cos(t)+y*sin(t)   ]
 *              [   sin(t)    cos(t)   0   y-x*sin(t)-y*cos(t)   ]
 *              [     0         0      1           z             ]
 * &lt;/pre&gt;
 * &lt;p&gt;
 * For example, to rotate a text 30 degrees around the Z-axis at
 * anchor point of (50,30):
 * &lt;pre&gt;{@code
 * Text text = new Text(&quot;This is a test&quot;);
 * text.setX(10);
 * text.setY(50);
 * text.setFont(new Font(20));
 *
 * text.getTransforms().add(new Rotate(30, 50, 30));
 * }&lt;/pre&gt;
 *
 * @since JavaFX 2.0
 */

public class Rotate extends Transform {

    /**
     * Specifies the X-axis as the axis of rotation.
     */
    public static final Point3D X_AXIS = new Point3D(1,0,0);

    /**
     * Specifies the Y-axis as the axis of rotation.
     */
    public static final Point3D Y_AXIS = new Point3D(0,1,0);

    /**
     * Specifies the Z-axis as the axis of rotation.
     */
    public static final Point3D Z_AXIS = new Point3D(0,0,1);

    /**
     * Avoids lot of repeated computation.
     * @see #MatrixCache
     */
    private MatrixCache cache;

    /**
     * Avoids lot of repeated computation.
     * @see #MatrixCache
     */
    private MatrixCache inverseCache;

    /**
     * Creates a default Rotate transform (identity).
     */
    public Rotate() {
    }

    /**
     * Creates a two-dimensional Rotate transform.
     * The pivot point is set to (0,0)
     * @param angle the angle of rotation measured in degrees
     */
    public Rotate(double angle) {
        setAngle(angle);
    }

    /**
     * Creates a three-dimensional Rotate transform.
     * The pivot point is set to (0,0,0)
     * @param angle the angle of rotation measured in degrees
     * @param axis the axis of rotation
     */
    public Rotate(double angle, Point3D axis) {
        setAngle(angle);
        setAxis(axis);
    }

    /**
     * Creates a two-dimensional Rotate transform with pivot.
     * @param angle the angle of rotation measured in degrees
     * @param pivotX the X coordinate of the rotation pivot point
<A NAME="22"></A>     * @param pivotY the Y coordinate of the rotation pivot point
     */
    public Rotate(double angle, double pivotX, double pivotY) {
        <FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#22',2,'match31-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>setAngle(angle);
        setPivotX(pivotX);
        setPivotY(pivotY);
    }

    /**
     * Creates a simple Rotate transform with three-dimensional pivot.
     * @param angle the angle of rotation measured in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @param pivotZ the Z coordinate of the rotation pivot point
     */
    public Rotate(double angle, double pivotX, double pivotY, double pivotZ) {
        this(angle, pivotX, pivotY);
        setPivotZ(pivotZ);
    }

    /**
     * Creates a three-dimensional Rotate transform with pivot.
     * @param angle the angle of rotation measured in degrees
     * @param pivotX the X coordinate of the rotation pivot point
     * @param pivotY the Y coordinate of the rotation pivot point
     * @param pivotZ the Z coordinate of the rotation pivot point
     * @param axis the axis of rotation
     */
    public Rotate(double angle, double pivotX, double pivotY</B></FONT>, double pivotZ, Point3D axis) {
        this(angle, pivotX, pivotY);
        setPivotZ(pivotZ);
        setAxis(axis);
    }

    /**
     * Defines the angle of rotation measured in degrees.
     */
    private DoubleProperty angle;


    public final void setAngle(double value) {
        angleProperty().set(value);
    }

    public final double getAngle() {
        return angle == null ? 0.0 : angle.get();
    }

    public final DoubleProperty angleProperty() {
        if (angle == null) {
            angle = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Rotate.this;
                }

                @Override
                public String getName() {
                    return &quot;angle&quot;;
                }
            };
        }
        return angle;
    }

    /**
     * Defines the X coordinate of the rotation pivot point.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty pivotX;


    public final void setPivotX(double value) {
        pivotXProperty().set(value);
    }

    public final double getPivotX() {
        return pivotX == null ? 0.0 : pivotX.get();
    }

    public final DoubleProperty pivotXProperty() {
        if (pivotX == null) {
            pivotX = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Rotate.this;
                }

                @Override
                public String getName() {
                    return &quot;pivotX&quot;;
                }
            };
        }
        return pivotX;
    }

    /**
     * Defines the Y coordinate of the rotation pivot point.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty pivotY;


    public final void setPivotY(double value) {
        pivotYProperty().set(value);
    }

    public final double getPivotY() {
        return pivotY == null ? 0.0 : pivotY.get();
    }

    public final DoubleProperty pivotYProperty() {
        if (pivotY == null) {
            pivotY = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Rotate.this;
                }

                @Override
                public String getName() {
                    return &quot;pivotY&quot;;
                }
            };
        }
        return pivotY;
    }

    /**
     * Defines the Z coordinate of the rotation pivot point.
     *
     * @defaultValue 0.0
     */
    private DoubleProperty pivotZ;


    public final void setPivotZ(double value) {
        pivotZProperty().set(value);
    }

    public final double getPivotZ() {
        return pivotZ == null ? 0.0 : pivotZ.get();
    }

    public final DoubleProperty pivotZProperty() {
        if (pivotZ == null) {
            pivotZ = new DoublePropertyBase() {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Rotate.this;
                }

                @Override
                public String getName() {
                    return &quot;pivotZ&quot;;
                }
            };
        }
        return pivotZ;
    }

    /**
     * Defines the axis of rotation at the pivot point.
     */
    private ObjectProperty&lt;Point3D&gt; axis;


    public final void setAxis(Point3D value) {
        axisProperty().set(value);
    }

    public final Point3D getAxis() {
        return axis == null ? Z_AXIS : axis.get();
    }

    public final ObjectProperty&lt;Point3D&gt; axisProperty() {
        if (axis == null) {
            axis = new ObjectPropertyBase&lt;Point3D&gt;(Z_AXIS) {

                @Override
                public void invalidated() {
                    transformChanged();
                }

                @Override
                public Object getBean() {
                    return Rotate.this;
                }

                @Override
                public String getName() {
                    return &quot;axis&quot;;
                }
            };
        }
        return axis;
    }

    /* *************************************************************************
     *                                                                         *
     *                         Element getters                                 *
     *                                                                         *
     **************************************************************************/

    @Override
    public double getMxx() {
        updateCache();
        return cache.mxx;
    }

    @Override
    public double getMxy() {
        updateCache();
        return cache.mxy;
    }

    @Override
    public double getMxz() {
        updateCache();
        return cache.mxz;
    }

    @Override
    public double getTx() {
        updateCache();
        return cache.tx;
    }

    @Override
    public double getMyx() {
        updateCache();
        return cache.myx;
    }

    @Override
    public double getMyy() {
        updateCache();
        return cache.myy;
    }

    @Override
    public double getMyz() {
        updateCache();
        return cache.myz;
    }

    @Override
    public double getTy() {
        updateCache();
        return cache.ty;
    }

    @Override
    public double getMzx() {
        updateCache();
        return cache.mzx;
    }

    @Override
    public double getMzy() {
        updateCache();
        return cache.mzy;
    }

    @Override
    public double getMzz() {
        updateCache();
        return cache.mzz;
    }

    @Override
    public double getTz() {
        updateCache();
        return cache.tz;
    }

    /* *************************************************************************
     *                                                                         *
     *                           State getters                                 *
     *                                                                         *
     **************************************************************************/

    @Override
    boolean computeIs2D() {
        final Point3D a = getAxis();
        return (a.getX() == 0.0 &amp;&amp; a.getY() == 0.0) || getAngle() == 0;
    }

    @Override
    boolean computeIsIdentity() {
        if (getAngle() == 0.0) {
            return true;
        }

        final Point3D a = getAxis();
        return a.getX() == 0 &amp;&amp; a.getY() == 0 &amp;&amp; a.getZ() == 0.0;
    }

    /* *************************************************************************
     *                                                                         *
     *                           Array getters                                 *
     *                                                                         *
     **************************************************************************/

    @Override
    void fill2DArray(double[] array) {
        updateCache();
        array[0] = cache.mxx;
        array[1] = cache.mxy;
        array[2] = cache.tx;
        array[3] = cache.myx;
        array[4] = cache.myy;
        array[5] = cache.ty;
    }

    @Override
    void fill3DArray(double[] array) {
        updateCache();
        array[0] = cache.mxx;
        array[1] = cache.mxy;
        array[2] = cache.mxz;
        array[3] = cache.tx;
        array[4] = cache.myx;
        array[5] = cache.myy;
        array[6] = cache.myz;
        array[7] = cache.ty;
        array[8] = cache.mzx;
        array[9] = cache.mzy;
        array[10] = cache.mzz;
        array[11] = cache.tz;
        return;
    }

    /* *************************************************************************
     *                                                                         *
     *                         Transform creators                              *
     *                                                                         *
     **************************************************************************/

    @Override
    public Transform createConcatenation(Transform transform) {
        if (transform instanceof Rotate) {
            Rotate r = (Rotate) transform;
            final double px = getPivotX();
            final double py = getPivotY();
            final double pz = getPivotZ();

            if ((r.getAxis() == getAxis() ||
                        r.getAxis().normalize().equals(getAxis().normalize())) &amp;&amp;
                    px == r.getPivotX() &amp;&amp;
                    py == r.getPivotY() &amp;&amp;
                    pz == r.getPivotZ()) {
                return new Rotate(getAngle() + r.getAngle(), px, py, pz, getAxis());
            }
        }

        if (transform instanceof Affine) {
            Affine a = (Affine) transform.clone();
            a.prepend(this);
            return a;
        }

        return super.createConcatenation(transform);
    }

    @Override
    public Transform createInverse() throws NonInvertibleTransformException {
        return new Rotate(-getAngle(), getPivotX(), getPivotY(), getPivotZ(),
                getAxis());
    }

    @Override
    public Rotate clone() {
        return new Rotate(getAngle(), getPivotX(), getPivotY(), getPivotZ(),
                getAxis());
    }

    /* *************************************************************************
     *                                                                         *
     *                     Transform, Inverse Transform                        *
     *                                                                         *
     **************************************************************************/

    @Override
    public Point2D transform(double x, double y) {
        ensureCanTransform2DPoint();

        updateCache();

        return new Point2D(
            cache.mxx * x + cache.mxy * y + cache.tx,
            cache.myx * x + cache.myy * y + cache.ty);
    }

    @Override
    public Point3D transform(double x, double y, double z) {
        updateCache();

        return new Point3D(
            cache.mxx * x + cache.mxy * y + cache.mxz * z + cache.tx,
            cache.myx * x + cache.myy * y + cache.myz * z + cache.ty,
            cache.mzx * x + cache.mzy * y + cache.mzz * z + cache.tz);
    }

    @Override
    void transform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {
        updateCache();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];

            dstPts[dstOff++] = cache.mxx * x + cache.mxy * y + cache.tx;
            dstPts[dstOff++] = cache.myx * x + cache.myy * y + cache.ty;
        }
    }

    @Override
    void transform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {

        updateCache();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];
            final double z = srcPts[srcOff++];

            dstPts[dstOff++] = cache.mxx * x + cache.mxy * y + cache.mxz * z + cache.tx;
            dstPts[dstOff++] = cache.myx * x + cache.myy * y + cache.myz * z + cache.ty;
            dstPts[dstOff++] = cache.mzx * x + cache.mzy * y + cache.mzz * z + cache.tz;
        }
    }

    @Override
    public Point2D deltaTransform(double x, double y) {
        ensureCanTransform2DPoint();

        updateCache();

        return new Point2D(
            cache.mxx * x + cache.mxy * y,
            cache.myx * x + cache.myy * y);
    }

    @Override
    public Point3D deltaTransform(double x, double y, double z) {
        updateCache();

        return new Point3D(
            cache.mxx * x + cache.mxy * y + cache.mxz * z,
            cache.myx * x + cache.myy * y + cache.myz * z,
            cache.mzx * x + cache.mzy * y + cache.mzz * z);
    }

    @Override
    public Point2D inverseTransform(double x, double y) {
        ensureCanTransform2DPoint();

        updateInverseCache();

        return new Point2D(
            inverseCache.mxx * x + inverseCache.mxy * y + inverseCache.tx,
            inverseCache.myx * x + inverseCache.myy * y + inverseCache.ty);
    }

    @Override
    public Point3D inverseTransform(double x, double y, double z) {
        updateInverseCache();

        return new Point3D(
            inverseCache.mxx * x + inverseCache.mxy * y + inverseCache.mxz * z
                + inverseCache.tx,
            inverseCache.myx * x + inverseCache.myy * y + inverseCache.myz * z
                + inverseCache.ty,
            inverseCache.mzx * x + inverseCache.mzy * y + inverseCache.mzz * z
                + inverseCache.tz);
    }

    @Override
    void inverseTransform2DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {
        updateInverseCache();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];

            dstPts[dstOff++] = inverseCache.mxx * x + inverseCache.mxy * y
                    + inverseCache.tx;
            dstPts[dstOff++] = inverseCache.myx * x + inverseCache.myy * y
                    + inverseCache.ty;
        }
    }

    @Override
    void inverseTransform3DPointsImpl(double[] srcPts, int srcOff,
            double[] dstPts, int dstOff, int numPts) {

        updateInverseCache();

        while (--numPts &gt;= 0) {
            final double x = srcPts[srcOff++];
            final double y = srcPts[srcOff++];
            final double z = srcPts[srcOff++];

            dstPts[dstOff++] = inverseCache.mxx * x + inverseCache.mxy * y
                    + inverseCache.mxz * z + inverseCache.tx;
            dstPts[dstOff++] = inverseCache.myx * x + inverseCache.myy * y
                    + inverseCache.myz * z + inverseCache.ty;
            dstPts[dstOff++] = inverseCache.mzx * x + inverseCache.mzy * y
                    + inverseCache.mzz * z + inverseCache.tz;
        }
    }

    @Override
    public Point2D inverseDeltaTransform(double x, double y) {
        ensureCanTransform2DPoint();

        updateInverseCache();

        return new Point2D(
            inverseCache.mxx * x + inverseCache.mxy * y,
            inverseCache.myx * x + inverseCache.myy * y);
    }

    @Override
    public Point3D inverseDeltaTransform(double x, double y, double z) {
        updateInverseCache();

        return new Point3D(
            inverseCache.mxx * x + inverseCache.mxy * y + inverseCache.mxz * z,
            inverseCache.myx * x + inverseCache.myy * y + inverseCache.myz * z,
            inverseCache.mzx * x + inverseCache.mzy * y + inverseCache.mzz * z);
    }

    /* *************************************************************************
     *                                                                         *
     *                               Other API                                 *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns a string representation of this {@code Rotate} object.
     * @return a string representation of this {@code Rotate} object.
     */
    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder(&quot;Rotate [&quot;);

        sb.append(&quot;angle=&quot;).append(getAngle());
        sb.append(&quot;, pivotX=&quot;).append(getPivotX());
        sb.append(&quot;, pivotY=&quot;).append(getPivotY());
        sb.append(&quot;, pivotZ=&quot;).append(getPivotZ());
        sb.append(&quot;, axis=&quot;).append(getAxis());

        return sb.append(&quot;]&quot;).toString();
    }

    /* *************************************************************************
     *                                                                         *
     *                    Internal implementation stuff                        *
     *                                                                         *
     **************************************************************************/

    @Override
    void apply(final Affine3D trans) {
        double localPivotX = getPivotX();
        double localPivotY = getPivotY();
        double localPivotZ = getPivotZ();
        double localAngle = getAngle();

        if (localPivotX != 0 || localPivotY != 0 || localPivotZ != 0) {
            trans.translate(localPivotX, localPivotY, localPivotZ);
            trans.rotate(Math.toRadians(localAngle),
                         getAxis().getX(),getAxis().getY(), getAxis().getZ());
            trans.translate(-localPivotX, -localPivotY, -localPivotZ);
        } else {
            trans.rotate(Math.toRadians(localAngle),
                         getAxis().getX(), getAxis().getY(), getAxis().getZ());
        }
    }

    @Override
    BaseTransform derive(BaseTransform trans) {
        if (isIdentity()) {
            return trans;
        }

        double localPivotX = getPivotX();
        double localPivotY = getPivotY();
        double localPivotZ = getPivotZ();
        double localAngle = getAngle();

        if (localPivotX != 0 || localPivotY != 0 || localPivotZ != 0) {
            trans = trans.deriveWithTranslation(localPivotX, localPivotY, localPivotZ);
            trans = trans.deriveWithRotation(Math.toRadians(localAngle),
                         getAxis().getX(),getAxis().getY(), getAxis().getZ());
            return trans.deriveWithTranslation(-localPivotX, -localPivotY, -localPivotZ);
        } else {
            return trans.deriveWithRotation(Math.toRadians(localAngle),
                         getAxis().getX(), getAxis().getY(), getAxis().getZ());
        }
    }

    @Override
    void validate() {
        getAxis();
        getAngle();
        getPivotX();
        getPivotY();
        getPivotZ();
    }

    @Override
    protected void transformChanged() {
        if (cache != null) {
            cache.invalidate();
        }
        super.transformChanged();
    }

    @Override
    void appendTo(Affine a) {
        a.appendRotation(getAngle(), getPivotX(), getPivotY(), getPivotZ(),
                getAxis());
    }

    @Override
    void prependTo(Affine a) {
        a.prependRotation(getAngle(), getPivotX(), getPivotY(), getPivotZ(),
                getAxis());
    }

    /**
     * Updates the matrix cache
     */
    private void updateCache() {
        if (cache == null) {
            cache = new MatrixCache();
        }

        if (!cache.valid) {
            cache.update(getAngle(), getAxis(),
                    getPivotX(), getPivotY(), getPivotZ());
        }
    }

    /**
     * Updates the inverse matrix cache
     */
    private void updateInverseCache() {
        if (inverseCache == null) {
            inverseCache = new MatrixCache();
        }

        if (!inverseCache.valid) {
            inverseCache.update(-getAngle(), getAxis(),
                    getPivotX(), getPivotY(), getPivotZ());
        }
    }

    /**
     * Matrix cache. Computing single transformation matrix elements for
     * a general rotation is quite expensive. Also each of those partial
     * computations need some common operations to be made (compute sin
     * and cos, normalize axis). Therefore with the direct element computations
     * if all the getters for the elements are called to get the matrix,
     * the result is slow.
     *
     * If a matrix element is asked for, we can reasonably anticipate that
     * some other elements will be asked for as well. So when any element
     * needs to be computed, we compute the entire matrix, cache it,
     * and use the stored values until the transform changes.
     */
    private static class MatrixCache {
        boolean valid = false;
        boolean is3D = false;

        double mxx, mxy, mxz, tx,
               myx, myy, myz, ty,
               mzx, mzy, mzz, tz;

        public MatrixCache() {
            // to have the 3D part right when using 2D-only
            mzz = 1.0;
        }

        public void update(double angle, Point3D axis,
                double px, double py, double pz) {

            final double rads = Math.toRadians(angle);
            final double sin = Math.sin(rads);
            final double cos = Math.cos(rads);

            if (axis == Z_AXIS ||
                    (axis.getX() == 0.0 &amp;&amp;
                     axis.getY() == 0.0 &amp;&amp;
                     axis.getZ() &gt; 0.0)) {
                // 2D case
                mxx = cos;
                mxy = -sin;
                tx = px * (1 - cos) + py * sin;
                myx = sin;
                myy = cos;
                ty = py * (1 - cos) - px * sin;

                if (is3D) {
                    // Was 3D, needs to set the 3D values
                    mxz = 0.0;
                    myz = 0.0;
                    mzx = 0.0;
                    mzy = 0.0;
                    mzz = 1.0;
                    tz = 0.0;
                    is3D = false;
                }
                valid = true;
                return;
            }
            // 3D case
            is3D = true;

            double axisX, axisY, axisZ;

            if (axis == X_AXIS || axis == Y_AXIS || axis == Z_AXIS) {
                axisX = axis.getX();
                axisY = axis.getY();
                axisZ = axis.getZ();
            } else {
                // normalize
                final double mag = Math.sqrt(axis.getX() * axis.getX() +
                        axis.getY() * axis.getY() + axis.getZ() * axis.getZ());

                if (mag == 0.0) {
                    mxx = 1; mxy = 0; mxz = 0; tx = 0;
                    myx = 0; myy = 1; myz = 0; ty = 0;
                    mzx = 0; mzy = 0; mzz = 1; tz = 0;
                    valid = true;
                    return;
                } else {
                    axisX = axis.getX() / mag;
                    axisY = axis.getY() / mag;
                    axisZ = axis.getZ() / mag;
                }
            }

            mxx = cos + axisX * axisX * (1 - cos);
            mxy = axisX * axisY * (1 - cos) - axisZ * sin;
            mxz = axisX * axisZ * (1 - cos) + axisY * sin;
            tx = px * (1 - mxx) - py * mxy - pz * mxz;

            myx = axisY * axisX * (1 - cos) + axisZ * sin;
            myy = cos + axisY * axisY * (1 - cos);
            myz = axisY * axisZ * (1 - cos) - axisX * sin;
            ty = py * (1 - myy) - px * myx - pz * myz;

            mzx = axisZ * axisX * (1 - cos) - axisY * sin;
            mzy = axisZ * axisY * (1 - cos) + axisX * sin;
            mzz = cos + axisZ * axisZ * (1 - cos);
            tz = pz * (1 - mzz) - px * mzx - py * mzy;

            valid = true;
        }

        public void invalidate() {
            valid = false;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.media/com/sun/media/jfxmedia/locator/HLSConnectionHolder.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.media.jfxmedia.locator;

import com.sun.media.jfxmedia.MediaError;
import com.sun.media.jfxmediaimpl.MediaUtils;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.*;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;

final class HLSConnectionHolder extends ConnectionHolder {

    private URLConnection urlConnection = null;
    private PlaylistThread playlistThread = new PlaylistThread();
    private VariantPlaylist variantPlaylist = null;
    private Playlist currentPlaylist = null;
    private int mediaFileIndex = -1;
    private CountDownLatch readySignal = new CountDownLatch(1);
    private Semaphore liveSemaphore = new Semaphore(0);
    private boolean isPlaylistClosed = false;
    private boolean isBitrateAdjustable = false;
    private long startTime = -1;
    private static final long HLS_VALUE_FLOAT_MULTIPLIER = 1000;
    private static final int HLS_PROP_GET_DURATION = 1;
    private static final int HLS_PROP_GET_HLS_MODE = 2;
    private static final int HLS_PROP_GET_MIMETYPE = 3;
    private static final int HLS_VALUE_MIMETYPE_MP2T = 1;
    private static final int HLS_VALUE_MIMETYPE_MP3 = 2;
    private static final String CHARSET_UTF_8 = &quot;UTF-8&quot;;
    private static final String CHARSET_US_ASCII = &quot;US-ASCII&quot;;

    HLSConnectionHolder(URI uri) throws IOException {
        playlistThread.setPlaylistURI(uri);
        init();
    }

    private void init() {
        playlistThread.putState(PlaylistThread.STATE_INIT);
        playlistThread.start();
    }

    @Override
    public int readNextBlock() throws IOException {
        if (isBitrateAdjustable &amp;&amp; startTime == -1) {
            startTime = System.currentTimeMillis();
        }

        int read = super.readNextBlock();
        if (isBitrateAdjustable &amp;&amp; read == -1) {
            long readTime = System.currentTimeMillis() - startTime;
            startTime = -1;
            adjustBitrate(readTime);
        }

        return read;
    }

    int readBlock(long position, int size) throws IOException {
        throw new IOException();
    }

    boolean needBuffer() {
        return true;
    }

    boolean isSeekable() {
        return true;
    }

    boolean isRandomAccess() {
        return false; // Only by segments
    }

    public long seek(long position) {
        try {
            readySignal.await();
        } catch (Exception e) {
            return -1;
        }

        return (long) (currentPlaylist.seek(position) * HLS_VALUE_FLOAT_MULTIPLIER);
    }

    @Override
    public void closeConnection() {
        currentPlaylist.close();
        super.closeConnection();
        resetConnection();
        playlistThread.putState(PlaylistThread.STATE_EXIT);
    }

    @Override
    int property(int prop, int value) {
        try {
            readySignal.await();
        } catch (Exception e) {
            return -1;
        }

        if (prop == HLS_PROP_GET_DURATION) {
            return (int) (currentPlaylist.getDuration() * HLS_VALUE_FLOAT_MULTIPLIER);
        } else if (prop == HLS_PROP_GET_HLS_MODE) {
            return 1;
        } else if (prop == HLS_PROP_GET_MIMETYPE) {
            return currentPlaylist.getMimeType();
        }

        return -1;
    }

    @Override
    int getStreamSize() {
        try {
            readySignal.await();
        } catch (Exception e) {
            return -1;
        }

        return loadNextSegment();
    }

    private void resetConnection() {
        super.closeConnection();

        Locator.closeConnection(urlConnection);
        urlConnection = null;
    }

    // Returns -1 EOS or critical error
    // Returns positive size of segment if no isssues.
    // Returns negative size of segment if discontinuity.
    private int loadNextSegment() {
        resetConnection();

        String mediaFile = currentPlaylist.getNextMediaFile();
        if (mediaFile == null) {
            return -1;
        }

        try {
            URI uri = new URI(mediaFile);
            urlConnection = uri.toURL().openConnection();
            channel = openChannel();
        } catch (Exception e) {
            return -1;
        }

        if (currentPlaylist.isCurrentMediaFileDiscontinuity()) {
            return (-1 * urlConnection.getContentLength());
        } else {
            return urlConnection.getContentLength();
        }
    }

    private ReadableByteChannel openChannel() throws IOException {
        return Channels.newChannel(urlConnection.getInputStream());
    }

    private void adjustBitrate(long readTime) {
        int avgBitrate = (int)(((long) urlConnection.getContentLength() * 8 * 1000) / readTime);

        Playlist playlist = variantPlaylist.getPlaylistBasedOnBitrate(avgBitrate);
        if (playlist != null &amp;&amp; playlist != currentPlaylist) {
            if (currentPlaylist.isLive()) {
                playlist.update(currentPlaylist.getNextMediaFile());
                playlistThread.setReloadPlaylist(playlist);
            }

            playlist.setForceDiscontinuity(true);
            currentPlaylist = playlist;
        }
    }

    private static String stripParameters(String mediaFile) {
        int qp = mediaFile.indexOf('?');
        if (qp &gt; 0) {
            mediaFile = mediaFile.substring(0, qp); // Strip all possible http parameters.
        }
        return mediaFile;
    }

    private class PlaylistThread extends Thread {

        public static final int STATE_INIT = 0;
        public static final int STATE_EXIT = 1;
        public static final int STATE_RELOAD_PLAYLIST = 2;
        private BlockingQueue&lt;Integer&gt; stateQueue = new LinkedBlockingQueue&lt;Integer&gt;();
        private URI playlistURI = null;
        private Playlist reloadPlaylist = null;
        private final Object reloadLock = new Object();
        private volatile boolean stopped = false;

        private PlaylistThread() {
            setName(&quot;JFXMedia HLS Playlist Thread&quot;);
            setDaemon(true);
        }

        private void setPlaylistURI(URI playlistURI) {
            this.playlistURI = playlistURI;
        }

        private void setReloadPlaylist(Playlist playlist) {
            synchronized(reloadLock) {
                reloadPlaylist = playlist;
            }
        }

        @Override
        public void run() {
            while (!stopped) {
                try {
                    int state = stateQueue.take();
                    switch (state) {
                        case STATE_INIT:
                            stateInit();
                            break;
                        case STATE_EXIT:
                            stopped = true;
                            break;
                        case STATE_RELOAD_PLAYLIST:
                            stateReloadPlaylist();
                            break;
                        default:
                            break;
                    }
                } catch (Exception e) {
                }
            }
        }

        private void putState(int state) {
            if (stateQueue != null) {
                try {
                    stateQueue.put(state);
                } catch (InterruptedException ex) {
                }
            }
        }

        private void stateInit() {
            if (playlistURI == null) {
                return;
            }

            PlaylistParser parser = new PlaylistParser();
            parser.load(playlistURI);

            if (parser.isVariantPlaylist()) {
                variantPlaylist = new VariantPlaylist(playlistURI);

                while (parser.hasNext()) {
                    variantPlaylist.addPlaylistInfo(parser.getString(), parser.getInteger());
                }
            } else {
                if (currentPlaylist == null) {
                    currentPlaylist = new Playlist(parser.isLivePlaylist(), parser.getTargetDuration());
                    currentPlaylist.setPlaylistURI(playlistURI);
                }

                if (currentPlaylist.setSequenceNumber(parser.getSequenceNumber())) {
                    while (parser.hasNext()) {
                        currentPlaylist.addMediaFile(parser.getString(), parser.getDouble(), parser.getBoolean());
                    }
                }

                if (variantPlaylist != null) {
                    variantPlaylist.addPlaylist(currentPlaylist);
                }
            }

            // Update variant playlists
            if (variantPlaylist != null) {
                while (variantPlaylist.hasNext()) {
                    try {
                        currentPlaylist = new Playlist(variantPlaylist.getPlaylistURI());
                        currentPlaylist.update(null);
                        variantPlaylist.addPlaylist(currentPlaylist);
                    } catch (URISyntaxException e) {
                    } catch (MalformedURLException e) {
                    }
                }
            }

            // Always start with first data playlist
            if (variantPlaylist != null) {
                currentPlaylist = variantPlaylist.getPlaylist(0);
                isBitrateAdjustable = true;
            }

            // Start reloading live playlist
            if (currentPlaylist.isLive()) {
                setReloadPlaylist(currentPlaylist);
                putState(STATE_RELOAD_PLAYLIST);
            }

            readySignal.countDown();
        }

        private void stateReloadPlaylist() {
            try {
                long timeout;
                synchronized(reloadLock) {
                    timeout = reloadPlaylist.getTargetDuration() / 2;
                }
                Thread.sleep(timeout);
            } catch (InterruptedException ex) {
                return;
            }

            synchronized(reloadLock) {
                reloadPlaylist.update(null);
            }

            putState(STATE_RELOAD_PLAYLIST);
        }
    }

    private static class PlaylistParser {

        private boolean isFirstLine = true;
        private boolean isLineMediaFileURI = false;
        private boolean isEndList = false;
        private boolean isLinePlaylistURI = false;
        private boolean isVariantPlaylist = false;
        private boolean isDiscontinuity = false;
        private int targetDuration = 0;
        private int sequenceNumber = 0;
        private int dataListIndex = -1;
        private List&lt;String&gt; dataListString = new ArrayList&lt;String&gt;();
        private List&lt;Integer&gt; dataListInteger = new ArrayList&lt;Integer&gt;();
        private List&lt;Double&gt; dataListDouble = new ArrayList&lt;Double&gt;();
        private List&lt;Boolean&gt; dataListBoolean = new ArrayList&lt;Boolean&gt;();

        private void load(URI uri) {
            HttpURLConnection connection = null;
            BufferedReader reader = null;
            try {
                connection = (HttpURLConnection) uri.toURL().openConnection();
                connection.setRequestMethod(&quot;GET&quot;);

                if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {
                    MediaUtils.error(this, MediaError.ERROR_LOCATOR_CONNECTION_LOST.code(), &quot;HTTP responce code: &quot; + connection.getResponseCode(), null);
                }

                Charset charset = getCharset(uri.toURL().toExternalForm(), connection.getContentType());
                if (charset != null) {
                    reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), charset));
                }

                if (reader != null) {
                    boolean result;
                    do {
                        result = parseLine(reader.readLine());
                    } while (result);
                }
            } catch (MalformedURLException e) {
            } catch (IOException e) {
            } finally {
                if (reader != null) {
                    try {
                        reader.close();
                    } catch (IOException e) {}

                    Locator.closeConnection(connection);
                }
            }
        }

        private boolean isVariantPlaylist() {
            return isVariantPlaylist;
        }

        private boolean isLivePlaylist() {
            return !isEndList;
        }

        private int getTargetDuration() {
            return targetDuration;
        }

        private int getSequenceNumber() {
            return sequenceNumber;
        }

        private boolean hasNext() {
            dataListIndex++;
            if (dataListString.size() &gt; dataListIndex || dataListInteger.size() &gt; dataListIndex || dataListDouble.size() &gt; dataListIndex || dataListBoolean.size() &gt; dataListIndex) {
                return true;
            } else {
                return false;
            }
        }

        private String getString() {
            return dataListString.get(dataListIndex);
        }

        private Integer getInteger() {
            return dataListInteger.get(dataListIndex);
        }

        private Double getDouble() {
            return dataListDouble.get(dataListIndex);
        }

        private Boolean getBoolean() {
            return dataListBoolean.get(dataListIndex);
        }

        private boolean parseLine(String line) {
            if (line == null) {
                return false;
            }

            // First line of playlist must be &quot;#EXTM3U&quot;
            if (isFirstLine) {
                if (line.compareTo(&quot;#EXTM3U&quot;) != 0) {
                    return false;
                }

                isFirstLine = false;
                return true;
            }

            // Ignore blank lines and comments
            if (line.isEmpty() || (line.startsWith(&quot;#&quot;) &amp;&amp; !line.startsWith(&quot;#EXT&quot;))) {
                return true;
            }

            if (line.startsWith(&quot;#EXTINF&quot;)) { // #EXTINF
                //#EXTINF:&lt;duration&gt;,&lt;title&gt;
                String[] s1 = line.split(&quot;:&quot;);
                if (s1.length == 2 &amp;&amp; s1[1].length() &gt; 0) {
                    String[] s2 = s1[1].split(&quot;,&quot;);
                    if (s2.length &gt;= 1) { // We have duration
                        dataListDouble.add(Double.parseDouble(s2[0]));
                    }
                }

                isLineMediaFileURI = true;
            } else if (line.startsWith(&quot;#EXT-X-TARGETDURATION&quot;)) {
                // #EXT-X-TARGETDURATION:&lt;s&gt;
                String[] s1 = line.split(&quot;:&quot;);
                if (s1.length == 2 &amp;&amp; s1[1].length() &gt; 0) {
                    targetDuration = Integer.parseInt(s1[1]);
                }
            } else if (line.startsWith(&quot;#EXT-X-MEDIA-SEQUENCE&quot;)) {
                // #EXT-X-MEDIA-SEQUENCE:&lt;number&gt;
                String[] s1 = line.split(&quot;:&quot;);
                if (s1.length == 2 &amp;&amp; s1[1].length() &gt; 0) {
                    sequenceNumber = Integer.parseInt(s1[1]);
                }
            } else if (line.startsWith(&quot;#EXT-X-STREAM-INF&quot;)) {
                // #EXT-X-STREAM-INF:&lt;attribute-list&gt;
                isVariantPlaylist = true;

                int bitrate = 0;
                String[] s1 = line.split(&quot;:&quot;);
                if (s1.length == 2 &amp;&amp; s1[1].length() &gt; 0) {
                    String[] s2 = s1[1].split(&quot;,&quot;);
                    if (s2.length &gt; 0) {
                        for (int i = 0; i &lt; s2.length; i++) {
                            s2[i] = s2[i].trim();
                            if (s2[i].startsWith(&quot;BANDWIDTH&quot;)) {
                                String[] s3 = s2[i].split(&quot;=&quot;);
                                if (s3.length == 2 &amp;&amp; s3[1].length() &gt; 0) {
                                    bitrate = Integer.parseInt(s3[1]);
                                }
                            }
                        }
                    }
                }

                if (bitrate &lt; 1) {
                    return false;
                }

                dataListInteger.add(bitrate);

                isLinePlaylistURI = true; // Next line will be URI to playlist
            } else if (line.startsWith(&quot;#EXT-X-ENDLIST&quot;)) { // #EXT-X-ENDLIST
                isEndList = true;
            } else if (line.startsWith(&quot;#EXT-X-DISCONTINUITY&quot;)) { // #EXT-X-DISCONTINUITY
                isDiscontinuity = true;
            } else if (isLinePlaylistURI) {
                isLinePlaylistURI = false;
                dataListString.add(line);
            } else if (isLineMediaFileURI) {
                isLineMediaFileURI = false;
                dataListString.add(line);
                dataListBoolean.add(isDiscontinuity);
                isDiscontinuity = false;
            }

            return true;
        }

        private Charset getCharset(String url, String mimeType) {
            if ((url != null &amp;&amp; stripParameters(url).endsWith(&quot;.m3u8&quot;)) || (mimeType != null &amp;&amp; mimeType.equals(&quot;application/vnd.apple.mpegurl&quot;))) {
                if (Charset.isSupported(CHARSET_UTF_8)) {
                    return Charset.forName(CHARSET_UTF_8);
                }
            } else if ((url != null &amp;&amp; stripParameters(url).endsWith(&quot;.m3u&quot;)) || (mimeType != null &amp;&amp; mimeType.equals(&quot;audio/mpegurl&quot;))) {
                if (Charset.isSupported(CHARSET_US_ASCII)) {
                    return Charset.forName(CHARSET_US_ASCII);
                }
            }

            return null;
        }
    }

    private static class VariantPlaylist {

        private URI playlistURI = null;
        private int infoIndex = -1;
        private List&lt;String&gt; playlistsLocations = new ArrayList&lt;String&gt;();
        private List&lt;Integer&gt; playlistsBitrates = new ArrayList&lt;Integer&gt;();
        private List&lt;Playlist&gt; playlists = new ArrayList&lt;Playlist&gt;();
        private String mediaFileExtension = null; // Will be set to media file extension of first playlist

        private VariantPlaylist(URI uri) {
            playlistURI = uri;
        }

        private void addPlaylistInfo(String location, int bitrate) {
            playlistsLocations.add(location);
            playlistsBitrates.add(bitrate);
        }

        private void addPlaylist(Playlist playlist) {
            if (mediaFileExtension == null) {
                mediaFileExtension = playlist.getMediaFileExtension();
            } else {
                if (!mediaFileExtension.equals(playlist.getMediaFileExtension())) {
                    playlistsLocations.remove(infoIndex);
                    playlistsBitrates.remove(infoIndex);
                    infoIndex--;
                    return; // Ignore playlist with different media type
                }
            }
            playlists.add(playlist);
        }

        private Playlist getPlaylist(int index) {
            if (playlists.size() &gt; index) {
                return playlists.get(index);
<A NAME="34"></A>            } else {
                return null;
            }
        <FONT color="#827d6b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#34',2,'match31-top.html#34',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

        private boolean hasNext() {
            infoIndex++;
            if (playlistsLocations.size() &gt; infoIndex &amp;&amp; playlistsBitrates.size() &gt; infoIndex) {
                return true;
            } else {
                return false;
            }
        }

        private URI ge</B></FONT>tPlaylistURI() throws URISyntaxException, MalformedURLException {
            String location = playlistsLocations.get(infoIndex);
            if (location.startsWith(&quot;http://&quot;) || location.startsWith(&quot;https://&quot;)) {
                return new URI(location);
            } else {
                return new URI(playlistURI.toURL().toString().substring(0, playlistURI.toURL().toString().lastIndexOf(&quot;/&quot;) + 1) + location);
            }
        }

        private Playlist getPlaylistBasedOnBitrate(int bitrate) {
            int playlistIndex = -1;
            int playlistBitrate = 0;

            // Get bitrate that less then requested bitrate, but most closed to it
            for (int i = 0; i &lt; playlistsBitrates.size(); i++) {
                int b = playlistsBitrates.get(i);
                if (b &lt; bitrate) {
                    if (playlistIndex != -1) {
                        if (b &gt; playlistBitrate) {
                            playlistBitrate = b;
                            playlistIndex = i;
                        }
                    } else {
                        playlistIndex = i;
                    }
                }
            }

            // If we did not find one (stall), then get the lowest bitrate possible
            if (playlistIndex == -1) {
                for (int i = 0; i &lt; playlistsBitrates.size(); i++) {
                    int b = playlistsBitrates.get(i);
                    if (b &lt; playlistBitrate || playlistIndex == -1) {
                        playlistBitrate = b;
                        playlistIndex = i;
                    }
                }
            }

            // Just in case
            if (playlistIndex &lt; 0 || playlistIndex &gt;= playlists.size()) {
                return null;
             } else {
                return playlists.get(playlistIndex);
            }
        }
    }

    private class Playlist {

        private boolean isLive = false;
        private volatile boolean isLiveWaiting = false;
        private volatile boolean isLiveStop = false;
        private long targetDuration = 0;
        private URI playlistURI = null;
        private final Object lock = new Object();
        private List&lt;String&gt; mediaFiles = new ArrayList&lt;String&gt;();
        private List&lt;Double&gt; mediaFilesStartTimes = new ArrayList&lt;Double&gt;();
        private List&lt;Boolean&gt; mediaFilesDiscontinuities = new ArrayList&lt;Boolean&gt;();
        private boolean needBaseURI = true;
        private String baseURI = null;
        private double duration = 0.0;
        private int sequenceNumber = -1;
        private int sequenceNumberStart = -1;
        private boolean sequenceNumberUpdated = false;
        private boolean forceDiscontinuity = false;

        private Playlist(boolean isLive, int targetDuration) {
            this.isLive = isLive;
            this.targetDuration = targetDuration * 1000;

            if (isLive) {
                duration = -1.0;
            }
        }

        private Playlist(URI uri) {
            playlistURI = uri;
        }

        private void update(String nextMediaFile) {
            PlaylistParser parser = new PlaylistParser();
            parser.load(playlistURI);

            isLive = parser.isLivePlaylist();
            targetDuration = parser.getTargetDuration() * 1000;

            if (isLive) {
                duration = -1.0;
            }

            if (setSequenceNumber(parser.getSequenceNumber())) {
                while (parser.hasNext()) {
                    addMediaFile(parser.getString(), parser.getDouble(), parser.getBoolean());
                }
            }

            if (nextMediaFile != null) {
                synchronized (lock) {
                    for (int i = 0; i &lt; mediaFiles.size(); i++) {
                        String mediaFile = mediaFiles.get(i);
                        if (nextMediaFile.endsWith(mediaFile)) {
                            mediaFileIndex = i - 1;
                            break;
                        }
                    }
                }
            }
        }

        private boolean isLive() {
            return isLive;
        }

        private long getTargetDuration() {
            return targetDuration;
        }

        private void setPlaylistURI(URI uri) {
            playlistURI = uri;
        }

        private void addMediaFile(String URI, double duration, boolean isDiscontinuity) {
            synchronized (lock) {

                if (needBaseURI) {
                    setBaseURI(playlistURI.toString(), URI);
                }

                if (isLive) {
                    if (sequenceNumberUpdated) {
                        int index = mediaFiles.indexOf(URI);
                        if (index != -1) {
                            for (int i = 0; i &lt; index; i++) {
                                mediaFiles.remove(0);
                                mediaFilesDiscontinuities.remove(0);
                                if (mediaFileIndex == -1) {
                                    forceDiscontinuity = true;
                                }
                                if (mediaFileIndex &gt;= 0) {
                                    mediaFileIndex--;
                                }
                            }
                        }
                        sequenceNumberUpdated = false;
                    }

                    if (mediaFiles.contains(URI)) {
                        return; // Nothing to add
                    }
                }

                mediaFiles.add(URI);
                mediaFilesDiscontinuities.add(isDiscontinuity);

                if (isLive) {
                    if (isLiveWaiting) {
                        liveSemaphore.release();
                    }
                } else {
                    mediaFilesStartTimes.add(this.duration);
                    this.duration += duration;
                }
            }
        }

        private String getNextMediaFile() {
            if (isLive) {
                synchronized (lock) {
                    isLiveWaiting = ((mediaFileIndex + 1) &gt;= mediaFiles.size());
                }
                if (isLiveWaiting) {
                    try {
                        liveSemaphore.acquire();
                        isLiveWaiting = false;
                        if (isLiveStop) {
                            isLiveStop = false;
                            return null;
                        }
                    } catch (InterruptedException e) {
                        isLiveWaiting = false;
                        return null;
                    }
                }
                if (isPlaylistClosed) {
                    return null;
                }
            }

            synchronized (lock) {
                mediaFileIndex++;
                if ((mediaFileIndex) &lt; mediaFiles.size()) {
                    if (baseURI != null) {
                        return baseURI + mediaFiles.get(mediaFileIndex);
                    } else {
                        return mediaFiles.get(mediaFileIndex);
                    }
                } else {
                    return null;
                }
            }
        }

        private double getDuration() {
            return duration;
        }

        private void setForceDiscontinuity(boolean value) {
            forceDiscontinuity = value;
        }

        private boolean isCurrentMediaFileDiscontinuity() {
            if (forceDiscontinuity) {
                forceDiscontinuity = false;
                return true;
            } else {
                return mediaFilesDiscontinuities.get(mediaFileIndex);
            }
        }

        private double seek(long time) {
            synchronized (lock) {
                if (isLive) {
                    if (time == 0) {
                        mediaFileIndex = -1;
                        if (isLiveWaiting) {
                            isLiveStop = true;
                            liveSemaphore.release();
                        }
                        return 0;
                    }
                } else {
                    time += targetDuration / 2000;

                    int mediaFileStartTimeSize = mediaFilesStartTimes.size();

                    for (int index = 0; index &lt; mediaFileStartTimeSize; index++) {
                        if (time &gt;= mediaFilesStartTimes.get(index)) {
                            if (index + 1 &lt; mediaFileStartTimeSize) {
                                if (time &lt; mediaFilesStartTimes.get(index + 1)) {
                                    mediaFileIndex = index - 1; // Seek will load segment and increment mediaFileIndex
                                    return mediaFilesStartTimes.get(index);
                                }
                            } else {
                                if ((time - targetDuration / 2000) &lt; duration) {
                                    mediaFileIndex = index - 1; // Seek will load segment and increment mediaFileIndex
                                    return mediaFilesStartTimes.get(index);
                                } else if (Double.compare(time - targetDuration / 2000, duration) == 0) {
                                    return duration;
                                }
                            }
                        }
                    }
                }
            }

            return -1;
        }

        private int getMimeType() {
            synchronized (lock) {
                if (mediaFiles.size() &gt; 0) {
                    if (stripParameters(mediaFiles.get(0)).endsWith(&quot;.ts&quot;)) {
                        return HLS_VALUE_MIMETYPE_MP2T;
                    } else if (stripParameters(mediaFiles.get(0)).endsWith(&quot;.mp3&quot;)) {
                        return HLS_VALUE_MIMETYPE_MP3;
                    }
                }
            }

            return -1;
        }

        private String getMediaFileExtension() {
            synchronized (lock) {
                if (mediaFiles.size() &gt; 0) {
                    String mediaFile = stripParameters(mediaFiles.get(0));
                    int index = mediaFile.lastIndexOf(&quot;.&quot;);
                    if (index != -1) {
                        return mediaFile.substring(index);
                    }
                }
            }

            return null;
        }

        private boolean setSequenceNumber(int value) {
            if (sequenceNumberStart == -1) {
                sequenceNumberStart = value;
            } else if (sequenceNumber != value) {
                sequenceNumberUpdated = true;
                sequenceNumber = value;
            } else {
                return false;
            }

            return true;
        }

        private void close() {
            if (isLive) {
                isPlaylistClosed = true;
                liveSemaphore.release();
            }
        }

        private void setBaseURI(String playlistURI, String URI) {
            if (!URI.startsWith(&quot;http://&quot;) &amp;&amp; !URI.startsWith(&quot;https://&quot;)) {
                baseURI = playlistURI.substring(0, playlistURI.lastIndexOf(&quot;/&quot;) + 1);
            }
            needBaseURI = false;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.media/com/sun/media/jfxmediaimpl/platform/PlatformManager.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.jfxmediaimpl.platform;

import com.sun.media.jfxmedia.Media;
import com.sun.media.jfxmedia.MediaPlayer;
import com.sun.media.jfxmedia.MetadataParser;
import com.sun.media.jfxmedia.locator.Locator;
import com.sun.media.jfxmedia.logging.Logger;
import com.sun.media.jfxmediaimpl.platform.java.JavaPlatform;
import com.sun.media.jfxmediaimpl.HostUtils;
import com.sun.media.jfxmediaimpl.platform.gstreamer.GSTPlatform;
import com.sun.media.jfxmediaimpl.platform.osx.OSXPlatform;
import com.sun.media.jfxmediaimpl.platform.ios.IOSPlatform;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * Core media platform management code.
 */
public final class PlatformManager {
    private static String enabledPlatforms;
    static {
        AccessController.doPrivileged((PrivilegedAction) () -&gt; {
            getPlatformSettings();
            return null;
        });
    }

    private static void getPlatformSettings() {
        // get enabled platforms, comma separated list, e.g., -Djfxmedia.platforms=GSTPlatform,OSXPlatform
        enabledPlatforms = System.getProperty(&quot;jfxmedia.platforms&quot;, &quot;&quot;).toLowerCase();
    }

    private static boolean isPlatformEnabled(String name) {
        if (null == enabledPlatforms || enabledPlatforms.length() == 0) {
            // everything enabled
            return true;
        }
        return (enabledPlatforms.indexOf(name.toLowerCase()) != -1);
    }

    private static final class PlatformManagerInitializer {
        private static final PlatformManager globalInstance = new PlatformManager();
    }

    public static PlatformManager getManager() {
        return PlatformManagerInitializer.globalInstance;
    }

    private final List&lt;Platform&gt; platforms;

    private PlatformManager() {
        platforms = new ArrayList&lt;Platform&gt;();

        Platform platty;

        /*
         * We don't want to fully initialize the platforms here for performance
         * reasons but some platforms may be dependent on native resources that
         * need to be loaded, those platforms need to be given a chance to load
         * those resources (without initializing) and determine if the natives
         * are available.
         */

        // Now &quot;universal&quot; platform(s)
        if (isPlatformEnabled(&quot;JavaPlatform&quot;)) {
            platty = JavaPlatform.getPlatformInstance();
            if (null != platty) {
                platforms.add(platty);
            }
        }

        if (!HostUtils.isIOS() &amp;&amp; isPlatformEnabled(&quot;GSTPlatform&quot;)) {
            platty = GSTPlatform.getPlatformInstance();
            if (null != platty) {
                platforms.add(platty);
            }
        }

        // Add after GSTPlatform so it's used as a fallback
        if (HostUtils.isMacOSX() &amp;&amp; isPlatformEnabled(&quot;OSXPlatform&quot;)) {
            platty = OSXPlatform.getPlatformInstance();
            if (null != platty) {
                platforms.add(platty);
            }
        }

        if (HostUtils.isIOS() &amp;&amp; isPlatformEnabled(&quot;IOSPlatform&quot;)) {
            platty = IOSPlatform.getPlatformInstance();
            if (null != platty) {
                platforms.add(platty);
            }
        }

        if (Logger.canLog(Logger.DEBUG)) {
            StringBuilder sb = new StringBuilder(&quot;Enabled JFXMedia platforms: &quot;);
            for (Platform p : platforms) {
                sb.append(&quot;\n   - &quot;);
                sb.append(p.getClass().getName());
            }
            Logger.logMsg(Logger.DEBUG, sb.toString());
        }
    }

    public synchronized void loadPlatforms() {
        // Use an iterator so we can remove on failure
        Iterator&lt;Platform&gt; iter = platforms.iterator();
        while (iter.hasNext()) {
            Platform platty = iter.next();
            if (!platty.loadPlatform()) {
                if (Logger.canLog(Logger.DEBUG)) {
                    Logger.logMsg(Logger.DEBUG, &quot;Failed to load platform: &quot;+platty);
                }
                // remove it so it can't be reused
                iter.remove();
            }
        }
    }

    public List&lt;String&gt; getSupportedContentTypes() {
        ArrayList&lt;String&gt; outTypes = new ArrayList&lt;String&gt;();

        if (!platforms.isEmpty()) {
            for (Platform platty : platforms) {
                if (Logger.canLog(Logger.DEBUG)) {
                    Logger.logMsg(Logger.DEBUG, &quot;Getting content types from platform: &quot;+platty);
                }
                String[] npt = platty.getSupportedContentTypes();
                if (npt != null) {
                    for (String type : npt) {
                        if (!outTypes.contains(type)) {
                            outTypes.add(type);
                        }
                    }
                }
            }
        }

        return outTypes;
    }

    public List&lt;String&gt; getSupportedProtocols() {
        ArrayList&lt;String&gt; outProtocols = new ArrayList&lt;String&gt;();

        if (!platforms.isEmpty()) {
            for (Platform platty : platforms) {
                String[] npt = platty.getSupportedProtocols();
                if (npt != null) {
                    for (String p : npt) {
                        if (!outProtocols.contains(p)) {
                            outProtocols.add(p);
                        }
                    }
                }
            }
        }

        return outProtocols;
    }

    public MetadataParser createMetadataParser(Locator source) {
        for (Platform platty : platforms) {
            MetadataParser parser = platty.createMetadataParser(source);
            if (parser != null) {
                return parser;
            }
        }

        return null;
    }

    // FIXME: Make Media non-platform specific, it doesn't need to be
    public Media createMedia(Locator source) {
        String mimeType = source.getContentType();
        String protocol = source.getProtocol();
        // go down the list until we get one that can be created
<A NAME="37"></A>        for (Platform platty : platforms) {
            if (platty.canPlayContentType(mimeType) &amp;&amp; platty.canPlayProtocol(protocol)) {
                Media outMedia = platty.createMedia(source);
                <FONT color="#810541"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#37',2,'match31-top.html#37',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (null != outMedia) {
                    return outMedia;
                }
            }
        }

        return null;
    }

    public MediaPlayer createMediaPlayer(Locator source) {</B></FONT>
        String mimeType = source.getContentType();
        String protocol = source.getProtocol();
        // go down the list until we get one that can be created
        for (Platform platty : platforms) {
            if (platty.canPlayContentType(mimeType) &amp;&amp; platty.canPlayProtocol(protocol)) {
                MediaPlayer outPlayer = platty.createMediaPlayer(source);
                if (null != outPlayer) {
                    return outPlayer;
                }
            }
        }

        return null;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.swing/com/sun/javafx/embed/swing/CachingTransferable.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.embed.swing;

import java.awt.datatransfer.DataFlavor;
<A NAME="43"></A>import java.awt.datatransfer.Transferable;
import java.io.UnsupportedEncodingException;
import java.util.Arrays;
<FONT color="#c22817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#43',2,'match31-top.html#43',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import javafx.scene.input.Clipboard;
import javafx.scene.input.DataFormat;

/**
 * A Transferable implementation backed by a Map.
 * The data can be populated either from AWT Transferable
 * or from FX Clipboard.
 */
public class CachingTransferable implements Transferable {

    @Override
    public Object getTransferData(final DataFlavor flavor) throws UnsupportedEncodingException
    {
        String mimeType = DataFlavorUtils.getFxMimeType</B></FONT>(flavor);
        return DataFlavorUtils.adjustFxData(
                flavor, getData(mimeType));
    }

    @Override
    public DataFlavor[] getTransferDataFlavors() {
        final String mimeTypes[] = getMimeTypes();
        return DataFlavorUtils.getDataFlavors(mimeTypes);
    }

    @Override
    public boolean isDataFlavorSupported(final DataFlavor flavor) {
        return isMimeTypeAvailable(
                DataFlavorUtils.getFxMimeType(flavor));
    }

    private Map&lt;String, Object&gt; mimeType2Data = Collections.EMPTY_MAP;

    public void updateData(Transferable t, boolean fetchData) {
        final Map&lt;String, DataFlavor&gt; mimeType2DataFlavor =
                DataFlavorUtils.adjustSwingDataFlavors(
                t.getTransferDataFlavors());

        // If we keep reference to source Transferable in SwingDragSource and
        // call Transferable#getTransferData() on it from
        // SwingDragSource#getData() we may run into
        // &quot;java.awt.dnd.InvalidDnDOperationException&quot; issue as
        // SwingDragSource#getData() is called from FX user code and from
        // QuantumClipboard#getContent() (sik!). These calls usually take
        // place in the context of
        // EmbeddedSceneDTInterface#handleDragDrop() method as the
        // normal handling of DnD.
        // Instead of keeping reference to source Transferable we just read
        // all its data while in the context safe for calling
        // Transferable#getTransferData().
        //
        // This observation is true for standard AWT Transferable-s.
        // Things may be totally broken for custom Transferable-s though.

        // For performance reasons, the DRAG_ENTERED and DRAG_OVER event
        // handlers pass fetchData == false so as to update the set of
        // available MIME types only. The DRAG_DROPPED handler passes
        // fetchData == true which also fetches all the data.
        // NOTE: Due to JDK-8028585 this code won't be able to fetch data
        // when invoked from handlers other than DROPPED in any case.

        try {
            mimeType2Data = DataFlavorUtils.readAllData(t, mimeType2DataFlavor,
                    fetchData);
        } catch (Exception e) {
            mimeType2Data = Collections.EMPTY_MAP;
        }
    }

    public void updateData(Clipboard cb, boolean fetchData) {
        mimeType2Data = new HashMap&lt;&gt;();
        for (DataFormat f : cb.getContentTypes()) {
            mimeType2Data.put(DataFlavorUtils.getMimeType(f),
                    fetchData ? cb.getContent(f) : null);
        }
    }

    public Object getData(final String mimeType) {
        return mimeType2Data.get(mimeType);
    }

    public String[] getMimeTypes() {
        return mimeType2Data.keySet().toArray(new String[0]);
    }

    public boolean isMimeTypeAvailable(final String mimeType) {
        return Arrays.asList(getMimeTypes()).contains(mimeType);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/javafx/webkit/theme/RenderThemeImpl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.webkit.theme;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.collections.FXCollections;
import javafx.geometry.Orientation;
import javafx.scene.control.Button;
import javafx.scene.control.CheckBox;
import javafx.scene.control.ChoiceBox;
import javafx.scene.control.Control;
import javafx.scene.control.ProgressBar;
import javafx.scene.control.RadioButton;
import javafx.scene.control.SkinBase;
import javafx.scene.control.Slider;
import javafx.scene.control.TextField;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.Region;
import java.lang.ref.WeakReference;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.LinkedHashMap;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;
import com.sun.javafx.webkit.Accessor;
import com.sun.webkit.LoadListenerClient;
import com.sun.webkit.graphics.Ref;
import com.sun.webkit.graphics.RenderTheme;
import com.sun.webkit.graphics.WCGraphicsContext;
import com.sun.webkit.graphics.WCSize;
import javafx.application.Application;

public final class RenderThemeImpl extends RenderTheme {
    private final static PlatformLogger log = PlatformLogger.getLogger(RenderThemeImpl.class.getName());

    enum WidgetType {
        TEXTFIELD      (0),
        BUTTON         (1),
        CHECKBOX       (2),
        RADIOBUTTON    (3),
        MENULIST       (4),
        MENULISTBUTTON (5),
        SLIDER         (6),
        PROGRESSBAR    (7),
        METER          (8),
        SCROLLBAR      (9);

        private static final HashMap&lt;Integer, WidgetType&gt; map = new HashMap&lt;Integer, WidgetType&gt;();
        private final int value;

        private WidgetType(int value) { this.value = value; }

        static { for (WidgetType v: values()) map.put(v.value, v); }

        private static WidgetType convert(int index) { return map.get(index); }
    };

    private Accessor accessor;
    private boolean isDefault; // indicates if the instance is used in non-page context

    private Pool&lt;FormControl&gt; pool;

    /**
     * A pool of controls.
     * Based on a hash map where a control is the value and its ID is the key.
     * The pool size is limited. When a new control is added to the pool and
     * the limit is reached, a control which is used most rarely is removed.
     */
    static final class Pool&lt;T extends Widget&gt; {
        private static final int INITIAL_CAPACITY = 100;

        private int capacity = INITIAL_CAPACITY;

        // A map of control IDs used to track the rate of accociated controls
        // based on their &quot;popularity&quot;.
        // Maps an ID to an updateContentCycleID corresponding to the cycle
        // at which the control was added to the pool.
        private final LinkedHashMap&lt;Long, Integer&gt; ids = new LinkedHashMap&lt;&gt;();

        // A map b/w the IDs and associated controls.
        // The {@code ids} map is kept in sync with the set of keys.
        private final Map&lt;Long, WeakReference&lt;T&gt;&gt; pool = new HashMap&lt;&gt;();

        private final Notifier&lt;T&gt; notifier;
        private final String type; // used for logging

        /**
         * An interface used to notify the implementor of removal
         * of a control from the pool.
         */
        interface Notifier&lt;T&gt; {
            public void notifyRemoved(T control);
        }

        Pool(Notifier&lt;T&gt; notifier, Class&lt;T&gt; type) {
            this.notifier = notifier;
            this.type = type.getSimpleName();
        }

        T get(long id) {
            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;type: {0}, size: {1}, id: 0x{2}&quot;,
                        new Object[] {type, pool.size(), Long.toHexString(id)});
            }
            assert ids.size() == pool.size();

            WeakReference&lt;T&gt; controlRef = pool.get(id);
            if (controlRef == null) {
                return null;
            }

            T control = controlRef.get();
            if (control == null) {
                return null;
            }

            // &quot;Bubble&quot; the id.
            Integer value = ids.remove(Long.valueOf(id));
            ids.put(id, value);

            return control;
        }

        void put(long id, T control, int updateContentCycleID) {
            if (log.isLoggable(Level.FINEST)) {
                log.finest(&quot;size: {0}, id: 0x{1}, control: {2}&quot;,
                        new Object[] {pool.size(), Long.toHexString(id), control.getType()});
            }
            if (ids.size() &gt;= capacity) {
                // Pull a control from the bottom of the map, least used.
                Long _id = ids.keySet().iterator().next();
                Integer cycleID = ids.get(_id);
                // Remove that &quot;unpopular&quot; control in case it wasn't added
                // during the current update cycle.
                if (cycleID != updateContentCycleID) {
                    ids.remove(_id);
                    T _control = pool.remove(_id).get();
                    if (_control != null) {
                        notifier.notifyRemoved(_control);
                    }
                // Otherwise, double the pool capacity.
                } else {
                    capacity = Math.min(capacity, (int)Math.ceil(Integer.MAX_VALUE/2)) * 2;
                }
            }
            ids.put(id, updateContentCycleID);
            pool.put(id, new WeakReference&lt;T&gt;(control));
        }

        void clear() {
            if (log.isLoggable(Level.FINE)) {
                log.fine(&quot;size: &quot; + pool.size() + &quot;, controls: &quot; + pool.values());
            }
            if (pool.size() == 0) {
                return;
            }
            ids.clear();
            for (WeakReference&lt;T&gt; controlRef : pool.values()) {
                T control = controlRef.get();
                if (control != null) {
                    notifier.notifyRemoved(control);
                }
            }
            pool.clear();
            capacity = INITIAL_CAPACITY;
        }
    }

    static class ViewListener implements InvalidationListener {
        private final Pool pool;
        private final Accessor accessor;
        private LoadListenerClient loadListener;

        ViewListener(Pool pool, Accessor accessor) {
            this.pool = pool;
            this.accessor = accessor;
        }

        @Override public void invalidated(Observable ov) {
            pool.clear(); // clear the pool when WebView changes

            // Add the LoadListenerClient when the page is available.
            if (accessor.getPage() != null &amp;&amp; loadListener == null) {
                loadListener = new LoadListenerClient() {
                    @Override
                    public void dispatchLoadEvent(long frame, int state, String url,
                                                  String contentType, double progress, int errorCode)
                    {
                        if (state == LoadListenerClient.PAGE_STARTED) {
                            // An html page with new content is being loaded.
                            // Clear the controls associated with the previous html page.
                            pool.clear();
                        }
                    }
                    @Override
                    public void dispatchResourceLoadEvent(long frame, int state, String url,
                                                          String contentType, double progress,
                                                          int errorCode) {}
                };
                accessor.getPage().addLoadListenerClient(loadListener);
            }
        }
    }

    public RenderThemeImpl(final Accessor accessor) {
        this.accessor = accessor;
        pool = new Pool&lt;FormControl&gt;(fc -&gt; {
            // Remove the control from WebView when it's removed from the pool.
            accessor.removeChild(fc.asControl());
        }, FormControl.class);
        accessor.addViewListener(new ViewListener(pool, accessor));
    }

    public RenderThemeImpl() {
        isDefault = true;
    }

    private void ensureNotDefault() {
        if (isDefault) {
            throw new IllegalStateException(&quot;the method should not be called in this context&quot;);
        }
    }

    @Override
    protected Ref createWidget(
        long id,
        int widgetIndex,
        int state,
        int w, int h,
        int bgColor,
        ByteBuffer extParams)
    {
        ensureNotDefault();

        FormControl fc = pool.get(id);
        WidgetType type = WidgetType.convert(widgetIndex);

        if (fc == null || fc.getType() != type) {
            if (fc  != null) {
                // Remove the unmatching control.
                accessor.removeChild(fc.asControl());
            }
            switch (type) {
                case TEXTFIELD:
                    fc = new FormTextField();
                    break;
                case BUTTON:
                    fc = new FormButton();
                    break;
                case CHECKBOX:
                    fc = new FormCheckBox();
                    break;
                case RADIOBUTTON:
                    fc = new FormRadioButton();
                    break;
                case MENULIST:
                    fc = new FormMenuList();
                    break;
                case MENULISTBUTTON:
                    fc = new FormMenuListButton();
                    break;
                case SLIDER:
                    fc = new FormSlider();
                    break;
                case PROGRESSBAR:
                    fc = new FormProgressBar(WidgetType.PROGRESSBAR);
                    break;
                case METER:
                    fc = new FormProgressBar(WidgetType.METER);
                    break;
                default:
                    log.severe(&quot;unknown widget index: {0}&quot;, widgetIndex);
                    return null;
            }
            fc.asControl().setFocusTraversable(false);
            pool.put(id, fc, accessor.getPage().getUpdateContentCycleID()); // put or replace the entry
            accessor.addChild(fc.asControl());
        }

        fc.setState(state);
        Control ctrl = fc.asControl();
        if (ctrl.getWidth() != w || ctrl.getHeight() != h) {
            ctrl.resize(w, h);
        }
        if (ctrl.isManaged()) {
            ctrl.setManaged(false);
        }

        if (extParams != null) {
            if (type == WidgetType.SLIDER) {
                Slider slider = (Slider)ctrl;
                extParams.order(ByteOrder.nativeOrder());
                slider.setOrientation(extParams.getInt()==0
                    ? Orientation.HORIZONTAL
                    : Orientation.VERTICAL);
                slider.setMax(extParams.getFloat());
                slider.setMin(extParams.getFloat());
                slider.setValue(extParams.getFloat());
            } else if (type == WidgetType.PROGRESSBAR) {
                ProgressBar progress = (ProgressBar)ctrl;
                extParams.order(ByteOrder.nativeOrder());
                progress.setProgress(extParams.getInt() == 1
                        ? extParams.getFloat()
                        : progress.INDETERMINATE_PROGRESS);
            } else if (type == WidgetType.METER) {
                ProgressBar progress = (ProgressBar) ctrl;
                extParams.order(ByteOrder.nativeOrder());
                progress.setProgress(extParams.getFloat());
                progress.setStyle(getMeterStyle(extParams.getInt()));
            }
        }
        return new FormControlRef(fc);
    }

    private String getMeterStyle(int region) {
        // see GaugeRegion in HTMLMeterElement.h
        switch (region) {
            case 1: // GaugeRegionSuboptimal
                return &quot;-fx-accent: yellow&quot;;
            case 2: // GaugeRegionEvenLessGood
                return &quot;-fx-accent: red&quot;;
            default: // GaugeRegionOptimum
                return &quot;-fx-accent: green&quot;;
        }
    }

    @Override
    public void drawWidget(
        WCGraphicsContext g,
        final Ref widget,
        int x, int y)
    {
        ensureNotDefault();

        FormControl fcontrol = ((FormControlRef) widget).asFormControl();
        if (fcontrol != null) {
            Control control = fcontrol.asControl();
            if (control != null) {
                g.saveState();
                g.translate(x, y);
                Renderer.getRenderer().render(control, g);
                g.restoreState();
            }
        }
    }

    @Override
    public WCSize getWidgetSize(Ref widget) {
        ensureNotDefault();

        FormControl fcontrol = ((FormControlRef)widget).asFormControl();
        if (fcontrol != null) {
            Control control = fcontrol.asControl();
            return new WCSize((float)control.getWidth(), (float)control.getHeight());
        }
        return new WCSize(0, 0);
    }

    @Override
    protected int getRadioButtonSize() {
        String style = Application.getUserAgentStylesheet();
        if (Application.STYLESHEET_MODENA.equalsIgnoreCase(style)) {
            return 20; // 18 + 2; size + focus outline
        } else if (Application.STYLESHEET_CASPIAN.equalsIgnoreCase(style)) {
            return 19; // 16 + 3; size + focus outline
        }
        return 20;
    }

    // TODO: get theme value
    @Override
    protected int getSelectionColor(int index) {
        switch (index) {
            case BACKGROUND: return 0xff0093ff;
            case FOREGROUND: return 0xffffffff;
            default: return 0;
        }
    }

    private static boolean hasState(int state, int mask) {
        return (state &amp; mask) != 0;
    }

    private static final class FormControlRef extends Ref {
        private final WeakReference&lt;FormControl&gt; fcRef;

        private FormControlRef(FormControl fc) {
            this.fcRef = new WeakReference&lt;FormControl&gt;(fc);
        }

        private FormControl asFormControl() {
            return fcRef.get();
        }
    }

    interface Widget {
        public WidgetType getType();
    }

    private interface FormControl extends Widget {
        public Control asControl();
        public void setState(int state);
    }

    private static final class FormButton extends Button implements FormControl {

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
            setPressed(hasState(state, RenderTheme.PRESSED));
            if (isPressed()) arm(); else disarm();
        }

        @Override public WidgetType getType() { return WidgetType.BUTTON; };
    }

    private static final class FormTextField extends TextField implements FormControl {

        private FormTextField() {
            setStyle(&quot;-fx-display-caret: false&quot;);
        }

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setEditable(hasState(state, RenderTheme.READ_ONLY));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
        }

        @Override public WidgetType getType() { return WidgetType.TEXTFIELD; };
    }

    private static final class FormCheckBox extends CheckBox implements FormControl {

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
            setSelected(hasState(state, RenderTheme.CHECKED));
        }

        @Override public WidgetType getType() { return WidgetType.CHECKBOX; };
    }

    private static final class FormRadioButton extends RadioButton implements FormControl {

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
            setSelected(hasState(state, RenderTheme.CHECKED));
        }

        @Override public WidgetType getType() { return WidgetType.RADIOBUTTON; };
    }

    private static final class FormSlider extends Slider implements FormControl {

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
        }

        @Override public WidgetType getType() { return WidgetType.SLIDER; };
    }

    private static final class FormProgressBar extends ProgressBar implements FormControl {
        private final WidgetType type;

        private FormProgressBar(WidgetType type) {
            this.type = type;
        }

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
        }

        @Override public WidgetType getType() { return type; };
    }

    private static final class FormMenuList extends ChoiceBox implements FormControl {

        private FormMenuList() {
            // Adding a dummy item to please ChoiceBox.
            List&lt;String&gt; l = new ArrayList&lt;String&gt;();
            l.add(&quot;&quot;);
            setItems(FXCollections.observableList(l));
        }

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setFocused(hasState(state, RenderTheme.FOCUSED));
            setHover(hasState(state, RenderTheme.HOVERED) &amp;&amp; !isDisabled());
        }

        @Override public WidgetType getType() { return WidgetType.MENULIST; };
    }

    private static final class FormMenuListButton extends Button implements FormControl {

        private static final int MAX_WIDTH = 20;
        private static final int MIN_WIDTH = 16;

        @Override public Control asControl() { return this; }

        @Override public void setState(int state) {
            setDisabled(! hasState(state, RenderTheme.ENABLED));
            setHover(hasState(state, RenderTheme.HOVERED));
            setPressed(hasState(state, RenderTheme.PRESSED));
            if (isPressed()) arm(); else disarm();
        }

        private FormMenuListButton() {
            setSkin(new Skin());
            setFocusTraversable(false);
            getStyleClass().add(&quot;form-select-button&quot;);
        }

        /**
         * @param height is the height of the FormMenuList widget
         * @param width is passed equal to height
         */
        @Override public void resize(double width, double height) {
            width = height &gt; MAX_WIDTH ? MAX_WIDTH : height &lt; MIN_WIDTH ? MIN_WIDTH : height;

            super.resize(width, height);

            // [x] is originally aligned with the right edge of
            // the menulist control, and here we adjust it
            setTranslateX(-width);
        }

        private final class Skin extends SkinBase {
            Skin() {
<A NAME="44"></A>                super(FormMenuListButton.this);

                Region arrow = new Region();
                <FONT color="#e57ded"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#44',2,'match31-top.html#44',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>arrow.getStyleClass().add(&quot;arrow&quot;);
                arrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
                BorderPane pane = new BorderPane();
                pane.setCenter(arrow);
                getChildren().add(pane);
            }
        }</B></FONT>

        @Override public WidgetType getType() { return WidgetType.MENULISTBUTTON; };
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/webkit/dom/CharacterDataImpl.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
<A NAME="1"></A>
package com.sun.webkit.dom;

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#1',2,'match31-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.lang.annotation.Native;
import org.w3c.dom.CharacterData;
import org.w3c.dom.DOMException;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

public class CharacterDataImpl extends NodeImpl implements CharacterData {
    @Native public static final byte DIRECTIONALITY_LEFT_TO_RIGHT = Character.DIRECTIONALITY_LEFT_TO_RIGHT;
    @Native public static final byte DIRECTIONALITY_RIGHT_TO_LEFT = Character.DIRECTIONALITY_RIGHT_TO_LEFT;
    @Native public static final byte DIRECTIONALITY_EUROPEAN_NUMBER = Character.DIRECTIONALITY_EUROPEAN_NUMBER;
    @Native public static final byte DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR = Character.DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR;
    @Native public static final byte DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR = Character.DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR;
    @Native public static final byte DIRECTIONALITY_ARABIC_NUMBER = Character.DIRECTIONALITY_ARABIC_NUMBER;
    @Native public static final byte DIRECTIONALITY_COMMON_NUMBER_SEPARATOR = Character.DIRECTIONALITY_COMMON_NUMBER_SEPARATOR;
    @Native public static final byte DIRECTIONALITY_PARAGRAPH_SEPARATOR = Character.DIRECTIONALITY_PARAGRAPH_SEPARATOR;
    @Native public static final byte DIRECTIONALITY_SEGMENT_SEPARATOR = Character.DIRECTIONALITY_SEGMENT_SEPARATOR;
    @Native public static final byte DIRECTIONALITY_WHITESPACE = Character.DIRECTIONALITY_WHITESPACE;
    @Native public static final byte DIRECTIONALITY_OTHER_NEUTRALS = Character.DIRECTIONALITY_OTHER_NEUTRALS;
    @Native public static final byte DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING = Character.DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING;
    @Native public static final byte DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE = Character.DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE;
    @Native public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC = Character.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC;
    @Native public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING = Character.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING;
    @Native public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE = Character.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE;
    @Native public static final byte DIRECTIONALITY_POP_DIRECTIONAL_FORMAT = Character.DIRECTIONALITY_POP_DIRECTIONAL_FORMAT;
    @Native public static final byte DIRECTIONALITY_NONSPACING_MARK = Character.DIRECTIONALITY_NONSPACING_MARK;
    @Native public static final byte DIRECTIONALITY_BOUNDARY_NEUTRAL = Character.DIRECTIONALITY_BOUNDARY_NEUTRAL;
    @Native public static final byte UNASSIGNED = Character.UNASSIGNED;
    @Native public static final byte UPPERCASE_LETTER = Character.UPPERCASE_LETTER;
    @Native public static final byte LOWERCASE_LETTER = Character.LOWERCASE_LETTER;
    @Native public static final byte TITLECASE_LETTER = Character.TITLECASE_LETTER</B></FONT>;
    @Native public static final byte MODIFIER_LETTER = Character.MODIFIER_LETTER;
    @Native public static final byte OTHER_LETTER = Character.OTHER_LETTER;

    @Native public static final byte NON_SPACING_MARK = Character.NON_SPACING_MARK;
    @Native public static final byte ENCLOSING_MARK = Character.ENCLOSING_MARK;
    @Native public static final byte COMBINING_SPACING_MARK = Character.COMBINING_SPACING_MARK;

    @Native public static final byte DECIMAL_DIGIT_NUMBER = Character.DECIMAL_DIGIT_NUMBER;
    @Native public static final byte LETTER_NUMBER = Character.LETTER_NUMBER;
    @Native public static final byte OTHER_NUMBER = Character.OTHER_NUMBER;

    @Native public static final byte SPACE_SEPARATOR = Character.SPACE_SEPARATOR;
    @Native public static final byte LINE_SEPARATOR = Character.LINE_SEPARATOR;
    @Native public static final byte PARAGRAPH_SEPARATOR = Character.PARAGRAPH_SEPARATOR;

    @Native public static final byte CONTROL = Character.CONTROL;
    @Native public static final byte FORMAT = Character.FORMAT;
    @Native public static final byte PRIVATE_USE = Character.PRIVATE_USE;
    @Native public static final byte SURROGATE = Character.SURROGATE;

    @Native public static final byte DASH_PUNCTUATION = Character.DASH_PUNCTUATION;
    @Native public static final byte START_PUNCTUATION = Character.START_PUNCTUATION;
    @Native public static final byte END_PUNCTUATION = Character.END_PUNCTUATION;
    @Native public static final byte CONNECTOR_PUNCTUATION = Character.CONNECTOR_PUNCTUATION;
    @Native public static final byte OTHER_PUNCTUATION = Character.OTHER_PUNCTUATION;

    @Native public static final byte MATH_SYMBOL = Character.MATH_SYMBOL;
    @Native public static final byte CURRENCY_SYMBOL = Character.CURRENCY_SYMBOL;
    @Native public static final byte MODIFIER_SYMBOL = Character.MODIFIER_SYMBOL;
    @Native public static final byte OTHER_SYMBOL = Character.OTHER_SYMBOL;

    @Native public static final byte INITIAL_QUOTE_PUNCTUATION = Character.INITIAL_QUOTE_PUNCTUATION;
    @Native public static final byte FINAL_QUOTE_PUNCTUATION = Character.FINAL_QUOTE_PUNCTUATION;

    CharacterDataImpl(long peer) {
        super(peer);
    }

    static Node getImpl(long peer) {
        return (Node)create(peer);
    }


// Attributes
    public String getData() {
        return getDataImpl(getPeer());
    }
    native static String getDataImpl(long peer);

    public void setData(String value) {
        setDataImpl(getPeer(), value);
    }
    native static void setDataImpl(long peer, String value);

    public int getLength() {
        return getLengthImpl(getPeer());
    }
    native static int getLengthImpl(long peer);

    public Element getPreviousElementSibling() {
        return ElementImpl.getImpl(getPreviousElementSiblingImpl(getPeer()));
    }
    native static long getPreviousElementSiblingImpl(long peer);

    public Element getNextElementSibling() {
        return ElementImpl.getImpl(getNextElementSiblingImpl(getPeer()));
    }
    native static long getNextElementSiblingImpl(long peer);


// Functions
    public String substringData(int offset
        , int length) throws DOMException
    {
        return substringDataImpl(getPeer()
            , offset
            , length);
    }
    native static String substringDataImpl(long peer
        , int offset
        , int length);


    public void appendData(String data)
    {
        appendDataImpl(getPeer()
            , data);
    }
    native static void appendDataImpl(long peer
        , String data);


    public void insertData(int offset
        , String data) throws DOMException
    {
        insertDataImpl(getPeer()
            , offset
            , data);
    }
    native static void insertDataImpl(long peer
        , int offset
        , String data);


    public void deleteData(int offset
        , int length) throws DOMException
    {
        deleteDataImpl(getPeer()
            , offset
            , length);
    }
    native static void deleteDataImpl(long peer
        , int offset
        , int length);


    public void replaceData(int offset
        , int length
        , String data) throws DOMException
    {
        replaceDataImpl(getPeer()
            , offset
            , length
            , data);
    }
    native static void replaceDataImpl(long peer
        , int offset
        , int length
        , String data);


    public void remove() throws DOMException
    {
        removeImpl(getPeer());
    }
    native static void removeImpl(long peer);


}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/webkit/network/Cookie.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.webkit.network;

import com.sun.javafx.logging.PlatformLogger;

import java.net.URI;
import java.text.ParseException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * An RFC 6265-compliant cookie.
 */
final class Cookie {

    private static final PlatformLogger logger =
            PlatformLogger.getLogger(Cookie.class.getName());
    private static final Pattern IP_ADDRESS_PATTERN = Pattern.compile(
            &quot;(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})&quot;);


    private final String name;
    private final String value;
    private final long expiryTime;
    private String domain;
    private String path;
    private ExtendedTime creationTime;
    private long lastAccessTime;
    private final boolean persistent;
    private boolean hostOnly;
    private final boolean secureOnly;
    private final boolean httpOnly;


    /**
     * Creates a new {@code Cookie}.
     */
    private Cookie(String name, String value, long expiryTime, String domain,
            String path, ExtendedTime creationTime, long lastAccessTime,
            boolean persistent, boolean hostOnly, boolean secureOnly,
            boolean httpOnly)
    {
        this.name = name;
        this.value = value;
        this.expiryTime = expiryTime;
        this.domain = domain;
        this.path = path;
        this.creationTime = creationTime;
        this.lastAccessTime = lastAccessTime;
        this.persistent = persistent;
        this.hostOnly = hostOnly;
        this.secureOnly = secureOnly;
        this.httpOnly = httpOnly;
    }


    /**
     * Parses a {@code Set-Cookie} header string into a {@code Cookie}
     * object.
     */
    static Cookie parse(String setCookieString, ExtendedTime currentTime) {
        logger.finest(&quot;setCookieString: [{0}]&quot;, setCookieString);

        String[] items = setCookieString.split(&quot;;&quot;, -1);

        String[] nameValuePair = items[0].split(&quot;=&quot;, 2);
        if (nameValuePair.length != 2) {
            logger.finest(&quot;Name-value pair string lacks '=', &quot;
<A NAME="11"></A>                    + &quot;ignoring cookie&quot;);
            return null;
        }
        <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#11',2,'match31-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>String name = nameValuePair[0].trim();
        String value = nameValuePair[1].trim();
        if (name.length() == 0) {
            logger.finest(&quot;Name string is empty, ignoring cookie&quot;);
            return null;
        }</B></FONT>

        Long expires = null;
        Long maxAge = null;
        String domain = null;
        String path = null;
        boolean secure = false;
        boolean httpOnly = false;

        for (int i = 1; i &lt; items.length; i++) {
            String[] terms = items[i].split(&quot;=&quot;, 2);
            String attrName = terms[0].trim();
            String attrValue = (terms.length &gt; 1 ? terms[1] : &quot;&quot;).trim();

            try {
                if (&quot;Expires&quot;.equalsIgnoreCase(attrName)) {
                    expires = parseExpires(attrValue);
                } else if (&quot;Max-Age&quot;.equalsIgnoreCase(attrName)) {
                    maxAge = parseMaxAge(attrValue, currentTime.baseTime());
                } else if (&quot;Domain&quot;.equalsIgnoreCase(attrName)) {
                    domain = parseDomain(attrValue);
                } else if (&quot;Path&quot;.equalsIgnoreCase(attrName)) {
                    path = parsePath(attrValue);
                } else if (&quot;Secure&quot;.equalsIgnoreCase(attrName)) {
                    secure = true;
                } else if (&quot;HttpOnly&quot;.equalsIgnoreCase(attrName)) {
                    httpOnly = true;
                } else {
                    logger.finest(&quot;Unknown attribute: [{0}], &quot;
                            + &quot;ignoring&quot;, attrName);
                }
            } catch (ParseException ex) {
                logger.finest(&quot;{0}, ignoring&quot;, ex.getMessage());
            }
        }

        long expiryTime;
        boolean persistent;
        if (maxAge != null) {
            persistent = true;
            expiryTime = maxAge;
        } else if (expires != null) {
            persistent = true;
            expiryTime = expires;
        } else {
            persistent = false;
            expiryTime = Long.MAX_VALUE;
        }

        if (domain == null) {
            domain = &quot;&quot;;
        }

        Cookie result = new Cookie(name, value, expiryTime, domain, path,
                currentTime, currentTime.baseTime(), persistent, false,
                secure, httpOnly);
        logger.finest(&quot;result: {0}&quot;, result);
        return result;
    }

    /**
     * Parses the value of the {@code Expires} attribute.
     */
    private static long parseExpires(String attributeValue)
        throws ParseException
    {
        try {
            return Math.max(DateParser.parse(attributeValue), 0);
        } catch (ParseException ex) {
            throw new ParseException(&quot;Error parsing Expires attribute&quot;, 0);
        }
    }

    /**
     * Parses the value of the {@code Max-Age} attribute.
     */
    private static long parseMaxAge(String attributeValue, long currentTime)
        throws ParseException
    {
        try {
            long maxAge = Long.parseLong(attributeValue);
            if (maxAge &lt;= 0) {
                return 0;
            } else {
                return maxAge &gt; (Long.MAX_VALUE - currentTime) / 1000
                        ? Long.MAX_VALUE : currentTime + maxAge * 1000;
            }
        } catch (NumberFormatException ex) {
            throw new ParseException(&quot;Error parsing Max-Age attribute&quot;, 0);
        }
    }

    /**
     * Parses the value of the {@code Domain} attribute.
     */
    private static String parseDomain(String attributeValue)
        throws ParseException
    {
        if (attributeValue.length() == 0) {
            throw new ParseException(&quot;Domain attribute is empty&quot;, 0);
        }
        if (attributeValue.startsWith(&quot;.&quot;)) {
            attributeValue = attributeValue.substring(1);
        }
        return attributeValue.toLowerCase();
    }

    /**
     * Parses the value of the {@code Path} attribute.
     */
    private static String parsePath(String attributeValue) {
        return attributeValue.startsWith(&quot;/&quot;) ? attributeValue : null;
    }


    /**
     * Returns the name of this cookie.
     */
    String getName() {
        return name;
    }

    /**
     * Returns the value of this cookie.
     */
    String getValue() {
        return value;
    }

    /**
     * Returns the expiry time of this cookie.
     */
    long getExpiryTime() {
        return expiryTime;
    }

    /**
     * Returns the domain of this cookie.
     */
    String getDomain() {
        return domain;
    }

    /**
     * Sets the domain of this cookie.
     */
    void setDomain(String domain) {
        this.domain = domain;
    }

    /**
     * Returns the path of this cookie.
     */
    String getPath() {
        return path;
    }

    /**
     * Sets the path of this cookie.
     */
    void setPath(String path) {
        this.path = path;
    }

    /**
     * Returns the creation time of this cookie.
     */
    ExtendedTime getCreationTime() {
        return creationTime;
    }

    /**
     * Sets the creation time of this cookie.
     */
    void setCreationTime(ExtendedTime creationTime) {
        this.creationTime = creationTime;
    }

    /**
     * Returns the last access time of this cookie.
     */
    long getLastAccessTime() {
        return lastAccessTime;
    }

    /**
     * Sets the last access time of this cookie.
     */
    void setLastAccessTime(long lastAccessTime) {
        this.lastAccessTime = lastAccessTime;
    }

    /**
     * Returns the persistent property of this cookie.
     */
    boolean getPersistent() {
        return persistent;
    }

    /**
     * Returns the host-only property of this cookie.
     */
    boolean getHostOnly() {
        return hostOnly;
    }

    /**
     * Sets the host-only property of this cookie.
     */
    void setHostOnly(boolean hostOnly) {
        this.hostOnly = hostOnly;
    }

    /**
     * Returns the secure-only property of this cookie.
     */
    boolean getSecureOnly() {
        return secureOnly;
    }

    /**
     * Returns the http-only property of this cookie.
     */
    boolean getHttpOnly() {
        return httpOnly;
    }

    /**
     * Determines if this cookie has expired.
     */
    boolean hasExpired() {
        return System.currentTimeMillis() &gt; expiryTime;
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Cookie) {
            Cookie cookie = (Cookie) obj;
            return equal(name, cookie.name)
                    &amp;&amp; equal(domain, cookie.domain)
                    &amp;&amp; equal(path, cookie.path);
        } else {
            return false;
        }
    }

    /**
     * Determines, in null-safe manner, if two objects are equal.
     */
    private static boolean equal(Object obj1, Object obj2) {
        return (obj1 == null &amp;&amp; obj2 == null)
                || (obj1 != null &amp;&amp; obj1.equals(obj2));
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode() {
        int hashCode = 7;
        hashCode = 53 * hashCode + hashCode(name);
        hashCode = 53 * hashCode + hashCode(domain);
        hashCode = 53 * hashCode + hashCode(path);
        return hashCode;
    }

    /**
     * Computes the hash code of an object in null safe-manner.
     */
    private static int hashCode(Object obj) {
        return obj != null ? obj.hashCode() : 0;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
        return &quot;[name=&quot; + name + &quot;, value=&quot; + value + &quot;, &quot;
                + &quot;expiryTime=&quot; + expiryTime + &quot;, domain=&quot; + domain + &quot;, &quot;
                + &quot;path=&quot; + path + &quot;, creationTime=&quot; + creationTime + &quot;, &quot;
                + &quot;lastAccessTime=&quot; + lastAccessTime + &quot;, &quot;
                + &quot;persistent=&quot; + persistent + &quot;, hostOnly=&quot; + hostOnly + &quot;, &quot;
                + &quot;secureOnly=&quot; + secureOnly + &quot;, httpOnly=&quot; + httpOnly + &quot;]&quot;;
    }

    /**
     * Determines if a domain matches another domain.
     */
    static boolean domainMatches(String domain, String cookieDomain) {
        return domain.endsWith(cookieDomain) &amp;&amp; (
                domain.length() == cookieDomain.length()
                || domain.charAt(domain.length()
                        - cookieDomain.length() - 1) == '.'
                &amp;&amp; !isIpAddress(domain));
    }

    /**
     * Determines if a hostname is an IP address.
     */
    private static boolean isIpAddress(String hostname) {
        Matcher matcher = IP_ADDRESS_PATTERN.matcher(hostname);
        if (!matcher.matches()) {
            return false;
        }
        for (int i = 1; i &lt;= matcher.groupCount(); i++) {
            if (Integer.parseInt(matcher.group(i)) &gt; 255) {
                return false;
            }
        }
        return true;
    }

    /**
     * Computes the default path for a given URI.
     */
    static String defaultPath(URI uri) {
        String path = uri.getPath();
        if (path == null || !path.startsWith(&quot;/&quot;)) {
            return &quot;/&quot;;
        }
        path = path.substring(0, path.lastIndexOf(&quot;/&quot;));
        if (path.length() == 0) {
            return &quot;/&quot;;
        }
        return path;
    }

    /**
     * Determines if a path matches another path.
     */
    static boolean pathMatches(String path, String cookiePath) {
        return path != null &amp;&amp; path.startsWith(cookiePath) &amp;&amp; (
                path.length() == cookiePath.length()
                || cookiePath.endsWith(&quot;/&quot;)
                || path.charAt(cookiePath.length()) == '/');
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/javafx/scene/web/WebEngine.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.web;

import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.scene.web.Debugger;
import com.sun.javafx.scene.web.Printable;
import com.sun.javafx.tk.TKPulseListener;
import com.sun.javafx.tk.Toolkit;
import com.sun.javafx.webkit.*;
import com.sun.javafx.webkit.prism.PrismGraphicsManager;
import com.sun.javafx.webkit.prism.PrismInvoker;
import com.sun.javafx.webkit.prism.theme.PrismRenderer;
import com.sun.javafx.webkit.theme.RenderThemeImpl;
import com.sun.javafx.webkit.theme.Renderer;
import com.sun.webkit.*;
import com.sun.webkit.graphics.WCGraphicsManager;
import com.sun.webkit.network.URLs;
import com.sun.webkit.network.Util;
import javafx.animation.AnimationTimer;
import javafx.application.Platform;
import javafx.beans.InvalidationListener;
import javafx.beans.property.*;
import javafx.concurrent.Worker;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.geometry.Rectangle2D;
import javafx.print.PageLayout;
import javafx.print.PrinterJob;
import javafx.scene.Node;
import javafx.util.Callback;
import org.w3c.dom.Document;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.IOException;
import static java.lang.String.format;
import java.lang.ref.WeakReference;
import java.net.MalformedURLException;
import java.net.URLConnection;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.PosixFilePermissions;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.Objects;

import static com.sun.webkit.LoadListenerClient.*;

/**
 * {@code WebEngine} is a non-visual object capable of managing one Web page
 * at a time. It loads Web pages, creates their document models, applies
 * styles as necessary, and runs JavaScript on pages. It provides access
 * to the document model of the current page, and enables two-way
 * communication between a Java application and JavaScript code of the page.
 *
 * &lt;p&gt;&lt;b&gt;Loading Web Pages&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;The {@code WebEngine} class provides two ways to load content into a
 * {@code WebEngine} object:
 * &lt;ul&gt;
 * &lt;li&gt;From an arbitrary URL using the {@link #load} method. This method uses
 *     the {@code java.net} package for network access and protocol handling.
 * &lt;li&gt;From an in-memory String using the
 *     {@link #loadContent(java.lang.String, java.lang.String)} and
 *     {@link #loadContent(java.lang.String)} methods.
 * &lt;/ul&gt;
 * &lt;p&gt;Loading always happens on a background thread. Methods that initiate
 * loading return immediately after scheduling a background job. To track
 * progress and/or cancel a job, use the {@link javafx.concurrent.Worker}
 * instance available from the {@link #getLoadWorker} method.
 *
 * &lt;p&gt;The following example changes the stage title when loading completes
 * successfully:
 * &lt;pre&gt;{@code
    import javafx.concurrent.Worker.State;
    final Stage stage;
    webEngine.getLoadWorker().stateProperty().addListener(
        new ChangeListener&lt;State&gt;() {
            public void changed(ObservableValue ov, State oldState, State newState) {
                if (newState == State.SUCCEEDED) {
                    stage.setTitle(webEngine.getLocation());
                }
            }
        });
    webEngine.load(&quot;http://javafx.com&quot;);
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;User Interface Callbacks&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;A number of user interface callbacks may be registered with a
 * {@code WebEngine} object. These callbacks are invoked when a script running
 * on the page requests a user interface operation to be performed, for
 * example, opens a popup window or changes status text. A {@code WebEngine}
 * object cannot handle such requests internally, so it passes the request to
 * the corresponding callbacks. If no callback is defined for a specific
 * operation, the request is silently ignored.
 *
 * &lt;p&gt;The table below shows JavaScript user interface methods and properties
 * with their corresponding {@code WebEngine} callbacks:
 * &lt;table border=&quot;1&quot;&gt;
 * &lt;caption&gt;JavaScript Callback Table&lt;/caption&gt;
 * &lt;tr&gt;
 *     &lt;th scope=&quot;col&quot;&gt;JavaScript method/property&lt;/th&gt;
 *     &lt;th scope=&quot;col&quot;&gt;WebEngine callback&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.alert()}&lt;/th&gt;&lt;td&gt;{@code onAlert}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.confirm()}&lt;/th&gt;&lt;td&gt;{@code confirmHandler}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.open()}&lt;/th&gt;&lt;td&gt;{@code createPopupHandler}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.open()} and&lt;br&gt;
 *         {@code window.close()}&lt;/th&gt;&lt;td&gt;{@code onVisibilityChanged}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.prompt()}&lt;/th&gt;&lt;td&gt;{@code promptHandler}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Setting {@code window.status}&lt;/th&gt;&lt;td&gt;{@code onStatusChanged}&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Setting any of the following:&lt;br&gt;
 *         {@code window.innerWidth}, {@code window.innerHeight},&lt;br&gt;
 *         {@code window.outerWidth}, {@code window.outerHeight},&lt;br&gt;
 *         {@code window.screenX}, {@code window.screenY},&lt;br&gt;
 *         {@code window.screenLeft}, {@code window.screenTop}&lt;/th&gt;
 *         &lt;td&gt;{@code onResized}&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;p&gt;The following example shows a callback that resizes a browser window:
 * &lt;pre&gt;{@code
    Stage stage;
    webEngine.setOnResized(
        new EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;() {
            public void handle(WebEvent&lt;Rectangle2D&gt; ev) {
                Rectangle2D r = ev.getData();
                stage.setWidth(r.getWidth());
                stage.setHeight(r.getHeight());
            }
        });
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;Access to Document Model&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;The {@code WebEngine} objects create and manage a Document Object Model
 * (DOM) for their Web pages. The model can be accessed and modified using
 * Java DOM Core classes. The {@link #getDocument()} method provides access
 * to the root of the model. Additionally DOM Event specification is supported
 * to define event handlers in Java code.
 *
 * &lt;p&gt;The following example attaches a Java event listener to an element of
 * a Web page. Clicking on the element causes the application to exit:
 * &lt;pre&gt;{@code
    EventListener listener = new EventListener() {
        public void handleEvent(Event ev) {
            Platform.exit();
        }
    };

    Document doc = webEngine.getDocument();
    Element el = doc.getElementById(&quot;exit-app&quot;);
    ((EventTarget) el).addEventListener(&quot;click&quot;, listener, false);
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;Evaluating JavaScript expressions&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;It is possible to execute arbitrary JavaScript code in the context of
 * the current page using the {@link #executeScript} method. For example:
 * &lt;pre&gt;{@code
    webEngine.executeScript(&quot;history.back()&quot;);
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;The execution result is returned to the caller,
 * as described in the next section.
 *
 * &lt;p&gt;&lt;b&gt;Mapping JavaScript values to Java objects&lt;/b&gt;&lt;/p&gt;
 *
 * JavaScript values are represented using the obvious Java classes:
 * null becomes Java null; a boolean becomes a {@code java.lang.Boolean};
 * and a string becomes a {@code java.lang.String}.
 * A number can be {@code java.lang.Double} or a {@code java.lang.Integer},
 * depending.
 * The undefined value maps to a specific unique String
 * object whose value is {@code &quot;undefined&quot;}.
 * &lt;p&gt;
 * If the result is a
 * JavaScript object, it is wrapped as an instance of the
 * {@link netscape.javascript.JSObject} class.
 * (As a special case, if the JavaScript object is
 * a {@code JavaRuntimeObject} as discussed in the next section,
 * then the original Java object is extracted instead.)
 * The {@code JSObject} class is a proxy that provides access to
 * methods and properties of its underlying JavaScript object.
 * The most commonly used {@code JSObject} methods are
 * {@link netscape.javascript.JSObject#getMember getMember}
 * (to read a named property),
 * {@link netscape.javascript.JSObject#setMember setMember}
 * (to set or define a property),
 * and {@link netscape.javascript.JSObject#call call}
 * (to call a function-valued property).
 * &lt;p&gt;
 * A DOM {@code Node} is mapped to an object that both extends
 * {@code JSObject} and implements the appropriate DOM interfaces.
 * To get a {@code JSObject} object for a {@code Node} just do a cast:
 * &lt;pre&gt;
 * JSObject jdoc = (JSObject) webEngine.getDocument();
 * &lt;/pre&gt;
 * &lt;p&gt;
 * In some cases the context provides a specific Java type that guides
 * the conversion.
 * For example if setting a Java {@code String} field from a JavaScript
 * expression, then the JavaScript value is converted to a string.
 *
 * &lt;p&gt;&lt;b&gt;Mapping Java objects to JavaScript values&lt;/b&gt;&lt;/p&gt;
 *
 * The arguments of the {@code JSObject} methods {@code setMember} and
 * {@code call} pass Java objects to the JavaScript environment.
 * This is roughly the inverse of the JavaScript-to-Java mapping
 * described above:
 * Java {@code String},  {@code Number}, or {@code Boolean} objects
 * are converted to the obvious JavaScript values. A  {@code JSObject}
 * object is converted to the original wrapped JavaScript object.
 * Otherwise a {@code JavaRuntimeObject} is created.  This is
 * a JavaScript object that acts as a proxy for the Java object,
 * in that accessing properties of the {@code JavaRuntimeObject}
 * causes the Java field or method with the same name to be accessed.
 * &lt;p&gt; Note that the Java objects bound using
 * {@link netscape.javascript.JSObject#setMember JSObject.setMember},
 * {@link netscape.javascript.JSObject#setSlot JSObject.setSlot}, and
 * {@link netscape.javascript.JSObject#call JSObject.call}
 * are implemented using weak references. This means that the Java object
 * can be garbage collected, causing subsequent accesses to the JavaScript
 * objects to have no effect.
 *
 * &lt;p&gt;&lt;b&gt;Calling back to Java from JavaScript&lt;/b&gt;&lt;/p&gt;
 *
 * &lt;p&gt;The {@link netscape.javascript.JSObject#setMember JSObject.setMember}
 * method is useful to enable upcalls from JavaScript
 * into Java code, as illustrated by the following example. The Java code
 * establishes a new JavaScript object named {@code app}. This object has one
 * public member, the method {@code exit}.
 * &lt;pre&gt;&lt;code&gt;
public class JavaApplication {
    public void exit() {
        Platform.exit();
    }
}
...
JavaApplication javaApp = new JavaApplication();
JSObject window = (JSObject) webEngine.executeScript(&quot;window&quot;);
window.setMember(&quot;app&quot;, javaApp);
 * &lt;/code&gt;&lt;/pre&gt;
 * You can then refer to the object and the method from your HTML page:
 * &lt;pre&gt;{@code
    &lt;a href=&quot;&quot; onclick=&quot;app.exit()&quot;&gt;Click here to exit application&lt;/a&gt;
 * }&lt;/pre&gt;
 * &lt;p&gt;When a user clicks the link the application is closed.
 * &lt;p&gt;
 * Note that in the above example, the application holds a reference
 * to the {@code JavaApplication} instance. This is required for the callback
 * from JavaScript to execute the desired method.
 * &lt;p&gt; In the following example, the application does not hold a reference
 * to the Java object:
 * &lt;pre&gt;&lt;code&gt;
 * JSObject window = (JSObject) webEngine.executeScript(&quot;window&quot;);
 * window.setMember(&quot;app&quot;, new JavaApplication());
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt; In this case, since the property value is a local object, {@code &quot;new JavaApplication()&quot;},
 * the value may be garbage collected in next GC cycle.
 * &lt;p&gt;
 * When a user clicks the link, it does not guarantee to execute the callback method {@code exit}.
 * &lt;p&gt;
 * If there are multiple Java methods with the given name,
 * then the engine selects one matching the number of parameters
 * in the call.  (Varargs are not handled.) An unspecified one is
 * chosen if there are multiple ones with the correct number of parameters.
 * &lt;p&gt;
 * You can pick a specific overloaded method by listing the
 * parameter types in an &quot;extended method name&quot;, which has the
 * form &lt;code&gt;&quot;&lt;var&gt;method_name&lt;/var&gt;(&lt;var&gt;param_type1&lt;/var&gt;,...,&lt;var&gt;param_typen&lt;/var&gt;)&quot;&lt;/code&gt;.  Typically you'd write the JavaScript expression:
 * &lt;pre&gt;
 * &lt;code&gt;&lt;var&gt;receiver&lt;/var&gt;[&quot;&lt;var&gt;method_name&lt;/var&gt;(&lt;var&gt;param_type1&lt;/var&gt;,...,&lt;var&gt;param_typeN&lt;/var&gt;)&quot;](&lt;var&gt;arg1&lt;/var&gt;,...,&lt;var&gt;argN&lt;/var&gt;)&lt;/code&gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * The Java class and method must both be declared public.
 * &lt;/p&gt;
 *
 * &lt;p&gt;&lt;b&gt;Deploying an Application as a Module&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;
 * If any Java class passed to JavaScript is in a named module, then it must
 * be reflectively accessible to the {@code javafx.web} module.
 * A class is reflectively accessible if the module
 * {@link Module#isOpen(String,Module) opens} the containing package to at
 * least the {@code javafx.web} module.
 * Otherwise, the method will not be called, and no error or
 * warning will be produced.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For example, if {@code com.foo.MyClass} is in the {@code foo.app} module,
 * the {@code module-info.java} might
 * look like this:
 * &lt;/p&gt;
 *
&lt;pre&gt;{@code module foo.app {
    opens com.foo to javafx.web;
}}&lt;/pre&gt;
 *
 * &lt;p&gt;
 * Alternatively, a class is reflectively accessible if the module
 * {@link Module#isExported(String) exports} the containing package
 * unconditionally.
 * &lt;/p&gt;
 *
 * &lt;p&gt;&lt;b&gt;Threading&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;{@code WebEngine} objects must be created and accessed solely from the
 * JavaFX Application thread. This rule also applies to any DOM and JavaScript
 * objects obtained from the {@code WebEngine} object.
 * @since JavaFX 2.0
 */
final public class WebEngine {
    static {
        Accessor.setPageAccessor(w -&gt; w == null ? null : w.getPage());

        Invoker.setInvoker(new PrismInvoker());
        Renderer.setRenderer(new PrismRenderer());
        WCGraphicsManager.setGraphicsManager(new PrismGraphicsManager());
        CursorManager.setCursorManager(new CursorManagerImpl());
        com.sun.webkit.EventLoop.setEventLoop(new EventLoopImpl());
        ThemeClient.setDefaultRenderTheme(new RenderThemeImpl());
        Utilities.setUtilities(new UtilitiesImpl());
    }

    private static final PlatformLogger logger =
            PlatformLogger.getLogger(WebEngine.class.getName());

    /**
     * The number of instances of this class.
     * Used to start and stop the pulse timer.
     */
    private static int instanceCount = 0;

    /**
     * The node associated with this engine. There is a one-to-one correspondence
     * between the WebView and its WebEngine (although not all WebEngines have
     * a WebView, every WebView has one and only one WebEngine).
     */
    private final ObjectProperty&lt;WebView&gt; view = new SimpleObjectProperty&lt;WebView&gt;(this, &quot;view&quot;);

    /**
     * The Worker which shows progress of the web engine as it loads pages.
     */
    private final LoadWorker loadWorker = new LoadWorker();

    /**
     * The object that provides interaction with the native webkit core.
     */
    private final WebPage page;

    private final SelfDisposer disposer;

    private final DebuggerImpl debugger = new DebuggerImpl();

    private boolean userDataDirectoryApplied = false;


    /**
     * Returns a {@link javafx.concurrent.Worker} object that can be used to
     * track loading progress.
     *
     * @return the {@code Worker} object
     */
    public final Worker&lt;Void&gt; getLoadWorker() {
        return loadWorker;
    }


    /*
     * The final document. This may be null if no document has been loaded.
     */
    private final DocumentProperty document = new DocumentProperty();

    public final Document getDocument() { return document.getValue(); }

    /**
     * Document object for the current Web page. The value is {@code null}
     * if the Web page failed to load.
     *
     * @return the document property
     */
    public final ReadOnlyObjectProperty&lt;Document&gt; documentProperty() {
        return document;
    }


    /*
     * The location of the current page. This may return null.
     */
    private final ReadOnlyStringWrapper location = new ReadOnlyStringWrapper(this, &quot;location&quot;);

    public final String getLocation() { return location.getValue(); }

    /**
     * URL of the current Web page. If the current page has no URL,
     * the value is an empty String.
     *
     * @return the location property
     */
    public final ReadOnlyStringProperty locationProperty() { return location.getReadOnlyProperty(); }

    private void updateLocation(String value) {
        this.location.set(value);
        this.document.invalidate(false);
        this.title.set(null);
    }


    /*
     * The page title.
     */
    private final ReadOnlyStringWrapper title = new ReadOnlyStringWrapper(this, &quot;title&quot;);

    public final String getTitle() { return title.getValue(); }

    /**
     * Title of the current Web page. If the current page has no title,
     * the value is {@code null}.
     *
     * @return the title property
     */
    public final ReadOnlyStringProperty titleProperty() { return title.getReadOnlyProperty(); }

    private void updateTitle() {
        title.set(page.getTitle(page.getMainFrame()));
    }

    //
    // Settings

    /**
     * Specifies whether JavaScript execution is enabled.
     *
     * @defaultValue true
     * @since JavaFX 2.2
     */
    private BooleanProperty javaScriptEnabled;

    public final void setJavaScriptEnabled(boolean value) {
        javaScriptEnabledProperty().set(value);
    }

    public final boolean isJavaScriptEnabled() {
        return javaScriptEnabled == null ? true : javaScriptEnabled.get();
    }

    public final BooleanProperty javaScriptEnabledProperty() {
        if (javaScriptEnabled == null) {
            javaScriptEnabled = new BooleanPropertyBase(true) {
                @Override public void invalidated() {
                    checkThread();
                    page.setJavaScriptEnabled(get());
                }

                @Override public Object getBean() {
                    return WebEngine.this;
                }

                @Override public String getName() {
                    return &quot;javaScriptEnabled&quot;;
                }
            };
        }
        return javaScriptEnabled;
    }

    /**
     * Location of the user stylesheet as a string URL.
     *
     * &lt;p&gt;This should be a local URL, i.e. either {@code 'data:'},
     * {@code 'file:'}, or {@code 'jar:'}. Remote URLs are not allowed
     * for security reasons.
     *
     * @defaultValue null
     * @since JavaFX 2.2
     */
    private StringProperty userStyleSheetLocation;

    public final void setUserStyleSheetLocation(String value) {
        userStyleSheetLocationProperty().set(value);
    }

    public final String getUserStyleSheetLocation() {
        return userStyleSheetLocation == null ? null : userStyleSheetLocation.get();
    }

    private byte[] readFully(BufferedInputStream in) throws IOException {
        final int BUF_SIZE = 4096;
        int outSize = 0;
        final List&lt;byte[]&gt; outList = new ArrayList&lt;&gt;();
        byte[] buffer = new byte[BUF_SIZE];

        while (true) {
            int nBytes = in.read(buffer);
            if (nBytes &lt; 0) break;

            byte[] chunk;
            if (nBytes == buffer.length) {
                chunk = buffer;
                buffer = new byte[BUF_SIZE];
            } else {
                chunk = new byte[nBytes];
                System.arraycopy(buffer, 0, chunk, 0, nBytes);
            }
            outList.add(chunk);
            outSize += nBytes;
        }

        final byte[] out = new byte[outSize];
        int outPos = 0;
        for (byte[] chunk : outList) {
            System.arraycopy(chunk, 0, out, outPos, chunk.length);
            outPos += chunk.length;
        }

        return out;
    }

    public final StringProperty userStyleSheetLocationProperty() {
        if (userStyleSheetLocation == null) {
            userStyleSheetLocation = new StringPropertyBase(null) {
                private final static String DATA_PREFIX = &quot;data:text/css;charset=utf-8;base64,&quot;;

                @Override public void invalidated() {
                    checkThread();
                    String url = get();
                    String dataUrl;
                    if (url == null || url.length() &lt;= 0) {
                        dataUrl = null;
                    } else if (url.startsWith(DATA_PREFIX)) {
                        dataUrl = url;
                    } else if (url.startsWith(&quot;file:&quot;) ||
                               url.startsWith(&quot;jar:&quot;)  ||
                               url.startsWith(&quot;data:&quot;))
                    {
                        try {
                            URLConnection conn = URLs.newURL(url).openConnection();
                            conn.connect();

                            BufferedInputStream in =
                                    new BufferedInputStream(conn.getInputStream());
                            byte[] inBytes = readFully(in);
                            String out = Base64.getMimeEncoder().encodeToString(inBytes);
                            dataUrl = DATA_PREFIX + out;
                        } catch (IOException e) {
                            throw new RuntimeException(e);
                        }
                    } else {
                        throw new IllegalArgumentException(&quot;Invalid stylesheet URL&quot;);
                    }
                    page.setUserStyleSheetLocation(dataUrl);
                }

                @Override public Object getBean() {
                    return WebEngine.this;
                }

                @Override public String getName() {
                    return &quot;userStyleSheetLocation&quot;;
                }
            };
        }
        return userStyleSheetLocation;
    }

    /**
     * Specifies the directory to be used by this {@code WebEngine}
     * to store local user data.
     *
     * &lt;p&gt;If the value of this property is not {@code null},
     * the {@code WebEngine} will attempt to store local user data
     * in the respective directory.
     * If the value of this property is {@code null},
     * the {@code WebEngine} will attempt to store local user data
     * in an automatically selected system-dependent user- and
     * application-specific directory.
     *
     * &lt;p&gt;When a {@code WebEngine} is about to start loading a web
     * page or executing a script for the first time, it checks whether
     * it can actually use the directory specified by this property.
     * If the check fails for some reason, the {@code WebEngine} invokes
     * the {@link WebEngine#onErrorProperty WebEngine.onError} event handler,
     * if any, with a {@link WebErrorEvent} describing the reason.
     * If the invoked event handler modifies the {@code userDataDirectory}
     * property, the {@code WebEngine} retries with the new value as soon
     * as the handler returns. If the handler does not modify the
     * {@code userDataDirectory} property (which is the default),
     * the {@code WebEngine} continues without local user data.
     *
     * &lt;p&gt;Once the {@code WebEngine} has started loading a web page or
     * executing a script, changes made to this property have no effect
     * on where the {@code WebEngine} stores or will store local user
     * data.
     *
     * &lt;p&gt;Currently, the directory specified by this property is used
     * only to store the data that backs the {@code window.localStorage}
     * objects. In the future, more types of data can be added.
     *
     * @defaultValue {@code null}
     * @since JavaFX 8.0
     */
    private final ObjectProperty&lt;File&gt; userDataDirectory =
            new SimpleObjectProperty&lt;&gt;(this, &quot;userDataDirectory&quot;);

    public final File getUserDataDirectory() {
        return userDataDirectory.get();
    }

    public final void setUserDataDirectory(File value) {
        userDataDirectory.set(value);
    }

    public final ObjectProperty&lt;File&gt; userDataDirectoryProperty() {
        return userDataDirectory;
    }

    /**
     * Specifies user agent ID string. This string is the value of the
     * {@code User-Agent} HTTP header.
     *
     * @defaultValue system dependent
     * @since JavaFX 8.0
     */
    private StringProperty userAgent;

    public final void setUserAgent(String value) {
        userAgentProperty().set(value);
    }

    public final String getUserAgent() {
        return userAgent == null ? page.getUserAgent() : userAgent.get();
    }

    public final StringProperty userAgentProperty() {
        if (userAgent == null) {
            userAgent = new StringPropertyBase(page.getUserAgent()) {
                @Override public void invalidated() {
                    checkThread();
                    page.setUserAgent(get());
                }

                @Override public Object getBean() {
                    return WebEngine.this;
                }

                @Override public String getName() {
                    return &quot;userAgent&quot;;
                }
            };
        }
        return userAgent;
    }

    private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onAlert
            = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt;(this, &quot;onAlert&quot;);

    public final EventHandler&lt;WebEvent&lt;String&gt;&gt; getOnAlert() { return onAlert.get(); }

    public final void setOnAlert(EventHandler&lt;WebEvent&lt;String&gt;&gt; handler) { onAlert.set(handler); }

    /**
     * JavaScript {@code alert} handler property. This handler is invoked
     * when a script running on the Web page calls the {@code alert} function.
     * @return the onAlert property
     */
    public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onAlertProperty() { return onAlert; }


    private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onStatusChanged
            = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt;(this, &quot;onStatusChanged&quot;);

    public final EventHandler&lt;WebEvent&lt;String&gt;&gt; getOnStatusChanged() { return onStatusChanged.get(); }

    public final void setOnStatusChanged(EventHandler&lt;WebEvent&lt;String&gt;&gt; handler) { onStatusChanged.set(handler); }

    /**
     * JavaScript status handler property. This handler is invoked when
     * a script running on the Web page sets {@code window.status} property.
     * @return the onStatusChanged property
     */
    public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onStatusChangedProperty() { return onStatusChanged; }


    private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt; onResized
            = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt;(this, &quot;onResized&quot;);

    public final EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt; getOnResized() { return onResized.get(); }

    public final void setOnResized(EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt; handler) { onResized.set(handler); }

    /**
     * JavaScript window resize handler property. This handler is invoked
     * when a script running on the Web page moves or resizes the
     * {@code window} object.
     * @return the onResized property
     */
    public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt; onResizedProperty() { return onResized; }


    private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt; onVisibilityChanged
            = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt;(this, &quot;onVisibilityChanged&quot;);

    public final EventHandler&lt;WebEvent&lt;Boolean&gt;&gt; getOnVisibilityChanged() { return onVisibilityChanged.get(); }

    public final void setOnVisibilityChanged(EventHandler&lt;WebEvent&lt;Boolean&gt;&gt; handler) { onVisibilityChanged.set(handler); }

    /**
     * JavaScript window visibility handler property. This handler is invoked
     * when a script running on the Web page changes visibility of the
     * {@code window} object.
     * @return the onVisibilityChanged property
     */
    public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt; onVisibilityChangedProperty() { return onVisibilityChanged; }


    private final ObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt; createPopupHandler
            = new SimpleObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt;(this, &quot;createPopupHandler&quot;,
            p -&gt; WebEngine.this);

    public final Callback&lt;PopupFeatures, WebEngine&gt; getCreatePopupHandler() { return createPopupHandler.get(); }

    public final void setCreatePopupHandler(Callback&lt;PopupFeatures, WebEngine&gt; handler) { createPopupHandler.set(handler); }

    /**
     * JavaScript popup handler property. This handler is invoked when a script
     * running on the Web page requests a popup to be created.
     * &lt;p&gt;To satisfy this request a handler may create a new {@code WebEngine},
     * attach a visibility handler and optionally a resize handler, and return
     * the newly created engine. To block the popup, a handler should return
     * {@code null}.
     * &lt;p&gt;By default, a popup handler is installed that opens popups in this
     * {@code WebEngine}.
     *
     * @return the createPopupHandler property
     *
     * @see PopupFeatures
     */
    public final ObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt; createPopupHandlerProperty() { return createPopupHandler; }


    private final ObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt; confirmHandler
            = new SimpleObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt;(this, &quot;confirmHandler&quot;);

    public final Callback&lt;String, Boolean&gt; getConfirmHandler() { return confirmHandler.get(); }

    public final void setConfirmHandler(Callback&lt;String, Boolean&gt; handler) { confirmHandler.set(handler); }

    /**
     * JavaScript {@code confirm} handler property. This handler is invoked
     * when a script running on the Web page calls the {@code confirm} function.
     * &lt;p&gt;An implementation may display a dialog box with Yes and No options,
     * and return the user's choice.
     *
     * @return the confirmHandler property
     */
    public final ObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt; confirmHandlerProperty() { return confirmHandler; }


    private final ObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt; promptHandler
            = new SimpleObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt;(this, &quot;promptHandler&quot;);

    public final Callback&lt;PromptData, String&gt; getPromptHandler() { return promptHandler.get(); }

    public final void setPromptHandler(Callback&lt;PromptData, String&gt; handler) { promptHandler.set(handler); }

    /**
     * JavaScript {@code prompt} handler property. This handler is invoked
     * when a script running on the Web page calls the {@code prompt} function.
     * &lt;p&gt;An implementation may display a dialog box with an text field,
     * and return the user's input.
     *
     * @return the promptHandler property
     * @see PromptData
     */
    public final ObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt; promptHandlerProperty() { return promptHandler; }

    /**
     * The event handler called when an error occurs.
     *
     * @defaultValue {@code null}
     * @since JavaFX 8.0
     */
    private final ObjectProperty&lt;EventHandler&lt;WebErrorEvent&gt;&gt; onError =
            new SimpleObjectProperty&lt;&gt;(this, &quot;onError&quot;);

    public final EventHandler&lt;WebErrorEvent&gt; getOnError() {
        return onError.get();
    }

    public final void setOnError(EventHandler&lt;WebErrorEvent&gt; handler) {
        onError.set(handler);
    }

    public final ObjectProperty&lt;EventHandler&lt;WebErrorEvent&gt;&gt; onErrorProperty() {
        return onError;
    }


    /**
     * Creates a new engine.
     */
    public WebEngine() {
        this(null, false);
    }

    /**
     * Creates a new engine and loads a Web page into it.
     *
     * @param url the URL of the web page to load
     */
    public WebEngine(String url) {
        this(url, true);
    }

    private WebEngine(String url, boolean callLoad) {
        checkThread();
        Accessor accessor = new AccessorImpl(this);
        page = new WebPage(
            new WebPageClientImpl(accessor),
            new UIClientImpl(accessor),
            null,
            new InspectorClientImpl(this),
            new ThemeClientImpl(accessor),
            false);
        page.addLoadListenerClient(new PageLoadListener(this));

        history = new WebHistory(page);

        disposer = new SelfDisposer(page);
        Disposer.addRecord(this, disposer);

        if (callLoad) {
            load(url);
        }

        if (instanceCount == 0 &amp;&amp;
            Timer.getMode() == Timer.Mode.PLATFORM_TICKS)
        {
            PulseTimer.start();
        }
        instanceCount++;
    }

    /**
     * Loads a Web page into this engine. This method starts asynchronous
     * loading and returns immediately.
     * @param url URL of the web page to load
     */
    public void load(String url) {
        checkThread();
        loadWorker.cancelAndReset();

        if (url == null || url.equals(&quot;&quot;) || url.equals(&quot;about:blank&quot;)) {
            url = &quot;&quot;;
        } else {
            // verify and, if possible, adjust the url on the Java
            // side, otherwise it may crash native code
            try {
                url = Util.adjustUrlForWebKit(url);
            } catch (MalformedURLException e) {
                loadWorker.dispatchLoadEvent(getMainFrame(),
                        PAGE_STARTED, url, null, 0.0, 0);
                loadWorker.dispatchLoadEvent(getMainFrame(),
                        LOAD_FAILED, url, null, 0.0, MALFORMED_URL);
<A NAME="30"></A>                return;
            }
        }
        <FONT color="#f9966b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#30',2,'match31-top.html#30',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>applyUserDataDirectory();
        page.open(page.getMainFrame(), url);
    }

    /**
     * Loads the given HTML content directly. This method is useful when you have an HTML
     * String composed in memory, or loaded from some system which cannot be reached via
     * a URL (for example, the HTML text may have come from a database). As with
     * {@link #load(String)}, this method is asynchronous.
     *
     * @param content the HTML content to load
     */
    public void loadContent(String content) {
        loadContent(content, &quot;text/html&quot;);
    }

    /**
     * Loads the given content directly. This method is useful when you have content
     * composed in memory, or loaded from some system which cannot be reached via
     * a URL (for example, the SVG text may have come from a database). As with
     * {@link #load(String)}, this method is asynchronous. This method also allows you to
     * specify the content type of the string being loaded, and so may optionally support
     * other types besides just HTML.
     *
     * @param content the HTML content to load
     * @param contentType the type of content to load
     */
    public void loadContent(String content, String contentType) {
        checkThread();
        loadWorker.cancelAndReset</B></FONT>();
        applyUserDataDirectory();
        page.load(page.getMainFrame(), content, contentType);
    }

    /**
     * Reloads the current page, whether loaded from URL or directly from a String in
     * one of the {@code loadContent} methods.
     */
    public void reload() {
        // TODO what happens if this is called while currently loading a page?
        checkThread();
        page.refresh(page.getMainFrame());
    }

    private final WebHistory history;

    /**
     * Returns the session history object.
     *
     * @return history object
     * @since JavaFX 2.2
     */
    public WebHistory getHistory() {
        return history;
    }

    /**
     * Executes a script in the context of the current page.
     *
     * @param script the script
     * @return execution result, converted to a Java object using the following
     * rules:
     * &lt;ul&gt;
     * &lt;li&gt;JavaScript Int32 is converted to {@code java.lang.Integer}
     * &lt;li&gt;Other JavaScript numbers to {@code java.lang.Double}
     * &lt;li&gt;JavaScript string to {@code java.lang.String}
     * &lt;li&gt;JavaScript boolean to {@code java.lang.Boolean}
     * &lt;li&gt;JavaScript {@code null} to {@code null}
     * &lt;li&gt;Most JavaScript objects get wrapped as
     *     {@code netscape.javascript.JSObject}
     * &lt;li&gt;JavaScript JSNode objects get mapped to instances of
     *     {@code netscape.javascript.JSObject}, that also implement
     *     {@code org.w3c.dom.Node}
     * &lt;li&gt;A special case is the JavaScript class {@code JavaRuntimeObject}
     *     which is used to wrap a Java object as a JavaScript value - in this
     *     case we just extract the original Java value.
     * &lt;/ul&gt;
     */
    public Object executeScript(String script) {
        checkThread();
        applyUserDataDirectory();
        return page.executeScript(page.getMainFrame(), script);
    }

    private long getMainFrame() {
        return page.getMainFrame();
    }

    WebPage getPage() {
        return page;
    }

    void setView(WebView view) {
        this.view.setValue(view);
    }

    private void stop() {
        checkThread();
        page.stop(page.getMainFrame());
    }

    private void applyUserDataDirectory() {
        if (userDataDirectoryApplied) {
            return;
        }
        userDataDirectoryApplied = true;
        File nominalUserDataDir = getUserDataDirectory();
        while (true) {
            File userDataDir;
            String displayString;
            if (nominalUserDataDir == null) {
                userDataDir = defaultUserDataDirectory();
                displayString = format(&quot;null (%s)&quot;, userDataDir);
            } else {
                userDataDir = nominalUserDataDir;
                displayString = userDataDir.toString();
            }
            logger.fine(&quot;Trying to apply user data directory [{0}]&quot;, displayString);
            String errorMessage;
            EventType&lt;WebErrorEvent&gt; errorType;
            Throwable error;
            try {
                userDataDir = DirectoryLock.canonicalize(userDataDir);
                File localStorageDir = new File(userDataDir, &quot;localstorage&quot;);
                File[] dirs = new File[] {
                    userDataDir,
                    localStorageDir,
                };
                for (File dir : dirs) {
                    createDirectories(dir);
                    // Additional security check to make sure the caller
                    // has permission to write to the target directory
                    File test = new File(dir, &quot;.test&quot;);
                    if (test.createNewFile()) {
                        test.delete();
                    }
                }
                disposer.userDataDirectoryLock = new DirectoryLock(userDataDir);

                page.setLocalStorageDatabasePath(localStorageDir.getPath());
                page.setLocalStorageEnabled(true);

                logger.fine(&quot;User data directory [{0}] has &quot;
                        + &quot;been applied successfully&quot;, displayString);
                return;

            } catch (DirectoryLock.DirectoryAlreadyInUseException ex) {
                errorMessage = &quot;User data directory [%s] is already in use&quot;;
                errorType = WebErrorEvent.USER_DATA_DIRECTORY_ALREADY_IN_USE;
                error = ex;
            } catch (IOException ex) {
                errorMessage = &quot;An I/O error occurred while setting up &quot;
                        + &quot;user data directory [%s]&quot;;
                errorType = WebErrorEvent.USER_DATA_DIRECTORY_IO_ERROR;
                error = ex;
            } catch (SecurityException ex) {
                errorMessage = &quot;A security error occurred while setting up &quot;
                        + &quot;user data directory [%s]&quot;;
                errorType = WebErrorEvent.USER_DATA_DIRECTORY_SECURITY_ERROR;
                error = ex;
            }

            errorMessage = format(errorMessage, displayString);
            logger.fine(&quot;{0}, calling error handler&quot;, errorMessage);
            File oldNominalUserDataDir = nominalUserDataDir;
            fireError(errorType, errorMessage, error);
            nominalUserDataDir = getUserDataDirectory();
            if (Objects.equals(nominalUserDataDir, oldNominalUserDataDir)) {
                logger.fine(&quot;Error handler did not modify user data directory, &quot;
                        + &quot;continuing without user data directory&quot;);
                return;
            } else {
                logger.fine(&quot;Error handler has set user data directory to [{0}], &quot;
                        + &quot;retrying&quot;, nominalUserDataDir);
                continue;
            }
        }
    }

    private static File defaultUserDataDirectory() {
        return new File(
                com.sun.glass.ui.Application.GetApplication()
                        .getDataDirectory(),
                &quot;webview&quot;);
    }

    private static void createDirectories(File directory) throws IOException {
        Path path = directory.toPath();
        try {
            Files.createDirectories(path, PosixFilePermissions.asFileAttribute(
                    PosixFilePermissions.fromString(&quot;rwx------&quot;)));
        } catch (UnsupportedOperationException ex) {
            Files.createDirectories(path);
        }
    }

    private void fireError(EventType&lt;WebErrorEvent&gt; eventType, String message,
                           Throwable exception)
    {
        EventHandler&lt;WebErrorEvent&gt; handler = getOnError();
        if (handler != null) {
            handler.handle(new WebErrorEvent(this, eventType,
                                             message, exception));
        }
    }

    // for testing purposes only
    void dispose() {
        disposer.dispose();
    }

    private static final class SelfDisposer implements DisposerRecord {
        private WebPage page;
        private DirectoryLock userDataDirectoryLock;

        private SelfDisposer(WebPage page) {
            this.page = page;
        }

        @Override public void dispose() {
            if (page == null) {
                return;
            }
            page.dispose();
            page = null;
            if (userDataDirectoryLock != null) {
                userDataDirectoryLock.close();
            }
            instanceCount--;
            if (instanceCount == 0 &amp;&amp;
                Timer.getMode() == Timer.Mode.PLATFORM_TICKS)
            {
                PulseTimer.stop();
            }
        }
    }

    private static final class AccessorImpl extends Accessor {
        private final WeakReference&lt;WebEngine&gt; engine;

        private AccessorImpl(WebEngine w) {
            this.engine = new WeakReference&lt;WebEngine&gt;(w);
        }

        @Override public WebEngine getEngine() {
            return engine.get();
        }

        @Override public WebPage getPage() {
            WebEngine w = getEngine();
            return w == null ? null : w.page;
        }

        @Override public WebView getView() {
            WebEngine w = getEngine();
            return w == null ? null : w.view.get();
        }

        @Override public void addChild(Node child) {
            WebView view = getView();
            if (view != null) {
                view.getChildren().add(child);
            }
        }

        @Override public void removeChild(Node child) {
            WebView view = getView();
            if (view != null) {
                view.getChildren().remove(child);
            }
        }

        @Override public void addViewListener(InvalidationListener l) {
            WebEngine w = getEngine();
            if (w != null) {
                w.view.addListener(l);
            }
        }
    }

    /**
     * Drives the {@code Timer} when {@code Timer.Mode.PLATFORM_TICKS} is set.
     */
    private static final class PulseTimer {

        // Used just to guarantee constant pulse activity. See RT-14433.
        private static final AnimationTimer animation =
            new AnimationTimer() {
                @Override public void handle(long l) {}
            };

        private static final TKPulseListener listener =
                () -&gt; {
                    // Note, the timer event is executed right in the notifyTick(),
                    // that is during the pulse event. This makes the timer more
                    // repsonsive, though prolongs the pulse. So far it causes no
                    // problems but nevertheless it should be kept in mind.

                    // Execute notifyTick in runLater to run outside of pulse so
                    // that events will run in order and be able to display dialogs
                    // or call other methods that require a nested event loop.
                    Platform.runLater(() -&gt; Timer.getTimer().notifyTick());
                };

        private static void start(){
            Toolkit.getToolkit().addSceneTkPulseListener(listener);
            animation.start();
        }

        private static void stop() {
            Toolkit.getToolkit().removeSceneTkPulseListener(listener);
            animation.stop();
        }
    }

    static void checkThread() {
        Toolkit.getToolkit().checkFxUserThread();
    }


    /**
     * The page load event listener. This object references the owner
     * WebEngine weakly so as to avoid referencing WebEngine from WebPage
     * strongly.
     */
    private static final class PageLoadListener implements LoadListenerClient {

        private final WeakReference&lt;WebEngine&gt; engine;


        private PageLoadListener(WebEngine engine) {
            this.engine = new WeakReference&lt;WebEngine&gt;(engine);
        }


        @Override public void dispatchLoadEvent(long frame, int state,
                String url, String contentType, double progress, int errorCode)
        {
            WebEngine w = engine.get();
            if (w != null) {
                w.loadWorker.dispatchLoadEvent(frame, state, url,
                        contentType, progress, errorCode);
            }
        }

        @Override public void dispatchResourceLoadEvent(long frame,
                int state, String url, String contentType, double progress,
                int errorCode)
        {
        }
    }


    private final class LoadWorker implements Worker&lt;Void&gt; {

        private final ReadOnlyObjectWrapper&lt;State&gt; state = new ReadOnlyObjectWrapper&lt;State&gt;(this, &quot;state&quot;, State.READY);
        @Override public final State getState() { checkThread(); return state.get(); }
        @Override public final ReadOnlyObjectProperty&lt;State&gt; stateProperty() { checkThread(); return state.getReadOnlyProperty(); }
        private void updateState(State value) {
            checkThread();
            this.state.set(value);
            running.set(value == State.SCHEDULED || value == State.RUNNING);
        }

        /**
         * @InheritDoc
         */
        private final ReadOnlyObjectWrapper&lt;Void&gt; value = new ReadOnlyObjectWrapper&lt;Void&gt;(this, &quot;value&quot;, null);
        @Override public final Void getValue() { checkThread(); return value.get(); }
        @Override public final ReadOnlyObjectProperty&lt;Void&gt; valueProperty() { checkThread(); return value.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyObjectWrapper&lt;Throwable&gt; exception = new ReadOnlyObjectWrapper&lt;Throwable&gt;(this, &quot;exception&quot;);
        @Override public final Throwable getException() { checkThread(); return exception.get(); }
        @Override public final ReadOnlyObjectProperty&lt;Throwable&gt; exceptionProperty() { checkThread(); return exception.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyDoubleWrapper workDone = new ReadOnlyDoubleWrapper(this, &quot;workDone&quot;, -1);
        @Override public final double getWorkDone() { checkThread(); return workDone.get(); }
        @Override public final ReadOnlyDoubleProperty workDoneProperty() { checkThread(); return workDone.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyDoubleWrapper totalWorkToBeDone = new ReadOnlyDoubleWrapper(this, &quot;totalWork&quot;, -1);
        @Override public final double getTotalWork() { checkThread(); return totalWorkToBeDone.get(); }
        @Override public final ReadOnlyDoubleProperty totalWorkProperty() { checkThread(); return totalWorkToBeDone.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyDoubleWrapper progress = new ReadOnlyDoubleWrapper(this, &quot;progress&quot;, -1);
        @Override public final double getProgress() { checkThread(); return progress.get(); }
        @Override public final ReadOnlyDoubleProperty progressProperty() { checkThread(); return progress.getReadOnlyProperty(); }
        private void updateProgress(double p) {
            totalWorkToBeDone.set(100.0);
            workDone.set(p * 100.0);
            progress.set(p);
        }

        /**
         * @InheritDoc
         */
        private final ReadOnlyBooleanWrapper running = new ReadOnlyBooleanWrapper(this, &quot;running&quot;, false);
        @Override public final boolean isRunning() { checkThread(); return running.get(); }
        @Override public final ReadOnlyBooleanProperty runningProperty() { checkThread(); return running.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyStringWrapper message = new ReadOnlyStringWrapper(this, &quot;message&quot;, &quot;&quot;);
        @Override public final String getMessage() { return message.get(); }
        @Override public final ReadOnlyStringProperty messageProperty() { return message.getReadOnlyProperty(); }

        /**
         * @InheritDoc
         */
        private final ReadOnlyStringWrapper title = new ReadOnlyStringWrapper(this, &quot;title&quot;, &quot;WebEngine Loader&quot;);
        @Override public final String getTitle() { return title.get(); }
        @Override public final ReadOnlyStringProperty titleProperty() { return title.getReadOnlyProperty(); }

        /**
         * Cancels the loading of the page. If called after the page has already
         * been loaded, then this call takes no effect.
         */
        @Override public boolean cancel() {
            if (isRunning()) {
                stop(); // this call indirectly sets state
                return true;
            } else {
                return false;
            }
        }

        private void cancelAndReset() {
            cancel();
            exception.set(null);
            message.set(&quot;&quot;);
            totalWorkToBeDone.set(-1);
            workDone.set(-1);
            progress.set(-1);
            updateState(State.READY);
            running.set(false);
        }

        private void dispatchLoadEvent(long frame, int state,
                String url, String contentType, double workDone, int errorCode)
        {
            if (frame != getMainFrame()) {
                return;
            }
            switch (state) {
                case PAGE_STARTED:
                    message.set(&quot;Loading &quot; + url);
                    updateLocation(url);
                    updateProgress(0.0);
                    updateState(State.SCHEDULED);
                    updateState(State.RUNNING);
                    break;
                case PAGE_REDIRECTED:
                    message.set(&quot;Loading &quot; + url);
                    updateLocation(url);
                    break;
                case PAGE_REPLACED:
                    message.set(&quot;Replaced &quot; + url);
                    // Update only the location, don't change title or document.
                    WebEngine.this.location.set(url);
                    break;
                case PAGE_FINISHED:
                    message.set(&quot;Loading complete&quot;);
                    updateProgress(1.0);
                    updateState(State.SUCCEEDED);
                    break;
                case LOAD_FAILED:
                    message.set(&quot;Loading failed&quot;);
                    exception.set(describeError(errorCode));
                    updateState(State.FAILED);
                    break;
                case LOAD_STOPPED:
                    message.set(&quot;Loading stopped&quot;);
                    updateState(State.CANCELLED);
                    break;
                case PROGRESS_CHANGED:
                    updateProgress(workDone);
                    break;
                case TITLE_RECEIVED:
                    updateTitle();
                    break;
                case DOCUMENT_AVAILABLE:
                    if (this.state.get() != State.RUNNING) {
                        // We have empty load; send a synthetic event (RT-32097)
                        dispatchLoadEvent(frame, PAGE_STARTED, url, contentType, workDone, errorCode);
                    }
                    document.invalidate(true);
                    break;
            }
        }

        private Throwable describeError(int errorCode) {
            String reason = &quot;Unknown error&quot;;

            switch (errorCode) {
                case UNKNOWN_HOST:
                    reason = &quot;Unknown host&quot;;
                    break;
                case MALFORMED_URL:
                    reason = &quot;Malformed URL&quot;;
                    break;
                case SSL_HANDSHAKE:
                    reason = &quot;SSL handshake failed&quot;;
                    break;
                case CONNECTION_REFUSED:
                    reason = &quot;Connection refused by server&quot;;
                    break;
                case CONNECTION_RESET:
                    reason = &quot;Connection reset by server&quot;;
                    break;
                case NO_ROUTE_TO_HOST:
                    reason = &quot;No route to host&quot;;
                    break;
                case CONNECTION_TIMED_OUT:
                    reason = &quot;Connection timed out&quot;;
                    break;
                case PERMISSION_DENIED:
                    reason = &quot;Permission denied&quot;;
                    break;
                case INVALID_RESPONSE:
                    reason = &quot;Invalid response from server&quot;;
                    break;
                case TOO_MANY_REDIRECTS:
                    reason = &quot;Too many redirects&quot;;
                    break;
                case FILE_NOT_FOUND:
                    reason = &quot;File not found&quot;;
                    break;
            }
            return new Throwable(reason);
        }
    }


    private final class DocumentProperty
            extends ReadOnlyObjectPropertyBase&lt;Document&gt; {

        private boolean available;
        private Document document;

        private void invalidate(boolean available) {
            if (this.available || available) {
                this.available = available;
                this.document = null;
                fireValueChangedEvent();
            }
        }

        public Document get() {
            if (!this.available) {
                return null;
            }
            if (this.document == null) {
                this.document = page.getDocument(page.getMainFrame());
                if (this.document == null) {
                    this.available = false;
                }
            }
            return this.document;
        }

        public Object getBean() {
            return WebEngine.this;
        }

        public String getName() {
            return &quot;document&quot;;
        }
    }


    /*
     * Returns the debugger associated with this web engine.
     * The debugger is an object that can be used to debug
     * the web page currently loaded into the web engine.
     * &lt;p&gt;
     * All methods of the debugger must be called on
     * the JavaFX Application Thread.
     * The message callback object registered with the debugger
     * is always called on the JavaFX Application Thread.
     * @return the debugger associated with this web engine.
     *         The return value cannot be {@code null}.
     */
    Debugger getDebugger() {
        return debugger;
    }

    /**
     * The debugger implementation.
     */
    private final class DebuggerImpl implements Debugger {

        private boolean enabled;
        private Callback&lt;String,Void&gt; messageCallback;


        @Override
        public boolean isEnabled() {
            checkThread();
            return enabled;
        }

        @Override
        public void setEnabled(boolean enabled) {
            checkThread();
            if (enabled != this.enabled) {
                if (enabled) {
                    page.setDeveloperExtrasEnabled(true);
                    page.connectInspectorFrontend();
                } else {
                    page.disconnectInspectorFrontend();
                    page.setDeveloperExtrasEnabled(false);
                }
                this.enabled = enabled;
            }
        }

        @Override
        public void sendMessage(String message) {
            checkThread();
            if (!enabled) {
                throw new IllegalStateException(&quot;Debugger is not enabled&quot;);
            }
            if (message == null) {
                throw new NullPointerException(&quot;message is null&quot;);
            }
            page.dispatchInspectorMessageFromFrontend(message);
        }

        @Override
        public Callback&lt;String,Void&gt; getMessageCallback() {
            checkThread();
            return messageCallback;
        }

        @Override
        public void setMessageCallback(Callback&lt;String,Void&gt; callback) {
            checkThread();
            messageCallback = callback;
        }
    }

    /**
     * The inspector client implementation. This object references the owner
     * WebEngine weakly so as to avoid referencing WebEngine from WebPage
     * strongly.
     */
    private static final class InspectorClientImpl implements InspectorClient {

        private final WeakReference&lt;WebEngine&gt; engine;


        private InspectorClientImpl(WebEngine engine) {
            this.engine = new WeakReference&lt;WebEngine&gt;(engine);
        }


        @Override
        public boolean sendMessageToFrontend(final String message) {
            boolean result = false;
            WebEngine webEngine = engine.get();
            if (webEngine != null) {
                final Callback&lt;String,Void&gt; messageCallback =
                        webEngine.debugger.messageCallback;
                if (messageCallback != null) {
                    AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                        messageCallback.call(message);
                        return null;
                    }, webEngine.page.getAccessControlContext());
                    result = true;
                }
            }
            return result;
        }
    }

    private static final boolean printStatusOK(PrinterJob job) {
        switch (job.getJobStatus()) {
            case NOT_STARTED:
            case PRINTING:
                return true;
            default:
                return false;
        }
    }

    /**
     * Prints the current Web page using the given printer job.
     * &lt;p&gt;This method does not modify the state of the job, nor does it call
     * {@link PrinterJob#endJob}, so the job may be safely reused afterwards.
     *
     * @param job printer job used for printing
     * @since JavaFX 8.0
     */
    public void print(PrinterJob job) {
        if (!printStatusOK(job)) {
            return;
        }

        PageLayout pl = job.getJobSettings().getPageLayout();
        float width = (float) pl.getPrintableWidth();
        float height = (float) pl.getPrintableHeight();
        int pageCount = page.beginPrinting(width, height);

        for (int i = 0; i &lt; pageCount; i++) {
            if (printStatusOK(job)) {
                Node printable = new Printable(page, i, width);
                job.printPage(printable);
            }
        }
        page.endPrinting();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/Controller/TroChoiVietDemo.java</CENTER></H3><HR>
<PRE>
/*
  RMIT University Vietnam
  Course: INTE2512 Object-Oriented Programming
  Semester: 2019C
  Assessment: Assignment 2
  Author: Hoang Quoc Dai
  ID: s3426353
  Created  date: 15/12/2019
  Last modified: 16/12/2019
  Acknowledgement: If you use any resources, acknowledge here. Failure to do so will be considered as plagiarism.
*/
package sample.Controller;

<A NAME="19"></A>import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
<FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#19',2,'match31-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.stage.Stage;
import sample.Sound.*;
import sample.View.*;
import java.util.*;
import javafx.animation.Interpolator;
import javafx.animation.RotateTransition;
import javafx.animation.SequentialTransition;
import javafx.scene.Node;
import javafx.scene.transform.Rotate;
import javafx.util.Duration;

public class TroChoiVietDemo extends Application {
    private int  matches;
    private Queue&lt;Card&gt; queue = new LinkedList&lt;&gt;()</B></FONT>;
    private Scene startScene;
    private Scene gameScene;
    private Scene endScene;
    private StartView startView;
    private GameView gameView;
    private EndView endView;
    private int timeLevel;
    private Stage primaryStage;
    private Sound sound;

    @Override
    public void start(Stage primaryStage){
        // Create stage
        setPrimaryStage(new Stage());
        // Add sound
        setSound(new Sound());
        //Create startView, set viewID, width, height and background by css file
        setStartView(new StartView());
        getStartView().setId(&quot;startScene&quot;);
        setStartScene(new Scene(getStartView(), 810, 960));
        getStartScene().getStylesheets().add(TroChoiVietDemo.class.getResource(&quot;style.css&quot;).toExternalForm());
        // Create EndScene, set viewID, width, height and background by css file
        setEndView(new EndView());
        getEndView().setId(&quot;endScene&quot;);
        setEndScene(new Scene(getEndView(), 710, 444));
        getEndScene().getStylesheets().add(TroChoiVietDemo.class.getResource(&quot;style.css&quot;).toExternalForm());
        //Set primaryStage firstly show startScene
        getPrimaryStage().setScene(getStartScene());
        getPrimaryStage().setTitle(&quot;Tro Choi Viet&quot;);
        getPrimaryStage().show();
        //


        // Set action for btLevel 1
        getStartView().getBtLevel1().setId(&quot;btLevel1&quot;);
        getStartView().getBtLevel1().setOnAction(getMyHandler());

        // Set action for btLevel 2
        getStartView().getBtLevel2().setId(&quot;btLevel2&quot;);
        getStartView().getBtLevel2().setOnAction(getMyHandler());

        // Set action for btLevel 3
        getStartView().getBtLevel3().setId(&quot;btLevel3&quot;);
        getStartView().getBtLevel3().setOnAction(getMyHandler());
        //
        getStartView().getBtSoundPlay().setId(&quot;play&quot;);
        getStartView().getBtSoundPlay().setOnAction(getMyHandler());
        //
        getStartView().getBtSoundPause().setId(&quot;pause&quot;);
        getStartView().getBtSoundPause().setOnAction(getMyHandler());

        // Set btQuit, btPlayAgain
        getEndView().getBtQuit().setId(&quot;btQuit&quot;);
        getEndView().getBtQuit().setOnAction(getMyHandler());
        getEndView().getBtPlayAgain().setId(&quot;btPlayAgain&quot;);
        getEndView().getBtPlayAgain().setOnAction(getMyHandler());
    }

    private EventHandler&lt;ActionEvent&gt; myHandler = new EventHandler&lt;ActionEvent&gt;() {
        @Override
        public void handle(ActionEvent event) {
            Button x = (Button) event.getSource();
            if (x.getId().equals(getEndView().getBtQuit().getId()))
                System.exit(0);
            else if (x.getId().equals(getEndView().getBtPlayAgain().getId()))
                getPrimaryStage().setScene(getStartScene());
            else if (x.getId().equals(getStartView().getBtLevel1().getId())) {
                setTimeLevel(3);
                setGameLevel();
            }
            else if (x.getId().equals(getStartView().getBtLevel2().getId())) {
                setTimeLevel(2);
                setGameLevel();
            }
            else if (x.getId().equals(getStartView().getBtLevel3().getId())) {
                setTimeLevel(1);
                setGameLevel();
            }
            else if (x.getId().equals(getStartView().getBtSoundPlay().getId()))
                getSound().playMusic();
            else if (x.getId().equals(getStartView().getBtSoundPause().getId()))
                getSound().pauseMusic();
        }
    };

    private void setGameLevel() {
        setGameView(new GameView());
        getGameView().setId(&quot;gameScene&quot;);
        setGameScene(new Scene(getGameView(), 1280, 720));
        getGameScene().getStylesheets().add(TroChoiVietDemo.class.getResource(&quot;style.css&quot;).toExternalForm());
        getPrimaryStage().setScene(getGameScene());
        setMatches(0);
        // if 10 matches -&gt; switch to endScene
        checkMatches();
        if (getMatches() ==  10) {
            getPrimaryStage().setScene(getEndScene()); }
    }

    private void checkMatches() {
        ArrayList&lt;Card&gt; cards = getGameView().getCards();
        for (Card card : cards){
            card.setOnMouseClicked(event -&gt; {
                getQueue().add(card);
                if(getQueue().size() &lt;= 2){
                    rotateCard(card);
                }
                if(getQueue().size() == 2){
                    Card card1 = getQueue().peek();
                    getQueue().remove();
                    Card card2 = getQueue().peek();
                    getQueue().remove();
                    //Check cardID by print out to the console
                    System.out.println(card1.getCardID());
                    System.out.println(card2.getCardID());
                    // If 2 cards are the same
                    if(card1.getCardID() == card2.getCardID()){
                        showFront2Cards(card1, card2);
                        setMatches(getMatches() + 1);
                        if (getMatches() ==  10) { getPrimaryStage().setScene(getEndScene()); }
                    }
                }
            });
        }
    }

    private void showFront2Cards(Card card1, Card card2) {
        card1.imageProperty().unbind();
        card1.setImage(card1.getFrontSide());
        card2.imageProperty().unbind();
        card2.setImage(card2.getFrontSide());
    }

    private void rotateCard(Card card) {
        RotateTransition rotator1 = createRotator(card);
        rotator1.setOnFinished(evt -&gt; {
            card.getIsFront().set(true);
        }); // When rotator1 completed, the status is true
        RotateTransition rotator2 = new RotateTransition(Duration.millis(getTimeLevel() * 1000), card);
        rotator2.setAxis(Rotate.Y_AXIS);
        rotator2.setFromAngle(0);
        rotator2.setToAngle(0);
        rotator2.setInterpolator(Interpolator.LINEAR);
        rotator2.setOnFinished(evt -&gt; {
            card.getIsFront().set(false);
        }); // When rotator2 completed, the status is false
        RotateTransition rotator3 = createRotator(card);
        SequentialTransition rotator = new SequentialTransition(card, rotator1, rotator2, rotator3);
        rotator.play();
    }

    private RotateTransition createRotator(Node card) {
        // animation length proportional to the rotation angle
        RotateTransition rotator = new RotateTransition(Duration.millis(100), card);
        rotator.setAxis(Rotate.Y_AXIS);
        rotator.setFromAngle(0);
        rotator.setToAngle(180);
        rotator.setInterpolator(Interpolator.LINEAR);

        return rotator;
    }

    private int getMatches() {
        return matches;
    }
    private void setMatches(int number) {
        this.matches = number;
    }

    private Queue&lt;Card&gt; getQueue() {
        return queue;
    }

    private void setQueue(Queue&lt;Card&gt; queue) {
        this.queue = queue;
    }

    private Scene getStartScene() {
        return startScene;
    }
    private void setStartScene(Scene startScene) {
        this.startScene = startScene;
    }

    private int getTimeLevel() {
        return timeLevel;
    }

    private void setTimeLevel(int time) {
        this.timeLevel = time;
    }

    private StartView getStartView() {
        return startView;
    }

    private void setStartView(StartView startView) {
        this.startView = startView;
    }

    private Scene getGameScene() {
        return gameScene;
    }

    private void setGameScene(Scene gameScene) {
        this.gameScene = gameScene;
    }

    private Scene getEndScene() {
        return endScene;
    }

    private void setEndScene(Scene endScene) {
        this.endScene = endScene;
    }

    private GameView getGameView() {
        return gameView;
    }

    private void setGameView(GameView gameView) {
        this.gameView = gameView;
    }

    private EndView getEndView() {
        return endView;
    }

    private void setEndView(EndView endView) {
        this.endView = endView;
    }

    private Stage getPrimaryStage() {
        return primaryStage;
    }

    private void setPrimaryStage(Stage primaryStage) {
        this.primaryStage = primaryStage;
    }

    private EventHandler&lt;ActionEvent&gt; getMyHandler() {
        return myHandler;
    }

    public void setSound(Sound sound) {
        this.sound = sound;
    }

    public Sound getSound() {
        return sound;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/View/GameView.java</CENTER></H3><HR>
<PRE>
/*
  RMIT University Vietnam
  Course: INTE2512 Object-Oriented Programming
  Semester: 2019C
  Assessment: Assignment 2
  Author: Hoang Quoc Dai
  ID: s3426353
  Created  date: 15/12/2019
  Last modified: 16/12/2019
  Acknowledgement: If you use any resources, acknowledge here. Failure to do so will be considered as plagiarism.
<A NAME="0"></A>*/
package sample.View;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#0',2,'match31-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import javafx.geometry.Pos;
import javafx.scene.image.Image;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontPosture;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import java.util.ArrayList;
import java.util.Random;
import</B></FONT> java.util.Timer;
import java.util.TimerTask;

public class GameView extends VBox{
    int[] cardIndices = { 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10};
    ArrayList &lt;Card&gt; cards = new ArrayList&lt;&gt;();
    private GridPane matrixCards;
    private TimeBar timeBar;
    private Image image;
    private Text timeDisplay;
    private Timer timer;
    private int min = 1;
    private int sec = 59;
    private int milliSec = 99;
    private int totalFront;

    public GameView() {
        setSpacing(20);
        setAlignment(Pos.CENTER_RIGHT);

        matrixCards = new GridPane();
        String prefix = &quot;Images/&quot;;
        String postfix = &quot;.jpg&quot;;
        shuffleCards();
        for (int col = 1; col &lt;= 5; col++) {
            for (int row = 1; row &lt;= 4; row++) {
                String cardID = Integer.toString(cardIndices[row - 1 + 4*(col-1)]);
                Card temp = new Card(prefix + cardID + postfix);
                matrixCards.add(temp, col, row);
                cards.add(temp);
            }
        }
        setTimeBar(new TimeBar());
        getChildren().addAll(matrixCards, getTimeBar());

        //Set timeDisplay
        setTimeDisplay(new Text(&quot;Time: 00:00:00&quot;));
        getTimeDisplay().setFill(Color.YELLOW);
        getTimeDisplay().setFont(Font.font(&quot;Courier&quot;, FontWeight.BOLD, FontPosture.REGULAR, 15));
        getChildren().add(getTimeDisplay());
        timerProcess(); //Set timer
    }

    //For Card
    public void shuffleCards() {
        Random rand = new Random();
        for (int i = 0; i &lt; cardIndices.length; i++) {
            int randomIndexToSwap = rand.nextInt(cardIndices.length);
            int temp = cardIndices[randomIndexToSwap];
            cardIndices[randomIndexToSwap] = cardIndices[i];
            cardIndices[i] = temp;
        }
    }
    //For timer
    private void timerProcess() {

        setTotalFront(0);
        int delay = 40;
        int period = 40;
        setTimer(new Timer());
        getTimer().scheduleAtFixedRate(new TimerTask() {
            public void run() {
                getTimeDisplay().setText(&quot;Time: &quot;+ showCountDown());
            }
        }, delay, period);
    }

    //For timer
    private String showCountDown() {
        setMilliSec(getMilliSec() -4);
        if (getMilliSec() &lt; 0){
            setMilliSec(99);
            setSec(getSec() - 1);
        }
        if (getSec() == 0){
            setSec(59);
            setMin(getMin() - 1);
        }
        if (getMin() &lt; 0) {
            getTimer().cancel();
            return &quot;00:00:00&quot;;
        };
        if (getTotalFront() == 20){
            getTimer().cancel();
        }
        return &quot;0&quot;+Integer.toString(getMin())+&quot;:&quot;+Integer.toString(getSec()/10)+Integer.toString(getSec()%10)+&quot;:&quot;+Integer.toString(getMilliSec());
    }

    private TimeBar getTimeBar() {
        return timeBar;
    }

    private void setTimeBar(TimeBar timeBar) {
        this.timeBar = timeBar;
    }

    private Image getImage() {
        return image;
    }

    private void setImage(Image image) {
        this.image = image;
    }

    public ArrayList&lt;Card&gt; getCards() {
        return cards;
    }

    private Text getTimeDisplay() {
        return timeDisplay;
    }

    private void setTimeDisplay(Text timeDisplay) {
        this.timeDisplay = timeDisplay;
    }

    private Timer getTimer() {
        return timer;
    }

    private void setTimer(Timer timer) {
        this.timer = timer;
    }

    private int getMin() {
        return min;
    }

    private void setMin(int min) {
        this.min = min;
    }

    private int getSec() {
        return sec;
    }

    private void setSec(int sec) {
        this.sec = sec;
    }

    private int getMilliSec() {
        return milliSec;
    }

    private void setMilliSec(int milliSec) {
        this.milliSec = milliSec;
    }

    private int getTotalFront() {
        return totalFront;
    }

    private void setTotalFront(int totalFront) {
        this.totalFront = totalFront;
    }
}
</PRE>

</BODY>
</HTML>
