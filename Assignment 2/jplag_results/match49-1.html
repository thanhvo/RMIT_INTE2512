<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>daihoangquoc_</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/CustomColorDialog.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import com.sun.javafx.scene.control.IntegerField;
import com.sun.javafx.scene.control.WebColorField;
import com.sun.javafx.scene.control.skin.IntegerFieldSkin;
import com.sun.javafx.scene.control.skin.WebColorFieldSkin;
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.*;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.*;
import javafx.scene.paint.*;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;
import javafx.beans.binding.Bindings;
import javafx.beans.binding.ObjectBinding;
import javafx.geometry.Insets;
import javafx.geometry.Orientation;
import javafx.geometry.Pos;
import javafx.geometry.Rectangle2D;
import javafx.scene.input.KeyEvent;
import javafx.stage.Screen;
import javafx.stage.WindowEvent;

/**
 *
 */
public class CustomColorDialog extends HBox {

    private final Stage dialog = new Stage();
    private ColorRectPane colorRectPane;
    private ControlsPane controlsPane;

    private ObjectProperty&lt;Color&gt; currentColorProperty = new SimpleObjectProperty&lt;&gt;(Color.WHITE);
    private ObjectProperty&lt;Color&gt; customColorProperty = new SimpleObjectProperty&lt;&gt;(Color.TRANSPARENT);
    private Runnable onSave;
    private Runnable onUse;
    private Runnable onCancel;

    private WebColorField webField = null;
    private Scene customScene;

    // JDK-8161449
    private String saveBtnText;
    private boolean showUseBtn = true;
    private boolean showOpacitySlider = true;

    public CustomColorDialog(Window owner) {
        getStyleClass().add(&quot;custom-color-dialog&quot;);
        if (owner != null) dialog.initOwner(owner);
        dialog.setTitle(Properties.getColorPickerString(&quot;customColorDialogTitle&quot;));
        dialog.initModality(Modality.APPLICATION_MODAL);
        dialog.initStyle(StageStyle.UTILITY);
        dialog.setResizable(false);

        dialog.addEventHandler(KeyEvent.ANY, keyEventListener);

        customScene = new Scene(this);
        final Scene ownerScene = owner.getScene();
        if (ownerScene != null) {
            if (ownerScene.getUserAgentStylesheet() != null) {
                customScene.setUserAgentStylesheet(ownerScene.getUserAgentStylesheet());
            }
            customScene.getStylesheets().addAll(ownerScene.getStylesheets());
        }

        buildUI();

        dialog.setScene(customScene);
    }

    private void buildUI() {
        colorRectPane = new ColorRectPane();
        controlsPane = new ControlsPane();
        setHgrow(controlsPane, Priority.ALWAYS);
        getChildren().setAll(colorRectPane, controlsPane);
    }

    private final EventHandler&lt;KeyEvent&gt; keyEventListener = e -&gt; {
        switch (e.getCode()) {
            case ESCAPE:
                dialog.setScene(null);
                dialog.close();
            default:
                break;
        }
    };

    public void setCurrentColor(Color currentColor) {
        this.currentColorProperty.set(currentColor);
    }

    public final Color getCurrentColor() {
        return currentColorProperty.get();
    }

    public final ObjectProperty&lt;Color&gt; customColorProperty() {
        return customColorProperty;
    }

    public final void setCustomColor(Color color) {
        customColorProperty.set(color);
    }

    public final Color getCustomColor() {
        return customColorProperty.get();
    }

    public Runnable getOnSave() {
        return onSave;
    }

    public void setOnSave(Runnable onSave) {
        this.onSave = onSave;
    }

    // JDK-8161449
    public void setSaveBtnToOk() {
        this.saveBtnText = Properties.getColorPickerString(&quot;OK&quot;);
        buildUI();
    }

    public Runnable getOnUse() {
        return onUse;
    }

    public void setOnUse(Runnable onUse) {
        this.onUse = onUse;
    }

    // JDK-8161449
    public void setShowUseBtn(boolean showUseBtn) {
        this.showUseBtn = showUseBtn;
        buildUI();
    }

    // JDK-8161449
    public void setShowOpacitySlider(boolean showOpacitySlider) {
        this.showOpacitySlider = showOpacitySlider;
        buildUI();
    }

    public Runnable getOnCancel() {
        return onCancel;
    }

    public void setOnCancel(Runnable onCancel) {
        this.onCancel = onCancel;
    }

    public void setOnHidden(EventHandler&lt;WindowEvent&gt; onHidden) {
        dialog.setOnHidden(onHidden);
    }

    public Stage getDialog() {
        return dialog;
    }

    public void show() {
        if (dialog.getOwner() != null) {
            // Workaround of RT-29871: Instead of just invoking fixPosition()
            // here need to use listener that fixes dialog position once both
            // width and height are determined
            dialog.widthProperty().addListener(positionAdjuster);
            dialog.heightProperty().addListener(positionAdjuster);
            positionAdjuster.invalidated(null);
        }
        if (dialog.getScene() == null) dialog.setScene(customScene);
        colorRectPane.updateValues();
        dialog.show();
    }

    public void hide() {
        if (dialog.getOwner() != null) {
            dialog.hide();
        }
    }

    private InvalidationListener positionAdjuster = new InvalidationListener() {

        @Override
        public void invalidated(Observable ignored) {
            if (Double.isNaN(dialog.getWidth()) || Double.isNaN(dialog.getHeight())) {
                return;
            }
            dialog.widthProperty().removeListener(positionAdjuster);
            dialog.heightProperty().removeListener(positionAdjuster);
            fixPosition();
        }

    };

    private void fixPosition() {
        Window w = dialog.getOwner();
        Screen s = com.sun.javafx.util.Utils.getScreen(w);
        Rectangle2D sb = s.getBounds();
        double xR = w.getX() + w.getWidth();
        double xL = w.getX() - dialog.getWidth();
        double x, y;
        if (sb.getMaxX() &gt;= xR + dialog.getWidth()) {
            x = xR;
        } else if (sb.getMinX() &lt;= xL) {
            x = xL;
        } else {
            x = Math.max(sb.getMinX(), sb.getMaxX() - dialog.getWidth());
        }
        y = Math.max(sb.getMinY(), Math.min(sb.getMaxY() - dialog.getHeight(), w.getY()));
        dialog.setX(x);
        dialog.setY(y);
    }

    @Override
    public void layoutChildren() {
        super.layoutChildren();
        if (dialog.getMinWidth() &gt; 0 &amp;&amp; dialog.getMinHeight() &gt; 0) {
            // don't recalculate min size once it's set
            return;
        }

        // Math.max(0, ...) added for RT-34704 to ensure the dialog is at least 0 x 0
        double minWidth = Math.max(0, computeMinWidth(getHeight()) + (dialog.getWidth() - customScene.getWidth()));
        double minHeight = Math.max(0, computeMinHeight(getWidth()) + (dialog.getHeight() - customScene.getHeight()));
        dialog.setMinWidth(minWidth);
        dialog.setMinHeight(minHeight);
    }

    /* ------------------------------------------------------------------------*/

    private class ColorRectPane extends HBox {

        private Pane colorRect;
        private Pane colorBar;
        private Pane colorRectOverlayOne;
        private Pane colorRectOverlayTwo;
        private Region colorRectIndicator;
        private Region colorBarIndicator;

        private boolean changeIsLocal = false;
        private DoubleProperty hue = new SimpleDoubleProperty(-1) {
            @Override
            protected void invalidated() {
                if (!changeIsLocal) {
                    changeIsLocal = true;
                    updateHSBColor();
                    changeIsLocal = false;
                }
            }
        };
        private DoubleProperty sat = new SimpleDoubleProperty(-1) {
            @Override
            protected void invalidated() {
                if (!changeIsLocal) {
                    changeIsLocal = true;
                    updateHSBColor();
                    changeIsLocal = false;
                }
            }
        };
        private DoubleProperty bright = new SimpleDoubleProperty(-1) {
            @Override
            protected void invalidated() {
                if (!changeIsLocal) {
                    changeIsLocal = true;
                    updateHSBColor();
                    changeIsLocal = false;
                }
            }
        };
        private IntegerProperty red = new SimpleIntegerProperty(-1) {
            @Override
            protected void invalidated() {
                if (!changeIsLocal) {
                    changeIsLocal = true;
                    updateRGBColor();
                    changeIsLocal = false;
                }
            }
        };

        private IntegerProperty green = new SimpleIntegerProperty(-1) {
            @Override
            protected void invalidated() {
                if (!changeIsLocal) {
                    changeIsLocal = true;
                    updateRGBColor();
                    changeIsLocal = false;
                }
            }
        };

        private IntegerProperty blue = new SimpleIntegerProperty(-1) {
            @Override
            protected void invalidated() {
                if (!changeIsLocal) {
                    changeIsLocal = true;
                    updateRGBColor();
                    changeIsLocal = false;
                }
            }
        };

        private DoubleProperty alpha = new SimpleDoubleProperty(100) {
            @Override
            protected void invalidated() {
                if (!changeIsLocal) {
                    changeIsLocal = true;
                    setCustomColor(new Color(
                            getCustomColor().getRed(),
                            getCustomColor().getGreen(),
                            getCustomColor().getBlue(),
                            clamp(alpha.get() / 100)));
                    changeIsLocal = false;
                }
            }
<A NAME="7"></A>        };

        private void updateRGBColor() {
            Color newColor = Color.rgb(red.get(), green.get(), blue.get(), <FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#7',2,'match49-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>clamp(alpha.get() / 100));
            hue.set(newColor.getHue());
            sat.set(newColor.getSaturation() * 100);
            bright.set(newColor.getBrightness() * 100);
            setCustomColor(newColor);
        }

        private void updateHSBColor() {
            Color newColor = Color.hsb(hue.get(), clamp(sat.get() / 100),</B></FONT>
                    clamp(bright.get() / 100), clamp(alpha.get() / 100));
            red.set(doubleToInt(newColor.getRed()));
            green.set(doubleToInt(newColor.getGreen()));
            blue.set(doubleToInt(newColor.getBlue()));
            setCustomColor(newColor);
        }

        private void colorChanged() {
            if (!changeIsLocal) {
                changeIsLocal = true;
                hue.set(getCustomColor().getHue());
                sat.set(getCustomColor().getSaturation() * 100);
                bright.set(getCustomColor().getBrightness() * 100);
                red.set(doubleToInt(getCustomColor().getRed()));
                green.set(doubleToInt(getCustomColor().getGreen()));
                blue.set(doubleToInt(getCustomColor().getBlue()));
                changeIsLocal = false;
            }
        }

        public ColorRectPane() {

            getStyleClass().add(&quot;color-rect-pane&quot;);

            customColorProperty().addListener((ov, t, t1) -&gt; {
                colorChanged();
            });

            colorRectIndicator = new Region();
            colorRectIndicator.setId(&quot;color-rect-indicator&quot;);
            colorRectIndicator.setManaged(false);
            colorRectIndicator.setMouseTransparent(true);
            colorRectIndicator.setCache(true);

            final Pane colorRectOpacityContainer = new StackPane();

            colorRect = new StackPane() {
                // This is an implementation of square control that chooses its
                // size to fill the available height
                @Override
                public Orientation getContentBias() {
                    return Orientation.VERTICAL;
                }

                @Override
                protected double computePrefWidth(double height) {
                    return height;
                }

                @Override
                protected double computeMaxWidth(double height) {
                    return height;
                }
            };
            colorRect.getStyleClass().addAll(&quot;color-rect&quot;, &quot;transparent-pattern&quot;);

            Pane colorRectHue = new Pane();
            colorRectHue.backgroundProperty().bind(new ObjectBinding&lt;Background&gt;() {

                {
                    bind(hue);
                }

                @Override
                protected Background computeValue() {
                    return new Background(new BackgroundFill(
                            Color.hsb(hue.getValue(), 1.0, 1.0),
                            CornerRadii.EMPTY, Insets.EMPTY));
                }
            });

            colorRectOverlayOne = new Pane();
            colorRectOverlayOne.getStyleClass().add(&quot;color-rect&quot;);
            colorRectOverlayOne.setBackground(new Background(new BackgroundFill(
                    new LinearGradient(0, 0, 1, 0, true, CycleMethod.NO_CYCLE,
                            new Stop(0, Color.rgb(255, 255, 255, 1)),
                            new Stop(1, Color.rgb(255, 255, 255, 0))),
                    CornerRadii.EMPTY, Insets.EMPTY)));

            EventHandler&lt;MouseEvent&gt; rectMouseHandler = event -&gt; {
                final double x = event.getX();
                final double y = event.getY();
                sat.set(clamp(x / colorRect.getWidth()) * 100);
                bright.set(100 - (clamp(y / colorRect.getHeight()) * 100));
            };

            colorRectOverlayTwo = new Pane();
            colorRectOverlayTwo.getStyleClass().addAll(&quot;color-rect&quot;);
            colorRectOverlayTwo.setBackground(new Background(new BackgroundFill(
                    new LinearGradient(0, 0, 0, 1, true, CycleMethod.NO_CYCLE,
                            new Stop(0, Color.rgb(0, 0, 0, 0)), new Stop(1, Color.rgb(0, 0, 0, 1))),
                    CornerRadii.EMPTY, Insets.EMPTY)));
            colorRectOverlayTwo.setOnMouseDragged(rectMouseHandler);
            colorRectOverlayTwo.setOnMousePressed(rectMouseHandler);

            Pane colorRectBlackBorder = new Pane();
            colorRectBlackBorder.setMouseTransparent(true);
            colorRectBlackBorder.getStyleClass().addAll(&quot;color-rect&quot;, &quot;color-rect-border&quot;);

            colorBar = new Pane();
            colorBar.getStyleClass().add(&quot;color-bar&quot;);
            colorBar.setBackground(new Background(new BackgroundFill(createHueGradient(),
                    CornerRadii.EMPTY, Insets.EMPTY)));

            colorBarIndicator = new Region();
            colorBarIndicator.setId(&quot;color-bar-indicator&quot;);
            colorBarIndicator.setMouseTransparent(true);
            colorBarIndicator.setCache(true);

            colorRectIndicator.layoutXProperty().bind(sat.divide(100).multiply(colorRect.widthProperty()));
            colorRectIndicator.layoutYProperty().bind(Bindings.subtract(1, bright.divide(100)).multiply(colorRect.heightProperty()));
            colorBarIndicator.layoutYProperty().bind(hue.divide(360).multiply(colorBar.heightProperty()));
            colorRectOpacityContainer.opacityProperty().bind(alpha.divide(100));

            EventHandler&lt;MouseEvent&gt; barMouseHandler = event -&gt; {
                final double y = event.getY();
                hue.set(clamp(y / colorRect.getHeight()) * 360);
            };

            colorBar.setOnMouseDragged(barMouseHandler);
            colorBar.setOnMousePressed(barMouseHandler);

            colorBar.getChildren().setAll(colorBarIndicator);
            colorRectOpacityContainer.getChildren().setAll(colorRectHue, colorRectOverlayOne, colorRectOverlayTwo);
            colorRect.getChildren().setAll(colorRectOpacityContainer, colorRectBlackBorder, colorRectIndicator);
            HBox.setHgrow(colorRect, Priority.SOMETIMES);
            getChildren().addAll(colorRect, colorBar);
        }

        private void updateValues() {
            if (getCurrentColor() == null) {
                setCurrentColor(Color.TRANSPARENT);
            }
            changeIsLocal = true;
            //Initialize hue, sat, bright, color, red, green and blue
            hue.set(getCurrentColor().getHue());
            sat.set(getCurrentColor().getSaturation() * 100);
            bright.set(getCurrentColor().getBrightness() * 100);
            alpha.set(getCurrentColor().getOpacity() * 100);
            setCustomColor(Color.hsb(hue.get(), clamp(sat.get() / 100), clamp(bright.get() / 100),
                    clamp(alpha.get() / 100)));
            red.set(doubleToInt(getCustomColor().getRed()));
            green.set(doubleToInt(getCustomColor().getGreen()));
            blue.set(doubleToInt(getCustomColor().getBlue()));
            changeIsLocal = false;
        }

        @Override
        protected void layoutChildren() {
            super.layoutChildren();

            // to maintain default size
            colorRectIndicator.autosize();
            // to maintain square size
            double size = Math.min(colorRect.getWidth(), colorRect.getHeight());
            colorRect.resize(size, size);
            colorBar.resize(colorBar.getWidth(), size);
        }
    }

    /* ------------------------------------------------------------------------*/

    private class ControlsPane extends VBox {

        private Label currentColorLabel;
        private Label newColorLabel;
        private Region currentColorRect;
        private Region newColorRect;
        private Region currentTransparent; // for opacity
        private GridPane currentAndNewColor;
        private Region currentNewColorBorder;
        private ToggleButton hsbButton;
        private ToggleButton rgbButton;
        private ToggleButton webButton;
        private HBox hBox;

        private Label labels[] = new Label[4];
        private Slider sliders[] = new Slider[4];
        private IntegerField fields[] = new IntegerField[4];
        private Label units[] = new Label[4];
        private HBox buttonBox;
        private Region whiteBox;

        private GridPane settingsPane = new GridPane();

        public ControlsPane() {
            getStyleClass().add(&quot;controls-pane&quot;);

            currentNewColorBorder = new Region();
            currentNewColorBorder.setId(&quot;current-new-color-border&quot;);

            currentTransparent = new Region();
            currentTransparent.getStyleClass().addAll(&quot;transparent-pattern&quot;);

            currentColorRect = new Region();
            currentColorRect.getStyleClass().add(&quot;color-rect&quot;);
            currentColorRect.setId(&quot;current-color&quot;);
            currentColorRect.backgroundProperty().bind(new ObjectBinding&lt;Background&gt;() {
                {
                    bind(currentColorProperty);
                }

                @Override
                protected Background computeValue() {
                    return new Background(new BackgroundFill(currentColorProperty.get(), CornerRadii.EMPTY, Insets.EMPTY));
                }
            });

            newColorRect = new Region();
            newColorRect.getStyleClass().add(&quot;color-rect&quot;);
            newColorRect.setId(&quot;new-color&quot;);
            newColorRect.backgroundProperty().bind(new ObjectBinding&lt;Background&gt;() {
                {
                    bind(customColorProperty);
                }

                @Override
                protected Background computeValue() {
                    return new Background(new BackgroundFill(customColorProperty.get(), CornerRadii.EMPTY, Insets.EMPTY));
                }
            });

            currentColorLabel = new Label(Properties.getColorPickerString(&quot;currentColor&quot;));
            newColorLabel = new Label(Properties.getColorPickerString(&quot;newColor&quot;));

            whiteBox = new Region();
            whiteBox.getStyleClass().add(&quot;customcolor-controls-background&quot;);

            hsbButton = new ToggleButton(Properties.getColorPickerString(&quot;colorType.hsb&quot;));
            hsbButton.getStyleClass().add(&quot;left-pill&quot;);
            rgbButton = new ToggleButton(Properties.getColorPickerString(&quot;colorType.rgb&quot;));
            rgbButton.getStyleClass().add(&quot;center-pill&quot;);
            webButton = new ToggleButton(Properties.getColorPickerString(&quot;colorType.web&quot;));
            webButton.getStyleClass().add(&quot;right-pill&quot;);
            final ToggleGroup group = new ToggleGroup();

            hBox = new HBox();
            hBox.setAlignment(Pos.CENTER);
            hBox.getChildren().addAll(hsbButton, rgbButton, webButton);

            Region spacer1 = new Region();
            spacer1.setId(&quot;spacer1&quot;);
            Region spacer2 = new Region();
            spacer2.setId(&quot;spacer2&quot;);
            Region leftSpacer = new Region();
            leftSpacer.setId(&quot;spacer-side&quot;);
            Region rightSpacer = new Region();
            rightSpacer.setId(&quot;spacer-side&quot;);
            Region bottomSpacer = new Region();
            bottomSpacer.setId(&quot;spacer-bottom&quot;);

            currentAndNewColor = new GridPane();
            currentAndNewColor.getColumnConstraints().addAll(new ColumnConstraints(), new ColumnConstraints());
            currentAndNewColor.getColumnConstraints().get(0).setHgrow(Priority.ALWAYS);
            currentAndNewColor.getColumnConstraints().get(1).setHgrow(Priority.ALWAYS);
            currentAndNewColor.getRowConstraints().addAll(new RowConstraints(), new RowConstraints(), new RowConstraints());
            currentAndNewColor.getRowConstraints().get(2).setVgrow(Priority.ALWAYS);
            VBox.setVgrow(currentAndNewColor, Priority.ALWAYS);

            currentAndNewColor.getStyleClass().add(&quot;current-new-color-grid&quot;);
            currentAndNewColor.add(currentColorLabel, 0, 0);
            currentAndNewColor.add(newColorLabel, 1, 0);
            currentAndNewColor.add(spacer1, 0, 1, 2, 1);
            currentAndNewColor.add(currentTransparent, 0, 2, 2, 1);
            currentAndNewColor.add(currentColorRect, 0, 2);
            currentAndNewColor.add(newColorRect, 1, 2);
            currentAndNewColor.add(currentNewColorBorder, 0, 2, 2, 1);
            currentAndNewColor.add(spacer2, 0, 3, 2, 1);

            settingsPane = new GridPane();
            settingsPane.setId(&quot;settings-pane&quot;);
            settingsPane.getColumnConstraints().addAll(new ColumnConstraints(),
                    new ColumnConstraints(), new ColumnConstraints(),
                    new ColumnConstraints(), new ColumnConstraints(),
                    new ColumnConstraints());
            settingsPane.getColumnConstraints().get(0).setHgrow(Priority.NEVER);
            settingsPane.getColumnConstraints().get(2).setHgrow(Priority.ALWAYS);
            settingsPane.getColumnConstraints().get(3).setHgrow(Priority.NEVER);
            settingsPane.getColumnConstraints().get(4).setHgrow(Priority.NEVER);
            settingsPane.getColumnConstraints().get(5).setHgrow(Priority.NEVER);
            settingsPane.add(whiteBox, 0, 0, 6, 5);
            settingsPane.add(hBox, 0, 0, 6, 1);
            settingsPane.add(leftSpacer, 0, 0);
            settingsPane.add(rightSpacer, 5, 0);
            settingsPane.add(bottomSpacer, 0, 4);

            webField = new WebColorField();
            webField.getStyleClass().add(&quot;web-field&quot;);
            webField.setSkin(new WebColorFieldSkin(webField));
            webField.valueProperty().bindBidirectional(customColorProperty);
            webField.visibleProperty().bind(group.selectedToggleProperty().isEqualTo(webButton));
            settingsPane.add(webField, 2, 1);

            // Color settings Grid Pane
            for (int i = 0; i &lt; 4; i++) {
                labels[i] = new Label();
                labels[i].getStyleClass().add(&quot;settings-label&quot;);

                sliders[i] = new Slider();

                fields[i] = new IntegerField();
                fields[i].getStyleClass().add(&quot;color-input-field&quot;);
                fields[i].setSkin(new IntegerFieldSkin(fields[i]));

                units[i] = new Label(i == 0 ? &quot;\u00B0&quot; : &quot;%&quot;);
                units[i].getStyleClass().add(&quot;settings-unit&quot;);

                if (i &gt; 0 &amp;&amp; i &lt; 3) {
                    // first row and opacity labels are always visible
                    // second and third row labels are not visible in Web page
                    labels[i].visibleProperty().bind(group.selectedToggleProperty().isNotEqualTo(webButton));
                }
                if (i &lt; 3) {
                    // sliders and fields shouldn't be visible in Web page
                    sliders[i].visibleProperty().bind(group.selectedToggleProperty().isNotEqualTo(webButton));
                    fields[i].visibleProperty().bind(group.selectedToggleProperty().isNotEqualTo(webButton));
                    units[i].visibleProperty().bind(group.selectedToggleProperty().isEqualTo(hsbButton));
                }
                int row = 1 + i;
                if (i == 3) {
                    // opacity row is shifted one gridPane row down
                    row++;
                }

                // JDK-8161449 - hide the opacity slider
                if (i == 3 &amp;&amp; !showOpacitySlider) {
                    continue;
                }

                settingsPane.add(labels[i], 1, row);
                settingsPane.add(sliders[i], 2, row);
                settingsPane.add(fields[i], 3, row);
                settingsPane.add(units[i], 4, row);
            }

            set(3, Properties.getColorPickerString(&quot;opacity_colon&quot;), 100, colorRectPane.alpha);

            hsbButton.setToggleGroup(group);
            rgbButton.setToggleGroup(group);
            webButton.setToggleGroup(group);
            group.selectedToggleProperty().addListener((observable, oldValue, newValue) -&gt; {
                if (newValue == null) {
                    group.selectToggle(oldValue);
                } else {
                    if (newValue == hsbButton) {
                        showHSBSettings();
                    } else if (newValue == rgbButton) {
                        showRGBSettings();
                    } else {
                        showWebSettings();
                    }
                }
            });
            group.selectToggle(hsbButton);

            buttonBox = new HBox();
            buttonBox.setId(&quot;buttons-hbox&quot;);

            Button saveButton = new Button(saveBtnText != null &amp;&amp; !saveBtnText.isEmpty() ? saveBtnText : Properties.getColorPickerString(&quot;Save&quot;));
            saveButton.setDefaultButton(true);
            saveButton.setOnAction(t -&gt; {
                if (onSave != null) {
                    onSave.run();
                }
                dialog.hide();
            });

            Button useButton = new Button(Properties.getColorPickerString(&quot;Use&quot;));
            useButton.setOnAction(t -&gt; {
                if (onUse != null) {
                    onUse.run();
                }
                dialog.hide();
            });

            Button cancelButton = new Button(Properties.getColorPickerString(&quot;Cancel&quot;));
            cancelButton.setCancelButton(true);
            cancelButton.setOnAction(e -&gt; {
                customColorProperty.set(getCurrentColor());
                if (onCancel != null) {
                    onCancel.run();
                }
                dialog.hide();
            });

            if (showUseBtn) {
                buttonBox.getChildren().addAll(saveButton, useButton, cancelButton);
            } else {
                buttonBox.getChildren().addAll(saveButton, cancelButton);
            }

            getChildren().addAll(currentAndNewColor, settingsPane, buttonBox);
        }

        private void showHSBSettings() {
            set(0, Properties.getColorPickerString(&quot;hue_colon&quot;), 360, colorRectPane.hue);
            set(1, Properties.getColorPickerString(&quot;saturation_colon&quot;), 100, colorRectPane.sat);
            set(2, Properties.getColorPickerString(&quot;brightness_colon&quot;), 100, colorRectPane.bright);
        }

        private void showRGBSettings() {
            set(0, Properties.getColorPickerString(&quot;red_colon&quot;), 255, colorRectPane.red);
            set(1, Properties.getColorPickerString(&quot;green_colon&quot;), 255, colorRectPane.green);
            set(2, Properties.getColorPickerString(&quot;blue_colon&quot;), 255, colorRectPane.blue);
        }

        private void showWebSettings() {
            labels[0].setText(Properties.getColorPickerString(&quot;web_colon&quot;));
        }

        private Property&lt;Number&gt;[] bindedProperties = new Property[4];

        private void set(int row, String caption, int maxValue, Property&lt;Number&gt; prop) {
            labels[row].setText(caption);
            if (bindedProperties[row] != null) {
                sliders[row].valueProperty().unbindBidirectional(bindedProperties[row]);
                fields[row].valueProperty().unbindBidirectional(bindedProperties[row]);
            }
            sliders[row].setMax(maxValue);
            sliders[row].valueProperty().bindBidirectional(prop);
            labels[row].setLabelFor(sliders[row]);
            fields[row].setMaxValue(maxValue);
            fields[row].valueProperty().bindBidirectional(prop);
            bindedProperties[row] = prop;
        }
    }

    static double clamp(double value) {
        return value &lt; 0 ? 0 : value &gt; 1 ? 1 : value;
    }

    private static LinearGradient createHueGradient() {
        double offset;
        Stop[] stops = new Stop[255];
        for (int y = 0; y &lt; 255; y++) {
            offset = (double) (1 - (1.0 / 255) * y);
            int h = (int) ((y / 255.0) * 360);
            stops[y] = new Stop(offset, Color.hsb(h, 1.0, 1.0));
        }
        return new LinearGradient(0f, 1f, 0f, 0f, true, CycleMethod.NO_CYCLE, stops);
    }

    private static int doubleToInt(double value) {
        return (int) (value * 255 + 0.5); // Adding 0.5 for rounding only
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/DatePickerContent.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control;

import java.time.DateTimeException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DecimalStyle;
import java.time.chrono.Chronology;
import java.time.chrono.ChronoLocalDate;
import java.time.temporal.ChronoUnit;
import java.time.temporal.ValueRange;
import java.time.temporal.WeekFields;
import java.time.YearMonth;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import static java.time.temporal.ChronoField.*;
import static java.time.temporal.ChronoUnit.*;

import com.sun.javafx.scene.control.skin.*;
import javafx.application.Platform;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.WeakChangeListener;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.DatePicker;
import javafx.scene.control.DateCell;
import javafx.scene.control.Label;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.ColumnConstraints;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.layout.StackPane;

import com.sun.javafx.scene.control.skin.resources.ControlResources;
import com.sun.javafx.scene.traversal.Direction;

import static com.sun.javafx.PlatformUtil.*;
import com.sun.javafx.scene.NodeHelper;

/**
 * The full content for the DatePicker popup. This class could
 * probably be used more or less as-is with an embeddable type of date
 * picker that doesn't use a popup.
 */
public class DatePickerContent extends VBox {
    protected DatePicker datePicker;
    private Button backMonthButton;
    private Button forwardMonthButton;
    private Button backYearButton;
    private Button forwardYearButton;
    private Label monthLabel;
    private Label yearLabel;
    protected GridPane gridPane;

    private int daysPerWeek;
    private List&lt;DateCell&gt; dayNameCells = new ArrayList&lt;DateCell&gt;();
    private List&lt;DateCell&gt; weekNumberCells = new ArrayList&lt;DateCell&gt;();
    protected List&lt;DateCell&gt; dayCells = new ArrayList&lt;DateCell&gt;();
    private LocalDate[] dayCellDates;
    private DateCell lastFocusedDayCell = null;

    final DateTimeFormatter monthFormatter =
        DateTimeFormatter.ofPattern(&quot;MMMM&quot;);

    final DateTimeFormatter monthFormatterSO =
            DateTimeFormatter.ofPattern(&quot;LLLL&quot;); // Standalone month name

    final DateTimeFormatter yearFormatter =
        DateTimeFormatter.ofPattern(&quot;y&quot;);

    final DateTimeFormatter yearWithEraFormatter =
        DateTimeFormatter.ofPattern(&quot;GGGGy&quot;); // For Japanese. What to use for others??

    final DateTimeFormatter weekNumberFormatter =
        DateTimeFormatter.ofPattern(&quot;w&quot;);

    final DateTimeFormatter weekDayNameFormatter =
            DateTimeFormatter.ofPattern(&quot;ccc&quot;); // Standalone day name

    final DateTimeFormatter dayCellFormatter =
        DateTimeFormatter.ofPattern(&quot;d&quot;);

    static String getString(String key) {
        return ControlResources.getString(&quot;DatePicker.&quot;+key);
    }

    public DatePickerContent(final DatePicker datePicker) {
        this.datePicker = datePicker;

        getStyleClass().add(&quot;date-picker-popup&quot;);

        daysPerWeek = getDaysPerWeek();

        {
            LocalDate date = datePicker.getValue();
            displayedYearMonth.set((date != null) ? YearMonth.from(date) : YearMonth.now());
        }

        displayedYearMonth.addListener((observable, oldValue, newValue) -&gt; {
            updateValues();
        });


        getChildren().add(createMonthYearPane());

        gridPane = new GridPane() {
            @Override protected double computePrefWidth(double height) {
                final double width = super.computePrefWidth(height);

                // RT-30903: Make sure width snaps to pixel when divided by
                // number of columns. GridPane doesn't do this with percentage
                // width constraints. See GridPane.adjustColumnWidths().
                final int nCols = daysPerWeek + (datePicker.isShowWeekNumbers() ? 1 : 0);
                final double snaphgap = snapSpaceX(getHgap());
                final double left = snapSpaceX(getInsets().getLeft());
                final double right = snapSpaceX(getInsets().getRight());
                final double hgaps = snaphgap * (nCols - 1);
                final double contentWidth = width - left - right - hgaps;
                return ((snapSizeX(contentWidth / nCols)) * nCols) + left + right + hgaps;
            }

            @Override protected void layoutChildren() {
                // Prevent AssertionError in GridPane
                if (getWidth() &gt; 0 &amp;&amp; getHeight() &gt; 0) {
                    super.layoutChildren();
                }
            }
        };
        gridPane.setFocusTraversable(true);
        gridPane.getStyleClass().add(&quot;calendar-grid&quot;);
        gridPane.setVgap(-1);
        gridPane.setHgap(-1);

        // Add a focus owner listener to Scene when it becomes available.
        final WeakChangeListener&lt;Node&gt; weakFocusOwnerListener =
            new WeakChangeListener&lt;Node&gt;((ov2, oldFocusOwner, newFocusOwner) -&gt; {
                if (newFocusOwner == gridPane) {
                    if (oldFocusOwner instanceof DateCell) {
                        // Backwards traversal, skip gridPane.
                        NodeHelper.traverse(gridPane, Direction.PREVIOUS);
                    } else {
                        // Forwards traversal, pass focus to day cell.
                        if (lastFocusedDayCell != null) {
                            Platform.runLater(() -&gt; {
                                lastFocusedDayCell.requestFocus();
                            });
                        } else {
                            clearFocus();
                        }
                    }
                }
            });
        gridPane.sceneProperty().addListener(new WeakChangeListener&lt;Scene&gt;((ov, oldScene, newScene) -&gt; {
            if (oldScene != null) {
                oldScene.focusOwnerProperty().removeListener(weakFocusOwnerListener);
            }
            if (newScene != null) {
                Platform.runLater(() -&gt; {
                    newScene.focusOwnerProperty().addListener(weakFocusOwnerListener);
                });
            }
        }));
        if (gridPane.getScene() != null) {
            gridPane.getScene().focusOwnerProperty().addListener(weakFocusOwnerListener);
        }

        // get the weekday labels starting with the weekday that is the
        // first-day-of-the-week according to the locale in the
        // displayed LocalDate
        for (int i = 0; i &lt; daysPerWeek; i++) {
            DateCell cell = new DateCell();
            cell.getStyleClass().add(&quot;day-name-cell&quot;);
            dayNameCells.add(cell);
        }

        // Week number column
        for (int i = 0; i &lt; 6; i++) {
            DateCell cell = new DateCell();
            cell.getStyleClass().add(&quot;week-number-cell&quot;);
            weekNumberCells.add(cell);
        }

        createDayCells();
        updateGrid();
        getChildren().add(gridPane);

        refresh();

        // RT-30511: This prevents key events from reaching the popup's owner.
        addEventHandler(KeyEvent.ANY, e -&gt; {
            Node node = getScene().getFocusOwner();
            if (node instanceof DateCell) {
                lastFocusedDayCell = (DateCell)node;
            }

            if (e.getEventType() == KeyEvent.KEY_PRESSED) {
                switch (e.getCode()) {
                  case HOME:
                      goToDate(LocalDate.now(), true);
                      e.consume();
                      break;


                  case PAGE_UP:
                      if ((isMac() &amp;&amp; e.isMetaDown()) || (!isMac() &amp;&amp; e.isControlDown())) {
                          if (!backYearButton.isDisabled()) {
                              forward(-1, YEARS, true);
                          }
                      } else {
                          if (!backMonthButton.isDisabled()) {
                              forward(-1, MONTHS, true);
                          }
                      }
                      e.consume();
                      break;

                  case PAGE_DOWN:
                      if ((isMac() &amp;&amp; e.isMetaDown()) || (!isMac() &amp;&amp; e.isControlDown())) {
                          if (!forwardYearButton.isDisabled()) {
                              forward(1, YEARS, true);
                          }
                      } else {
                          if (!forwardMonthButton.isDisabled()) {
                              forward(1, MONTHS, true);
                          }
                      }
                      e.consume();
                      break;
                }

                node = getScene().getFocusOwner();
                if (node instanceof DateCell) {
                    lastFocusedDayCell = (DateCell)node;
                }
            }

            // Consume all key events except those that control
            // showing the popup and traversal.
            switch (e.getCode()) {
              case F4:
              case F10:
              case UP:
              case DOWN:
              case LEFT:
              case RIGHT:
              case TAB:
                    break;

              case ESCAPE:
                datePicker.hide();
                e.consume();
                break;

              default:
                e.consume();
            }
        });
    }

    private ObjectProperty&lt;YearMonth&gt; displayedYearMonth =
        new SimpleObjectProperty&lt;YearMonth&gt;(this, &quot;displayedYearMonth&quot;);

    public ObjectProperty&lt;YearMonth&gt; displayedYearMonthProperty() {
        return displayedYearMonth;
    }


    protected BorderPane createMonthYearPane() {
        BorderPane monthYearPane = new BorderPane();
        monthYearPane.getStyleClass().add(&quot;month-year-pane&quot;);

        // Month spinner

        HBox monthSpinner = new HBox();
        monthSpinner.getStyleClass().add(&quot;spinner&quot;);

        backMonthButton = new Button();
        backMonthButton.getStyleClass().add(&quot;left-button&quot;);

<A NAME="1"></A>        forwardMonthButton = new Button();
        forwardMonthButton.getStyleClass().add(&quot;right-button&quot;);

        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#1',2,'match49-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>StackPane leftMonthArrow = new StackPane();
        leftMonthArrow.getStyleClass().add(&quot;left-arrow&quot;);
        leftMonthArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        backMonthButton.setGraphic(leftMonthArrow);

        StackPane rightMonthArrow = new StackPane();
        rightMonthArrow.getStyleClass().add(&quot;right-arrow&quot;);
        rightMonthArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        forwardMonthButton.setGraphic(rightMonthArrow);


        backMonthButton.setOnAction</B></FONT>(t -&gt; {
            forward(-1, MONTHS, false);
        });

        monthLabel = new Label();
        monthLabel.getStyleClass().add(&quot;spinner-label&quot;);
        monthLabel.fontProperty().addListener((o, ov, nv) -&gt; {
            updateMonthLabelWidth();
        });

        forwardMonthButton.setOnAction(t -&gt; {
            forward(1, MONTHS, false);
        });

        monthSpinner.getChildren().addAll(backMonthButton, monthLabel, forwardMonthButton);
        monthYearPane.setLeft(monthSpinner);

        // Year spinner

        HBox yearSpinner = new HBox();
        yearSpinner.getStyleClass().add(&quot;spinner&quot;);

        backYearButton = new Button();
        backYearButton.getStyleClass().add(&quot;left-button&quot;);

        forwardYearButton = new Button();
        forwardYearButton.getStyleClass().add(&quot;right-button&quot;);

        StackPane leftYearArrow = new StackPane();
        leftYearArrow.getStyleClass().add(&quot;left-arrow&quot;);
        leftYearArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        backYearButton.setGraphic(leftYearArrow);

        StackPane rightYearArrow = new StackPane();
        rightYearArrow.getStyleClass().add(&quot;right-arrow&quot;);
        rightYearArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
        forwardYearButton.setGraphic(rightYearArrow);


        backYearButton.setOnAction(t -&gt; {
            forward(-1, YEARS, false);
        });

        yearLabel = new Label();
        yearLabel.getStyleClass().add(&quot;spinner-label&quot;);

        forwardYearButton.setOnAction(t -&gt; {
            forward(1, YEARS, false);
        });

        yearSpinner.getChildren().addAll(backYearButton, yearLabel, forwardYearButton);
        yearSpinner.setFillHeight(false);
        monthYearPane.setRight(yearSpinner);

        return monthYearPane;
    }

    private void refresh() {
        updateMonthLabelWidth();
        updateDayNameCells();
        updateValues();
    }

    public void updateValues() {
        // Note: Preserve this order, as DatePickerHijrahContent needs
        // updateDayCells before updateMonthYearPane().
        updateWeeknumberDateCells();
        updateDayCells();
        updateMonthYearPane();
    }

    public void updateGrid() {
        gridPane.getColumnConstraints().clear();
        gridPane.getChildren().clear();

        int nCols = daysPerWeek + (datePicker.isShowWeekNumbers() ? 1 : 0);

        ColumnConstraints columnConstraints = new ColumnConstraints();
        columnConstraints.setPercentWidth(100); // Treated as weight
        for (int i = 0; i &lt; nCols; i++) {
            gridPane.getColumnConstraints().add(columnConstraints);
        }

        for (int i = 0; i &lt; daysPerWeek; i++) {
            gridPane.add(dayNameCells.get(i), i + nCols - daysPerWeek, 1);  // col, row
        }

        // Week number column
        if (datePicker.isShowWeekNumbers()) {
            for (int i = 0; i &lt; 6; i++) {
                gridPane.add(weekNumberCells.get(i), 0, i + 2);  // col, row
            }
        }

        // setup: 6 rows of daysPerWeek (which is the maximum number of cells required in the worst case layout)
        for (int row = 0; row &lt; 6; row++) {
            for (int col = 0; col &lt; daysPerWeek; col++) {
                gridPane.add(dayCells.get(row*daysPerWeek+col), col + nCols - daysPerWeek, row + 2);
            }
        }
    }

    public void updateDayNameCells() {
        // first day of week, 1 = monday, 7 = sunday
        int firstDayOfWeek = WeekFields.of(getLocale()).getFirstDayOfWeek().getValue();

        // july 13th 2009 is a Monday, so a firstDayOfWeek=1 must come out of the 13th
        LocalDate date = LocalDate.of(2009, 7, 12 + firstDayOfWeek);
        for (int i = 0; i &lt; daysPerWeek; i++) {
            String name = weekDayNameFormatter.withLocale(getLocale()).format(date.plus(i, DAYS));
            dayNameCells.get(i).setText(titleCaseWord(name));
        }
    }

    public void updateWeeknumberDateCells() {
        if (datePicker.isShowWeekNumbers()) {
            final Locale locale = getLocale();
            final int maxWeeksPerMonth = 6; // TODO: Get this from chronology?

            LocalDate firstOfMonth = displayedYearMonth.get().atDay(1);
            for (int i = 0; i &lt; maxWeeksPerMonth; i++) {
                LocalDate date = firstOfMonth.plus(i, WEEKS);
                // Use a formatter to ensure correct localization,
                // such as when Thai numerals are required.
                String cellText =
                    weekNumberFormatter.withLocale(locale)
                                       .withDecimalStyle(DecimalStyle.of(locale))
                                       .format(date);
                weekNumberCells.get(i).setText(cellText);
            }
        }
    }

    public void updateDayCells() {
        Locale locale = getLocale();
        Chronology chrono = getPrimaryChronology();
        int firstOfMonthIdx = determineFirstOfMonthDayOfWeek();
        YearMonth curMonth = displayedYearMonth.get();

        // RT-31075: The following are now set in the try-catch block.
        YearMonth prevMonth = null;
        YearMonth nextMonth = null;
        int daysInCurMonth = -1;
        int daysInPrevMonth = -1;
        int daysInNextMonth = -1;

        for (int i = 0; i &lt; 6 * daysPerWeek; i++) {
            DateCell dayCell = dayCells.get(i);
            dayCell.getStyleClass().setAll(&quot;cell&quot;, &quot;date-cell&quot;, &quot;day-cell&quot;);
            dayCell.setDisable(false);
            dayCell.setStyle(null);
            dayCell.setGraphic(null);
            dayCell.setTooltip(null);

            try {
                if (daysInCurMonth == -1) {
                    daysInCurMonth = curMonth.lengthOfMonth();
                }
                YearMonth month = curMonth;
                int day = i - firstOfMonthIdx + 1;
                //int index = firstOfMonthIdx + i - 1;
                if (i &lt; firstOfMonthIdx) {
                    if (prevMonth == null) {
                        prevMonth = curMonth.minusMonths(1);
                        daysInPrevMonth = prevMonth.lengthOfMonth();
                    }
                    month = prevMonth;
                    day = i + daysInPrevMonth - firstOfMonthIdx + 1;
                    dayCell.getStyleClass().add(&quot;previous-month&quot;);
                } else if (i &gt;= firstOfMonthIdx + daysInCurMonth) {
                    if (nextMonth == null) {
                        nextMonth = curMonth.plusMonths(1);
                        daysInNextMonth = nextMonth.lengthOfMonth();
                    }
                    month = nextMonth;
                    day = i - daysInCurMonth - firstOfMonthIdx + 1;
                    dayCell.getStyleClass().add(&quot;next-month&quot;);
                }
                LocalDate date = month.atDay(day);
                dayCellDates[i] = date;
                ChronoLocalDate cDate = chrono.date(date);

                dayCell.setDisable(false);

                if (isToday(date)) {
                    dayCell.getStyleClass().add(&quot;today&quot;);
                }

                if (date.equals(datePicker.getValue())) {
                    dayCell.getStyleClass().add(&quot;selected&quot;);
                }

                String cellText =
                    dayCellFormatter.withLocale(locale)
                                    .withChronology(chrono)
                                    .withDecimalStyle(DecimalStyle.of(locale))
                                    .format(cDate);
                dayCell.setText(cellText);

                dayCell.updateItem(date, false);
            } catch (DateTimeException ex) {
                // Date is out of range.
                // System.err.println(dayCellDate(dayCell) + &quot; &quot; + ex);
                dayCell.setText(&quot; &quot;);
                dayCell.setDisable(true);
            }
        }
    }

    private int getDaysPerWeek() {
        ValueRange range = getPrimaryChronology().range(DAY_OF_WEEK);
        return (int)(range.getMaximum() - range.getMinimum() + 1);
    }

    private int getMonthsPerYear() {
        ValueRange range = getPrimaryChronology().range(MONTH_OF_YEAR);
        return (int)(range.getMaximum() - range.getMinimum() + 1);
    }

    private void updateMonthLabelWidth() {
        if (monthLabel != null) {
            int monthsPerYear = getMonthsPerYear();
            double width = 0;
            for (int i = 0; i &lt; monthsPerYear; i++) {
                YearMonth yearMonth = displayedYearMonth.get().withMonth(i + 1);
                String name = monthFormatterSO.withLocale(getLocale()).format(yearMonth);
                if (Character.isDigit(name.charAt(0))) {
                    // Fallback. The standalone format returned a number, so use standard format instead.
                    name = monthFormatter.withLocale(getLocale()).format(yearMonth);
                }
                width = Math.max(width, Utils.computeTextWidth(monthLabel.getFont(), name, 0));
            }
            monthLabel.setMinWidth(width);
        }
    }

    protected void updateMonthYearPane() {
        YearMonth yearMonth = displayedYearMonth.get();
        String str = formatMonth(yearMonth);
        monthLabel.setText(str);

        str = formatYear(yearMonth);
        yearLabel.setText(str);
        double width = Utils.computeTextWidth(yearLabel.getFont(), str, 0);
        if (width &gt; yearLabel.getMinWidth()) {
            yearLabel.setMinWidth(width);
        }

        Chronology chrono = datePicker.getChronology();
        LocalDate firstDayOfMonth = yearMonth.atDay(1);
        backMonthButton.setDisable(!isValidDate(chrono, firstDayOfMonth, -1, DAYS));
        forwardMonthButton.setDisable(!isValidDate(chrono, firstDayOfMonth, +1, MONTHS));
        backYearButton.setDisable(!isValidDate(chrono, firstDayOfMonth, -1, YEARS));
        forwardYearButton.setDisable(!isValidDate(chrono, firstDayOfMonth, +1, YEARS));
    }

    private String formatMonth(YearMonth yearMonth) {
        Chronology chrono = getPrimaryChronology();
        try {
            ChronoLocalDate cDate = chrono.date(yearMonth.atDay(1));

            String str = monthFormatterSO.withLocale(getLocale())
                                         .withChronology(chrono)
                                         .format(cDate);
            if (Character.isDigit(str.charAt(0))) {
                // Fallback. The standalone format returned a number, so use standard format instead.
                str = monthFormatter.withLocale(getLocale())
                                    .withChronology(chrono)
                                    .format(cDate);
            }
            return titleCaseWord(str);
        } catch (DateTimeException ex) {
            // Date is out of range.
            return &quot;&quot;;
        }
    }

    private String formatYear(YearMonth yearMonth) {
        Chronology chrono = getPrimaryChronology();
        try {
            DateTimeFormatter formatter = yearFormatter;
            ChronoLocalDate cDate = chrono.date(yearMonth.atDay(1));
            int era = cDate.getEra().getValue();
            int nEras = chrono.eras().size();

            /*if (cDate.get(YEAR) &lt; 0) {
                formatter = yearForNegYearFormatter;
            } else */
            if ((nEras == 2 &amp;&amp; era == 0) || nEras &gt; 2) {
                formatter = yearWithEraFormatter;
            }

            // Fixme: Format Japanese era names with Japanese text.
            String str = formatter.withLocale(getLocale())
                                  .withChronology(chrono)
                                  .withDecimalStyle(DecimalStyle.of(getLocale()))
                                  .format(cDate);

            return str;
        } catch (DateTimeException ex) {
            // Date is out of range.
            return &quot;&quot;;
        }
    }

    // Ensures that month and day names are titlecased (capitalized).
    private String titleCaseWord(String str) {
        if (str.length() &gt; 0) {
            int firstChar = str.codePointAt(0);
            if (!Character.isTitleCase(firstChar)) {
                str = new String(new int[] { Character.toTitleCase(firstChar) }, 0, 1) +
                      str.substring(Character.offsetByCodePoints(str, 0, 1));
            }
        }
        return str;
    }



    /**
     * determine on which day of week idx the first of the months is
     */
    private int determineFirstOfMonthDayOfWeek() {
        // determine with which cell to start
        int firstDayOfWeek = WeekFields.of(getLocale()).getFirstDayOfWeek().getValue();
        int firstOfMonthIdx = displayedYearMonth.get().atDay(1).getDayOfWeek().getValue() - firstDayOfWeek;
        if (firstOfMonthIdx &lt; 0) {
            firstOfMonthIdx += daysPerWeek;
        }
        return firstOfMonthIdx;
    }

    private boolean isToday(LocalDate localDate) {
        return (localDate.equals(LocalDate.now()));
    }

    protected LocalDate dayCellDate(DateCell dateCell) {
        assert (dayCellDates != null);
        return dayCellDates[dayCells.indexOf(dateCell)];
    }

    // public for behavior class
    public void goToDayCell(DateCell dateCell, int offset, ChronoUnit unit, boolean focusDayCell) {
        goToDate(dayCellDate(dateCell).plus(offset, unit), focusDayCell);
    }

    protected void forward(int offset, ChronoUnit unit, boolean focusDayCell) {
        YearMonth yearMonth = displayedYearMonth.get();
        DateCell dateCell = lastFocusedDayCell;
        if (dateCell == null || !dayCellDate(dateCell).getMonth().equals(yearMonth.getMonth())) {
            dateCell = findDayCellForDate(yearMonth.atDay(1));
        }
        goToDayCell(dateCell, offset, unit, focusDayCell);
    }

    // public for behavior class
    public void goToDate(LocalDate date, boolean focusDayCell) {
        if (isValidDate(datePicker.getChronology(), date)) {
            displayedYearMonth.set(YearMonth.from(date));
            if (focusDayCell) {
                findDayCellForDate(date).requestFocus();
            }
        }
    }

    // public for behavior class
    public void selectDayCell(DateCell dateCell) {
        datePicker.setValue(dayCellDate(dateCell));
        datePicker.hide();
    }

    private DateCell findDayCellForDate(LocalDate date) {
        for (int i = 0; i &lt; dayCellDates.length; i++) {
            if (date.equals(dayCellDates[i])) {
                return dayCells.get(i);
            }
        }
        return dayCells.get(dayCells.size()/2+1);
    }

    public void clearFocus() {
        LocalDate focusDate = datePicker.getValue();
        if (focusDate == null) {
            focusDate = LocalDate.now();
        }
        if (YearMonth.from(focusDate).equals(displayedYearMonth.get())) {
            // focus date
            goToDate(focusDate, true);
        } else {
            // focus month spinner (should not happen)
            backMonthButton.requestFocus();
        }

        // RT-31857
        if (backMonthButton.getWidth() == 0) {
            backMonthButton.requestLayout();
            forwardMonthButton.requestLayout();
            backYearButton.requestLayout();
            forwardYearButton.requestLayout();
        }
    }

    protected void createDayCells() {
        final EventHandler&lt;MouseEvent&gt; dayCellActionHandler = ev -&gt; {
            if (ev.getButton() != MouseButton.PRIMARY) {
                return;
            }

            DateCell dayCell = (DateCell)ev.getSource();
            selectDayCell(dayCell);
            lastFocusedDayCell = dayCell;
        };

        for (int row = 0; row &lt; 6; row++) {
            for (int col = 0; col &lt; daysPerWeek; col++) {
                DateCell dayCell = createDayCell();
                dayCell.addEventHandler(MouseEvent.MOUSE_CLICKED, dayCellActionHandler);
                dayCells.add(dayCell);
            }
        }

        dayCellDates = new LocalDate[6 * daysPerWeek];
    }

    private DateCell createDayCell() {
        DateCell cell = null;
        if (datePicker.getDayCellFactory() != null) {
            cell = datePicker.getDayCellFactory().call(datePicker);
        }
        if (cell == null) {
            cell = new DateCell();
        }

        return cell;
    }

    protected Locale getLocale() {
        return Locale.getDefault(Locale.Category.FORMAT);
    }

    /**
     * The primary chronology for display. This may be overridden to
     * be different than the DatePicker chronology. For example
     * DatePickerHijrahContent uses ISO as primary and Hijrah as a
     * secondary chronology.
     */
    protected Chronology getPrimaryChronology() {
        return datePicker.getChronology();
    }

    protected boolean isValidDate(Chronology chrono, LocalDate date, int offset, ChronoUnit unit) {
        if (date != null) {
            try {
                return isValidDate(chrono, date.plus(offset, unit));
            } catch (DateTimeException ex) {
            }
        }
        return false;
    }

    protected boolean isValidDate(Chronology chrono, LocalDate date) {
        try {
            if (date != null) {
                chrono.date(date);
            }
            return true;
        } catch (DateTimeException ex) {
            return false;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/TextAreaBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.PlatformUtil;
import com.sun.javafx.geom.transform.Affine3D;
import com.sun.javafx.scene.control.Properties;
import javafx.scene.control.skin.TextAreaSkin;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.scene.Scene;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.TextArea;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.scene.input.ContextMenuEvent;
import com.sun.javafx.scene.control.inputmap.InputMap;
import com.sun.javafx.scene.control.inputmap.KeyBinding;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.text.HitInfo;
import javafx.stage.Screen;
import javafx.stage.Window;

import java.util.function.Predicate;

import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;
import com.sun.javafx.stage.WindowHelper;
import static javafx.scene.control.skin.TextInputControlSkin.TextUnit;
import static javafx.scene.control.skin.TextInputControlSkin.Direction;
import static javafx.scene.input.KeyCode.*;


/**
 * Text area behavior.
 */
public class TextAreaBehavior extends TextInputControlBehavior&lt;TextArea&gt; {
    private TextAreaSkin skin;
    private TwoLevelFocusBehavior tlFocus;

    /**************************************************************************
     * Constructors                                                           *
     *************************************************************************/

    public TextAreaBehavior(final TextArea c) {
        super(c);

        if (Properties.IS_TOUCH_SUPPORTED) {
            contextMenu.getStyleClass().add(&quot;text-input-context-menu&quot;);
        }

        // some of the mappings are only valid when the control is editable, or
        // only on certain platforms, so we create the following predicates that filters out the mapping when the
        // control is not in the correct state / on the correct platform
<A NAME="4"></A>        final Predicate&lt;KeyEvent&gt; validWhenEditable = e -&gt; !c.isEditable();

        // Add these bindings as a child input map, so they take precedence
        InputMap&lt;TextArea&gt; textAreaInputMap = <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#4',2,'match49-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new InputMap&lt;&gt;(c);
        textAreaInputMap.getMappings().addAll(
            keyMapping(HOME,      e -&gt; lineStart(false)),
            keyMapping(END,       e -&gt; lineEnd(false)),
            keyMapping(UP,        e -&gt; skin.moveCaret(TextUnit.LINE, Direction.UP,   false)),
            keyMapping(DOWN,      e -&gt; skin.moveCaret(TextUnit.LINE, Direction.DOWN, false)),
            keyMapping(PAGE_UP,   e -&gt; skin.moveCaret</B></FONT>(TextUnit.PAGE, Direction.UP,   false)),
            keyMapping(PAGE_DOWN, e -&gt; skin.moveCaret(TextUnit.PAGE, Direction.DOWN, false)),

            keyMapping(new KeyBinding(HOME).shift(),      e -&gt; lineStart(true)),
            keyMapping(new KeyBinding(END).shift(),       e -&gt; lineEnd(true)),
            keyMapping(new KeyBinding(UP).shift(),        e -&gt; skin.moveCaret(TextUnit.LINE, Direction.UP,   true)),
            keyMapping(new KeyBinding(DOWN).shift(),      e -&gt; skin.moveCaret(TextUnit.LINE, Direction.DOWN, true)),
            keyMapping(new KeyBinding(PAGE_UP).shift(),   e -&gt; skin.moveCaret(TextUnit.PAGE, Direction.UP,   true)),
            keyMapping(new KeyBinding(PAGE_DOWN).shift(), e -&gt; skin.moveCaret(TextUnit.PAGE, Direction.DOWN, true)),

            // editing-only mappings
            keyMapping(new KeyBinding(ENTER), e -&gt; insertNewLine(), validWhenEditable),
            keyMapping(new KeyBinding(TAB), e -&gt; insertTab(), validWhenEditable)
        );
        addDefaultChildMap(getInputMap(), textAreaInputMap);

        // mac os specific mappings
        InputMap&lt;TextArea&gt; macOsInputMap = new InputMap&lt;&gt;(c);
        macOsInputMap.setInterceptor(e -&gt; !PlatformUtil.isMac());
        macOsInputMap.getMappings().addAll(
            // Mac OS specific mappings
            keyMapping(new KeyBinding(LEFT).shortcut(),  e -&gt; lineStart(false)),
            keyMapping(new KeyBinding(RIGHT).shortcut(), e -&gt; lineEnd(false)),
            keyMapping(new KeyBinding(UP).shortcut(),    e -&gt; c.home()),
            keyMapping(new KeyBinding(DOWN).shortcut(),  e -&gt; c.end()),

            keyMapping(new KeyBinding(LEFT).shortcut().shift(),  e -&gt; lineStart(true)),
            keyMapping(new KeyBinding(RIGHT).shortcut().shift(), e -&gt; lineEnd(true)),
            keyMapping(new KeyBinding(UP).shortcut().shift(),    e -&gt; selectHomeExtend()),
            keyMapping(new KeyBinding(DOWN).shortcut().shift(),  e -&gt; selectEndExtend()),

            keyMapping(new KeyBinding(UP).alt(),           e -&gt; skin.moveCaret(TextUnit.PARAGRAPH, Direction.UP,   false)),
            keyMapping(new KeyBinding(DOWN).alt(),         e -&gt; skin.moveCaret(TextUnit.PARAGRAPH, Direction.DOWN, false)),
            keyMapping(new KeyBinding(UP).alt().shift(),   e -&gt; skin.moveCaret(TextUnit.PARAGRAPH, Direction.UP,   true)),
            keyMapping(new KeyBinding(DOWN).alt().shift(), e -&gt; skin.moveCaret(TextUnit.PARAGRAPH, Direction.DOWN, true))
        );
        addDefaultChildMap(textAreaInputMap, macOsInputMap);

        // windows / linux specific mappings
        InputMap&lt;TextArea&gt; nonMacOsInputMap = new InputMap&lt;&gt;(c);
        nonMacOsInputMap.setInterceptor(e -&gt; PlatformUtil.isMac());
        nonMacOsInputMap.getMappings().addAll(
            keyMapping(new KeyBinding(UP).ctrl(),           e -&gt; skin.moveCaret(TextUnit.PARAGRAPH, Direction.UP,   false)),
            keyMapping(new KeyBinding(DOWN).ctrl(),         e -&gt; skin.moveCaret(TextUnit.PARAGRAPH, Direction.DOWN, false)),
            keyMapping(new KeyBinding(UP).ctrl().shift(),   e -&gt; skin.moveCaret(TextUnit.PARAGRAPH, Direction.UP,   true)),
            keyMapping(new KeyBinding(DOWN).ctrl().shift(), e -&gt; skin.moveCaret(TextUnit.PARAGRAPH, Direction.DOWN, true))
        );
        addDefaultChildMap(textAreaInputMap, nonMacOsInputMap);

        addKeyPadMappings(textAreaInputMap);

        // Register for change events
        c.focusedProperty().addListener(new ChangeListener&lt;Boolean&gt;() {
            @Override
            public void changed(ObservableValue&lt;? extends Boolean&gt; observable, Boolean oldValue, Boolean newValue) {
                // NOTE: The code in this method is *almost* and exact copy of what is in TextFieldBehavior.
                // The only real difference is that TextFieldBehavior selects all the text when the control
                // receives focus (when not gained by mouse click), whereas TextArea doesn't, and also the
                // TextArea doesn't lose selection on focus lost, whereas the TextField does.
                final TextArea textArea = getNode();
                if (textArea.isFocused()) {
                    if (PlatformUtil.isIOS()) {
                        // Special handling of focus on iOS is required to allow to
                        // control native keyboard, because native keyboard is popped-up only when native
                        // text component gets focus. When we have JFX keyboard we can remove this code
                        final Bounds bounds = textArea.getBoundsInParent();
                        double w = bounds.getWidth();
                        double h = bounds.getHeight();
                        Affine3D trans = TextFieldBehavior.calculateNodeToSceneTransform(textArea);
                        String text = textArea.textProperty().getValueSafe();

                        // we need to display native text input component on the place where JFX component is drawn
                        // all parameters needed to do that are passed to native impl. here
                        WindowHelper.getPeer(textArea.getScene().getWindow()).requestInput(
                                text, TextFieldBehavior.TextInputTypes.TEXT_AREA.ordinal(), w, h,
                                trans.getMxx(), trans.getMxy(), trans.getMxz(), trans.getMxt(),
                                trans.getMyx(), trans.getMyy(), trans.getMyz(), trans.getMyt(),
                                trans.getMzx(), trans.getMzy(), trans.getMzz(), trans.getMzt());
                    }
                    if (!focusGainedByMouseClick) {
                        setCaretAnimating(true);
                    }
                } else {
//                    skin.hideCaret();
                    if (PlatformUtil.isIOS() &amp;&amp; textArea.getScene() != null) {
                        // releasing the focus =&gt; we need to hide the native component and also native keyboard
                        WindowHelper.getPeer(textArea.getScene().getWindow()).releaseInput();
                    }
                    focusGainedByMouseClick = false;
                    setCaretAnimating(false);
                }
            }
        });

        // Only add this if we're on an embedded platform that supports 5-button navigation
        if (Utils.isTwoLevelFocus()) {
            tlFocus = new TwoLevelFocusBehavior(c); // needs to be last.
        }
    }

    @Override public void dispose() {
        if (tlFocus != null) tlFocus.dispose();
        super.dispose();
    }

    // An unholy back-reference!
    public void setTextAreaSkin(TextAreaSkin skin) {
        this.skin = skin;
    }

    private void insertNewLine() {
        setEditing(true);
        getNode().replaceSelection(&quot;\n&quot;);
        setEditing(false);
    }

    private void insertTab() {
        setEditing(true);
        getNode().replaceSelection(&quot;\t&quot;);
        setEditing(false);
    }

    @Override protected void deleteChar(boolean previous) {
        if (previous) {
            getNode().deletePreviousChar();
        } else {
            getNode().deleteNextChar();
        }
    }

    @Override protected void deleteFromLineStart() {
        TextArea textArea = getNode();
        int end = textArea.getCaretPosition();

        if (end &gt; 0) {
            lineStart(false);
            int start = textArea.getCaretPosition();
            if (end &gt; start) {
                replaceText(start, end, &quot;&quot;);
            }
        }
    }

    private void lineStart(boolean select) {
        skin.moveCaret(TextUnit.LINE, Direction.BEGINNING, select);
    }

    private void lineEnd(boolean select) {
        skin.moveCaret(TextUnit.LINE, Direction.END, select);
    }

    @Override protected void replaceText(int start, int end, String txt) {
        getNode().replaceText(start, end, txt);
    }

    /**
     * If the focus is gained via response to a mouse click, then we don't
     * want to select all the text even if selectOnFocus is true.
     */
    private boolean focusGainedByMouseClick = false; // TODO!!
    private boolean shiftDown = false;
    private boolean deferClick = false;

    @Override public void mousePressed(MouseEvent e) {
        TextArea textArea = getNode();
        // We never respond to events if disabled
        if (!textArea.isDisabled()) {
            // If the text field doesn't have focus, then we'll attempt to set
            // the focus and we'll indicate that we gained focus by a mouse
            // click, TODO which will then NOT honor the selectOnFocus variable
            // of the textInputControl
            if (!textArea.isFocused()) {
                focusGainedByMouseClick = true;
                textArea.requestFocus();
            }

            // stop the caret animation
            setCaretAnimating(false);
            // only if there is no selection should we see the caret
//            setCaretOpacity(if (textInputControl.dot == textInputControl.mark) then 1.0 else 0.0);

            // if the primary button was pressed
            if (e.getButton() == MouseButton.PRIMARY &amp;&amp; !(e.isMiddleButtonDown() || e.isSecondaryButtonDown())) {
                HitInfo hit = skin.getIndex(e.getX(), e.getY());
                int i = hit.getInsertionIndex();
                final int anchor = textArea.getAnchor();
                final int caretPosition = textArea.getCaretPosition();
                if (e.getClickCount() &lt; 2 &amp;&amp;
                    (e.isSynthesized() ||
                     (anchor != caretPosition &amp;&amp;
                      ((i &gt; anchor &amp;&amp; i &lt; caretPosition) || (i &lt; anchor &amp;&amp; i &gt; caretPosition))))) {
                    // if there is a selection, then we will NOT handle the
                    // press now, but will defer until the release. If you
                    // select some text and then press down, we change the
                    // caret and wait to allow you to drag the text (TODO).
                    // When the drag concludes, then we handle the click

                    deferClick = true;
                    // TODO start a timer such that after some millis we
                    // switch into text dragging mode, change the cursor
                    // to indicate the text can be dragged, etc.
                } else if (!(e.isControlDown() || e.isAltDown() || e.isShiftDown() || e.isMetaDown() || e.isShortcutDown())) {
                    switch (e.getClickCount()) {
                        case 1: skin.positionCaret(hit, false); break;
                        case 2: mouseDoubleClick(hit); break;
                        case 3: mouseTripleClick(hit); break;
                        default: // no-op
                    }
                } else if (e.isShiftDown() &amp;&amp; !(e.isControlDown() || e.isAltDown() || e.isMetaDown() || e.isShortcutDown()) &amp;&amp; e.getClickCount() == 1) {
                    // didn't click inside the selection, so select
                    shiftDown = true;
                    // if we are on mac os, then we will accumulate the
                    // selection instead of just moving the dot. This happens
                    // by figuring out past which (dot/mark) are extending the
                    // selection, and set the mark to be the other side and
                    // the dot to be the new position.
                    // everywhere else we just move the dot.
                    if (isMac()) {
                        textArea.extendSelection(i);
                    } else {
                        skin.positionCaret(hit, true);
                    }
                }
//                 skin.setForwardBias(hit.isLeading());
//                if (textInputControl.editable)
//                    displaySoftwareKeyboard(true);
            }
            if (contextMenu.isShowing()) {
                contextMenu.hide();
            }
        }
    }

    @Override public void mouseDragged(MouseEvent e) {
        final TextArea textArea = getNode();
        // we never respond to events if disabled, but we do notify any onXXX
        // event listeners on the control
        if (!textArea.isDisabled() &amp;&amp; !e.isSynthesized()) {
            if (e.getButton() == MouseButton.PRIMARY &amp;&amp;
                    !(e.isMiddleButtonDown() || e.isSecondaryButtonDown() ||
                            e.isControlDown() || e.isAltDown() || e.isShiftDown() || e.isMetaDown())) {
                skin.positionCaret(skin.getIndex(e.getX(), e.getY()), true);
            }
        }
        deferClick = false;
    }

    @Override public void mouseReleased(final MouseEvent e) {
        final TextArea textArea = getNode();
        // we never respond to events if disabled, but we do notify any onXXX
        // event listeners on the control
        if (!textArea.isDisabled()) {
            setCaretAnimating(false);
            if (deferClick) {
                deferClick = false;
                skin.positionCaret(skin.getIndex(e.getX(), e.getY()), shiftDown);
                shiftDown = false;
            }
            setCaretAnimating(true);
        }
    }

    @Override public void contextMenuRequested(ContextMenuEvent e) {
        final TextArea textArea = getNode();

        if (contextMenu.isShowing()) {
            contextMenu.hide();
        } else if (textArea.getContextMenu() == null &amp;&amp;
                   textArea.getOnContextMenuRequested() == null) {
            double screenX = e.getScreenX();
            double screenY = e.getScreenY();
            double sceneX = e.getSceneX();

            if (Properties.IS_TOUCH_SUPPORTED) {
                Point2D menuPos;
                if (textArea.getSelection().getLength() == 0) {
                    skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false);
                    menuPos = skin.getMenuPosition();
                } else {
                    menuPos = skin.getMenuPosition();
                    if (menuPos != null &amp;&amp; (menuPos.getX() &lt;= 0 || menuPos.getY() &lt;= 0)) {
                        skin.positionCaret(skin.getIndex(e.getX(), e.getY()), false);
                        menuPos = skin.getMenuPosition();
                    }
                }

                if (menuPos != null) {
                    Point2D p = getNode().localToScene(menuPos);
                    Scene scene = getNode().getScene();
                    Window window = scene.getWindow();
                    Point2D location = new Point2D(window.getX() + scene.getX() + p.getX(),
                                                   window.getY() + scene.getY() + p.getY());
                    screenX = location.getX();
                    sceneX = p.getX();
                    screenY = location.getY();
                }
            }

            populateContextMenu();
            double menuWidth = contextMenu.prefWidth(-1);
            double menuX = screenX - (Properties.IS_TOUCH_SUPPORTED ? (menuWidth / 2) : 0);
            Screen currentScreen = com.sun.javafx.util.Utils.getScreenForPoint(screenX, 0);
            Rectangle2D bounds = currentScreen.getBounds();

            if (menuX &lt; bounds.getMinX()) {
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, screenX);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, sceneX);
                contextMenu.show(getNode(), bounds.getMinX(), screenY);
            } else if (screenX + menuWidth &gt; bounds.getMaxX()) {
                double leftOver = menuWidth - ( bounds.getMaxX() - screenX);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, screenX);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, sceneX);
                contextMenu.show(getNode(), screenX - leftOver, screenY);
            } else {
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCREEN_X&quot;, 0);
                getNode().getProperties().put(&quot;CONTEXT_MENU_SCENE_X&quot;, 0);
                contextMenu.show(getNode(), menuX, screenY);
            }
        }

        e.consume();
    }

    @Override protected void setCaretAnimating(boolean play) {
        skin.setCaretAnimating(play);
    }

    protected void mouseDoubleClick(HitInfo hit) {
        final TextArea textArea = getNode();
        textArea.previousWord();
        if (isWindows()) {
            textArea.selectNextWord();
        } else {
            textArea.selectEndOfNextWord();
        }
    }

    protected void mouseTripleClick(HitInfo hit) {
        // select the line
        skin.moveCaret(TextUnit.PARAGRAPH, Direction.BEGINNING, false);
        skin.moveCaret(TextUnit.PARAGRAPH, Direction.END, true);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/com/sun/javafx/scene/control/behavior/TextInputControlBehavior.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.javafx.scene.control.behavior;

import com.sun.javafx.PlatformUtil;
import com.sun.javafx.application.PlatformImpl;
import com.sun.javafx.scene.control.Properties;
import com.sun.javafx.scene.control.skin.FXVK;

import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.scene.control.skin.TextInputControlSkin;
import javafx.application.ConditionalFeature;
import javafx.beans.InvalidationListener;
import javafx.collections.ObservableList;
import javafx.geometry.NodeOrientation;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.IndexRange;
import javafx.scene.control.MenuItem;
import javafx.scene.control.PasswordField;
import javafx.scene.control.SeparatorMenuItem;
import javafx.scene.control.TextInputControl;
import javafx.scene.input.ContextMenuEvent;
import javafx.scene.input.Clipboard;
import com.sun.javafx.scene.control.inputmap.InputMap;
import com.sun.javafx.scene.control.inputmap.KeyBinding;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;

import java.text.Bidi;
import java.util.function.Predicate;

import static com.sun.javafx.PlatformUtil.isLinux;
import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;
import static com.sun.javafx.scene.control.inputmap.KeyBinding.OptionalBoolean;
import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;
import static javafx.scene.control.skin.TextInputControlSkin.TextUnit;
import static javafx.scene.control.skin.TextInputControlSkin.Direction;
import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;
import static com.sun.javafx.scene.control.inputmap.InputMap.MouseMapping;
import static javafx.scene.input.KeyCode.*;
import static javafx.scene.input.KeyEvent.*;

/**
 * All of the &quot;button&quot; types (CheckBox, RadioButton, ToggleButton, and Button)
 * and also maybe some other types like hyperlinks operate on the &quot;armed&quot;
 * selection strategy, just like JButton. This behavior class encapsulates that
 * logic in a way that can be reused and extended by each of the individual
 * class behaviors.
 *
 */
public abstract class TextInputControlBehavior&lt;T extends TextInputControl&gt; extends BehaviorBase&lt;T&gt; {

    /**
     * Specifies whether we ought to show handles. We should do it on touch platforms, but not
     * iOS (and maybe not Android either?)
     */
    static final boolean SHOW_HANDLES = Properties.IS_TOUCH_SUPPORTED &amp;&amp; !PlatformUtil.isIOS();

    public static final String DISABLE_FORWARD_TO_PARENT = &quot;TextInputControlBehavior.disableForwardToParent&quot;;

    /**************************************************************************
     * Fields                                                                 *
     *************************************************************************/

    final T textInputControl;

    protected ContextMenu contextMenu;

    private InvalidationListener textListener = observable -&gt; invalidateBidi();

    private final InputMap&lt;T&gt; inputMap;




    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    public TextInputControlBehavior(T c) {
        super(c);

        this.textInputControl = c;

        textInputControl.textProperty().addListener(textListener);

        // create a map for text input-specific mappings (this reuses the default
        // InputMap installed on the control, if it is non-null, allowing us to pick up any user-specified mappings)
        inputMap = createInputMap();

        // some of the mappings are only valid when the control is editable, or
        // only on certain platforms, so we create the following predicates that filters out the mapping when the
        // control is not in the correct state / on the correct platform
        final Predicate&lt;KeyEvent&gt; validWhenEditable = e -&gt; !c.isEditable();
        final Predicate&lt;KeyEvent&gt; validOnWindows = e -&gt; !PlatformUtil.isWindows();
        final Predicate&lt;KeyEvent&gt; validOnLinux = e -&gt; !PlatformUtil.isLinux();

        KeyMapping cancelEditMapping;
        KeyMapping consumeMostPressedEventsMapping;

        // create a child input map for mappings which are applicable on all
        // platforms, and regardless of editing state
<A NAME="8"></A>        addDefaultMapping(inputMap,
                // caret movement
                keyMapping(RIGHT, e -&gt; nextCharacterVisually(true)),
                keyMapping(LEFT, e -&gt; <FONT color="#bce954"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#8',2,'match49-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>nextCharacterVisually(false)),
                keyMapping(UP, e -&gt; c.home()),
                keyMapping(HOME, e -&gt; c.home()),
                keyMapping(DOWN, e -&gt; c.end()),
                keyMapping(END, e -&gt; c.end()),
                keyMapping(ENTER, this::fire),

                keyMapping(new KeyBinding(HOME).shortcut</B></FONT>(), e -&gt; c.home()),
                keyMapping(new KeyBinding(END).shortcut(), e -&gt; c.end()),

                // deletion (only applies when control is editable)
                keyMapping(new KeyBinding(BACK_SPACE), e -&gt; deletePreviousChar(), validWhenEditable),
                keyMapping(new KeyBinding(BACK_SPACE).shift(), e -&gt; deletePreviousChar(), validWhenEditable),
                keyMapping(new KeyBinding(DELETE), e -&gt; deleteNextChar(), validWhenEditable),

                // cut (only applies when control is editable)
                keyMapping(new KeyBinding(X).shortcut(), e -&gt; cut(), validWhenEditable),
                keyMapping(new KeyBinding(CUT), e -&gt; cut(), validWhenEditable),

                // copy
                keyMapping(new KeyBinding(C).shortcut(), e -&gt; c.copy()),
                keyMapping(new KeyBinding(INSERT).shortcut(), e -&gt; c.copy()),
                keyMapping(COPY, e -&gt; c.copy()),

                // paste (only applies when control is editable)
                keyMapping(new KeyBinding(V).shortcut(), e -&gt; paste(), validWhenEditable),
                keyMapping(new KeyBinding(PASTE), e -&gt; paste(), validWhenEditable),
                keyMapping(new KeyBinding(INSERT).shift(), e -&gt; paste(), validWhenEditable),

                // selection
                keyMapping(new KeyBinding(RIGHT).shift(), e -&gt; selectRight()),
                keyMapping(new KeyBinding(LEFT).shift(), e -&gt; selectLeft()),
                keyMapping(new KeyBinding(UP).shift(), e -&gt; selectHome()),
                keyMapping(new KeyBinding(DOWN).shift(), e -&gt; selectEnd()),
                keyMapping(new KeyBinding(HOME).shortcut().shift(), e -&gt; selectHome()),
                keyMapping(new KeyBinding(END).shortcut().shift(), e -&gt; selectEnd()),
                keyMapping(new KeyBinding(A).shortcut(), e -&gt; c.selectAll()),

                // Traversal Bindings
                new KeyMapping(new KeyBinding(TAB), FocusTraversalInputMap::traverseNext),
                new KeyMapping(new KeyBinding(TAB).shift(), FocusTraversalInputMap::traversePrevious),
                new KeyMapping(new KeyBinding(TAB).ctrl(), FocusTraversalInputMap::traverseNext),
                new KeyMapping(new KeyBinding(TAB).ctrl().shift(), FocusTraversalInputMap::traversePrevious),

                // The following keys are forwarded to the parent container
                cancelEditMapping = new KeyMapping(ESCAPE, this::cancelEdit),

                keyMapping(new KeyBinding(Z).shortcut(), e -&gt; undo()),

                // character input.
                // Any other key press first goes to normal text input
                // Note this is KEY_TYPED because otherwise the character is not available in the event.
                keyMapping(new KeyBinding(null, KEY_TYPED)
                                    .alt(OptionalBoolean.ANY)
                                    .shift(OptionalBoolean.ANY)
                                    .ctrl(OptionalBoolean.ANY)
                                    .meta(OptionalBoolean.ANY),
                           this::defaultKeyTyped),

                // However, we want to consume other key press / release events too, for
                // things that would have been handled by the InputCharacter normally
                consumeMostPressedEventsMapping =
                    keyMapping(new KeyBinding(null, KEY_PRESSED).shift(OptionalBoolean.ANY),
                               e -&gt; { if (!e.getCode().isFunctionKey()) e.consume(); }),

                // VK
                new KeyMapping(new KeyBinding(DIGIT9).ctrl().shift(), e -&gt; {
                    FXVK.toggleUseVK(textInputControl);
                }, p -&gt; !PlatformImpl.isSupported(ConditionalFeature.VIRTUAL_KEYBOARD)),

                // mouse and context menu mappings
                new MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed),
                new MouseMapping(MouseEvent.MOUSE_DRAGGED, this::mouseDragged),
                new MouseMapping(MouseEvent.MOUSE_RELEASED, this::mouseReleased),
                new InputMap.Mapping&lt;ContextMenuEvent&gt;(ContextMenuEvent.CONTEXT_MENU_REQUESTED, this::contextMenuRequested) {
                    @Override public int getSpecificity(Event event) {
                        return 1;
                    }
                }
        );

        cancelEditMapping.setAutoConsume(false);
        consumeMostPressedEventsMapping.setAutoConsume(false);

        // mac os specific mappings
        InputMap&lt;T&gt; macOsInputMap = new InputMap&lt;&gt;(c);
        macOsInputMap.setInterceptor(e -&gt; !PlatformUtil.isMac());
        macOsInputMap.getMappings().addAll(
            // Mac OS specific mappings
            keyMapping(new KeyBinding(HOME).shift(), e -&gt; selectHomeExtend()),
            keyMapping(new KeyBinding(END).shift(), e -&gt; selectEndExtend()),
            keyMapping(new KeyBinding(LEFT).shortcut(), e -&gt; c.home()),
            keyMapping(new KeyBinding(RIGHT).shortcut(), e -&gt; c.end()),
            keyMapping(new KeyBinding(LEFT).alt(), e -&gt; leftWord()),
            keyMapping(new KeyBinding(RIGHT).alt(), e -&gt; rightWord()),
            keyMapping(new KeyBinding(DELETE).alt(), e -&gt; deleteNextWord()),
            keyMapping(new KeyBinding(BACK_SPACE).alt(), e -&gt; deletePreviousWord()),
            keyMapping(new KeyBinding(BACK_SPACE).shortcut(), e -&gt; deleteFromLineStart()),
            keyMapping(new KeyBinding(Z).shortcut().shift(), e -&gt; redo()),
            keyMapping(new KeyBinding(LEFT).shortcut().shift(), e -&gt; selectHomeExtend()),
            keyMapping(new KeyBinding(RIGHT).shortcut().shift(), e -&gt; selectEndExtend()),

            // Mac OS specific selection mappings
            keyMapping(new KeyBinding(LEFT).shift().alt(), e -&gt; selectLeftWord()),
            keyMapping(new KeyBinding(RIGHT).shift().alt(), e -&gt; selectRightWord())
        );
        addDefaultChildMap(inputMap, macOsInputMap);

        // windows / linux specific mappings
        InputMap&lt;T&gt; nonMacOsInputMap = new InputMap&lt;&gt;(c);
        nonMacOsInputMap.setInterceptor(e -&gt; PlatformUtil.isMac());
        nonMacOsInputMap.getMappings().addAll(
            keyMapping(new KeyBinding(HOME).shift(), e -&gt; selectHome()),
            keyMapping(new KeyBinding(END).shift(), e -&gt; selectEnd()),
            keyMapping(new KeyBinding(LEFT).ctrl(), e -&gt; leftWord()),
            keyMapping(new KeyBinding(RIGHT).ctrl(), e -&gt; rightWord()),
            keyMapping(new KeyBinding(H).ctrl(), e -&gt; deletePreviousChar()),
            keyMapping(new KeyBinding(DELETE).ctrl(), e -&gt; deleteNextWord()),
            keyMapping(new KeyBinding(BACK_SPACE).ctrl(), e -&gt; deletePreviousWord()),
            keyMapping(new KeyBinding(BACK_SLASH).ctrl(), e -&gt; c.deselect()),
            keyMapping(new KeyBinding(Y).ctrl(), e -&gt; redo(), validOnWindows),
            keyMapping(new KeyBinding(Z).ctrl().shift(), e -&gt; redo(), validOnLinux),
            keyMapping(new KeyBinding(LEFT).ctrl().shift(), e -&gt; selectLeftWord()),
            keyMapping(new KeyBinding(RIGHT).ctrl().shift(), e -&gt; selectRightWord())
        );
        addDefaultChildMap(inputMap, nonMacOsInputMap);

        addKeyPadMappings(inputMap);

        textInputControl.textProperty().addListener(textListener);

        contextMenu = new ContextMenu();
}

    @Override public InputMap&lt;T&gt; getInputMap() {
        return inputMap;
    }

    /**
     * Bind keypad arrow keys to the same as the regular arrow keys.
     */
    protected void addKeyPadMappings(InputMap&lt;T&gt; map) {
        // First create a temporary map for the keypad mappings
        InputMap&lt;T&gt; tmpMap = new InputMap&lt;&gt;(getNode());
        for (Object o : map.getMappings()) {
            if (o instanceof KeyMapping) {
                KeyMapping mapping = (KeyMapping)o;
                KeyBinding kb = (KeyBinding)mapping.getMappingKey();
                if (kb.getCode() != null) {
                    KeyCode newCode = null;
                    switch (kb.getCode()) {
                        case LEFT:  newCode = KP_LEFT;  break;
                        case RIGHT: newCode = KP_RIGHT; break;
                        case UP:    newCode = KP_UP;    break;
                        case DOWN:  newCode = KP_DOWN;  break;
                        default:
                    }
                    if (newCode != null) {
                        KeyBinding newkb = new KeyBinding(newCode).shift(kb.getShift())
                                                                  .ctrl(kb.getCtrl())
                                                                  .alt(kb.getAlt())
                                                                  .meta(kb.getMeta());
                        tmpMap.getMappings().add(new KeyMapping(newkb, mapping.getEventHandler()));
                    }
                }
            }
        }
        // Install mappings
        for (Object o : tmpMap.getMappings()) {
            map.getMappings().add((KeyMapping)o);
        }

        // Recursive call for child maps
        for (Object o : map.getChildInputMaps()) {
            addKeyPadMappings((InputMap&lt;T&gt;)o);
        }
    }


    /**
     * Wraps the event handler to pause caret blinking when
     * processing the key event.
     */
    protected KeyMapping keyMapping(final KeyCode keyCode, final EventHandler&lt;KeyEvent&gt; eventHandler) {
        return keyMapping(new KeyBinding(keyCode), eventHandler);
    }

    protected KeyMapping keyMapping(KeyBinding keyBinding, final EventHandler&lt;KeyEvent&gt; eventHandler) {
        return keyMapping(keyBinding, eventHandler, null);
    }

    protected KeyMapping keyMapping(KeyBinding keyBinding, final EventHandler&lt;KeyEvent&gt; eventHandler,
                                    Predicate&lt;KeyEvent&gt; interceptor) {
        return new KeyMapping(keyBinding,
                              e -&gt; {
                                  setCaretAnimating(false);
                                  eventHandler.handle(e);
                                  setCaretAnimating(true);
                              },
                              interceptor);
    }





    /**************************************************************************
     * Disposal methods                                                       *
     *************************************************************************/

    @Override public void dispose() {
        textInputControl.textProperty().removeListener(textListener);
        super.dispose();
    }

    /**************************************************************************
     * Abstract methods                                                       *
     *************************************************************************/

    protected abstract void deleteChar(boolean previous);
    protected abstract void replaceText(int start, int end, String txt);
    protected abstract void setCaretAnimating(boolean play);
    protected abstract void deleteFromLineStart();

    protected abstract void mousePressed(MouseEvent e);
    protected abstract void mouseDragged(MouseEvent e);
    protected abstract void mouseReleased(MouseEvent e);
    protected abstract void contextMenuRequested(ContextMenuEvent e);

    /**************************************************************************
     * Key handling implementation                                            *
     *************************************************************************/

    /**
     * The default handler for a key typed event, which is called when none of
     * the other key bindings match. This is the method which handles basic
     * text entry.
     * @param event not null
     */
    private void defaultKeyTyped(KeyEvent event) {
        final TextInputControl textInput = getNode();
        // I'm not sure this case can actually ever happen, maybe this
        // should be an assert instead?
        if (!textInput.isEditable() || textInput.isDisabled()) return;

        // Sometimes we get events with no key character, in which case
        // we need to bail.
        String character = event.getCharacter();
        if (character.length() == 0) return;

        // Filter out control keys except control+Alt on PC or Alt on Mac
        if (event.isControlDown() || event.isAltDown() || (isMac() &amp;&amp; event.isMetaDown())) {
            if (!((event.isControlDown() || isMac()) &amp;&amp; event.isAltDown())) return;
        }

        setEditing(true);

        // Ignore characters in the control range and the ASCII delete
        // character as well as meta key presses
        if (character.charAt(0) &gt; 0x1F
                &amp;&amp; character.charAt(0) != 0x7F
                &amp;&amp; !event.isMetaDown()) { // Not sure about this one
            final IndexRange selection = textInput.getSelection();
            final int start = selection.getStart();
            final int end = selection.getEnd();

            replaceText(start, end, character);
        }

        setEditing(false);
    }

    private Bidi bidi = null;
    private Boolean mixed = null;
    private Boolean rtlText = null;

    private void invalidateBidi() {
        bidi = null;
        mixed = null;
        rtlText = null;
    }

    private Bidi getBidi() {
        if (bidi == null) {
            bidi = new Bidi(textInputControl.textProperty().getValueSafe(),
                    (textInputControl.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT)
                            ? Bidi.DIRECTION_RIGHT_TO_LEFT
                            : Bidi.DIRECTION_LEFT_TO_RIGHT);
        }
        return bidi;
    }

    protected boolean isMixed() {
        if (mixed == null) {
            mixed = getBidi().isMixed();
        }
        return mixed;
    }

    protected boolean isRTLText() {
        if (rtlText == null) {
            Bidi bidi = getBidi();
            rtlText =
                    (bidi.isRightToLeft() ||
                            (isMixed() &amp;&amp;
                                    textInputControl.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT));
        }
        return rtlText;
    }

    private void nextCharacterVisually(boolean moveRight) {
        if (isMixed()) {
            TextInputControlSkin&lt;?&gt; skin = (TextInputControlSkin&lt;?&gt;)textInputControl.getSkin();
            skin.moveCaret(TextUnit.CHARACTER, moveRight ? Direction.RIGHT : Direction.LEFT, false);
        } else if (moveRight != isRTLText()) {
            textInputControl.forward();
        } else {
            textInputControl.backward();
        }
    }

    private void selectLeft() {
        if (isRTLText()) {
            textInputControl.selectForward();
        } else {
            textInputControl.selectBackward();
        }
    }

    private void selectRight() {
        if (isRTLText()) {
            textInputControl.selectBackward();
        } else {
            textInputControl.selectForward();
        }
    }

    private void deletePreviousChar() {
        setEditing(true);
        deleteChar(true);
        setEditing(false);
    }

    private void deleteNextChar() {
        setEditing(true);
        deleteChar(false);
        setEditing(false);
    }

    protected void deletePreviousWord() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
        int end = textInputControl.getCaretPosition();

        if (end &gt; 0) {
            textInputControl.previousWord();
            int start = textInputControl.getCaretPosition();
            replaceText(start, end, &quot;&quot;);
        }
        setEditing(false);
    }

    protected void deleteNextWord() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
        int start = textInputControl.getCaretPosition();

        if (start &lt; textInputControl.getLength()) {
            nextWord();
            int end = textInputControl.getCaretPosition();
            replaceText(start, end, &quot;&quot;);
        }
        setEditing(false);
    }

    public void deleteSelection() {
        setEditing(true);
        TextInputControl textInputControl = getNode();
        IndexRange selection = textInputControl.getSelection();

        if (selection.getLength() &gt; 0) {
            deleteChar(false);
        }
        setEditing(false);
    }

    public void cut() {
        setEditing(true);
        getNode().cut();
        setEditing(false);
    }

    public void paste() {
        setEditing(true);
        getNode().paste();
        setEditing(false);
    }

    public void undo() {
        setEditing(true);
        getNode().undo();
        setEditing(false);
    }

    public void redo() {
        setEditing(true);
        getNode().redo();
        setEditing(false);
    }

    protected void selectPreviousWord() {
        getNode().selectPreviousWord();
    }

    public void selectNextWord() {
        TextInputControl textInputControl = getNode();
        if (isMac() || isLinux()) {
            textInputControl.selectEndOfNextWord();
        } else {
            textInputControl.selectNextWord();
        }
    }

    private void selectLeftWord() {
        if (isRTLText()) {
            selectNextWord();
        } else {
            selectPreviousWord();
        }
    }

    private void selectRightWord() {
        if (isRTLText()) {
            selectPreviousWord();
        } else {
            selectNextWord();
        }
    }

    protected void selectWord() {
        final TextInputControl textInputControl = getNode();
        textInputControl.previousWord();
        if (isWindows()) {
            textInputControl.selectNextWord();
        } else {
            textInputControl.selectEndOfNextWord();
        }
        if (SHOW_HANDLES &amp;&amp; contextMenu.isShowing()) {
            populateContextMenu();
        }
    }

    protected void selectAll() {
        getNode().selectAll();
        if (SHOW_HANDLES &amp;&amp; contextMenu.isShowing()) {
            populateContextMenu();
        }
    }

    protected void previousWord() {
        getNode().previousWord();
    }

    protected void nextWord() {
        TextInputControl textInputControl = getNode();
        if (isMac() || isLinux()) {
            textInputControl.endOfNextWord();
        } else {
            textInputControl.nextWord();
        }
    }

    private void leftWord() {
        if (isRTLText()) {
            nextWord();
        } else {
            previousWord();
        }
    }

    private void rightWord() {
        if (isRTLText()) {
            previousWord();
        } else {
            nextWord();
        }
    }

    protected void fire(KeyEvent event) { } // TODO move to TextFieldBehavior
    protected void cancelEdit(KeyEvent event) { forwardToParent(event);} // not autoconsumed

    protected void forwardToParent(KeyEvent event) {
        // fix for JDK-8145515
        if (getNode().getProperties().containsKey(DISABLE_FORWARD_TO_PARENT)) {
            return;
        }

        if (getNode().getParent() != null) {
            getNode().getParent().fireEvent(event);
        }
    }

    protected void selectHome() {
        getNode().selectHome();
    }

    protected void selectEnd() {
        getNode().selectEnd();
    }

    protected void selectHomeExtend() {
        getNode().extendSelection(0);
    }

    protected void selectEndExtend() {
        TextInputControl textInputControl = getNode();
        textInputControl.extendSelection(textInputControl.getLength());
    }

    private boolean editing = false;
    protected void setEditing(boolean b) {
        editing = b;
    }
    public boolean isEditing() {
        return editing;
    }

    protected void populateContextMenu() {
        TextInputControl textInputControl = getNode();
        boolean editable = textInputControl.isEditable();
        boolean hasText = (textInputControl.getLength() &gt; 0);
        boolean hasSelection = (textInputControl.getSelection().getLength() &gt; 0);
        boolean allSelected = (textInputControl.getSelection().getLength() == textInputControl.getLength());
        boolean maskText = (textInputControl instanceof PasswordField); // (maskText(&quot;A&quot;) != &quot;A&quot;);
        ObservableList&lt;MenuItem&gt; items = contextMenu.getItems();

        if (SHOW_HANDLES) {
            items.clear();
            if (!maskText &amp;&amp; hasSelection) {
                if (editable) {
                    items.add(cutMI);
                }
                items.add(copyMI);
            }
            if (editable &amp;&amp; Clipboard.getSystemClipboard().hasString()) {
                items.add(pasteMI);
            }
            if (hasText &amp;&amp; !allSelected) {
                if (!hasSelection &amp;&amp; !(textInputControl instanceof PasswordField)) {
                    items.add(selectWordMI);
                }
                items.add(selectAllMI);
            }
            selectWordMI.getProperties().put(&quot;refreshMenu&quot;, Boolean.TRUE);
            selectAllMI.getProperties().put(&quot;refreshMenu&quot;, Boolean.TRUE);
        } else {
            if (editable) {
                items.setAll(undoMI, redoMI, cutMI, copyMI, pasteMI, deleteMI,
                        separatorMI, selectAllMI);
            } else {
                items.setAll(copyMI, separatorMI, selectAllMI);
            }
            undoMI.setDisable(!getNode().isUndoable());
            redoMI.setDisable(!getNode().isRedoable());
            cutMI.setDisable(maskText || !hasSelection);
            copyMI.setDisable(maskText || !hasSelection);
            pasteMI.setDisable(!Clipboard.getSystemClipboard().hasString());
            deleteMI.setDisable(!hasSelection);
        }
    }

    private static class ContextMenuItem extends MenuItem {
        ContextMenuItem(final String action, EventHandler&lt;ActionEvent&gt; onAction) {
            super(getString(&quot;TextInputControl.menu.&quot; + action));
            setOnAction(onAction);
        }
    }

    private final MenuItem undoMI   = new ContextMenuItem(&quot;Undo&quot;, e -&gt; undo());
    private final MenuItem redoMI   = new ContextMenuItem(&quot;Redo&quot;, e -&gt; redo());
    private final MenuItem cutMI    = new ContextMenuItem(&quot;Cut&quot;, e -&gt; cut());
    private final MenuItem copyMI   = new ContextMenuItem(&quot;Copy&quot;, e -&gt; getNode().copy());
    private final MenuItem pasteMI  = new ContextMenuItem(&quot;Paste&quot;, e -&gt; paste());
    private final MenuItem deleteMI = new ContextMenuItem(&quot;DeleteSelection&quot;, e -&gt; deleteSelection());
    private final MenuItem selectWordMI = new ContextMenuItem(&quot;SelectWord&quot;, e -&gt; selectWord());
    private final MenuItem selectAllMI = new ContextMenuItem(&quot;SelectAll&quot;, e -&gt; selectAll());
    private final MenuItem separatorMI = new SeparatorMenuItem();

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/BubbleChart.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import javafx.animation.FadeTransition;
import javafx.animation.ParallelTransition;
import javafx.application.Platform;
import javafx.beans.NamedArg;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Ellipse;
import javafx.util.Duration;

import com.sun.javafx.charts.Legend.LegendItem;

/**
 * Chart type that plots bubbles for the data points in a series. The extra value property of Data is used to represent
 * the radius of the bubble it should be a java.lang.Number.
 * @since JavaFX 2.0
 */
public class BubbleChart&lt;X,Y&gt; extends XYChart&lt;X,Y&gt; {

    // -------------- CONSTRUCTORS ----------------------------------------------

    /**
     * Construct a new BubbleChart with the given axis. BubbleChart does not use a Category Axis.
     * Both X and Y axes should be of type NumberAxis.
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     */
    public BubbleChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis) {
        this(xAxis, yAxis, FXCollections.&lt;Series&lt;X, Y&gt;&gt;observableArrayList());
    }

    /**
     * Construct a new BubbleChart with the given axis and data. BubbleChart does not
     * use a Category Axis. Both X and Y axes should be of type NumberAxis.
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart
     */
    public BubbleChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis, @NamedArg(&quot;data&quot;) ObservableList&lt;Series&lt;X,Y&gt;&gt; data) {
        super(xAxis, yAxis);
        if (!(xAxis instanceof ValueAxis &amp;&amp; yAxis instanceof ValueAxis)) {
            throw new IllegalArgumentException(&quot;Axis type incorrect, X and Y should both be NumberAxis&quot;);
        }
        setData(data);
    }

    // -------------- METHODS ------------------------------------------------------------------------------------------

    /**
     * Used to get a double value from a object that can be a Number object or null
     *
     * @param number Object possibly a instance of Number
     * @param nullDefault What value to return if the number object is null or not a Number
     * @return number converted to double or nullDefault
     */
    private static double getDoubleValue(Object number, double nullDefault) {
        return !(number instanceof Number) ? nullDefault : ((Number)number).doubleValue();
    }

    /** {@inheritDoc} */
    @Override protected void layoutPlotChildren() {
        // update bubble positions
      for (int seriesIndex=0; seriesIndex &lt; getDataSize(); seriesIndex++) {
            Series&lt;X,Y&gt; series = getData().get(seriesIndex);
//            for (Data&lt;X,Y&gt; item = series.begin; item != null; item = item.next) {
            Iterator&lt;Data&lt;X,Y&gt;&gt; iter = getDisplayedDataIterator(series);
            while(iter.hasNext()) {
                Data&lt;X,Y&gt; item = iter.next();
                double x = getXAxis().getDisplayPosition(item.getCurrentX());
                double y = getYAxis().getDisplayPosition(item.getCurrentY());
                if (Double.isNaN(x) || Double.isNaN(y)) {
                    continue;
                }
                Node bubble = item.getNode();
                Ellipse ellipse;
                if (bubble != null) {
                    if (bubble instanceof StackPane) {
                        StackPane region = (StackPane)item.getNode();
                        if (region.getShape() == null) {
                            ellipse = new Ellipse(getDoubleValue(item.getExtraValue(), 1), getDoubleValue(item.getExtraValue(), 1));
                        } else if (region.getShape() instanceof Ellipse) {
                            ellipse = (Ellipse)region.getShape();
                        } else {
                            return;
                        }
                        ellipse.setRadiusX(getDoubleValue(item.getExtraValue(), 1) * ((getXAxis() instanceof NumberAxis) ? Math.abs(((NumberAxis)getXAxis()).getScale()) : 1));
                        ellipse.setRadiusY(getDoubleValue(item.getExtraValue(), 1) * ((getYAxis() instanceof NumberAxis) ? Math.abs(((NumberAxis)getYAxis()).getScale()) : 1));
                        // Note: workaround for RT-7689 - saw this in ProgressControlSkin
                        // The region doesn't update itself when the shape is mutated in place, so we
                        // null out and then restore the shape in order to force invalidation.
                        region.setShape(null);
                        region.setShape(ellipse);
                        region.setScaleShape(false);
                        region.setCenterShape(false);
                        region.setCacheShape(false);
                        // position the bubble
                        bubble.setLayoutX(x);
                        bubble.setLayoutY(y);
                    }
                }
            }
        }
    }

    @Override protected void dataItemAdded(Series&lt;X,Y&gt; series, int itemIndex, Data&lt;X,Y&gt; item) {
        Node bubble = createBubble(series, getData().indexOf(series), item, itemIndex);
        if (shouldAnimate()) {
            // fade in new bubble
            bubble.setOpacity(0);
            getPlotChildren().add(bubble);
            FadeTransition ft = new FadeTransition(Duration.millis(500),bubble);
            ft.setToValue(1);
            ft.play();
        } else {
            getPlotChildren().add(bubble);
        }
    }

    @Override protected  void dataItemRemoved(final Data&lt;X,Y&gt; item, final Series&lt;X,Y&gt; series) {
        final Node bubble = item.getNode();
        if (shouldAnimate()) {
            // fade out old bubble
            FadeTransition ft = new FadeTransition(Duration.millis(500),bubble);
            ft.setToValue(0);
            ft.setOnFinished(actionEvent -&gt; {
                getPlotChildren().remove(bubble);
                removeDataItemFromDisplay(series, item);
                bubble.setOpacity(1.0);
            });
            ft.play();
        } else {
            getPlotChildren().remove(bubble);
            removeDataItemFromDisplay(series, item);
        }
    }

    /** {@inheritDoc} */
    @Override protected void dataItemChanged(Data&lt;X, Y&gt; item) {
    }

    @Override protected  void seriesAdded(Series&lt;X,Y&gt; series, int seriesIndex) {
        // handle any data already in series
        for (int j=0; j&lt;series.getData().size(); j++) {
            Data&lt;X,Y&gt; item = series.getData().get(j);
            Node bubble = createBubble(series, seriesIndex, item, j);
            if (shouldAnimate()) {
                bubble.setOpacity(0);
                getPlotChildren().add(bubble);
                // fade in new bubble
                FadeTransition ft = new FadeTransition(Duration.millis(500),bubble);
                ft.setToValue(1);
                ft.play();
            } else {
                getPlotChildren().add(bubble);
            }
        }
    }

    @Override protected  void seriesRemoved(final Series&lt;X,Y&gt; series) {
        // remove all bubble nodes
        if (shouldAnimate()) {
            ParallelTransition pt = new ParallelTransition();
            pt.setOnFinished(event -&gt; {
<A NAME="24"></A>                removeSeriesFromDisplay(series);
            });
            for (XYChart.Data&lt;X,Y&gt; d : series.getData()) {
                final Node bubble = <FONT color="#ada96e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#24',2,'match49-top.html#24',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>d.getNode();
                // fade out old bubble
                FadeTransition ft = new FadeTransition(Duration.millis(500),bubble);
                ft.setToValue(0);
                ft.setOnFinished(actionEvent -&gt; {
                    getPlotChildren().remove</B></FONT>(bubble);
                    bubble.setOpacity(1.0);
                });
                pt.getChildren().add(ft);
            }
            pt.play();
        } else {
            for (XYChart.Data&lt;X,Y&gt; d : series.getData()) {
                final Node bubble = d.getNode();
                getPlotChildren().remove(bubble);
            }
            removeSeriesFromDisplay(series);
        }

    }

    /**
     * Create a Bubble for a given data item if it doesn't already have a node
     *
     *
     * @param series
     * @param seriesIndex The index of the series containing the item
     * @param item        The data item to create node for
     * @param itemIndex   The index of the data item in the series
     * @return Node used for given data item
     */
    private Node createBubble(Series&lt;X, Y&gt; series, int seriesIndex, final Data&lt;X,Y&gt; item, int itemIndex) {
        Node bubble = item.getNode();
        // check if bubble has already been created
        if (bubble == null) {
            bubble = new StackPane() {
                @Override
                public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
                    switch (attribute) {
                        case TEXT: {
                            String accText = getAccessibleText();
                            if (item.getExtraValue() == null) {
                                return accText;
                            } else {
                                return accText + &quot; Bubble radius is &quot; + item.getExtraValue();
                            }
                        }
                        default: return super.queryAccessibleAttribute(attribute, parameters);
                    }
                }
            };
            bubble.setAccessibleRole(AccessibleRole.TEXT);
            bubble.setAccessibleRoleDescription(&quot;Bubble&quot;);
            bubble.focusTraversableProperty().bind(Platform.accessibilityActiveProperty());
            item.setNode(bubble);
        }
        // set bubble styles
        bubble.getStyleClass().setAll(&quot;chart-bubble&quot;, &quot;series&quot; + seriesIndex, &quot;data&quot; + itemIndex,
                series.defaultColorStyleClass);
        return bubble;
    }

    /**
     * This is called when the range has been invalidated and we need to update it. If the axis are auto
     * ranging then we compile a list of all data that the given axis has to plot and call invalidateRange() on the
     * axis passing it that data.
     */
    @Override protected void updateAxisRange() {
        // For bubble chart we need to override this method as we need to let the axis know that they need to be able
        // to cover the whole area occupied by the bubble not just its center data value
        final Axis&lt;X&gt; xa = getXAxis();
        final Axis&lt;Y&gt; ya = getYAxis();
        List&lt;X&gt; xData = null;
        List&lt;Y&gt; yData = null;
        if(xa.isAutoRanging()) xData = new ArrayList&lt;X&gt;();
        if(ya.isAutoRanging()) yData = new ArrayList&lt;Y&gt;();
        final boolean xIsCategory = xa instanceof CategoryAxis;
        final boolean yIsCategory = ya instanceof CategoryAxis;
        if(xData != null || yData != null) {
            for(Series&lt;X,Y&gt; series : getData()) {
                for(Data&lt;X,Y&gt; data: series.getData()) {
                    if(xData != null) {
                        if(xIsCategory) {
                            xData.add(data.getXValue());
                        } else {
                            xData.add(xa.toRealValue(xa.toNumericValue(data.getXValue()) + getDoubleValue(data.getExtraValue(), 0)));
                            xData.add(xa.toRealValue(xa.toNumericValue(data.getXValue()) - getDoubleValue(data.getExtraValue(), 0)));
                        }
                    }
                    if(yData != null){
                        if(yIsCategory) {
                            yData.add(data.getYValue());
                        } else {
                            yData.add(ya.toRealValue(ya.toNumericValue(data.getYValue()) + getDoubleValue(data.getExtraValue(), 0)));
                            yData.add(ya.toRealValue(ya.toNumericValue(data.getYValue()) - getDoubleValue(data.getExtraValue(), 0)));
                        }
                    }
                }
            }
            if(xData != null) xa.invalidateRange(xData);
            if(yData != null) ya.invalidateRange(yData);
        }
    }

    @Override
    LegendItem createLegendItemForSeries(Series&lt;X, Y&gt; series, int seriesIndex) {
        LegendItem legendItem = new LegendItem(series.getName());
        legendItem.getSymbol().getStyleClass().addAll(&quot;series&quot; + seriesIndex, &quot;chart-bubble&quot;,
                &quot;bubble-legend-symbol&quot;, series.defaultColorStyleClass);
        return legendItem;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/chart/StackedBarChart.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.chart;


import java.util.*;

import javafx.animation.*;
import javafx.application.Platform;
import javafx.beans.NamedArg;
import javafx.beans.property.DoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.Orientation;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.layout.StackPane;
import javafx.util.Duration;

import com.sun.javafx.charts.Legend.LegendItem;

import javafx.css.StyleableDoubleProperty;
import javafx.css.CssMetaData;
import javafx.css.PseudoClass;

import javafx.css.converter.SizeConverter;

import javafx.collections.ListChangeListener;
import javafx.css.Styleable;
import javafx.css.StyleableProperty;


/**
 * StackedBarChart is a variation of {@link BarChart} that plots bars indicating
 * data values for a category. The bars can be vertical or horizontal depending
 * on which axis is a category axis.
 * The bar for each series is stacked on top of the previous series.
 * @since JavaFX 2.1
 */
public class StackedBarChart&lt;X, Y&gt; extends XYChart&lt;X, Y&gt; {

    // -------------- PRIVATE FIELDS -------------------------------------------
    private Map&lt;Series&lt;X, Y&gt;, Map&lt;String, List&lt;Data&lt;X, Y&gt;&gt;&gt;&gt; seriesCategoryMap =
            new HashMap&lt;&gt;();
    private final Orientation orientation;
    private CategoryAxis categoryAxis;
    private ValueAxis valueAxis;
    // RT-23125 handling data removal when a category is removed.
    private ListChangeListener&lt;String&gt; categoriesListener = new ListChangeListener&lt;String&gt;() {
        @Override public void onChanged(ListChangeListener.Change&lt;? extends String&gt; c) {
            while (c.next()) {
                for(String cat : c.getRemoved()) {
                    for (Series&lt;X, Y&gt; series : getData()) {
                        for (Data&lt;X, Y&gt; data : series.getData()) {
                            if ((cat).equals((orientation == orientation.VERTICAL) ?
                                    data.getXValue() : data.getYValue())) {
                                boolean animatedOn = getAnimated();
                                setAnimated(false);
                                dataItemRemoved(data, series);
                                setAnimated(animatedOn);
                            }
                        }
                    }
                    requestChartLayout();
                }
            }
        }
    };

    // -------------- PUBLIC PROPERTIES ----------------------------------------
    /** The gap to leave between bars in separate categories */
    private DoubleProperty categoryGap = new StyleableDoubleProperty(10) {
        @Override protected void invalidated() {
            get();
            requestChartLayout();
        }

        @Override
        public Object getBean() {
            return StackedBarChart.this;
        }

        @Override
        public String getName() {
            return &quot;categoryGap&quot;;
        }

        public CssMetaData&lt;StackedBarChart&lt;?,?&gt;,Number&gt; getCssMetaData() {
            return StackedBarChart.StyleableProperties.CATEGORY_GAP;
        }
    };

    public double getCategoryGap() {
        return categoryGap.getValue();
    }

    public void setCategoryGap(double value) {
        categoryGap.setValue(value);
    }

    public DoubleProperty categoryGapProperty() {
        return categoryGap;
    }

    // -------------- CONSTRUCTOR ----------------------------------------------
    /**
     * Construct a new StackedBarChart with the given axis. The two axis should be a ValueAxis/NumberAxis and a CategoryAxis,
     * they can be in either order depending on if you want a horizontal or vertical bar chart.
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     */
    public StackedBarChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis) {
        this(xAxis, yAxis, FXCollections.&lt;Series&lt;X, Y&gt;&gt;observableArrayList());
    }

    /**
     * Construct a new StackedBarChart with the given axis and data. The two axis should be a ValueAxis/NumberAxis and a
     * CategoryAxis, they can be in either order depending on if you want a horizontal or vertical bar chart.
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart
     */
    public StackedBarChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis, @NamedArg(&quot;data&quot;) ObservableList&lt;Series&lt;X, Y&gt;&gt; data) {
        super(xAxis, yAxis);
        getStyleClass().add(&quot;stacked-bar-chart&quot;);
        if (!((xAxis instanceof ValueAxis &amp;&amp; yAxis instanceof CategoryAxis)
                || (yAxis instanceof ValueAxis &amp;&amp; xAxis instanceof CategoryAxis))) {
            throw new IllegalArgumentException(&quot;Axis type incorrect, one of X,Y should be CategoryAxis and the other NumberAxis&quot;);
        }
        if (xAxis instanceof CategoryAxis) {
            categoryAxis = (CategoryAxis) xAxis;
            valueAxis = (ValueAxis) yAxis;
            orientation = Orientation.VERTICAL;
        } else {
            categoryAxis = (CategoryAxis) yAxis;
            valueAxis = (ValueAxis) xAxis;
            orientation = Orientation.HORIZONTAL;
        }
        // update css
        pseudoClassStateChanged(HORIZONTAL_PSEUDOCLASS_STATE, orientation == Orientation.HORIZONTAL);
        pseudoClassStateChanged(VERTICAL_PSEUDOCLASS_STATE, orientation == Orientation.VERTICAL);
        setData(data);
        categoryAxis.getCategories().addListener(categoriesListener);
    }

    /**
     * Construct a new StackedBarChart with the given axis and data. The two axis should be a ValueAxis/NumberAxis and a
     * CategoryAxis, they can be in either order depending on if you want a horizontal or vertical bar chart.
     *
     * @param xAxis The x axis to use
     * @param yAxis The y axis to use
     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart
     * @param categoryGap The gap to leave between bars in separate categories
     */
    public StackedBarChart(@NamedArg(&quot;xAxis&quot;) Axis&lt;X&gt; xAxis, @NamedArg(&quot;yAxis&quot;) Axis&lt;Y&gt; yAxis, @NamedArg(&quot;data&quot;) ObservableList&lt;Series&lt;X, Y&gt;&gt; data, @NamedArg(&quot;categoryGap&quot;) double categoryGap) {
        this(xAxis, yAxis);
        setData(data);
        setCategoryGap(categoryGap);
    }

    // -------------- METHODS --------------------------------------------------
    @Override protected void dataItemAdded(Series&lt;X, Y&gt; series, int itemIndex, Data&lt;X, Y&gt; item) {
        String category;
        if (orientation == Orientation.VERTICAL) {
            category = (String) item.getXValue();
        } else {
            category = (String) item.getYValue();
        }
        // Don't plot if category does not already exist ?
//        if (!categoryAxis.getCategories().contains(category)) return;

        Map&lt;String, List&lt;Data&lt;X, Y&gt;&gt;&gt; categoryMap = seriesCategoryMap.get(series);

        if (categoryMap == null) {
            categoryMap = new HashMap&lt;String, List&lt;Data&lt;X, Y&gt;&gt;&gt;();
            seriesCategoryMap.put(series, categoryMap);
        }
        // list to hold more that one bar &quot;positive and negative&quot;
        List&lt;Data&lt;X, Y&gt;&gt; itemList = categoryMap.get(category) != null ? categoryMap.get(category) : new ArrayList&lt;Data&lt;X, Y&gt;&gt;();
        itemList.add(item);
        categoryMap.put(category, itemList);
//        categoryMap.put(category, item);
        Node bar = createBar(series, getData().indexOf(series), item, itemIndex);
        if (shouldAnimate()) {
            animateDataAdd(item, bar);
        } else {
            getPlotChildren().add(bar);
        }
    }

    @Override protected void dataItemRemoved(final Data&lt;X, Y&gt; item, final Series&lt;X, Y&gt; series) {
        final Node bar = item.getNode();

        if (bar != null) {
            bar.focusTraversableProperty().unbind();
        }

        if (shouldAnimate()) {
            Timeline t = createDataRemoveTimeline(item, bar, series);
            t.setOnFinished(event -&gt; {
                removeDataItemFromDisplay(series, item);
            });
            t.play();
        } else {
            processDataRemove(series, item);
            removeDataItemFromDisplay(series, item);
        }
    }

    /** {@inheritDoc} */
    @Override protected void dataItemChanged(Data&lt;X, Y&gt; item) {
        double barVal;
        double currentVal;
        if (orientation == Orientation.VERTICAL) {
            barVal = ((Number) item.getYValue()).doubleValue();
            currentVal = ((Number) getCurrentDisplayedYValue(item)).doubleValue();
        } else {
            barVal = ((Number) item.getXValue()).doubleValue();
            currentVal = ((Number) getCurrentDisplayedXValue(item)).doubleValue();
        }
        if (currentVal &gt; 0 &amp;&amp; barVal &lt; 0) { // going from positive to negative
            // add style class negative
            item.getNode().getStyleClass().add(&quot;negative&quot;);
        } else if (currentVal &lt; 0 &amp;&amp; barVal &gt; 0) { // going from negative to positive
            // remove style class negative
            item.getNode().getStyleClass().remove(&quot;negative&quot;);
        }
    }

    @Override protected void seriesChanged(ListChangeListener.Change&lt;? extends Series&gt; c) {
        // Update style classes for all series lines and symbols
        // Note: is there a more efficient way of doing this?
        for (int i = 0; i &lt; getDataSize(); i++) {
            final Series&lt;X,Y&gt; series = getData().get(i);
            for (int j=0; j&lt;series.getData().size(); j++) {
                Data&lt;X,Y&gt; item = series.getData().get(j);
                Node bar = item.getNode();
                bar.getStyleClass().setAll(&quot;chart-bar&quot;, &quot;series&quot; + i, &quot;data&quot; + j, series.defaultColorStyleClass);
            }
        }
    }

    /** {@inheritDoc} */
    @Override protected void seriesAdded(Series&lt;X, Y&gt; series, int seriesIndex) {
        // handle any data already in series
        // create entry in the map
        Map&lt;String, List&lt;Data&lt;X, Y&gt;&gt;&gt; categoryMap = new HashMap&lt;String, List&lt;Data&lt;X, Y&gt;&gt;&gt;();
        for (int j = 0; j &lt; series.getData().size(); j++) {
            Data&lt;X, Y&gt; item = series.getData().get(j);
            Node bar = createBar(series, seriesIndex, item, j);
            String category;
            if (orientation == Orientation.VERTICAL) {
                category = (String) item.getXValue();
            } else {
                category = (String) item.getYValue();
            }
            // list of two item positive and negative
            List&lt;Data&lt;X, Y&gt;&gt; itemList = categoryMap.get(category) != null ? categoryMap.get(category) : new ArrayList&lt;Data&lt;X, Y&gt;&gt;();
            itemList.add(item);
            categoryMap.put(category, itemList);
            if (shouldAnimate()) {
                animateDataAdd(item, bar);
            } else {
                double barVal = (orientation == Orientation.VERTICAL) ? ((Number)item.getYValue()).doubleValue() :
                    ((Number)item.getXValue()).doubleValue();
                if (barVal &lt; 0) {
                    bar.getStyleClass().add(&quot;negative&quot;);
                }
                getPlotChildren().add(bar);
            }
        }
        if (categoryMap.size() &gt; 0) {
            seriesCategoryMap.put(series, categoryMap);
        }
    }

    @Override protected void seriesRemoved(final Series&lt;X, Y&gt; series) {
        // remove all symbol nodes
        if (shouldAnimate()) {
            ParallelTransition pt = new ParallelTransition();
            pt.setOnFinished(event -&gt; {
                removeSeriesFromDisplay(series);
                requestChartLayout();
            });
            for (Data&lt;X, Y&gt; d : series.getData()) {
                final Node bar = d.getNode();
                // Animate series deletion
                if (getSeriesSize() &gt; 1) {
                    Timeline t = createDataRemoveTimeline(d, bar, series);
                    pt.getChildren().add(t);
                } else {
                    // fade out last series
                    FadeTransition ft = new FadeTransition(Duration.millis(700), bar);
                    ft.setFromValue(1);
                    ft.setToValue(0);
                    ft.setOnFinished(actionEvent -&gt; {
                        processDataRemove(series, d);
                        bar.setOpacity(1.0);
                    });
                    pt.getChildren().add(ft);
                }
            }
            pt.play();
        } else {
            for (Data&lt;X, Y&gt; d : series.getData()) {
                processDataRemove(series, d);
            }
            removeSeriesFromDisplay(series);
            requestChartLayout();
        }
    }

    /** {@inheritDoc} */
    @Override protected void updateAxisRange() {
        // This override is necessary to update axis range based on cumulative Y value for the
        // Y axis instead of the inherited way where the max value in the data range is used.
        boolean categoryIsX = categoryAxis == getXAxis();
        if (categoryAxis.isAutoRanging()) {
            List cData = new ArrayList();
            for (Series&lt;X, Y&gt; series : getData()) {
                for (Data&lt;X, Y&gt; data : series.getData()) {
                    if (data != null) cData.add(categoryIsX ? data.getXValue() : data.getYValue());
                }
            }
            categoryAxis.invalidateRange(cData);
        }
        if (valueAxis.isAutoRanging()) {
            List&lt;Number&gt; vData = new ArrayList&lt;&gt;();
            for (String category : categoryAxis.getAllDataCategories()) {
                double totalXN = 0;
                double totalXP = 0;
                Iterator&lt;Series&lt;X, Y&gt;&gt; seriesIterator = getDisplayedSeriesIterator();
                while (seriesIterator.hasNext()) {
                    Series&lt;X, Y&gt; series = seriesIterator.next();
                    for (final Data&lt;X, Y&gt; item : getDataItem(series, category)) {
                        if (item != null) {
                            boolean isNegative = item.getNode().getStyleClass().contains(&quot;negative&quot;);
                            Number value = (Number) (categoryIsX ? item.getYValue() : item.getXValue());
                            if (!isNegative) {
                                totalXP += valueAxis.toNumericValue(value);
                            } else {
                                totalXN += valueAxis.toNumericValue(value);
                            }
                        }
                    }
                }
                vData.add(totalXP);
                vData.add(totalXN);
            }
            valueAxis.invalidateRange(vData);
        }
    }

    /** {@inheritDoc} */
    @Override protected void layoutPlotChildren() {
        double catSpace = categoryAxis.getCategorySpacing();
        // calculate bar spacing
        final double availableBarSpace = catSpace - getCategoryGap();
        final double barWidth = availableBarSpace;
        final double barOffset = -((catSpace - getCategoryGap()) / 2);
        // update bar positions and sizes
        for (String category : categoryAxis.getCategories()) {
            double currentPositiveValue = 0;
            double currentNegativeValue = 0;
            Iterator&lt;Series&lt;X, Y&gt;&gt; seriesIterator = getDisplayedSeriesIterator();
            while (seriesIterator.hasNext()) {
                Series&lt;X, Y&gt; series = seriesIterator.next();
                for (final Data&lt;X, Y&gt; item : getDataItem(series, category)) {
                    if (item != null) {
                        final Node bar = item.getNode();
                        final double categoryPos;
                        final double valNumber;
                        final X xValue = getCurrentDisplayedXValue(item);
                        final Y yValue = getCurrentDisplayedYValue(item);
                        if (orientation == Orientation.VERTICAL) {
                            categoryPos = getXAxis().getDisplayPosition(xValue);
                            valNumber = getYAxis().toNumericValue(yValue);
                        } else {
                            categoryPos = getYAxis().getDisplayPosition(yValue);
                            valNumber = getXAxis().toNumericValue(xValue);
                        }
                        double bottom;
                        double top;
                        boolean isNegative = bar.getStyleClass().contains(&quot;negative&quot;);
                        if (!isNegative) {
                            bottom = valueAxis.getDisplayPosition(currentPositiveValue);
                            top = valueAxis.getDisplayPosition(currentPositiveValue + valNumber);
                            currentPositiveValue += valNumber;
                        } else {
                            bottom = valueAxis.getDisplayPosition(currentNegativeValue + valNumber);
                            top = valueAxis.getDisplayPosition(currentNegativeValue);
                            currentNegativeValue += valNumber;
                        }

                        if (orientation == Orientation.VERTICAL) {
                            bar.resizeRelocate(categoryPos + barOffset,
                                    top, barWidth, bottom - top);
                        } else {
                            bar.resizeRelocate(bottom,
                                    categoryPos + barOffset,
                                    top - bottom, barWidth);
                        }
                    }
                }
            }
        }
    }

    @Override
    LegendItem createLegendItemForSeries(Series&lt;X, Y&gt; series, int seriesIndex) {
        LegendItem legendItem = new LegendItem(series.getName());
        legendItem.getSymbol().getStyleClass().addAll(&quot;chart-bar&quot;, &quot;series&quot; + seriesIndex,
                &quot;bar-legend-symbol&quot;, series.defaultColorStyleClass);
        return legendItem;
    }

    private void updateMap(Series&lt;X,Y&gt; series, Data&lt;X,Y&gt; item) {
        final String category = (orientation == Orientation.VERTICAL) ? (String)item.getXValue() :
                                     (String)item.getYValue();
        Map&lt;String, List&lt;Data&lt;X, Y&gt;&gt;&gt; categoryMap = seriesCategoryMap.get(series);
        if (categoryMap != null) {
            categoryMap.remove(category);
            if (categoryMap.isEmpty()) seriesCategoryMap.remove(series);
        }
        if (seriesCategoryMap.isEmpty() &amp;&amp; categoryAxis.isAutoRanging()) categoryAxis.getCategories().clear();
    }

    private void processDataRemove(final Series&lt;X,Y&gt; series, final Data&lt;X,Y&gt; item) {
        Node bar = item.getNode();
        getPlotChildren().remove(bar);
        updateMap(series, item);
    }

    private void animateDataAdd(Data&lt;X, Y&gt; item, Node bar) {
        double barVal;
        if (orientation == Orientation.VERTICAL) {
            barVal = ((Number) item.getYValue()).doubleValue();
            if (barVal &lt; 0) {
                bar.getStyleClass().add(&quot;negative&quot;);
            }
            item.setYValue(getYAxis().toRealValue(getYAxis().getZeroPosition()));
            setCurrentDisplayedYValue(item, getYAxis().toRealValue(getYAxis().getZeroPosition()));
            getPlotChildren().add(bar);
            item.setYValue(getYAxis().toRealValue(barVal));
            animate(
                    new KeyFrame(Duration.ZERO, new KeyValue(
                            currentDisplayedYValueProperty(item),
                            getCurrentDisplayedYValue(item))),
                    new KeyFrame(Duration.millis(700), new KeyValue(
                            currentDisplayedYValueProperty(item),
                            item.getYValue(), Interpolator.EASE_BOTH))
            );
        } else {
            barVal = ((Number) item.getXValue()).doubleValue();
            if (barVal &lt; 0) {
                bar.getStyleClass().add(&quot;negative&quot;);
            }
            item.setXValue(getXAxis().toRealValue(getXAxis().getZeroPosition()));
            setCurrentDisplayedXValue(item, getXAxis().toRealValue(getXAxis().getZeroPosition()));
            getPlotChildren().add(bar);
            item.setXValue(getXAxis().toRealValue(barVal));
            animate(
                    new KeyFrame(Duration.ZERO, new KeyValue(
                            currentDisplayedXValueProperty(item),
                            getCurrentDisplayedXValue(item))),
                    new KeyFrame(Duration.millis(700), new KeyValue(
                            currentDisplayedXValueProperty(item),
                            item.getXValue(), Interpolator.EASE_BOTH))
            );
        }
    }

    private Timeline createDataRemoveTimeline(Data&lt;X, Y&gt; item, final Node bar, final Series&lt;X, Y&gt; series) {
        Timeline t = new Timeline();
        if (orientation == Orientation.VERTICAL) {
            item.setYValue(getYAxis().toRealValue(getYAxis().getZeroPosition()));
<A NAME="18"></A>            t.getKeyFrames().addAll(
                    new KeyFrame(Duration.ZERO, new KeyValue(
                            currentDisplayedYValueProperty(item),
                            <FONT color="#f62817"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#18',2,'match49-top.html#18',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>getCurrentDisplayedYValue(item))),
                    new KeyFrame(Duration.millis(700), actionEvent -&gt; {
                        processDataRemove(series, item);
                    }, new KeyValue(
                            currentDisplayedYValueProperty(item),
                            item.getYValue(), Interpolator.EASE_BOTH))
            );
        }</B></FONT> else {
            item.setXValue(getXAxis().toRealValue(getXAxis().getZeroPosition()));
            t.getKeyFrames().addAll(
                    new KeyFrame(Duration.ZERO, new KeyValue(
                            currentDisplayedXValueProperty(item),
                            getCurrentDisplayedXValue(item))),
                    new KeyFrame(Duration.millis(700), actionEvent -&gt; {
                        processDataRemove(series, item);
                    }, new KeyValue(
                            currentDisplayedXValueProperty(item),
                            item.getXValue(), Interpolator.EASE_BOTH))
            );
        }
        return t;
    }

    private Node createBar(Series&lt;X, Y&gt; series, int seriesIndex, final Data&lt;X, Y&gt; item, int itemIndex) {
        Node bar = item.getNode();
        if (bar == null) {
            bar = new StackPane();
            bar.setAccessibleRole(AccessibleRole.TEXT);
            bar.setAccessibleRoleDescription(&quot;Bar&quot;);
            bar.focusTraversableProperty().bind(Platform.accessibilityActiveProperty());
            item.setNode(bar);
        }
        bar.getStyleClass().setAll(&quot;chart-bar&quot;, &quot;series&quot; + seriesIndex, &quot;data&quot; + itemIndex, series.defaultColorStyleClass);
        return bar;
    }

    private List&lt;Data&lt;X, Y&gt;&gt; getDataItem(Series&lt;X, Y&gt; series, String category) {
        Map&lt;String, List&lt;Data&lt;X, Y&gt;&gt;&gt; catmap = seriesCategoryMap.get(series);
        return catmap != null ? catmap.get(category) != null ?
            catmap.get(category) : new ArrayList&lt;Data&lt;X, Y&gt;&gt;() : new ArrayList&lt;Data&lt;X, Y&gt;&gt;();
    }

// -------------- STYLESHEET HANDLING ------------------------------------------------------------------------------

    /*
     * Super-lazy instantiation pattern from Bill Pugh.
     */
    private static class StyleableProperties {

        private static final CssMetaData&lt;StackedBarChart&lt;?,?&gt;,Number&gt; CATEGORY_GAP =
            new CssMetaData&lt;StackedBarChart&lt;?,?&gt;,Number&gt;(&quot;-fx-category-gap&quot;,
                SizeConverter.getInstance(), 10.0)  {

            @Override
            public boolean isSettable(StackedBarChart&lt;?,?&gt; node) {
                return node.categoryGap == null || !node.categoryGap.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(StackedBarChart&lt;?,?&gt; node) {
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)node.categoryGapProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                    new ArrayList&lt;&gt;(XYChart.getClassCssMetaData());
            styleables.add(CATEGORY_GAP);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    /** Pseudoclass indicating this is a vertical chart. */
    private static final PseudoClass VERTICAL_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;vertical&quot;);

    /** Pseudoclass indicating this is a horizontal chart. */
    private static final PseudoClass HORIZONTAL_PSEUDOCLASS_STATE =
            PseudoClass.getPseudoClass(&quot;horizontal&quot;);

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/Tab.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import com.sun.javafx.beans.IDProperty;
import com.sun.javafx.scene.control.ControlAcceleratorSupport;
import javafx.collections.ObservableSet;
import javafx.css.CssMetaData;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ObjectPropertyBase;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.css.PseudoClass;
import javafx.event.Event;
import javafx.event.EventDispatchChain;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.event.EventType;
import javafx.scene.Node;

import javafx.css.Styleable;
import com.sun.javafx.event.EventHandlerManager;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Set;

import javafx.beans.DefaultProperty;
import javafx.beans.InvalidationListener;
import javafx.beans.property.BooleanPropertyBase;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyBooleanWrapper;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.collections.ObservableMap;

/**
 * &lt;p&gt;Tabs are placed within a {@link TabPane}, where each tab represents a single
 * 'page'.&lt;/p&gt;
 * &lt;p&gt;Tabs can contain any {@link Node} such as UI controls or groups
 * of nodes added to a layout container.&lt;/p&gt;
 * &lt;p&gt;When the user clicks
 * on a Tab in the TabPane the Tab content becomes visible to the user.&lt;/p&gt;
 * @since JavaFX 2.0
 */
@DefaultProperty(&quot;content&quot;)
@IDProperty(&quot;id&quot;)
public class Tab implements EventTarget, Styleable {

    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a tab with no title.
     */
    public Tab() {
        this(null);
    }

    /**
     * Creates a tab with a text title.
     *
     * @param text The title of the tab.
     */
    public Tab(String text) {
        this(text, null);
    }

    /**
     * Creates a tab with a text title and the specified content node.
     *
     * @param text The title of the tab.
     * @param content The content of the tab.
     * @since JavaFX 8u40
     */
    public Tab(String text, Node content) {
        setText(text);
        setContent(content);
        styleClass.addAll(DEFAULT_STYLE_CLASS);
    }


    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    private StringProperty id;

    /**
     * Sets the id of this tab. This simple string identifier is useful for
     * finding a specific Tab within the {@code TabPane}. The default value is {@code null}.
     * @param value the id of this tab
     */
   public final void setId(String value) { idProperty().set(value); }

    /**
     * The id of this tab.
     *
     * @return The id of the tab.
     */
    @Override
    public final String getId() { return id == null ? null : id.get(); }

    /**
     * The id of this tab.
     * @return the id property of this tab
     */
    public final StringProperty idProperty() {
        if (id == null) {
            id = new SimpleStringProperty(this, &quot;id&quot;);
        }
        return id;
    }

    private StringProperty style;

    /**
     * A string representation of the CSS style associated with this
     * tab. This is analogous to the &quot;style&quot; attribute of an
     * HTML element. Note that, like the HTML style attribute, this
     * variable contains style properties and values and not the
     * selector portion of a style rule.
     * &lt;p&gt;
     * Parsing this style might not be supported on some limited
     * platforms. It is recommended to use a standalone CSS file instead.
     *
     * @param value the style string
     */
   public final void setStyle(String value) { styleProperty().set(value); }

    /**
     * The CSS style string associated to this tab.
     *
     * @return The CSS style string associated to this tab.
     */
    @Override
    public final String getStyle() { return style == null ? null : style.get(); }

    /**
     * The CSS style string associated to this tab.
     * @return the CSS style string property associated to this tab
     */
    public final StringProperty styleProperty() {
        if (style == null) {
            style = new SimpleStringProperty(this, &quot;style&quot;);
        }
        return style;
    }

    private ReadOnlyBooleanWrapper selected;

    final void setSelected(boolean value) {
        selectedPropertyImpl().set(value);
    }

    /**
     * &lt;p&gt;Represents whether this tab is the currently selected tab,
     * To change the selected Tab use {@code tabPane.getSelectionModel().select()}
     * &lt;/p&gt;
     * @return true if selected
     */
    public final boolean isSelected() {
        return selected == null ? false : selected.get();
    }

    /**
     * The currently selected tab.
     * @return the selected tab
     */
    public final ReadOnlyBooleanProperty selectedProperty() {
        return selectedPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyBooleanWrapper selectedPropertyImpl() {
        if (selected == null) {
            selected = new ReadOnlyBooleanWrapper() {
                @Override protected void invalidated() {
                    if (getOnSelectionChanged() != null) {
                        Event.fireEvent(Tab.this, new Event(SELECTION_CHANGED_EVENT));
                    }
                }

                @Override
                public Object getBean() {
                    return Tab.this;
                }

                @Override
                public String getName() {
                    return &quot;selected&quot;;
                }
            };
        }
        return selected;
    }

    private ReadOnlyObjectWrapper&lt;TabPane&gt; tabPane;

    final void setTabPane(TabPane value) {
        tabPanePropertyImpl().set(value);
    }

    /**
     * &lt;p&gt;A reference to the TabPane that contains this tab instance.&lt;/p&gt;
     * @return the TabPane
     */
    public final TabPane getTabPane() {
        return tabPane == null ? null : tabPane.get();
    }

    /**
     * The TabPane that contains this tab.
     * @return the TabPane property
     */
    public final ReadOnlyObjectProperty&lt;TabPane&gt; tabPaneProperty() {
        return tabPanePropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyObjectWrapper&lt;TabPane&gt; tabPanePropertyImpl() {
        if (tabPane == null) {
            tabPane = new ReadOnlyObjectWrapper&lt;TabPane&gt;(this, &quot;tabPane&quot;) {
                private WeakReference&lt;TabPane&gt; oldParent;

                @Override protected void invalidated() {
                    if(oldParent != null &amp;&amp; oldParent.get() != null) {
                        oldParent.get().disabledProperty().removeListener(parentDisabledChangedListener);
                    }
                    updateDisabled();
                    TabPane newParent = get();
                    if (newParent != null) {
                        newParent.disabledProperty().addListener(parentDisabledChangedListener);
                    }
                    oldParent = new WeakReference&lt;TabPane&gt;(newParent);
                    super.invalidated();
                }
            };
        }
        return tabPane;
    }

    private final InvalidationListener parentDisabledChangedListener = valueModel -&gt; {
        updateDisabled();
    };

    private StringProperty text;

    /**
     * &lt;p&gt;Sets the text to show in the tab to allow the user to differentiate between
     * the function of each tab. The text is always visible
     * &lt;/p&gt;
     * @param value the text string
     */
    public final void setText(String value) {
        textProperty().set(value);
    }

    /**
     * The text shown in the tab.
     *
     * @return The text shown in the tab.
     */
    public final String getText() {
        return text == null ? null : text.get();
    }

    /**
     * The text shown in the tab.
     * @return the text property
     */
    public final StringProperty textProperty() {
        if (text == null) {
            text = new SimpleStringProperty(this, &quot;text&quot;);
        }
        return text;
    }

    private ObjectProperty&lt;Node&gt; graphic;

    /**
     * &lt;p&gt;Sets the graphic to show in the tab to allow the user to differentiate
     * between the function of each tab. By default the graphic does not rotate
     * based on the TabPane.tabPosition value, but it can be set to rotate by
     * setting TabPane.rotateGraphic to true.&lt;/p&gt;
     * @param value the graphic node
     */
    public final void setGraphic(Node value) {
        graphicProperty().set(value);
    }

    /**
     * The graphic shown in the tab.
     *
     * @return The graphic shown in the tab.
     */
    public final Node getGraphic() {
        return graphic == null ? null : graphic.get();
    }

    /**
     * The graphic in the tab.
     *
     * @return The graphic in the tab.
     */
    public final ObjectProperty&lt;Node&gt; graphicProperty() {
        if (graphic == null) {
            graphic = new SimpleObjectProperty&lt;Node&gt;(this, &quot;graphic&quot;);
        }
        return graphic;
    }

    private ObjectProperty&lt;Node&gt; content;

    /**
     * &lt;p&gt;The content to show within the main TabPane area. The content
     * can be any Node such as UI controls or groups of nodes added
     * to a layout container.&lt;/p&gt;
     * @param value the content node
     */
    public final void setContent(Node value) {
        contentProperty().set(value);
    }

    /**
     * &lt;p&gt;The content associated with the tab.&lt;/p&gt;
     *
     * @return The content associated with the tab.
     */
    public final Node getContent() {
        return content == null ? null : content.get();
    }

    /**
     * &lt;p&gt;The content associated with the tab.&lt;/p&gt;
     * @return the content property
     */
    public final ObjectProperty&lt;Node&gt; contentProperty() {
        if (content == null) {
            content = new SimpleObjectProperty&lt;Node&gt;(this, &quot;content&quot;) {
                @Override protected void invalidated() {
                    updateDisabled();
                }
            };
        }
        return content;
    }


    private ObjectProperty&lt;ContextMenu&gt; contextMenu;

    /**
     * &lt;p&gt;Specifies the context menu to show when the user right-clicks on the tab.
     * &lt;/p&gt;
     * @param value the context menu
     */
    public final void setContextMenu(ContextMenu value) {
        contextMenuProperty().set(value);
    }

    /**
     * The context menu associated with the tab.
     * @return The context menu associated with the tab.
     */
    public final ContextMenu getContextMenu() {
        return contextMenu == null ? null : contextMenu.get();
    }

    /**
     * The context menu associated with the tab.
     * @return the context menu property
     */
    public final ObjectProperty&lt;ContextMenu&gt; contextMenuProperty() {
        if (contextMenu == null) {
            contextMenu = new SimpleObjectProperty&lt;ContextMenu&gt;(this, &quot;contextMenu&quot;) {
                private WeakReference&lt;ContextMenu&gt; contextMenuRef;

                @Override protected void invalidated() {
                    ContextMenu oldMenu = contextMenuRef == null ? null : contextMenuRef.get();
                    if (oldMenu != null) {
                        ControlAcceleratorSupport.removeAcceleratorsFromScene(oldMenu.getItems(), Tab.this);
                    }

                    ContextMenu ctx = get();
                    contextMenuRef = new WeakReference&lt;&gt;(ctx);

                    if (ctx != null) {
                        // if a context menu is set, we need to install any accelerators
                        // belonging to its menu items ASAP into the scene that this
                        // Control is in (if the control is not in a Scene, we will need
                        // to wait until it is and then do it).
                        ControlAcceleratorSupport.addAcceleratorsIntoScene(ctx.getItems(), Tab.this);
                    }
                }
            };
        }
        return contextMenu;
    }

    private BooleanProperty closable;

    /**
     * &lt;p&gt;Sets {@code true} if the tab is closable.  If this is set to {@code false},
     * then regardless of the TabClosingPolicy, it will not be
     * possible for the user to close this tab. Therefore, when this
     * property is {@code false}, no 'close' button will be shown on the tab.
     * The default is {@code true}.&lt;/p&gt;
     *
     * @param value the closable value
     */
    public final void setClosable(boolean value) {
        closableProperty().set(value);
    }

    /**
     * Returns {@code true} if this tab is closable.
     *
     * @return {@code true} if the tab is closable.
     */
    public final boolean isClosable() {
        return closable == null ? true : closable.get();
    }

    /**
     * The closable state for this tab.
     * @return the closable property
     */
    public final BooleanProperty closableProperty() {
        if (closable == null) {
            closable = new SimpleBooleanProperty(this, &quot;closable&quot;, true);
        }
        return closable;
    }


    /**
     * &lt;p&gt;Called when the tab becomes selected or unselected.&lt;/p&gt;
     */
    public static final EventType&lt;Event&gt; SELECTION_CHANGED_EVENT =
            new EventType&lt;Event&gt; (Event.ANY, &quot;SELECTION_CHANGED_EVENT&quot;);
    private ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onSelectionChanged;

    /**
     * Defines a function to be called when a selection changed has occurred on the tab.
     * @param value the on selection changed event handler
     */
    public final void setOnSelectionChanged(EventHandler&lt;Event&gt; value) {
        onSelectionChangedProperty().set(value);
    }

    /**
     * The event handler that is associated with a selection on the tab.
     *
     * @return The event handler that is associated with a tab selection.
     */
    public final EventHandler&lt;Event&gt; getOnSelectionChanged() {
        return onSelectionChanged == null ? null : onSelectionChanged.get();
    }

    /**
     * The event handler that is associated with a selection on the tab.
     * @return the on selection changed event handler property
     */
    public final ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onSelectionChangedProperty() {
        if (onSelectionChanged == null) {
            onSelectionChanged = new ObjectPropertyBase&lt;EventHandler&lt;Event&gt;&gt;() {
                @Override protected void invalidated() {
                    setEventHandler(SELECTION_CHANGED_EVENT, get());
                }

                @Override
                public Object getBean() {
                    return Tab.this;
                }

                @Override
                public String getName() {
                    return &quot;onSelectionChanged&quot;;
                }
            };
        }
        return onSelectionChanged;
    }

    /**
     * &lt;p&gt;Called when a user closes this tab. This is useful for freeing up memory.&lt;/p&gt;
     */
    public static final EventType&lt;Event&gt; CLOSED_EVENT = new EventType&lt;Event&gt;(Event.ANY, &quot;TAB_CLOSED&quot;);
    private ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onClosed;

    /**
     * Defines a function to be called when the tab is closed.
     * @param value the on closed event handler
     */
    public final void setOnClosed(EventHandler&lt;Event&gt; value) {
        onClosedProperty().set(value);
    }

    /**
     * The event handler that is associated with the tab when the tab is closed.
     *
     * @return The event handler that is associated with the tab when the tab is closed.
     */
    public final EventHandler&lt;Event&gt; getOnClosed() {
        return onClosed == null ? null : onClosed.get();
    }

    /**
     * The event handler that is associated with the tab when the tab is closed.
     * @return the on closed event handler property
     */
    public final ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onClosedProperty() {
        if (onClosed == null) {
            onClosed = new ObjectPropertyBase&lt;EventHandler&lt;Event&gt;&gt;() {
                @Override protected void invalidated() {
                    setEventHandler(CLOSED_EVENT, get());
                }

                @Override
                public Object getBean() {
                    return Tab.this;
                }

                @Override
                public String getName() {
                    return &quot;onClosed&quot;;
                }
            };
        }
        return onClosed;
    }

    private ObjectProperty&lt;Tooltip&gt; tooltip;

    /**
     * &lt;p&gt;Specifies the tooltip to show when the user hovers over the tab.&lt;/p&gt;
     * @param value the tool tip value
     */
    public final void setTooltip(Tooltip value) { tooltipProperty().setValue(value); }

    /**
     * The tooltip associated with this tab.
     * @return The tooltip associated with this tab.
     */
    public final Tooltip getTooltip() { return tooltip == null ? null : tooltip.getValue(); }

    /**
     * The tooltip associated with this tab.
     * @return the tool tip property
     */
    public final ObjectProperty&lt;Tooltip&gt; tooltipProperty() {
        if (tooltip == null) {
            tooltip = new SimpleObjectProperty&lt;Tooltip&gt;(this, &quot;tooltip&quot;);
        }
        return tooltip;
    }

    private final ObservableList&lt;String&gt; styleClass = FXCollections.observableArrayList();

    private BooleanProperty disable;

    /**
     * Sets the disabled state of this tab.
     *
     * @param value the state to set this tab
     *
     * @defaultValue false
     * @since JavaFX 2.2
     */
    public final void setDisable(boolean value) {
        disableProperty().set(value);
    }

    /**
     * Returns {@code true} if this tab is disable.
     * @return true if this tab is disable
     * @since JavaFX 2.2
     */
    public final boolean isDisable() { return disable == null ? false : disable.get(); }

    /**
     * Sets the disabled state of this tab. A disable tab is no longer interactive
     * or traversable, but the contents remain interactive.  A disable tab
     * can be selected using {@link TabPane#getSelectionModel()}.
     *
     * @return the disable property
     * @defaultValue false
     * @since JavaFX 2.2
     */
    public final BooleanProperty disableProperty() {
        if (disable == null) {
            disable = new BooleanPropertyBase(false) {
                @Override
                protected void invalidated() {
                    updateDisabled();
                }

                @Override
                public Object getBean() {
                    return Tab.this;
                }

                @Override
                public String getName() {
                    return &quot;disable&quot;;
                }
            };
        }
        return disable;
    }

    private ReadOnlyBooleanWrapper disabled;

    private final void setDisabled(boolean value) {
        disabledPropertyImpl().set(value);
    }

    /**
     * Returns true when the {@code Tab} {@link #disableProperty disable} is set to
     * {@code true} or if the {@code TabPane} is disabled.
     * @return true if the TabPane is disabled
     * @since JavaFX 2.2
     */
    public final boolean isDisabled() {
        return disabled == null ? false : disabled.get();
    }

    /**
     * Indicates whether or not this {@code Tab} is disabled.  A {@code Tab}
     * will become disabled if {@link #disableProperty disable} is set to {@code true} on either
     * itself or if the {@code TabPane} is disabled.
     *
     * @return the disabled property
     * @defaultValue false
     * @since JavaFX 2.2
     */
    public final ReadOnlyBooleanProperty disabledProperty() {
        return disabledPropertyImpl().getReadOnlyProperty();
    }

    private ReadOnlyBooleanWrapper disabledPropertyImpl() {
        if (disabled == null) {
            disabled = new ReadOnlyBooleanWrapper() {
                @Override
                public Object getBean() {
                    return Tab.this;
                }

                @Override
                public String getName() {
                    return &quot;disabled&quot;;
<A NAME="2"></A>                }
            };
        }
        <FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#2',2,'match49-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return disabled;
    }

    private void updateDisabled() {
        boolean disabled = isDisable() || (getTabPane() != null &amp;&amp; getTabPane().isDisabled());
        setDisabled</B></FONT>(disabled);

        // Fix for RT-24658 - content should be disabled if the tab is disabled
        Node content = getContent();
        if (content != null) {
            content.setDisable(disabled);
        }
    }

     /**
     * Called when there is an external request to close this {@code Tab}.
     * The installed event handler can prevent tab closing by consuming the
     * received event.
     * @since JavaFX 8.0
     */
    public static final EventType&lt;Event&gt; TAB_CLOSE_REQUEST_EVENT = new EventType&lt;Event&gt; (Event.ANY, &quot;TAB_CLOSE_REQUEST_EVENT&quot;);

    /**
     * Called when there is an external request to close this {@code Tab}.
     * The installed event handler can prevent tab closing by consuming the
     * received event.
     * @since JavaFX 8.0
     */
    private ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onCloseRequest;
    public final ObjectProperty&lt;EventHandler&lt;Event&gt;&gt; onCloseRequestProperty() {
        if (onCloseRequest == null) {
            onCloseRequest = new ObjectPropertyBase&lt;EventHandler&lt;Event&gt;&gt;() {
                @Override protected void invalidated() {
                    setEventHandler(TAB_CLOSE_REQUEST_EVENT, get());
                }

                @Override public Object getBean() {
                    return Tab.this;
                }

                @Override public String getName() {
                    return &quot;onCloseRequest&quot;;
                }
            };
        }
        return onCloseRequest;
    }

    public EventHandler&lt;Event&gt; getOnCloseRequest() {
        if( onCloseRequest == null ) {
            return null;
        }
        return onCloseRequest.get();
    }

    public void setOnCloseRequest(EventHandler&lt;Event&gt; value) {
        onCloseRequestProperty().set(value);
    }


    // --- Properties
    private static final Object USER_DATA_KEY = new Object();

    // A map containing a set of properties for this Tab
    private ObservableMap&lt;Object, Object&gt; properties;

    /**
      * Returns an observable map of properties on this Tab for use primarily
      * by application developers.
      *
      * @return an observable map of properties on this Tab for use primarily
      * by application developers
     * @since JavaFX 2.2
     */
     public final ObservableMap&lt;Object, Object&gt; getProperties() {
        if (properties == null) {
            properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
        }
        return properties;
    }

    /**
     * Tests if this Tab has properties.
     * @return true if this tab has properties.
     * @since JavaFX 2.2
     */
     public boolean hasProperties() {
        return properties != null &amp;&amp; !properties.isEmpty();
    }


    // --- UserData
    /**
     * Convenience method for setting a single Object property that can be
     * retrieved at a later date. This is functionally equivalent to calling
     * the getProperties().put(Object key, Object value) method. This can later
     * be retrieved by calling {@link Tab#getUserData()}.
     *
     * @param value The value to be stored - this can later be retrieved by calling
     *          {@link Tab#getUserData()}.
     * @since JavaFX 2.2
     */
    public void setUserData(Object value) {
        getProperties().put(USER_DATA_KEY, value);
    }

    /**
     * Returns a previously set Object property, or null if no such property
     * has been set using the {@link Tab#setUserData(java.lang.Object)} method.
     *
     * @return The Object that was previously set, or null if no property
     *          has been set or if null was set.
     * @since JavaFX 2.2
     */
    public Object getUserData() {
        return getProperties().get(USER_DATA_KEY);
    }

    /**
     * A list of String identifiers which can be used to logically group
     * Nodes, specifically for an external style engine. This variable is
     * analogous to the &quot;class&quot; attribute on an HTML element and, as such,
     * each element of the list is a style class to which this Node belongs.
     *
     * @see &lt;a href=&quot;http://www.w3.org/TR/css3-selectors/#class-html&quot;&gt;CSS3 class selectors&lt;/a&gt;
     */
    @Override
    public ObservableList&lt;String&gt; getStyleClass() {
        return styleClass;
    }

    private final EventHandlerManager eventHandlerManager =
            new EventHandlerManager(this);

     /** {@inheritDoc} */
    @Override
    public EventDispatchChain buildEventDispatchChain(EventDispatchChain tail) {
        return tail.prepend(eventHandlerManager);
    }

    &lt;E extends Event&gt; void setEventHandler(EventType&lt;E&gt; eventType, EventHandler&lt;E&gt; eventHandler) {
        eventHandlerManager.setEventHandler(eventType, eventHandler);
    }

    /*
     * See Node#lookup(String)
     */
    Node lookup(String selector) {
        if (selector == null) return null;
        Node n = null;
        if (getContent() != null) {
            n = getContent().lookup(selector);
        }
        if (n == null &amp;&amp; getGraphic() != null) {
            n = getGraphic().lookup(selector);
        }
        return n;
    }

    /*
     * See Node#lookupAll(String)
     */
    List&lt;Node&gt; lookupAll(String selector) {
        final List&lt;Node&gt; results = new ArrayList&lt;&gt;();
        if (getContent() != null) {
            Set set = getContent().lookupAll(selector);
            if (!set.isEmpty()) {
                results.addAll(set);
            }
        }
        if (getGraphic() != null) {
            Set set = getGraphic().lookupAll(selector);
            if (!set.isEmpty()) {
                results.addAll(set);
            }
        }
        return results;
    }


    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;tab&quot;;

    /**
     * {@inheritDoc}
     * @return &quot;Tab&quot;
     * @since JavaFX 8.0
     */
   @Override
    public String getTypeSelector() {
        return &quot;Tab&quot;;
    }

    /**
     * {@inheritDoc}
     * @return {@code getTabPane()}
     * @since JavaFX 8.0
     */
    @Override
    public Styleable getStyleableParent() {
        return getTabPane();
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    public final ObservableSet&lt;PseudoClass&gt; getPseudoClassStates() {
        return FXCollections.emptyObservableSet();
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return Collections.emptyList();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/TreeTableRow.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control;

import javafx.css.PseudoClass;
import javafx.scene.control.skin.TreeTableRowSkin;
import java.lang.ref.WeakReference;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.WeakInvalidationListener;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyObjectWrapper;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.ListChangeListener;
import javafx.collections.WeakListChangeListener;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.control.TreeTableView.TreeTableViewFocusModel;
import javafx.scene.control.TreeTableView.TreeTableViewSelectionModel;

/**
 * &lt;p&gt;TreeTableRow is an {@link javafx.scene.control.IndexedCell IndexedCell}, but
 * rarely needs to be used by developers creating TreeTableView instances. The only
 * time TreeTableRow is likely to be encountered at all by a developer is if they
 * wish to create a custom {@link TreeTableView#rowFactoryProperty() rowFactory}
 * that replaces an entire row of a TreeTableView.&lt;/p&gt;
 *
 * &lt;p&gt;More often than not, it is actually easier for a developer to customize
 * individual cells in a row, rather than the whole row itself. To do this,
 * you can specify a custom {@link TreeTableColumn#cellFactoryProperty() cellFactory}
 * on each TreeTableColumn instance.&lt;/p&gt;
 *
 * @see TreeTableView
 * @see TreeTableColumn
 * @see TreeTableCell
 * @see IndexedCell
 * @see Cell
 * @param &lt;T&gt; The type of the item contained within the Cell.
 * @since JavaFX 8.0
 */
public class TreeTableRow&lt;T&gt; extends IndexedCell&lt;T&gt; {


    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a default TreeTableRow instance.
     */
    public TreeTableRow() {
        getStyleClass().addAll(DEFAULT_STYLE_CLASS);
        setAccessibleRole(AccessibleRole.TREE_TABLE_ROW);
    }



    /***************************************************************************
     *                                                                         *
     * Callbacks and events                                                    *
     *                                                                         *
     **************************************************************************/

    private final ListChangeListener&lt;Integer&gt; selectedListener = c -&gt; {
        updateSelection();
    };

    private final InvalidationListener focusedListener = valueModel -&gt; {
        updateFocus();
    };

    private final InvalidationListener editingListener = valueModel -&gt; {
        updateEditing();
    };

    private final InvalidationListener leafListener = new InvalidationListener() {
        @Override public void invalidated(Observable valueModel) {
            // necessary to update the disclosure node in the skin when the
            // leaf property changes
            TreeItem&lt;T&gt; treeItem = getTreeItem();
            if (treeItem != null) {
                requestLayout();
            }
        }
    };

    private boolean oldExpanded;
    private final InvalidationListener treeItemExpandedInvalidationListener = o -&gt; {
        final boolean expanded = ((BooleanProperty)o).get();
        pseudoClassStateChanged(EXPANDED_PSEUDOCLASS_STATE,   expanded);
        pseudoClassStateChanged(COLLAPSED_PSEUDOCLASS_STATE, !expanded);
        if (expanded != oldExpanded) {
            notifyAccessibleAttributeChanged(AccessibleAttribute.EXPANDED);
        }
        oldExpanded = expanded;
    };

    private final WeakListChangeListener&lt;Integer&gt; weakSelectedListener =
            new WeakListChangeListener&lt;Integer&gt;(selectedListener);
    private final WeakInvalidationListener weakFocusedListener =
            new WeakInvalidationListener(focusedListener);
    private final WeakInvalidationListener weakEditingListener =
            new WeakInvalidationListener(editingListener);
    private final WeakInvalidationListener weakLeafListener =
            new WeakInvalidationListener(leafListener);
    private final WeakInvalidationListener weakTreeItemExpandedInvalidationListener =
            new WeakInvalidationListener(treeItemExpandedInvalidationListener);



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    // --- TreeItem
    private ReadOnlyObjectWrapper&lt;TreeItem&lt;T&gt;&gt; treeItem =
        new ReadOnlyObjectWrapper&lt;TreeItem&lt;T&gt;&gt;(this, &quot;treeItem&quot;) {

            TreeItem&lt;T&gt; oldValue = null;

            @Override protected void invalidated() {
                if (oldValue != null) {
                    oldValue.expandedProperty().removeListener(weakTreeItemExpandedInvalidationListener);
                }

                oldValue = get();

                if (oldValue != null) {
                    oldExpanded = oldValue.isExpanded();
                    oldValue.expandedProperty().addListener(weakTreeItemExpandedInvalidationListener);
                    // fake an invalidation to ensure updated pseudo-class state
                    weakTreeItemExpandedInvalidationListener.invalidated(oldValue.expandedProperty());
                }
            }
    };
    private void setTreeItem(TreeItem&lt;T&gt; value) {
        treeItem.set(value);
    }

    /**
     * Returns the TreeItem currently set in this TreeTableRow.
     * @return the TreeItem currently set in this TreeTableRow
     */
    public final TreeItem&lt;T&gt; getTreeItem() { return treeItem.get(); }

    /**
     * Each TreeTableCell represents at most a single {@link TreeItem}, which is
     * represented by this property.
     * @return the tree item property
     */
    public final ReadOnlyObjectProperty&lt;TreeItem&lt;T&gt;&gt; treeItemProperty() { return treeItem.getReadOnlyProperty(); }



    // --- Disclosure Node
    private ObjectProperty&lt;Node&gt; disclosureNode = new SimpleObjectProperty&lt;Node&gt;(this, &quot;disclosureNode&quot;);

    /**
     * The node to use as the &quot;disclosure&quot; triangle, or toggle, used for
     * expanding and collapsing items. This is only used in the case of
     * an item in the tree which contains child items. If not specified, the
     * TreeTableCell's Skin implementation is responsible for providing a default
     * disclosure node.
     * @param value the disclosure node
     */
    public final void setDisclosureNode(Node value) { disclosureNodeProperty().set(value); }

    /**
     * Returns the current disclosure node set in this TreeTableCell.
     * @return the disclosure node
     */
    public final Node getDisclosureNode() { return disclosureNode.get(); }

    /**
     * The disclosure node is commonly seen represented as a triangle that rotates
     * on screen to indicate whether or not the TreeItem that it is placed
     * beside is expanded or collapsed.
     * @return the disclosure node property
     */
    public final ObjectProperty&lt;Node&gt; disclosureNodeProperty() { return disclosureNode; }


    // --- TreeView
    private ReadOnlyObjectWrapper&lt;TreeTableView&lt;T&gt;&gt; treeTableView = new ReadOnlyObjectWrapper&lt;TreeTableView&lt;T&gt;&gt;(this, &quot;treeTableView&quot;) {
        private WeakReference&lt;TreeTableView&lt;T&gt;&gt; weakTreeTableViewRef;
        @Override protected void invalidated() {
            TreeTableViewSelectionModel&lt;T&gt; sm;
            TreeTableViewFocusModel&lt;T&gt; fm;

            if (weakTreeTableViewRef != null) {
                TreeTableView&lt;T&gt; oldTreeTableView = weakTreeTableViewRef.get();
                if (oldTreeTableView != null) {
                    // remove old listeners
                    sm = oldTreeTableView.getSelectionModel();
                    if (sm != null) {
                        sm.getSelectedIndices().removeListener(weakSelectedListener);
                    }

                    fm = oldTreeTableView.getFocusModel();
                    if (fm != null) {
                        fm.focusedIndexProperty().removeListener(weakFocusedListener);
                    }

                    oldTreeTableView.editingCellProperty().removeListener(weakEditingListener);
                }

                weakTreeTableViewRef = null;
            }

            if (get() != null) {
                sm = get().getSelectionModel();
                if (sm != null) {
                    // listening for changes to treeView.selectedIndex and IndexedCell.index,
                    // to determine if this cell is selected
<A NAME="26"></A>                    sm.getSelectedIndices().addListener(weakSelectedListener);
                }

                fm = <FONT color="#95b9c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#26',2,'match49-top.html#26',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>get().getFocusModel();
                if (fm != null) {
                    // similar to above, but this time for focus
                    fm.focusedIndexProperty().addListener(weakFocusedListener);
                }

                get().editingCellProperty().addListener(weakEditingListener);

                weakTreeTableViewRef = new WeakReference&lt;TreeTableView&lt;T&gt;&gt;(get</B></FONT>());
            }

            updateItem();
            requestLayout();
        }
    };

    private void setTreeTableView(TreeTableView&lt;T&gt; value) { treeTableView.set(value); }

    /**
     * Returns the TreeTableView associated with this TreeTableCell.
     * @return the tree table view
     */
    public final TreeTableView&lt;T&gt; getTreeTableView() { return treeTableView.get(); }

    /**
     * A TreeTableCell is explicitly linked to a single {@link TreeTableView} instance,
     * which is represented by this property.
     * @return the tree table view property
     */
    public final ReadOnlyObjectProperty&lt;TreeTableView&lt;T&gt;&gt; treeTableViewProperty() { return treeTableView.getReadOnlyProperty(); }




    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     *************************************************************************
     * @param oldIndex
     * @param newIndex*/


    @Override void indexChanged(int oldIndex, int newIndex) {
        index = getIndex();

        // when the cell index changes, this may result in the cell
        // changing state to be selected and/or focused.
        updateItem();
        updateSelection();
        updateFocus();
//        oldIndex = index;
    }


    /** {@inheritDoc} */
    @Override public void startEdit() {
        final TreeTableView&lt;T&gt; treeTable = getTreeTableView();
        if (! isEditable() || (treeTable != null &amp;&amp; ! treeTable.isEditable())) {
            return;
        }

        // it makes sense to get the cell into its editing state before firing
        // the event to the TreeView below, so that's what we're doing here
        // by calling super.startEdit().
        super.startEdit();

         // Inform the TreeView of the edit starting.
        if (treeTable != null) {
            treeTable.fireEvent(new TreeTableView.EditEvent&lt;T&gt;(treeTable,
                    TreeTableView.&lt;T&gt;editStartEvent(),
                    getTreeItem(),
                    getItem(),
                    null));

            treeTable.requestFocus();
        }
    }

     /** {@inheritDoc} */
    @Override public void commitEdit(T newValue) {
        if (! isEditing()) return;
        final TreeItem&lt;T&gt; treeItem = getTreeItem();
        final TreeTableView&lt;T&gt; treeTable = getTreeTableView();
        if (treeTable != null) {
            // Inform the TreeView of the edit being ready to be committed.
            treeTable.fireEvent(new TreeTableView.EditEvent&lt;T&gt;(treeTable,
                    TreeTableView.&lt;T&gt;editCommitEvent(),
                    treeItem,
                    getItem(),
                    newValue));
        }

        // update the item within this cell, so that it represents the new value
        if (treeItem != null) {
            treeItem.setValue(newValue);
            updateTreeItem(treeItem);
            updateItem(newValue, false);
        }

        // inform parent classes of the commit, so that they can switch us
        // out of the editing state
        super.commitEdit(newValue);

        if (treeTable != null) {
            // reset the editing item in the TreetView
            treeTable.edit(-1, null);
            treeTable.requestFocus();
        }
    }

    /** {@inheritDoc} */
    @Override public void cancelEdit() {
        if (! isEditing()) return;

        TreeTableView&lt;T&gt; treeTable = getTreeTableView();
        if (treeTable != null) {
            treeTable.fireEvent(new TreeTableView.EditEvent&lt;T&gt;(treeTable,
                    TreeTableView.&lt;T&gt;editCancelEvent(),
                    getTreeItem(),
                    getItem(),
                    null));
        }

        super.cancelEdit();

        if (treeTable != null) {
            // reset the editing index on the TreeView
            treeTable.edit(-1, null);
            treeTable.requestFocus();
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private int index = -1;
    private boolean isFirstRun = true;

    private void updateItem() {
        TreeTableView&lt;T&gt; tv = getTreeTableView();
        if (tv == null) return;

        // Compute whether the index for this cell is for a real item
        boolean valid = index &gt;=0 &amp;&amp; index &lt; tv.getExpandedItemCount();

        final TreeItem&lt;T&gt; oldTreeItem = getTreeItem();
        final boolean isEmpty = isEmpty();

        // Cause the cell to update itself
        if (valid) {
            // update the TreeCell state.
            // get the new treeItem that is about to go in to the TreeCell
            final TreeItem&lt;T&gt; newTreeItem = tv.getTreeItem(index);
            final T newValue = newTreeItem == null ? null : newTreeItem.getValue();

            // For the sake of RT-14279, it is important that the order of these
            // method calls is as shown below. If the order is switched, it is
            // likely that events will be fired where the item is null, even
            // though calling cell.getTreeItem().getValue() returns the value
            // as expected

            // There used to be conditional code here to prevent updateItem from
            // being called when the value didn't change, but that led us to
            // issues such as RT-33108, where the value didn't change but the item
            // we needed to be listening to did. Without calling updateItem we
            // were breaking things, so once again the conditionals are gone.
            updateTreeItem(newTreeItem);
            updateItem(newValue, false);
        } else {
            // RT-30484 We need to allow a first run to be special-cased to allow
            // for the updateItem method to be called at least once to allow for
            // the correct visual state to be set up. In particular, in RT-30484
            // refer to Ensemble8PopUpTree.png - in this case the arrows are being
            // shown as the new cells are instantiated with the arrows in the
            // children list, and are only hidden in updateItem.
            if ((!isEmpty &amp;&amp; oldTreeItem != null) || isFirstRun) {
                updateTreeItem(null);
                updateItem(null, true);
                isFirstRun = false;
            }
        }
    }

    private void updateSelection() {
        if (isEmpty()) return;
        if (index == -1 || getTreeTableView() == null) return;
        if (getTreeTableView().getSelectionModel() == null) return;

        boolean isSelected = getTreeTableView().getSelectionModel().isSelected(index);
        if (isSelected() == isSelected) return;

        updateSelected(isSelected);
    }

    private void updateFocus() {
        if (getIndex() == -1 || getTreeTableView() == null) return;
        if (getTreeTableView().getFocusModel() == null) return;

        setFocused(getTreeTableView().getFocusModel().isFocused(getIndex()));
    }

    private void updateEditing() {
        if (getIndex() == -1 || getTreeTableView() == null || getTreeItem() == null) return;

        final TreeTablePosition&lt;T,?&gt; editingCell = getTreeTableView().getEditingCell();
        if (editingCell != null &amp;&amp; editingCell.getTableColumn() != null) {
            return;
        }

        final TreeItem&lt;T&gt; editItem = editingCell == null ? null : editingCell.getTreeItem();
        if (! isEditing() &amp;&amp; getTreeItem().equals(editItem)) {
            startEdit();
        } else if (isEditing() &amp;&amp; ! getTreeItem().equals(editItem)) {
            cancelEdit();
        }
    }



    /***************************************************************************
     *                                                                         *
     * Expert API                                                              *
     *                                                                         *
     **************************************************************************/

    /**
     * Updates the TreeTableView associated with this TreeTableCell.
     *
     * @param treeTable The new TreeTableView that should be associated with this
     *         TreeTableCell.
     * Note: This function is intended to be used by experts, primarily
     *         by those implementing new Skins. It is not common
     *         for developers or designers to access this function directly.
     */
    public final void updateTreeTableView(TreeTableView&lt;T&gt; treeTable) {
        setTreeTableView(treeTable);
    }

    /**
     * Updates the TreeItem associated with this TreeTableCell.
     *
     * @param treeItem The new TreeItem that should be associated with this
     *      TreeTableCell.
     * Note: This function is intended to be used by experts, primarily
     *       by those implementing new Skins. It is not common
     *       for developers or designers to access this function directly.
     */
    public final void updateTreeItem(TreeItem&lt;T&gt; treeItem) {
        TreeItem&lt;T&gt; _treeItem = getTreeItem();
        if (_treeItem != null) {
            _treeItem.leafProperty().removeListener(weakLeafListener);
        }
        setTreeItem(treeItem);
        if (treeItem != null) {
            treeItem.leafProperty().addListener(weakLeafListener);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Stylesheet Handling                                                     *
     *                                                                         *
     **************************************************************************/

    private static final String DEFAULT_STYLE_CLASS = &quot;tree-table-row-cell&quot;;

    private static final PseudoClass EXPANDED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;expanded&quot;);
    private static final PseudoClass COLLAPSED_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;collapsed&quot;);

    /** {@inheritDoc} */
    @Override protected Skin&lt;?&gt; createDefaultSkin() {
        return new TreeTableRowSkin&lt;T&gt;(this);
    }


    /***************************************************************************
     *                                                                         *
     * Accessibility handling                                                  *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override
    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        final TreeItem&lt;T&gt; treeItem = getTreeItem();
        final TreeTableView&lt;T&gt; treeTableView = getTreeTableView();

        switch (attribute) {
            case TREE_ITEM_PARENT: {
                if (treeItem == null) return null;
                TreeItem&lt;T&gt; parent = treeItem.getParent();
                if (parent == null) return null;
                int parentIndex = treeTableView.getRow(parent);
                return treeTableView.queryAccessibleAttribute(AccessibleAttribute.ROW_AT_INDEX, parentIndex);
            }
            case TREE_ITEM_COUNT: {
                if (treeItem == null) return 0;
                if (!treeItem.isExpanded()) return 0;
                return treeItem.getChildren().size();
            }
            case TREE_ITEM_AT_INDEX: {
                if (treeItem == null) return null;
                if (!treeItem.isExpanded()) return null;
                int index = (Integer)parameters[0];
                if (index &gt;= treeItem.getChildren().size()) return null;
                TreeItem&lt;T&gt; child = treeItem.getChildren().get(index);
                if (child == null) return null;
                int childIndex = treeTableView.getRow(child);
                return treeTableView.queryAccessibleAttribute(AccessibleAttribute.ROW_AT_INDEX, childIndex);
            }
            case LEAF: return treeItem == null ? true : treeItem.isLeaf();
            case EXPANDED: return treeItem == null ? false : treeItem.isExpanded();
            case INDEX: return getIndex();
            case DISCLOSURE_LEVEL: {
                return treeTableView == null ? 0 : treeTableView.getTreeItemLevel(treeItem);
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override
    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case EXPAND: {
                TreeItem&lt;T&gt; treeItem = getTreeItem();
                if (treeItem != null) treeItem.setExpanded(true);
                break;
            }
            case COLLAPSE: {
                TreeItem&lt;T&gt; treeItem = getTreeItem();
                if (treeItem != null) treeItem.setExpanded(false);
                break;
            }
            default: super.executeAccessibleAction(action);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/PaginationSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.skin.Utils;
import javafx.beans.property.DoubleProperty;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableObjectProperty;
import javafx.css.CssMetaData;

import javafx.css.converter.BooleanConverter;
import javafx.css.converter.EnumConverter;
import javafx.css.converter.SizeConverter;
import com.sun.javafx.scene.control.behavior.PaginationBehavior;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javafx.animation.*;
import javafx.application.Platform;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.WritableValue;
import javafx.collections.ListChangeListener;
import javafx.css.Styleable;
import javafx.css.StyleableProperty;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.geometry.VPos;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.TouchEvent;
import javafx.scene.layout.HBox;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;

import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;

/**
 * Default skin implementation for the {@link Pagination} control.
 *
 * @see Pagination
 * @since 9
 */
public class PaginationSkin extends SkinBase&lt;Pagination&gt; {

    /***************************************************************************
     *                                                                         *
     * Static fields                                                           *
     *                                                                         *
     **************************************************************************/

    private static final Duration DURATION = new Duration(125.0);
    private static final double SWIPE_THRESHOLD = 0.30;
    private static final double TOUCH_THRESHOLD = 15;
    private static final Interpolator interpolator = Interpolator.SPLINE(0.4829, 0.5709, 0.6803, 0.9928);



    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private Pagination pagination;
    private StackPane currentStackPane;
    private StackPane nextStackPane;
    private Timeline timeline;
    private Rectangle clipRect;

    private NavigationControl navigation;
    private int fromIndex;
    private int previousIndex;
    private int currentIndex;
    private int toIndex;
    private int pageCount;
    private int maxPageIndicatorCount;

    private double startTouchPos;
    private double lastTouchPos;
    private long startTouchTime;
    private long lastTouchTime;
    private double touchVelocity;
    private boolean touchThresholdBroken;
    private int touchEventId = -1;
    private boolean nextPageReached = false;
    private boolean setInitialDirection = false;
    private int direction;

    private int currentAnimatedIndex;
    private boolean hasPendingAnimation = false;

    private boolean animate = true;

    private final PaginationBehavior behavior;



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private EventHandler&lt;ActionEvent&gt; swipeAnimationEndEventHandler = new EventHandler&lt;ActionEvent&gt;() {
        @Override public void handle(ActionEvent t) {
            swapPanes();
            timeline = null;

            if (hasPendingAnimation) {
                animateSwitchPage();
                hasPendingAnimation = false;
            }
        }
    };

    private EventHandler&lt;ActionEvent&gt; clampAnimationEndEventHandler = new EventHandler&lt;ActionEvent&gt;() {
        @Override public void handle(ActionEvent t) {
            currentStackPane.setTranslateX(0);
            nextStackPane.setTranslateX(0);
            nextStackPane.setVisible(false);
            timeline = null;
        }
    };



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new PaginationSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public PaginationSkin(final Pagination control) {
        super(control);

        // install default input map for the Pagination control
        behavior = new PaginationBehavior(control);
//        control.setInputMap(behavior.getInputMap());

//        setManaged(false);
        clipRect = new Rectangle();
        getSkinnable().setClip(clipRect);

        this.pagination = control;

        this.currentStackPane = new StackPane();
        currentStackPane.getStyleClass().add(&quot;page&quot;);

        this.nextStackPane = new StackPane();
        nextStackPane.getStyleClass().add(&quot;page&quot;);
        nextStackPane.setVisible(false);

        resetIndexes(true);

        this.navigation = new NavigationControl();

        getChildren().addAll(currentStackPane, nextStackPane, navigation);

        control.maxPageIndicatorCountProperty().addListener(o -&gt; {
            resetIndiciesAndNav();
        });

        registerChangeListener(control.widthProperty(), e -&gt; clipRect.setWidth(getSkinnable().getWidth()));
        registerChangeListener(control.heightProperty(), e -&gt; clipRect.setHeight(getSkinnable().getHeight()));
        registerChangeListener(control.pageCountProperty(), e -&gt; resetIndiciesAndNav());
        registerChangeListener(control.pageFactoryProperty(), e -&gt; {
            if (animate &amp;&amp; timeline != null) {
                // If we are in the middle of a page animation.
                // Speedup and finish the animation then update the page factory.
                timeline.setRate(8);
                timeline.setOnFinished(arg0 -&gt; {
                    resetIndiciesAndNav();
                });
                return;
            }
            resetIndiciesAndNav();
        });

        initializeSwipeAndTouchHandlers();
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    /** The size of the gap between number buttons and arrow buttons */
    private final DoubleProperty arrowButtonGap = new StyleableDoubleProperty(60.0) {
        @Override public Object getBean() {
            return PaginationSkin.this;
        }
        @Override public String getName() {
            return &quot;arrowButtonGap&quot;;
        }
        @Override public CssMetaData&lt;Pagination,Number&gt; getCssMetaData() {
            return StyleableProperties.ARROW_BUTTON_GAP;
        }
    };
    private final DoubleProperty arrowButtonGapProperty() {
        return arrowButtonGap;
    }
    private final double getArrowButtonGap() {
        return arrowButtonGap.get();
    }
    private final void setArrowButtonGap(double value) {
        arrowButtonGap.set(value);
    }

    private BooleanProperty arrowsVisible;
    private final void setArrowsVisible(boolean value) { arrowsVisibleProperty().set(value); }
    private final boolean isArrowsVisible() { return arrowsVisible == null ? DEFAULT_ARROW_VISIBLE : arrowsVisible.get(); }
    private final BooleanProperty arrowsVisibleProperty() {
        if (arrowsVisible == null) {
            arrowsVisible = new StyleableBooleanProperty(DEFAULT_ARROW_VISIBLE) {
                @Override
                protected void invalidated() {
                    getSkinnable().requestLayout();
                }

                @Override
                public CssMetaData&lt;Pagination,Boolean&gt; getCssMetaData() {
                    return StyleableProperties.ARROWS_VISIBLE;
                }

                @Override
                public Object getBean() {
                    return PaginationSkin.this;
                }

                @Override
                public String getName() {
                    return &quot;arrowVisible&quot;;
                }
            };
        }
        return arrowsVisible;
    }

    private BooleanProperty pageInformationVisible;
    private final void setPageInformationVisible(boolean value) { pageInformationVisibleProperty().set(value); }
    private final boolean isPageInformationVisible() { return pageInformationVisible == null ? DEFAULT_PAGE_INFORMATION_VISIBLE : pageInformationVisible.get(); }
    private final BooleanProperty pageInformationVisibleProperty() {
        if (pageInformationVisible == null) {
            pageInformationVisible = new StyleableBooleanProperty(DEFAULT_PAGE_INFORMATION_VISIBLE) {
                @Override
                protected void invalidated() {
                    getSkinnable().requestLayout();
                }

                @Override
                public CssMetaData&lt;Pagination,Boolean&gt; getCssMetaData() {
                    return StyleableProperties.PAGE_INFORMATION_VISIBLE;
                }

                @Override
                public Object getBean() {
                    return PaginationSkin.this;
                }

                @Override
                public String getName() {
                    return &quot;pageInformationVisible&quot;;
                }
            };
        }
        return pageInformationVisible;
    }

    private ObjectProperty&lt;Side&gt; pageInformationAlignment;
    private final void setPageInformationAlignment(Side value) { pageInformationAlignmentProperty().set(value); }
    private final Side getPageInformationAlignment() { return pageInformationAlignment == null ? DEFAULT_PAGE_INFORMATION_ALIGNMENT : pageInformationAlignment.get(); }
    private final ObjectProperty&lt;Side&gt; pageInformationAlignmentProperty() {
        if (pageInformationAlignment == null) {
            pageInformationAlignment = new StyleableObjectProperty&lt;Side&gt;(Side.BOTTOM) {
                @Override
                protected void invalidated() {
                    getSkinnable().requestLayout();
                }

                @Override
                public CssMetaData&lt;Pagination,Side&gt; getCssMetaData() {
                    return StyleableProperties.PAGE_INFORMATION_ALIGNMENT;
                }

                @Override
                public Object getBean() {
                    return PaginationSkin.this;
                }

                @Override
                public String getName() {
                    return &quot;pageInformationAlignment&quot;;
                }
            };
        }
        return pageInformationAlignment;
    }

    private BooleanProperty tooltipVisible;
    private final void setTooltipVisible(boolean value) { tooltipVisibleProperty().set(value); }
    private final boolean isTooltipVisible() { return tooltipVisible == null ? DEFAULT_TOOLTIP_VISIBLE : tooltipVisible.get(); }
    private final BooleanProperty tooltipVisibleProperty() {
        if (tooltipVisible == null) {
            tooltipVisible = new StyleableBooleanProperty(DEFAULT_TOOLTIP_VISIBLE) {
                @Override
                protected void invalidated() {
                    getSkinnable().requestLayout();
                }

                @Override
                public CssMetaData&lt;Pagination,Boolean&gt; getCssMetaData() {
                    return StyleableProperties.TOOLTIP_VISIBLE;
                }

                @Override
                public Object getBean() {
                    return PaginationSkin.this;
                }

                @Override
                public String getName() {
                    return &quot;tooltipVisible&quot;;
                }
            };
        }
        return tooltipVisible;
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        double navigationWidth = navigation.isVisible() ? snapSizeX(navigation.minWidth(height)) : 0;
        return leftInset + Math.max(currentStackPane.minWidth(height), navigationWidth) + rightInset;
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        double navigationHeight = navigation.isVisible() ? snapSizeY(navigation.minHeight(width)) : 0;
        return topInset + currentStackPane.minHeight(width) + navigationHeight + bottomInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        double navigationWidth = navigation.isVisible() ? snapSizeX(navigation.prefWidth(height)) : 0;
        return leftInset + Math.max(currentStackPane.prefWidth(height), navigationWidth) + rightInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        double navigationHeight = navigation.isVisible() ? snapSizeY(navigation.prefHeight(width)) : 0;
        return topInset + currentStackPane.prefHeight(width) + navigationHeight + bottomInset;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        double navigationHeight = navigation.isVisible() ? snapSizeY(navigation.prefHeight(-1)) : 0;
        double stackPaneHeight = snapSizeY(h - navigationHeight);

        layoutInArea(currentStackPane, x, y, w, stackPaneHeight, 0, HPos.CENTER, VPos.CENTER);
        layoutInArea(nextStackPane, x, y, w, stackPaneHeight, 0, HPos.CENTER, VPos.CENTER);
        layoutInArea(navigation, x, stackPaneHeight, w, navigationHeight, 0, HPos.CENTER, VPos.CENTER);
    }

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case FOCUS_ITEM: return navigation.indicatorButtons.getSelectedToggle();
            case ITEM_COUNT: return navigation.indicatorButtons.getToggles().size();
            case ITEM_AT_INDEX: {
                Integer index = (Integer)parameters[0];
                if (index == null) return null;
                return navigation.indicatorButtons.getToggles().get(index);
            }
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private void selectNext() {
        if (getCurrentPageIndex() &lt; getPageCount() - 1) {
            pagination.setCurrentPageIndex(getCurrentPageIndex() + 1);
        }
    }

    private void selectPrevious() {
        if (getCurrentPageIndex() &gt; 0) {
            pagination.setCurrentPageIndex(getCurrentPageIndex() - 1);
        }
    }

    private void resetIndiciesAndNav() {
        resetIndexes(false);
        navigation.initializePageIndicators();
        navigation.updatePageIndicators();
    }

    private void initializeSwipeAndTouchHandlers() {
        final Pagination control = getSkinnable();

        getSkinnable().addEventHandler(TouchEvent.TOUCH_PRESSED, e -&gt; {
            if (touchEventId == -1) {
                touchEventId = e.getTouchPoint().getId();
            }
            if (touchEventId != e.getTouchPoint().getId()) {
                return;
            }
            lastTouchPos = startTouchPos = e.getTouchPoint().getX();
            lastTouchTime = startTouchTime = System.currentTimeMillis();
            touchThresholdBroken = false;
            e.consume();
        });

        getSkinnable().addEventHandler(TouchEvent.TOUCH_MOVED, e -&gt; {
            if (touchEventId != e.getTouchPoint().getId()) {
                return;
            }

            double drag = e.getTouchPoint().getX() - lastTouchPos;
            long time = System.currentTimeMillis() - lastTouchTime;
            touchVelocity = drag/time;
            lastTouchPos = e.getTouchPoint().getX();
            lastTouchTime = System.currentTimeMillis();
            double delta = e.getTouchPoint().getX() - startTouchPos;

            if (!touchThresholdBroken &amp;&amp; Math.abs(delta) &gt; TOUCH_THRESHOLD) {
                touchThresholdBroken = true;
            }

            if (touchThresholdBroken) {
                double width = control.getWidth() - (snappedLeftInset() + snappedRightInset());
                double currentPaneX;
                double nextPaneX;

                if (!setInitialDirection) {
                    // Remember the direction travelled so we can
                    // load the next or previous page if the touch is not released.
                    setInitialDirection = true;
                    direction = delta &lt; 0 ? 1 : -1;
                }
                if (delta &lt; 0) {
                    if (direction == -1) {
                        nextStackPane.getChildren().clear();
                        direction = 1;
                    }
                    // right to left
                    if (Math.abs(delta) &lt;= width) {
                        currentPaneX = delta;
                        nextPaneX = width + delta;
                        nextPageReached = false;
                    } else {
                        currentPaneX = -width;
                        nextPaneX = 0;
                        nextPageReached = true;
                    }
                    currentStackPane.setTranslateX(currentPaneX);
                    if (getCurrentPageIndex() &lt; getPageCount() - 1) {
                        createPage(nextStackPane, currentIndex + 1);
                        nextStackPane.setVisible(true);
                        nextStackPane.setTranslateX(nextPaneX);
                    } else {
                        currentStackPane.setTranslateX(0);
                    }
                } else {
                    // left to right
                    if (direction == 1) {
                        nextStackPane.getChildren().clear();
                        direction = -1;
                    }
                    if (Math.abs(delta) &lt;= width) {
                        currentPaneX = delta;
                        nextPaneX = -width + delta;
                        nextPageReached = false;
                    } else {
                        currentPaneX = width;
                        nextPaneX = 0;
                        nextPageReached = true;
                    }
                    currentStackPane.setTranslateX(currentPaneX);
                    if (getCurrentPageIndex() != 0) {
                        createPage(nextStackPane, currentIndex - 1);
                        nextStackPane.setVisible(true);
                        nextStackPane.setTranslateX(nextPaneX);
                    } else {
                        currentStackPane.setTranslateX(0);
                    }
                }
            }
            e.consume();
        });

        getSkinnable().addEventHandler(TouchEvent.TOUCH_RELEASED, e -&gt; {
            if (touchEventId != e.getTouchPoint().getId()) {
                return;
            } else {
                touchEventId = -1;
                setInitialDirection = false;
            }

            if (touchThresholdBroken) {
                // determin if click or swipe
                final double drag = e.getTouchPoint().getX() - startTouchPos;
                // calculate complete time from start to end of drag
                final long time = System.currentTimeMillis() - startTouchTime;
                // if time is less than 300ms then considered a quick swipe and whole time is used
                final boolean quick = time &lt; 300;
                // calculate velocity
                final double velocity = quick ? (double)drag / time : touchVelocity; // pixels/ms
                // calculate distance we would travel at this speed for 500ms of travel
                final double distance = (velocity * 500);
                final double width = control.getWidth() - (snappedLeftInset() + snappedRightInset());

                // The swipe distance travelled.
                final double threshold = Math.abs(distance/width);
                // The touch and dragged distance travelled.
                final double delta = Math.abs(drag/width);
                if (threshold &gt; SWIPE_THRESHOLD || delta &gt; SWIPE_THRESHOLD) {
                    if (startTouchPos &gt; e.getTouchPoint().getX()) {
                        selectNext();
                    } else {
                        selectPrevious();
                    }
                } else {
                    animateClamping(startTouchPos &gt; e.getTouchPoint().getSceneX());
                }
            }
            e.consume();
        });
    }

    private void resetIndexes(boolean usePageIndex) {
        maxPageIndicatorCount = getMaxPageIndicatorCount();
        // Used to indicate that we can change a set of pages.
        pageCount = getPageCount();
        if (pageCount &gt; maxPageIndicatorCount) {
            pageCount = maxPageIndicatorCount;
        }

        fromIndex = 0;
        previousIndex = 0;
        currentIndex = usePageIndex ? getCurrentPageIndex() : 0;
        toIndex = pageCount - 1;

        if (pageCount == Pagination.INDETERMINATE &amp;&amp; maxPageIndicatorCount == Pagination.INDETERMINATE) {
            // We do not know how many indicators  can fit.  Let the layout pass compute it.
            toIndex = 0;
        }

        boolean isAnimate = animate;
        if (isAnimate) {
            animate = false;
        }

        // Remove the children in the pane before we create a new page.
        currentStackPane.getChildren().clear();
        nextStackPane.getChildren().clear();

        pagination.setCurrentPageIndex(currentIndex);
        createPage(currentStackPane, currentIndex);

        if (isAnimate) {
            animate = true;
        }
    }

    private boolean createPage(StackPane pane, int index) {
        if (pagination.getPageFactory() != null &amp;&amp; pane.getChildren().isEmpty()) {
            Node content = pagination.getPageFactory().call(index);
            // If the content is null we don't want to switch pages.
            if (content != null) {
                pane.getChildren().setAll(content);
                return true;
            } else {
                // Disable animation if the new page does not exist.  It is strange to
                // see the same page animated out then in.
                boolean isAnimate = animate;
                if (isAnimate) {
                    animate = false;
                }

                if (pagination.getPageFactory().call(previousIndex) != null) {
                    pagination.setCurrentPageIndex(previousIndex);
                } else {
                    // Set the page index to 0 because both the current,
                    // and the previous pages have no content.
                    pagination.setCurrentPageIndex(0);
                }

                if (isAnimate) {
                    animate = true;
                }
                return false;
            }
        }
        return false;
    }

    private int getPageCount() {
        if (getSkinnable().getPageCount() &lt; 1) {
            return 1;
        }
        return getSkinnable().getPageCount();
    }

    private int getMaxPageIndicatorCount() {
        return getSkinnable().getMaxPageIndicatorCount();
    }

    private int getCurrentPageIndex() {
        return getSkinnable().getCurrentPageIndex();
    }

    private void animateSwitchPage() {
        if (timeline != null) {
            timeline.setRate(8);
            hasPendingAnimation = true;
            return;
        }

        // We are handling a touch event if nextPane's page has already been
        // created and visible == true.
        if (!nextStackPane.isVisible()) {
            if (!createPage(nextStackPane, currentAnimatedIndex)) {
                // The next page does not exist just return without starting
                // any animation.
                return;
            }
        }
        if (nextPageReached) {
            // No animation is needed when the next page is already showing
            // and in the correct position.  Just swap the panes and return
            swapPanes();
            nextPageReached = false;
            return;
        }

        nextStackPane.setCache(true);
        currentStackPane.setCache(true);

        // wait one pulse then animate
        Platform.runLater(() -&gt; {
<A NAME="28"></A>            // We are handling a touch event if nextPane's translateX is not 0
            boolean useTranslateX = nextStackPane.getTranslateX() != 0;
            if (currentAnimatedIndex &gt; previousIndex) {  // animate right to left
                <FONT color="#717d7d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#28',2,'match49-top.html#28',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (!useTranslateX) {
                    nextStackPane.setTranslateX(currentStackPane.getWidth());
                }
                nextStackPane.setVisible(true);
                timeline = new</B></FONT> Timeline();
                KeyFrame k1 =  new KeyFrame(Duration.millis(0),
                    new KeyValue(currentStackPane.translateXProperty(),
                        useTranslateX ? currentStackPane.getTranslateX() : 0,
                        interpolator),
                    new KeyValue(nextStackPane.translateXProperty(),
                        useTranslateX ?
                            nextStackPane.getTranslateX() : currentStackPane.getWidth(), interpolator));
                KeyFrame k2 = new KeyFrame(DURATION,
                    swipeAnimationEndEventHandler,
                    new KeyValue(currentStackPane.translateXProperty(), -currentStackPane.getWidth(), interpolator),
                    new KeyValue(nextStackPane.translateXProperty(), 0, interpolator));
                timeline.getKeyFrames().setAll(k1, k2);
                timeline.play();
            } else { // animate left to right
                if (!useTranslateX) {
                    nextStackPane.setTranslateX(-currentStackPane.getWidth());
                }
                nextStackPane.setVisible(true);
                timeline = new Timeline();
                KeyFrame k1 = new KeyFrame(Duration.millis(0),
                    new KeyValue(currentStackPane.translateXProperty(),
                        useTranslateX ? currentStackPane.getTranslateX() : 0,
                        interpolator),
                    new KeyValue(nextStackPane.translateXProperty(),
                        useTranslateX ? nextStackPane.getTranslateX() : -currentStackPane.getWidth(),
                        interpolator));
                KeyFrame k2 = new KeyFrame(DURATION,
                    swipeAnimationEndEventHandler,
                    new KeyValue(currentStackPane.translateXProperty(), currentStackPane.getWidth(), interpolator),
                    new KeyValue(nextStackPane.translateXProperty(), 0, interpolator));
                timeline.getKeyFrames().setAll(k1, k2);
                timeline.play();
            }
        });
    }

    private void swapPanes() {
        StackPane temp = currentStackPane;
        currentStackPane = nextStackPane;
        nextStackPane = temp;

        currentStackPane.setTranslateX(0);
        currentStackPane.setCache(false);

        nextStackPane.setTranslateX(0);
        nextStackPane.setCache(false);
        nextStackPane.setVisible(false);
        nextStackPane.getChildren().clear();
    }

    // If the swipe hasn't reached the THRESHOLD we want to animate the clamping.
    private void animateClamping(boolean rightToLeft) {
        if (rightToLeft) {  // animate right to left
            timeline = new Timeline();
            KeyFrame k1 = new KeyFrame(Duration.millis(0),
                new KeyValue(currentStackPane.translateXProperty(), currentStackPane.getTranslateX(), interpolator),
                new KeyValue(nextStackPane.translateXProperty(), nextStackPane.getTranslateX(), interpolator));
            KeyFrame k2 = new KeyFrame(DURATION,
                clampAnimationEndEventHandler,
                new KeyValue(currentStackPane.translateXProperty(), 0, interpolator),
                new KeyValue(nextStackPane.translateXProperty(), currentStackPane.getWidth(), interpolator));
            timeline.getKeyFrames().setAll(k1, k2);
            timeline.play();
        } else { // animate left to right
            timeline = new Timeline();
            KeyFrame k1 = new KeyFrame(Duration.millis(0),
                new KeyValue(currentStackPane.translateXProperty(), currentStackPane.getTranslateX(), interpolator),
                new KeyValue(nextStackPane.translateXProperty(), nextStackPane.getTranslateX(), interpolator));
            KeyFrame k2 = new KeyFrame(DURATION,
                clampAnimationEndEventHandler,
                new KeyValue(currentStackPane.translateXProperty(), 0, interpolator),
                new KeyValue(nextStackPane.translateXProperty(), -currentStackPane.getWidth(), interpolator));
            timeline.getKeyFrames().setAll(k1, k2);
            timeline.play();
        }
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    class NavigationControl extends StackPane {

        private HBox controlBox;
        private Button leftArrowButton;
        private StackPane leftArrow;
        private Button rightArrowButton;
        private StackPane rightArrow;
        private ToggleGroup indicatorButtons;
        private Label pageInformation;
        private double minButtonSize = -1;

        public NavigationControl() {
            getStyleClass().setAll(&quot;pagination-control&quot;);

            // redirect mouse events to behavior
            addEventHandler(MouseEvent.MOUSE_PRESSED, behavior::mousePressed);

            controlBox = new HBox();
            controlBox.getStyleClass().add(&quot;control-box&quot;);

            leftArrowButton = new Button();
            leftArrowButton.setAccessibleText(getString(&quot;Accessibility.title.Pagination.PreviousButton&quot;));
            minButtonSize = leftArrowButton.getFont().getSize() * 2;
            leftArrowButton.fontProperty().addListener((arg0, arg1, newFont) -&gt; {
                minButtonSize = newFont.getSize() * 2;
                for(Node child: controlBox.getChildren()) {
                    ((Control)child).setMinSize(minButtonSize, minButtonSize);
                }
                // We want to relayout the indicator buttons because the size has changed.
                requestLayout();
            });
            leftArrowButton.setMinSize(minButtonSize, minButtonSize);
            leftArrowButton.prefWidthProperty().bind(leftArrowButton.minWidthProperty());
            leftArrowButton.prefHeightProperty().bind(leftArrowButton.minHeightProperty());
            leftArrowButton.getStyleClass().add(&quot;left-arrow-button&quot;);
            leftArrowButton.setFocusTraversable(false);
            HBox.setMargin(leftArrowButton, new Insets(0, snapSize(arrowButtonGap.get()), 0, 0));
            leftArrow = new StackPane();
            leftArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
            leftArrowButton.setGraphic(leftArrow);
            leftArrow.getStyleClass().add(&quot;left-arrow&quot;);

            rightArrowButton = new Button();
            rightArrowButton.setAccessibleText(getString(&quot;Accessibility.title.Pagination.NextButton&quot;));
            rightArrowButton.setMinSize(minButtonSize, minButtonSize);
            rightArrowButton.prefWidthProperty().bind(rightArrowButton.minWidthProperty());
            rightArrowButton.prefHeightProperty().bind(rightArrowButton.minHeightProperty());
            rightArrowButton.getStyleClass().add(&quot;right-arrow-button&quot;);
            rightArrowButton.setFocusTraversable(false);
            HBox.setMargin(rightArrowButton, new Insets(0, 0, 0, snapSize(arrowButtonGap.get())));
            rightArrow = new StackPane();
            rightArrow.setMaxSize(USE_PREF_SIZE, USE_PREF_SIZE);
            rightArrowButton.setGraphic(rightArrow);
            rightArrow.getStyleClass().add(&quot;right-arrow&quot;);

            indicatorButtons = new ToggleGroup();

            pageInformation = new Label();
            pageInformation.getStyleClass().add(&quot;page-information&quot;);

            getChildren().addAll(controlBox, pageInformation);
            initializeNavigationHandlers();
            initializePageIndicators();
            updatePageIndex();

            // listen to changes to arrowButtonGap and update margins
            arrowButtonGap.addListener((observable, oldValue, newValue) -&gt; {
                if (newValue.doubleValue() == 0) {
                    HBox.setMargin(leftArrowButton, null);
                    HBox.setMargin(rightArrowButton, null);

                } else {
                    HBox.setMargin(leftArrowButton, new Insets(0, snapSize(newValue.doubleValue()), 0, 0));
                    HBox.setMargin(rightArrowButton, new Insets(0, 0, 0, snapSize(newValue.doubleValue())));
                }
            });
        }

        private void initializeNavigationHandlers() {
            leftArrowButton.setOnAction(arg0 -&gt; {
                getNode().requestFocus();
                selectPrevious();
                requestLayout();
            });

            rightArrowButton.setOnAction(arg0 -&gt; {
                getNode().requestFocus();
                selectNext();
                requestLayout();
            });

            pagination.currentPageIndexProperty().addListener((arg0, arg1, arg2) -&gt; {
                previousIndex = arg1.intValue();
                currentIndex = arg2.intValue();
                updatePageIndex();
                if (animate) {
                    currentAnimatedIndex = currentIndex;
                    animateSwitchPage();
                } else {
                    createPage(currentStackPane, currentIndex);
                }
            });
        }

        // Create the indicators using fromIndex and toIndex.
        private void initializePageIndicators() {
            previousIndicatorCount = 0;
            controlBox.getChildren().clear();
            clearIndicatorButtons();

            controlBox.getChildren().add(leftArrowButton);
            for (int i = fromIndex; i &lt;= toIndex; i++) {
                IndicatorButton ib = new IndicatorButton(i);
                ib.setMinSize(minButtonSize, minButtonSize);
                ib.setToggleGroup(indicatorButtons);
                controlBox.getChildren().add(ib);
            }
            controlBox.getChildren().add(rightArrowButton);
        }

        private void clearIndicatorButtons() {
            for (Toggle toggle : indicatorButtons.getToggles()) {
                if (toggle instanceof IndicatorButton) {
                    IndicatorButton indicatorButton = (IndicatorButton) toggle;
                    indicatorButton.release();
                }
            }
            indicatorButtons.getToggles().clear();
        }

        // Finds and selects the IndicatorButton using the currentIndex.
         private void updatePageIndicators() {
            for (int i = 0; i &lt; indicatorButtons.getToggles().size(); i++) {
                IndicatorButton ib = (IndicatorButton)indicatorButtons.getToggles().get(i);
                if (ib.getPageNumber() == currentIndex) {
                    ib.setSelected(true);
                    updatePageInformation();
                    break;
                }
            }
            getSkinnable().notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
        }

        // Update the page index using the currentIndex and updates the page set
        // if necessary.
        private void updatePageIndex() {
            //System.out.println(&quot;SELECT PROPERTY FROM &quot; + fromIndex + &quot; TO &quot; + toIndex + &quot; PREVIOUS &quot; + previousIndex + &quot; CURRENT &quot;+ currentIndex + &quot; PAGE COUNT &quot; + pageCount + &quot; MAX PAGE INDICATOR COUNT &quot; + maxPageIndicatorCount);
            if (pageCount == maxPageIndicatorCount) {
                if (changePageSet()) {
                    initializePageIndicators();
                }
            }
            updatePageIndicators();
            requestLayout();
        }

        private void updatePageInformation() {
            String currentPageNumber = Integer.toString(currentIndex + 1);
            String lastPageNumber = getPageCount() == Pagination.INDETERMINATE ? &quot;...&quot; : Integer.toString(getPageCount());
            pageInformation.setText(currentPageNumber + &quot;/&quot; + lastPageNumber);
        }

        private int previousIndicatorCount = 0;
        // Layout the maximum number of page indicators we can fit within the width.
        // And always show the selected indicator.
        private void layoutPageIndicators() {
            final double left = snappedLeftInset();
            final double right = snappedRightInset();
            final double width = snapSize(getWidth()) - (left + right);
            final double controlBoxleft = controlBox.snappedLeftInset();
            final double controlBoxRight = controlBox.snappedRightInset();
            final double leftArrowWidth = snapSize(Utils.boundedSize(leftArrowButton.prefWidth(-1), leftArrowButton.minWidth(-1), leftArrowButton.maxWidth(-1)));
            final double rightArrowWidth = snapSize(Utils.boundedSize(rightArrowButton.prefWidth(-1), rightArrowButton.minWidth(-1), rightArrowButton.maxWidth(-1)));
            final double spacing = snapSize(controlBox.getSpacing());
            double w = width - (controlBoxleft + leftArrowWidth + 2* arrowButtonGap.get() + spacing + rightArrowWidth + controlBoxRight);

            if (isPageInformationVisible() &amp;&amp;
                    (Side.LEFT.equals(getPageInformationAlignment()) ||
                    Side.RIGHT.equals(getPageInformationAlignment()))) {
                w -= snapSize(pageInformation.prefWidth(-1));
            }

            double x = 0;
            int indicatorCount = 0;
            for (int i = 0; i &lt; getMaxPageIndicatorCount(); i++) {
                int index = i &lt; indicatorButtons.getToggles().size() ? i : indicatorButtons.getToggles().size() - 1;
                double iw = minButtonSize;
                if (index != -1) {
                    IndicatorButton ib = (IndicatorButton)indicatorButtons.getToggles().get(index);
                    iw = snapSize(Utils.boundedSize(ib.prefWidth(-1), ib.minWidth(-1), ib.maxWidth(-1)));
                }

                x += (iw + spacing);
                if (x &gt; w) {
                    break;
                }
                indicatorCount++;
            }
            if (indicatorCount == 0) {
               indicatorCount = 1; // The parent didn't respect the minSize of this Pagination.
                                   // We will show at least one indicator nonetheless.
            }

            if (indicatorCount != previousIndicatorCount) {
                if (indicatorCount &lt; getMaxPageIndicatorCount()) {
                    maxPageIndicatorCount = indicatorCount;
                } else {
                    maxPageIndicatorCount = getMaxPageIndicatorCount();
                }

                int lastIndicatorButtonIndex;
                if (pageCount &gt; maxPageIndicatorCount) {
                    pageCount = maxPageIndicatorCount;
                    lastIndicatorButtonIndex = maxPageIndicatorCount - 1;
                 } else {
                    if (indicatorCount &gt; getPageCount()) {
                        pageCount = getPageCount();
                        lastIndicatorButtonIndex = getPageCount() - 1;
                    } else {
                        pageCount = indicatorCount;
                        lastIndicatorButtonIndex = indicatorCount - 1;
                    }
                }

                if (currentIndex &gt;= toIndex) {
                    // The current index has fallen off the right
                    toIndex = currentIndex;
                    fromIndex = toIndex - lastIndicatorButtonIndex;
                } else if (currentIndex &lt;= fromIndex) {
                    // The current index has fallen off the left
                    fromIndex = currentIndex;
                    toIndex = fromIndex + lastIndicatorButtonIndex;
                } else {
                    toIndex = fromIndex + lastIndicatorButtonIndex;
                }

                if (toIndex &gt; getPageCount() - 1) {
                    toIndex = getPageCount() - 1;
                    //fromIndex = toIndex - lastIndicatorButtonIndex;
                }

                if (fromIndex &lt; 0) {
                    fromIndex = 0;
                    toIndex = fromIndex + lastIndicatorButtonIndex;
                }

                initializePageIndicators();
                updatePageIndicators();
                previousIndicatorCount = indicatorCount;
            }
        }

        // Only change to the next set when the current index is at the start or the end of the set.
        // Return true only if we have scrolled to the next/previous set.
        private boolean changePageSet() {
            int index = indexToIndicatorButtonsIndex(currentIndex);
            int lastIndicatorButtonIndex = maxPageIndicatorCount - 1;
            if (previousIndex &lt; currentIndex &amp;&amp;
                    index == 0 &amp;&amp;
                    lastIndicatorButtonIndex != 0 &amp;&amp;
                    index % lastIndicatorButtonIndex == 0) {
                // Get the right page set
                fromIndex = currentIndex;
                toIndex = fromIndex + lastIndicatorButtonIndex;
            } else if (currentIndex &lt; previousIndex &amp;&amp;
                    index == lastIndicatorButtonIndex &amp;&amp;
                    lastIndicatorButtonIndex != 0 &amp;&amp;
                    index % lastIndicatorButtonIndex == 0) {
                // Get the left page set
                toIndex = currentIndex;
                fromIndex = toIndex - lastIndicatorButtonIndex;
            } else {
                // We need to get the new page set if the currentIndex is out of range.
                // This can happen if setPageIndex() is called programatically.
                if (currentIndex &lt; fromIndex || currentIndex &gt; toIndex) {
                    fromIndex = currentIndex - index;
                    toIndex = fromIndex + lastIndicatorButtonIndex;
                } else {
                    return false;
                }
            }

            // We have gone past the total number of pages
            if (toIndex &gt; getPageCount() - 1) {
                if (fromIndex &gt; getPageCount() - 1) {
                    return false;
                } else {
                  toIndex = getPageCount() - 1;
                  //fromIndex = toIndex - lastIndicatorButtonIndex;
                }
            }

            // We have gone past the starting page
            if (fromIndex &lt; 0) {
                fromIndex = 0;
                toIndex = fromIndex + lastIndicatorButtonIndex;
            }
            return true;
        }

        private int indexToIndicatorButtonsIndex(int index) {
            // This should be in the indicator buttons toggle list.
            if (index &gt;= fromIndex &amp;&amp; index &lt;= toIndex) {
                return index - fromIndex;
            }
            // The requested index is not in indicator buttons list we have to predict
            // where the index will be.
            int i = 0;
            int from = fromIndex;
            int to = toIndex;
            if (currentIndex &gt; previousIndex) {
                while(from &lt; getPageCount() &amp;&amp; to &lt; getPageCount()) {
                    from += i;
                    to += i;
                    if (index &gt;= from &amp;&amp; index &lt;= to) {
                        if (index == from) {
                            return 0;
                        } else if (index == to) {
                            return maxPageIndicatorCount - 1;
                        }
                        return index - from;
                    }
                    i += maxPageIndicatorCount;
                }
            } else {
                while (from &gt; 0 &amp;&amp; to &gt; 0) {
                    from -= i;
                    to -= i;
                    if (index &gt;= from &amp;&amp; index &lt;= to) {
                        if (index == from) {
                            return 0;
                        } else if (index == to) {
                            return maxPageIndicatorCount - 1;
                        }
                        return index - from;
                    }
                    i += maxPageIndicatorCount;
                }
            }
            // We are on the last page set going back to the previous page set
            return maxPageIndicatorCount - 1;
        }

        private Pos sideToPos(Side s) {
            if (Side.TOP.equals(s)) {
                return Pos.TOP_CENTER;
            } else if (Side.RIGHT.equals(s)) {
                return Pos.CENTER_RIGHT;
            } else if (Side.BOTTOM.equals(s)) {
                return Pos.BOTTOM_CENTER;
            }
            return Pos.CENTER_LEFT;
        }

        @Override protected double computeMinWidth(double height) {
            double left = snappedLeftInset();
            double right = snappedRightInset();
            double leftArrowWidth = snapSize(Utils.boundedSize(leftArrowButton.prefWidth(-1), leftArrowButton.minWidth(-1), leftArrowButton.maxWidth(-1)));
            double rightArrowWidth = snapSize(Utils.boundedSize(rightArrowButton.prefWidth(-1), rightArrowButton.minWidth(-1), rightArrowButton.maxWidth(-1)));
            double spacing = snapSize(controlBox.getSpacing());
            double pageInformationWidth = 0;
            Side side = getPageInformationAlignment();
            if (Side.LEFT.equals(side) || Side.RIGHT.equals(side)) {
                pageInformationWidth = snapSize(pageInformation.prefWidth(-1));
            }
            double arrowGap = arrowButtonGap.get();

            return left + leftArrowWidth + 2 *arrowGap + minButtonSize /*at least one button*/
                    + 2 * spacing + rightArrowWidth + right + pageInformationWidth;
        }

        @Override protected double computeMinHeight(double width) {
            return computePrefHeight(width);
        }

        @Override protected double computePrefWidth(double height) {
            final double left = snappedLeftInset();
            final double right = snappedRightInset();
            final double controlBoxWidth = snapSize(controlBox.prefWidth(height));
            double pageInformationWidth = 0;
            Side side = getPageInformationAlignment();
            if (Side.LEFT.equals(side) || Side.RIGHT.equals(side)) {
                pageInformationWidth = snapSize(pageInformation.prefWidth(-1));
            }

            return left + controlBoxWidth + right + pageInformationWidth;
        }

        @Override protected double computePrefHeight(double width) {
            final double top = snappedTopInset();
            final double bottom = snappedBottomInset();
            final double boxHeight = snapSize(controlBox.prefHeight(width));
            double pageInformationHeight = 0;
            Side side = getPageInformationAlignment();
            if (Side.TOP.equals(side) || Side.BOTTOM.equals(side)) {
                pageInformationHeight = snapSize(pageInformation.prefHeight(-1));
            }

            return top + boxHeight + pageInformationHeight + bottom;
        }

        @Override protected void layoutChildren() {
            final double top = snappedTopInset();
            final double bottom = snappedBottomInset();
            final double left = snappedLeftInset();
            final double right = snappedRightInset();
            final double width = snapSize(getWidth()) - (left + right);
            final double height = snapSize(getHeight()) - (top + bottom);
            final double controlBoxWidth = snapSize(controlBox.prefWidth(-1));
            final double controlBoxHeight = snapSize(controlBox.prefHeight(-1));
            final double pageInformationWidth = snapSize(pageInformation.prefWidth(-1));
            final double pageInformationHeight = snapSize(pageInformation.prefHeight(-1));

            leftArrowButton.setDisable(false);
            rightArrowButton.setDisable(false);

            if (currentIndex == 0) {
                // Grey out the left arrow if we are at the beginning.
                leftArrowButton.setDisable(true);
            }
            if (currentIndex == (getPageCount() - 1)) {
                // Grey out the right arrow if we have reached the end.
                rightArrowButton.setDisable(true);
            }
            // Reapply CSS so the left and right arrow button's disable state is updated
            // immediately.
            applyCss();

            leftArrowButton.setVisible(isArrowsVisible());
            rightArrowButton.setVisible(isArrowsVisible());
            pageInformation.setVisible(isPageInformationVisible());

            // Determine the number of indicators we can fit within the pagination width.
            layoutPageIndicators();

            HPos controlBoxHPos = controlBox.getAlignment().getHpos();
            VPos controlBoxVPos = controlBox.getAlignment().getVpos();
            double controlBoxX = left + Utils.computeXOffset(width, controlBoxWidth, controlBoxHPos);
            double controlBoxY = top + Utils.computeYOffset(height, controlBoxHeight, controlBoxVPos);

            if (isPageInformationVisible()) {
                Pos p = sideToPos(getPageInformationAlignment());
                HPos pageInformationHPos = p.getHpos();
                VPos pageInformationVPos = p.getVpos();
                double pageInformationX = left + Utils.computeXOffset(width, pageInformationWidth, pageInformationHPos);
                double pageInformationY = top + Utils.computeYOffset(height, pageInformationHeight, pageInformationVPos);

                if (Side.TOP.equals(getPageInformationAlignment())) {
                    pageInformationY = top;
                    controlBoxY = top + pageInformationHeight;
                } else if (Side.RIGHT.equals(getPageInformationAlignment())) {
                    pageInformationX = width - right - pageInformationWidth;
                } else if (Side.BOTTOM.equals(getPageInformationAlignment())) {
                    controlBoxY = top;
                    pageInformationY = top + controlBoxHeight;
                } else if (Side.LEFT.equals(getPageInformationAlignment())) {
                    pageInformationX = left;
                }
                layoutInArea(pageInformation, pageInformationX, pageInformationY, pageInformationWidth, pageInformationHeight, 0, pageInformationHPos, pageInformationVPos);
            }

            layoutInArea(controlBox, controlBoxX, controlBoxY, controlBoxWidth, controlBoxHeight, 0, controlBoxHPos, controlBoxVPos);
        }
    }

    class IndicatorButton extends ToggleButton {
        private final ListChangeListener&lt;String&gt; updateSkinIndicatorType =
                                                    c -&gt; setIndicatorType();

        private final ChangeListener&lt;Boolean&gt; updateTooltipVisibility =
                       (ob, oldValue, newValue) -&gt; setTooltipVisible(newValue);

        private int pageNumber;

        public IndicatorButton(int pageNumber) {
            this.pageNumber = pageNumber;
            setFocusTraversable(false);
            setIndicatorType();
            setTooltipVisible(isTooltipVisible());

            getSkinnable().getStyleClass().addListener(updateSkinIndicatorType);

            setOnAction(arg0 -&gt; {
                    getNode().requestFocus();
                    int selected = getCurrentPageIndex();
                    // We do not need to update the selection if it has not changed.
                    if (selected != IndicatorButton.this.pageNumber) {
                        pagination.setCurrentPageIndex(IndicatorButton.this.pageNumber);
                        requestLayout();
                    }
            });

            tooltipVisibleProperty().addListener(updateTooltipVisibility);

            prefHeightProperty().bind(minHeightProperty());
            setAccessibleRole(AccessibleRole.PAGE_ITEM);
        }

        private void setIndicatorType() {
            if (getSkinnable().getStyleClass().contains(Pagination.STYLE_CLASS_BULLET)) {
                getStyleClass().remove(&quot;number-button&quot;);
                getStyleClass().add(&quot;bullet-button&quot;);
                setText(null);

                // Bind the width in addition to the height to ensure the region is square
                prefWidthProperty().bind(minWidthProperty());
            } else {
                getStyleClass().remove(&quot;bullet-button&quot;);
                getStyleClass().add(&quot;number-button&quot;);
                setText(Integer.toString(this.pageNumber + 1));

                // Free the width to conform to the text content
                prefWidthProperty().unbind();
            }
        }

        private void setTooltipVisible(boolean b) {
            if (b) {
                setTooltip(new Tooltip(Integer.toString(IndicatorButton.this.pageNumber + 1)));
            } else {
                setTooltip(null);
            }
        }

        public int getPageNumber() {
            return this.pageNumber;
        }

        @Override public void fire() {
            // we don't toggle from selected to not selected if part of a group
            if (getToggleGroup() == null || !isSelected()) {
                super.fire();
            }
        }

        public void release() {
            getSkinnable().getStyleClass().removeListener(updateSkinIndicatorType);
            tooltipVisibleProperty().removeListener(updateTooltipVisibility);
        }

        /** {@inheritDoc} */
        @Override
        public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
            switch (attribute) {
                case TEXT: return getText();
                case SELECTED: return isSelected();
                default: return super.queryAccessibleAttribute(attribute, parameters);
            }
        }

        /** {@inheritDoc} */
        @Override
        public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
            switch (action) {
                case REQUEST_FOCUS:
                    getSkinnable().setCurrentPageIndex(pageNumber);
                    break;
                default: super.executeAccessibleAction(action);
            }
        }
    }

    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/

    private static final Boolean DEFAULT_ARROW_VISIBLE = Boolean.FALSE;
    private static final Boolean DEFAULT_PAGE_INFORMATION_VISIBLE = Boolean.FALSE;
    private static final Side DEFAULT_PAGE_INFORMATION_ALIGNMENT = Side.BOTTOM;
    private static final Boolean DEFAULT_TOOLTIP_VISIBLE = Boolean.FALSE;

    private static class StyleableProperties {
        private static final CssMetaData&lt;Pagination,Boolean&gt; ARROWS_VISIBLE =
            new CssMetaData&lt;Pagination,Boolean&gt;(&quot;-fx-arrows-visible&quot;,
                BooleanConverter.getInstance(), DEFAULT_ARROW_VISIBLE) {

            @Override
            public boolean isSettable(Pagination n) {
                final PaginationSkin skin = (PaginationSkin) n.getSkin();
                return skin.arrowsVisible == null || !skin.arrowsVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Pagination n) {
                final PaginationSkin skin = (PaginationSkin) n.getSkin();
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)skin.arrowsVisibleProperty();
            }
        };

        private static final CssMetaData&lt;Pagination,Boolean&gt; PAGE_INFORMATION_VISIBLE =
            new CssMetaData&lt;Pagination,Boolean&gt;(&quot;-fx-page-information-visible&quot;,
                BooleanConverter.getInstance(), DEFAULT_PAGE_INFORMATION_VISIBLE) {

            @Override
            public boolean isSettable(Pagination n) {
                final PaginationSkin skin = (PaginationSkin) n.getSkin();
                return skin.pageInformationVisible == null || !skin.pageInformationVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Pagination n) {
                final PaginationSkin skin = (PaginationSkin) n.getSkin();
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)skin.pageInformationVisibleProperty();
            }
        };

        private static final CssMetaData&lt;Pagination,Side&gt; PAGE_INFORMATION_ALIGNMENT =
            new CssMetaData&lt;Pagination,Side&gt;(&quot;-fx-page-information-alignment&quot;,
                new EnumConverter&lt;Side&gt;(Side.class), DEFAULT_PAGE_INFORMATION_ALIGNMENT) {

            @Override
            public boolean isSettable(Pagination n) {
                final PaginationSkin skin = (PaginationSkin) n.getSkin();
                return skin.pageInformationAlignment == null || !skin.pageInformationAlignment.isBound();
            }

            @Override
            public StyleableProperty&lt;Side&gt; getStyleableProperty(Pagination n) {
                final PaginationSkin skin = (PaginationSkin) n.getSkin();
                return (StyleableProperty&lt;Side&gt;)(WritableValue&lt;Side&gt;)skin.pageInformationAlignmentProperty();
            }
        };

        private static final CssMetaData&lt;Pagination,Boolean&gt; TOOLTIP_VISIBLE =
            new CssMetaData&lt;Pagination,Boolean&gt;(&quot;-fx-tooltip-visible&quot;,
                BooleanConverter.getInstance(), DEFAULT_TOOLTIP_VISIBLE) {

            @Override
            public boolean isSettable(Pagination n) {
                final PaginationSkin skin = (PaginationSkin) n.getSkin();
                return skin.tooltipVisible == null || !skin.tooltipVisible.isBound();
            }

            @Override
            public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Pagination n) {
                final PaginationSkin skin = (PaginationSkin) n.getSkin();
                return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)skin.tooltipVisibleProperty();
            }
        };
        private static final CssMetaData&lt;Pagination,Number&gt; ARROW_BUTTON_GAP =
            new CssMetaData&lt;Pagination,Number&gt;(&quot;-fx-arrow-button-gap&quot;, SizeConverter.getInstance(), 4) {
                @Override public boolean isSettable(Pagination n) {
                    final PaginationSkin skin = (PaginationSkin) n.getSkin();
                    return skin.arrowButtonGap == null ||
                            !skin.arrowButtonGap.isBound();
                }
                @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(Pagination n) {
                    final PaginationSkin skin = (PaginationSkin) n.getSkin();
                    return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)skin.arrowButtonGapProperty();
                }
            };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
        static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
            styleables.add(ARROWS_VISIBLE);
            styleables.add(PAGE_INFORMATION_VISIBLE);
            styleables.add(PAGE_INFORMATION_ALIGNMENT);
            styleables.add(TOOLTIP_VISIBLE);
            styleables.add(ARROW_BUTTON_GAP);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
    }

    /**
     * Returns the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/RadioButtonSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.behavior.BehaviorBase;
import com.sun.javafx.scene.control.behavior.ToggleButtonBehavior;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.scene.Node;
import javafx.scene.control.Accordion;
import javafx.scene.control.Button;
import javafx.scene.control.Control;
import javafx.scene.control.RadioButton;
import javafx.scene.layout.StackPane;

/**
 * Default skin implementation for the {@link RadioButton} control.
 *
 * @see RadioButton
 * @since 9
 */
public class RadioButtonSkin extends LabeledSkinBase&lt;RadioButton&gt; {

    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    /** The radio contains the &quot;dot&quot;, which is usually a circle */
    private StackPane radio;
    private final BehaviorBase&lt;RadioButton&gt; behavior;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new RadioButtonSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public RadioButtonSkin(RadioButton control) {
        super(control);

        // install default input map for the RadioButton control
        behavior = new ToggleButtonBehavior&lt;&gt;(control);
//        control.setInputMap(behavior.getInputMap());

        radio = createRadio();
        updateChildren();
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected void updateChildren() {
        super.updateChildren();
        if (radio != null) {
            getChildren().add(radio);
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return super.computeMinWidth(height, topInset, rightInset, bottomInset, leftInset) + snapSizeX(radio.minWidth(-1));
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return Math.max(snapSizeY(super.computeMinHeight(width - radio.minWidth(-1), topInset, rightInset, bottomInset, leftInset)),
                topInset + radio.minHeight(-1) + bottomInset);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return super.computePrefWidth(height, topInset, rightInset, bottomInset, leftInset) + snapSizeX(radio.prefWidth(-1));
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return Math.max(snapSizeY(super.computePrefHeight(width - radio.prefWidth(-1), topInset, rightInset, bottomInset, leftInset)),
                topInset + radio.prefHeight(-1) + bottomInset);
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x, final double y,
                                            final double w, final double h) {
        final RadioButton radioButton = getSkinnable();
        final double radioWidth = radio.prefWidth(-1);
        final double radioHeight = radio.prefHeight(-1);
        final double computeWidth = Math.max(radioButton.prefWidth(-1),radioButton.minWidth(-1));
        final double labelWidth = Math.min(computeWidth - radioWidth, w - snapSizeX(radioWidth));
        final double labelHeight = Math.min(radioButton.prefHeight(labelWidth), h);
        final double maxHeight = Math.max(radioHeight, labelHeight);
        final double xOffset = Utils.computeXOffset(w, labelWidth + radioWidth, radioButton.getAlignment().getHpos()) + x;
<A NAME="10"></A>        final double yOffset = Utils.computeYOffset(h, maxHeight, radioButton.getAlignment().getVpos()) + y;

        layoutLabelInArea(xOffset + radioWidth, yOffset, labelWidth, maxHeight,  radioButton.getAlignment());
        <FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#10',2,'match49-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>radio.resize(snapSizeX(radioWidth), snapSizeY(radioHeight));
        positionInArea(radio, xOffset, yOffset, radioWidth, maxHeight, 0, radioButton.getAlignment().getHpos(), radioButton.getAlignment().getVpos());
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private static StackPane createRadio() {
        StackPane radio = new StackPane();
        radio.getStyleClass().setAll(&quot;radio&quot;);
        radio.setSnapToPixel</B></FONT>(false);
        StackPane region = new StackPane();
        region.getStyleClass().setAll(&quot;dot&quot;);
        radio.getChildren().clear();
        radio.getChildren().addAll(region);
        return radio;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TableRowSkinBase.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;


import java.lang.ref.Reference;
import java.lang.ref.WeakReference;
import java.util.*;

import com.sun.javafx.PlatformUtil;
import javafx.animation.FadeTransition;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.WeakListChangeListener;
import javafx.css.StyleOrigin;
import javafx.css.StyleableObjectProperty;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.*;
import javafx.util.Duration;

import com.sun.javafx.tk.Toolkit;

/**
 * TableRowSkinBase is the base skin class used by controls such as
 * {@link javafx.scene.control.TableRow} and {@link javafx.scene.control.TreeTableRow}
 * (the concrete classes are {@link TableRowSkin} and {@link TreeTableRowSkin},
 * respectively).
 *
 * @param &lt;T&gt; The type of the cell (i.e. the generic type of the {@link IndexedCell} subclass).
 * @param &lt;C&gt; The cell type (e.g. TableRow or TreeTableRow)
 * @param &lt;R&gt; The type of cell that is contained within each row (e.g.
 *           {@link javafx.scene.control.TableCell or {@link javafx.scene.control.TreeTableCell}}).
 *
 * @since 9
 * @see javafx.scene.control.TableRow
 * @see javafx.scene.control.TreeTableRow
 * @see TableRowSkin
 * @see TreeTableRowSkin
 */
public abstract class TableRowSkinBase&lt;T,
                                       C extends IndexedCell/*&lt;T&gt;*/,
                                       R extends IndexedCell&gt; extends CellSkinBase&lt;C&gt; {

    /***************************************************************************
     *                                                                         *
     * Static Fields                                                           *
     *                                                                         *
     **************************************************************************/

    // There appears to be a memory leak when using the stub toolkit. Therefore,
    // to prevent tests from failing we disable the animations below when the
    // stub toolkit is being used.
    // Filed as RT-29163.
    private static boolean IS_STUB_TOOLKIT = Toolkit.getToolkit().toString().contains(&quot;StubToolkit&quot;);

    // lets save the CPU and not do animations when on embedded platforms
    private static boolean DO_ANIMATIONS = ! IS_STUB_TOOLKIT &amp;&amp; ! PlatformUtil.isEmbedded();

    private static final Duration FADE_DURATION = Duration.millis(200);

    /*
     * This is rather hacky - but it is a quick workaround to resolve the
     * issue that we don't know maximum width of a disclosure node for a given
     * control. If we don't know the maximum width, we have no way to ensure
     * consistent indentation.
     *
     * To work around this, we create a single WeakHashMap to store a max
     * disclosureNode width per TableColumnBase. We use WeakHashMap to help prevent
     * any memory leaks.
     */
    static final Map&lt;TableColumnBase&lt;?,?&gt;, Double&gt; maxDisclosureWidthMap = new WeakHashMap&lt;&gt;();

    // Specifies the number of times we will call 'recreateCells()' before we blow
    // out the cellsMap structure and rebuild all cells. This helps to prevent
    // against memory leaks in certain extreme circumstances.
    private static final int DEFAULT_FULL_REFRESH_COUNTER = 100;



    /***************************************************************************
     *                                                                         *
     * Private Fields                                                          *
     *                                                                         *
     **************************************************************************/

    /*
     * A map that maps from TableColumn to TableCell (i.e. model to view).
     * This is recreated whenever the leaf columns change, however to increase
     * efficiency we create cells for all columns, even if they aren't visible,
     * and we only create new cells if we don't already have it cached in this
     * map.
     *
     * Note that this means that it is possible for this map to therefore be
     * a memory leak if an application uses TableView and is creating and removing
     * a large number of tableColumns. This is mitigated in the recreateCells()
     * function below - refer to that to learn more.
     */
    WeakHashMap&lt;TableColumnBase, Reference&lt;R&gt;&gt; cellsMap;

    // This observableArrayList contains the currently visible table cells for this row.
    final List&lt;R&gt; cells = new ArrayList&lt;&gt;();

    private int fullRefreshCounter = DEFAULT_FULL_REFRESH_COUNTER;

    boolean isDirty = false;
    boolean updateCells = false;

    double fixedCellSize;
    boolean fixedCellSizeEnabled;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new instance of TableRowSkinBase, although note that this
     * instance does not handle any behavior / input mappings - this needs to be
     * handled appropriately by subclasses.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TableRowSkinBase(C control) {
        super(control);
        getSkinnable().setPickOnBounds(false);

        recreateCells();
        updateCells(true);

        // init bindings
        // watches for any change in the leaf columns observableArrayList - this will indicate
        // that the column order has changed and that we should update the row
        // such that the cells are in the new order
        getVisibleLeafColumns().addListener(weakVisibleLeafColumnsListener);
        // --- end init bindings


        // use invalidation listener here to update even when item equality is true
        // (e.g. see RT-22463)
        control.itemProperty().addListener(o -&gt; requestCellUpdate());
        registerChangeListener(control.indexProperty(), e -&gt; {
            // Fix for RT-36661, where empty table cells were showing content, as they
            // had incorrect table cell indices (but the table row index was correct).
            // Note that we only do the update on empty cells to avoid the issue
            // noted below in requestCellUpdate().
            if (getSkinnable().isEmpty()) {
                requestCellUpdate();
            }
        });
    }



    /***************************************************************************
     *                                                                         *
     * Listeners                                                               *
     *                                                                         *
     **************************************************************************/

    private ListChangeListener&lt;TableColumnBase&gt; visibleLeafColumnsListener = c -&gt; {
        isDirty = true;
        getSkinnable().requestLayout();
    };

    private WeakListChangeListener&lt;TableColumnBase&gt; weakVisibleLeafColumnsListener =
            new WeakListChangeListener&lt;&gt;(visibleLeafColumnsListener);



    /***************************************************************************
     *                                                                         *
     * Abstract Methods                                                        *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new cell instance that is suitable for representing the given table column instance.
     * @param tc the table column
     * @return the created cell
     */
    protected abstract R createCell(TableColumnBase&lt;T,?&gt; tc);

    /**
     * A method to allow the given cell to be told that it is a member of the given row.
     * How this is implemented is dependent on the actual cell implementation.
     * @param cell The cell for which we want to inform it of its owner row.
     * @param row The row which will be set on the given cell.
     */
    protected abstract void updateCell(R cell, C row);

    /**
     * Returns the {@link TableColumnBase} instance for the given cell instance.
     * @param cell The cell for which a TableColumn is desired.
     * @return the table column
     */
    protected abstract TableColumnBase&lt;T,?&gt; getTableColumn(R cell);

    /**
     * Returns an unmodifiable list containing the currently visible leaf columns.
     * @return the list of visible leaf columns
     */
    protected abstract ObservableList&lt;? extends TableColumnBase/*&lt;T,?&gt;*/&gt; getVisibleLeafColumns();



    /***************************************************************************
     *                                                                         *
     * Public Methods                                                          *
     *                                                                         *
     **************************************************************************/

    /**
     * Returns the graphic to draw on the inside of the disclosure node. Null
     * is acceptable when no graphic should be shown. Commonly this is the
     * graphic associated with a TreeItem (i.e. treeItem.getGraphic()), rather
     * than a graphic associated with a cell.
     * @return the graphic to draw on the inside of the disclosure node
     */
    protected ObjectProperty&lt;Node&gt; graphicProperty() {
        return null;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(double x, final double y, final double w, final double h) {
        checkState();
        if (cellsMap.isEmpty()) return;

        ObservableList&lt;? extends TableColumnBase&gt; visibleLeafColumns = getVisibleLeafColumns();
        if (visibleLeafColumns.isEmpty()) {
            super.layoutChildren(x,y,w,h);
            return;
        }

        C control = getSkinnable();

        ///////////////////////////////////////////
        // indentation code starts here
        ///////////////////////////////////////////
        double leftMargin = 0;
        double disclosureWidth = 0;
        double graphicWidth = 0;
        boolean indentationRequired = isIndentationRequired();
        boolean disclosureVisible = isDisclosureNodeVisible();
        int indentationColumnIndex = 0;
        Node disclosureNode = null;
        if (indentationRequired) {
            // Determine the column in which we want to put the disclosure node.
            // By default it is null, which means the 0th column should be
            // where the indentation occurs.
            TableColumnBase&lt;?,?&gt; treeColumn = getTreeColumn();
            indentationColumnIndex = treeColumn == null ? 0 : visibleLeafColumns.indexOf(treeColumn);
            indentationColumnIndex = indentationColumnIndex &lt; 0 ? 0 : indentationColumnIndex;

            int indentationLevel = getIndentationLevel(control);
            if (! isShowRoot()) indentationLevel--;
            final double indentationPerLevel = getIndentationPerLevel();
            leftMargin = indentationLevel * indentationPerLevel;

            // position the disclosure node so that it is at the proper indent
            final double defaultDisclosureWidth = maxDisclosureWidthMap.containsKey(treeColumn) ?
                maxDisclosureWidthMap.get(treeColumn) : 0;
            disclosureWidth = defaultDisclosureWidth;

            disclosureNode = getDisclosureNode();
            if (disclosureNode != null) {
                disclosureNode.setVisible(disclosureVisible);

                if (disclosureVisible) {
                    disclosureWidth = disclosureNode.prefWidth(h);
                    if (disclosureWidth &gt; defaultDisclosureWidth) {
                        maxDisclosureWidthMap.put(treeColumn, disclosureWidth);

                        // RT-36359: The recorded max width of the disclosure node
                        // has increased. We need to go back and request all
                        // earlier rows to update themselves to take into account
                        // this increased indentation.
                        final VirtualFlow&lt;C&gt; flow = getVirtualFlow();
                        final int thisIndex = getSkinnable().getIndex();
                        for (int i = 0; i &lt; flow.cells.size(); i++) {
                            C cell = flow.cells.get(i);
                            if (cell == null || cell.isEmpty()) continue;
                            cell.requestLayout();
                            cell.layout();
                        }
                    }
                }
            }
        }
        ///////////////////////////////////////////
        // indentation code ends here
        ///////////////////////////////////////////

        // layout the individual column cells
        double width;
        double height;

        final double verticalPadding = snappedTopInset() + snappedBottomInset();
        final double horizontalPadding = snappedLeftInset() + snappedRightInset();
        final double controlHeight = control.getHeight();

        /**
         * RT-26743:TreeTableView: Vertical Line looks unfinished.
         * We used to not do layout on cells whose row exceeded the number
         * of items, but now we do so as to ensure we get vertical lines
         * where expected in cases where the vertical height exceeds the
         * number of items.
         */
        int index = control.getIndex();
        if (index &lt; 0/* || row &gt;= itemsProperty().get().size()*/) return;

        for (int column = 0, max = cells.size(); column &lt; max; column++) {
            R tableCell = cells.get(column);
            TableColumnBase&lt;T, ?&gt; tableColumn = getTableColumn(tableCell);

            boolean isVisible = true;
            if (fixedCellSizeEnabled) {
                // we determine if the cell is visible, and if not we have the
                // ability to take it out of the scenegraph to help improve
                // performance. However, we only do this when there is a
                // fixed cell length specified in the TableView. This is because
                // when we have a fixed cell length it is possible to know with
                // certainty the height of each TableCell - it is the fixed value
                // provided by the developer, and this means that we do not have
                // to concern ourselves with the possibility that the height
                // may be variable and / or dynamic.
                isVisible = isColumnPartiallyOrFullyVisible(tableColumn);

                height = fixedCellSize;
            } else {
                height = Math.max(controlHeight, tableCell.prefHeight(-1));
                height = snapSizeY(height) - snapSizeY(verticalPadding);
            }

            if (isVisible) {
                if (fixedCellSizeEnabled &amp;&amp; tableCell.getParent() == null) {
                    getChildren().add(tableCell);
                }

                width = tableCell.prefWidth(height) - snapSizeX(horizontalPadding);

                // Added for RT-32700, and then updated for RT-34074.
                // We change the alignment from CENTER_LEFT to TOP_LEFT if the
                // height of the row is greater than the default size, and if
                // the alignment is the default alignment.
                // What I would rather do is only change the alignment if the
                // alignment has not been manually changed, but for now this will
                // do.
                final boolean centreContent = h &lt;= 24.0;

                // if the style origin is null then the property has not been
                // set (or it has been reset to its default), which means that
                // we can set it without overwriting someone elses settings.
                final StyleOrigin origin = ((StyleableObjectProperty&lt;?&gt;) tableCell.alignmentProperty()).getStyleOrigin();
                if (! centreContent &amp;&amp; origin == null) {
                    tableCell.setAlignment(Pos.TOP_LEFT);
                }
                // --- end of RT-32700 fix

                ///////////////////////////////////////////
                // further indentation code starts here
                ///////////////////////////////////////////
                if (indentationRequired &amp;&amp; column == indentationColumnIndex) {
                    if (disclosureVisible) {
                        double ph = disclosureNode.prefHeight(disclosureWidth);

                        if (width &gt; 0 &amp;&amp; width &lt; (disclosureWidth + leftMargin)) {
                            fadeOut(disclosureNode);
                        } else {
                            fadeIn(disclosureNode);
                            disclosureNode.resize(disclosureWidth, ph);

                            disclosureNode.relocate(x + leftMargin,
                                    centreContent ? (h / 2.0 - ph / 2.0) :
                                            (y + tableCell.getPadding().getTop()));
                            disclosureNode.toFront();
                        }
                    }

                    // determine starting point of the graphic or cell node, and the
                    // remaining width available to them
                    ObjectProperty&lt;Node&gt; graphicProperty = graphicProperty();
                    Node graphic = graphicProperty == null ? null : graphicProperty.get();

                    if (graphic != null) {
                        graphicWidth = graphic.prefWidth(-1) + 3;
                        double ph = graphic.prefHeight(graphicWidth);

                        if (width &gt; 0 &amp;&amp; width &lt; disclosureWidth + leftMargin + graphicWidth) {
                            fadeOut(graphic);
                        } else {
                            fadeIn(graphic);

                            graphic.relocate(x + leftMargin + disclosureWidth,
                                    centreContent ? (h / 2.0 - ph / 2.0) :
                                            (y + tableCell.getPadding().getTop()));

                            graphic.toFront();
                        }
                    }
                }
                ///////////////////////////////////////////
                // further indentation code ends here
                ///////////////////////////////////////////

                tableCell.resize(width, height);
                tableCell.relocate(x, snappedTopInset());

                // Request layout is here as (partial) fix for RT-28684.
                // This does not appear to impact performance...
                tableCell.requestLayout();
            } else {
                width = snapSizeX(tableCell.prefWidth(-1)) - snapSizeX(horizontalPadding);

                if (fixedCellSizeEnabled) {
                    // we only add/remove to the scenegraph if the fixed cell
                    // length support is enabled - otherwise we keep all
                    // TableCells in the scenegraph
                    getChildren().remove(tableCell);
                }
            }

            x += width;
        }
    }

    int getIndentationLevel(C control) {
        return 0;
    }

    double getIndentationPerLevel() {
        return 0;
    }

    /**
     * Used to represent whether the current virtual flow owner is wanting
     * indentation to be used in this table row.
     */
    boolean isIndentationRequired() {
        return false;
    }

    /**
     * Returns the table column that should show the disclosure nodes and / or
     * a graphic. By default this is the left-most column.
     */
    TableColumnBase getTreeColumn() {
        return null;
    }

    Node getDisclosureNode() {
        return null;
    }

    /**
     * Used to represent whether a disclosure node is visible for _this_
     * table row. Not to be confused with isIndentationRequired(), which is the
     * more general API.
     */
    boolean isDisclosureNodeVisible() {
        return false;
    }

    boolean isShowRoot() {
        return true;
    }

    void updateCells(boolean resetChildren) {
        // To avoid a potential memory leak (when the TableColumns in the
        // TableView are created/inserted/removed/deleted, we have a 'refresh
        // counter' that when we reach 0 will delete all cells in this row
        // and recreate all of them.
        if (resetChildren) {
            if (fullRefreshCounter == 0) {
                recreateCells();
            }
            fullRefreshCounter--;
        }

        // if clear isn't called first, we can run into situations where the
        // cells aren't updated properly.
        final boolean cellsEmpty = cells.isEmpty();
        cells.clear();

        final C skinnable = getSkinnable();
        final int skinnableIndex = skinnable.getIndex();
        final List&lt;? extends TableColumnBase/*&lt;T,?&gt;*/&gt; visibleLeafColumns = getVisibleLeafColumns();

        for (int i = 0, max = visibleLeafColumns.size(); i &lt; max; i++) {
            TableColumnBase&lt;T,?&gt; col = visibleLeafColumns.get(i);

            R cell = null;
            if (cellsMap.containsKey(col)) {
                cell = cellsMap.get(col).get();

                // the reference has been gc'd, remove key entry from map
                if (cell == null) {
                    cellsMap.remove(col);
                }
            }

            if (cell == null) {
                // if the cell is null it means we don't have it in cache and
                // need to create it
                cell = createCellAndCache(col);
            }

            updateCell(cell, skinnable);
            cell.updateIndex(skinnableIndex);
            cells.add(cell);
        }

        // update children of each row
        if (fixedCellSizeEnabled) {
            // we leave the adding / removing up to the layoutChildren method mostly,
            // but here we remove any children cells that refer to columns that are
            // not visible
            List&lt;Node&gt; toRemove = new ArrayList&lt;&gt;();
            for (Node cell : getChildren()) {
                if (! (cell instanceof IndexedCell)) continue;
                if (!getTableColumn((R)cell).isVisible()) {
                    toRemove.add(cell);
                }
            }
            getChildren().removeAll(toRemove);
        } else if (!fixedCellSizeEnabled &amp;&amp; (resetChildren || cellsEmpty)) {
            getChildren().setAll(cells);
        }
    }

    VirtualFlow&lt;C&gt; getVirtualFlow() {
        Parent p = getSkinnable();
        while (p != null) {
            if (p instanceof VirtualFlow) {
                return (VirtualFlow&lt;C&gt;) p;
            }
            p = p.getParent();
        }
        return null;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        double prefWidth = 0.0;
        for (R cell : cells) {
            prefWidth += cell.prefWidth(height);
        }
        return prefWidth;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        if (fixedCellSizeEnabled) {
            return fixedCellSize;
        }

        // fix for RT-29080
        checkState();

        // Support for RT-18467: making it easier to specify a height for
        // cells via CSS, where the desired height is less than the height
        // of the TableCells. Essentially, -fx-cell-size is given higher
        // precedence now
        if (getCellSize() &lt; DEFAULT_CELL_SIZE) {
            return getCellSize();
        }

        // FIXME according to profiling, this method is slow and should
        // be optimised
        double prefHeight = 0.0f;
        final int count = cells.size();
        for (int i=0; i&lt;count; i++) {
            final R tableCell = cells.get(i);
            prefHeight = Math.max(prefHeight, tableCell.prefHeight(-1));
        }
        double ph = Math.max(prefHeight, Math.max(getCellSize(), getSkinnable().minHeight(-1)));

        return ph;
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        if (fixedCellSizeEnabled) {
            return fixedCellSize;
        }

        // fix for RT-29080
        checkState();

        // Support for RT-18467: making it easier to specify a height for
        // cells via CSS, where the desired height is less than the height
        // of the TableCells. Essentially, -fx-cell-size is given higher
        // precedence now
        if (getCellSize() &lt; DEFAULT_CELL_SIZE) {
            return getCellSize();
        }

        // FIXME according to profiling, this method is slow and should
        // be optimised
        double minHeight = 0.0f;
        final int count = cells.size();
        for (int i = 0; i &lt; count; i++) {
            final R tableCell = cells.get(i);
            minHeight = Math.max(minHeight, tableCell.minHeight(-1));
        }
        return minHeight;
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        if (fixedCellSizeEnabled) {
            return fixedCellSize;
        }
        return super.computeMaxHeight(width, topInset, rightInset, bottomInset, leftInset);
    }

    final void checkState() {
        if (isDirty) {
            updateCells(true);
            isDirty = false;
            updateCells = false;
        } else if (updateCells) {
            updateCells(false);
            updateCells = false;
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private Implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private boolean isColumnPartiallyOrFullyVisible(TableColumnBase col) {
        if (col == null || !col.isVisible()) return false;

        final VirtualFlow&lt;?&gt; virtualFlow = getVirtualFlow();
        double scrollX = virtualFlow == null ? 0.0 : virtualFlow.getHbar().getValue();

        // work out where this column header is, and it's width (start -&gt; end)
        double start = 0;
        final ObservableList&lt;? extends TableColumnBase&gt; visibleLeafColumns = getVisibleLeafColumns();
        for (int i = 0, max = visibleLeafColumns.size(); i &lt; max; i++) {
            TableColumnBase&lt;?,?&gt; c = visibleLeafColumns.get(i);
            if (c.equals(col)) break;
            start += c.getWidth();
        }
        double end = start + col.getWidth();

        // determine the width of the table
        final Insets padding = getSkinnable().getPadding();
        double headerWidth = getSkinnable().getWidth() - padding.getLeft() + padding.getRight();

        return (start &gt;= scrollX || end &gt; scrollX) &amp;&amp; (start &lt; (headerWidth + scrollX) || end &lt;= (headerWidth + scrollX));
    }

    private void requestCellUpdate() {
        updateCells = true;
        getSkinnable().requestLayout();

        // update the index of all children cells (RT-29849).
        // Note that we do this after the TableRow item has been updated,
        // rather than when the TableRow index has changed (as this will be
        // before the row has updated its item). This will result in the
        // issue highlighted in RT-33602, where the table cell had the correct
        // item whilst the row had the old item.
        final int newIndex = getSkinnable().getIndex();
        for (int i = 0, max = cells.size(); i &lt; max; i++) {
            cells.get(i).updateIndex(newIndex);
        }
    }

    private void recreateCells() {
        if (cellsMap != null) {
            Collection&lt;Reference&lt;R&gt;&gt; cells = cellsMap.values();
            Iterator&lt;Reference&lt;R&gt;&gt; cellsIter = cells.iterator();
            while (cellsIter.hasNext()) {
                Reference&lt;R&gt; cellRef = cellsIter.next();
                R cell = cellRef.get();
                if (cell != null) {
                    cell.updateIndex(-1);
                    cell.getSkin().dispose();
                    cell.setSkin(null);
                }
            }
            cellsMap.clear();
        }

        ObservableList&lt;? extends TableColumnBase/*&lt;T,?&gt;*/&gt; columns = getVisibleLeafColumns();

        cellsMap = new WeakHashMap&lt;&gt;(columns.size());
        fullRefreshCounter = DEFAULT_FULL_REFRESH_COUNTER;
        getChildren().clear();

        for (TableColumnBase col : columns) {
            if (cellsMap.containsKey(col)) {
                continue;
            }

            // create a TableCell for this column and store it in the cellsMap
            // for future use
            createCellAndCache(col);
        }
    }

    private R createCellAndCache(TableColumnBase&lt;T,?&gt; col) {
        // we must create a TableCell for this table column
        R cell = createCell(col);

        // and store this in our HashMap until needed
        cellsMap.put(col, new WeakReference&lt;&gt;(cell));

        return cell;
    }

    private void fadeOut(final Node node) {
        if (node.getOpacity() &lt; 1.0) return;

        if (! DO_ANIMATIONS) {
            node.setOpacity(0);
            return;
        }
<A NAME="21"></A>
        final FadeTransition fader = new FadeTransition(FADE_DURATION, node);
        fader.setToValue(0.0);
        <FONT color="#00ff00"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#21',2,'match49-top.html#21',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>fader.play();
    }

    private void fadeIn(final Node node) {
        if (node.getOpacity() &gt; 0.0) return;

        if (! DO_ANIMATIONS) {</B></FONT>
            node.setOpacity(1);
            return;
        }

        final FadeTransition fader = new FadeTransition(FADE_DURATION, node);
        fader.setToValue(1.0);
        fader.play();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/TextAreaSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.control.behavior.BehaviorBase;
import com.sun.javafx.scene.control.behavior.TextAreaBehavior;
import com.sun.javafx.scene.control.skin.Utils;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.beans.binding.BooleanBinding;
import javafx.beans.binding.DoubleBinding;
import javafx.beans.binding.IntegerBinding;
import javafx.beans.value.ObservableBooleanValue;
import javafx.beans.value.ObservableIntegerValue;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Bounds;
import javafx.geometry.Orientation;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.geometry.VPos;
import javafx.geometry.VerticalDirection;
import javafx.scene.AccessibleAttribute;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.control.Accordion;
import javafx.scene.control.Button;
import javafx.scene.control.Control;
<A NAME="16"></A>import javafx.scene.control.IndexRange;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
<FONT color="#3090c7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#16',2,'match49-top.html#16',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.Region;
import javafx.scene.shape.MoveTo;
import javafx.scene.shape.Path;
import javafx.scene.shape.PathElement;
import javafx.scene.text.Text;
import javafx.scene.text.HitInfo;
import javafx.util.Duration;

import java.util.List;

import static com.sun.javafx.PlatformUtil.isMac;
import static com.sun.javafx.PlatformUtil.isWindows;

/**
 * Default skin implementation for the {@link TextArea} control.
 *
 * @see TextArea
 * @since 9
 */
public class TextAreaSkin extends TextInputControlSkin&lt;TextArea&gt; {

    /**************************************************************************
     *
     * Static fields
     *
     **************************************************************************/

    /** A shared helper object, used only by downLines(). */
    private static final Path tmpCaretPath = new Path();



    /**************************************************************************
     *
     * Private fields
     *
     **************************************************************************/

    final private TextArea textArea;

    // *** NOTE: Multiple node mode is not yet fully implemented *** //
    private static final boolean USE_MULTIPLE_NODES = false;

    private final TextAreaBehavior behavior;

    private double computedMinWidth = Double.NEGATIVE_INFINITY;
    private double computedMinHeight = Double.NEGATIVE_INFINITY;
    private double computedPrefWidth = Double.NEGATIVE_INFINITY;
    private double computedPrefHeight = Double.NEGATIVE_INFINITY;
    private double widthForComputedPrefHeight = Double.NEGATIVE_INFINITY;
    private double characterWidth</B></FONT>;
    private double lineHeight;

    private ContentView contentView = new ContentView();
    private Group paragraphNodes = new Group();

    private Text promptNode;
    private ObservableBooleanValue usePromptText;

    private ObservableIntegerValue caretPosition;
    private Group selectionHighlightGroup = new Group();

    private ScrollPane scrollPane;
    private Bounds oldViewportBounds;

    private VerticalDirection scrollDirection = null;

    private Path characterBoundingPath = new Path();

    private Timeline scrollSelectionTimeline = new Timeline();
    private EventHandler&lt;ActionEvent&gt; scrollSelectionHandler = event -&gt; {
        switch (scrollDirection) {
            case UP: {
                // TODO Get previous offset
                break;
            }

            case DOWN: {
                // TODO Get next offset
                break;
            }
        }
    };

    private double pressX, pressY; // For dragging handles on embedded
    private boolean handlePressed;

    /**
     * Remembers horizontal position when traversing up / down.
     */
    double targetCaretX = -1;



    /**************************************************************************
     *
     * Constructors
     *
     **************************************************************************/

    /**
     * Creates a new TextAreaSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public TextAreaSkin(final TextArea control) {
        super(control);

        // install default input map for the text area control
        this.behavior = new TextAreaBehavior(control);
        this.behavior.setTextAreaSkin(this);
//        control.setInputMap(behavior.getInputMap());

        this.textArea = control;

        caretPosition = new IntegerBinding() {
            { bind(control.caretPositionProperty()); }
            @Override protected int computeValue() {
                return control.getCaretPosition();
            }
        };
        caretPosition.addListener((observable, oldValue, newValue) -&gt; {
            targetCaretX = -1;
            if (control.getWidth() &gt; 0) {
                setForwardBias(true);
            }
        });

        forwardBiasProperty().addListener(observable -&gt; {
            if (control.getWidth() &gt; 0) {
                updateTextNodeCaretPos(control.getCaretPosition());
            }
        });

//        setManaged(false);

        // Initialize content
        scrollPane = new ScrollPane();
        scrollPane.setFitToWidth(control.isWrapText());
        scrollPane.setContent(contentView);
        getChildren().add(scrollPane);

        getSkinnable().addEventFilter(ScrollEvent.ANY, event -&gt; {
            if (event.isDirect() &amp;&amp; handlePressed) {
                event.consume();
            }
        });

        // Add selection
        selectionHighlightGroup.setManaged(false);
        selectionHighlightGroup.setVisible(false);
        contentView.getChildren().add(selectionHighlightGroup);

        // Add content view
        paragraphNodes.setManaged(false);
        contentView.getChildren().add(paragraphNodes);

        // Add caret
        caretPath.setManaged(false);
        caretPath.setStrokeWidth(1);
        caretPath.fillProperty().bind(textFillProperty());
        caretPath.strokeProperty().bind(textFillProperty());
        // modifying visibility of the caret forces a layout-pass (RT-32373), so
        // instead we modify the opacity.
        caretPath.opacityProperty().bind(new DoubleBinding() {
            { bind(caretVisibleProperty()); }
            @Override protected double computeValue() {
                return caretVisibleProperty().get() ? 1.0 : 0.0;
            }
        });
        contentView.getChildren().add(caretPath);

        if (SHOW_HANDLES) {
            contentView.getChildren().addAll(caretHandle, selectionHandle1, selectionHandle2);
        }

        scrollPane.hvalueProperty().addListener((observable, oldValue, newValue) -&gt; {
            getSkinnable().setScrollLeft(newValue.doubleValue() * getScrollLeftMax());
        });

        scrollPane.vvalueProperty().addListener((observable, oldValue, newValue) -&gt; {
            getSkinnable().setScrollTop(newValue.doubleValue() * getScrollTopMax());
        });

        // Initialize the scroll selection timeline
        scrollSelectionTimeline.setCycleCount(Timeline.INDEFINITE);
        List&lt;KeyFrame&gt; scrollSelectionFrames = scrollSelectionTimeline.getKeyFrames();
        scrollSelectionFrames.clear();
        scrollSelectionFrames.add(new KeyFrame(Duration.millis(350), scrollSelectionHandler));

        // Add initial text content
        for (int i = 0, n = USE_MULTIPLE_NODES ? control.getParagraphs().size() : 1; i &lt; n; i++) {
            CharSequence paragraph = (n == 1) ? control.textProperty().getValueSafe() : control.getParagraphs().get(i);
            addParagraphNode(i, paragraph.toString());
        }

        control.selectionProperty().addListener((observable, oldValue, newValue) -&gt; {
            // TODO Why do we need two calls here?
            control.requestLayout();
            contentView.requestLayout();
        });

        control.wrapTextProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            scrollPane.setFitToWidth(newValue);
        });

        control.prefColumnCountProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updatePrefViewportWidth();
        });

        control.prefRowCountProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updatePrefViewportHeight();
        });

        updateFontMetrics();
        fontMetrics.addListener(valueModel -&gt; {
            updateFontMetrics();
        });

        contentView.paddingProperty().addListener(valueModel -&gt; {
            updatePrefViewportWidth();
            updatePrefViewportHeight();
        });

        scrollPane.viewportBoundsProperty().addListener(valueModel -&gt; {
            if (scrollPane.getViewportBounds() != null) {
                // ScrollPane creates a new Bounds instance for each
                // layout pass, so we need to check if the width/height
                // have really changed to avoid infinite layout requests.
                Bounds newViewportBounds = scrollPane.getViewportBounds();
                if (oldViewportBounds == null ||
                    oldViewportBounds.getWidth() != newViewportBounds.getWidth() ||
                    oldViewportBounds.getHeight() != newViewportBounds.getHeight()) {

                    invalidateMetrics();
                    oldViewportBounds = newViewportBounds;
                    contentView.requestLayout();
                }
            }
        });

        control.scrollTopProperty().addListener((observable, oldValue, newValue) -&gt; {
            double vValue = (newValue.doubleValue() &lt; getScrollTopMax())
                               ? (newValue.doubleValue() / getScrollTopMax()) : 1.0;
            scrollPane.setVvalue(vValue);
        });

        control.scrollLeftProperty().addListener((observable, oldValue, newValue) -&gt; {
            double hValue = (newValue.doubleValue() &lt; getScrollLeftMax())
                               ? (newValue.doubleValue() / getScrollLeftMax()) : 1.0;
            scrollPane.setHvalue(hValue);
        });

        if (USE_MULTIPLE_NODES) {
            control.getParagraphs().addListener((ListChangeListener.Change&lt;? extends CharSequence&gt; change) -&gt; {
                while (change.next()) {
                    int from = change.getFrom();
                    int to = change.getTo();
                    List&lt;? extends CharSequence&gt; removed = change.getRemoved();
                    if (from &lt; to) {

                        if (removed.isEmpty()) {
                            // This is an add
                            for (int i = from, n = to; i &lt; n; i++) {
                                addParagraphNode(i, change.getList().get(i).toString());
                            }
                        } else {
                            // This is an update
                            for (int i = from, n = to; i &lt; n; i++) {
                                Node node = paragraphNodes.getChildren().get(i);
                                Text paragraphNode = (Text) node;
                                paragraphNode.setText(change.getList().get(i).toString());
                            }
                        }
                    } else {
                        // This is a remove
                        paragraphNodes.getChildren().subList(from, from + removed.size()).clear();
                    }
                }
            });
        } else {
            control.textProperty().addListener(observable -&gt; {
                invalidateMetrics();
                ((Text)paragraphNodes.getChildren().get(0)).setText(control.textProperty().getValueSafe());
                contentView.requestLayout();
            });
        }

        usePromptText = new BooleanBinding() {
            { bind(control.textProperty(), control.promptTextProperty()); }
            @Override protected boolean computeValue() {
                String txt = control.getText();
                String promptTxt = control.getPromptText();
                return ((txt == null || txt.isEmpty()) &amp;&amp;
                        promptTxt != null &amp;&amp; !promptTxt.isEmpty());
            }
        };

        if (usePromptText.get()) {
            createPromptNode();
        }

        usePromptText.addListener(observable -&gt; {
            createPromptNode();
            control.requestLayout();
        });

        updateHighlightFill();
        updatePrefViewportWidth();
        updatePrefViewportHeight();
        if (control.isFocused()) setCaretAnimating(true);

        if (SHOW_HANDLES) {
            selectionHandle1.setRotate(180);

            EventHandler&lt;MouseEvent&gt; handlePressHandler = e -&gt; {
                pressX = e.getX();
                pressY = e.getY();
                handlePressed = true;
                e.consume();
            };

            EventHandler&lt;MouseEvent&gt; handleReleaseHandler = event -&gt; {
                handlePressed = false;
            };

            caretHandle.setOnMousePressed(handlePressHandler);
            selectionHandle1.setOnMousePressed(handlePressHandler);
            selectionHandle2.setOnMousePressed(handlePressHandler);

            caretHandle.setOnMouseReleased(handleReleaseHandler);
            selectionHandle1.setOnMouseReleased(handleReleaseHandler);
            selectionHandle2.setOnMouseReleased(handleReleaseHandler);

            caretHandle.setOnMouseDragged(e -&gt; {
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + caretHandle.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY - 6);
                HitInfo hit = textNode.hitTest(translateCaretPosition(p));
                positionCaret(hit, false);
                e.consume();
            });

            selectionHandle1.setOnMouseDragged(e -&gt; {
                TextArea control1 = getSkinnable();
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + selectionHandle1.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY + selectionHandle1.getHeight() + 5);
                HitInfo hit = textNode.hitTest(translateCaretPosition(p));
                if (control1.getAnchor() &lt; control1.getCaretPosition()) {
                    // Swap caret and anchor
                    control1.selectRange(control1.getCaretPosition(), control1.getAnchor());
                }
                int pos = hit.getCharIndex();
                if (pos &gt; 0) {
                    if (pos &gt;= control1.getAnchor()) {
                        pos = control1.getAnchor();
                    }
                }
                positionCaret(hit, true);
                e.consume();
            });

            selectionHandle2.setOnMouseDragged(e -&gt; {
                TextArea control1 = getSkinnable();
                Text textNode = getTextNode();
                Point2D tp = textNode.localToScene(0, 0);
                Point2D p = new Point2D(e.getSceneX() - tp.getX() - pressX + selectionHandle2.getWidth() / 2,
                                        e.getSceneY() - tp.getY() - pressY - 6);
                HitInfo hit = textNode.hitTest(translateCaretPosition(p));
                if (control1.getAnchor() &gt; control1.getCaretPosition()) {
                    // Swap caret and anchor
                    control1.selectRange(control1.getCaretPosition(), control1.getAnchor());
                }
                int pos = hit.getCharIndex();
                if (pos &gt; 0) {
                    if (pos &lt;= control1.getAnchor() + 1) {
                        pos = Math.min(control1.getAnchor() + 2, control1.getLength());
                    }
                    positionCaret(hit, true);
                }
                e.consume();
            });
        }
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override protected void invalidateMetrics() {
        computedMinWidth = Double.NEGATIVE_INFINITY;
        computedMinHeight = Double.NEGATIVE_INFINITY;
        computedPrefWidth = Double.NEGATIVE_INFINITY;
        computedPrefHeight = Double.NEGATIVE_INFINITY;
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(double contentX, double contentY, double contentWidth, double contentHeight) {
        scrollPane.resizeRelocate(contentX, contentY, contentWidth, contentHeight);
    }

    /** {@inheritDoc} */
    @Override protected void updateHighlightFill() {
        for (Node node : selectionHighlightGroup.getChildren()) {
            Path selectionHighlightPath = (Path)node;
            selectionHighlightPath.setFill(highlightFillProperty().get());
        }
    }

    // Public for behavior
    /**
     * Performs a hit test, mapping point to index in the content.
     *
     * @param x the x coordinate of the point.
     * @param y the y coordinate of the point.
     * @return a {@code HitInfo} object describing the index and forward bias.
     */
    public HitInfo getIndex(double x, double y) {
        // adjust the event to be in the same coordinate space as the
        // text content of the textInputControl
        Text textNode = getTextNode();
        Point2D p = new Point2D(x - textNode.getLayoutX(), y - getTextTranslateY());
        HitInfo hit = textNode.hitTest(translateCaretPosition(p));
        return hit;
    };

    /** {@inheritDoc} */
    @Override public void moveCaret(TextUnit unit, Direction dir, boolean select) {
        switch (unit) {
            case CHARACTER:
                switch (dir) {
                    case LEFT:
                    case RIGHT:
                        nextCharacterVisually(dir == Direction.RIGHT);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case LINE:
                switch (dir) {
                    case UP:
                        previousLine(select);
                        break;
                    case DOWN:
                        nextLine(select);
                        break;
                    case BEGINNING:
                        lineStart(select, select &amp;&amp; isMac());
                        break;
                    case END:
                        lineEnd(select, select &amp;&amp; isMac());
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case PAGE:
                switch (dir) {
                    case UP:
                        previousPage(select);
                        break;
                    case DOWN:
                        nextPage(select);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            case PARAGRAPH:
                switch (dir) {
                    case UP:
                        paragraphStart(true, select);
                        break;
                    case DOWN:
                        paragraphEnd(true, select);
                        break;
                    case BEGINNING:
                        paragraphStart(false, select);
                        break;
                    case END:
                        paragraphEnd(false, select);
                        break;
                    default:
                        throw new IllegalArgumentException(&quot;&quot;+dir);
                }
                break;

            default:
                throw new IllegalArgumentException(&quot;&quot;+unit);
        }
    }

    private void nextCharacterVisually(boolean moveRight) {
        if (isRTL()) {
            // Text node is mirrored.
            moveRight = !moveRight;
        }

        Text textNode = getTextNode();
        Bounds caretBounds = caretPath.getLayoutBounds();
        if (caretPath.getElements().size() == 4) {
            // The caret is split
            // TODO: Find a better way to get the primary caret position
            // instead of depending on the internal implementation.
            // See RT-25465.
            caretBounds = new Path(caretPath.getElements().get(0), caretPath.getElements().get(1)).getLayoutBounds();
        }
        double hitX = moveRight ? caretBounds.getMaxX() : caretBounds.getMinX();
        double hitY = (caretBounds.getMinY() + caretBounds.getMaxY()) / 2;
        HitInfo hit = textNode.hitTest(new Point2D(hitX, hitY));
        boolean leading = hit.isLeading();
        Path charShape = new Path(textNode.rangeShape(hit.getCharIndex(), hit.getCharIndex() + 1));
        if ((moveRight &amp;&amp; charShape.getLayoutBounds().getMaxX() &gt; caretBounds.getMaxX()) ||
                (!moveRight &amp;&amp; charShape.getLayoutBounds().getMinX() &lt; caretBounds.getMinX())) {
            leading = !leading;
            positionCaret(hit.getInsertionIndex(), leading, false, false);
        } else {
            // We're at beginning or end of line. Try moving up / down.
            int dot = textArea.getCaretPosition();
            targetCaretX = moveRight ? 0 : Double.MAX_VALUE;
            // TODO: Use Bidi sniffing instead of assuming right means forward here?
            downLines(moveRight ? 1 : -1, false, false);
            targetCaretX = -1;
            if (dot == textArea.getCaretPosition()) {
                if (moveRight) {
                    textArea.forward();
                } else {
                    textArea.backward();
                }
            }
        }
    }

    private void downLines(int nLines, boolean select, boolean extendSelection) {
        Text textNode = getTextNode();
        Bounds caretBounds = caretPath.getLayoutBounds();

        // The middle y coordinate of the the line we want to go to.
        double targetLineMidY = (caretBounds.getMinY() + caretBounds.getMaxY()) / 2 + nLines * lineHeight;
        if (targetLineMidY &lt; 0) {
            targetLineMidY = 0;
        }

        // The target x for the caret. This may have been set during a
        // previous call.
        double x = (targetCaretX &gt;= 0) ? targetCaretX : (caretBounds.getMaxX());

        // Find a text position for the target x,y.
        HitInfo hit = textNode.hitTest(translateCaretPosition(new Point2D(x, targetLineMidY)));
        int pos = hit.getCharIndex();

        // Save the old pos temporarily while testing the new one.
        int oldPos = textNode.getCaretPosition();
        boolean oldBias = textNode.isCaretBias();
        textNode.setCaretBias(hit.isLeading());
        textNode.setCaretPosition(pos);
        tmpCaretPath.getElements().clear();
        tmpCaretPath.getElements().addAll(textNode.getCaretShape());
        tmpCaretPath.setLayoutX(textNode.getLayoutX());
        tmpCaretPath.setLayoutY(textNode.getLayoutY());
        Bounds tmpCaretBounds = tmpCaretPath.getLayoutBounds();
        // The y for the middle of the row we found.
        double foundLineMidY = (tmpCaretBounds.getMinY() + tmpCaretBounds.getMaxY()) / 2;
        textNode.setCaretBias(oldBias);
        textNode.setCaretPosition(oldPos);

        // Test if the found line is in the correct direction and move
        // the caret.
        if (nLines == 0 ||
                (nLines &gt; 0 &amp;&amp; foundLineMidY &gt; caretBounds.getMaxY()) ||
                (nLines &lt; 0 &amp;&amp; foundLineMidY &lt; caretBounds.getMinY())) {

            positionCaret(hit.getInsertionIndex(), hit.isLeading(), select, extendSelection);
            targetCaretX = x;
        }
    }

    private void previousLine(boolean select) {
        downLines(-1, select, false);
    }

    private void nextLine(boolean select) {
        downLines(1, select, false);
    }

    private void previousPage(boolean select) {
        downLines(-(int)(scrollPane.getViewportBounds().getHeight() / lineHeight),
                select, false);
    }

    private void nextPage(boolean select) {
        downLines((int)(scrollPane.getViewportBounds().getHeight() / lineHeight),
                select, false);
    }

    private void lineStart(boolean select, boolean extendSelection) {
        targetCaretX = 0;
        downLines(0, select, extendSelection);
        targetCaretX = -1;
    }

    private void lineEnd(boolean select, boolean extendSelection) {
        targetCaretX = Double.MAX_VALUE;
        downLines(0, select, extendSelection);
        targetCaretX = -1;
    }


    private void paragraphStart(boolean previousIfAtStart, boolean select) {
        TextArea textArea = getSkinnable();
        String text = textArea.textProperty().getValueSafe();
        int pos = textArea.getCaretPosition();

        if (pos &gt; 0) {
            if (previousIfAtStart &amp;&amp; text.codePointAt(pos-1) == 0x0a) {
                // We are at the beginning of a paragraph.
                // Back up to the previous paragraph.
                pos--;
            }
            // Back up to the beginning of this paragraph
            while (pos &gt; 0 &amp;&amp; text.codePointAt(pos-1) != 0x0a) {
                pos--;
            }
            if (select) {
                textArea.selectPositionCaret(pos);
            } else {
                textArea.positionCaret(pos);
                setForwardBias(true);
            }
        }
    }

    private void paragraphEnd(boolean goPastInitialNewline, boolean select) {
        TextArea textArea = getSkinnable();
        String text = textArea.textProperty().getValueSafe();
        int pos = textArea.getCaretPosition();
        int len = text.length();
        boolean wentPastInitialNewline = false;
        boolean goPastTrailingNewline = isWindows();

        if (pos &lt; len) {
            if (goPastInitialNewline &amp;&amp; text.codePointAt(pos) == 0x0a) {
                // We are at the end of a paragraph, start by moving to the
                // next paragraph.
                pos++;
                wentPastInitialNewline = true;
            }
            if (!(goPastTrailingNewline &amp;&amp; wentPastInitialNewline)) {
                // Go to the end of this paragraph
                while (pos &lt; len &amp;&amp; text.codePointAt(pos) != 0x0a) {
                    pos++;
                }
                if (goPastTrailingNewline &amp;&amp; pos &lt; len) {
                    // We are at the end of a paragraph, finish by moving to
                    // the beginning of the next paragraph (Windows behavior).
                    pos++;
                }
            }
            if (select) {
                textArea.selectPositionCaret(pos);
            } else {
                textArea.positionCaret(pos);
            }
        }
    }

    /** {@inheritDoc} */
    @Override protected PathElement[] getUnderlineShape(int start, int end) {
        int pStart = 0;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                return p.underlineShape(start - pStart, end - pStart);
            }
            pStart = pEnd + 1;
        }
        return null;
    }

    /** {@inheritDoc} */
    @Override protected PathElement[] getRangeShape(int start, int end) {
        int pStart = 0;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                return p.rangeShape(start - pStart, end - pStart);
            }
            pStart = pEnd + 1;
        }
        return null;
    }

    /** {@inheritDoc} */
    @Override protected void addHighlight(List&lt;? extends Node&gt; nodes, int start) {
        int pStart = 0;
        Text paragraphNode = null;
        for (Node node : paragraphNodes.getChildren()) {
            Text p = (Text)node;
            int pEnd = pStart + p.textProperty().getValueSafe().length();
            if (pEnd &gt;= start) {
                paragraphNode = p;
                break;
            }
            pStart = pEnd + 1;
        }

        if (paragraphNode != null) {
            for (Node node : nodes) {
                node.setLayoutX(paragraphNode.getLayoutX());
                node.setLayoutY(paragraphNode.getLayoutY());
            }
        }
        contentView.getChildren().addAll(nodes);
    }

    /** {@inheritDoc} */
    @Override protected void removeHighlight(List&lt;? extends Node&gt; nodes) {
        contentView.getChildren().removeAll(nodes);
    }

    /** {@inheritDoc} */
    @Override public Point2D getMenuPosition() {
        contentView.layoutChildren();
        Point2D p = super.getMenuPosition();
        if (p != null) {
            p = new Point2D(Math.max(0, p.getX() - contentView.snappedLeftInset() - getSkinnable().getScrollLeft()),
                    Math.max(0, p.getY() - contentView.snappedTopInset() - getSkinnable().getScrollTop()));
        }
        return p;
    }

    // Public for FXVKSkin
    /**
     * Gets the {@code Bounds} of the caret of the skinned {@code TextArea}.
     * @return the {@code Bounds} of the caret shape, relative to the {@code TextArea}.
     */
    public Bounds getCaretBounds() {
        return getSkinnable().sceneToLocal(caretPath.localToScene(caretPath.getBoundsInLocal()));
    }

    /** {@inheritDoc} */
    @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case LINE_FOR_OFFSET:
            case LINE_START:
            case LINE_END:
            case BOUNDS_FOR_RANGE:
            case OFFSET_AT_POINT:
                Text text = getTextNode();
                return text.queryAccessibleAttribute(attribute, parameters);
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }

        // TODO Unregister listeners on text editor, paragraph list
        throw new UnsupportedOperationException();
    }

    /** {@inheritDoc} */
    @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
        Text firstParagraph = (Text) paragraphNodes.getChildren().get(0);
        return Utils.getAscent(getSkinnable().getFont(), firstParagraph.getBoundsType())
                + contentView.snappedTopInset() + textArea.snappedTopInset();
    }

    private char getCharacter(int index) {
        int n = paragraphNodes.getChildren().size();

        int paragraphIndex = 0;
        int offset = index;

        String paragraph = null;
        while (paragraphIndex &lt; n) {
            Text paragraphNode = (Text)paragraphNodes.getChildren().get(paragraphIndex);
            paragraph = paragraphNode.getText();
            int count = paragraph.length() + 1;

            if (offset &lt; count) {
                break;
            }

            offset -= count;
            paragraphIndex++;
        }

        return offset == paragraph.length() ? '\n' : paragraph.charAt(offset);
    }

    /** {@inheritDoc} */
    @Override protected int getInsertionPoint(double x, double y) {
        TextArea textArea = getSkinnable();

        int n = paragraphNodes.getChildren().size();
        int index = -1;

        if (n &gt; 0) {
            if (y &lt; contentView.snappedTopInset()) {
                // Select the character at x in the first row
                Text paragraphNode = (Text)paragraphNodes.getChildren().get(0);
                index = getNextInsertionPoint(paragraphNode, x, -1, VerticalDirection.DOWN);
            } else if (y &gt; contentView.snappedTopInset() + contentView.getHeight()) {
                // Select the character at x in the last row
                int lastParagraphIndex = n - 1;
                Text lastParagraphView = (Text)paragraphNodes.getChildren().get(lastParagraphIndex);

                index = getNextInsertionPoint(lastParagraphView, x, -1, VerticalDirection.UP)
                        + (textArea.getLength() - lastParagraphView.getText().length());
            } else {
                // Select the character at x in the row at y
                int paragraphOffset = 0;
                for (int i = 0; i &lt; n; i++) {
                    Text paragraphNode = (Text)paragraphNodes.getChildren().get(i);

                    Bounds bounds = paragraphNode.getBoundsInLocal();
                    double paragraphViewY = paragraphNode.getLayoutY() + bounds.getMinY();
                    if (y &gt;= paragraphViewY
                            &amp;&amp; y &lt; paragraphViewY + paragraphNode.getBoundsInLocal().getHeight()) {
                        index = getInsertionPoint(paragraphNode,
                                x - paragraphNode.getLayoutX(),
                                y - paragraphNode.getLayoutY()) + paragraphOffset;
                        break;
                    }

                    paragraphOffset += paragraphNode.getText().length() + 1;
                }
            }
        }

        return index;
    }

    // Public for behavior
    /**
     * Moves the caret to the specified position.
     *
     * @param hit the new position and forward bias of the caret.
     * @param select whether to extend selection to the new position.
     */
    public void positionCaret(HitInfo hit, boolean select) {
        positionCaret(hit.getInsertionIndex(), hit.isLeading(), select, false);
    }

    private void positionCaret(int pos, boolean leading, boolean select, boolean extendSelection) {
        boolean isNewLine =
                (pos &gt; 0 &amp;&amp;
                        pos &lt;= getSkinnable().getLength() &amp;&amp;
                        getSkinnable().getText().codePointAt(pos-1) == 0x0a);

        // special handling for a new line
        if (!leading &amp;&amp; isNewLine) {
            leading = true;
            pos -= 1;
        }

        if (select) {
            if (extendSelection) {
                getSkinnable().extendSelection(pos);
            } else {
                getSkinnable().selectPositionCaret(pos);
            }
        } else {
            getSkinnable().positionCaret(pos);
        }

        setForwardBias(leading);
    }

    /** {@inheritDoc} */
    @Override public Rectangle2D getCharacterBounds(int index) {
        TextArea textArea = getSkinnable();

        int paragraphIndex = paragraphNodes.getChildren().size();
        int paragraphOffset = textArea.getLength() + 1;

        Text paragraphNode = null;
        do {
            paragraphNode = (Text)paragraphNodes.getChildren().get(--paragraphIndex);
            paragraphOffset -= paragraphNode.getText().length() + 1;
        } while (index &lt; paragraphOffset);

        int characterIndex = index - paragraphOffset;
        boolean terminator = false;

        if (characterIndex == paragraphNode.getText().length()) {
            characterIndex--;
            terminator = true;
        }

        characterBoundingPath.getElements().clear();
        characterBoundingPath.getElements().addAll(paragraphNode.rangeShape(characterIndex, characterIndex + 1));
        characterBoundingPath.setLayoutX(paragraphNode.getLayoutX());
        characterBoundingPath.setLayoutY(paragraphNode.getLayoutY());

        Bounds bounds = characterBoundingPath.getBoundsInLocal();

        double x = bounds.getMinX() + paragraphNode.getLayoutX() - textArea.getScrollLeft();
        double y = bounds.getMinY() + paragraphNode.getLayoutY() - textArea.getScrollTop();

        // Sometimes the bounds is empty, in which case we must ignore the width/height
        double width = bounds.isEmpty() ? 0 : bounds.getWidth();
        double height = bounds.isEmpty() ? 0 : bounds.getHeight();

        if (terminator) {
            x += width;
            width = 0;
        }

        return new Rectangle2D(x, y, width, height);
    }

    /** {@inheritDoc} */
    @Override protected void scrollCharacterToVisible(final int index) {
        // TODO We queue a callback because when characters are added or
        // removed the bounds are not immediately updated; is this really
        // necessary?

        Platform.runLater(() -&gt; {
            if (getSkinnable().getLength() == 0) {
                return;
            }
            Rectangle2D characterBounds = getCharacterBounds(index);
            scrollBoundsToVisible(characterBounds);
        });
    }



    /**************************************************************************
     *
     * Private implementation
     *
     **************************************************************************/

    TextAreaBehavior getBehavior() {
        return behavior;
    }

    private void createPromptNode() {
        if (promptNode == null &amp;&amp; usePromptText.get()) {
            promptNode = new Text();
            contentView.getChildren().add(0, promptNode);
            promptNode.setManaged(false);
            promptNode.getStyleClass().add(&quot;text&quot;);
            promptNode.visibleProperty().bind(usePromptText);
            promptNode.fontProperty().bind(getSkinnable().fontProperty());
            promptNode.textProperty().bind(getSkinnable().promptTextProperty());
            promptNode.fillProperty().bind(promptTextFillProperty());
        }
    }

    private void addParagraphNode(int i, String string) {
        final TextArea textArea = getSkinnable();
        Text paragraphNode = new Text(string);
        paragraphNode.setTextOrigin(VPos.TOP);
        paragraphNode.setManaged(false);
        paragraphNode.getStyleClass().add(&quot;text&quot;);
        paragraphNode.boundsTypeProperty().addListener((observable, oldValue, newValue) -&gt; {
            invalidateMetrics();
            updateFontMetrics();
        });
        paragraphNodes.getChildren().add(i, paragraphNode);

        paragraphNode.fontProperty().bind(textArea.fontProperty());
        paragraphNode.fillProperty().bind(textFillProperty());
        paragraphNode.selectionFillProperty().bind(highlightTextFillProperty());
    }

    private double getScrollTopMax() {
        return Math.max(0, contentView.getHeight() - scrollPane.getViewportBounds().getHeight());
    }

    private double getScrollLeftMax() {
        return Math.max(0, contentView.getWidth() - scrollPane.getViewportBounds().getWidth());
    }

    private int getInsertionPoint(Text paragraphNode, double x, double y) {
        HitInfo hitInfo = paragraphNode.hitTest(new Point2D(x, y));
        return hitInfo.getInsertionIndex();
    }

    private int getNextInsertionPoint(Text paragraphNode, double x, int from,
        VerticalDirection scrollDirection) {
        // TODO
        return 0;
    }

    private void scrollCaretToVisible() {
        TextArea textArea = getSkinnable();
        Bounds bounds = caretPath.getLayoutBounds();
        double x = bounds.getMinX() - textArea.getScrollLeft();
        double y = bounds.getMinY() - textArea.getScrollTop();
        double w = bounds.getWidth();
        double h = bounds.getHeight();

        if (SHOW_HANDLES) {
            if (caretHandle.isVisible()) {
                h += caretHandle.getHeight();
            } else if (selectionHandle1.isVisible() &amp;&amp; selectionHandle2.isVisible()) {
                x -= selectionHandle1.getWidth() / 2;
                y -= selectionHandle1.getHeight();
                w += selectionHandle1.getWidth() / 2 + selectionHandle2.getWidth() / 2;
                h += selectionHandle1.getHeight() + selectionHandle2.getHeight();
            }
        }

        if (w &gt; 0 &amp;&amp; h &gt; 0) {
            scrollBoundsToVisible(new Rectangle2D(x, y, w, h));
        }
    }

    private void scrollBoundsToVisible(Rectangle2D bounds) {
        TextArea textArea = getSkinnable();
        Bounds viewportBounds = scrollPane.getViewportBounds();

        double viewportWidth = viewportBounds.getWidth();
        double viewportHeight = viewportBounds.getHeight();
        double scrollTop = textArea.getScrollTop();
        double scrollLeft = textArea.getScrollLeft();
        double slop = 6.0;

        if (bounds.getMinY() &lt; 0) {
            double y = scrollTop + bounds.getMinY();
            if (y &lt;= contentView.snappedTopInset()) {
                y = 0;
            }
            textArea.setScrollTop(y);
        } else if (contentView.snappedTopInset() + bounds.getMaxY() &gt; viewportHeight) {
            double y = scrollTop + contentView.snappedTopInset() + bounds.getMaxY() - viewportHeight;
            if (y &gt;= getScrollTopMax() - contentView.snappedBottomInset()) {
                y = getScrollTopMax();
            }
            textArea.setScrollTop(y);
        }


        if (bounds.getMinX() &lt; 0) {
            double x = scrollLeft + bounds.getMinX() - slop;
            if (x &lt;= contentView.snappedLeftInset() + slop) {
                x = 0;
            }
            textArea.setScrollLeft(x);
        } else if (contentView.snappedLeftInset() + bounds.getMaxX() &gt; viewportWidth) {
            double x = scrollLeft + contentView.snappedLeftInset() + bounds.getMaxX() - viewportWidth + slop;
            if (x &gt;= getScrollLeftMax() - contentView.snappedRightInset() - slop) {
                x = getScrollLeftMax();
            }
            textArea.setScrollLeft(x);
        }
    }

    private void updatePrefViewportWidth() {
        int columnCount = getSkinnable().getPrefColumnCount();
        scrollPane.setPrefViewportWidth(columnCount * characterWidth + contentView.snappedLeftInset() + contentView.snappedRightInset());
        scrollPane.setMinViewportWidth(characterWidth + contentView.snappedLeftInset() + contentView.snappedRightInset());
    }

    private void updatePrefViewportHeight() {
        int rowCount = getSkinnable().getPrefRowCount();
        scrollPane.setPrefViewportHeight(rowCount * lineHeight + contentView.snappedTopInset() + contentView.snappedBottomInset());
        scrollPane.setMinViewportHeight(lineHeight + contentView.snappedTopInset() + contentView.snappedBottomInset());
    }

    private void updateFontMetrics() {
        Text firstParagraph = (Text)paragraphNodes.getChildren().get(0);
        lineHeight = Utils.getLineHeight(getSkinnable().getFont(), firstParagraph.getBoundsType());
        characterWidth = fontMetrics.get().getCharWidth('W');
    }

    private double getTextTranslateX() {
        return contentView.snappedLeftInset();
    }

    private double getTextTranslateY() {
        return contentView.snappedTopInset();
    }

    private double getTextLeft() {
        return 0;
    }

    private Point2D translateCaretPosition(Point2D p) {
        return p;
    }

    private Text getTextNode() {
        if (USE_MULTIPLE_NODES) {
            throw new IllegalArgumentException(&quot;Multiple node traversal is not yet implemented.&quot;);
        }
        return (Text)paragraphNodes.getChildren().get(0);
    }

    private void updateTextNodeCaretPos(int pos) {
        Text textNode = getTextNode();
        if (isForwardBias()) {
            textNode.setCaretPosition(pos);
        } else {
            textNode.setCaretPosition(pos - 1);
        }
        textNode.caretBiasProperty().set(isForwardBias());
    }



    /**************************************************************************
     *
     * Support classes
     *
     **************************************************************************/

    private class ContentView extends Region {
        {
            getStyleClass().add(&quot;content&quot;);

            addEventHandler(MouseEvent.MOUSE_PRESSED, event -&gt; {
                behavior.mousePressed(event);
                event.consume();
            });

            addEventHandler(MouseEvent.MOUSE_RELEASED, event -&gt; {
                behavior.mouseReleased(event);
                event.consume();
            });

            addEventHandler(MouseEvent.MOUSE_DRAGGED, event -&gt; {
                behavior.mouseDragged(event);
                event.consume();
            });
        }

        @Override protected ObservableList&lt;Node&gt; getChildren() {
            return super.getChildren();
        }

        @Override public Orientation getContentBias() {
            return Orientation.HORIZONTAL;
        }

        @Override protected double computePrefWidth(double height) {
            if (computedPrefWidth &lt; 0) {
                double prefWidth = 0;

                for (Node node : paragraphNodes.getChildren()) {
                    Text paragraphNode = (Text)node;
                    prefWidth = Math.max(prefWidth,
                            Utils.computeTextWidth(paragraphNode.getFont(),
                                    paragraphNode.getText(), 0));
                }

                prefWidth += snappedLeftInset() + snappedRightInset();

                Bounds viewPortBounds = scrollPane.getViewportBounds();
                computedPrefWidth = Math.max(prefWidth, (viewPortBounds != null) ? viewPortBounds.getWidth() : 0);
            }
            return computedPrefWidth;
        }

        @Override protected double computePrefHeight(double width) {
            if (width != widthForComputedPrefHeight) {
                invalidateMetrics();
                widthForComputedPrefHeight = width;
            }

            if (computedPrefHeight &lt; 0) {
                double wrappingWidth;
                if (width == -1) {
                    wrappingWidth = 0;
                } else {
                    wrappingWidth = Math.max(width - (snappedLeftInset() + snappedRightInset()), 0);
                }

                double prefHeight = 0;

                for (Node node : paragraphNodes.getChildren()) {
                    Text paragraphNode = (Text)node;
                    prefHeight += Utils.computeTextHeight(
                            paragraphNode.getFont(),
                            paragraphNode.getText(),
                            wrappingWidth,
                            paragraphNode.getBoundsType());
                }

                prefHeight += snappedTopInset() + snappedBottomInset();

                Bounds viewPortBounds = scrollPane.getViewportBounds();
                computedPrefHeight = Math.max(prefHeight, (viewPortBounds != null) ? viewPortBounds.getHeight() : 0);
            }
            return computedPrefHeight;
        }

        @Override protected double computeMinWidth(double height) {
            if (computedMinWidth &lt; 0) {
                double hInsets = snappedLeftInset() + snappedRightInset();
                computedMinWidth = Math.min(characterWidth + hInsets, computePrefWidth(height));
            }
            return computedMinWidth;
        }

        @Override protected double computeMinHeight(double width) {
            if (computedMinHeight &lt; 0) {
                double vInsets = snappedTopInset() + snappedBottomInset();
                computedMinHeight = Math.min(lineHeight + vInsets, computePrefHeight(width));
            }
            return computedMinHeight;
        }

        @Override public void layoutChildren() {
            TextArea textArea = getSkinnable();
            double width = getWidth();

            // Lay out paragraphs
            final double topPadding = snappedTopInset();
            final double leftPadding = snappedLeftInset();

            double wrappingWidth = Math.max(width - (leftPadding + snappedRightInset()), 0);

            double y = topPadding;

            final List&lt;Node&gt; paragraphNodesChildren = paragraphNodes.getChildren();

            for (int i = 0; i &lt; paragraphNodesChildren.size(); i++) {
                Node node = paragraphNodesChildren.get(i);
                Text paragraphNode = (Text)node;
                paragraphNode.setWrappingWidth(wrappingWidth);

                Bounds bounds = paragraphNode.getBoundsInLocal();
                paragraphNode.setLayoutX(leftPadding);
                paragraphNode.setLayoutY(y);

                y += bounds.getHeight();
            }

            if (promptNode != null) {
                promptNode.setLayoutX(leftPadding);
                promptNode.setLayoutY(topPadding + promptNode.getBaselineOffset());
                promptNode.setWrappingWidth(wrappingWidth);
            }

            // Update the selection
            IndexRange selection = textArea.getSelection();
            Bounds oldCaretBounds = caretPath.getBoundsInParent();

            selectionHighlightGroup.getChildren().clear();

            int caretPos = textArea.getCaretPosition();
            int anchorPos = textArea.getAnchor();

            if (SHOW_HANDLES) {
                // Install and resize the handles for caret and anchor.
                if (selection.getLength() &gt; 0) {
                    selectionHandle1.resize(selectionHandle1.prefWidth(-1),
                            selectionHandle1.prefHeight(-1));
                    selectionHandle2.resize(selectionHandle2.prefWidth(-1),
                            selectionHandle2.prefHeight(-1));
                } else {
                    caretHandle.resize(caretHandle.prefWidth(-1),
                            caretHandle.prefHeight(-1));
                }

                // Position the handle for the anchor. This could be handle1 or handle2.
                // Do this before positioning the actual caret.
                if (selection.getLength() &gt; 0) {
                    int paragraphIndex = paragraphNodesChildren.size();
                    int paragraphOffset = textArea.getLength() + 1;
                    Text paragraphNode = null;
                    do {
                        paragraphNode = (Text)paragraphNodesChildren.get(--paragraphIndex);
                        paragraphOffset -= paragraphNode.getText().length() + 1;
                    } while (anchorPos &lt; paragraphOffset);

                    updateTextNodeCaretPos(anchorPos - paragraphOffset);
                    caretPath.getElements().clear();
                    caretPath.getElements().addAll(paragraphNode.getCaretShape());
                    caretPath.setLayoutX(paragraphNode.getLayoutX());
                    caretPath.setLayoutY(paragraphNode.getLayoutY());

                    Bounds b = caretPath.getBoundsInParent();
                    if (caretPos &lt; anchorPos) {
                        selectionHandle2.setLayoutX(b.getMinX() - selectionHandle2.getWidth() / 2);
                        selectionHandle2.setLayoutY(b.getMaxY() - 1);
                    } else {
                        selectionHandle1.setLayoutX(b.getMinX() - selectionHandle1.getWidth() / 2);
                        selectionHandle1.setLayoutY(b.getMinY() - selectionHandle1.getHeight() + 1);
                    }
                }
            }

            {
                // Position caret
                int paragraphIndex = paragraphNodesChildren.size();
                int paragraphOffset = textArea.getLength() + 1;

                Text paragraphNode = null;
                do {
                    paragraphNode = (Text)paragraphNodesChildren.get(--paragraphIndex);
                    paragraphOffset -= paragraphNode.getText().length() + 1;
                } while (caretPos &lt; paragraphOffset);

                updateTextNodeCaretPos(caretPos - paragraphOffset);

                caretPath.getElements().clear();
                caretPath.getElements().addAll(paragraphNode.getCaretShape());

                caretPath.setLayoutX(paragraphNode.getLayoutX());

                // TODO: Remove this temporary workaround for RT-27533
                paragraphNode.setLayoutX(2 * paragraphNode.getLayoutX() - paragraphNode.getBoundsInParent().getMinX());

                caretPath.setLayoutY(paragraphNode.getLayoutY());
                if (oldCaretBounds == null || !oldCaretBounds.equals(caretPath.getBoundsInParent())) {
                    scrollCaretToVisible();
                }
            }

            // Update selection fg and bg
            int start = selection.getStart();
            int end = selection.getEnd();
            for (int i = 0, max = paragraphNodesChildren.size(); i &lt; max; i++) {
                Node paragraphNode = paragraphNodesChildren.get(i);
                Text textNode = (Text)paragraphNode;
                int paragraphLength = textNode.getText().length() + 1;
                if (end &gt; start &amp;&amp; start &lt; paragraphLength) {
                    textNode.setSelectionStart(start);
                    textNode.setSelectionEnd(Math.min(end, paragraphLength));

                    Path selectionHighlightPath = new Path();
                    selectionHighlightPath.setManaged(false);
                    selectionHighlightPath.setStroke(null);
                    PathElement[] selectionShape = textNode.getSelectionShape();
                    if (selectionShape != null) {
                        selectionHighlightPath.getElements().addAll(selectionShape);
                    }
                    selectionHighlightGroup.getChildren().add(selectionHighlightPath);
                    selectionHighlightGroup.setVisible(true);
                    selectionHighlightPath.setLayoutX(textNode.getLayoutX());
                    selectionHighlightPath.setLayoutY(textNode.getLayoutY());
                    updateHighlightFill();
                } else {
                    textNode.setSelectionStart(-1);
                    textNode.setSelectionEnd(-1);
                    selectionHighlightGroup.setVisible(false);
                }
                start = Math.max(0, start - paragraphLength);
                end   = Math.max(0, end   - paragraphLength);
            }

            if (SHOW_HANDLES) {
                // Position handle for the caret. This could be handle1 or handle2 when
                // a selection is active.
                Bounds b = caretPath.getBoundsInParent();
                if (selection.getLength() &gt; 0) {
                    if (caretPos &lt; anchorPos) {
                        selectionHandle1.setLayoutX(b.getMinX() - selectionHandle1.getWidth() / 2);
                        selectionHandle1.setLayoutY(b.getMinY() - selectionHandle1.getHeight() + 1);
                    } else {
                        selectionHandle2.setLayoutX(b.getMinX() - selectionHandle2.getWidth() / 2);
                        selectionHandle2.setLayoutY(b.getMaxY() - 1);
                    }
                } else {
                    caretHandle.setLayoutX(b.getMinX() - caretHandle.getWidth() / 2 + 1);
                    caretHandle.setLayoutY(b.getMaxY());
                }
            }

            if (scrollPane.getPrefViewportWidth() == 0
                    || scrollPane.getPrefViewportHeight() == 0) {
                updatePrefViewportWidth();
                updatePrefViewportHeight();
                if (getParent() != null &amp;&amp; scrollPane.getPrefViewportWidth() &gt; 0
                        || scrollPane.getPrefViewportHeight() &gt; 0) {
                    // Force layout of viewRect in ScrollPaneSkin
                    getParent().requestLayout();
                }
            }

            // RT-36454: Fit to width/height only if smaller than viewport.
            // That is, grow to fit but don't shrink to fit.
            Bounds viewportBounds = scrollPane.getViewportBounds();
            boolean wasFitToWidth = scrollPane.isFitToWidth();
            boolean wasFitToHeight = scrollPane.isFitToHeight();
            boolean setFitToWidth = textArea.isWrapText() || computePrefWidth(-1) &lt;= viewportBounds.getWidth();
            boolean setFitToHeight = computePrefHeight(width) &lt;= viewportBounds.getHeight();
            if (wasFitToWidth != setFitToWidth || wasFitToHeight != setFitToHeight) {
                Platform.runLater(() -&gt; {
                    scrollPane.setFitToWidth(setFitToWidth);
                    scrollPane.setFitToHeight(setFitToHeight);
                });
                getParent().requestLayout();
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.controls/javafx/scene/control/skin/ToolBarSkin.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.control.skin;

import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.ParentHelper;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.sun.javafx.scene.control.behavior.BehaviorBase;
import com.sun.javafx.scene.traversal.Algorithm;
import com.sun.javafx.scene.traversal.ParentTraversalEngine;
import com.sun.javafx.scene.traversal.TraversalContext;

import javafx.beans.property.ObjectProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.value.WritableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.geometry.HPos;
import javafx.geometry.Orientation;
import javafx.geometry.Pos;
import javafx.geometry.Side;
import javafx.geometry.VPos;
import javafx.scene.AccessibleAction;
import javafx.scene.AccessibleAttribute;
import javafx.scene.AccessibleRole;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Control;
import javafx.scene.control.MenuItem;
import javafx.scene.control.CustomMenuItem;
import javafx.scene.control.Separator;
import javafx.scene.control.SeparatorMenuItem;
import javafx.scene.control.SkinBase;
import javafx.scene.control.ToolBar;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.css.CssMetaData;

import javafx.css.converter.EnumConverter;
import javafx.css.converter.SizeConverter;
import com.sun.javafx.scene.control.behavior.ToolBarBehavior;
import com.sun.javafx.scene.traversal.Direction;

import javafx.css.Styleable;

import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;

/**
 * Default skin implementation for the {@link ToolBar} control.
 *
 * @see ToolBar
 * @since 9
 */
public class ToolBarSkin extends SkinBase&lt;ToolBar&gt; {

    /***************************************************************************
     *                                                                         *
     * Private fields                                                          *
     *                                                                         *
     **************************************************************************/

    private Pane box;
    private ToolBarOverflowMenu overflowMenu;
    private boolean overflow = false;
    private double previousWidth = 0;
    private double previousHeight = 0;
    private double savedPrefWidth = 0;
    private double savedPrefHeight = 0;
    private ObservableList&lt;MenuItem&gt; overflowMenuItems;
    private boolean needsUpdate = false;
    private final ParentTraversalEngine engine;
    private final BehaviorBase&lt;ToolBar&gt; behavior;



    /***************************************************************************
     *                                                                         *
     * Constructors                                                            *
     *                                                                         *
     **************************************************************************/

    /**
     * Creates a new ToolBarSkin instance, installing the necessary child
     * nodes into the Control {@link Control#getChildren() children} list, as
     * well as the necessary input mappings for handling key, mouse, etc events.
     *
     * @param control The control that this skin should be installed onto.
     */
    public ToolBarSkin(ToolBar control) {
        super(control);

        // install default input map for the ToolBar control
        behavior = new ToolBarBehavior(control);
//        control.setInputMap(behavior.getInputMap());

        overflowMenuItems = FXCollections.observableArrayList();
        initialize();
        registerChangeListener(control.orientationProperty(), e -&gt; initialize());

        engine = new ParentTraversalEngine(getSkinnable(), new Algorithm() {

            private Node selectPrev(int from, TraversalContext context) {
                for (int i = from; i &gt;= 0; --i) {
                    Node n = box.getChildren().get(i);
                    if (n.isDisabled() || !NodeHelper.isTreeShowing(n)) continue;
                    if (n instanceof Parent) {
                        Node selected = context.selectLastInParent((Parent)n);
                        if (selected != null) return selected;
                    }
                    if (n.isFocusTraversable() ) {
                        return n;
                    }
                }
                return null;
            }

            private Node selectNext(int from, TraversalContext context) {
                for (int i = from, max = box.getChildren().size(); i &lt; max; ++i) {
                    Node n = box.getChildren().get(i);
                    if (n.isDisabled() || !NodeHelper.isTreeShowing(n)) continue;
                    if (n.isFocusTraversable()) {
                        return n;
                    }
                    if (n instanceof Parent) {
                        Node selected = context.selectFirstInParent((Parent)n);
                        if (selected != null) return selected;
                    }
                }
                return null;
            }

            @Override
            public Node select(Node owner, Direction dir, TraversalContext context) {
                final ObservableList&lt;Node&gt; boxChildren = box.getChildren();
                if (owner == overflowMenu) {
                    if (dir.isForward()) {
                        return null;
                    } else {
                        Node selected = selectPrev(boxChildren.size() - 1, context);
                        if (selected != null) return selected;
                    }
                }

                int idx = boxChildren.indexOf(owner);

                if (idx &lt; 0) {
                    // The current focus owner is a child of some Toolbar's item
                    Parent item = owner.getParent();
                    while (!boxChildren.contains(item)) {
                        item = item.getParent();
                    }
                    Node selected = context.selectInSubtree(item, owner, dir);
                    if (selected != null) return selected;
                    idx = boxChildren.indexOf(item);
                    if (dir == Direction.NEXT) dir = Direction.NEXT_IN_LINE;
                }

                if (idx &gt;= 0) {
                    if (dir.isForward()) {
                        Node selected = selectNext(idx + 1, context);
                        if (selected != null) return selected;
                        if (overflow) {
                            overflowMenu.requestFocus();
                            return overflowMenu;
                        }
                    } else {
                        Node selected = selectPrev(idx - 1, context);
                        if (selected != null) return selected;
                    }
                }
                return null;
            }

            @Override
            public Node selectFirst(TraversalContext context) {
                Node selected = selectNext(0, context);
                if (selected != null) return selected;
                if (overflow) {
                    return overflowMenu;
                }
                return null;
            }

            @Override
            public Node selectLast(TraversalContext context) {
                if (overflow) {
                    return overflowMenu;
                }
                return selectPrev(box.getChildren().size() - 1, context);
            }
        });
        ParentHelper.setTraversalEngine(getSkinnable(), engine);

        control.focusedProperty().addListener((observable, oldValue, newValue) -&gt; {
            if (newValue) {
                // TODO need to detect the focus direction
                // to selected the first control in the toolbar when TAB is pressed
                // or select the last control in the toolbar when SHIFT TAB is pressed.
                if (!box.getChildren().isEmpty()) {
                    box.getChildren().get(0).requestFocus();
                } else {
                    overflowMenu.requestFocus();
                }
            }
        });

        control.getItems().addListener((ListChangeListener&lt;Node&gt;) c -&gt; {
            while (c.next()) {
                for (Node n: c.getRemoved()) {
                    box.getChildren().remove(n);
                }
                box.getChildren().addAll(c.getAddedSubList());
            }
            needsUpdate = true;
            getSkinnable().requestLayout();
        });
    }



    /***************************************************************************
     *                                                                         *
     * Properties                                                              *
     *                                                                         *
     **************************************************************************/

    private double snapSpacing(double value) {
        if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
            return snapSpaceY(value);
        } else {
            return snapSpaceX(value);
        }
    }

    // --- spacing
    private DoubleProperty spacing;
    private final void setSpacing(double value) {
        spacingProperty().set(snapSpacing(value));
    }

    private final double getSpacing() {
        return spacing == null ? 0.0 : snapSpacing(spacing.get());
    }

    private final DoubleProperty spacingProperty() {
        if (spacing == null) {
            spacing = new StyleableDoubleProperty() {

                @Override
                protected void invalidated() {
                    final double value = get();
                    if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
                        ((VBox)box).setSpacing(value);
                    } else {
                        ((HBox)box).setSpacing(value);
                    }
                }

                @Override
                public Object getBean() {
                    return ToolBarSkin.this;
                }

                @Override
                public String getName() {
                    return &quot;spacing&quot;;
                }

                @Override
                public CssMetaData&lt;ToolBar,Number&gt; getCssMetaData() {
                    return StyleableProperties.SPACING;
                }
            };
        }
        return spacing;
    }

    // --- box alignment
    private ObjectProperty&lt;Pos&gt; boxAlignment;
    private final void setBoxAlignment(Pos value) {
        boxAlignmentProperty().set(value);
    }

    private final Pos getBoxAlignment() {
        return boxAlignment == null ? Pos.TOP_LEFT : boxAlignment.get();
    }

    private final ObjectProperty&lt;Pos&gt; boxAlignmentProperty() {
        if (boxAlignment == null) {
            boxAlignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.TOP_LEFT) {

                @Override
                public void invalidated() {
                    final Pos value = get();
                    if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
                        ((VBox)box).setAlignment(value);
                    } else {
                        ((HBox)box).setAlignment(value);
                    }
                }

                @Override
                public Object getBean() {
                    return ToolBarSkin.this;
                }

                @Override
                public String getName() {
                    return &quot;boxAlignment&quot;;
                }

                @Override
                public CssMetaData&lt;ToolBar,Pos&gt; getCssMetaData() {
                    return StyleableProperties.ALIGNMENT;
                }
            };
        }
        return boxAlignment;
    }



    /***************************************************************************
     *                                                                         *
     * Public API                                                              *
     *                                                                         *
     **************************************************************************/

    /** {@inheritDoc} */
    @Override public void dispose() {
        super.dispose();

        if (behavior != null) {
            behavior.dispose();
        }
    }

    /** {@inheritDoc} */
    @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        final ToolBar toolbar = getSkinnable();
        return toolbar.getOrientation() == Orientation.VERTICAL ?
            computePrefWidth(-1, topInset, rightInset, bottomInset, leftInset) :
            snapSizeX(overflowMenu.prefWidth(-1)) + leftInset + rightInset;
    }

    /** {@inheritDoc} */
    @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        final ToolBar toolbar = getSkinnable();
        return toolbar.getOrientation() == Orientation.VERTICAL?
            snapSizeY(overflowMenu.prefHeight(-1)) + topInset + bottomInset :
            computePrefHeight(-1, topInset, rightInset, bottomInset, leftInset);
    }

    /** {@inheritDoc} */
    @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        double prefWidth = 0;
        final ToolBar toolbar = getSkinnable();

        if (toolbar.getOrientation() == Orientation.HORIZONTAL) {
            for (Node node : toolbar.getItems()) {
                if (!node.isManaged()) continue;
                prefWidth += snapSizeX(node.prefWidth(-1)) + getSpacing();
            }
            prefWidth -= getSpacing();
        } else {
            for (Node node : toolbar.getItems()) {
                if (!node.isManaged()) continue;
                prefWidth = Math.max(prefWidth, snapSizeX(node.prefWidth(-1)));
            }
            if (toolbar.getItems().size() &gt; 0) {
                savedPrefWidth = prefWidth;
            } else {
                prefWidth = savedPrefWidth;
            }
        }
        return leftInset + prefWidth + rightInset;
    }

    /** {@inheritDoc} */
    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        double prefHeight = 0;
        final ToolBar toolbar = getSkinnable();

        if(toolbar.getOrientation() == Orientation.VERTICAL) {
            for (Node node: toolbar.getItems()) {
                if (!node.isManaged()) continue;
                prefHeight += snapSizeY(node.prefHeight(-1)) + getSpacing();
            }
            prefHeight -= getSpacing();
        } else {
            for (Node node : toolbar.getItems()) {
                if (!node.isManaged()) continue;
                prefHeight = Math.max(prefHeight, snapSizeY(node.prefHeight(-1)));
            }
            if (toolbar.getItems().size() &gt; 0) {
                savedPrefHeight = prefHeight;
            } else {
                prefHeight = savedPrefHeight;
            }
        }
        return topInset + prefHeight + bottomInset;
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
        return getSkinnable().getOrientation() == Orientation.VERTICAL ?
                snapSizeX(getSkinnable().prefWidth(-1)) : Double.MAX_VALUE;
    }

    /** {@inheritDoc} */
    @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
        return getSkinnable().getOrientation() == Orientation.VERTICAL ?
                Double.MAX_VALUE : snapSizeY(getSkinnable().prefHeight(-1));
    }

    /** {@inheritDoc} */
    @Override protected void layoutChildren(final double x,final double y,
            final double w, final double h) {
//        super.layoutChildren();
        final ToolBar toolbar = getSkinnable();

        if (toolbar.getOrientation() == Orientation.VERTICAL) {
            if (snapSizeY(toolbar.getHeight()) != previousHeight || needsUpdate) {
                ((VBox)box).setSpacing(getSpacing());
                ((VBox)box).setAlignment(getBoxAlignment());
                previousHeight = snapSizeY(toolbar.getHeight());
                addNodesToToolBar();
            }
        } else {
            if (snapSizeX(toolbar.getWidth()) != previousWidth || needsUpdate) {
                ((HBox)box).setSpacing(getSpacing());
                ((HBox)box).setAlignment(getBoxAlignment());
                previousWidth = snapSizeX(toolbar.getWidth());
                addNodesToToolBar();
            }
        }
        needsUpdate = false;

        double toolbarWidth = w;
        double toolbarHeight = h;

        if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
            toolbarHeight -= (overflow ? snapSizeY(overflowMenu.prefHeight(-1)) : 0);
        } else {
            toolbarWidth -= (overflow ? snapSizeX(overflowMenu.prefWidth(-1)) : 0);
        }

        box.resize(toolbarWidth, toolbarHeight);
        positionInArea(box, x, y,
                toolbarWidth, toolbarHeight, /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);

        // If popup menu is not null show the overflowControl
        if (overflow) {
            double overflowMenuWidth = snapSizeX(overflowMenu.prefWidth(-1));
            double overflowMenuHeight = snapSizeY(overflowMenu.prefHeight(-1));
            double overflowX = x;
            double overflowY = x;
            if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
                // This is to prevent the overflow menu from moving when there
                // are no items in the toolbar.
                if (toolbarWidth == 0) {
                    toolbarWidth = savedPrefWidth;
                }
                HPos pos = ((VBox)box).getAlignment().getHpos();
                if (HPos.LEFT.equals(pos)) {
                    overflowX = x + Math.abs((toolbarWidth - overflowMenuWidth)/2);
                } else if (HPos.RIGHT.equals(pos)) {
                    overflowX = (snapSizeX(toolbar.getWidth()) - snappedRightInset() - toolbarWidth) +
                        Math.abs((toolbarWidth - overflowMenuWidth)/2);
                } else {
                    overflowX = x +
                        Math.abs((snapSizeX(toolbar.getWidth()) - (x) +
                        snappedRightInset() - overflowMenuWidth)/2);
                }
                overflowY = snapSizeY(toolbar.getHeight()) - overflowMenuHeight - y;
            } else {
                // This is to prevent the overflow menu from moving when there
                // are no items in the toolbar.
                if (toolbarHeight == 0) {
                    toolbarHeight = savedPrefHeight;
                }
                VPos pos = ((HBox)box).getAlignment().getVpos();
                if (VPos.TOP.equals(pos)) {
                    overflowY = y +
                        Math.abs((toolbarHeight - overflowMenuHeight)/2);
                } else if (VPos.BOTTOM.equals(pos)) {
                    overflowY = (snapSizeY(toolbar.getHeight()) - snappedBottomInset() - toolbarHeight) +
                        Math.abs((toolbarHeight - overflowMenuHeight)/2);
                } else {
                    overflowY = y + Math.abs((toolbarHeight - overflowMenuHeight)/2);
                }
               overflowX = snapSizeX(toolbar.getWidth()) - overflowMenuWidth - snappedRightInset();
            }
            overflowMenu.resize(overflowMenuWidth, overflowMenuHeight);
            positionInArea(overflowMenu, overflowX, overflowY, overflowMenuWidth, overflowMenuHeight, /*baseline ignored*/0,
                    HPos.CENTER, VPos.CENTER);
        }
    }



    /***************************************************************************
     *                                                                         *
     * Private implementation                                                  *
     *                                                                         *
     **************************************************************************/

    private void initialize() {
        if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
            box = new VBox();
        } else {
            box = new HBox();
        }
        box.getStyleClass().add(&quot;container&quot;);
        box.getChildren().addAll(getSkinnable().getItems());
        overflowMenu = new ToolBarOverflowMenu(overflowMenuItems);
        overflowMenu.setVisible(false);
        overflowMenu.setManaged(false);

        getChildren().clear();
        getChildren().add(box);
        getChildren().add(overflowMenu);
<A NAME="30"></A>
        previousWidth = 0;
        previousHeight = 0;
        <FONT color="#f9966b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#30',2,'match49-top.html#30',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>savedPrefWidth = 0;
        savedPrefHeight = 0;
        needsUpdate = true;
        getSkinnable().requestLayout();
    }

    private void addNodesToToolBar() {</B></FONT>
        final ToolBar toolbar = getSkinnable();
        double length = 0;
        if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
            length = snapSizeY(toolbar.getHeight()) - snappedTopInset() - snappedBottomInset() + getSpacing();
        } else {
            length = snapSizeX(toolbar.getWidth()) - snappedLeftInset() - snappedRightInset() + getSpacing();
        }

        // Is there overflow ?
        double x = 0;
        boolean hasOverflow = false;
        for (Node node : getSkinnable().getItems()) {
            if (!node.isManaged()) continue;

            if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
                x += snapSizeY(node.prefHeight(-1)) + getSpacing();
            } else {
                x += snapSizeX(node.prefWidth(-1)) + getSpacing();
            }
            if (x &gt; length) {
                hasOverflow = true;
                break;
            }
        }

        if (hasOverflow) {
            if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
                length -= snapSizeY(overflowMenu.prefHeight(-1));
            } else {
                length -= snapSizeX(overflowMenu.prefWidth(-1));
            }
            length -= getSpacing();
        }

        // Determine which node goes to the toolbar and which goes to the overflow.
        x = 0;
        overflowMenuItems.clear();
        box.getChildren().clear();
        for (Node node : getSkinnable().getItems()) {
            node.getStyleClass().remove(&quot;menu-item&quot;);
            node.getStyleClass().remove(&quot;custom-menu-item&quot;);

            if (node.isManaged()) {
                if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
                    x += snapSizeY(node.prefHeight(-1)) + getSpacing();
                } else {
                    x += snapSizeX(node.prefWidth(-1)) + getSpacing();
                }
            }

            if (x &lt;= length) {
                box.getChildren().add(node);
            } else {
                if (node.isFocused()) {
                    if (!box.getChildren().isEmpty()) {
                        Node last = engine.selectLast();
                        if (last != null) {
                            last.requestFocus();
                        }
                    } else {
                        overflowMenu.requestFocus();
                    }
                }
                if (node instanceof Separator) {
                    overflowMenuItems.add(new SeparatorMenuItem());
                } else {
                    CustomMenuItem customMenuItem = new CustomMenuItem(node);

                    // RT-36455:
                    // We can't be totally certain of all nodes, but for the
                    // most common nodes we can check to see whether we should
                    // hide the menu when the node is clicked on. The common
                    // case is for TextField or Slider.
                    // This list won't be exhaustive (there is no point really
                    // considering the ListView case), but it should try to
                    // include most common control types that find themselves
                    // placed in menus.
                    final String nodeType = node.getTypeSelector();
                    switch (nodeType) {
                        case &quot;Button&quot;:
                        case &quot;Hyperlink&quot;:
                        case &quot;Label&quot;:
                            customMenuItem.setHideOnClick(true);
                            break;
                        case &quot;CheckBox&quot;:
                        case &quot;ChoiceBox&quot;:
                        case &quot;ColorPicker&quot;:
                        case &quot;ComboBox&quot;:
                        case &quot;DatePicker&quot;:
                        case &quot;MenuButton&quot;:
                        case &quot;PasswordField&quot;:
                        case &quot;RadioButton&quot;:
                        case &quot;ScrollBar&quot;:
                        case &quot;ScrollPane&quot;:
                        case &quot;Slider&quot;:
                        case &quot;SplitMenuButton&quot;:
                        case &quot;SplitPane&quot;:
                        case &quot;TextArea&quot;:
                        case &quot;TextField&quot;:
                        case &quot;ToggleButton&quot;:
                        case &quot;ToolBar&quot;:
                        default:
                            customMenuItem.setHideOnClick(false);
                            break;
                    }

                    overflowMenuItems.add(customMenuItem);
                }
            }
        }

        // Check if we overflowed.
        overflow = overflowMenuItems.size() &gt; 0;
        if (!overflow &amp;&amp; overflowMenu.isFocused()) {
            Node last = engine.selectLast();
            if (last != null) {
                last.requestFocus();
            }
        }
        overflowMenu.setVisible(overflow);
        overflowMenu.setManaged(overflow);
    }



    /***************************************************************************
     *                                                                         *
     * Support classes                                                         *
     *                                                                         *
     **************************************************************************/

    class ToolBarOverflowMenu extends StackPane {
        private StackPane downArrow;
        private ContextMenu popup;
        private ObservableList&lt;MenuItem&gt; menuItems;

        public ToolBarOverflowMenu(ObservableList&lt;MenuItem&gt; items) {
            getStyleClass().setAll(&quot;tool-bar-overflow-button&quot;);
            setAccessibleRole(AccessibleRole.BUTTON);
            setAccessibleText(getString(&quot;Accessibility.title.ToolBar.OverflowButton&quot;));
            setFocusTraversable(true);
            this.menuItems = items;
            downArrow = new StackPane();
            downArrow.getStyleClass().setAll(&quot;arrow&quot;);
            downArrow.setOnMousePressed(me -&gt; {
                fire();
            });

            setOnKeyPressed(ke -&gt; {
                if (KeyCode.SPACE.equals(ke.getCode())) {
                    if (!popup.isShowing()) {
                        popup.getItems().clear();
                        popup.getItems().addAll(menuItems);
                        popup.show(downArrow, Side.BOTTOM, 0, 0);
                    }
                    ke.consume();
                } else if (KeyCode.ESCAPE.equals(ke.getCode())) {
                    if (popup.isShowing()) {
                        popup.hide();
                    }
                    ke.consume();
                } else if (KeyCode.ENTER.equals(ke.getCode())) {
                    fire();
                    ke.consume();
                }
            });

            visibleProperty().addListener((observable, oldValue, newValue) -&gt; {
                    if (newValue) {
                        if (box.getChildren().isEmpty()) {
                            setFocusTraversable(true);
                        }
                    }
            });
            popup = new ContextMenu();
            setVisible(false);
            setManaged(false);
            getChildren().add(downArrow);
        }

        private void fire() {
            if (popup.isShowing()) {
                popup.hide();
            } else {
                popup.getItems().clear();
                popup.getItems().addAll(menuItems);
                popup.show(downArrow, Side.BOTTOM, 0, 0);
            }
        }

        @Override protected double computePrefWidth(double height) {
            return snappedLeftInset() + snappedRightInset();
        }

        @Override protected double computePrefHeight(double width) {
            return snappedTopInset() + snappedBottomInset();
        }

        @Override protected void layoutChildren() {
            double w = snapSize(downArrow.prefWidth(-1));
            double h = snapSize(downArrow.prefHeight(-1));
            double x = (snapSize(getWidth()) - w)/2;
            double y = (snapSize(getHeight()) - h)/2;

            // TODO need to provide support for when the toolbar is on the right
            // or bottom
            if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
                downArrow.setRotate(0);
            }

            downArrow.resize(w, h);
            positionInArea(downArrow, x, y, w, h,
                    /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
        }

        /** {@inheritDoc} */
        @Override
        public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
            switch (action) {
                case FIRE: fire(); break;
                default: super.executeAccessibleAction(action); break;
            }
        }
    }

    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/

     /*
      * Super-lazy instantiation pattern from Bill Pugh.
      */
     private static class StyleableProperties {
         private static final CssMetaData&lt;ToolBar,Number&gt; SPACING =
             new CssMetaData&lt;ToolBar,Number&gt;(&quot;-fx-spacing&quot;,
                 SizeConverter.getInstance(), 0.0) {

            @Override
            public boolean isSettable(ToolBar n) {
                final ToolBarSkin skin = (ToolBarSkin) n.getSkin();
                return skin.spacing == null || !skin.spacing.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(ToolBar n) {
                final ToolBarSkin skin = (ToolBarSkin) n.getSkin();
                return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)skin.spacingProperty();
            }
        };

        private static final CssMetaData&lt;ToolBar,Pos&gt;ALIGNMENT =
                new CssMetaData&lt;ToolBar,Pos&gt;(&quot;-fx-alignment&quot;,
                new EnumConverter&lt;Pos&gt;(Pos.class), Pos.TOP_LEFT ) {

            @Override
            public boolean isSettable(ToolBar n) {
                final ToolBarSkin skin = (ToolBarSkin) n.getSkin();
                return skin.boxAlignment == null || !skin.boxAlignment.isBound();
            }

            @Override
            public StyleableProperty&lt;Pos&gt; getStyleableProperty(ToolBar n) {
                final ToolBarSkin skin = (ToolBarSkin) n.getSkin();
                return (StyleableProperty&lt;Pos&gt;)(WritableValue&lt;Pos&gt;)skin.boxAlignmentProperty();
            }
        };


         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
         static {

            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());

            // StackPane also has -fx-alignment. Replace it with
            // ToolBarSkin's.
            // TODO: Really should be able to reference StackPane.StyleableProperties.ALIGNMENT
            final String alignmentProperty = ALIGNMENT.getProperty();
            for (int n=0, nMax=styleables.size(); n&lt;nMax; n++) {
                final CssMetaData&lt;?,?&gt; prop = styleables.get(n);
                if (alignmentProperty.equals(prop.getProperty())) styleables.remove(prop);
            }

            styleables.add(SPACING);
            styleables.add(ALIGNMENT);
            STYLEABLES = Collections.unmodifiableList(styleables);

         }
    }

    /**
     * Returns the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @return the CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    @Override
    protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
        switch (attribute) {
            case OVERFLOW_BUTTON: return overflowMenu;
            default: return super.queryAccessibleAttribute(attribute, parameters);
        }
    }

    @Override
    protected void executeAccessibleAction(AccessibleAction action, Object... parameters) {
        switch (action) {
            case SHOW_MENU:
                overflowMenu.fire();
                break;
            default: super.executeAccessibleAction(action, parameters);
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/GlassRobot.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui;

import java.lang.annotation.Native;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.util.Objects;

import javafx.scene.image.Image;
import javafx.scene.image.PixelWriter;
import javafx.scene.image.WritableImage;
import javafx.scene.input.KeyCode;
import javafx.scene.input.MouseButton;
import javafx.scene.paint.Color;
import javafx.stage.Screen;

import com.sun.javafx.image.PixelUtils;

public abstract class GlassRobot {

    @Native public static final int MOUSE_LEFT_BTN    = 1 &lt;&lt; 0;
    @Native public static final int MOUSE_RIGHT_BTN   = 1 &lt;&lt; 1;
    @Native public static final int MOUSE_MIDDLE_BTN  = 1 &lt;&lt; 2;

    /**
     * Initializes any state necessary for this {@code Robot}. Called by
     * the {@code Robot} constructor.
     */
    public abstract void create();

    /**
     * Frees any resources allocated by this {@code Robot}.
     */
    public abstract void destroy();

    /**
     * Presses the specified {@link KeyCode} key.
     *
     * @param keyCode the key to press
     */
    public abstract void keyPress(KeyCode keyCode);

    /**
     * Releases the specified {@link KeyCode} key.
     *
     * @param keyCode the key to release
     */
    public abstract void keyRelease(KeyCode keyCode);

    /**
     * Returns the current mouse x-position.
     *
     * @return the current mouse x-position
     */
    public abstract double getMouseX();

    /**
     * Returns the current mouse y-position.
     *
     * @return the current mouse y-position
     */
    public abstract double getMouseY();

    /**
     * Moves the mouse to the specified (x,y) screen coordinates relative to
     * the primary screen.
     *
     * @param x screen coordinate x to move the mouse to
     * @param y screen coordinate y to move the mouse to
     */
    public abstract void mouseMove(double x, double y);

    /**
     * Presses the specified {@link MouseButton}s.
     *
     * @param buttons the mouse buttons to press
     */
    public abstract void mousePress(MouseButton... buttons);

    /**
     * Releases the specified {@link MouseButton}s.
     *
     * @param buttons the mouse buttons to release
     */
    public abstract void mouseRelease(MouseButton... buttons);

    /**
     * Scrolls the mouse wheel by the specified amount of wheel clicks. A positive
     * {@code wheelAmt} scrolls the wheel towards the user (down) whereas negative
     * amounts scrolls the wheel away from the user (up).
     *
     * @param wheelAmt the (signed) amount of clicks to scroll the wheel
     */
    public abstract void mouseWheel(int wheelAmt);

    /**
     * Returns the {@link Color} of the pixel at the screen coordinates relative to the
     * primary screen specified by {@code location}. Regardless of the scale of the screen
     * ({@link Screen#getOutputScaleX()}, {@link Screen#getOutputScaleY()}), this method only
     * samples a single pixel. For example, on a HiDPI screen with output scale 2, the screen
     * unit at the point (x,y) may have 4 pixels. In this case the color returned is the color
     * of the top, left pixel. Color values are &lt;em&gt;not&lt;/em&gt; averaged when a screen unit is
     * made up of more than one pixel.
     *
     * @param x the x coordinate to get the pixel color from
     * @param y the y coordinate to get the pixel color from
     * @return the pixel color at the specified screen coordinates
     */
    public abstract Color getPixelColor(double x, double y);

    /**
     * Captures the specified rectangular area of the screen and uses it to fill the given
     * {@code data} array with the raw pixel data. The data is in RGBA format where each
     * pixel in the image is encoded as 4 bytes - one for each color component of each
     * pixel. If this method is not overridden by subclasses then
     * {@link #getScreenCapture(WritableImage, double, double, double, double, boolean)}
     * must be overridden to not call this method.
     *
     * @param x the starting x-position of the rectangular area to capture
     * @param y the starting y-position of the rectangular area to capture
     * @param width the width of the rectangular area to capture
     * @param height the height of the rectangular area to capture
     * @param data the array to fill with the raw pixel data corresponding to
     * the captured region
     * @param scaleToFit If {@literal true} the returned {@code Image} will be
     * scaled to fit the request dimensions, if necessary. Otherwise the size
     * of the returned image will depend on the output scale (DPI) of the primary
     * screen.
     */
    public void getScreenCapture(int x, int y, int width, int height, int[] data, boolean scaleToFit) {
        throw new InternalError(&quot;not implemented&quot;);
    }

    /**
     * Returns an {@code Image} containing the specified rectangular area of the screen.
     * &lt;p&gt;
     * If the {@code scaleToFit} argument is {@literal false}, the returned
     * {@code Image} object dimensions may differ from the requested {@code width}
     * and {@code height} depending on how many physical pixels the area occupies
     * on the screen. E.g. in HiDPI mode on the Mac (aka Retina display) the pixels
     * are doubled, and thus a screen capture of an area of size (10x10) pixels
     * will result in an {@code Image} with dimensions (20x20). Calling code should
     * use the returned images's {@link Image#getWidth() and {@link Image#getHeight()
     * methods to determine the actual image size.
     * &lt;p&gt;
     * If {@code scaleToFit} is {@literal true}, the returned {@code Image} is of
     * the requested size. Note that in this case the image will be scaled in
     * order to fit to the requested dimensions if necessary such as when running
     * on a HiDPI display.
     *
     * @param x the starting x-position of the rectangular area to capture
     * @param y the starting y-position of the rectangular area to capture
     * @param width the width of the rectangular area to capture
     * @param height the height of the rectangular area to capture
     * @param scaleToFit If {@literal true} the returned {@code Image} will be
     * scaled to fit the request dimensions, if necessary. Otherwise the size
     * of the returned image will depend on the output scale (DPI) of the primary
     * screen.
     */
    public WritableImage getScreenCapture(WritableImage image, double x, double y, double width,
                                          double height, boolean scaleToFit) {
        if (width &lt;= 0) {
            throw new IllegalArgumentException(&quot;width must be &gt; 0&quot;);
        }
        if (height &lt;= 0) {
            throw new IllegalArgumentException(&quot;height must be &gt; 0&quot;);
        }
        Screen primaryScreen = Screen.getPrimary();
        Objects.requireNonNull(primaryScreen);
        double outputScaleX = primaryScreen.getOutputScaleX();
        double outputScaleY = primaryScreen.getOutputScaleY();
        int data[];
        int dw, dh;
        if (outputScaleX == 1.0f &amp;&amp; outputScaleY == 1.0f) {
            // No scaling will be necessary regardless of if &quot;scaleToFit&quot; is set or not.
            data = new int[(int) (width * height)];
            getScreenCapture((int) x, (int) y, (int) width, (int) height, data, scaleToFit);
            dw = (int) width;
            dh = (int) height;
        } else {
            // Compute the absolute pixel bounds that the requested size will fill given
            // the display's scale.
            int pminx = (int) Math.floor(x * outputScaleX);
            int pminy = (int) Math.floor(y * outputScaleY);
            int pmaxx = (int) Math.ceil((x + width) * outputScaleX);
            int pmaxy = (int) Math.ceil((y + height) * outputScaleY);
            int pwidth = pmaxx - pminx;
            int pheight = pmaxy - pminy;
            int tmpdata[] = new int[pwidth * pheight];
            getScreenCapture(pminx, pminy, pwidth, pheight, tmpdata, scaleToFit);
            dw = pwidth;
            dh = pheight;
            if (!scaleToFit) {
                data = tmpdata;
            } else {
                // We must resize the image to fit the requested bounds. This means
                // resizing the pixel data array which we accomplish using bilinear (?)
                // interpolation.
                data = new int[(int) (width * height)];
                int index = 0;
                for (int iy = 0; iy &lt; height; iy++) {
                    double rely = ((y + iy + 0.5f) * outputScaleY) - (pminy + 0.5f);
                    int irely = (int) Math.floor(rely);
                    int fracty = (int) ((rely - irely) * 256);
                    for (int ix = 0; ix &lt; width; ix++) {
                        double relx = ((x + ix + 0.5f) * outputScaleX) - (pminx + 0.5f);
                        int irelx = (int) Math.floor(relx);
                        int fractx = (int) ((relx - irelx) * 256);
                        data[index++] = interp(tmpdata, irelx, irely, pwidth, pheight, fractx, fracty);
                    }
                }
                dw = (int) width;
                dh = (int) height;
            }
        }

        return convertFromPixels(image, Application.GetApplication().createPixels(dw, dh, IntBuffer.wrap(data)));
    }

    public static int convertToRobotMouseButton(MouseButton[] buttons) {
        int ret = 0;
        for (MouseButton button : buttons) {
            switch (button) {
                case PRIMARY: ret |= MOUSE_LEFT_BTN; break;
                case SECONDARY: ret |= MOUSE_RIGHT_BTN; break;
                case MIDDLE: ret |= MOUSE_MIDDLE_BTN; break;
                default: throw new IllegalArgumentException(&quot;MouseButton: &quot; + button + &quot; not supported by Robot&quot;);
            }
        }
        return ret;
    }

    public static Color convertFromIntArgb(int color) {
        int alpha = (color &gt;&gt; 24) &amp; 0xFF;
        int red   = (color &gt;&gt; 16) &amp; 0xFF;
        int green = (color &gt;&gt;  8) &amp; 0xFF;
        int blue  =  color        &amp; 0xFF;
        return new Color(red / 255d, green / 255d, blue / 255d, alpha / 255d);
    }

    protected static WritableImage convertFromPixels(WritableImage image, Pixels pixels) {
        Objects.requireNonNull(pixels);
        int width = pixels.getWidth();
        int height = pixels.getHeight();
        if (image == null || image.getWidth() != width || image.getHeight() != height) {
            image = new WritableImage(width, height);
        }

        int bytesPerComponent = pixels.getBytesPerComponent();
        if (bytesPerComponent == 4) {
            IntBuffer intBuffer = (IntBuffer) pixels.getPixels();
            writeIntBufferToImage(intBuffer, image);
        } else if (bytesPerComponent == 1) {
            ByteBuffer byteBuffer = (ByteBuffer) pixels.getPixels();
            writeByteBufferToImage(byteBuffer, image);
        } else {
            throw new IllegalArgumentException(&quot;bytesPerComponent must be either 4 or 1 but was: &quot; +
                    bytesPerComponent);
        }

        return image;
    }

    private static void writeIntBufferToImage(IntBuffer intBuffer, WritableImage image) {
        Objects.requireNonNull(image);
        PixelWriter pixelWriter = image.getPixelWriter();
<A NAME="33"></A>        double width = image.getWidth();
        double height = image.getHeight();

        <FONT color="#736aff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#33',2,'match49-top.html#33',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>for (int y = 0; y &lt; height; y++) {
            for (int x = 0; x &lt; width; x++) {
                int argb = intBuffer.get();
                pixelWriter.setArgb(x, y, argb);
            }
        }</B></FONT>
    }

    private static void writeByteBufferToImage(ByteBuffer byteBuffer, WritableImage image) {
        Objects.requireNonNull(image);
        PixelWriter pixelWriter = image.getPixelWriter();
        double width = image.getWidth();
        double height = image.getHeight();

        int format = Pixels.getNativeFormat();

        for (int y = 0; y &lt; height; y++) {
            for (int x = 0; x &lt; width; x++) {
                if (format == Pixels.Format.BYTE_BGRA_PRE) {
                    pixelWriter.setArgb(x, y, PixelUtils.PretoNonPre(bgraPreToRgbaPre(byteBuffer.getInt())));
                } else if (format == Pixels.Format.BYTE_ARGB) {
                    pixelWriter.setArgb(x, y, byteBuffer.getInt());
                } else {
                    throw new IllegalArgumentException(&quot;format must be either BYTE_BGRA_PRE or BYTE_ARGB&quot;);
                }
            }
        }
    }

    private static int bgraPreToRgbaPre(int bgraPre) {
        return Integer.reverseBytes(bgraPre);
    }

    private static int interp(int pixels[], int x, int y, int w, int h, int fractx1, int fracty1) {
        int fractx0 = 256 - fractx1;
        int fracty0 = 256 - fracty1;
        int i = y * w + x;
        int rgb00 = (x &lt; 0 || y &lt; 0 || x &gt;= w || y &gt;= h) ? 0 : pixels[i];
        if (fracty1 == 0) {
            // No interpolation with pixels[y+1]
            if (fractx1 == 0) {
                // No interpolation with any neighbors
                return rgb00;
            }
            int rgb10 = (y &lt; 0 || x+1 &gt;= w || y &gt;= h) ? 0 : pixels[i+1];
            return interp(rgb00, rgb10, fractx0, fractx1);
        } else if (fractx1 == 0) {
            // No interpolation with pixels[x+1]
            int rgb01 = (x &lt; 0 || x &gt;= w || y+1 &gt;= h) ? 0 : pixels[i+w];
            return interp(rgb00, rgb01, fracty0, fracty1);
        } else {
            // All 4 neighbors must be interpolated
            int rgb10 = (y &lt; 0 || x+1 &gt;= w || y &gt;= h) ? 0 : pixels[i+1];
            int rgb01 = (x &lt; 0 || x &gt;= w || y+1 &gt;= h) ? 0 : pixels[i+w];
            int rgb11 = (x+1 &gt;= w || y+1 &gt;= h) ? 0 : pixels[i+w+1];
            return interp(interp(rgb00, rgb10, fractx0, fractx1),
                    interp(rgb01, rgb11, fractx0, fractx1),
                    fracty0, fracty1);
        }
    }

    private static int interp(int rgb0, int rgb1, int fract0, int fract1) {
        int a0 = (rgb0 &gt;&gt; 24) &amp; 0xff;
        int r0 = (rgb0 &gt;&gt; 16) &amp; 0xff;
        int g0 = (rgb0 &gt;&gt;  8) &amp; 0xff;
        int b0 = (rgb0      ) &amp; 0xff;
        int a1 = (rgb1 &gt;&gt; 24) &amp; 0xff;
        int r1 = (rgb1 &gt;&gt; 16) &amp; 0xff;
        int g1 = (rgb1 &gt;&gt;  8) &amp; 0xff;
        int b1 = (rgb1      ) &amp; 0xff;
        int a = (a0 * fract0 + a1 * fract1) &gt;&gt; 8;
        int r = (r0 * fract0 + r1 * fract1) &gt;&gt; 8;
        int g = (g0 * fract0 + g1 * fract1) &gt;&gt; 8;
        int b = (b0 * fract0 + b1 * fract1) &gt;&gt; 8;
        return (a &lt;&lt; 24) | (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/View.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.glass.ui;

import com.sun.glass.events.MouseEvent;
import com.sun.glass.events.ViewEvent;

import java.lang.annotation.Native;
import java.lang.ref.WeakReference;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Map;

public abstract class View {

    @Native public final static int GESTURE_NO_VALUE = Integer.MAX_VALUE;
    @Native public final static double GESTURE_NO_DOUBLE_VALUE = Double.NaN;

    @Native public final static byte IME_ATTR_INPUT                 = 0x00;
    @Native public final static byte IME_ATTR_TARGET_CONVERTED      = 0x01;
    @Native public final static byte IME_ATTR_CONVERTED             = 0x02;
    @Native public final static byte IME_ATTR_TARGET_NOTCONVERTED   = 0x03;
    @Native public final static byte IME_ATTR_INPUT_ERROR           = 0x04;

    final static boolean accessible = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; {
        String force = System.getProperty(&quot;glass.accessible.force&quot;);
        if (force != null) return Boolean.parseBoolean(force);

        /* By default accessibility is enabled for Mac 10.9 or greater and Windows 7 or greater. */
        try {
            String platform = Platform.determinePlatform();
            String major = System.getProperty(&quot;os.version&quot;).replaceFirst(&quot;(\\d+)\\.\\d+.*&quot;, &quot;$1&quot;);
            String minor = System.getProperty(&quot;os.version&quot;).replaceFirst(&quot;\\d+\\.(\\d+).*&quot;, &quot;$1&quot;);
            int v = Integer.parseInt(major) * 100 + Integer.parseInt(minor);
            return (platform.equals(Platform.MAC) &amp;&amp; v &gt;= 1009) ||
                   (platform.equals(Platform.WINDOWS) &amp;&amp; v &gt;= 601);
        } catch (Exception e) {
            return false;
        }
    });

    public static class EventHandler {
        public void handleViewEvent(View view, long time, int type) {
        }
        public void handleKeyEvent(View view, long time, int action,
                int keyCode, char[] keyChars, int modifiers) {
        }
        public void handleMenuEvent(View view, int x, int y, int xAbs,
                int yAbs, boolean isKeyboardTrigger) {
        }
        public void handleMouseEvent(View view, long time, int type, int button,
                                     int x, int y, int xAbs, int yAbs,
                                     int modifiers, boolean isPopupTrigger, boolean isSynthesized)
        {
        }

        /**
         * A Scroll event handler.
         *
         * The lines argument:
         * &amp;gt; 0 - a number of lines to scroll per each 1.0 of deltaY scroll amount
         * == 0 - the scroll amount is in pixel units
         * &amp;lt; 0 - the scrolling should be performed by pages. Each 1.0 of scroll amount
         * corresponds to exactly one page of scrollable content.
         *
         * Similarly, the chars argument specifies the number of characters
         * to scroll per 1.0 of the deltaX scrolling amount.
         * If the parameter is zero, the deltaX represents the number of
         * pixels to scroll.
         *
         * The defaultLines and defaultChars arguments contain the system-default
         * values of lines and chars. This can be used by the app to compute
         * the ratio of current settings and default settings and adjust the
         * pixel values accordingly.
         *
         * Multiplers are used when an app receives a non-zero unit values (i.e.
         * either the lines or chars are not zeroes), but wants instead get delta
         * values in pixels. In this case the app needs to multiply the deltas
         * on the provided multiplier parameter.
         */
        public void handleScrollEvent(View view, long time,
                int x, int y, int xAbs, int yAbs,
                double deltaX, double deltaY, int modifiers, int lines, int chars,
                int defaultLines, int defaultChars,
                double xMultiplier, double yMultiplier)
        {
        }

        public void handleInputMethodEvent(long time, String text,
                int[] clauseBoundary,
                int[] attrBoundary, byte[] attrValue,
                int commitCount, int cursorPos) {
        }

        public double[] getInputMethodCandidatePos(int offset) {
            return null;
        }

        public void handleDragStart(View view, int button, int x, int y, int xAbs, int yAbs,
                ClipboardAssistance dropSourceAssistant) {
        }

        public void handleDragEnd(View view, int performedAction) {
        }

        public int handleDragEnter(View view, int x, int y, int xAbs, int yAbs,
                int recommendedDropAction, ClipboardAssistance dropTargetAssistant) {
            return recommendedDropAction;
        }

        public int handleDragOver(View view, int x, int y, int xAbs, int yAbs,
                int recommendedDropAction, ClipboardAssistance dropTargetAssistant) {
            return recommendedDropAction;
        }

        public void handleDragLeave(View view, ClipboardAssistance dropTargetAssistant) {
        }

        public int handleDragDrop(View view, int x, int y, int xAbs, int yAbs,
                int recommendedDropAction, ClipboardAssistance dropTargetAssistant) {
            return Clipboard.ACTION_NONE;
        }

        /**
         * Touch event handler. Called when touch event occures.
         * Always followed with one ore more #handleNextTouchEvent() calls
         * and a single #handleEndTouchEvent() call.
         *
         * @param isDirect if event reported by direct or indirect touch device;
         *        touch screen is an example of direct touch device and
         *        touch pad is an example of indirect one
         * @param touchEventCount indicates number of #handleNextTouchEvent() calls
         *        that will follow this method call.
         */
        public void handleBeginTouchEvent(View view, long time, int modifiers,
                                          boolean isDirect, int touchEventCount) {
        }

        /**
         * Touch event handler. Called for every touch point in some touch event.
         *
         * If the touch event has been emitted with direct touch device
         * (touch screen) then x and y arguments designate touch point position
         * relative to the top-left corner of the view and xAbs and yAbs
         * arguments designate position relative to the top-left corner of the
         * screen. Both positions are measured in pixels.
         *
         * If the touch event has been emitted with indirect touch device
         * (touch pad) then x and y arguments designate normalized touch point
         * position. It is measured between (0,0) and (10000,10000), where (0,0)
         * is the top-left and (10000,10000) is the bottom-right position on
         * the indirect touch input device (touch pad). xAbs and yAbs
         * arguments are equal values of x and y arguments respectively.
         *
         * @see #handleBeginTouchEvent(com.sun.glass.ui.View, long, int, boolean, int)
         *
         * @param type touch event type. One of constants declared in
         *        #com.sun.glass.events.TouchEvent class.
         * @param touchId touch point identifier;
         *        every touch point has its own unique identifier;
         *        the identifier remains the same across multiple calls of
         *        #handleNextTouchEvent method for the same touch point until
         *        it is not released.
         * @param x the X coordinate of the touch point;
         * @param y the Y coordinate of the touch point;
         * @param xAbs absolute X coordinate of the touch point;
         * @param yAbs absolute Y coordinate of the touch point;
         */
        public void handleNextTouchEvent(View view, long time, int type,
                                         long touchId, int x, int y, int xAbs,
                                         int yAbs) {
        }

        /**
         * Touch event handler. Called to notify that all #handleNextTouchEvent
         * methods corresponding to some touch event have been called already.
         *
         * @see #handleBeginTouchEvent(com.sun.glass.ui.View, long, int, boolean, int)
         */
        public void handleEndTouchEvent(View view, long time) {
        }

        /**
         * Scroll gesture handler.
         *
         * If underlying system supports coordinates for gestures then x and y
         * arguments designate gesture position relative to the top-left
         * corner of the view and xAbs and yAbs designate gesture position
         * relative to the top-left corner of the screen. For gestures emitted
         * from direct touch input device (touch screen) positions are measured
         * in pixels. For gestures emitted from indirect touch input device
         * (touch pad) positions are normalized. For details of normalized
         * touch input position see #handleBeginTouchEvent method.
         *
         * If underlying system doesn't support coordinates for gestures then
         * x and y arguments designate mouse position relative to the top-left
         * corner of the view and xAbs and yAbs designate mouse position
         * relative to the top-left corner of the screen. Positions are measured
         * in pixels.
         *
         * If gesture handler is called to notify end of gesture, i.e. value of
         * type argument is equal to
         * com.sun.glass.events.GestureEvent.GESTURE_FINISHED constant then
         * x, y, xAbs and yAbs arguments may be set to View.GESTURE_NO_VALUE
         * constant indicating no data is available. This is implementation
         * specific behavior.
         *
         * Values of dx and dy arguments are always 0.0 if type argument
         * is set to com.sun.glass.events.GestureEvent.GESTURE_FINISHED
         * constant.
         *
         * For description of isDirect argument see #handleBeginTouchEvent
         * method.
         *
         * @param type gesture state. One of constants declared in
         *        #com.sun.glass.events.GestureEvent class.
         * @param isInertia if gesture is caused by inertia.
         * @param touchCount number of touch points at
         *        the moment of gesture execution; it is always set to
         *        View.GESTURE_NO_VALUE constant if value of type argument is
         *        set to com.sun.glass.events.GestureEvent.GESTURE_FINISHED
         *        constant
         * @param x the X coordinate of the gesture;
         * @param y the Y coordinate of the gesture;
         * @param xAbs absolute X coordinate of the gesture;
         * @param yAbs absolute Y coordinate of the gesture;
         * @param dx horizontal scroll delta. Positive if scrolling from
         *        left to right, non-positive otherwise
         * @param dy vertical scroll delta. Positive if scrolling from
         *        up to down, non-positive otherwise
         * @param totaldx total horizontal scroll calculated from all
         *        sequential scroll gestures, i.e. sum of all 'dx' values from
         *        previous sequential calls to this method
         * @param totaldy total vertical scroll calculated from all
         *        sequential scroll gestures, i.e. sum of all 'dy' values from
         *        previous sequential calls to this method
         * @param multiplierX the X multiplier
         * @param multiplierY the Y multiplier
         *
         * Multiplers are used when an app receives a non-zero unit values (i.e.
         * either the lines or chars are not zeroes), but wants instead get delta
         * values in pixels. In this case the app needs to multiply the deltas
         * on the provided multiplier parameter.
         */
        public void handleScrollGestureEvent(View view, long time, int type,
                                             int modifiers, boolean isDirect,
                                             boolean isInertia, int touchCount,
                                             int x, int y, int xAbs, int yAbs,
                                             double dx, double dy,
                                             double totaldx, double totaldy,
                                             double multiplierX, double multiplierY) {
        }

        /**
         * Zoom gesture handler.
         *
         * For description of isDirect argument see #handleBeginTouchEvent
         * method.
         *
         * For description of isInertia argument see #handleScrollGestureEvent
         * method.
         *
         * For description of type, x,y, xAbs and yAbs arguments
         * see #handleBeginTouchEvent method.
         *
         * If underlying system doesn't support measurement of expansion value
         * in zoom gestures then expansion and totalexpansion arguments are
         * always set to View.GESTURE_NO_DOUBLE_VALUE.
         *
         * If type argument is set to
         * com.sun.glass.events.GestureEvent.GESTURE_FINISHED constant value of
         * scale argument is always set to View.GESTURE_NO_DOUBLE_VALUE constant
         * and expansion argument is always 0.0.
         *
         * @param scale current zoom delta; the value is multiplicative
         *        and not additive.
         * @param expansion current expansion delta. Measured in pixels on
         *        direct touch input devices and normalized values on indirect
         *        touch input devices. See #handleBeginTouchEvent for
         *        description of units of indirect touch input devices.
         * @param totalscale total zoom calculated from all
         *        sequential zoom gestures, i.e. sum of all 'scale' values from
         *        previous sequential calls to this method
         * @param totalexpansion total expansion calculated from all
         *        sequential zoom gestures, i.e. sum of all 'expansion' values
         *        from previous sequential calls of this method
         */
        public void handleZoomGestureEvent(View view, long time, int type,
                                           int modifiers, boolean isDirect,
                                           boolean isInertia, int x, int y,
                                           int xAbs, int yAbs, double scale,
                                           double expansion, double totalscale,
                                           double totalexpansion) {
        }

        /**
         * Rotation gesture handler.
         *
         * For description of isDirect argument see #handleBeginTouchEvent
         * method.
         *
         * For description of isInertia argument see #handleScrollGestureEvent
         * method.
         *
         * For description of type, x,y, xAbs and yAbs arguments
         * see #handleBeginTouchEvent method.
         *
         * @param dangle current angle delta in degrees. Positive for clockwise
         *        rotation
         * @param totalangle total angle calculated from all
         *        sequential rotation gestures, i.e. sum of all 'dangle' values
         *        from previous sequential calls of this method
         */
        public void handleRotateGestureEvent(View view, long time, int type,
                                             int modifiers, boolean isDirect,
                                             boolean isInertia, int x, int y,
                                             int xAbs, int yAbs, double dangle,
                                             double totalangle) {
        }

        /**
         * Swipe gesture handler.
         *
         * For description of isDirect argument see #handleBeginTouchEvent
         * method.
         *
         * For description of isInertia and touchCount arguments
         * see #handleScrollGestureEvent method.
         *
         * For description of type, x,y, xAbs and yAbs arguments
         * see #handleBeginTouchEvent method.
         *
         * @param dir gesture direction.
         *        One of constants defined in com.sun.glass.events.SwipeGesture
         *        class.
         */
        public void handleSwipeGestureEvent(View view, long time, int type,
                                            int modifiers, boolean isDirect,
                                            boolean isInertia, int touchCount,
                                            int dir, int x, int y, int xAbs,
                                            int yAbs) {
        }

        public Accessible getSceneAccessible() {
            return null;
        }
    }

    public static long getMultiClickTime() {
        Application.checkEventThread();
        return Application.GetApplication().staticView_getMultiClickTime();
    }

    public static int getMultiClickMaxX() {
        Application.checkEventThread();
        return Application.GetApplication().staticView_getMultiClickMaxX();
    }

    public static int getMultiClickMaxY() {
        Application.checkEventThread();
        return Application.GetApplication().staticView_getMultiClickMaxY();
    }

    protected abstract void _enableInputMethodEvents(long ptr, boolean enable);
    protected void _finishInputMethodComposition(long ptr) {
        // Action needed only on Windows.
    }

    /*
        Read by the checkNotClosed method which could be called from lock/unlock on render thread
     */
    private volatile long ptr; // Native handle (NSView*, or internal structure pointer)
    private Window window; // parent window
    private EventHandler eventHandler;

    private int width = -1;     // not set
    private int height = -1;    // not set

    private boolean isValid = false; // true between ViewEvent.Add &amp; ViewEvent.REMOVE
    private boolean isVisible = false;
    private boolean inFullscreen = false;

    static final public class Capability {
        // we need these for native code
        @Native static final public int k3dKeyValue                     = 0;
        @Native static final public int kSyncKeyValue                   = 1;
        @Native static final public int k3dProjectionKeyValue           = 2;
        @Native static final public int k3dProjectionAngleKeyValue      = 3;
        @Native static final public int k3dDepthKeyValue                = 4;
        @Native static final public int kHiDPIAwareKeyValue             = 5;

        static final public Object k3dKey                       = Integer.valueOf(k3dKeyValue); // value must be Boolean
        static final public Object kSyncKey                     = Integer.valueOf(kSyncKeyValue); // value must be Boolean
        static final public Object k3dProjectionKey             = Integer.valueOf(k3dProjectionKeyValue); // value must be Boolean
        static final public Object k3dProjectionAngleKey        = Integer.valueOf(k3dProjectionAngleKeyValue); // value must be Float
        static final public Object k3dDepthKey                  = Integer.valueOf(k3dDepthKeyValue); // value must be Integer(depth), where depth = 0, 4, 8, 16, 32etc
        static final public Object kHiDPIAwareKey               = Integer.valueOf(kHiDPIAwareKeyValue); // value must be Boolean; default = false (i.e. NOT HiDPI-aware)
    }


    protected abstract long _create(Map capabilities);
    protected View() {
        Application.checkEventThread();
        this.ptr = _create(Application.GetApplication().getDeviceDetails());
        if (this.ptr == 0L) {
            throw new RuntimeException(&quot;could not create platform view&quot;);
        }
    }

    private void checkNotClosed() {
        if (this.ptr == 0L) {
            throw new IllegalStateException(&quot;The view has already been closed&quot;);
        }
    }

    public boolean isClosed() {
        Application.checkEventThread();
        return this.ptr == 0L;
    }

    protected abstract long _getNativeView(long ptr);
    /**
     * On Windows ptr is a pointer to a native structure.
     * However, for external clients of the API, a HWND has to be returned.
     * Hence the native method.
     */
    public long getNativeView() {
        Application.checkEventThread();
        checkNotClosed();
        return _getNativeView(this.ptr);
    }

    /** Only used on Mac when run inside a plugin */
    public int getNativeRemoteLayerId(String serverName) {
        Application.checkEventThread();
        throw new RuntimeException(&quot;This operation is not supported on this platform&quot;);
    }

    public Window getWindow() {
        Application.checkEventThread();
        return this.window;
    }

    protected abstract int _getX(long ptr);
    /** X coordinate relative to the host (window or applet). */
    public int getX() {
        Application.checkEventThread();
        checkNotClosed();
        return _getX(this.ptr);
    }

    protected abstract int _getY(long ptr);
    /** Y coordinate relative to the host (window or applet). */
    public int getY() {
        Application.checkEventThread();
        checkNotClosed();
        return _getY(this.ptr);
    }

    public int getWidth() {
        Application.checkEventThread();
        return this.width;
    }

    public int getHeight() {
        Application.checkEventThread();
        return this.height;
    }

    protected abstract void _setParent(long ptr, long parentPtr);
    // Window calls the method from Window.setView()
    // package private
    void setWindow(Window window) {
        Application.checkEventThread();
        checkNotClosed();
        this.window = window;
        _setParent(this.ptr, window == null ? 0L : window.getNativeHandle());
        this.isValid = this.ptr != 0 &amp;&amp; window != null;
    }

    // package private
    void setVisible(boolean visible) {
        this.isVisible = visible;
    }

    protected abstract boolean _close(long ptr);
    public void close() {
        Application.checkEventThread();
        if (this.ptr == 0) {
            return;
        }
        if (isInFullscreen()) {
            _exitFullscreen(this.ptr, false);
        }
        Window host = getWindow();
        if (host != null) {
            host.setView(null); // will call this.setWindow(null)
        }
        this.isValid = false;
        _close(this.ptr);
        this.ptr = 0;
    }

    public EventHandler getEventHandler() {
        Application.checkEventThread();
        return this.eventHandler;
    }

    public void setEventHandler(EventHandler eventHandler) {
        Application.checkEventThread();
        this.eventHandler = eventHandler;
    }

    //-------- EVENTS --------//

    private void handleViewEvent(long time, int type) {
        if (this.eventHandler != null) {
            this.eventHandler.handleViewEvent(this, time, type);
        }
    }

    private void handleKeyEvent(long time, int action,
            int keyCode, char[] keyChars, int modifiers) {
        if (this.eventHandler != null) {
            this.eventHandler.handleKeyEvent(this, time, action, keyCode, keyChars, modifiers);
        }
    }

    private void handleMouseEvent(long time, int type, int button, int x, int y,
                                  int xAbs, int yAbs,
                                  int modifiers, boolean isPopupTrigger,
                                  boolean isSynthesized) {
        if (eventHandler != null) {
            eventHandler.handleMouseEvent(this, time, type, button, x, y, xAbs,
                                          yAbs, modifiers,
                                          isPopupTrigger, isSynthesized);
        }
    }

    private void handleMenuEvent(int x, int y, int xAbs, int yAbs, boolean isKeyboardTrigger) {
        if (this.eventHandler != null) {
            this.eventHandler.handleMenuEvent(this, x, y, xAbs, yAbs, isKeyboardTrigger);
        }
    }

    public void handleBeginTouchEvent(View view, long time, int modifiers,
                                      boolean isDirect, int touchEventCount) {
        if (eventHandler != null) {
            eventHandler.handleBeginTouchEvent(view, time, modifiers, isDirect,
                    touchEventCount);
        }
    }

    public void handleNextTouchEvent(View view, long time, int type,
                                     long touchId, int x, int y, int xAbs,
                                     int yAbs) {
        if (eventHandler != null) {
            eventHandler.handleNextTouchEvent(view, time, type, touchId, x, y, xAbs, yAbs);
        }
    }

    public void handleEndTouchEvent(View view, long time) {
        if (eventHandler != null) {
            eventHandler.handleEndTouchEvent(view, time);
        }
    }

    public void handleScrollGestureEvent(View view, long time, int type,
                                         int modifiers, boolean isDirect,
                                         boolean isInertia, int touchCount,
                                         int x, int y, int xAbs, int yAbs,
                                         double dx, double dy, double totaldx,
                                         double totaldy, double multiplierX,
                                         double multiplierY) {
        if (eventHandler != null) {
            eventHandler.handleScrollGestureEvent(view, time, type, modifiers, isDirect,
                    isInertia, touchCount, x, y, xAbs, yAbs,
                    dx, dy, totaldx, totaldy, multiplierX, multiplierY);
        }
    }

    public void handleZoomGestureEvent(View view, long time, int type,
                                       int modifiers, boolean isDirect,
                                       boolean isInertia, int originx,
                                       int originy, int originxAbs,
                                       int originyAbs, double scale,
                                       double expansion, double totalscale,
                                       double totalexpansion) {
        if (eventHandler != null) {
            eventHandler.handleZoomGestureEvent(view, time, type, modifiers, isDirect,
                                     isInertia, originx, originy, originxAbs,
                                     originyAbs, scale, expansion, totalscale,
                                     totalexpansion);
        }
    }

    public void handleRotateGestureEvent(View view, long time, int type,
                                         int modifiers, boolean isDirect,
                                         boolean isInertia, int originx,
                                         int originy, int originxAbs,
                                         int originyAbs, double dangle,
                                         double totalangle) {
        if (eventHandler != null) {
            eventHandler.handleRotateGestureEvent(view, time, type, modifiers, isDirect,
                    isInertia, originx, originy, originxAbs,
                    originyAbs, dangle, totalangle);
        }
    }

    public void handleSwipeGestureEvent(View view, long time, int type,
                                        int modifiers, boolean isDirect,
                                        boolean isInertia, int touchCount,
                                        int dir, int originx, int originy,
                                        int originxAbs, int originyAbs) {
        if (eventHandler != null) {
            eventHandler.handleSwipeGestureEvent(view, time, type, modifiers, isDirect,
                    isInertia, touchCount, dir, originx,
                    originy, originxAbs, originyAbs);
        }
    }

    private void handleInputMethodEvent(long time, String text, int[] clauseBoundary,
                int[] attrBoundary, byte[] attrValue,
                int commitCount, int cursorPos) {
        if (this.eventHandler != null) {
            this.eventHandler.handleInputMethodEvent(time, text, clauseBoundary,
                attrBoundary, attrValue,
                commitCount, cursorPos);
        }
    }

    public void enableInputMethodEvents(boolean enable) {
        Application.checkEventThread();
        checkNotClosed();
        _enableInputMethodEvents(this.ptr, enable);
    }

    public void finishInputMethodComposition() {
        Application.checkEventThread();
        checkNotClosed();
        _finishInputMethodComposition(this.ptr);
    }

    private double[] getInputMethodCandidatePos(int offset) {
        if (this.eventHandler != null) {
            return this.eventHandler.getInputMethodCandidatePos(offset);
        }
        return null;
    }

    private void handleDragStart(int button, int x, int y, int xAbs, int yAbs,
            ClipboardAssistance dropSourceAssistant) {
        if (this.eventHandler != null) {
            this.eventHandler.handleDragStart(this, button, x, y, xAbs, yAbs, dropSourceAssistant);
        }
    }

    private void handleDragEnd(int performedAction) {
        if (this.eventHandler != null) {
            this.eventHandler.handleDragEnd(this, performedAction);
        }
    }

    private int handleDragEnter(int x, int y, int xAbs, int yAbs,
            int recommendedDropAction, ClipboardAssistance dropTargetAssistant) {
        if (this.eventHandler != null) {
            return this.eventHandler.handleDragEnter(this, x, y, xAbs, yAbs, recommendedDropAction, dropTargetAssistant);
        } else {
            return recommendedDropAction;
        }
    }

    private int handleDragOver(int x, int y, int xAbs, int yAbs,
            int recommendedDropAction, ClipboardAssistance dropTargetAssistant) {
        if (this.eventHandler != null) {
            return this.eventHandler.handleDragOver(this, x, y, xAbs, yAbs, recommendedDropAction, dropTargetAssistant);
        } else {
            return recommendedDropAction;
        }
    }

    private void handleDragLeave(ClipboardAssistance dropTargetAssistant) {
        if (this.eventHandler != null) {
            this.eventHandler.handleDragLeave(this, dropTargetAssistant);
        }
    }

    private int handleDragDrop(int x, int y, int xAbs, int yAbs,
            int recommendedDropAction, ClipboardAssistance dropTargetAssistant) {
        if (this.eventHandler != null) {
            return this.eventHandler.handleDragDrop(this, x, y, xAbs, yAbs, recommendedDropAction, dropTargetAssistant);
        } else {
            return Clipboard.ACTION_NONE;
        }
    }

    //-------- DRAWING --------//
    protected abstract void _scheduleRepaint(long ptr);
    /** marks native surface dirty, so the system itself will create repaint event
     * */
    public void scheduleRepaint() {
        Application.checkEventThread();
        checkNotClosed();
        _scheduleRepaint(this.ptr);
    }

    protected abstract void _begin(long ptr);
    /** prepares to painting by locking native surface
     *
     * Called on the render thread
     */
    public void lock() {
        checkNotClosed();
        _begin(this.ptr);
    }

    protected abstract void _end(long ptr);
    /** ends painting by unlocking native surface and flushing
     * flushes surface (if flush == true) or discard it (flush == false)
     *
     * Called on the render thread
     */
    public void unlock() {
        checkNotClosed();
        _end(this.ptr);
    }

    protected abstract int _getNativeFrameBuffer(long ptr);

    /**
     * Called on the renderer thread and must be between lock and unlock
     */
    public int getNativeFrameBuffer() {
        return _getNativeFrameBuffer(this.ptr);
    }


    protected abstract void _uploadPixels(long ptr, Pixels pixels);
    /**
     * This method dumps the pixels on to the view.
     *
     * NOTE: On MS Windows calling this method is REQUIRED for
     * transparent windows in order to update them.
     */
    public void uploadPixels(Pixels pixels) {
        Application.checkEventThread();
        checkNotClosed();
        lock();
        try {
            _uploadPixels(this.ptr, pixels);
        } finally {
            unlock();
        }
    }


    //-------- FULLSCREEN --------//

    protected abstract boolean _enterFullscreen(long ptr, boolean animate, boolean keepRatio, boolean hideCursor);
    public boolean enterFullscreen(boolean animate, boolean keepRatio, boolean hideCursor) {
        Application.checkEventThread();
        checkNotClosed();
        return _enterFullscreen(this.ptr, animate, keepRatio, hideCursor);
    }

    protected abstract void _exitFullscreen(long ptr, boolean animate);
    public void exitFullscreen(boolean animate) {
        Application.checkEventThread();
        checkNotClosed();
        _exitFullscreen(this.ptr, animate);
    }

    public boolean isInFullscreen() {
        Application.checkEventThread();
        return this.inFullscreen;
    }

    public boolean toggleFullscreen(boolean animate, boolean keepRatio, boolean hideCursor) {
        Application.checkEventThread();
        checkNotClosed();
        if (!this.inFullscreen) {
            enterFullscreen(animate, keepRatio, hideCursor);
        } else {
            exitFullscreen(animate);
        }

        _scheduleRepaint(this.ptr);

        return this.inFullscreen;
    }

    public void updateLocation() {
        notifyView(ViewEvent.MOVE);
    }


    //-------- DELEGATE NOTIFICATIONS --------//

    protected void notifyView(int type) {
        //System.err.println(&quot;    notifyView: &quot;+ViewEvent.getTypeString(type)+&quot; on thread&quot;+Thread.currentThread());
        if (type == ViewEvent.REPAINT) {
            if (isValid) {
                handleViewEvent(System.nanoTime(), type);
            }
        }
        else
        {
            boolean synthesizeMOVE = false;

            switch (type) {
                case ViewEvent.REMOVE:
                    isValid = false;
                    synthesizeMOVE = true;
                    break;
                case ViewEvent.ADD:
                    isValid = true;
                    synthesizeMOVE = true;
                    break;
                case ViewEvent.FULLSCREEN_ENTER:
                    this.inFullscreen = true;
                    synthesizeMOVE = true;
                    if (getWindow() != null) {
                        getWindow().notifyFullscreen(true);
                    }
                    break;
                case ViewEvent.FULLSCREEN_EXIT:
                    this.inFullscreen = false;
                    synthesizeMOVE = true;
                    if (getWindow() != null) {
                        getWindow().notifyFullscreen(false);
                    }
                    break;
                case ViewEvent.MOVE:
                case ViewEvent.RESIZE:
                    break;
                default:
                    System.err.println(&quot;Unknown view event type: &quot; + type);
                    return;
            }

            handleViewEvent(System.nanoTime(), type);

            if (synthesizeMOVE) {
                // Generate MOVE event to update current insets. Native code may
                // send additional MOVE events when it detects insets change.
                handleViewEvent(System.nanoTime(), ViewEvent.MOVE);
            }
        }
    }

    protected void notifyResize(int width, int height) {
        if (this.width == width &amp;&amp; this.height == height) {
            return;
        }

        this.width = width;
        this.height = height;
        handleViewEvent(System.nanoTime(), ViewEvent.RESIZE);
    }

    /*
     * x, y, width, heigth define the &quot;dirty&quot; rect
     */
    protected void notifyRepaint(int x, int y, int width, int height) {
        notifyView(ViewEvent.REPAINT);
    }


    // ------------ MENU EVENT HANDLING -----------------
//    protected void notifyMenu(int type, int button, int x, int y, int xAbs, int yAbs, int keyCode, char[] keyChars, int modifiers) {
        protected void notifyMenu(int x, int y, int xAbs, int yAbs, boolean isKeyboardTrigger) {
        handleMenuEvent(x, y, xAbs, yAbs, isKeyboardTrigger);
    }

    // ------------ MOUSE EVENTS HANDLING -----------------

    // Synchronized on the Main thread of the underlying native system
    private static WeakReference&lt;View&gt; lastClickedView = null;
    private static int lastClickedButton;
    private static long lastClickedTime;
    private static int lastClickedX, lastClickedY;
    private static int clickCount;
    private static boolean dragProcessed = false;

    protected void notifyMouse(int type, int button, int x, int y, int xAbs,
                               int yAbs, int modifiers, boolean isPopupTrigger,
                               boolean isSynthesized) {
        // gznote: optimize - only call for undecorated Windows!
        if (this.window != null) {
            // handled by window (programmatical move/resize)
            if (this.window.handleMouseEvent(type, button, x, y, xAbs, yAbs)) {
                // The evnet has been processed by Glass
                return;
            }
        }

        long now = System.nanoTime();
        if (type == MouseEvent.DOWN) {
            View lastClickedView = View.lastClickedView == null ? null : View.lastClickedView.get();

            if (lastClickedView == this &amp;&amp;
                    lastClickedButton == button &amp;&amp;
                    (now - lastClickedTime) &lt;= 1000000L*getMultiClickTime() &amp;&amp;
                    Math.abs(x - lastClickedX) &lt;= getMultiClickMaxX() &amp;&amp;
                    Math.abs(y - lastClickedY) &lt;= getMultiClickMaxY())
            {
                clickCount++;
            } else {
                clickCount = 1;

                View.lastClickedView = new WeakReference&lt;View&gt;(this);
                lastClickedButton = button;
                lastClickedX = x;
                lastClickedY = y;
            }

            lastClickedTime = now;
        }

        handleMouseEvent(now, type, button, x, y, xAbs, yAbs,
                         modifiers, isPopupTrigger, isSynthesized);

        if (type == MouseEvent.DRAG) {
            // Send the handleDragStart() only once per a drag gesture
            if (!dragProcessed) {
                notifyDragStart(button, x, y, xAbs, yAbs);
                dragProcessed = true;
            }
        } else {
            dragProcessed = false;
        }
    }

    // ------------- END OF MOUSE EVENTS -----------------

    protected void notifyScroll(int x, int y, int xAbs, int yAbs,
            double deltaX, double deltaY, int modifiers, int lines, int chars,
            int defaultLines, int defaultChars,
            double xMultiplier, double yMultiplier)
    {
        if (this.eventHandler != null) {
            this.eventHandler.handleScrollEvent(this, System.nanoTime(),
                    x, y, xAbs, yAbs, deltaX, deltaY, modifiers, lines, chars,
                    defaultLines, defaultChars, xMultiplier, yMultiplier);
        }
    }

    protected void notifyKey(int type, int keyCode, char[] keyChars, int modifiers) {
        handleKeyEvent(System.nanoTime(), type, keyCode, keyChars, modifiers);
    }

    protected void notifyInputMethod(String text, int[] clauseBoundary,
        int[] attrBoundary, byte[] attrValue,
        int committedTextLength, int caretPos, int visiblePos) {
        handleInputMethodEvent(System.nanoTime(), text, clauseBoundary,
                attrBoundary, attrValue, committedTextLength, caretPos);
    }

    protected double[] notifyInputMethodCandidatePosRequest(int offset) {
        double[] ret = getInputMethodCandidatePos(offset);
        if (ret == null) {
            ret = new double[2];
            ret[0] = 0.0;
            ret[1] = 0.0;
        }
        return ret;
<A NAME="19"></A>    }

    private ClipboardAssistance dropSourceAssistant;
    protected void notifyDragStart(int button, int x, int y, int xAbs, <FONT color="#4e9258"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#19',2,'match49-top.html#19',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>int yAbs) {
        dropSourceAssistant = new ClipboardAssistance(Clipboard.DND) {
            @Override public void actionPerformed(int performedAction) {</B></FONT>
                // on Windows called from DnD modal loop
                // on Mac the View is the drag delegate and calls notifyDragEnd directly
                notifyDragEnd(performedAction);
            }
        };
        //DnD loop is inside dropSourceAssistant.flush()
        handleDragStart(button, x, y, xAbs, yAbs, dropSourceAssistant);
        //utilize dropSourceAssistant if DnD was not started.
        if (dropSourceAssistant != null) {
            dropSourceAssistant.close();
            dropSourceAssistant = null;
        }
    }

    protected void notifyDragEnd(int performedAction) {
        handleDragEnd(performedAction);
        if (dropSourceAssistant != null) {
            dropSourceAssistant.close();
            dropSourceAssistant = null;
        }
    }

    ClipboardAssistance  dropTargetAssistant;
    // callback for native code
    protected int notifyDragEnter(int x, int y, int xAbs, int yAbs, int recommendedDropAction) {
        dropTargetAssistant = new ClipboardAssistance(Clipboard.DND) {
            @Override public void flush() {
                throw new UnsupportedOperationException(&quot;Flush is forbidden from target!&quot;);
            }
        };
        return handleDragEnter(x, y, xAbs, yAbs, recommendedDropAction, dropTargetAssistant);
    }

    // callback for native code
    protected int notifyDragOver(int x, int y, int xAbs, int yAbs, int recommendedDropAction) {
        return handleDragOver(x, y, xAbs, yAbs, recommendedDropAction, dropTargetAssistant);
    }

    // callback for native code
    protected void notifyDragLeave() {
        handleDragLeave(dropTargetAssistant);
        dropTargetAssistant.close();
    }

    // callback for native code
    // gznote: should be renamed to notifyDragDrop/notifyDragPerformed to be consistent
    protected int notifyDragDrop(int x, int y, int xAbs, int yAbs, int recommendedDropAction) {
        int performedAction = handleDragDrop(x, y, xAbs, yAbs, recommendedDropAction, dropTargetAssistant);
        dropTargetAssistant.close();
        return performedAction;
    }

    public void notifyBeginTouchEvent(int modifiers, boolean isDirect,
                                      int touchEventCount) {
        handleBeginTouchEvent(this, System.nanoTime(), modifiers, isDirect,
                              touchEventCount);
    }

    public void notifyNextTouchEvent(int type, long touchId, int x, int y,
                                     int xAbs, int yAbs) {
        handleNextTouchEvent(this, System.nanoTime(), type, touchId, x, y, xAbs,
                             yAbs);
    }

    public void notifyEndTouchEvent() {
        handleEndTouchEvent(this, System.nanoTime());
    }

    public void notifyScrollGestureEvent(int type, int modifiers,
                                         boolean isDirect, boolean isInertia,
                                         int touchCount, int x, int y, int xAbs,
                                         int yAbs, double dx, double dy,
                                         double totaldx, double totaldy,
                                         double multiplierX, double multiplierY) {
        handleScrollGestureEvent(this, System.nanoTime(), type, modifiers,
                                 isDirect, isInertia, touchCount, x, y, xAbs,
                                 yAbs, dx, dy, totaldx, totaldy, multiplierX, multiplierY);
    }

    public void notifyZoomGestureEvent(int type, int modifiers, boolean isDirect,
                                       boolean isInertia, int originx,
                                       int originy, int originxAbs,
                                       int originyAbs, double scale,
                                       double expansion, double totalscale,
                                       double totalexpansion) {
        handleZoomGestureEvent(this, System.nanoTime(), type, modifiers,
                               isDirect, isInertia, originx, originy, originxAbs,
                               originyAbs, scale, expansion, totalscale,
                               totalexpansion);
    }

    public void notifyRotateGestureEvent(int type, int modifiers,
                                         boolean isDirect, boolean isInertia,
                                         int originx, int originy,
                                         int originxAbs, int originyAbs,
                                         double dangle, double totalangle) {
        handleRotateGestureEvent(this, System.nanoTime(), type, modifiers,
                                 isDirect, isInertia, originx, originy,
                                 originxAbs, originyAbs, dangle, totalangle);
    }

    public void notifySwipeGestureEvent(int type, int modifiers,
                                        boolean isDirect, boolean isInertia,
                                        int touchCount, int dir, int originx,
                                        int originy, int originxAbs,
                                        int originyAbs) {
        handleSwipeGestureEvent(this, System.nanoTime(), type, modifiers,
                                isDirect, isInertia, touchCount, dir, originx,
                                originy, originxAbs, originyAbs);
    }

    /**
     * Returns the accessible object for the view.
     * This method is called by JNI code when the
     * platform requested the accessible peer for the view.
     * On Windows it happens on WM_GETOBJECT.
     * On Mac it happens on NSView#accessibilityAttributeNames.
     */
    long getAccessible() {
        Application.checkEventThread();
        checkNotClosed();
        if (accessible) {
            Accessible acc = eventHandler.getSceneAccessible();
            if (acc != null) {
                acc.setView(this);
                return acc.getNativeAccessible();
            }
        }
        return 0L;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/glass/ui/monocle/MonocleWindow.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.glass.ui.monocle;

import com.sun.glass.events.MouseEvent;
import com.sun.glass.events.ViewEvent;
import com.sun.glass.events.WindowEvent;
import com.sun.glass.ui.Application;
import com.sun.glass.ui.Cursor;
import com.sun.glass.ui.Pixels;
import com.sun.glass.ui.Screen;
import com.sun.glass.ui.View;
import com.sun.glass.ui.Window;


final class MonocleWindow extends Window {


    private static final int STATE_NORMAL = 0;
    private static final int STATE_MINIMIZED = 1;
    private static final int STATE_MAXIMIZED = 2;
    private static final int STATE_FULLSCREEN = 3;

    private int id;
    private int state;
    private int cachedX, cachedY, cachedW, cachedH;
    private int minW, minH;
    private int maxW = -1;
    private int maxH = -1;
<A NAME="3"></A>
    MonocleWindow(Window owner, Screen screen, int styleMask) {
        super(owner, screen, styleMask);
    <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#3',2,'match49-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    MonocleWindow(long parent) {
        super(parent);
    }

    @Override
    protected void _toFront(long ptr) {
        MonocleWindowManager.getInstance</B></FONT>().toFront(this);
    }

    @Override
    protected void _toBack(long ptr) {
        MonocleWindowManager.getInstance().toBack(this);

    }

    /**
     *
     * w/h is the total window width/height including all its
     * decorations (e.g. title bar). cw/ch is the &quot;client&quot;, or
     * interior width/height. Negative values for w/h/cw/ch are
     * treated as &quot;not set&quot;. For example: setBounds(x, y, xSet,
     * ySet, 800, 600, -1, -1) will make the window 800x600 pixels.
     * The client area available for drawing will be smaller, e.g.
     * 792x580 - it depends on the window decorations on different
     * platforms. setBounds(x, y, xSet, ySet, -1, -1, 800, 600) will
     * make the window client size to be 800x600 pixels. The area
     * for drawing (FX scene size) will be exactly 800x600, but the
     * total window size including decorations will be slightly
     * bigger. For undecorated windows w/h and cw/ch are obviously
     * the same.
     *
     * As this is a void function the native code should trigger an
     * event to notify the system on actual change
     *
     */
    @Override
    protected void _setBounds(long nativeWindowPointer,
                              int x, int y, boolean xSet, boolean ySet,
                              int w, int h, int cw, int ch,
                              float xGravity, float yGravity) {
        int width;
        int height;

        if (w &gt; 0) {
            //window width surpass window content width (cw)
            width = w;
        } else if (cw &gt; 0) {
            //content width changed
            width = cw;
        } else {
            //no explicit request to change width, get default
            width = getWidth();
        }

        if (h &gt; 0) {
            //window height surpass window content height(ch)
            height = h;
        } else if (cw &gt; 0) {
            //content height changed
            height = ch;
        } else {
            //no explicit request to change height, get default
            height = getHeight();
        }
        if (!xSet) {
            x = getX();
        }
        if (!ySet) {
            y = getY();
        }
        if (maxW &gt;= 0) {
            width = Math.min(width, maxW);
        }
        if (maxH &gt;= 0) {
            height = Math.min(height, maxH);
        }
        width = Math.max(width, minW);
        height = Math.max(height, minH);

        notifyResizeAndMove(x, y, width, height);
    }

    private void notifyResizeAndMove(int x, int y, int width, int height) {
        MonocleView view = (MonocleView) getView();
        boolean repaintView = false;

        if (getWidth() != width || getHeight() != height) {
            notifyResize(WindowEvent.RESIZE, width, height);
            if (view != null) {
                view.notifyResize(width, height);
                repaintView = true;
            }
        }
        if (getX() != x || getY() != y) {
            notifyMove(x, y);
            if (view != null) {
                repaintView = true;
            }
        }
        if (repaintView) {
            view.notifyRepaint();
        }
    }

    //creates the native window
    @Override
    protected long _createWindow(long NativeWindow, long NativeScreen,
                                 int mask) {
        id = MonocleWindowManager.getInstance().addWindow(this);
        return id;
    }

    @Override
    protected long _createChildWindow(long parent) {
        throw new UnsupportedOperationException();
    }

    @Override
    protected boolean _close(long nativeWindowPointer) {
        return MonocleWindowManager.getInstance().closeWindow(this);
    }

    @Override
    protected boolean _setView(long nativeWindowPointer, View view) {
        boolean result = true;
        if (view != null) {
            // the system assumes a resize notification to set the View
            // sizes and to get the Scene to layout correctly.
            ((MonocleView)view).notifyResize(getWidth(), getHeight());
        }
        return result;
    }

    /**
     * Returns the handle used to create a rendering context in Prism
     */
    @Override
    public long getNativeWindow() {
        return id;
    }

    @Override
    protected boolean _setMenubar(long ptr, long menubarPtr) {
        return true;
    }

    @Override
    protected boolean _minimize(long nativeWindowPointer, boolean minimize) {
        int x = getX();
        int y = getY();
        int width = getWidth();
        int height = getHeight();
        if (minimize &amp;&amp; !(state == STATE_MINIMIZED)) {
            state = STATE_MINIMIZED;
            cachedX = x;
            cachedY = y;
            cachedW = width;
            cachedH = height;
            // remove the window from the list of visible windows in the
            // superclass
            remove(this);
            notifyResize(WindowEvent.MINIMIZE, width, height);

        } else if (!minimize &amp;&amp; state == STATE_MINIMIZED) {
            state = STATE_NORMAL;
            x = cachedX;
            y = cachedY;
            width = cachedW;
            height = cachedH;
            // this call will add the window back into the visible list of
            // windows in the superclass
            add(this);
            notifyResize(WindowEvent.RESTORE, width, height);
        }
        return true;
    }

    @Override
    protected boolean _maximize(long nativeWindowPointer, boolean maximize,
                                boolean wasMaximized) {
        NativeScreen screen = NativePlatformFactory.getNativePlatform().getScreen();
        int x = getX();
        int y = getY();
        int width = getWidth();
        int height = getHeight();
        if (maximize &amp;&amp; !wasMaximized) {
            if (state == STATE_NORMAL) {
                cachedX = x;
                cachedY = y;
                cachedW = width;
                cachedH = height;
            }
            if (maxW &gt;= 0) {
                width = maxW;
                x = Math.min(x, screen.getWidth() - width);
            } else {
                x = 0;
                width = screen.getWidth();
            }
            if (maxH &gt;= 0) {
                height = maxH;
                y = Math.min(y, screen.getHeight() - height);
            } else {
                y = 0;
                height = screen.getHeight();
            }
            state = STATE_MAXIMIZED;
        } else if (!maximize &amp;&amp; wasMaximized) {
            x = cachedX;
            y = cachedY;
            width = cachedW;
            height = cachedH;
            state = STATE_NORMAL;
        }
        notifyResizeAndMove(x, y, width, height);
        return true;
    }

    void setFullScreen(boolean fullscreen) {
        NativeScreen screen = NativePlatformFactory.getNativePlatform().getScreen();
        int x = getX();
        int y = getY();
        int width = getWidth();
        int height = getHeight();
        if (fullscreen) {
            if (state == STATE_NORMAL) {
                cachedX = x;
                cachedY = y;
                cachedW = width;
                cachedH = height;
            }
            x = 0;
            y = 0;
            width = screen.getWidth();
            height = screen.getHeight();
            MonocleView view = (MonocleView) getView();
            if (view != null) {
                view.notifyView(ViewEvent.FULLSCREEN_ENTER);
            }
            state = STATE_FULLSCREEN;
        } else {
            x = cachedX;
            y = cachedY;
            width = cachedW;
            height = cachedH;
            MonocleView view = (MonocleView) getView();
            if (view != null) {
                view.notifyView(ViewEvent.FULLSCREEN_EXIT);
            }
            state = STATE_NORMAL;
        }
        notifyResizeAndMove(x, y, width, height);
    }

    private float cachedAlpha = 1;
    @Override
    protected boolean _setVisible(long ptr, boolean visible) {
        if (visible) {
            setAlpha(cachedAlpha);
        } else {
            cachedAlpha = getAlpha();
            setAlpha(0);
        }

        return true;
    }

    @Override
    protected boolean _setResizable(long ptr, boolean resizable){
        return true;
    }

    @Override
    protected boolean _requestFocus(long ptr, int event) {
        return MonocleWindowManager.getInstance().requestFocus(this);
    }

    @Override
    protected void _setFocusable(long ptr, boolean isFocusable){}

    @Override
    protected boolean _setTitle(long ptr, String title) {
        return true;
    }

    @Override
    protected void _setLevel(long ptr, int level) {}

    @Override
    protected void _setAlpha(long ptr, float alpha) {}

    @Override
    protected boolean _setBackground(long ptr, float r, float g, float b) {
        return true;
    }

    @Override
    protected void _setEnabled(long ptr, boolean enabled){
        if (!enabled &amp;&amp;
            (this == MonocleWindowManager.getInstance().getFocusedWindow())) {
            MonocleView view = (MonocleView)getView();
            try {
                view.notifyMouse(MouseEvent.EXIT, MouseEvent.BUTTON_NONE,
                        0, 0, 0, 0, 0, false, false);
            } catch (RuntimeException e) {
                Application.reportException(e);
            }
        }
    }

    @Override
    protected boolean _setMinimumSize(long ptr, int width, int height) {
        minW = width;
        minH = height;
        return true;
    }

    @Override
    protected boolean _setMaximumSize(long ptr, int width, int height) {
        maxW = width;
        maxH = height;
        return true;
    }

    @Override
    protected void _setIcon(long ptr, Pixels pixels){}

    @Override
    protected boolean _grabFocus(long ptr) {
        return MonocleWindowManager.getInstance().grabFocus(this);
    }

    @Override
    protected void _ungrabFocus(long ptr) {
        MonocleWindowManager.getInstance().ungrabFocus(this);
    }

    /**
     * The functions below are used when the platform support modality natively.
     * Currently only GTK is using it. This functionality is disabled by
     * default. In order to enable it this class need to override Window::
     * supportsPlatformModality() to return true.
     *
     */
    @Override
    protected void _enterModal(long ptr) {
        throw new UnsupportedOperationException();
    }

    @Override
    protected void _enterModalWithWindow(long dialog, long window) {
        throw new UnsupportedOperationException();
    }

    @Override
    protected void _exitModal(long ptr) {
        throw new UnsupportedOperationException();
    }

    @Override
    protected void notifyClose() {
        super.notifyClose();
        close();
    }

    @Override
    protected void notifyDestroy() {
        super.notifyDestroy();
        MonocleWindowManager.getInstance().repaintAll();
    }

    @Override
    protected void notifyFocus(int event) {
        super.notifyFocus(event);
    }

    protected void _notifyFocusUngrab() {
        notifyFocusUngrab();
    }

    void _notifyFocusDisabled() {
        notifyFocusDisabled();
    }

    //**************************************************************

    @Override protected void _setCursor(long ptr, Cursor cursor) {
        ((MonocleCursor) cursor).applyCursor();
    }

    @Override protected int _getEmbeddedX(long ptr) {
        return 0;
    }
    @Override protected int _getEmbeddedY(long ptr) {
        return 0;
    }

    @Override
    protected void _requestInput(long ptr, String text, int type, double width, double height,
                                 double Mxx, double Mxy, double Mxz, double Mxt,
                                 double Myx, double Myy, double Myz, double Myt,
                                 double Mzx, double Mzy, double Mzz, double Mzt) {
        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
    }

    @Override
    protected void _releaseInput(long ptr) {
        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/font/FontFileWriter.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.font;

import java.io.File;
import java.io.RandomAccessFile;
import java.io.IOException;
import java.nio.file.Files;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

/*
 * Utility class to write sfnt-based font files.
 *
 * To reduce the number of IO operation this class buffers the font header
 * and directory when the API writeHeader() and writeDirectoryEntry() are used.
 */
class FontFileWriter implements FontConstants {
    byte[] header;              // buffer for the header and directory
    int pos;                    // current position for the tables
    int headerPos;              // current buffer position in the header
    int writtenBytes;
    FontTracker tracker;
    File file;
    RandomAccessFile raFile;

    public FontFileWriter() {
        if (!hasTempPermission()) {
            tracker = FontTracker.getTracker();
        }
    }

    protected void setLength(int size) throws IOException {
        if (raFile == null) {
            throw new IOException(&quot;File not open&quot;);
        }
        checkTracker(size);
        raFile.setLength(size);
    }

    public void seek(int pos) throws IOException {
        if (raFile == null) {
            throw new IOException(&quot;File not open&quot;);
        }
        if (pos != this.pos) {
            raFile.seek(pos);
            this.pos = pos;
        }
    }

    public File getFile() {
        return file;
    }

    public File openFile() throws PrivilegedActionException {
        pos = 0;
        writtenBytes = 0;
        file = AccessController.doPrivileged(
                (PrivilegedExceptionAction&lt;File&gt;) () -&gt; {
                    try {
                        return Files.createTempFile(&quot;+JXF&quot;, &quot;.tmp&quot;).toFile();
                    } catch (IOException e) {
                        // don't reveal temporary directory location
                        throw new IOException(&quot;Unable to create temporary file&quot;);
                    }
                }
        );
        if (tracker != null) {
            tracker.add(file);
        }
        raFile = AccessController.doPrivileged(
                (PrivilegedExceptionAction&lt;RandomAccessFile&gt;) () -&gt; new RandomAccessFile(file, &quot;rw&quot;)
        );
        if (tracker != null) {
            tracker.set(file, raFile);
        }
        if (PrismFontFactory.debugFonts) {
            System.err.println(&quot;Temp file created: &quot; + file.getPath());
        }
        return file;
    }

    public void closeFile() throws IOException {
        if (header != null) {
            raFile.seek(0);
            raFile.write(header);
            header = null;
        }
        if (raFile != null) {
            raFile.close();
            raFile = null;
        }
        if (tracker != null) {
            tracker.remove(file);
        }
    }

    public void deleteFile() {
        if (file != null) {
            if (tracker != null) {
                tracker.subBytes(writtenBytes);
            }
            try {
                closeFile();
            } catch (Exception e) {
            }
            try {
                AccessController.doPrivileged(
                        (PrivilegedExceptionAction&lt;Void&gt;) () -&gt; {
                            file.delete();
                            return null;
                        }
                );
                if (PrismFontFactory.debugFonts) {
                    System.err.println(&quot;Temp file delete: &quot; + file.getPath());
                }
            } catch (Exception e) {
            }
            file = null;
            raFile = null;
        }
    }

    public boolean isTracking() {
        return tracker != null;
    }

    private void checkTracker(int size) throws IOException {
        if (tracker != null) {
            if (size &lt; 0 || pos &gt; FontTracker.MAX_FILE_SIZE - size) {
                throw new IOException(&quot;File too big.&quot;);
            }
<A NAME="23"></A>            if (tracker.getNumBytes() &gt; FontTracker.MAX_TOTAL_BYTES - size) {
                throw new IOException(&quot;Total files too big.&quot;);
            }
        <FONT color="#f660ab"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#23',2,'match49-top.html#23',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
    }

    private void checkSize(int size) throws IOException {
        if (tracker != null) {
            checkTracker(size);
            tracker.addBytes(size);
            writtenBytes += size;
        }</B></FONT>
    }

    private void setHeaderPos(int pos) {
        headerPos = pos;
    }

    /*
     * Write a snft header for the specified format and number of tables.
     */
    public void writeHeader(int format, short numTables) throws IOException {
        int size = TTCHEADERSIZE + (DIRECTORYENTRYSIZE * numTables);
        checkSize(size);
        header = new byte[size];

        /* Spec:
        * searchRange = (maximum power of 2 &lt;= numTables) * 16
        * entrySelector = log2(maximum power of 2 &lt;= numTables)
        * rangeShift = numTables*16-searchRange
        */
        short maxPower2 = numTables;
        maxPower2 |= (maxPower2 &gt;&gt; 1);
        maxPower2 |= (maxPower2 &gt;&gt; 2);
        maxPower2 |= (maxPower2 &gt;&gt; 4);
        maxPower2 |= (maxPower2 &gt;&gt; 8);
        /* at this point maxPower2+1 is the minimum power of 2 &gt; numTables
          maxPower2 &amp; ~(maxPower2&gt;&gt;1) is the maximum power of 2 &lt;= numTables */
        maxPower2 &amp;= ~(maxPower2 &gt;&gt; 1);
        short searchRange = (short)(maxPower2 * 16);
        short entrySelector = 0;
        while (maxPower2 &gt; 1) {
            entrySelector++;
            maxPower2 &gt;&gt;= 1;
        }
        short rangeShift = (short)(numTables * 16 - searchRange);

        setHeaderPos(0);
        writeInt(format);
        writeShort(numTables);
        writeShort(searchRange);
        writeShort(entrySelector);
        writeShort(rangeShift);
    }

    public void writeDirectoryEntry(int index, int tag,
            int checksum, int offset, int length) throws IOException
    {
        setHeaderPos(TTCHEADERSIZE + DIRECTORYENTRYSIZE * index);
        writeInt(tag);
        writeInt(checksum);
        writeInt(offset);
        writeInt(length);
    }

    private void writeInt(int value) throws IOException {
        header[headerPos++] = (byte)((value &amp; 0xFF000000) &gt;&gt; 24);
        header[headerPos++] = (byte)((value &amp; 0x00FF0000) &gt;&gt; 16);
        header[headerPos++] = (byte)((value &amp; 0x0000FF00) &gt;&gt; 8);
        header[headerPos++] = (byte) (value &amp; 0x000000FF);
    }

    private void writeShort(short value) throws IOException {
        header[headerPos++] = (byte)((value &amp; 0xFF00) &gt;&gt; 8);
        header[headerPos++] = (byte)(value &amp; 0xFF);
    }

    public void writeBytes(byte[] buffer) throws IOException {
        writeBytes(buffer, 0, buffer.length);
    }

    public void writeBytes(byte[] buffer, int startPos, int length)
            throws IOException
    {
        checkSize(length);
        raFile.write(buffer, startPos, length);
        pos += length;
    }

    /**
     * Used with the byte count tracker for fonts created from streams.
     * If a thread can create temp files anyway, there is no point in counting
     * font bytes.
     */
    static boolean hasTempPermission() {
        if (System.getSecurityManager() == null) {
            return true;
        }
        File f = null;
        boolean hasPerm = false;
        try {
            f = Files.createTempFile(&quot;+JXF&quot;, &quot;.tmp&quot;).toFile();
            f.delete();
            f = null;
            hasPerm = true;
        } catch (Throwable t) {
            /* inc. any kind of SecurityException */
        }
        return hasPerm;
    }

    /* Like JDK, FX allows untrusted code to create fonts which consume
     * disk resource. We need to place some reasonable limit on the amount
     * that can be consumed to prevent D.O.S type attacks.
     */
    static class FontTracker {
        public static final int MAX_FILE_SIZE = 32 * 1024 * 1024;
        public static final int MAX_TOTAL_BYTES = 10 * MAX_FILE_SIZE;

        static int numBytes;
        static FontTracker tracker;

        public static synchronized FontTracker getTracker() {
            if (tracker == null) {
                tracker = new FontTracker();
            }
            return tracker;
        }

        public synchronized int getNumBytes() {
            return numBytes;
        }

        public synchronized void addBytes(int sz) {
            numBytes += sz;
        }

        public synchronized void subBytes(int sz) {
            numBytes -= sz;
        }

        private static Semaphore cs = null;

        /**
         * Returns a counting semaphore.
         */
        private static synchronized Semaphore getCS() {
            if (cs == null) {
                // Make a semaphore with 5 permits that obeys the first-in first-out
                // granting of permits.
                cs = new Semaphore(5, true);
            }
            return cs;
        }

        public boolean acquirePermit() throws InterruptedException {
            // This does a timed-out wait.
            return getCS().tryAcquire(120, TimeUnit.SECONDS);
        }

        public void releasePermit() {
            getCS().release();
        }

        public void add(File file) {
            TempFileDeletionHook.add(file);
        }

        public void set(File file, RandomAccessFile raf) {
            TempFileDeletionHook.set(file, raf);
        }

        public void remove(File file) {
            TempFileDeletionHook.remove(file);
        }

        /**
         * Helper class for cleanup of temp files created while processing fonts.
         */
        private static class TempFileDeletionHook {
            private static HashMap&lt;File, RandomAccessFile&gt; files =
                new HashMap&lt;File, RandomAccessFile&gt;();

            private static Thread t = null;
            static void init() {
                if (t == null) {
                    // Add a shutdown hook to remove the temp file.
                    java.security.AccessController.doPrivileged(
                            (java.security.PrivilegedAction) () -&gt; {
                                t = new Thread(() -&gt; {
                                    runHooks();
                                });
                                Runtime.getRuntime().addShutdownHook(t);
                                return null;
                            }
                    );
                }
            }

            private TempFileDeletionHook() {}

            static synchronized void add(File file) {
                init();
                files.put(file, null);
            }

            static synchronized void set(File file, RandomAccessFile raf) {
                files.put(file, raf);
            }

            static synchronized void remove(File file) {
                files.remove(file);
            }

            static synchronized void runHooks() {
                if (files.isEmpty()) {
                    return;
                }

                for (Map.Entry&lt;File, RandomAccessFile&gt; entry : files.entrySet())
                {
                    // Close the associated raf, and then delete the file.
                    try {
                        if (entry.getValue() != null) {
                            entry.getValue().close();
                        }
                    } catch (Exception e) {}
                    entry.getKey().delete();
                }
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/scene/layout/region/Margins.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.scene.layout.region;

import javafx.scene.text.Font;

import javafx.css.Size;
import javafx.css.SizeUnits;
import javafx.css.ParsedValue;
import javafx.css.StyleConverter;
import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;

/**
 * Similar to Insets but with flag denoting values are proportional.
 * If proportional is true, then the values represent fractions or percentages
 * and are in the range 0..1, although this is not enforced.
 */
public class Margins {

    // lazy, thread-safe instantiation
    private static class Holder {
        static Converter CONVERTER_INSTANCE = new Converter();
        static SequenceConverter SEQUENCE_CONVERTER_INSTANCE = new SequenceConverter();
    }

    final double top;
    public final double getTop() { return top; }

    final double right;
    public final double getRight() { return right; }

    final double bottom;
    public final double getBottom() { return bottom; }

    final double left;
    public final double getLeft() { return left; }

    final boolean proportional;
    public final boolean isProportional() { return proportional; }

    public Margins(double top, double right, double bottom, double left, boolean proportional) {
        this.top = top;
        this.right = right;
        this.bottom = bottom;
        this.left = left;
        this.proportional = proportional;
    }

    @Override
    public String toString() {
        return &quot;top: &quot;+top+&quot;\nright: &quot;+right+&quot;\nbottom: &quot;+bottom+&quot;\nleft: &quot;+left;
    }

    /**
     * Convert a sequence of sizes to an Margins
     */
    public static final class Converter extends StyleConverter&lt;ParsedValue[], Margins&gt; {

        public static Converter getInstance() {
            return Holder.CONVERTER_INSTANCE;
        }

        private Converter() {
            super();
        }

        @Override
        public Margins convert(ParsedValue&lt;ParsedValue[], Margins&gt; value, Font font) {
            ParsedValue&lt;?, Size&gt;[] sides = value.getValue();
            Size topSz = (sides.length &gt; 0) ? sides[0].convert(font) : new Size(0.0F, SizeUnits.PX);
            Size rightSz = (sides.length &gt; 1) ? sides[1].convert(font) : topSz;
            Size bottomSz = (sides.length &gt; 2) ? sides[2].convert(font) : topSz;
            Size leftSz = (sides.length &gt; 3) ? sides[3].convert(font) : rightSz;

            // assume proportional if any units are percent
            boolean proportional =
                    (topSz.getUnits() == SizeUnits.PERCENT)    ||
                    (rightSz.getUnits() == SizeUnits.PERCENT)  ||
                    (bottomSz.getUnits() == SizeUnits.PERCENT) ||
                    (leftSz.getUnits() == SizeUnits.PERCENT);

            // if any of the units is percent, then make sure they all are.
            boolean unitsMatch =
                !proportional ||
                ((topSz.getUnits() == SizeUnits.PERCENT)    &amp;&amp;
                 (rightSz.getUnits() == SizeUnits.PERCENT)  &amp;&amp;
                 (bottomSz.getUnits() == SizeUnits.PERCENT) &amp;&amp;
                 (leftSz.getUnits() == SizeUnits.PERCENT));

            // unitsMatch will only be false if proportional is true and
            // not all of the units are percent.
            if (unitsMatch == false) {
<A NAME="13"></A>                   final PlatformLogger LOGGER = com.sun.javafx.util.Logging.getCSSLogger();
                    if (LOGGER.isLoggable(Level.WARNING)) {
                        final String msg =
                            <FONT color="#842dce"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#13',2,'match49-top.html#13',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>new StringBuilder(&quot;units do no match: &quot;)
                                .append(topSz.toString())
                                .append(&quot; ,&quot;).append(rightSz.toString())
                                .append(&quot; ,&quot;).append(bottomSz.toString())
                                .append(&quot; ,&quot;).append(leftSz.toString</B></FONT>())
                            .toString();
                        LOGGER.warning(msg);
                    }
            }

            proportional = proportional &amp;&amp; unitsMatch;

            double top = topSz.pixels(font);
            double right = rightSz.pixels(font);
            double bottom = bottomSz.pixels(font);
            double left = leftSz.pixels(font);
            return new Margins(top, right, bottom, left, proportional);
        }

        @Override
        public String toString() {
            return &quot;MarginsConverter&quot;;
        }
    }

    /**
     * Convert a sequence of sizes to an Insets
     */
    public static final class SequenceConverter extends StyleConverter&lt;ParsedValue&lt;ParsedValue[], Margins&gt;[], Margins[]&gt; {

        public static SequenceConverter getInstance() {
            return Holder.SEQUENCE_CONVERTER_INSTANCE;
        }

        private SequenceConverter() {
            super();
        }

        @Override
        public Margins[] convert(ParsedValue&lt;ParsedValue&lt;ParsedValue[], Margins&gt;[], Margins[]&gt; value, Font font) {
            ParsedValue&lt;ParsedValue[], Margins&gt;[] layers = value.getValue();
            Margins[] margins = new Margins[layers.length];
            for (int layer = 0; layer &lt; layers.length; layer++) {
                margins[layer] = Converter.getInstance().convert(layers[layer], font);
            }
            return margins;
        }

        @Override
        public String toString() {
            return &quot;MarginsSequenceConverter&quot;;
        }
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/sg/prism/NGExternalNode.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
<A NAME="12"></A> * questions.
 */

<FONT color="#3b9c9c"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#12',2,'match49-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>package com.sun.javafx.sg.prism;

import java.nio.Buffer;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.ReentrantLock;
import com.sun.javafx.geom.Rectangle;
import com.sun.prism.Graphics;
import com.sun.prism.PixelFormat;
import com.sun.prism.ResourceFactory;
import com.sun.prism.Texture;

public class NGExternalNode extends NGNode {

    private Texture dsttexture;

    private BufferData bufferData;
    private final AtomicReference&lt;RenderData&gt; renderData = new AtomicReference&lt;RenderData&gt;(null);
    private RenderData rd</B></FONT>; // last rendered data

    private volatile ReentrantLock bufferLock;

    @Override
    protected void renderContent(Graphics g) {

        RenderData curRenderData = renderData.getAndSet(null);

        if (curRenderData != null) {
            rd = curRenderData;
        }
        if (rd == null) return;

        int x = rd.bdata.srcbounds.x;
        int y = rd.bdata.srcbounds.y;
        int w = rd.bdata.srcbounds.width;
        int h = rd.bdata.srcbounds.height;

        if (dsttexture != null) {

            dsttexture.lock();

            if (dsttexture.isSurfaceLost() ||
               (dsttexture.getContentWidth() != w) ||
               (dsttexture.getContentHeight() != h))
            {
                dsttexture.unlock();
                dsttexture.dispose();
                rd = rd.copyAddDirtyRect(0, 0, w, h);
                dsttexture = createTexture(g, rd);
            }
        } else {
            dsttexture = createTexture(g, rd);
        }
        if (dsttexture == null) {
            return;
        }
        try {
            if (curRenderData != null) {
                bufferLock.lock();
                try {
                    dsttexture.update(rd.bdata.srcbuffer,
                                      PixelFormat.INT_ARGB_PRE,
                                      rd.dirtyRect.x, rd.dirtyRect.y, // dst
                                      x + rd.dirtyRect.x, y + rd.dirtyRect.y,  // src
                                      rd.dirtyRect.width, rd.dirtyRect.height, // src
                                      rd.bdata.linestride * 4,
                                      false);
                } finally {
                    bufferLock.unlock();
                }
                if (rd.clearTarget) {
                    g.clearQuad(0, 0, rd.bdata.usrwidth, rd.bdata.usrheight);
                }
            }

            g.drawTexture(dsttexture,
                          0, 0, rd.bdata.usrwidth, rd.bdata.usrheight, // dst
                          0, 0, w, h); // src
        } finally {
            dsttexture.unlock();
        }
    }

    private Texture createTexture(Graphics g, RenderData rd) {
        ResourceFactory factory = g.getResourceFactory();
        if (!factory.isDeviceReady()) {
            return null;
        }
        Texture txt = factory.createTexture(PixelFormat.INT_ARGB_PRE,
                                            Texture.Usage.DYNAMIC,
                                            Texture.WrapMode.CLAMP_NOT_NEEDED,
                                            rd.bdata.srcbounds.width, rd.bdata.srcbounds.height);
        if (txt != null) {
            txt.contentsUseful();
        } else {
            System.err.println(&quot;NGExternalNode: failed to create a texture&quot;);
        }
        return txt;
    }

    public void setLock(ReentrantLock lock) {
        this.bufferLock = lock;
    }

    private static class BufferData {
        // the source pixel buffer
        final Buffer srcbuffer;

        // source buffer line stride
        final int linestride;

        // source image physical bounds
        final Rectangle srcbounds;

        // source image user space (logical) size
        final float usrwidth;
        final float usrheight;

        // source image scale factor
        final double scaleX;
        final double scaleY;

        BufferData(Buffer srcbuffer, int linestride,
                   int x, int y, int width, int height,
                   float usrWidth, float usrHeight,
                   double scaleX, double scaleY)
        {
            this.srcbuffer = srcbuffer;
            this.scaleX = scaleX;
            this.scaleY = scaleY;
            this.linestride = linestride;
            this.srcbounds = scale(new Rectangle(x, y, width, height));
            this.usrwidth = usrWidth;
            this.usrheight = usrHeight;
        }

        Rectangle scale(Rectangle r) {
            int x = r.x;
            r.x = (int)Math.round(x * scaleX);
            int y = r.y;
            r.y = (int)Math.round(y * scaleY);
            r.width = (int)Math.round(r.width * scaleX);
            r.height = (int)Math.round(r.height * scaleY);
            return r;
        }

        BufferData copyWithBounds(int x, int y, int width, int height,
                                  float usrWidth, float usrHeight)
        {
            return new BufferData(this.srcbuffer, this.linestride,
                                 x, y, width, height,
                                 usrWidth, usrHeight, this.scaleX, this.scaleY);
        }
    }

    private static class RenderData {
        final BufferData bdata;
        final Rectangle dirtyRect;
        final boolean clearTarget;

        RenderData(BufferData bdata,
                   int dirtyX, int dirtyY, int dirtyWidth, int dirtyHeight,
                   boolean clearTarget)
        {
            this(bdata, dirtyX, dirtyY, dirtyWidth, dirtyHeight, clearTarget, true);
        }

        RenderData(BufferData bdata,
                   int dirtyX, int dirtyY, int dirtyWidth, int dirtyHeight,
                   boolean clearTarget, boolean applyScale)
        {
            this.bdata = bdata;
            Rectangle r = new Rectangle(dirtyX, dirtyY, dirtyWidth, dirtyHeight);
            this.dirtyRect = applyScale ? bdata.scale(r) : r;
            this.dirtyRect.intersectWith(bdata.srcbounds);
            this.clearTarget = clearTarget;
        }

        RenderData copyAddDirtyRect(int dirtyX, int dirtyY, int dirtyWidth, int dirtyHeight) {

            Rectangle r = bdata.scale(new Rectangle(dirtyX, dirtyY, dirtyWidth, dirtyHeight));
            r.add(this.dirtyRect);
            return new RenderData(this.bdata, r.x, r.y, r.width, r.height,
                                  this.clearTarget, false);
        }
    }

    public void setImageBuffer(Buffer buffer,
                               int x, int y, int width, int height,
                               float usrWidth, float usrHeight,
                               int linestride,
                               double scaleX, double scaleY)
    {
        bufferData = new BufferData(buffer, linestride, x, y, width, height,
                                           usrWidth, usrHeight, scaleX, scaleY);
        renderData.set(new RenderData(bufferData, x, y, width, height, true));
    }

    public void setImageBounds(final int x, final int y, final int width, final int height,
                               final float usrWidth, final float usrHeight)
    {

        final boolean shrinked = width &lt; bufferData.usrwidth || height &lt; bufferData.usrheight;

        bufferData = bufferData.copyWithBounds(x, y, width, height, usrWidth, usrHeight);
        renderData.updateAndGet(prev -&gt; {
            boolean clearTarget = (prev != null ? prev.clearTarget : false);
            return new RenderData(bufferData, x, y, width, height, clearTarget | shrinked);
        });
    }

    public void repaintDirtyRegion(final int dirtyX, final int dirtyY,
                                   final int dirtyWidth, final int dirtyHeight)
    {
        renderData.updateAndGet(prev -&gt; {
            if (prev != null) {
                return prev.copyAddDirtyRect(dirtyX, dirtyY, dirtyWidth, dirtyHeight);
            } else {
                return new RenderData(bufferData, dirtyX, dirtyY, dirtyWidth, dirtyHeight, false);
            }
        });
    }

    public void markContentDirty() {
        visualsChanged();
    }

    @Override
    protected boolean hasOverlappingContents() {  return false; }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/tk/Toolkit.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.tk;

import javafx.application.ConditionalFeature;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.geometry.Dimension2D;
import javafx.scene.Scene;
import javafx.scene.effect.BlurType;
import javafx.scene.image.Image;
import javafx.scene.image.PixelFormat;
import javafx.scene.image.WritableImage;
import javafx.scene.input.Dragboard;
import javafx.scene.input.InputMethodRequests;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.TransferMode;
import javafx.scene.paint.Color;
import javafx.scene.paint.ImagePattern;
import javafx.scene.paint.LinearGradient;
import javafx.scene.paint.Paint;
import javafx.scene.paint.RadialGradient;
import javafx.scene.paint.Stop;
import javafx.scene.shape.PathElement;
import javafx.scene.shape.SVGPath;
import javafx.scene.shape.StrokeLineCap;
import javafx.scene.shape.StrokeLineJoin;
import javafx.scene.shape.StrokeType;
import javafx.stage.FileChooser.ExtensionFilter;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Future;
import com.sun.glass.ui.CommonDialogs.FileChooserResult;
import com.sun.glass.ui.GlassRobot;
import com.sun.glass.utils.NativeLibLoader;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.beans.event.AbstractNotifyListener;
import com.sun.javafx.embed.HostInterface;
import com.sun.javafx.geom.Path2D;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.perf.PerformanceTracker;
import com.sun.javafx.runtime.VersionInfo;
import com.sun.javafx.runtime.async.AsyncOperation;
import com.sun.javafx.runtime.async.AsyncOperationListener;
import com.sun.javafx.scene.SceneHelper;
import com.sun.javafx.scene.text.TextLayoutFactory;
import com.sun.javafx.sg.prism.NGCamera;
import com.sun.javafx.sg.prism.NGLightBase;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.util.Utils;
import com.sun.scenario.DelayedRunnable;
import com.sun.scenario.animation.AbstractMasterTimer;
import com.sun.scenario.effect.AbstractShadow.ShadowMode;
import com.sun.scenario.effect.Color4f;
import com.sun.scenario.effect.FilterContext;
import com.sun.scenario.effect.Filterable;


public abstract class Toolkit {
    private static String tk;
    private static Toolkit TOOLKIT;
    private static Thread fxUserThread = null;

    private static final String QUANTUM_TOOLKIT     = &quot;com.sun.javafx.tk.quantum.QuantumToolkit&quot;;
    private static final String DEFAULT_TOOLKIT     = QUANTUM_TOOLKIT;

    private static final Map gradientMap = new WeakHashMap();

    private static final boolean verbose = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.verbose&quot;));

    private static final String[] msLibNames = {
        &quot;api-ms-win-core-console-l1-1-0&quot;,
        &quot;api-ms-win-core-datetime-l1-1-0&quot;,
        &quot;api-ms-win-core-debug-l1-1-0&quot;,
        &quot;api-ms-win-core-errorhandling-l1-1-0&quot;,
        &quot;api-ms-win-core-file-l1-1-0&quot;,
        &quot;api-ms-win-core-file-l1-2-0&quot;,
        &quot;api-ms-win-core-file-l2-1-0&quot;,
        &quot;api-ms-win-core-handle-l1-1-0&quot;,
        &quot;api-ms-win-core-heap-l1-1-0&quot;,
        &quot;api-ms-win-core-interlocked-l1-1-0&quot;,
        &quot;api-ms-win-core-libraryloader-l1-1-0&quot;,
        &quot;api-ms-win-core-localization-l1-2-0&quot;,
        &quot;api-ms-win-core-memory-l1-1-0&quot;,
        &quot;api-ms-win-core-namedpipe-l1-1-0&quot;,
        &quot;api-ms-win-core-processenvironment-l1-1-0&quot;,
        &quot;api-ms-win-core-processthreads-l1-1-0&quot;,
        &quot;api-ms-win-core-processthreads-l1-1-1&quot;,
        &quot;api-ms-win-core-profile-l1-1-0&quot;,
        &quot;api-ms-win-core-rtlsupport-l1-1-0&quot;,
        &quot;api-ms-win-core-string-l1-1-0&quot;,
        &quot;api-ms-win-core-synch-l1-1-0&quot;,
        &quot;api-ms-win-core-synch-l1-2-0&quot;,
        &quot;api-ms-win-core-sysinfo-l1-1-0&quot;,
        &quot;api-ms-win-core-timezone-l1-1-0&quot;,
        &quot;api-ms-win-core-util-l1-1-0&quot;,
        &quot;api-ms-win-crt-conio-l1-1-0&quot;,
        &quot;api-ms-win-crt-convert-l1-1-0&quot;,
        &quot;api-ms-win-crt-environment-l1-1-0&quot;,
        &quot;api-ms-win-crt-filesystem-l1-1-0&quot;,
        &quot;api-ms-win-crt-heap-l1-1-0&quot;,
        &quot;api-ms-win-crt-locale-l1-1-0&quot;,
        &quot;api-ms-win-crt-math-l1-1-0&quot;,
        &quot;api-ms-win-crt-multibyte-l1-1-0&quot;,
        &quot;api-ms-win-crt-private-l1-1-0&quot;,
        &quot;api-ms-win-crt-process-l1-1-0&quot;,
        &quot;api-ms-win-crt-runtime-l1-1-0&quot;,
        &quot;api-ms-win-crt-stdio-l1-1-0&quot;,
        &quot;api-ms-win-crt-string-l1-1-0&quot;,
        &quot;api-ms-win-crt-time-l1-1-0&quot;,
        &quot;api-ms-win-crt-utility-l1-1-0&quot;,
        &quot;ucrtbase&quot;,

        // Finally load VS 2017 DLLs in the following order
        &quot;vcruntime140&quot;,
        &quot;msvcp140&quot;,
        &quot;concrt140&quot;
};

    private static String lookupToolkitClass(String name) {
        if (&quot;prism&quot;.equalsIgnoreCase(name)) {
            return QUANTUM_TOOLKIT;
        } else if (&quot;quantum&quot;.equalsIgnoreCase(name)) {
            return QUANTUM_TOOLKIT;
        }
        return name;
    }

    public static synchronized void loadMSWindowsLibraries() {
        for (String libName : msLibNames) {
            try {
                NativeLibLoader.loadLibrary(libName);
            } catch (Throwable t) {
                if (verbose) {
                    System.err.println(&quot;Error: failed to load &quot;
                            + libName + &quot;.dll : &quot; + t);
                }
            }
        }
    }

    private static String getDefaultToolkit() {
        if (PlatformUtil.isWindows()) {
            return DEFAULT_TOOLKIT;
        } else if (PlatformUtil.isMac()) {
            return DEFAULT_TOOLKIT;
        } else if (PlatformUtil.isLinux()) {
            return DEFAULT_TOOLKIT;
        } else if (PlatformUtil.isIOS()) {
            return DEFAULT_TOOLKIT;
        } else if (PlatformUtil.isAndroid()) {
           return DEFAULT_TOOLKIT;
        }

        throw new UnsupportedOperationException(System.getProperty(&quot;os.name&quot;) + &quot; is not supported&quot;);
    }

    public static synchronized Toolkit getToolkit() {
        if (TOOLKIT != null) {
            return TOOLKIT;
        }

        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
            // Get the javafx.version and javafx.runtime.version from a preconstructed
            // java class, VersionInfo, created at build time.
            VersionInfo.setupSystemProperties();
            return null;
        });

        // This loading of msvcp140.dll and vcruntime140.dll (VS2017) is required on Windows platforms
        if (PlatformUtil.isWindows()) {
            loadMSWindowsLibraries();
        }

        boolean userSpecifiedToolkit = true;

        // Check a system property to see if there is a specific toolkit to use.
        // This is not a doPriviledged check so that applets cannot use this.
        String forcedToolkit = null;
        try {
            forcedToolkit = System.getProperty(&quot;javafx.toolkit&quot;);
        } catch (SecurityException ex) {}

        if (forcedToolkit == null) {
            forcedToolkit = tk;
        }
        if (forcedToolkit == null) {
            userSpecifiedToolkit = false;
            forcedToolkit = getDefaultToolkit();
        }

        if (forcedToolkit.indexOf('.') == -1) {
            // Turn a short name into a fully qualified classname
            forcedToolkit = lookupToolkitClass(forcedToolkit);
        }

        boolean printToolkit = verbose
                || (userSpecifiedToolkit &amp;&amp; !forcedToolkit.endsWith(&quot;StubToolkit&quot;));

        try {
            Class clz = null;

            try {
                // try our priveledged loader first
                final ClassLoader loader = Toolkit.class.getClassLoader();
                clz = Class.forName(forcedToolkit, false, loader);
            } catch (ClassNotFoundException e) {
                // fall back and try the application class loader
                final ClassLoader loader = Thread.currentThread().getContextClassLoader();
                clz = Class.forName(forcedToolkit, false, loader);
            }

            // Check that clz is a subclass of Toolkit
            if (!Toolkit.class.isAssignableFrom(clz)) {
                throw new IllegalArgumentException(&quot;Unrecognized FX Toolkit class: &quot;
                        + forcedToolkit);
            }

            TOOLKIT = (Toolkit)clz.newInstance();
            if (TOOLKIT.init()) {
                if (printToolkit) {
                    System.err.println(&quot;JavaFX: using &quot; + forcedToolkit);
                }
                return TOOLKIT;
            }
            TOOLKIT = null;
        } catch (Exception any) {
            TOOLKIT = null;
            any.printStackTrace();
        }

        throw new RuntimeException(&quot;No toolkit found&quot;);
    }

    protected static Thread getFxUserThread() {
        return fxUserThread;
    }

    protected static void setFxUserThread(Thread t) {
        if (fxUserThread != null) {
            throw new IllegalStateException(&quot;Error: FX User Thread already initialized&quot;);
        }

        fxUserThread = t;
    }

    public void checkFxUserThread() {
        // Throw exception if not on FX user thread
        if (!isFxUserThread()) {
            throw new IllegalStateException(&quot;Not on FX application thread; currentThread = &quot;
                    + Thread.currentThread().getName());
        }
    }

    // Toolkit can override this if needed
    public boolean isFxUserThread() {
        return Thread.currentThread() == fxUserThread;
    }

    protected Toolkit() {
    }

    public abstract boolean init();

    /**
     * Indicates whether or not a nested event loop can be started
     * from the current thread in the current state. Note that a nested
     * event loop is not allowed outside of an event handler.
     *
     * @return flag indicating whether a nested event loop can be started.
     */
    public abstract boolean canStartNestedEventLoop();

    /**
     * Enter a nested event loop and block until the corresponding
     * exitNestedEventLoop call is made.
     * The key passed into this method is used to
     * uniquely identify the matched enter/exit pair. This method creates a
     * new nested event loop and blocks until the corresponding
     * exitNestedEventLoop method is called with the same key.
     * The return value of this method will be the {@code rval}
     * object supplied to the exitNestedEventLoop method call that unblocks it.
     *
     * @param key the Object that identifies the nested event loop, which
     * must not be null
     *
     * @throws IllegalArgumentException if the specified key is associated
     * with a nested event loop that has not yet returned
     *
     * @throws NullPointerException if the key is null
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the FX Application thread
     *
     * @return the value passed into the corresponding call to exitEventLoop
     */
    public abstract Object enterNestedEventLoop(Object key);

    /**
     * Exit a nested event loop and unblock the caller of the
     * corresponding enterNestedEventLoop.
     * The key passed into this method is used to
     * uniquely identify the matched enter/exit pair. This method causes the
     * nested event loop that was previously created with the key to exit and
     * return control to the caller. If the specified nested event loop is not
     * the inner-most loop then it will not return until all other inner loops
     * also exit.
     *
     * @param key the Object that identifies the nested event loop, which
     * must not be null
     *
     * @param rval an Object that is returned to the caller of the
     * corresponding enterNestedEventLoop. This may be null.
     *
     * @throws IllegalArgumentException if the specified key is not associated
     * with an active nested event loop
     *
     * @throws NullPointerException if the key is null
     *
     * @throws IllegalStateException if this method is called on a thread
     * other than the FX Application thread
     */
    public abstract void exitNestedEventLoop(Object key, Object rval);

    public abstract void exitAllNestedEventLoops();

    public abstract boolean isNestedLoopRunning();

    public abstract TKStage createTKStage(Window peerWindow, boolean securityDialog, StageStyle stageStyle, boolean primary, Modality modality, TKStage owner, boolean rtl, AccessControlContext acc);

    public abstract TKStage createTKPopupStage(Window peerWindow, StageStyle popupStyle, TKStage owner, AccessControlContext acc);
    public abstract TKStage createTKEmbeddedStage(HostInterface host, AccessControlContext acc);

    /**
     * Creates an AppletWindow using the provided window pointer as the parent
     * window.
     *
     * @param parent the native parent which will contain the primary stage
     * window(s). Used on Windows/Linux platforms.
     *
     * @param serverName the name of CARemoteLayerServer which
     * will be used to register native layer. Used on Mac platform.
     */
    public abstract AppletWindow createAppletWindow(long parent, String serverName);

    /**
     * Perform cleanup in preparation for applet termination, including closing
     * the applet window.
     */
    public abstract void closeAppletWindow();

    private final Map&lt;TKPulseListener,AccessControlContext&gt; stagePulseListeners =
            new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
    private final Map&lt;TKPulseListener,AccessControlContext&gt; scenePulseListeners =
            new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
    private final Map&lt;TKPulseListener,AccessControlContext&gt; postScenePulseListeners =
            new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
    private final Map&lt;TKListener,AccessControlContext&gt; toolkitListeners =
            new WeakHashMap&lt;TKListener,AccessControlContext&gt;();

    // The set of shutdown hooks is strongly held to avoid premature GC.
    private final Set&lt;Runnable&gt; shutdownHooks = new HashSet&lt;Runnable&gt;();

    private void runPulse(final TKPulseListener listener,
            final AccessControlContext acc) {

        if (acc == null) {
            throw new IllegalStateException(&quot;Invalid AccessControlContext&quot;);
        }

        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
<A NAME="5"></A>            listener.pulse();
            return null;
        }, acc);
    <FONT color="#c8c2a7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#5',2,'match49-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

    public void firePulse() {
        // Stages need to be notified of pulses before scenes so the Stage can resized
        // and those changes propogated to scene before it gets its pulse to update

        // Copy of listener map
        final Map&lt;TKPulseListener,AccessControlContext&gt; stagePulseList =
                new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
        final Map&lt;TKPulseListener,AccessControlContext&gt; scenePulseList =
                new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
        final Map&lt;TKPulseListener,AccessControlContext&gt; postScenePulseList =
                new</B></FONT> WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();

        synchronized (this) {
            stagePulseList.putAll(stagePulseListeners);
            scenePulseList.putAll(scenePulseListeners);
            postScenePulseList.putAll(postScenePulseListeners);
        }
        for (Map.Entry&lt;TKPulseListener,AccessControlContext&gt; entry : stagePulseList.entrySet()) {
            runPulse(entry.getKey(), entry.getValue());
        }
        for (Map.Entry&lt;TKPulseListener,AccessControlContext&gt; entry : scenePulseList.entrySet()) {
            runPulse(entry.getKey(), entry.getValue());
        }
        for (Map.Entry&lt;TKPulseListener,AccessControlContext&gt; entry : postScenePulseList.entrySet()) {
            runPulse(entry.getKey(), entry.getValue());
        }

        if (lastTkPulseListener != null) {
            runPulse(lastTkPulseListener, lastTkPulseAcc);
        }
    }
    public void addStageTkPulseListener(TKPulseListener listener) {
        if (listener == null) {
            return;
        }
        synchronized (this) {
            AccessControlContext acc = AccessController.getContext();
            stagePulseListeners.put(listener, acc);
        }
    }
    public void removeStageTkPulseListener(TKPulseListener listener) {
        synchronized (this) {
            stagePulseListeners.remove(listener);
        }
    }
    public void addSceneTkPulseListener(TKPulseListener listener) {
        if (listener == null) {
            return;
        }
        synchronized (this) {
            AccessControlContext acc = AccessController.getContext();
            scenePulseListeners.put(listener, acc);
        }
    }
    public void removeSceneTkPulseListener(TKPulseListener listener) {
        synchronized (this) {
            scenePulseListeners.remove(listener);
        }
    }
    public void addPostSceneTkPulseListener(TKPulseListener listener) {
        if (listener == null) {
            return;
        }
        synchronized (this) {
            AccessControlContext acc = AccessController.getContext();
            postScenePulseListeners.put(listener, acc);
        }
    }
    public void removePostSceneTkPulseListener(TKPulseListener listener) {
        synchronized (this) {
            postScenePulseListeners.remove(listener);
        }
    }

    public void addTkListener(TKListener listener) {
        if (listener == null) {
            return;
        }
        AccessControlContext acc = AccessController.getContext();
        toolkitListeners.put(listener, acc);
    }

    public void removeTkListener(TKListener listener) {
        toolkitListeners.remove(listener);
    }

    private TKPulseListener lastTkPulseListener = null;
    private AccessControlContext lastTkPulseAcc = null;
    public void setLastTkPulseListener(TKPulseListener listener) {
        lastTkPulseAcc = AccessController.getContext();
        lastTkPulseListener = listener;
    }

    public void addShutdownHook(Runnable hook) {
        if (hook == null) {
            return;
        }
        synchronized (shutdownHooks) {
            shutdownHooks.add(hook);
        }
    }

    public void removeShutdownHook(Runnable hook) {
        synchronized (shutdownHooks) {
            shutdownHooks.remove(hook);
        }
    }

    protected void notifyShutdownHooks() {
        List&lt;Runnable&gt; hooks;
        synchronized (shutdownHooks) {
            hooks = new ArrayList&lt;Runnable&gt;(shutdownHooks);
            shutdownHooks.clear();
        }

        for (Runnable hook : hooks) {
            hook.run();
        }
    }

    public void notifyWindowListeners(final List&lt;TKStage&gt; windows) {
        for (Map.Entry&lt;TKListener,AccessControlContext&gt; entry : toolkitListeners.entrySet()) {
            final TKListener listener = entry.getKey();
            final AccessControlContext acc = entry.getValue();
            if (acc == null) {
                throw new IllegalStateException(&quot;Invalid AccessControlContext&quot;);
            }

            AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                listener.changedTopLevelWindows(windows);
                return null;
            }, acc);
        }
    }

    public void notifyLastNestedLoopExited() {
        for (TKListener listener: toolkitListeners.keySet()) {
            listener.exitedLastNestedLoop();
        }
    }

    // notify the pulse timer code that we need the next pulse to happen
    // this flag is cleared each cycle so subsequent pulses must be requested
    public abstract void requestNextPulse();

    public abstract Future addRenderJob(RenderJob rj);

    public abstract ImageLoader loadImage(String url,
                                          double width, double height,
                                          boolean preserveRatio,
                                          boolean smooth);
    public abstract ImageLoader loadImage(InputStream stream,
                                          double width, double height,
                                          boolean preserveRatio,
                                          boolean smooth);
    public abstract AsyncOperation loadImageAsync(
                                          AsyncOperationListener&lt;? extends ImageLoader&gt; listener,
                                          String url,
                                          double width, double height,
                                          boolean preserveRatio,
                                          boolean smooth);

    /*
     * The loadPlatformImage method supports the following image types:
     *   - an object returned by the renderToImage method
     *   - an instance of com.sun.prism.Image (in case of prism)
     *   - an instance of an external image object, which can be a BufferedImage
     * If JavaFX Image had one more constructor Image(ImageLoader),
     * we could introduce a different method for external image loading support.
     */

    public abstract ImageLoader loadPlatformImage(Object platformImage);

    public abstract PlatformImage createPlatformImage(int w, int h);

    // Indicates the default state of smooth for ImageView and MediaView
    // Subclasses may override this to provide a platform-specific default
    public boolean getDefaultImageSmooth() { return true; }

    public abstract void startup(Runnable runnable);
    public abstract void defer(Runnable runnable);
    public void exit() {
        fxUserThread = null;
    }

    public abstract Map&lt;Object, Object&gt; getContextMap();
    public abstract int getRefreshRate();
    public abstract void setAnimationRunnable(DelayedRunnable animationRunnable);
    public abstract PerformanceTracker getPerformanceTracker();
    public abstract PerformanceTracker createPerformanceTracker();

    //to be used for testing only
    public abstract void waitFor(Task t);

    private Object checkSingleColor(List&lt;Stop&gt; stops) {
        if (stops.size() == 2) {
            Color c = stops.get(0).getColor();
            if (c.equals(stops.get(1).getColor())) {
                return Toolkit.getPaintAccessor().getPlatformPaint(c);
            }
        }
        return null;
    }

    private Object getPaint(LinearGradient paint) {
        Object p = gradientMap.get(paint);
        if (p != null) {
            return p;
        }
        p = checkSingleColor(paint.getStops());
        if (p == null) {
            p = createLinearGradientPaint(paint);
        }
        gradientMap.put(paint, p);
        return p;
    }

    private Object getPaint(RadialGradient paint) {
        Object p = gradientMap.get(paint);
        if (p != null) {
            return p;
        }
        p = checkSingleColor(paint.getStops());
        if (p == null) {
            p = createRadialGradientPaint(paint);
        }
        gradientMap.put(paint, p);
        return p;
    }

    public Object getPaint(Paint paint) {
        if (paint instanceof Color) {
            return createColorPaint((Color) paint);
        }

        if (paint instanceof LinearGradient) {
            return getPaint((LinearGradient) paint);
        }

        if (paint instanceof RadialGradient) {
            return getPaint((RadialGradient) paint);
        }

        if (paint instanceof ImagePattern) {
            return createImagePatternPaint((ImagePattern) paint);
        }

        return null;
    }

    protected static final double clampStopOffset(double offset) {
        return (offset &gt; 1.0) ? 1.0 :
               (offset &lt; 0.0) ? 0.0 : offset;
    }

    protected abstract Object createColorPaint(Color paint);
    protected abstract Object createLinearGradientPaint(LinearGradient paint);
    protected abstract Object createRadialGradientPaint(RadialGradient paint);
    protected abstract Object createImagePatternPaint(ImagePattern paint);

    public abstract void
        accumulateStrokeBounds(com.sun.javafx.geom.Shape shape,
                               float bbox[],
                               StrokeType type,
                               double strokewidth,
                               StrokeLineCap cap,
                               StrokeLineJoin join,
                               float miterLimit,
                               BaseTransform tx);

    public abstract boolean
        strokeContains(com.sun.javafx.geom.Shape shape,
                       double x, double y,
                       StrokeType type,
                       double strokewidth,
                       StrokeLineCap cap,
                       StrokeLineJoin join,
                       float miterLimit);

    public abstract com.sun.javafx.geom.Shape
        createStrokedShape(com.sun.javafx.geom.Shape shape,
                           StrokeType type,
                           double strokewidth,
                           StrokeLineCap cap,
                           StrokeLineJoin join,
                           float miterLimit,
                           float[] dashArray,
                           float dashOffset);

    public abstract int getKeyCodeForChar(String character);
    public abstract Dimension2D getBestCursorSize(int preferredWidth, int preferredHeight);
    public abstract int getMaximumCursorColors();
    public abstract PathElement[] convertShapeToFXPath(Object shape);

    public abstract Filterable toFilterable(Image img);
    public abstract FilterContext getFilterContext(Object config);

    public abstract boolean isForwardTraversalKey(KeyEvent e);
    public abstract boolean isBackwardTraversalKey(KeyEvent e);

    public abstract AbstractMasterTimer getMasterTimer();

    public abstract FontLoader getFontLoader();
    public abstract TextLayoutFactory getTextLayoutFactory();

    public abstract Object createSVGPathObject(SVGPath svgpath);
    public abstract Path2D createSVGPath2D(SVGPath svgpath);

    /**
     * Tests whether the pixel on the given coordinates in the given image
     * is non-empty (not fully transparent). Return value is not defined
     * for pixels out of the image bounds.
     */
    public abstract boolean imageContains(Object image, float x, float y);

    public abstract TKClipboard getSystemClipboard();

    public TKClipboard createLocalClipboard() {
        return new LocalClipboard();
    }

    public abstract TKSystemMenu getSystemMenu();

    public abstract TKClipboard getNamedClipboard(String name);

    public boolean isSupported(ConditionalFeature feature) { return false; }

    public boolean isMSAASupported() { return false; }

    public abstract ScreenConfigurationAccessor setScreenConfigurationListener(TKScreenConfigurationListener listener);

    public abstract Object getPrimaryScreen();

    public abstract List&lt;?&gt; getScreens();

    public abstract ScreenConfigurationAccessor getScreenConfigurationAccessor();

    public abstract void registerDragGestureListener(TKScene s, Set&lt;TransferMode&gt; tm, TKDragGestureListener l);

    /**
     * This function is called when a drag originates within a JavaFX application.
     * This means that drags that originate in other applications / from the OS
     * do not call this function.
     * The argument o represents an object used to identify a scene on which
     * the drag has started.
     */
    public abstract void startDrag(TKScene scene, Set&lt;TransferMode&gt; tm, TKDragSourceListener l, Dragboard dragboard);

    // template function which can be implemented by toolkit impls such that they
    // can be informed when a drag and drop operation has completed. This allows
    // for any cleanup that may need to be done.
    public void stopDrag(Dragboard dragboard) {
        // no-op
    }

    public abstract void enableDrop(TKScene s, TKDropTargetListener l);

    public interface Task {
        boolean isFinished();
    }

    public Color4f toColor4f(Color color) {
        return new Color4f((float)color.getRed(), (float)color.getGreen(), (float)color.getBlue(), (float)color.getOpacity());
    }


    public ShadowMode toShadowMode(BlurType blurType) {
        switch (blurType) {
            case ONE_PASS_BOX:
                return ShadowMode.ONE_PASS_BOX;
            case TWO_PASS_BOX:
                return ShadowMode.TWO_PASS_BOX;
            case THREE_PASS_BOX:
                return ShadowMode.THREE_PASS_BOX;
            default:
                return ShadowMode.GAUSSIAN;
        }
    }

    public abstract void installInputMethodRequests(TKScene scene, InputMethodRequests requests);

    /*
     * ImageRenderingContext holds the many parameters passed to
     * the renderToImage method.
     * The use of the parameters is specified by the renderToImage
     * method.
     * @see #renderToImage
     */
    public static class ImageRenderingContext {
        // Node to be rendered
        public NGNode root;

        // Viewport for rendering
        public int x;
        public int y;
        public int width;
        public int height;

        // Initial transform for root node
        public BaseTransform transform;

        // Rendering parameters either from Scene or SnapShotParams
        public boolean depthBuffer;
        public Object platformPaint;
        public NGCamera camera;
        public NGLightBase[] lights;

        // PlatformImage into which to render or null
        public Object platformImage;
    }

    /*
     * This method renders a PG-graph to a platform image object.
     * The returned object can be turned into a useable
     * scene graph image using the appropriate factor of the
     * Image class.
     * The scale specified in the params is used to scale the
     * entire rendering before any transforms in the nodes are
     * applied.
     * The width and height specified in the params represent
     * the user space dimensions to be rendered.  The returned
     * image will be large enough to hold these dimensions
     * scaled by the scale parameter.
     * The depthBuffer specified in the params is used to determine
     * with or without depthBuffer rendering should be performed.
     * The root node is the root of a tree of toolkit-specific
     * scene graph peer nodes to be rendered and should have
     * been previously created by this toolkit.
     * The platformPaint specified in the params must be
     * generated by the appropriate Toolkit.createPaint method
     * and is used to fill the background of the image before
     * rendering the scene graph.
     * The platformImage specified in the params may be non-null
     * and should be a previous return value from this method.
     * If it is non-null then it may be reused as the return value
     * of this method if it is still valid and large enough to
     * hold the requested size.
     *
     * @param context a ImageRenderingContext instance specifying
     *               the various rendering parameters
     * @return a platform specific image object
     * @see Toolkit.getImageAccessor().fromPlatformImage
     */

    public abstract Object renderToImage(ImageRenderingContext context);

    /**
     * Returns the key code for the key which is commonly used on the
     * corresponding platform as a modifier key in shortcuts. For example
     * it is {@code KeyCode.CONTROL} on Windows (Ctrl + C, Ctrl + V ...) and
     * {@code KeyCode.META} on MacOS (Cmd + C, Cmd + V ...).
     *
     * @return the key code for shortcut modifier key
     */
    public KeyCode getPlatformShortcutKey() {
        return PlatformUtil.isMac() ? KeyCode.META : KeyCode.CONTROL;
    }

    public abstract FileChooserResult showFileChooser(
            TKStage ownerWindow,
            String title,
            File initialDirectory,
            String initialFileName,
            FileChooserType fileChooserType,
            List&lt;ExtensionFilter&gt; extensionFilters,
            ExtensionFilter selectedFilter);

    public abstract File showDirectoryChooser(
            TKStage ownerWindow,
            String title,
            File initialDirectory);

    /*
     * Methods for obtaining &quot;double-click&quot; speed value.
     */
    public abstract long getMultiClickTime();
    public abstract int getMultiClickMaxX();
    public abstract int getMultiClickMaxY();

    private CountDownLatch pauseScenesLatch = null;

    public interface WritableImageAccessor {
        public void loadTkImage(WritableImage wimg, Object loader);
        public Object getTkImageLoader(WritableImage wimg);
    }

    private static WritableImageAccessor writableImageAccessor = null;

    public static void setWritableImageAccessor(WritableImageAccessor accessor) {
        writableImageAccessor = accessor;
    }

    public static WritableImageAccessor getWritableImageAccessor() {
        return writableImageAccessor;
    }

    public interface PaintAccessor {
        public boolean isMutable(Paint paint);
        public Object getPlatformPaint(Paint paint);
        public void addListener(Paint paint, AbstractNotifyListener platformChangeListener);
        public void removeListener(Paint paint, AbstractNotifyListener platformChangeListener);
    }

    private static PaintAccessor paintAccessor = null;

    public static void setPaintAccessor(PaintAccessor accessor) {
        paintAccessor = accessor;
    }

    public static PaintAccessor getPaintAccessor() {
        return paintAccessor;
    }

    public interface ImageAccessor {
        public boolean isAnimation(Image image);
        public ReadOnlyObjectProperty&lt;PlatformImage&gt;getImageProperty(Image image);
        public int[] getPreColors(PixelFormat&lt;ByteBuffer&gt; pf);
        public int[] getNonPreColors(PixelFormat&lt;ByteBuffer&gt; pf);
        public Object getPlatformImage(Image image);
        public Image fromPlatformImage(Object image);
    }

    private static ImageAccessor imageAccessor;

    static {
        // Need to ensure that the Image class is loaded since Toolkit class
        // is the provider of getImageAccessor method and sets the accessor.
        Utils.forceInit(Image.class);
    }

    public static void setImageAccessor(ImageAccessor accessor) {
        imageAccessor = accessor;
    }

    public static ImageAccessor getImageAccessor() {
        return imageAccessor;
    }

    public String getThemeName() {
        return null;
    }

    public abstract GlassRobot createRobot();
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/javafx/tk/quantum/WindowStage.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.javafx.tk.quantum;

import java.nio.ByteBuffer;
import java.security.AccessController;
import java.security.Permission;
import java.security.PrivilegedAction;
import java.security.AccessControlContext;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import javafx.scene.input.KeyCombination;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

import com.sun.glass.events.WindowEvent;
import com.sun.glass.ui.*;
import com.sun.glass.ui.Window.Level;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.iio.common.PushbroomScaler;
import com.sun.javafx.iio.common.ScalerFactory;
import com.sun.javafx.tk.FocusCause;
import com.sun.javafx.tk.TKScene;
import com.sun.javafx.tk.TKStage;
import com.sun.prism.Image;
import com.sun.prism.PixelFormat;
import java.util.Locale;
import java.util.ResourceBundle;
import static com.sun.javafx.FXPermissions.*;

class WindowStage extends GlassStage {

    protected Window platformWindow;

    protected javafx.stage.Stage fxStage;

    private StageStyle style;
    private GlassStage owner = null;
    private Modality modality = Modality.NONE;
    private final boolean securityDialog;

    private OverlayWarning warning = null;
    private boolean rtl = false;
    private boolean transparent = false;
    private boolean isPrimaryStage = false;
    private boolean isAppletStage = false; // true if this is an embedded applet window
    private boolean isPopupStage = false;
    private boolean isInFullScreen = false;
    private boolean isAlwaysOnTop = false;

    // A flag to indicate whether a call was generated from
    // an allowed input event handler.
    private boolean inAllowedEventHandler = false;

    // An active window is visible &amp;&amp; enabled &amp;&amp; focusable.
    // The list is maintained in the z-order, so that the last element
    // represents the topmost window (or more accurately, the last
    // focused window, which we assume is very close to the last topmost one).
    private static List&lt;WindowStage&gt; activeWindows = new LinkedList&lt;&gt;();

    private static Map&lt;Window, WindowStage&gt; platformWindows = new HashMap&lt;&gt;();

    private static GlassAppletWindow appletWindow = null;
    static void setAppletWindow(GlassAppletWindow aw) {
        appletWindow = aw;
    }
    static GlassAppletWindow getAppletWindow() {
        return appletWindow;
    }

    private static final Locale LOCALE = Locale.getDefault();

    private static final ResourceBundle RESOURCES =
        ResourceBundle.getBundle(WindowStage.class.getPackage().getName() +
                                 &quot;.QuantumMessagesBundle&quot;, LOCALE);


    public WindowStage(javafx.stage.Window peerWindow, boolean securityDialog, final StageStyle stageStyle, Modality modality, TKStage owner) {
        this.style = stageStyle;
        this.owner = (GlassStage)owner;
        this.modality = modality;
        this.securityDialog = securityDialog;

        if (peerWindow instanceof javafx.stage.Stage) {
            fxStage = (Stage)peerWindow;
        } else {
            fxStage = null;
        }

        transparent = stageStyle == StageStyle.TRANSPARENT;
        if (owner == null) {
            if (this.modality == Modality.WINDOW_MODAL) {
                this.modality = Modality.NONE;
            }
        }
    }

    final void setIsPrimary() {
        isPrimaryStage = true;
        if (appletWindow != null) {
            // this is an embedded applet stage
            isAppletStage = true;
        }
    }

    final void setIsPopup() {
        isPopupStage = true;
    }

    final boolean isSecurityDialog() {
        return securityDialog;
    }

    // Called by QuantumToolkit, so we can override initPlatformWindow in subclasses
    public final WindowStage init(GlassSystemMenu sysmenu) {
        initPlatformWindow();
        platformWindow.setEventHandler(new GlassWindowEventHandler(this));
        if (sysmenu.isSupported()) {
            sysmenu.createMenuBar();
            platformWindow.setMenuBar(sysmenu.getMenuBar());
        }
        return this;
    }

    private void initPlatformWindow() {
        if (platformWindow == null) {
            Application app = Application.GetApplication();
            if (isPrimaryStage &amp;&amp; (null != appletWindow)) {
                platformWindow = app.createWindow(appletWindow.getGlassWindow().getNativeWindow());
            } else {
                Window ownerWindow = null;
                if (owner instanceof WindowStage) {
                    ownerWindow = ((WindowStage)owner).platformWindow;
                }
                boolean resizable = false;
                boolean focusable = true;
                int windowMask = rtl ? Window.RIGHT_TO_LEFT : 0;
                if (isPopupStage) { // TODO: make it a stage style?
                    windowMask |= Window.POPUP;
                    if (style == StageStyle.TRANSPARENT) {
                        windowMask |= Window.TRANSPARENT;
                    }
                    focusable = false;
                } else {
                    switch (style) {
                        case UNIFIED:
                            if (app.supportsUnifiedWindows()) {
                                windowMask |= Window.UNIFIED;
                            }
                            // fall through
                        case DECORATED:
                            windowMask |=
                                Window.TITLED | Window.CLOSABLE |
                                Window.MINIMIZABLE | Window.MAXIMIZABLE;
                            if (ownerWindow != null || modality != Modality.NONE) {
                                windowMask &amp;=
                                    ~(Window.MINIMIZABLE | Window.MAXIMIZABLE);
                            }
                            resizable = true;
                            break;
                        case UTILITY:
                            windowMask |=  Window.TITLED | Window.UTILITY | Window.CLOSABLE;
                            break;
                        default:
                            windowMask |=
                                    (transparent ? Window.TRANSPARENT : Window.UNTITLED) | Window.CLOSABLE;
                            break;
                    }
                }
                platformWindow =
                        app.createWindow(ownerWindow, Screen.getMainScreen(), windowMask);
                platformWindow.setResizable(resizable);
                platformWindow.setFocusable(focusable);
                if (securityDialog) {
                    platformWindow.setLevel(Window.Level.FLOATING);
                }
                if (fxStage != null &amp;&amp; fxStage.getScene() != null) {
                    javafx.scene.paint.Paint paint = fxStage.getScene().getFill();
                    if (paint instanceof javafx.scene.paint.Color) {
                        javafx.scene.paint.Color color = (javafx.scene.paint.Color) paint;
                        platformWindow.setBackground((float) color.getRed(), (float) color.getGreen(), (float) color.getBlue());
                    } else if (paint instanceof javafx.scene.paint.LinearGradient) {
                        javafx.scene.paint.LinearGradient lgradient = (javafx.scene.paint.LinearGradient) paint;
                        computeAndSetBackground(lgradient.getStops());
                    } else if (paint instanceof javafx.scene.paint.RadialGradient) {
                        javafx.scene.paint.RadialGradient rgradient = (javafx.scene.paint.RadialGradient) paint;
                        computeAndSetBackground(rgradient.getStops());
                    }
                }

            }
        }
        platformWindows.put(platformWindow, this);
    }

    private void computeAndSetBackground(List&lt;javafx.scene.paint.Stop&gt; stops) {
        if (stops.size() == 1) {
            javafx.scene.paint.Color color = stops.get(0).getColor();
            platformWindow.setBackground((float) color.getRed(),
                    (float) color.getGreen(), (float) color.getBlue());
        } else if (stops.size() &gt; 1) {
            // A simple attempt to find a reasonable average color that is
            // within the stops arrange.
            javafx.scene.paint.Color color = stops.get(0).getColor();
            javafx.scene.paint.Color color2 = stops.get(stops.size() - 1).getColor();
            platformWindow.setBackground((float) ((color.getRed() + color2.getRed()) / 2.0),
                    (float) ((color.getGreen() + color2.getGreen()) / 2.0),
                    (float) ((color.getBlue() + color2.getBlue()) / 2.0));
        }
    }

    final Window getPlatformWindow() {
        return platformWindow;
    }

    static WindowStage findWindowStage(Window platformWindow) {
        return platformWindows.get(platformWindow);
    }

    protected GlassStage getOwner() {
        return owner;
    }

    protected ViewScene getViewScene() {
        return (ViewScene)getScene();
    }

    StageStyle getStyle() {
        return style;
    }

    @Override public TKScene createTKScene(boolean depthBuffer, boolean msaa, AccessControlContext acc) {
        ViewScene scene = new ViewScene(depthBuffer, msaa);
        scene.setSecurityContext(acc);
        return scene;
    }

    /**
     * Set the scene to be displayed in this stage
     *
     * @param scene The peer of the scene to be displayed
     */
    @Override public void setScene(TKScene scene) {
        GlassScene oldScene = getScene();
        if (oldScene == scene) {
            // Nothing to do
            return;
        }
        // RT-21465, RT-28490
        // We don't support scene changes in full-screen mode.
        exitFullScreen();
        super.setScene(scene);
        if (scene != null) {
            GlassScene newScene = getViewScene();
            View view = newScene.getPlatformView();
            QuantumToolkit.runWithRenderLock(() -&gt; {
                platformWindow.setView(view);
                if (oldScene != null) oldScene.updateSceneState();
                newScene.updateSceneState();
                return null;
            });
            requestFocus();
        } else {
            QuantumToolkit.runWithRenderLock(() -&gt; {
                // platformWindow can be null here, if this window is owned,
                // and its owner is being closed.
                if (platformWindow != null) {
                    platformWindow.setView(null);
                }
                if (oldScene != null) {
                    oldScene.updateSceneState();
                }
                return null;
            });
        }
        if (oldScene != null) {
            ViewPainter painter = ((ViewScene)oldScene).getPainter();
            QuantumRenderer.getInstance().disposePresentable(painter.presentable);   // latched on RT
        }
    }

    @Override public void setBounds(float x, float y, boolean xSet, boolean ySet,
                                    float w, float h, float cw, float ch,
                                    float xGravity, float yGravity,
                                    float renderScaleX, float renderScaleY)
    {
        if (renderScaleX &gt; 0.0 || renderScaleY &gt; 0.0) {
            // We set the render scale first since the call to setBounds()
            // below can induce a recursive update on the scales if it moves
            // the window to a new screen and we will then end up being called
            // back with a new scale.  We do not want to set these old scale
            // values after that recursion happens.
            if (renderScaleX &gt; 0.0) {
                platformWindow.setRenderScaleX(renderScaleX);
            }
            if (renderScaleY &gt; 0.0) {
                platformWindow.setRenderScaleY(renderScaleY);
            }
            ViewScene vscene = getViewScene();
            if (vscene != null) {
                vscene.updateSceneState();
                vscene.entireSceneNeedsRepaint();
            }
        }
        if (isAppletStage) {
            xSet = ySet = false;
        }
        if (xSet || ySet || w &gt; 0 || h &gt; 0 || cw &gt; 0 || ch &gt; 0) {
            platformWindow.setBounds(x, y, xSet, ySet, w, h, cw, ch, xGravity, yGravity);
        }
    }

    @Override
    public float getPlatformScaleX() {
        return platformWindow.getPlatformScaleX();
    }

    @Override
    public float getPlatformScaleY() {
        return platformWindow.getPlatformScaleY();
    }

    @Override
    public float getOutputScaleX() {
        return platformWindow.getOutputScaleX();
    }

    @Override
    public float getOutputScaleY() {
        return platformWindow.getOutputScaleY();
    }

    @Override public void setMinimumSize(int minWidth, int minHeight) {
        minWidth  = (int) Math.ceil(minWidth  * getPlatformScaleX());
        minHeight = (int) Math.ceil(minHeight * getPlatformScaleY());
        platformWindow.setMinimumSize(minWidth, minHeight);
    }

    @Override public void setMaximumSize(int maxWidth, int maxHeight) {
        maxWidth  = (int) Math.ceil(maxWidth  * getPlatformScaleX());
        maxHeight = (int) Math.ceil(maxHeight * getPlatformScaleY());
        platformWindow.setMaximumSize(maxWidth, maxHeight);
    }

    static Image findBestImage(java.util.List icons, int width, int height) {
        Image image = null;
        double bestSimilarity = 3; //Impossibly high value
        for (Object icon : icons) {
            //Iterate imageList looking for best matching image.
            //'Similarity' measure is defined as good scale factor and small insets.
            //best possible similarity is 0 (no scale, no insets).
            //It's found by experimentation that good-looking results are achieved
            //with scale factors x1, x3/4, x2/3, xN, x1/N.
            //Check to make sure the image/image format is correct.
            Image im = (Image)icon;
            if (im == null || !(im.getPixelFormat() == PixelFormat.BYTE_RGB ||
                im.getPixelFormat() == PixelFormat.BYTE_BGRA_PRE ||
                im.getPixelFormat() == PixelFormat.BYTE_GRAY))
            {
                continue;
            }

            int iw = im.getWidth();
            int ih = im.getHeight();

            if (iw &gt; 0 &amp;&amp; ih &gt; 0) {
                //Calc scale factor
                double scaleFactor = Math.min((double)width / (double)iw,
                                              (double)height / (double)ih);
                //Calculate scaled image dimensions
                //adjusting scale factor to nearest &quot;good&quot; value
                int adjw;
                int adjh;
                double scaleMeasure = 1; //0 - best (no) scale, 1 - impossibly bad
                if (scaleFactor &gt;= 2) {
                    //Need to enlarge image more than twice
                    //Round down scale factor to multiply by integer value
                    scaleFactor = Math.floor(scaleFactor);
                    adjw = iw * (int)scaleFactor;
                    adjh = ih * (int)scaleFactor;
                    scaleMeasure = 1.0 - 0.5 / scaleFactor;
                } else if (scaleFactor &gt;= 1) {
                    //Don't scale
                    scaleFactor = 1.0;
                    adjw = iw;
                    adjh = ih;
                    scaleMeasure = 0;
                } else if (scaleFactor &gt;= 0.75) {
                    //Multiply by 3/4
                    scaleFactor = 0.75;
                    adjw = iw * 3 / 4;
                    adjh = ih * 3 / 4;
                    scaleMeasure = 0.3;
                } else if (scaleFactor &gt;= 0.6666) {
                    //Multiply by 2/3
                    scaleFactor = 0.6666;
                    adjw = iw * 2 / 3;
                    adjh = ih * 2 / 3;
                    scaleMeasure = 0.33;
                } else {
                    //Multiply size by 1/scaleDivider
                    //where scaleDivider is minimum possible integer
                    //larger than 1/scaleFactor
                    double scaleDivider = Math.ceil(1.0 / scaleFactor);
                    scaleFactor = 1.0 / scaleDivider;
                    adjw = (int)Math.round((double)iw / scaleDivider);
                    adjh = (int)Math.round((double)ih / scaleDivider);
                    scaleMeasure = 1.0 - 1.0 / scaleDivider;
                }
                double similarity = ((double)width - (double)adjw) / (double)width +
                    ((double)height - (double)adjh) / (double)height + //Large padding is bad
                    scaleMeasure; //Large rescale is bad
                if (similarity &lt; bestSimilarity) {
                    bestSimilarity = similarity;
                    image = im;
                }
                if (similarity == 0) break;
            }
        }
        return image;
    }

    @Override public void setIcons(java.util.List icons) {

        int SMALL_ICON_HEIGHT = 32;
        int SMALL_ICON_WIDTH = 32;
        if (PlatformUtil.isMac()) { //Mac Sized Icons
            SMALL_ICON_HEIGHT = 128;
            SMALL_ICON_WIDTH = 128;
        } else if (PlatformUtil.isWindows()) { //Windows Sized Icons
            SMALL_ICON_HEIGHT = 32;
            SMALL_ICON_WIDTH = 32;
        } else if (PlatformUtil.isLinux()) { //Linux icons
            SMALL_ICON_HEIGHT = 128;
            SMALL_ICON_WIDTH = 128;
        }

        if (icons == null || icons.size() &lt; 1) { //no icons passed in
            platformWindow.setIcon(null);
            return;
        }

        Image image = findBestImage(icons, SMALL_ICON_WIDTH, SMALL_ICON_HEIGHT);
        if (image == null) {
            //No images were found, possibly all are broken
            return;
        }

        PushbroomScaler scaler = ScalerFactory.createScaler(image.getWidth(), image.getHeight(),
                                                            image.getBytesPerPixelUnit(),
                                                            SMALL_ICON_WIDTH, SMALL_ICON_HEIGHT, true);

        //shrink the image and convert the format to INT_ARGB_PRE
        ByteBuffer buf = (ByteBuffer) image.getPixelBuffer();
        byte bytes[] = new byte[buf.limit()];

        int iheight = image.getHeight();

        //Iterate through each scanline of the image
        //and pass it one at a time to the scaling object
        for (int z = 0; z &lt; iheight; z++) {
            buf.position(z*image.getScanlineStride());
            buf.get(bytes, 0, image.getScanlineStride());
            scaler.putSourceScanline(bytes, 0);
        }

        buf.rewind();

        final Image img = image.iconify(scaler.getDestination(), SMALL_ICON_WIDTH, SMALL_ICON_HEIGHT);
        platformWindow.setIcon(PixelUtils.imageToPixels(img));
    }

    @Override public void setTitle(String title) {
        platformWindow.setTitle(title);
    }

    @Override public void setVisible(final boolean visible) {
        // Before setting visible to false on the native window, we unblock
        // other windows.
        if (!visible) {
            removeActiveWindow(this);
            if (modality == Modality.WINDOW_MODAL) {
                if (owner != null &amp;&amp; owner instanceof WindowStage) {
                    ((WindowStage) owner).setEnabled(true);
                }
            } else if (modality == Modality.APPLICATION_MODAL) {
                windowsSetEnabled(true);
            } else {
                // Note: This method is required to workaround a glass issue
                // mentioned in RT-12607
                // If the hiding stage is unfocusable (i.e. it's a PopupStage),
                // then we don't do this to avoid stealing the focus.
                if (!isPopupStage &amp;&amp; owner != null &amp;&amp; owner instanceof WindowStage) {
                    WindowStage ownerStage = (WindowStage)owner;
                    ownerStage.requestToFront();
                }
            }
        }
        QuantumToolkit.runWithRenderLock(() -&gt; {
            // platformWindow can be null here, if this window is owned,
            // and its owner is being closed.
            if (platformWindow != null) {
                platformWindow.setVisible(visible);
            }
            super.setVisible(visible);
            return null;
        });
        // After setting visible to true on the native window, we block
        // other windows.
        if (visible) {
            if (modality == Modality.WINDOW_MODAL) {
                if (owner != null &amp;&amp; owner instanceof WindowStage) {
                    ((WindowStage) owner).setEnabled(false);
                }
            } else if (modality == Modality.APPLICATION_MODAL) {
                windowsSetEnabled(false);
            }
            if (isAppletStage &amp;&amp; null != appletWindow) {
                appletWindow.assertStageOrder();
            }
        }

        applyFullScreen();
    }

    @Override boolean isVisible() {
        return platformWindow.isVisible();
    }

    @Override public void setOpacity(float opacity) {
        platformWindow.setAlpha(opacity);
        GlassScene gs = getScene();
        if (gs != null) {
            gs.entireSceneNeedsRepaint();
        }
    }

    public boolean needsUpdateWindow() {
        return transparent &amp;&amp; (Application.GetApplication().shouldUpdateWindow());
    }

    @Override public void setIconified(boolean iconified) {
        if (platformWindow.isMinimized() == iconified) {
            return;
        }
        platformWindow.minimize(iconified);
    }

    @Override public void setMaximized(boolean maximized) {
        if (platformWindow.isMaximized() == maximized) {
            return;
        }
        platformWindow.maximize(maximized);
    }

    @Override
    public void setAlwaysOnTop(boolean alwaysOnTop) {
        // The securityDialog flag takes precedence over alwaysOnTop
        if (securityDialog) return;

        if (isAlwaysOnTop == alwaysOnTop) {
            return;
        }

        if (alwaysOnTop) {
            if (hasPermission(SET_WINDOW_ALWAYS_ON_TOP_PERMISSION)) {
                platformWindow.setLevel(Level.FLOATING);
            } else {
                alwaysOnTop = false;
                if (stageListener != null) {
                    stageListener.changedAlwaysOnTop(alwaysOnTop);
                }
            }
        } else {
            platformWindow.setLevel(Level.NORMAL);
        }
        isAlwaysOnTop = alwaysOnTop;
    }

    @Override public void setResizable(boolean resizable) {
        platformWindow.setResizable(resizable);
        // note: for child windows this is ignored and we fail silently
    }

    // Return true if this stage is trusted for full screen - doesn't have a
    // security manager, or a permission check doesn't result in a security
    // exeception.
    boolean isTrustedFullScreen() {
        return hasPermission(UNRESTRICTED_FULL_SCREEN_PERMISSION);
    }

    // Safely exit full screen
    void exitFullScreen() {
        setFullScreen(false);
    }

    boolean isApplet() {
        return isPrimaryStage &amp;&amp; null != appletWindow;
    }

    private boolean hasPermission(Permission perm) {
        try {
            final SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                sm.checkPermission(perm, getAccessControlContext());
            }
            return true;
        } catch (SecurityException se) {
            return false;
        }
    }

    private boolean fullScreenFromUserEvent = false;

    private KeyCombination savedFullScreenExitKey = null;

    public final KeyCombination getSavedFullScreenExitKey() {
        return savedFullScreenExitKey;
    }

    private void applyFullScreen() {
        if (platformWindow == null) {
            // applyFullScreen() can be called from setVisible(false), while the
            // platformWindow has already been destroyed.
            return;
        }
        View v = platformWindow.getView();
        if (isVisible() &amp;&amp; v != null &amp;&amp; v.isInFullscreen() != isInFullScreen) {
            if (isInFullScreen) {
                // Check whether app is full screen trusted or flag is set
                // indicating that the fullscreen request came from an input
                // event handler.
                // If not notify the stageListener to reset fullscreen to false.
<A NAME="22"></A>                final boolean isTrusted = isTrustedFullScreen();
                if (!isTrusted &amp;&amp; !fullScreenFromUserEvent) {
                    exitFullScreen();
                    <FONT color="#4cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#22',2,'match49-top.html#22',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>fullscreenChanged(false);
                } else {
                    v.enterFullscreen(false, false, false);
                    if (warning != null &amp;&amp; warning.inWarningTransition()) {
                        warning.setView(getViewScene());
                    } else {</B></FONT>
                        boolean showWarning = true;

                        KeyCombination key = null;
                        String exitMessage = null;

                        if (isTrusted &amp;&amp; (fxStage != null)) {
                            // copy the user set definitions for later use.
                            key = fxStage.getFullScreenExitKeyCombination();

                            exitMessage = fxStage.getFullScreenExitHint();
                        }

                        savedFullScreenExitKey =
                                key == null
                                ? defaultFullScreenExitKeycombo
                                : key;

                        if (
                            // the hint is &quot;&quot;
                            &quot;&quot;.equals(exitMessage) ||
                            // if the key is NO_MATCH
                            (savedFullScreenExitKey.equals(KeyCombination.NO_MATCH))
                                ) {
                            showWarning = false;
                        }

                        // the hint is not set, use the key for the message
                        if (showWarning &amp;&amp; exitMessage == null) {
                            if (key == null) {
                                exitMessage = RESOURCES.getString(&quot;OverlayWarningESC&quot;);
                            } else {
                                String f = RESOURCES.getString(&quot;OverlayWarningKey&quot;);
                                exitMessage = f.format(f, savedFullScreenExitKey.toString());
                            }
                        }

                        if (showWarning &amp;&amp; warning == null) {
                            setWarning(new OverlayWarning(getViewScene()));
                        }

                        if (showWarning &amp;&amp; warning != null) {
                            warning.warn(exitMessage);
                        }
                    }
                }
            } else {
                if (warning != null) {
                    warning.cancel();
                    setWarning(null);
                }
                v.exitFullscreen(false);
            }
            // Reset flag once we are done process fullscreen
            fullScreenFromUserEvent = false;
        } else if (!isVisible() &amp;&amp; warning != null) {
            // if the window is closed - re-open with fresh warning
            warning.cancel();
            setWarning(null);
        }
    }

    void setWarning(OverlayWarning newWarning) {
        this.warning = newWarning;
        getViewScene().synchroniseOverlayWarning();
    }

    OverlayWarning getWarning() {
        return warning;
    }

    @Override public void setFullScreen(boolean fullScreen) {
        if (isInFullScreen == fullScreen) {
            return;
        }

       // Set a flag indicating whether this method was called from
        // an allowed input event handler.
        if (isInAllowedEventHandler()) {
            fullScreenFromUserEvent = true;
        }

        GlassStage fsWindow = activeFSWindow.get();
        if (fullScreen &amp;&amp; (fsWindow != null)) {
            fsWindow.setFullScreen(false);
        }
        isInFullScreen = fullScreen;
        applyFullScreen();
        if (fullScreen) {
            activeFSWindow.set(this);
        }
    }

    void fullscreenChanged(final boolean fs) {
        if (!fs) {
            if (activeFSWindow.compareAndSet(this, null)) {
                isInFullScreen = false;
            }
        } else {
            isInFullScreen = true;
            activeFSWindow.set(this);
        }
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            if (stageListener != null) {
                stageListener.changedFullscreen(fs);
            }
            return null;
        }, getAccessControlContext());
    }

    @Override public void toBack() {
        platformWindow.toBack();
        if (isAppletStage &amp;&amp; null != appletWindow) {
            appletWindow.assertStageOrder();
        }
    }

    @Override public void toFront() {
        platformWindow.requestFocus(); // RT-17836
        platformWindow.toFront();
        if (isAppletStage &amp;&amp; null != appletWindow) {
            appletWindow.assertStageOrder();
        }
    }

    private boolean isClosePostponed = false;
    private Window deadWindow = null;

    @Override
    public void postponeClose() {
        isClosePostponed = true;
    }

    @Override
    public void closePostponed() {
        if (deadWindow != null) {
            deadWindow.close();
            deadWindow = null;
        }
    }

    @Override public void close() {
        super.close();
        QuantumToolkit.runWithRenderLock(() -&gt; {
            // prevents closing a closed platform window
            if (platformWindow != null) {
                platformWindows.remove(platformWindow);
                if (isClosePostponed) {
                    deadWindow = platformWindow;
                } else {
                    platformWindow.close();
                }
                platformWindow = null;
            }
            GlassScene oldScene = getViewScene();
            if (oldScene != null) {
                oldScene.updateSceneState();
            }
            return null;
        });
    }

    // setPlatformWindowClosed is only set upon receiving platform window has
    // closed notification. This state is necessary to prevent the platform
    // window from being closed more than once.
    void setPlatformWindowClosed() {
        platformWindow = null;
    }

    static void addActiveWindow(WindowStage window) {
        activeWindows.remove(window);
        activeWindows.add(window);
    }

    static void removeActiveWindow(WindowStage window) {
        activeWindows.remove(window);
    }

    final void handleFocusDisabled() {
        if (activeWindows.isEmpty()) {
            return;
        }
        WindowStage window = activeWindows.get(activeWindows.size() - 1);
        window.setIconified(false);
        window.requestToFront();
        window.requestFocus();
    }

    @Override public boolean grabFocus() {
        return platformWindow.grabFocus();
    }

    @Override public void ungrabFocus() {
        platformWindow.ungrabFocus();
    }

    @Override public void requestFocus() {
        platformWindow.requestFocus();
    }

    @Override public void requestFocus(FocusCause cause) {
        switch (cause) {
            case TRAVERSED_FORWARD:
                platformWindow.requestFocus(WindowEvent.FOCUS_GAINED_FORWARD);
                break;
            case TRAVERSED_BACKWARD:
                platformWindow.requestFocus(WindowEvent.FOCUS_GAINED_BACKWARD);
                break;
            case ACTIVATED:
                platformWindow.requestFocus(WindowEvent.FOCUS_GAINED);
                break;
            case DEACTIVATED:
                platformWindow.requestFocus(WindowEvent.FOCUS_LOST);
                break;
        }
    }

    @Override
    protected void setPlatformEnabled(boolean enabled) {
        super.setPlatformEnabled(enabled);
        if (platformWindow != null) {
            platformWindow.setEnabled(enabled);
        }
        if (enabled) {
            // Check if window is really enabled - to handle nested case
            if (platformWindow != null &amp;&amp; platformWindow.isEnabled()) {
                requestToFront();
            }
        } else {
            removeActiveWindow(this);
        }
    }

    @Override
    public void setEnabled(boolean enabled) {
        if ((owner != null) &amp;&amp; (owner instanceof WindowStage)) {
            ((WindowStage) owner).setEnabled(enabled);
        }
        /*
         * RT-17588 - exit if stage is closed from under us as
         *            any further access to the Glass layer
         *            will throw an exception
         */
        if (enabled &amp;&amp; (platformWindow == null || platformWindow.isClosed())) {
            return;
        }
        setPlatformEnabled(enabled);
        if (enabled) {
            if (isAppletStage &amp;&amp; null != appletWindow) {
                appletWindow.assertStageOrder();
            }
        }
    }

    @Override
    public long getRawHandle() {
       return platformWindow.getRawHandle();
    }

    // Note: This method is required to workaround a glass issue mentioned in RT-12607
    protected void requestToFront() {
        if (platformWindow != null) {
            platformWindow.toFront();
            platformWindow.requestFocus();
        }
    }

    public void setInAllowedEventHandler(boolean inAllowedEventHandler) {
        this.inAllowedEventHandler = inAllowedEventHandler;
    }

    private boolean isInAllowedEventHandler() {
        return inAllowedEventHandler;
    }

    @Override
    public void requestInput(String text, int type, double width, double height,
                        double Mxx, double Mxy, double Mxz, double Mxt,
                        double Myx, double Myy, double Myz, double Myt,
                        double Mzx, double Mzy, double Mzz, double Mzt) {
        platformWindow.requestInput(text, type, width, height,
                                    Mxx, Mxy, Mxz, Mxt,
                                    Myx, Myy, Myz, Myt,
                                    Mzx, Mzy, Mzz, Mzt);
    }

    @Override
    public void releaseInput() {
        platformWindow.releaseInput();
    }

    @Override public void setRTL(boolean b) {
        rtl = b;
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/marlin/MarlinConst.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.marlin;

/**
 * Marlin constant holder using System properties
 */
public interface MarlinConst {
    // enable Logs (logger or stdout)
    static final boolean ENABLE_LOGS = MarlinProperties.isLoggingEnabled();
    // use Logger instead of stdout
    static final boolean USE_LOGGER = ENABLE_LOGS &amp;&amp; MarlinProperties.isUseLogger();

    // log new RendererContext
    static final boolean LOG_CREATE_CONTEXT = ENABLE_LOGS
        &amp;&amp; MarlinProperties.isLogCreateContext();
    // log misc.Unsafe alloc/realloc/free
    static final boolean LOG_UNSAFE_MALLOC = ENABLE_LOGS
        &amp;&amp; MarlinProperties.isLogUnsafeMalloc();
    // do check unsafe alignment:
    static final boolean DO_CHECK_UNSAFE = false;

    // do statistics
    static final boolean DO_STATS = ENABLE_LOGS &amp;&amp; MarlinProperties.isDoStats();
    // do monitors
    // disabled to reduce byte-code size a bit...
    static final boolean DO_MONITORS = false;
//    static final boolean DO_MONITORS = ENABLE_LOGS &amp;&amp; MarlinProperties.isDoMonitors();
    // do checks
    static final boolean DO_CHECKS = ENABLE_LOGS &amp;&amp; MarlinProperties.isDoChecks();

    // do AA range checks: disable when algorithm / code is stable
    static final boolean DO_AA_RANGE_CHECK = false;

    // enable logs
    static final boolean DO_LOG_WIDEN_ARRAY = ENABLE_LOGS &amp;&amp; false;
    // enable oversize logs
    static final boolean DO_LOG_OVERSIZE = ENABLE_LOGS &amp;&amp; false;
    // enable traces
    static final boolean DO_TRACE = ENABLE_LOGS &amp;&amp; false;

    // do flush stats
    static final boolean DO_FLUSH_STATS = true;
    // do flush monitors
    static final boolean DO_FLUSH_MONITORS = true;
    // use one polling thread to dump statistics/monitors
    static final boolean USE_DUMP_THREAD = false;
    // thread dump interval (ms)
    static final long DUMP_INTERVAL = 5000L;

    // do clean dirty array
    static final boolean DO_CLEAN_DIRTY = false;

    // flag to use collinear simplifier
    static final boolean USE_SIMPLIFIER = MarlinProperties.isUseSimplifier();

    // flag to use path simplifier
    static final boolean USE_PATH_SIMPLIFIER = MarlinProperties.isUsePathSimplifier();

    static final boolean DO_CLIP_SUBDIVIDER = MarlinProperties.isDoClipSubdivider();

    // flag to enable logs related to bounds checks
    static final boolean DO_LOG_BOUNDS = ENABLE_LOGS &amp;&amp; false;

    // flag to enable logs related to clip rect
    static final boolean DO_LOG_CLIP = ENABLE_LOGS &amp;&amp; false;

    // Initial Array sizing (initial context capacity) ~ 450K

    // 4096 pixels (width) for initial capacity
    static final int INITIAL_PIXEL_WIDTH
        = MarlinProperties.getInitialPixelWidth();
    // 2176 pixels (height) for initial capacity
    static final int INITIAL_PIXEL_HEIGHT
        = MarlinProperties.getInitialPixelHeight();

    // typical array sizes: only odd numbers allowed below
    static final int INITIAL_ARRAY        = 256;

    // alpha row dimension
<A NAME="20"></A>    static final int INITIAL_AA_ARRAY     = INITIAL_PIXEL_WIDTH;

    // 4096 edges for initial capacity
    <FONT color="#d4a017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#20',2,'match49-top.html#20',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>static final int INITIAL_EDGES_COUNT = MarlinProperties.getInitialEdges();

    // initial edges = edges count (4096)
    // 6 ints per edges = 24 bytes
    // edges capacity = 24 x initial edges = 24 * edges count (4096) = 96K
    static final int INITIAL_EDGES_CAPACITY = INITIAL_EDGES_COUNT * 24;

    // crossing capacity = edges count / 4 ~ 1024
    static final int INITIAL_CROSSING_COUNT = INITIAL_EDGES_COUNT &gt;&gt; 2;

    // zero value as byte
    static final byte BYTE_0 = (byte) 0;

    // subpixels expressed as log2
    public static final int SUBPIXEL_LG_POSITIONS_X
        = MarlinProperties.getSubPixel_Log2_X();
    public static final int SUBPIXEL_LG_POSITIONS_Y
        = MarlinProperties.getSubPixel_Log2_Y();

    public static final int MIN_SUBPIXEL_LG_POSITIONS
        = Math.min</B></FONT>(SUBPIXEL_LG_POSITIONS_X, SUBPIXEL_LG_POSITIONS_Y);

    // number of subpixels
    public static final int SUBPIXEL_POSITIONS_X = 1 &lt;&lt; (SUBPIXEL_LG_POSITIONS_X);
    public static final int SUBPIXEL_POSITIONS_Y = 1 &lt;&lt; (SUBPIXEL_LG_POSITIONS_Y);

    public static final float MIN_SUBPIXELS = 1 &lt;&lt; MIN_SUBPIXEL_LG_POSITIONS;

    // 2176 pixels (height) x 8 subpixels = 68K
    static final int INITIAL_BUCKET_ARRAY
        = INITIAL_PIXEL_HEIGHT * SUBPIXEL_POSITIONS_Y;

    public static final int MAX_AA_ALPHA
        = (SUBPIXEL_POSITIONS_X * SUBPIXEL_POSITIONS_Y);

    public static final int BLOCK_SIZE_LG = MarlinProperties.getBlockSize_Log2();
    public static final int BLOCK_SIZE    = 1 &lt;&lt; BLOCK_SIZE_LG;

    static final boolean ENABLE_BLOCK_FLAGS = MarlinProperties.isUseTileFlags();
    static final boolean ENABLE_BLOCK_FLAGS_HEURISTICS = MarlinProperties.isUseTileFlagsWithHeuristics();

    static final boolean FORCE_RLE = MarlinProperties.isForceRLE();
    static final boolean FORCE_NO_RLE = MarlinProperties.isForceNoRLE();
    // minimum width to try using RLE encoding:
    static final int RLE_MIN_WIDTH
        = Math.max(BLOCK_SIZE, MarlinProperties.getRLEMinWidth());

    // Constants
    public static final int WIND_EVEN_ODD = 0;
    public static final int WIND_NON_ZERO = 1;

    /**
     * Constant value for join style.
     */
    public static final int JOIN_MITER = 0;

    /**
     * Constant value for join style.
     */
    public static final int JOIN_ROUND = 1;

    /**
     * Constant value for join style.
     */
    public static final int JOIN_BEVEL = 2;

    /**
     * Constant value for end cap style.
     */
    public static final int CAP_BUTT = 0;

    /**
     * Constant value for end cap style.
     */
    public static final int CAP_ROUND = 1;

    /**
     * Constant value for end cap style.
     */
    public static final int CAP_SQUARE = 2;

    // Out codes
    static final int OUTCODE_TOP      = 1;
    static final int OUTCODE_BOTTOM   = 2;
    static final int OUTCODE_LEFT     = 4;
    static final int OUTCODE_RIGHT    = 8;
    static final int OUTCODE_MASK_T_B = OUTCODE_TOP  | OUTCODE_BOTTOM;
    static final int OUTCODE_MASK_L_R = OUTCODE_LEFT | OUTCODE_RIGHT;
    static final int OUTCODE_MASK_T_B_L_R = OUTCODE_MASK_T_B | OUTCODE_MASK_L_R;
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/openpisces/Dasher.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2007, 2014, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.openpisces;

import com.sun.javafx.geom.PathConsumer2D;

/**
 * The &lt;code&gt;Dasher&lt;/code&gt; class takes a series of linear commands
 * (&lt;code&gt;moveTo&lt;/code&gt;, &lt;code&gt;lineTo&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt; and
 * &lt;code&gt;end&lt;/code&gt;) and breaks them into smaller segments according to a
 * dash pattern array and a starting dash phase.
 *
 * &lt;p&gt; Issues: in J2Se, a zero length dash segment as drawn as a very
 * short dash, whereas Pisces does not draw anything.  The PostScript
 * semantics are unclear.
 *
 */
public final class Dasher implements PathConsumer2D {

    private final PathConsumer2D out;
    private float[] dash;
    private float startPhase;
    private boolean startDashOn;
    private int startIdx;

    private boolean starting;
    private boolean needsMoveTo;

    private int idx;
    private boolean dashOn;
    private float phase;

    private float sx, sy;
    private float x0, y0;

    // temporary storage for the current curve
    private float[] curCurvepts;

    /**
     * Constructs a &lt;code&gt;Dasher&lt;/code&gt;.
     *
     * @param out an output &lt;code&gt;PathConsumer2D&lt;/code&gt;.
     * @param dash an array of &lt;code&gt;float&lt;/code&gt;s containing the dash pattern
     * @param phase a &lt;code&gt;float&lt;/code&gt; containing the dash phase
     */
    public Dasher(PathConsumer2D out, float[] dash, float phase) {
        this(out);
        reset(dash, phase);
    }

    public Dasher(PathConsumer2D out) {
        this.out = out;

        // we need curCurvepts to be able to contain 2 curves because when
        // dashing curves, we need to subdivide it
        curCurvepts = new float[8 * 2];
    }

    // More than 24 bits of mantissa means we can no longer accurately
    // measure the number of times cycled through the dash array so we
    // punt and override the phase to just be 0 past that point.
    static float MAX_CYCLES = 16000000f;
    public void reset(float[] dash, float phase) {
        // Normalize so 0 &lt;= phase &lt; dash[0]
        int sidx = 0;
        dashOn = true;
        float sum = 0f;
        for (float d : dash) {
            sum += d;
        }
        float cycles = phase / sum;
        if (phase &lt; 0) {
            if (-cycles &gt;= MAX_CYCLES) {
                phase = 0;
            } else {
                int fullcycles = (int) Math.floor(-cycles);
                if ((fullcycles &amp; dash.length &amp; 1) != 0) {
                    dashOn = !dashOn;
                }
                phase += fullcycles * sum;
                while (phase &lt; 0) {
                    if (--sidx &lt; 0) sidx = dash.length-1;
                    phase += dash[sidx];
                    dashOn = !dashOn;
                }
            }
        } else if (phase &gt; 0) {
            if (cycles &gt;= MAX_CYCLES) {
                phase = 0;
            } else {
                int fullcycles = (int) Math.floor(cycles);
                if ((fullcycles &amp; dash.length &amp; 1) != 0) {
                    dashOn = !dashOn;
                }
                phase -= fullcycles * sum;
                float d;
                while (phase &gt;= (d = dash[sidx])) {
                    phase -= d;
                    sidx = (sidx + 1) % dash.length;
                    dashOn = !dashOn;
                }
            }
        }

        this.dash = dash;
        this.startPhase = this.phase = phase;
        this.startDashOn = dashOn;
        this.startIdx = sidx;
        this.starting = true;
    }

    public void moveTo(float x0, float y0) {
        if (firstSegidx &gt; 0) {
            out.moveTo(sx, sy);
            emitFirstSegments();
        }
        needsMoveTo = true;
        this.idx = startIdx;
        this.dashOn = this.startDashOn;
        this.phase = this.startPhase;
        this.sx = this.x0 = x0;
        this.sy = this.y0 = y0;
        this.starting = true;
    }

    private void emitSeg(float[] buf, int off, int type) {
        switch (type) {
        case 8:
            out.curveTo(buf[off+0], buf[off+1],
                        buf[off+2], buf[off+3],
                        buf[off+4], buf[off+5]);
            break;
        case 6:
            out.quadTo(buf[off+0], buf[off+1],
                       buf[off+2], buf[off+3]);
            break;
        case 4:
            out.lineTo(buf[off], buf[off+1]);
        }
    }

    private void emitFirstSegments() {
        for (int i = 0; i &lt; firstSegidx; ) {
            emitSeg(firstSegmentsBuffer, i+1, (int)firstSegmentsBuffer[i]);
            i += (((int)firstSegmentsBuffer[i]) - 1);
        }
        firstSegidx = 0;
    }

    // We don't emit the first dash right away. If we did, caps would be
    // drawn on it, but we need joins to be drawn if there's a closePath()
    // So, we store the path elements that make up the first dash in the
    // buffer below.
    private float[] firstSegmentsBuffer = new float[7];
    private int firstSegidx = 0;
    // precondition: pts must be in relative coordinates (relative to x0,y0)
    // fullCurve is true iff the curve in pts has not been split.
    private void goTo(float[] pts, int off, final int type) {
        float x = pts[off + type - 4];
        float y = pts[off + type - 3];
        if (dashOn) {
            if (starting) {
                firstSegmentsBuffer =
                    Helpers.widenArray(firstSegmentsBuffer,
                                       firstSegidx, type - 1);
                firstSegmentsBuffer[firstSegidx++] = type;
                System.arraycopy(pts, off, firstSegmentsBuffer, firstSegidx, type - 2);
                firstSegidx += type - 2;
            } else {
                if (needsMoveTo) {
                    out.moveTo(x0, y0);
                    needsMoveTo = false;
                }
                emitSeg(pts, off, type);
            }
        } else {
            starting = false;
            needsMoveTo = true;
        }
        this.x0 = x;
        this.y0 = y;
    }

    public void lineTo(float x1, float y1) {
        float dx = x1 - x0;
        float dy = y1 - y0;

        float len = (float) Math.sqrt(dx*dx + dy*dy);

        if (len == 0) {
            return;
        }

        // The scaling factors needed to get the dx and dy of the
        // transformed dash segments.
        float cx = dx / len;
        float cy = dy / len;

        while (true) {
            float leftInThisDashSegment = dash[idx] - phase;
            if (len &lt;= leftInThisDashSegment) {
                curCurvepts[0] = x1;
                curCurvepts[1] = y1;
                goTo(curCurvepts, 0, 4);
                // Advance phase within current dash segment
                phase += len;
                if (len == leftInThisDashSegment) {
                    phase = 0f;
                    idx = (idx + 1) % dash.length;
                    dashOn = !dashOn;
                }
                return;
            }

            float dashdx = dash[idx] * cx;
            float dashdy = dash[idx] * cy;
            if (phase == 0) {
                curCurvepts[0] = x0 + dashdx;
                curCurvepts[1] = y0 + dashdy;
            } else {
                float p = leftInThisDashSegment / dash[idx];
                curCurvepts[0] = x0 + p * dashdx;
                curCurvepts[1] = y0 + p * dashdy;
            }

            goTo(curCurvepts, 0, 4);

            len -= leftInThisDashSegment;
            // Advance to next dash segment
            idx = (idx + 1) % dash.length;
            dashOn = !dashOn;
            phase = 0;
        }
    }

    private LengthIterator li = null;

    // preconditions: curCurvepts must be an array of length at least 2 * type,
    // that contains the curve we want to dash in the first type elements
    private void somethingTo(int type) {
        if (pointCurve(curCurvepts, type)) {
            return;
        }
        if (li == null) {
            li = new LengthIterator(4, 0.01f);
        }
        li.initializeIterationOnCurve(curCurvepts, type);

        int curCurveoff = 0; // initially the current curve is at curCurvepts[0...type]
        float lastSplitT = 0;
        float t = 0;
        float leftInThisDashSegment = dash[idx] - phase;
        while ((t = li.next(leftInThisDashSegment)) &lt; 1) {
            if (t != 0) {
                Helpers.subdivideAt((t - lastSplitT) / (1 - lastSplitT),
                                    curCurvepts, curCurveoff,
                                    curCurvepts, 0,
                                    curCurvepts, type, type);
                lastSplitT = t;
                goTo(curCurvepts, 2, type);
                curCurveoff = type;
            }
            // Advance to next dash segment
            idx = (idx + 1) % dash.length;
            dashOn = !dashOn;
            phase = 0;
            leftInThisDashSegment = dash[idx];
        }
        goTo(curCurvepts, curCurveoff+2, type);
        phase += li.lastSegLen();
        if (phase &gt;= dash[idx]) {
            phase = 0f;
            idx = (idx + 1) % dash.length;
            dashOn = !dashOn;
        }
    }

    private static boolean pointCurve(float[] curve, int type) {
        for (int i = 2; i &lt; type; i++) {
            if (curve[i] != curve[i-2]) {
                return false;
            }
        }
        return true;
    }

    // Objects of this class are used to iterate through curves. They return
    // t values where the left side of the curve has a specified length.
    // It does this by subdividing the input curve until a certain error
    // condition has been met. A recursive subdivision procedure would
    // return as many as 1&lt;&lt;limit curves, but this is an iterator and we
    // don't need all the curves all at once, so what we carry out a
    // lazy inorder traversal of the recursion tree (meaning we only move
    // through the tree when we need the next subdivided curve). This saves
    // us a lot of memory because at any one time we only need to store
    // limit+1 curves - one for each level of the tree + 1.
    // NOTE: the way we do things here is not enough to traverse a general
    // tree; however, the trees we are interested in have the property that
    // every non leaf node has exactly 2 children
    private static class LengthIterator {
        private enum Side {LEFT, RIGHT};
        // Holds the curves at various levels of the recursion. The root
        // (i.e. the original curve) is at recCurveStack[0] (but then it
        // gets subdivided, the left half is put at 1, so most of the time
        // only the right half of the original curve is at 0)
        private float[][] recCurveStack;
        // sides[i] indicates whether the node at level i+1 in the path from
        // the root to the current leaf is a left or right child of its parent.
        private Side[] sides;
        private int curveType;
        private final int limit;
        private final float ERR;
        private final float minTincrement;
        // lastT and nextT delimit the current leaf.
        private float nextT;
        private float lenAtNextT;
        private float lastT;
        private float lenAtLastT;
        private float lenAtLastSplit;
        private float lastSegLen;
        // the current level in the recursion tree. 0 is the root. limit
        // is the deepest possible leaf.
        private int recLevel;
        private boolean done;

        // the lengths of the lines of the control polygon. Only its first
        // curveType/2 - 1 elements are valid. This is an optimization. See
        // next(float) for more detail.
        private float[] curLeafCtrlPolyLengths = new float[3];

        public LengthIterator(int reclimit, float err) {
            this.limit = reclimit;
            this.minTincrement = 1f / (1 &lt;&lt; limit);
            this.ERR = err;
            this.recCurveStack = new float[reclimit+1][8];
            this.sides = new Side[reclimit];
            // if any methods are called without first initializing this object on
            // a curve, we want it to fail ASAP.
            this.nextT = Float.MAX_VALUE;
            this.lenAtNextT = Float.MAX_VALUE;
            this.lenAtLastSplit = Float.MIN_VALUE;
            this.recLevel = Integer.MIN_VALUE;
            this.lastSegLen = Float.MAX_VALUE;
            this.done = true;
        }

        public void initializeIterationOnCurve(float[] pts, int type) {
            System.arraycopy(pts, 0, recCurveStack[0], 0, type);
            this.curveType = type;
            this.recLevel = 0;
            this.lastT = 0;
            this.lenAtLastT = 0;
            this.nextT = 0;
            this.lenAtNextT = 0;
            goLeft(); // initializes nextT and lenAtNextT properly
            this.lenAtLastSplit = 0;
            if (recLevel &gt; 0) {
                this.sides[0] = Side.LEFT;
                this.done = false;
            } else {
                // the root of the tree is a leaf so we're done.
                this.sides[0] = Side.RIGHT;
                this.done = true;
            }
            this.lastSegLen = 0;
        }

        // 0 == false, 1 == true, -1 == invalid cached value.
        private int cachedHaveLowAcceleration = -1;

        private boolean haveLowAcceleration(float err) {
            if (cachedHaveLowAcceleration == -1) {
                final float len1 = curLeafCtrlPolyLengths[0];
                final float len2 = curLeafCtrlPolyLengths[1];
                // the test below is equivalent to !within(len1/len2, 1, err).
                // It is using a multiplication instead of a division, so it
                // should be a bit faster.
                if (!Helpers.within(len1, len2, err*len2)) {
                    cachedHaveLowAcceleration = 0;
                    return false;
                }
                if (curveType == 8) {
                    final float len3 = curLeafCtrlPolyLengths[2];
                    // if len1 is close to 2 and 2 is close to 3, that probably
                    // means 1 is close to 3 so the second part of this test might
                    // not be needed, but it doesn't hurt to include it.
                    if (!(Helpers.within(len2, len3, err*len3) &amp;&amp;
                          Helpers.within(len1, len3, err*len3))) {
                        cachedHaveLowAcceleration = 0;
                        return false;
                    }
                }
                cachedHaveLowAcceleration = 1;
                return true;
            }

            return (cachedHaveLowAcceleration == 1);
        }

        // we want to avoid allocations/gc so we keep this array so we
        // can put roots in it,
        private float[] nextRoots = new float[4];

        // caches the coefficients of the current leaf in its flattened
        // form (see inside next() for what that means). The cache is
        // invalid when it's third element is negative, since in any
        // valid flattened curve, this would be &gt;= 0.
        private float[] flatLeafCoefCache = new float[] {0, 0, -1, 0};
        // returns the t value where the remaining curve should be split in
        // order for the left subdivided curve to have length len. If len
        // is &gt;= than the length of the uniterated curve, it returns 1.
        public float next(final float len) {
            final float targetLength = lenAtLastSplit + len;
            while(lenAtNextT &lt; targetLength) {
                if (done) {
                    lastSegLen = lenAtNextT - lenAtLastSplit;
                    return 1;
                }
                goToNextLeaf();
            }
            lenAtLastSplit = targetLength;
            final float leaflen = lenAtNextT - lenAtLastT;
            float t = (targetLength - lenAtLastT) / leaflen;

            // cubicRootsInAB is a fairly expensive call, so we just don't do it
            // if the acceleration in this section of the curve is small enough.
            if (!haveLowAcceleration(0.05f)) {
                // We flatten the current leaf along the x axis, so that we're
                // left with a, b, c which define a 1D Bezier curve. We then
                // solve this to get the parameter of the original leaf that
                // gives us the desired length.

                if (flatLeafCoefCache[2] &lt; 0) {
                    float x = 0+curLeafCtrlPolyLengths[0],
                          y = x+curLeafCtrlPolyLengths[1];
                    if (curveType == 8) {
                        float z = y + curLeafCtrlPolyLengths[2];
                        flatLeafCoefCache[0] = 3*(x - y) + z;
                        flatLeafCoefCache[1] = 3*(y - 2*x);
                        flatLeafCoefCache[2] = 3*x;
                        flatLeafCoefCache[3] = -z;
                    } else if (curveType == 6) {
                        flatLeafCoefCache[0] = 0f;
                        flatLeafCoefCache[1] = y - 2*x;
                        flatLeafCoefCache[2] = 2*x;
                        flatLeafCoefCache[3] = -y;
                    }
                }
                float a = flatLeafCoefCache[0];
                float b = flatLeafCoefCache[1];
                float c = flatLeafCoefCache[2];
                float d = t*flatLeafCoefCache[3];

                // we use cubicRootsInAB here, because we want only roots in 0, 1,
                // and our quadratic root finder doesn't filter, so it's just a
                // matter of convenience.
                int n = Helpers.cubicRootsInAB(a, b, c, d, nextRoots, 0, 0, 1);
                if (n == 1 &amp;&amp; !Float.isNaN(nextRoots[0])) {
                    t = nextRoots[0];
                }
            }
            // t is relative to the current leaf, so we must make it a valid parameter
            // of the original curve.
            t = t * (nextT - lastT) + lastT;
            if (t &gt;= 1) {
                t = 1;
                done = true;
            }
            // even if done = true, if we're here, that means targetLength
            // is equal to, or very, very close to the total length of the
            // curve, so lastSegLen won't be too high. In cases where len
            // overshoots the curve, this method will exit in the while
            // loop, and lastSegLen will still be set to the right value.
            lastSegLen = len;
            return t;
        }

        public float lastSegLen() {
            return lastSegLen;
        }

        // go to the next leaf (in an inorder traversal) in the recursion tree
        // preconditions: must be on a leaf, and that leaf must not be the root.
        private void goToNextLeaf() {
            // We must go to the first ancestor node that has an unvisited
            // right child.
            recLevel--;
            while(sides[recLevel] == Side.RIGHT) {
                if (recLevel == 0) {
                    done = true;
                    return;
                }
                recLevel--;
            }

            sides[recLevel] = Side.RIGHT;
            System.arraycopy(recCurveStack[recLevel], 0,
                             recCurveStack[recLevel+1], 0, curveType);
            recLevel++;
            goLeft();
        }

        // go to the leftmost node from the current node. Return its length.
        private void goLeft() {
            float len = onLeaf();
            if (len &gt;= 0) {
                lastT = nextT;
                lenAtLastT = lenAtNextT;
                nextT += (1 &lt;&lt; (limit - recLevel)) * minTincrement;
                lenAtNextT += len;
                // invalidate caches
                flatLeafCoefCache[2] = -1;
                cachedHaveLowAcceleration = -1;
            } else {
                Helpers.subdivide(recCurveStack[recLevel], 0,
                                  recCurveStack[recLevel+1], 0,
                                  recCurveStack[recLevel], 0, curveType);
                sides[recLevel] = Side.LEFT;
                recLevel++;
                goLeft();
            }
        }

        // this is a bit of a hack. It returns -1 if we're not on a leaf, and
        // the length of the leaf if we are on a leaf.
        private float onLeaf() {
            float[] curve = recCurveStack[recLevel];
            float polyLen = 0;

            float x0 = curve[0], y0 = curve[1];
            for (int i = 2; i &lt; curveType; i += 2) {
                final float x1 = curve[i], y1 = curve[i+1];
                final float len = Helpers.linelen(x0, y0, x1, y1);
                polyLen += len;
                curLeafCtrlPolyLengths[i/2 - 1] = len;
                x0 = x1;
                y0 = y1;
            }

            final float lineLen =
                Helpers.linelen(curve[0], curve[1], curve[curveType-2], curve[curveType-1]);
            if (polyLen - lineLen &lt; ERR || recLevel == limit) {
                return (polyLen + lineLen)/2;
            }
            return -1;
        }
    }

    @Override
    public void curveTo(float x1, float y1,
                        float x2, float y2,
                        float x3, float y3)
    {
        curCurvepts[0] = x0;        curCurvepts[1] = y0;
        curCurvepts[2] = x1;        curCurvepts[3] = y1;
        curCurvepts[4] = x2;        curCurvepts[5] = y2;
        curCurvepts[6] = x3;        curCurvepts[7] = y3;
        somethingTo(8);
    }

    @Override
    public void quadTo(float x1, float y1, float x2, float y2) {
        curCurvepts[0] = x0;        curCurvepts[1] = y0;
        curCurvepts[2] = x1;        curCurvepts[3] = y1;
        curCurvepts[4] = x2;        curCurvepts[5] = y2;
        somethingTo(6);
    }

    public void closePath() {
        lineTo(sx, sy);
        if (firstSegidx &gt; 0) {
            if (!dashOn || needsMoveTo) {
                out.moveTo(sx, sy);
<A NAME="14"></A>            }
            emitFirstSegments();
        }
        <FONT color="#f52887"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#14',2,'match49-top.html#14',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>moveTo(sx, sy);
    }

    public void pathDone() {
        if (firstSegidx &gt; 0) {
            out.moveTo(sx, sy);
            emitFirstSegments();
        }
        out.pathDone();
    }</B></FONT>

//    @Override
//    public long getNativeConsumer() {
//        throw new InternalError(&quot;Dasher does not use a native consumer&quot;);
//    }
}

</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/prism/j2d/print/J2DPrinterJob.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.prism.j2d.print;

import javafx.print.Collation;
import javafx.print.JobSettings;
import javafx.print.PageLayout;
import javafx.print.PageOrientation;
import javafx.print.PageRange;
import javafx.print.Paper;
import javafx.print.PaperSource;
import javafx.print.PrintColor;
import javafx.print.PrintResolution;
import javafx.print.PrintSides;
import javafx.print.Printer;
import javafx.print.Printer.MarginType;
import javafx.print.PrinterAttributes;
import javafx.scene.Group;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Window;
import javax.print.PrintService;
import javax.print.attribute.HashPrintRequestAttributeSet;
import javax.print.attribute.PrintRequestAttribute;
import javax.print.attribute.PrintRequestAttributeSet;
import javax.print.attribute.ResolutionSyntax;
import javax.print.attribute.Size2DSyntax;
import javax.print.attribute.standard.Chromaticity;
import javax.print.attribute.standard.Copies;
import javax.print.attribute.standard.DialogTypeSelection;
import javax.print.attribute.standard.Media;
import javax.print.attribute.standard.MediaPrintableArea;
import javax.print.attribute.standard.MediaSize;
import javax.print.attribute.standard.MediaSizeName;
import javax.print.attribute.standard.MediaTray;
import javax.print.attribute.standard.OrientationRequested;
import javax.print.attribute.standard.PageRanges;
import javax.print.attribute.standard.PrintQuality;
import javax.print.attribute.standard.PrinterResolution;
import javax.print.attribute.standard.SheetCollate;
import javax.print.attribute.standard.Sides;
import java.awt.*;
import java.awt.print.PageFormat;
import java.awt.print.Pageable;
import java.awt.print.Printable;
import java.awt.print.PrinterException;
import java.util.ArrayList;
import java.util.Set;
import com.sun.glass.ui.Application;
import com.sun.javafx.PlatformUtil;
import com.sun.javafx.print.PrintHelper;
import com.sun.javafx.print.PrinterImpl;
import com.sun.javafx.print.PrinterJobImpl;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.stage.WindowHelper;
import com.sun.javafx.tk.TKStage;
import com.sun.javafx.tk.Toolkit;
import com.sun.glass.utils.NativeLibLoader;
import com.sun.prism.impl.PrismSettings;

import com.sun.prism.j2d.PrismPrintGraphics;

import java.lang.reflect.Constructor;
import java.security.AccessController;
import java.security.PrivilegedAction;

public class J2DPrinterJob implements PrinterJobImpl {

    static {
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            String libName = &quot;prism_common&quot;;

            if (PrismSettings.verbose) {
                System.out.println(&quot;Loading Prism common native library ...&quot;);
            }
            NativeLibLoader.loadLibrary(libName);
            if (PrismSettings.verbose) {
                System.out.println(&quot;\tsucceeded.&quot;);
            }
            return null;
        });
    }

    javafx.print.PrinterJob fxPrinterJob;
    java.awt.print.PrinterJob pJob2D;
    javafx.print.Printer fxPrinter;
    J2DPrinter j2dPrinter;

    private JobSettings settings;
    private PrintRequestAttributeSet printReqAttrSet;
    private volatile Object elo = null;

    private static Class onTopClass = null;
    PrintRequestAttribute getAlwaysOnTop(final long id) {
        return AccessController.doPrivileged(
            (PrivilegedAction&lt;PrintRequestAttribute&gt;) () -&gt; {

            PrintRequestAttribute alwaysOnTop = null;
            try {
                if (onTopClass == null) {
                    onTopClass =
                        Class.forName(&quot;javax.print.attribute.standard.DialogOwner&quot;);
                }
                if (id == 0) {
                    Constructor&lt;PrintRequestAttribute&gt;
                         cons = onTopClass.getConstructor();
                    alwaysOnTop = cons.newInstance();
                } else {
                    alwaysOnTop = getAlwaysOnTop(onTopClass, id);
                }
            } catch (Throwable t) {
            }
            return alwaysOnTop;
        });
    }

    private static native
        PrintRequestAttribute getAlwaysOnTop(Class onTopClass, long id);

    public J2DPrinterJob(javafx.print.PrinterJob fxJob) {

        fxPrinterJob = fxJob;
        fxPrinter = fxPrinterJob.getPrinter();
        j2dPrinter = getJ2DPrinter(fxPrinter);
        settings = fxPrinterJob.getJobSettings();
        pJob2D = java.awt.print.PrinterJob.getPrinterJob();
        try {
            pJob2D.setPrintService(j2dPrinter.getService());
        } catch (PrinterException pe) {
        }
        printReqAttrSet = new HashPrintRequestAttributeSet();
        printReqAttrSet.add(DialogTypeSelection.NATIVE);
        j2dPageable = new J2DPageable();
        pJob2D.setPageable(j2dPageable);
    }

    private void setEnabledState(Window owner, boolean state) {
        if (owner == null) {
           return;
        }
        final TKStage stage = WindowHelper.getPeer(owner);
        if (stage == null) { // just in case.
            return;
        }
        Application.invokeAndWait(() -&gt; stage.setEnabled(state));
    }

    public boolean showPrintDialog(Window owner) {

        if (jobRunning || jobDone) {
            return false;
        }

        if (GraphicsEnvironment.isHeadless()) {
            return true;
        }

        if (onTopClass != null) {
            printReqAttrSet.remove(onTopClass);
        }
        if (owner != null) {
            long id = 0L;
            if (PlatformUtil.isWindows()) {
                id = WindowHelper.getPeer(owner).getRawHandle();
            }
            PrintRequestAttribute alwaysOnTop = getAlwaysOnTop(id);
            if (alwaysOnTop != null) {
                printReqAttrSet.add(alwaysOnTop);
            }
        }

        boolean rv = false;
        syncSettingsToAttributes();
        try {
            setEnabledState(owner, false);
            if (!Toolkit.getToolkit().isFxUserThread()) {
                rv = pJob2D.printDialog(printReqAttrSet);
            } else {
                // If we are on the event thread, we need to check whether
                // we are allowed to call a nested event handler.
                if (!Toolkit.getToolkit().canStartNestedEventLoop()) {
                    throw new IllegalStateException(
              &quot;Printing is not allowed during animation or layout processing&quot;);
                }
                rv = showPrintDialogWithNestedLoop(owner);
            }
            if (rv) {
                updateSettingsFromDialog();
            }
        } finally {
            setEnabledState(owner, true);
        }
        return rv;
    }

    private class PrintDialogRunnable implements Runnable {

        public void run() {
            boolean rv = false;
            try {
                rv = pJob2D.printDialog(printReqAttrSet);
            } catch (Exception e) {
            } finally {
                Application.invokeLater(new ExitLoopRunnable(this, rv));
            }
        }
    }

    private boolean showPrintDialogWithNestedLoop(Window owner) {
        PrintDialogRunnable dr = new PrintDialogRunnable();
        Thread prtThread = new Thread(dr, &quot;FX Print Dialog Thread&quot;);
        prtThread.start();
        // the nested event loop will return after the runnable exits.
        Object rv = Toolkit.getToolkit().enterNestedEventLoop(dr);

        boolean rvbool = false;
        try {
            rvbool = ((Boolean)rv).booleanValue();
        } catch (Exception e) {
        }
        return rvbool;
    }

    public boolean showPageDialog(Window owner) {
        if (jobRunning || jobDone) {
            return false;
        }
        if (GraphicsEnvironment.isHeadless()) {
            return true;
        }

        if (onTopClass != null) {
            printReqAttrSet.remove(onTopClass);
        }
        if (owner != null) {
            long id = 0L;
            if (PlatformUtil.isWindows()) {
                id = WindowHelper.getPeer(owner).getRawHandle();
            }
            PrintRequestAttribute alwaysOnTop = getAlwaysOnTop(id);
            if (alwaysOnTop != null) {
                printReqAttrSet.add(alwaysOnTop);
            }
        }

        boolean rv = false;
        syncSettingsToAttributes();
        try {
            setEnabledState(owner, false);
            if (!Toolkit.getToolkit().isFxUserThread()) {
                PageFormat pf = pJob2D.pageDialog(printReqAttrSet);
                rv = pf != null;
            } else {
                // If we are on the event thread, we need to check whether
                // we are allowed to call a nested event handler.
                if (!Toolkit.getToolkit().canStartNestedEventLoop()) {
                    throw new IllegalStateException(
               &quot;Printing is not allowed during animation or layout processing&quot;);
                }
                rv = showPageDialogFromNestedLoop(owner);
            }
        } finally {
            setEnabledState(owner, true);
        }
        if (rv) {
            updateSettingsFromDialog();
        }
        return rv;
    }

    private class PageDialogRunnable implements Runnable {

        public void run() {
            PageFormat pf = null;
            try {
                pf = pJob2D.pageDialog(printReqAttrSet);
            } catch (Exception e) {
            } finally {
                Boolean rv = Boolean.valueOf(pf != null);
                Application.invokeLater(new ExitLoopRunnable(this, rv));
            }
        }
    }

    private boolean showPageDialogFromNestedLoop(Window owner) {

        PageDialogRunnable dr = new PageDialogRunnable();
        Thread prtThread = new Thread(dr, &quot;FX Page Setup Dialog Thread&quot;);
        prtThread.start();
        // the nested event loop will return after the runnable exits.
        Object rv = Toolkit.getToolkit().enterNestedEventLoop(dr);
        boolean rvbool = false;
        try {
            rvbool = ((Boolean)rv).booleanValue();
        } catch (Exception e) {
        }
        return rvbool;
    }

    /*
     * The update-Foo methods here are only used to update the
     * FX JobSettings as a result of changes by user interaction
     * with a print dialog. The new values are stored in the
     * PrintRequestAttributeSet and pulled from there in to the
     * equivalent FX public API JobSettings.
     */
    private void updateJobName() {
        String name =  pJob2D.getJobName();
        if (!name.equals(settings.getJobName())) {
            settings.setJobName(name);
        }
    }
    private void updateCopies() {
        int nCopies = pJob2D.getCopies();
        if (settings.getCopies() != nCopies) {
            settings.setCopies(nCopies);
        }
    }

    private void updatePageRanges() {
        PageRanges ranges = (PageRanges)printReqAttrSet.get(PageRanges.class);
        // JDK sets default to 1,Integer.MAX_VALUE
        // So in this case I think we can just check for non-null and
        // only set if its non-null.
        if (ranges != null) {
            int[][] members = ranges.getMembers();
            if (members.length == 1) {
                PageRange range = new PageRange(members[0][0], members[0][1]);
                settings.setPageRanges(range);
            } else if (members.length &gt; 0) {
                try {
                    ArrayList&lt;PageRange&gt; prList = new ArrayList&lt;PageRange&gt;();
                    int last = 0;
                    for (int i=0; i&lt;members.length;i++) {
                        int s = members[i][0];
                        int e = members[i][1];
                        if (s &lt;= last || e &lt; s) {
                            return;
                        }
                        last = e;
                        prList.add(new PageRange(s, e));
                    }
                    settings.setPageRanges(prList.toArray(new PageRange[0]));
                } catch (Exception e) {
                }
            }
        }
    }

    private void updateSides() {
        Sides sides = (Sides)printReqAttrSet.get(Sides.class);
        if (sides == null) {
            sides = (Sides)j2dPrinter.getService().
                getDefaultAttributeValue(Sides.class);
        }
        if (sides == Sides.ONE_SIDED) {
            settings.setPrintSides(PrintSides.ONE_SIDED);
        } else if (sides == Sides.DUPLEX) {
            settings.setPrintSides(PrintSides.DUPLEX);
        } else if (sides == Sides.TUMBLE) {
            settings.setPrintSides(PrintSides.TUMBLE);
        }
    }

    /* If the attribute set has an explicit setting for
     * collation, then its been set by the user at some point,
     * even if the current value is the printer default.
     * If there is no value for collation in the attribute set,
     * it means that we are u  sing the printer default.
     */
    private void updateCollation() {
        SheetCollate collate =
            (SheetCollate)printReqAttrSet.get(SheetCollate.class);
        if (collate == null) {
            collate = j2dPrinter.getDefaultSheetCollate();
        }
        if (collate == SheetCollate.UNCOLLATED) {
            settings.setCollation(Collation.UNCOLLATED);
        } else {
            settings.setCollation(Collation.COLLATED);
        }
    }

    private void updateColor() {
        Chromaticity color =
            (Chromaticity)printReqAttrSet.get(Chromaticity.class);
        if (color == null) {
            color = j2dPrinter.getDefaultChromaticity();
        }
        if (color == Chromaticity.COLOR) {
            settings.setPrintColor(PrintColor.COLOR);
        } else {
            settings.setPrintColor(PrintColor.MONOCHROME);
        }
    }

    private void updatePrintQuality() {
        PrintQuality quality =
            (PrintQuality)printReqAttrSet.get(PrintQuality.class);
        if (quality == null) {
            quality = j2dPrinter.getDefaultPrintQuality();
        }

        if (quality == PrintQuality.DRAFT) {
            settings.
                setPrintQuality(javafx.print.PrintQuality.DRAFT);
        } else if (quality == PrintQuality.HIGH) {
            settings.
                setPrintQuality(javafx.print.PrintQuality.HIGH);
        } else {
            settings.
                setPrintQuality(javafx.print.PrintQuality.NORMAL);
        }
    }

    private void updatePrintResolution() {
        PrinterResolution res =
            (PrinterResolution)printReqAttrSet.get(PrinterResolution.class);
        if (res == null) {
            res = j2dPrinter.getDefaultPrinterResolution();
        }
        int cfr = res.getCrossFeedResolution(ResolutionSyntax.DPI);
        int fr = res.getFeedResolution(ResolutionSyntax.DPI);
        settings.setPrintResolution(PrintHelper.createPrintResolution(cfr, fr));
    }

    private void updatePageLayout() {
        Media media = (Media)printReqAttrSet.get(Media.class);
        Paper paper = j2dPrinter.getPaperForMedia(media);
        OrientationRequested o = (OrientationRequested)
            printReqAttrSet.get(OrientationRequested.class);
        PageOrientation orient = J2DPrinter.reverseMapOrientation(o);
        MediaPrintableArea mpa =
            (MediaPrintableArea)printReqAttrSet.get(MediaPrintableArea.class);
        PageLayout newLayout;
        if (mpa == null) {
            newLayout = fxPrinter.createPageLayout(paper, orient,
                                                   MarginType.DEFAULT);
        } else {
            double pWid = paper.getWidth();
            double pHgt = paper.getHeight();
            int INCH = MediaPrintableArea.INCH;
            double mpaX = mpa.getX(INCH) * 72;
            double mpaY = mpa.getY(INCH) * 72;
            double mpaW = mpa.getWidth(INCH) * 72;
            double mpaH = mpa.getHeight(INCH) * 72;
            double lm=0, rm=0, tm=0, bm=0;
            switch (orient) {
            case PORTRAIT:
                lm = mpaX;
                rm = pWid - mpaX - mpaW;
                tm = mpaY;
                bm = pHgt - mpaY - mpaH;
                break;
            case REVERSE_PORTRAIT:
                lm = pWid - mpaX - mpaW;
                rm = mpaX;
                tm = pHgt - mpaY - mpaH;
                bm = mpaY;
                break;
            case LANDSCAPE:
                lm = mpaY;
                rm = pHgt - mpaY - mpaH;
                tm = pWid - mpaX - mpaW;
                bm = mpaX;
                break;
            case REVERSE_LANDSCAPE:
                lm = pHgt - mpaY - mpaH;
                tm = mpaX;
                rm = mpaY;
                bm = pWid - mpaX - mpaW;
                break;
            }
            if (Math.abs(lm) &lt; 0.01) lm = 0;
            if (Math.abs(rm) &lt; 0.01) rm = 0;
            if (Math.abs(tm) &lt; 0.01) tm = 0;
            if (Math.abs(bm) &lt; 0.01) bm = 0;
            newLayout = fxPrinter.createPageLayout(paper, orient,
                                                   lm, rm, tm, bm);
        }
        settings.setPageLayout(newLayout);
    }

    private void updatePaperSource() {
        Media m = (Media)printReqAttrSet.get(Media.class);
        if (m instanceof MediaTray) {
            PaperSource s = j2dPrinter.getPaperSource((MediaTray)m);
            if (s != null) {
                settings.setPaperSource(s);
            }
        }
    }

    private Printer getFXPrinterForService(PrintService service) {
        Set&lt;Printer&gt; printerSet = Printer.getAllPrinters();
        for (Printer p : printerSet) {
            J2DPrinter p2d = (J2DPrinter)PrintHelper.getPrinterImpl(p);
            PrintService s = p2d.getService();
            if (s.equals(service)) {
                return p;
            }
        }
        return fxPrinter; // current printer.
    }

    public void setPrinterImpl(PrinterImpl impl) {
        j2dPrinter = (J2DPrinter)impl;
        fxPrinter = j2dPrinter.getPrinter();
        try {
            pJob2D.setPrintService(j2dPrinter.getService());
        } catch (PrinterException pe) {
        }
    }

    public PrinterImpl getPrinterImpl() {
        return j2dPrinter;
    }

    private J2DPrinter getJ2DPrinter(Printer printer) {
        return (J2DPrinter)PrintHelper.getPrinterImpl(printer);
    }

    public Printer getPrinter() {
        return fxPrinter;
    }

    public void setPrinter(Printer printer) {
        fxPrinter = printer;
        j2dPrinter = getJ2DPrinter(printer);
        try {
            pJob2D.setPrintService(j2dPrinter.getService());
        } catch (PrinterException pe) {
        }
    }

    private void updatePrinter() {
        PrintService currService = j2dPrinter.getService();
        PrintService jobService = pJob2D.getPrintService();
<A NAME="29"></A>        if (currService.equals(jobService)) {
            return; // no change
        }
        <FONT color="#faafba"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#29',2,'match49-top.html#29',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Printer newFXPrinter = getFXPrinterForService(jobService);
        // The public setPrinter call also updates the job to be valid for
        // the new printer. Any old values not supported will be updated
        // to supported values. If we do that, then apply the new user
        // settings, any listener will see both sets of changes.
        // Its best to just see the single transition.
        fxPrinterJob.setPrinter(newFXPrinter);
    }

    private void updateSettingsFromDialog() {
        updatePrinter();
        updateJobName();
        updateCopies();
        updatePageRanges</B></FONT>();
        updateSides();
        updateCollation();
        updatePageLayout();
        updatePaperSource();
        updateColor();
        updatePrintQuality();
        updatePrintResolution();
    }

    private void syncSettingsToAttributes() {
        syncJobName();
        syncCopies();
        syncPageRanges();
        syncSides();
        syncCollation();
        syncPageLayout();
        syncPaperSource();
        syncColor();
        syncPrintQuality();
        syncPrintResolution();
    }

    private void syncJobName() {
        pJob2D.setJobName(settings.getJobName());
    }

    private void syncCopies() {
        pJob2D.setCopies(settings.getCopies());
        printReqAttrSet.add(new Copies(settings.getCopies()));
    }

    private void syncPageRanges() {
        printReqAttrSet.remove(PageRanges.class);
        PageRange[] prArr = settings.getPageRanges();
        if (prArr != null &amp;&amp; prArr.length&gt;0) {
            int len = prArr.length;
            int[][] ranges = new int[len][2];
            for (int i=0;i&lt;len;i++) {
                ranges[i][0] = prArr[i].getStartPage();
                ranges[i][1] = prArr[i].getEndPage();
            }
            printReqAttrSet.add(new PageRanges(ranges));
        }
    }

    private void syncSides() {
        Sides j2dSides = Sides.ONE_SIDED;
        PrintSides sides = settings.getPrintSides();
        if (sides == PrintSides.DUPLEX) {
            j2dSides = Sides.DUPLEX;
        } else if (sides == PrintSides.TUMBLE) {
            j2dSides = Sides.TUMBLE;
        }
        printReqAttrSet.add(j2dSides);
    }

    private void syncCollation() {
        if (settings.getCollation() == Collation.UNCOLLATED) {
            printReqAttrSet.add(SheetCollate.UNCOLLATED);
        } else {
            printReqAttrSet.add(SheetCollate.COLLATED);
        }

    }

    private void syncPageLayout() {
        PageLayout layout = settings.getPageLayout();
        PageOrientation orient = layout.getPageOrientation();
        printReqAttrSet.add(J2DPrinter.mapOrientation(orient));
        double pWid = layout.getPaper().getWidth();
        double pHgt = layout.getPaper().getHeight();
        float widthInInches = (float)(pWid/72.0);
        float heightInInches = (float)(pHgt/72.0);
        MediaSizeName media = MediaSize.findMedia(widthInInches,
                                                  heightInInches,
                                                  Size2DSyntax.INCH);
        if (media == null) {
            media = MediaSizeName.NA_LETTER;
        }
        printReqAttrSet.add(media);
        double ix=0, iy=0, iw=pWid, ih=pHgt;
        switch (orient) {
        case PORTRAIT:
            ix = layout.getLeftMargin();
            iy = layout.getTopMargin();
            iw = pWid - ix - layout.getRightMargin();
            ih = pHgt - iy - layout.getBottomMargin();
            break;
        case REVERSE_PORTRAIT:
            ix = layout.getRightMargin();
            iy = layout.getBottomMargin();
            iw = pWid - ix - layout.getLeftMargin();
            ih = pHgt - iy - layout.getTopMargin();
            break;
        case LANDSCAPE:
            ix = layout.getBottomMargin();
            iy = layout.getLeftMargin();
            iw = pWid - ix - layout.getTopMargin();
            ih = pHgt - iy - layout.getRightMargin();
            break;
        case REVERSE_LANDSCAPE:
            ix = layout.getTopMargin();
            iy = layout.getRightMargin();
            iw = pWid - ix - layout.getBottomMargin();
            ih = pHgt - iy - layout.getLeftMargin();
        }
        ix /= 72.0;
        iy /= 72.0;
        ih /= 72.0;
        iw /= 72.0;
        MediaPrintableArea mpa =
            new MediaPrintableArea((float)ix, (float)iy,
                                   (float)iw, (float)ih,
                                   MediaPrintableArea.INCH);
        printReqAttrSet.add(mpa);
    }

    private void syncPaperSource() {
        Media m = (Media)printReqAttrSet.get(Media.class);
        if (m != null &amp;&amp; m instanceof MediaTray) {
            printReqAttrSet.remove(Media.class);
        }
        PaperSource source = settings.getPaperSource();
        if (!source.equals(j2dPrinter.defaultPaperSource())) {
            MediaTray tray = j2dPrinter.getTrayForPaperSource(source);
            if (tray != null) {
                printReqAttrSet.add(tray);
            }
        }
    }

    private void syncColor() {
        if (settings.getPrintColor() == PrintColor.MONOCHROME) {
            printReqAttrSet.add(Chromaticity.MONOCHROME);
        } else {
            printReqAttrSet.add(Chromaticity.COLOR);
        }
    }

    private void syncPrintQuality() {
        javafx.print.PrintQuality
            quality = settings.getPrintQuality();
        PrintQuality j2DQuality;
        if (quality == javafx.print.PrintQuality.DRAFT) {
            j2DQuality = PrintQuality.DRAFT;
        } else if (quality == javafx.print.PrintQuality.HIGH) {
          j2DQuality = PrintQuality.HIGH;
        } else {
            j2DQuality = PrintQuality.NORMAL;
        }
        printReqAttrSet.add(j2DQuality);
    }

    private void syncPrintResolution() {
        /* An unsupported resolution results in incorrect scaling by J2D, so
         * remove any unsupported value, and only replace with a supported value.
         */
        PrintService ps = pJob2D.getPrintService();
        if (!ps.isAttributeCategorySupported(PrinterResolution.class)) {
            printReqAttrSet.remove(PrinterResolution.class);
            return;
        }
        PrinterResolution pres =
            (PrinterResolution)printReqAttrSet.get(PrinterResolution.class);
        if (pres != null &amp;&amp; !ps.isAttributeValueSupported(pres, null, null)) {
            printReqAttrSet.remove(PrinterResolution.class);
        };

        // Any resolution is now at least known to be supported for this device.
        PrintResolution res = settings.getPrintResolution();
        if (res == null) {
            return;
        }
        int cfRes = res.getCrossFeedResolution();
        int fRes = res.getFeedResolution();
        pres = new PrinterResolution(cfRes, fRes, ResolutionSyntax.DPI);
        if (!ps.isAttributeValueSupported(pres, null, null)) {
            return;
        }
        // We have validated its a supported value, so add it.
        printReqAttrSet.add(pres);
    }

    public PageLayout validatePageLayout(PageLayout pageLayout) {
        boolean needsNewLayout = false;
        PrinterAttributes caps = fxPrinter.getPrinterAttributes();
        Paper p = pageLayout.getPaper();
        if (!caps.getSupportedPapers().contains(p)) {
            needsNewLayout = true;
            p = caps.getDefaultPaper();
        }
        PageOrientation o = pageLayout.getPageOrientation();
        if (!caps.getSupportedPageOrientations().contains(o)) {
            needsNewLayout = true;
            o = caps.getDefaultPageOrientation();
        }
        if (needsNewLayout) {
            pageLayout = fxPrinter.createPageLayout(p, o, MarginType.DEFAULT);
        }
        return pageLayout;
    }

    private boolean jobRunning = false;
    private boolean jobError = false;
    private boolean jobDone = false;
    private J2DPageable j2dPageable = null;

    /*
     * Permissions were already checked when creating the job,
     * and when setting output file, but this is a final check
     * to be made before we start the underlying native job.
     */
    private void checkPermissions() {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
            security.checkPrintJobAccess();
        }
    }

    /*
     * 2D uses a call back model. So the 2D PrinterJob needs to run
     * on a different thread than the one that the FX app uses.
     * This gets really interesting if the FX Node is attached to a
     * scene, as you are only supposed to update it on the FX thread
     * and the PG code can only access it during sync.
     */
    public boolean print(PageLayout pageLayout, Node node) {
        if (Toolkit.getToolkit().isFxUserThread()) {
            // If we are on the event thread, we need to check whether we are
            // allowed to call a nested event handler.
            if (!Toolkit.getToolkit().canStartNestedEventLoop()) {
                throw new IllegalStateException(&quot;Printing is not allowed during animation or layout processing&quot;);
            }
        }

        if (jobError || jobDone) {
            return false;
        }

        if (!jobRunning) {
            checkPermissions();
            syncSettingsToAttributes();
            PrintJobRunnable runnable = new PrintJobRunnable();
            Thread prtThread = new Thread(runnable, &quot;Print Job Thread&quot;);
            prtThread.start();
            jobRunning = true;
        }
        try {
            j2dPageable.implPrintPage(pageLayout, node);
        } catch (Throwable t) {
            if (com.sun.prism.impl.PrismSettings.debug) {
                System.err.println(&quot;printPage caught exception.&quot;);
                t.printStackTrace();
            }
            jobError = true;
            jobDone = true;
        }
        return !jobError;
    }

    private class PrintJobRunnable implements Runnable {

        public void run() {

            try {
                pJob2D.print(printReqAttrSet);
                jobDone = true;
            } catch (Throwable t) { /* subsumes declared PrinterException */
                if (com.sun.prism.impl.PrismSettings.debug) {
                    System.err.println(&quot;print caught exception.&quot;);
                    t.printStackTrace();
                }
                jobError = true;
                jobDone = true;
            }
            /*
             * If the job ends because its reached a page range limit
             * rather than calling getPage() we need to exit the nested loop.
             */
            if (elo != null) {
                Application.invokeLater(new ExitLoopRunnable(elo, null));
            }
        }
    }

    static class LayoutRunnable implements Runnable {
        PageInfo pageInfo;

        LayoutRunnable(PageInfo info) {
            pageInfo = info;
        }

        public void run() {
            if (pageInfo.tempScene &amp;&amp; pageInfo.root.getScene() == null) {
                new Scene(pageInfo.root);
            }
            NodeHelper.layoutNodeForPrinting(pageInfo.root);
        }
    }

    static class ClearSceneRunnable implements Runnable {
        PageInfo pageInfo;

        ClearSceneRunnable(PageInfo info) {
            pageInfo = info;
        }

        public void run() {
            pageInfo.clearScene();
        }
    }

    private static class PageInfo {

        private PageLayout pageLayout;
        private Node node;
        private Parent root;
        private Node topNode;
        private Group group;
        private boolean tempGroup;
        private boolean tempScene;
        private boolean sceneInited;

        PageInfo(PageLayout pageLayout, Node node) {
            this.pageLayout = pageLayout;
            this.node = node;
        }

        Node getNode() {
            initScene();
            return node;
        }

        PageLayout getPageLayout() {
            return pageLayout;
        }

        /*
         * There are 4 scenarios here.
         * 1. We are passed the root node of a Scene.
         * 2. We are passed a child node of a Scene, but not the root
         * 3. We are passed a root node (no parent) but its not attached
         * to a Scene.
         * 4. We are passed a child node, but its not part of a Scene.
         * In addition we may be called on the FX thread, or not.
         * The code here is trying to make all of these work without
         * the application needing to do anything special, and hopefully
         * without affecting the application.
         * The application should not be surprised if we request layout for it,
         * since we can't display or print an unlaid out hiearchy.
         *
         * If this is the FX thread, then we can do everything directly.
         * If not, we must add the node to a scene (if needed) and
         * request layout on another thread.
         * I am assuming here that layout will be a quick no-op if
         * everything is already laid out.
         * Eventually all of this should be able to be performed on any
         * thread, and without attaching to a scene, so this is largely
         * workaround. One part I'm not so sure about is whether it
         * will ever be the case that being passed a node that is part
         * of a hierarchy, but not its root, will be able to be laid out
         * directly, or if you need to traverse to the root.
         */
        void initScene() {
            if (sceneInited) {
               return;
            }
            if (node.getScene() == null) {
                tempScene = true;
                Node topNode = node;
                while (topNode.getParent() != null) {
                    topNode = topNode.getParent();
                }
                if (topNode instanceof Group) {
                    group = (Group)topNode;
                } else {
                    tempGroup = true;
                    group = new Group();
                    group.getChildren().add(topNode);
                }
                root = group;
            } else {
                root = node.getScene().getRoot();
            }
            if (Toolkit.getToolkit().isFxUserThread()) {
                if (tempScene &amp;&amp; root.getScene() == null) {
                    new Scene(root); // don't need to keep the scene variable
                }
                NodeHelper.layoutNodeForPrinting(root);
            } else {
                Application.invokeAndWait(new LayoutRunnable(this));
            }
            sceneInited = true;
        }

        private void clearScene() {
            if (tempGroup) {
                group.getChildren().removeAll(root);
            }
            tempGroup = false;
            tempScene = false;
            root = null;
            group = null;
            topNode = null;
            sceneInited = false;
        }
    }

    private Object monitor = new Object();

    static class ExitLoopRunnable implements Runnable {
        Object elo, rv;

        ExitLoopRunnable(Object elo, Object rv) {
            this.elo = elo;
            this.rv = rv;
        }

        public void run() {
            Toolkit.getToolkit().exitNestedEventLoop(elo, rv);
        }
    }

    private class J2DPageable implements Pageable, Printable {

        private volatile boolean pageDone;

        private int currPageIndex = -1;

        private volatile PageInfo newPageInfo = null;
        private PageInfo currPageInfo;
        private PageFormat currPageFormat;


        private boolean waitForNextPage(int pageIndex) {

            if (elo != null &amp;&amp; currPageInfo != null) {
                Application.invokeLater(new ExitLoopRunnable(elo, null));
            }

            if (currPageInfo != null) {
                if (Toolkit.getToolkit().isFxUserThread()) {
                    currPageInfo.clearScene();
                } else {
                    Application.
                        invokeAndWait(new ClearSceneRunnable(currPageInfo));
                }
            }
            currPageInfo = null;
            pageDone = true;
            synchronized (monitor) {
                if (newPageInfo == null) {
                    monitor.notify(); // page is printed and no new page to print
                }
                while (newPageInfo == null &amp;&amp; !jobDone &amp;&amp; !jobError) {
                    try {
                        monitor.wait(1000);
                    } catch (InterruptedException e) {
                    }
                }
            }
            if (jobDone || jobError) {
                return false;
            }
            currPageInfo = newPageInfo;
            newPageInfo = null;
            currPageIndex = pageIndex;
            currPageFormat = getPageFormatFromLayout(currPageInfo.getPageLayout());
            return true;
        }

        private PageFormat getPageFormatFromLayout(PageLayout layout) {
            java.awt.print.Paper paper = new java.awt.print.Paper();
            double pWid = layout.getPaper().getWidth();
            double pHgt = layout.getPaper().getHeight();
            double ix=0, iy=0, iw=pWid, ih=pHgt;
            PageOrientation orient = layout.getPageOrientation();
            switch (orient) {
            case PORTRAIT:
                ix = layout.getLeftMargin();
                iy = layout.getTopMargin();
                iw = pWid - ix - layout.getRightMargin();
                ih = pHgt - iy - layout.getBottomMargin();
                break;
            case REVERSE_PORTRAIT:
                ix = layout.getRightMargin();
                iy = layout.getBottomMargin();
                iw = pWid - ix - layout.getLeftMargin();
                ih = pHgt - iy - layout.getTopMargin();
                break;
            case LANDSCAPE:
                ix = layout.getBottomMargin();
                iy = layout.getLeftMargin();
                iw = pWid - ix - layout.getTopMargin();
                ih = pHgt - iy - layout.getRightMargin();
                break;
            case REVERSE_LANDSCAPE:
                ix = layout.getTopMargin();
                iy = layout.getRightMargin();
                iw = pWid - ix - layout.getBottomMargin();
                ih = pHgt - iy - layout.getLeftMargin();
            }
            paper.setSize(pWid, pHgt);
            paper.setImageableArea(ix, iy, iw, ih);
            PageFormat format = new PageFormat();
            format.setOrientation(J2DPrinter.getOrientID(orient));
            format.setPaper(paper);
            return format;
        }

        private boolean getPage(int pageIndex) {
            if (pageIndex == currPageIndex) {
                return true;
            }
            boolean nextPage = false;
            if (pageIndex &gt; currPageIndex) {
                nextPage = waitForNextPage(pageIndex);
            }
            return nextPage;
        }

        public int print(Graphics g, PageFormat pf, int pageIndex) {
            if (jobError || jobDone || !getPage(pageIndex)) {
                return Printable.NO_SUCH_PAGE;
            }
            int x = (int)pf.getImageableX();
            int y = (int)pf.getImageableY();
            int w = (int)pf.getImageableWidth();
            int h = (int)pf.getImageableHeight();
            Node appNode = currPageInfo.getNode();
            g.translate(x, y);
            printNode(appNode, g, w, h);
            return Printable.PAGE_EXISTS;
        }

        private void printNode(Node node, Graphics g, int w, int h) {
            PrismPrintGraphics ppg =
                    new PrismPrintGraphics((Graphics2D) g, w, h);
            NGNode pgNode = NodeHelper.getPeer(node);
            boolean errored = false;
            try {
                pgNode.render(ppg);
            } catch (Throwable t) {
                if (com.sun.prism.impl.PrismSettings.debug) {
                    System.err.println(&quot;printNode caught exception.&quot;);
                    t.printStackTrace();
                }
                errored = true;
            }
            ppg.getResourceFactory()
                    .getTextureResourcePool()
                    .freeDisposalRequestedAndCheckResources(errored);
        }

        public Printable getPrintable(int pageIndex) {
            getPage(pageIndex);
            return this;
        }

        public PageFormat getPageFormat(int pageIndex) {
            getPage(pageIndex);
            return currPageFormat;
        }

        /*
         * Since we return unknown number of pages, then
         * the behaviour must be that we can only signal
         * end of the job by returning NO_SUCH_PAGE from
         * the print(..) method.
         */
        public int getNumberOfPages() {
            return Pageable.UNKNOWN_NUMBER_OF_PAGES;
        }

        /*
         * Executed on the application's thread.
         * Messages over to the printing thread.
         */
        private void implPrintPage(PageLayout pageLayout, Node node) {

            /* The public API printPage() is synchronized, so we know
             * that the app can't call it from 2 threads at the same
             * time, not that this is encouraged either.
             * Therefore when we are in this code, we know that any
             * previous page rendering has completed.
             * We also know that this means the app can't have 'queued up'
             * pages.
             * So, when we are in here, we know that the app is providing
             * the info for the next page.
             */
            pageDone = false;
            synchronized (monitor) {
                newPageInfo = new PageInfo(pageLayout, node);
                monitor.notify();
            }
            if (Toolkit.getToolkit().isFxUserThread()) {
                elo = new Object();
                Toolkit.getToolkit().enterNestedEventLoop(elo);
                elo = null;
            } else {
                while (!pageDone &amp;&amp; !jobDone &amp;&amp; !jobError) {
                    synchronized (monitor) {
                        try {
                            if (!pageDone) {
                                monitor.wait(1000);
                            }
                        } catch (InterruptedException e) {
                        }
                    }
                }
            }
        }

    } /* END J2DPageable class */


    public boolean endJob() {
        if (jobRunning &amp;&amp; !jobDone &amp;&amp; !jobError) {
            jobDone = true;
            try {
                synchronized (monitor) {
                    monitor.notify();
                    return jobDone;
                }
            } catch (IllegalStateException e) {
                if (com.sun.prism.impl.PrismSettings.debug) {
                    System.err.println(&quot;Internal Error &quot; + e);
                }
            }
        } else {
            return jobDone &amp;&amp; !jobError;
        }
        return jobDone;
    }

    public void cancelJob() {
        if (!pJob2D.isCancelled()) {
            pJob2D.cancel();
        }
        jobDone = true;
        if (jobRunning) {
            jobRunning = false;
            try {
                synchronized (monitor) {
                    monitor.notify();
                }
            } catch (IllegalStateException e) {
                if (com.sun.prism.impl.PrismSettings.debug) {
                    System.err.println(&quot;Internal Error &quot; + e);
                }
            }
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/scenario/effect/PhongLighting.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2008, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.scenario.effect;

import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.DirtyRegionContainer;
import com.sun.javafx.geom.DirtyRegionPool;
import com.sun.javafx.geom.Point2D;
import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.scenario.effect.impl.state.RenderState;
import com.sun.scenario.effect.light.Light;

/**
 * An effect that applies diffuse and specular lighting to an arbitrary
 * input using a positionable light source.
 */
public class PhongLighting extends CoreEffect&lt;RenderState&gt; {

    private float surfaceScale;
    private float diffuseConstant;
    private float specularConstant;
    private float specularExponent;
    private Light light;

    /**
     * Constructs a new {@code PhongLighting} effect for the given
     * {@code Light}, with default values for all other properties,
     * using the default input for source data.
     * This is a convenience constructor that automatically generates a
     * bump map using the default input.
     *
     * @param light the light source
     * @throws IllegalArgumentException if {@code light} is null
     */
    public PhongLighting(Light light) {
        this(light, new GaussianShadow(10f), DefaultInput);
    }

    /**
     * Constructs a new {@code PhongLighting} effect for the given
     * {@code Light} and the given bump and content input {@code Effect}s
     * with default values for all other properties.
     *
     * @param light the light source
     * @param bumpInput the input containing the bump map
     * @param contentInput the input containing the content data
     * @throws IllegalArgumentException if {@code light} is null
     */
    public PhongLighting(Light light, Effect bumpInput, Effect contentInput) {
        super(bumpInput, contentInput);

        this.surfaceScale = 1f;
        this.diffuseConstant = 1f;
        this.specularConstant = 1f;
        this.specularExponent = 1f;

        setLight(light);
    }

    /**
     * Returns the bump input for this {@code Effect}.
     *
     * @return the bump input for this {@code Effect}
     */
    public final Effect getBumpInput() {
        return getInputs().get(0);
    }

    /**
     * Sets the bump input for this {@code Effect} to a specific
     * {@code Effect} or to the default input if {@code input} is
     * {@code null}.
     *
<A NAME="15"></A>     * @param bumpInput the bump input for this {@code Effect}
     */
    public void setBumpInput(Effect bumpInput) {
        <FONT color="#3bb9ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#15',2,'match49-top.html#15',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>setInput(0, bumpInput);
    }

    /**
     * Returns the content input for this {@code Effect}.
     *
     * @return the content input for this {@code Effect}
     */
    public final Effect getContentInput() {
        return getInputs().get(1);
    }

    private Effect getContentInput(Effect defaultInput) {
        return</B></FONT> getDefaultedInput(1, defaultInput);
    }

    /**
     * Sets the content input for this {@code Effect} to a specific
     * {@code Effect} or to the default input if {@code input} is
     * {@code null}.
     *
     * @param contentInput the content input for this {@code Effect}
     */
    public void setContentInput(Effect contentInput) {
        setInput(1, contentInput);
    }

    /**
     * Returns the light source.
     *
     * @return the light source
     */
    public Light getLight() {
        return light;
    }

    /**
     * Sets the light source.
     *
     * @param light the light source
     * @throws IllegalArgumentException if {@code light} is null
     */
    public void setLight(Light light) {
        if (light == null) {
            throw new IllegalArgumentException(&quot;Light must be non-null&quot;);
        }
        this.light = light;
        updatePeerKey(&quot;PhongLighting_&quot; + light.getType().name());
    }

    /**
     * Returns the diffuse constant.
     *
     * @return the diffuse constant value
     */
    public float getDiffuseConstant() {
        return diffuseConstant;
    }

    /**
     * Sets the diffuse constant.
     * &lt;pre&gt;
     *       Min: 0.0
     *       Max: 2.0
     *   Default: 1.0
     *  Identity: n/a
     * &lt;/pre&gt;
     *
     * @param diffuseConstant the diffuse constant value
     * @throws IllegalArgumentException if {@code diffuseConstant} is outside
     * the allowable range
     */
    public void setDiffuseConstant(float diffuseConstant) {
        if (diffuseConstant &lt; 0f || diffuseConstant &gt; 2f) {
            throw new IllegalArgumentException(&quot;Diffuse constant must be in the range [0,2]&quot;);
        }
        float old = this.diffuseConstant;
        this.diffuseConstant = diffuseConstant;
    }

    /**
     * Returns the specular constant.
     *
     * @return the specular constant value
     */
    public float getSpecularConstant() {
        return specularConstant;
    }

    /**
     * Sets the specular constant.
     * &lt;pre&gt;
     *       Min: 0.0
     *       Max: 2.0
     *   Default: 1.0
     *  Identity: n/a
     * &lt;/pre&gt;
     *
     * @param specularConstant the specular constant value
     * @throws IllegalArgumentException if {@code specularConstant} is outside
     * the allowable range
     */
    public void setSpecularConstant(float specularConstant) {
        if (specularConstant &lt; 0f || specularConstant &gt; 2f) {
            throw new IllegalArgumentException(&quot;Specular constant must be in the range [0,2]&quot;);
        }
        float old = this.specularConstant;
        this.specularConstant = specularConstant;
    }

    /**
     * Returns the specular exponent.
     *
     * @return the specular exponent value
     */
    public float getSpecularExponent() {
        return specularExponent;
    }

    /**
     * Sets the specular exponent.
     * &lt;pre&gt;
     *       Min:  0.0
     *       Max: 40.0
     *   Default:  1.0
     *  Identity:  n/a
     * &lt;/pre&gt;
     *
     * @param specularExponent the specular exponent value
     * @throws IllegalArgumentException if {@code specularExponent} is outside
     * the allowable range
     */
    public void setSpecularExponent(float specularExponent) {
        if (specularExponent &lt; 0f || specularExponent &gt; 40f) {
            throw new IllegalArgumentException(&quot;Specular exponent must be in the range [0,40]&quot;);
        }
        float old = this.specularExponent;
        this.specularExponent = specularExponent;
    }

    /**
     * Returns the surface scale.
     *
     * @return the surface scale value
     */
    public float getSurfaceScale() {
        return surfaceScale;
    }

    /**
     * Sets the surface scale.
     * &lt;pre&gt;
     *       Min:  0.0
     *       Max: 10.0
     *   Default:  1.0
     *  Identity:  n/a
     * &lt;/pre&gt;
     *
     * @param surfaceScale the surface scale value
     * @throws IllegalArgumentException if {@code surfaceScale} is outside
     * the allowable range
     */
    public void setSurfaceScale(float surfaceScale) {
        if (surfaceScale &lt; 0f || surfaceScale &gt; 10f) {
            throw new IllegalArgumentException(&quot;Surface scale must be in the range [0,10]&quot;);
        }
        float old = this.surfaceScale;
        this.surfaceScale = surfaceScale;
    }

    @Override
    public BaseBounds getBounds(BaseTransform transform,
                              Effect defaultInput)
    {
        // effect inherits its bounds from the content input
        return getContentInput(defaultInput).getBounds(transform, defaultInput);
    }

    @Override
    public Rectangle getResultBounds(BaseTransform transform,
                                     Rectangle outputClip,
                                     ImageData... inputDatas)
    {
        // result inherits its dimensions from the content input
        return super.getResultBounds(transform, outputClip, inputDatas[1]);
    }

    @Override
    public Point2D transform(Point2D p, Effect defaultInput) {
        return getContentInput(defaultInput).transform(p, defaultInput);
    }

    @Override
    public Point2D untransform(Point2D p, Effect defaultInput) {
        return getContentInput(defaultInput).untransform(p, defaultInput);
    }

    @Override
    public RenderState getRenderState(FilterContext fctx,
                                      BaseTransform transform,
                                      Rectangle outputClip,
                                      Object renderHelper,
                                      Effect defaultInput)
    {
        // RT-27564
        // TODO: Since only the content input is used for the output bounds
        // we could attempt to factor the bounds of the content input in our
        // answer for the getInputClip() method of the RenderState, but for
        // now we will just use (a close copy of) the stock RenderSpaceRenderState object.
        return new RenderState() {
            @Override
            public EffectCoordinateSpace getEffectTransformSpace() {
                return EffectCoordinateSpace.RenderSpace;
            }

            @Override
            public BaseTransform getInputTransform(BaseTransform filterTransform) {
                return filterTransform;
            }

            @Override
            public BaseTransform getResultTransform(BaseTransform filterTransform) {
                return BaseTransform.IDENTITY_TRANSFORM;
            }

            @Override
            public Rectangle getInputClip(int i, Rectangle filterClip) {
                if (i == 0 &amp;&amp; filterClip != null) {
                    Rectangle r = new Rectangle(filterClip);
                    r.grow(1, 1);
                    return r;
                }
                return filterClip;
            }
        };
    }

    @Override
    public boolean reducesOpaquePixels() {
        final Effect contentInput = getContentInput();
        return contentInput != null &amp;&amp; contentInput.reducesOpaquePixels();
    }

    @Override
    public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
        Effect bump = getDefaultedInput(0, defaultInput);
        DirtyRegionContainer drc1 = bump.getDirtyRegions(defaultInput, regionPool);
        drc1.grow(1, 1);

        Effect content = getDefaultedInput(1, defaultInput);
        DirtyRegionContainer drc2 = content.getDirtyRegions(defaultInput, regionPool);

        drc1.merge(drc2);
        regionPool.checkIn(drc2);

        return drc1;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/com/sun/scenario/effect/impl/state/BoxRenderState.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.scenario.effect.impl.state;

import com.sun.javafx.geom.Rectangle;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.geom.transform.NoninvertibleTransformException;
import com.sun.scenario.effect.Color4f;
import com.sun.scenario.effect.Effect;
import com.sun.scenario.effect.FilterContext;
import com.sun.scenario.effect.Filterable;
import com.sun.scenario.effect.ImageData;
import com.sun.scenario.effect.impl.BufferUtil;
import com.sun.scenario.effect.impl.EffectPeer;
import com.sun.scenario.effect.impl.Renderer;
import java.nio.FloatBuffer;

/**
 * The RenderState for a box filter kernel that can be applied using a
 * standard linear convolution kernel.
 * A box filter has a size that represents how large of an area around a
 * given pixel should be averaged.  If the size is 1.0 then just the pixel
 * itself should be averaged and the operation is a NOP.  Values smaller
 * than that are automatically treated as 1.0/NOP.
 * For any odd size, the kernel weights the center pixel and an equal number
 * of pixels on either side of it equally, so the weights for size 2N+1 are:
 * [ {N copes of 1.0} 1.0 {N more copies of 1.0} ]
 * As the size grows past that integer size, we must then add another kernel
 * weight entry on both sides of the existing array of 1.0 weights and give
 * them a fractional weight of half of the amount we exceeded the last odd
 * size, so the weights for some size (2N+1)+e (e for epsilon) are:
 * [ e/2.0 {2*N+1 copies of 1.0} e/2.0 ]
 * As the size continues to grow, when it reaches the next even size, we get
 * weights for size 2*N+1+1 to be:
 * [ 0.5 {2*N+1 copies of 1.0} 0.5 ]
 * and as the size continues to grow and approaches the next odd number, we
 * see that 2(N+1)+1 == 2N+2+1 == 2N+1 + 2, so (e) approaches 2 and the
 * numbers on each end of the weights array approach e/2.0 == 1.0 and we end
 * up back at the pattern for an odd size again:
 * [ 1.0 {2*N+1 copies of 1.0} 1.0 ]
 *
 * ***************************
 * SOFTWARE LIMITATION CAVEAT:
 * ***************************
 *
 * Note that the highly optimized software filters for BoxBlur/Shadow will
 * actually do a very optimized &quot;running sum&quot; operation that is only currently
 * implemented for equal weighted kernels.  Also, until recently we had always
 * been rounding down the size by casting it to an integer at a high level (in
 * the FX layer peer synchronization code), so for now the software filters
 * may only implement a subset of the above theory and new optimized loops that
 * allow partial sums on the first and last values will need to be written.
 * Until then we will be rounding the sizes to an odd size, but only in the
 * sw loops.
 */
public class BoxRenderState extends LinearConvolveRenderState {
    private static final int MAX_BOX_SIZES[] = {
        getMaxSizeForKernelSize(MAX_KERNEL_SIZE, 0),
        getMaxSizeForKernelSize(MAX_KERNEL_SIZE, 1),
        getMaxSizeForKernelSize(MAX_KERNEL_SIZE, 2),
        getMaxSizeForKernelSize(MAX_KERNEL_SIZE, 3),
    };

    private final boolean isShadow;
    private final int blurPasses;
    private final float spread;
    private Color4f shadowColor;

    private EffectCoordinateSpace space;
    private BaseTransform inputtx;
    private BaseTransform resulttx;
    private final float inputSizeH;
    private final float inputSizeV;
    private final int spreadPass;
    private float samplevectors[];

    private int validatedPass;
    private float passSize;
    private FloatBuffer weights;
    private float weightsValidSize;
    private float weightsValidSpread;
    private boolean swCompatible;  // true if we can use the sw peers

    public static int getMaxSizeForKernelSize(int kernelSize, int blurPasses) {
        if (blurPasses == 0) {
            return Integer.MAX_VALUE;
        }
        // Kernel sizes are always odd, so if the supplied ksize is even then
        // we need to use ksize-1 to compute the max as that is actually the
        // largest kernel we will be able to produce that is no larger than
        // ksize for any given pass size.
        int passSize = (kernelSize - 1) | 1;
        passSize = ((passSize - 1) / blurPasses) | 1;
        assert getKernelSize(passSize, blurPasses) &lt;= kernelSize;
        return passSize;
    }

    public static int getKernelSize(int passSize, int blurPasses) {
        int kernelSize = (passSize &lt; 1) ? 1 : passSize;
        kernelSize = (kernelSize-1) * blurPasses + 1;
        kernelSize |= 1;
        return kernelSize;
    }

    public BoxRenderState(float hsize, float vsize, int blurPasses, float spread,
                          boolean isShadow, Color4f shadowColor, BaseTransform filtertx)
    {
        /*
         * The operation starts as a description of the size of a (pair of)
         * box filter kernels measured relative to that user space coordinate
         * system and to be applied horizontally and vertically in that same
         * space.  The presence of a filter transform can mean that the
         * direction we apply the box convolutions could change as well
         * as the new size of the box summations relative to the pixels
         * produced under that transform.
         *
         * Since the box filter is best described by the summation of a range
         * of discrete pixels horizontally and vertically, and since the
         * software algorithms vastly prefer applying the sums horizontally
         * and vertically to groups of whole pixels using an incremental &quot;add
         * the next pixel at the front edge of the box and subtract the pixel
         * that is at the back edge of the box&quot; technique, we will constrain
         * our box size to an integer size and attempt to force the inputs
         * to produce an axis aligned intermediate image.  But, in the end,
         * we must be prepared for an arbitrary transform on the input image
         * which essentially means being able to back off to an arbitrary
         * invocation on the associated LinearConvolvePeer from the software
         * hand-written Box peers.
         *
         * We will track the direction and size of the box as we traverse
         * different coordinate spaces with the intent that eventually we
         * will perform the math of the convolution with weights calculated
         * for one sample per pixel in the indicated direction and applied as
         * closely to the intended final filter transform as we can achieve
         * with the following caveats (very similar to the caveats for the
         * more general GaussianRenderState):
         *
         * - There is a maximum kernel size that the hardware pixel shaders
         *   can apply so we will try to keep the scaling of the filtered
         *   pixels low enough that we do not exceed that data limitation.
         *
         * - Software vastly prefers to apply these weights along horizontal
         *   and vertical vectors, but can apply them in an arbitrary direction
         *   if need be by backing off to the generic LinearConvolvePeer.
         *
         * - If the box is large enough, then applying a smaller box kernel
         *   to a downscaled input is close enough to applying the larger box
         *   to a larger scaled input.  Our maximum kernel size is large enough
         *   for this effect to be hidden if we max out the kernel.
         *
         * - We can tell the inputs what transform we want them to use, but
         *   they can always produce output under a different transform and
         *   then return a result with a &quot;post-processing&quot; trasnform to be
         *   applied (as we are doing here ourselves).  Thus, we can plan
         *   how we want to apply the convolution weights and samples here,
         *   but we will have to reevaluate our actions when the actual
         *   input pixels are created later.
         *
         * - We will try to blur at a nice axis-aligned orientation (which is
         *   preferred for the software versions of the shaders) and perform
         *   any rotation and skewing in the final post-processing result
         *   transform as that amount of blurring will quite effectively cover
         *   up any distortion that would occur by not rendering at the
         *   appropriate angles.
         *
         * To achieve this we start out with untransformed sample vectors
         * which are unit vectors along the X and Y axes.  We transform them
         * into the requested filter space, adjust the kernel size and see
         * if we can support that kernel size.  If it is too large of a
         * projected kernel, then we request the input at a smaller scale
         * and perform a maximum kernel convolution on it and then indicate
         * that this result will need to be scaled by the caller.  When this
         * method is done we will have computed what we need to do to the
         * input pixels when they come in if the inputtx was honored, otherwise
         * we may have to adjust the values further in {@link @validateInput()}.
         */
        this.isShadow = isShadow;
        this.shadowColor = shadowColor;
        this.spread = spread;
        this.blurPasses = blurPasses;
        if (filtertx == null) filtertx = BaseTransform.IDENTITY_TRANSFORM;
        double txScaleX = Math.hypot(filtertx.getMxx(), filtertx.getMyx());
        double txScaleY = Math.hypot(filtertx.getMxy(), filtertx.getMyy());
        float fSizeH = (float) (hsize * txScaleX);
        float fSizeV = (float) (vsize * txScaleY);
        int maxPassSize = MAX_BOX_SIZES[blurPasses];
        if (fSizeH &gt; maxPassSize) {
            txScaleX = maxPassSize / hsize;
            fSizeH = maxPassSize;
        }
        if (fSizeV &gt; maxPassSize) {
            txScaleY = maxPassSize / vsize;
            fSizeV = maxPassSize;
        }
        this.inputSizeH = fSizeH;
        this.inputSizeV = fSizeV;
        this.spreadPass = (fSizeV &gt; 1) ? 1 : 0;
        // We always want to use an unrotated space to do our filtering, so
        // we interpose our scaled-only space in all cases, but we do check
        // if it happens to be equivalent (ignoring translations) to the
        // original filtertx so we can avoid introducing extra layers of
        // transforms.
        boolean custom = (txScaleX != filtertx.getMxx() ||
                          0.0      != filtertx.getMyx() ||
                          txScaleY != filtertx.getMyy() ||
                          0.0      != filtertx.getMxy());
        if (custom) {
            this.space = EffectCoordinateSpace.CustomSpace;
            this.inputtx = BaseTransform.getScaleInstance(txScaleX, txScaleY);
            this.resulttx = filtertx
                .copy()
                .deriveWithScale(1.0 / txScaleX, 1.0 / txScaleY, 1.0);
        } else {
            this.space = EffectCoordinateSpace.RenderSpace;
            this.inputtx = filtertx;
            this.resulttx = BaseTransform.IDENTITY_TRANSFORM;
        }
        // assert inputtx.mxy == inputtx.myx == 0.0
    }

    public int getBoxPixelSize(int pass) {
        float size = passSize;
        if (size &lt; 1.0f) size = 1.0f;
        int boxsize = ((int) Math.ceil(size)) | 1;
        return boxsize;
    }

    public int getBlurPasses() {
        return blurPasses;
    }

    public float getSpread() {
        return spread;
    }

    @Override
    public boolean isShadow() {
        return isShadow;
    }

    @Override
    public Color4f getShadowColor() {
        return shadowColor;
    }

    @Override
    public float[] getPassShadowColorComponents() {
        return (validatedPass == 0)
            ? BLACK_COMPONENTS
            : shadowColor.getPremultipliedRGBComponents();
    }

    @Override
    public EffectCoordinateSpace getEffectTransformSpace() {
        return space;
    }

    @Override
    public BaseTransform getInputTransform(BaseTransform filterTransform) {
        return inputtx;
    }

    @Override
    public BaseTransform getResultTransform(BaseTransform filterTransform) {
        return resulttx;
    }

    @Override
    public EffectPeer&lt;BoxRenderState&gt; getPassPeer(Renderer r, FilterContext fctx) {
        if (isPassNop()) {
            return null;
        }
        int ksize = getPassKernelSize();
        int psize = getPeerSize(ksize);
        Effect.AccelType actype = r.getAccelType();
        String name;
        switch (actype) {
            case NONE:
            case SIMD:
                if (swCompatible &amp;&amp; spread == 0.0f) {
                    name = isShadow() ? &quot;BoxShadow&quot; : &quot;BoxBlur&quot;;
                    break;
                }
                /* FALLS THROUGH */
            default:
                name = isShadow() ? &quot;LinearConvolveShadow&quot; : &quot;LinearConvolve&quot;;
                break;
        }
        EffectPeer peer = r.getPeerInstance(fctx, name, psize);
        return peer;
    }

    @Override
    public Rectangle getInputClip(int i, Rectangle filterClip) {
        if (filterClip != null) {
            int klenh = getInputKernelSize(0);
            int klenv = getInputKernelSize(1);
            if ((klenh | klenv) &gt; 1) {
                filterClip = new Rectangle(filterClip);
                // We actually want to grow them by (klen-1)/2, but since we
                // have forced the klen sizes to be odd above, a simple integer
                // divide by 2 is enough...
                filterClip.grow(klenh/2, klenv/2);
            }
        }
        return filterClip;
    }

    @Override
    public ImageData validatePassInput(ImageData src, int pass) {
        this.validatedPass = pass;
        BaseTransform srcTx = src.getTransform();
        samplevectors = new float[2];
        samplevectors[pass] = 1.0f;
        float iSize = (pass == 0) ? inputSizeH : inputSizeV;
        if (srcTx.isTranslateOrIdentity()) {
            this.swCompatible = true;
            this.passSize = iSize;
        } else {
            // The input produced a texture that requires transformation,
            // reevaluate our box sizes.
            // First (inverse) transform our sample vectors from the intended
            // srcTx space back into the actual pixel space of the src texture.
            // Then evaluate their length and attempt to absorb as much of any
            // implicit scaling that would happen into our final pixelSizes,
            // but if we overflow the maximum supportable pass size then we will
            // just have to sample sparsely with a longer than unit vector.
            // REMIND: we should also downsample the texture by powers of
            // 2 if our sampling will be more sparse than 1 sample per 2
            // pixels.
            try {
                srcTx.inverseDeltaTransform(samplevectors, 0, samplevectors, 0, 1);
            } catch (NoninvertibleTransformException ex) {
                this.passSize = 0.0f;
                samplevectors[0] = samplevectors[1] = 0.0f;
                this.swCompatible = true;
                return src;
            }
            double srcScale = Math.hypot(samplevectors[0], samplevectors[1]);
            float pSize = (float) (iSize * srcScale);
            pSize *= srcScale;
            int maxPassSize = MAX_BOX_SIZES[blurPasses];
            if (pSize &gt; maxPassSize) {
                pSize = maxPassSize;
                srcScale = maxPassSize / iSize;
            }
            this.passSize = pSize;
            // For a pixelSize that was less than maxPassSize, the following
            // lines renormalize the un-transformed vector back into a unit
            // vector in the proper direction and we absorbed its length
            // into the pixelSize that we will apply for the box filter weights.
            // If we clipped the pixelSize to maxPassSize, then it will not
            // actually end up as a unit vector, but it will represent the
            // proper sampling deltas for the indicated box size (which should
            // be maxPassSize in that case).
            samplevectors[0] /= srcScale;
            samplevectors[1] /= srcScale;
            // If we are still sampling by an axis aligned unit vector, then the
            // optimized software filters can still do their &quot;incremental sum&quot;
            // magic.
            // REMIND: software loops could actually do an infinitely sized
            // kernel with only memory requirements getting in the way, but
            // the values being tested here are constrained by the limits of
            // the hardware peers.  It is not clear how to fix this since we
            // have to choose how to proceed before we have enough information
            // to know if the inputs will be cooperative enough to assume
            // software limits, and then once we get here, we may have already
            // constrained ourselves into a situation where we must use the
<A NAME="31"></A>            // hardware peers.  Still, there may be more &quot;fighting&quot; we can do
            // to hold on to compatibility with the software loops perhaps?
            Rectangle srcSize = src.getUntransformedBounds();
            <FONT color="#3ea99f"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#31',2,'match49-top.html#31',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (pass == 0) {
                this.swCompatible = nearOne(samplevectors[0], srcSize.width)
                                &amp;&amp; nearZero(samplevectors[1], srcSize.width);
            } else {
                this.swCompatible = nearZero(samplevectors[0], srcSize.height)
                                  &amp;&amp; nearOne(samplevectors[1], srcSize.height);
            }
        }</B></FONT>
        Filterable f = src.getUntransformedImage();
        samplevectors[0] /= f.getPhysicalWidth();
        samplevectors[1] /= f.getPhysicalHeight();
        return src;
    }

    @Override
    public Rectangle getPassResultBounds(Rectangle srcdimension, Rectangle outputClip) {
        // Note that the pass vector and the pass radius may be adjusted for
        // a transformed input, but our output will be in the untransformed
        // &quot;filter&quot; coordinate space so we need to use the &quot;input&quot; values that
        // are in that same coordinate space.
        // The srcdimension is padded by the amount of extra data we produce
        // for this pass.
        // The outputClip is padded by the amount of extra input data we will
        // need for subsequent passes to do their work.
        Rectangle ret = new Rectangle(srcdimension);
        if (validatedPass == 0) {
            ret.grow(getInputKernelSize(0) / 2, 0);
        } else {
            ret.grow(0, getInputKernelSize(1) / 2);
        }
        if (outputClip != null) {
            if (validatedPass == 0) {
                outputClip = new Rectangle(outputClip);
                outputClip.grow(0, getInputKernelSize(1) / 2);
            }
            ret.intersectWith(outputClip);
        }
        return ret;
    }

    @Override
    public float[] getPassVector() {
        float xoff = samplevectors[0];
        float yoff = samplevectors[1];
        int ksize = getPassKernelSize();
        int center = ksize / 2;
        float ret[] = new float[4];
        ret[0] = xoff;
        ret[1] = yoff;
        ret[2] = -center * xoff;
        ret[3] = -center * yoff;
        return ret;
    }

    @Override
    public int getPassWeightsArrayLength() {
        validateWeights();
        return weights.limit() / 4;
    }

    @Override
    public FloatBuffer getPassWeights() {
        validateWeights();
        weights.rewind();
        return weights;
    }

    private void validateWeights() {
        float pSize;
        if (blurPasses == 0) {
            pSize = 1.0f;
        } else {
            pSize = passSize;
            // 1.0f is the minimum size and is a NOP (each pixel averaged
            // over itself)
            if (pSize &lt; 1.0f) pSize = 1.0f;
        }
        float passSpread = (validatedPass == spreadPass) ? spread : 0f;
        if (weights != null &amp;&amp;
            weightsValidSize == pSize &amp;&amp;
            weightsValidSpread == passSpread)
        {
            return;
        }

        // round klen up to a full pixel size and make sure it is odd so
        // that we center the kernel around each pixel center (1.0 of the
        // total size/weight is centered on the current pixel and then
        // the remainder is split (size-1.0)/2 on each side.
        // If the size is 2, then we don't want to average each pair of
        // pixels together (weights: 0.5, 0.5), instead we want to take each
        // pixel and average in half of each of its neighbors with it
        // (weights: 0.25, 0.5, 0.25).
        int klen = ((int) Math.ceil(pSize)) | 1;
        int totalklen = klen;
        for (int p = 1; p &lt; blurPasses; p++) {
            totalklen += klen - 1;
        }
        double ik[] = new double[totalklen];
        for (int i = 0; i &lt; klen; i++) {
            ik[i] = 1.0;
        }
        // The sum of the ik[] array is now klen, but we want the sum to
        // be size.  The worst case difference will be less than 2.0 since
        // the klen length is the ceil of the actual size possibly bumped up
        // to an odd number.  Thus it can have been bumped up by no more than
        // 2.0. If there is an excess, we need to take half of it out of each
        // of the two end weights (first and last).
        double excess = klen - pSize;
        if (excess &gt; 0.0) {
            // assert (excess * 0.5 &lt; 1.0)
            ik[0] = ik[klen-1] = 1.0 - excess * 0.5;
        }
        int filledklen = klen;
        for (int p = 1; p &lt; blurPasses; p++) {
            filledklen += klen - 1;
            int i = filledklen - 1;
            while (i &gt; klen) {
                double sum = ik[i];
                for (int k = 1; k &lt; klen; k++) {
                    sum += ik[i-k];
                }
                ik[i--] = sum;
            }
            while (i &gt; 0) {
                double sum = ik[i];
                for (int k = 0; k &lt; i; k++) {
                    sum += ik[k];
                }
                ik[i--] = sum;
            }
        }
        // assert (filledklen == totalklen == ik.length)
        double sum = 0.0;
        for (int i = 0; i &lt; ik.length; i++) {
            sum += ik[i];
        }
        // We need to apply the spread on only one pass
        // Prefer pass1 if r1 is not trivial
        // Otherwise use pass 0 so that it doesn't disappear
        sum += (1.0 - sum) * passSpread;

        if (weights == null) {
            // peersize(MAX_KERNEL_SIZE) rounded up to the next multiple of 4
            int maxbufsize = getPeerSize(MAX_KERNEL_SIZE);
            maxbufsize = (maxbufsize + 3) &amp; (~3);
            weights = BufferUtil.newFloatBuffer(maxbufsize);
        }
        weights.clear();
        for (int i = 0; i &lt; ik.length; i++) {
            weights.put((float) (ik[i] / sum));
        }
        int limit = getPeerSize(ik.length);
        while (weights.position() &lt; limit) {
            weights.put(0f);
        }
        weights.limit(limit);
        weights.rewind();
    }

    @Override
    public int getInputKernelSize(int pass) {
        float size = (pass == 0) ? inputSizeH : inputSizeV;
        if (size &lt; 1.0f) size = 1.0f;
        int klen = ((int) Math.ceil(size)) | 1;
        int totalklen = 1;
        for (int p = 0; p &lt; blurPasses; p++) {
            totalklen += klen - 1;
        }
        return totalklen;
    }

    @Override
    public int getPassKernelSize() {
        float size = passSize;
        if (size &lt; 1.0f) size = 1.0f;
        int klen = ((int) Math.ceil(size)) | 1;
        int totalklen = 1;
        for (int p = 0; p &lt; blurPasses; p++) {
            totalklen += klen - 1;
        }
        return totalklen;
    }

    @Override
    public boolean isNop() {
        if (isShadow) return false;
        return (blurPasses == 0
                || (inputSizeH &lt;= 1.0f &amp;&amp; inputSizeV &lt;= 1.0f));
    }

    @Override
    public boolean isPassNop() {
        if (isShadow &amp;&amp; validatedPass == 1) return false;
        return (blurPasses == 0 || (passSize) &lt;= 1.0f);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/concurrent/Service.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.concurrent;

import javafx.application.Platform;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyDoubleProperty;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.ReadOnlyStringProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.Event;
import javafx.event.EventDispatchChain;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.event.EventType;
import java.security.AccessController;
import java.security.AccessControlContext;
import java.security.PrivilegedAction;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import com.sun.javafx.logging.PlatformLogger;
import static javafx.concurrent.WorkerStateEvent.WORKER_STATE_CANCELLED;
import static javafx.concurrent.WorkerStateEvent.WORKER_STATE_FAILED;
import static javafx.concurrent.WorkerStateEvent.WORKER_STATE_READY;
import static javafx.concurrent.WorkerStateEvent.WORKER_STATE_RUNNING;
import static javafx.concurrent.WorkerStateEvent.WORKER_STATE_SCHEDULED;
import static javafx.concurrent.WorkerStateEvent.WORKER_STATE_SUCCEEDED;

/**
 * &lt;p&gt;
 *     A Service is a non-visual component encapsulating the information required
 *     to perform some work on one or more background threads. As part of the
 *     JavaFX UI library, the Service knows about the JavaFX Application thread
 *     and is designed to relieve the application developer from the burden
 *     of managing multithreaded code that interacts with the user interface. As
 *     such, all of the methods and state on the Service are intended to be
 *     invoked exclusively from the JavaFX Application thread. The only exception
 *     to this, is when initially configuring a Service, which may safely be done
 *     from any thread, and initially starting a Service, which may also safely
 *     be done from any thread. However, once the Service has been initialized and
 *     started, it may only thereafter be used from the FX thread.
 * &lt;/p&gt;
 * &lt;p&gt;
 *     A Service creates and manages a {@link Task} that performs the work
 *     on the background thread.
 *     Service implements {@link Worker}. As such, you can observe the state of
 *     the background task and optionally cancel it. Service is a reusable
 *     Worker, meaning that it can be reset and restarted. Due to this, a Service
 *     can be constructed declaratively and restarted on demand.
 *     Once a Service is started, it will schedule its Task and listen for
 *     changes to the state of the Task. A Task does not hold a reference to the
 *     Service that started it, meaning that a running Task will not prevent
 *     the Service from being garbage collected.
 * &lt;/p&gt;
 * &lt;p&gt;
 *     If an {@link java.util.concurrent.Executor} is specified on the Service,
 *     then it will be used to actually execute the service. Otherwise,
 *     a daemon thread will be created and executed. If you wish to create
 *     non-daemon threads, then specify a custom Executor (for example,
 *     you could use a {@link ThreadPoolExecutor} with a custom
 *     {@link java.util.concurrent.ThreadFactory}).
 * &lt;/p&gt;
 * &lt;p&gt;
 *     Because a Service is intended to simplify declarative use cases, subclasses
 *     should expose as properties the input parameters to the work to be done.
 *     For example, suppose I wanted to write a Service which read the first line
 *     from any URL and returned it as a String. Such a Service might be defined,
 *     such that it had a single property, {@code url}. It might be implemented
 *     as:
 * &lt;/p&gt;
 *     &lt;pre&gt;&lt;code&gt;
 *     {@literal public static class FirstLineService extends Service&lt;String&gt;} {
 *         private StringProperty url = new SimpleStringProperty(this, &quot;url&quot;);
 *         public final void setUrl(String value) { url.set(value); }
 *         public final String getUrl() { return url.get(); }
 *         public final StringProperty urlProperty() { return url; }
 *
 *         protected Task createTask() {
 *             final String _url = getUrl();
 *             {@literal return new Task&lt;String&gt;()} {
 *                 protected String call() throws Exception {
 *                     URL u = new URL(_url);
 *                     BufferedReader in = new BufferedReader(
 *                             new InputStreamReader(u.openStream()));
 *                     String result = in.readLine();
 *                     in.close();
 *                     return result;
 *                 }
 *             };
 *         }
 *     }
 *     &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 *     The Service by default uses a thread pool Executor with some unspecified
 *     default or maximum thread pool size. This is done so that naive code
 *     will not completely swamp the system by creating thousands of Threads.
 * &lt;/p&gt;
 * @param &lt;V&gt; the type of object returned by the Service
 * @since JavaFX 2.0
 */
public abstract class Service&lt;V&gt; implements Worker&lt;V&gt;, EventTarget {
    /**
     * Logger used in the case of some uncaught exceptions
     */
    private static final PlatformLogger LOG = PlatformLogger.getLogger(Service.class.getName());

    /*
        The follow chunk of static state is for defining the default Executor used
        with the Service. This is based on pre-existing JavaFX Script code and
        experience with JavaFX Script. It was necessary to have a thread pool by default
        because we found naive code could totally overwhelm the system otherwise
        by spawning thousands of threads for fetching resources, for example.
        We also set the priority and daemon status of the thread in its thread
        factory.
     */
    private static final int THREAD_POOL_SIZE = 32;
    private static final long THREAD_TIME_OUT = 1000;

    /**
     * Because the ThreadPoolExecutor works completely backwards from what we want (ie:
     * it doesn't increase thread count beyond the core pool size unless the queue is full),
     * our queue has to be smart in that it will REJECT an item in the queue unless the
     * thread size in the EXECUTOR is &gt; 32, in which case we will queue up.
     */
    private static final BlockingQueue&lt;Runnable&gt; IO_QUEUE = new LinkedBlockingQueue&lt;Runnable&gt;() {
        @Override public boolean offer(Runnable runnable) {
            if (EXECUTOR.getPoolSize() &lt; THREAD_POOL_SIZE) {
                return false;
            }
            return super.offer(runnable);
        }
    };

    // Addition of doPrivileged added due to RT-19580
    private static final ThreadGroup THREAD_GROUP = AccessController.doPrivileged((PrivilegedAction&lt;ThreadGroup&gt;) () -&gt; new ThreadGroup(&quot;javafx concurrent thread pool&quot;));
    private static final Thread.UncaughtExceptionHandler UNCAUGHT_HANDLER = (thread, throwable) -&gt; {
        // Ignore IllegalMonitorStateException, these are thrown from the ThreadPoolExecutor
        // when a browser navigates away from a page hosting an applet that uses
        // asynchronous tasks. These exceptions generally do not cause loss of functionality.
        if (!(throwable instanceof IllegalMonitorStateException)) {
            LOG.warning(&quot;Uncaught throwable in &quot; + THREAD_GROUP.getName(), throwable);
        }
    };

    // Addition of doPrivileged added due to RT-19580
    private static final ThreadFactory THREAD_FACTORY = run -&gt; AccessController.doPrivileged((PrivilegedAction&lt;Thread&gt;) () -&gt; {
        final Thread th = new Thread(THREAD_GROUP, run);
        th.setUncaughtExceptionHandler(UNCAUGHT_HANDLER);
        th.setPriority(Thread.MIN_PRIORITY);
        th.setDaemon(true);
        return th;
    });

    private static final ThreadPoolExecutor EXECUTOR = new ThreadPoolExecutor(
            2, THREAD_POOL_SIZE,
            THREAD_TIME_OUT, TimeUnit.MILLISECONDS,
            IO_QUEUE, THREAD_FACTORY, new ThreadPoolExecutor.AbortPolicy());

    static {
        EXECUTOR.allowCoreThreadTimeOut(true);
    }

    private final ObjectProperty&lt;State&gt; state = new SimpleObjectProperty&lt;&gt;(this, &quot;state&quot;, State.READY);
    @Override public final State getState() { checkThread(); return state.get(); }
    @Override public final ReadOnlyObjectProperty&lt;State&gt; stateProperty() { checkThread(); return state; }

    private final ObjectProperty&lt;V&gt; value = new SimpleObjectProperty&lt;&gt;(this, &quot;value&quot;);
    @Override public final V getValue() { checkThread(); return value.get(); }
    @Override public final ReadOnlyObjectProperty&lt;V&gt; valueProperty() { checkThread(); return value; }

    private final ObjectProperty&lt;Throwable&gt; exception = new SimpleObjectProperty&lt;&gt;(this, &quot;exception&quot;);
    @Override public final Throwable getException() { checkThread(); return exception.get(); }
    @Override public final ReadOnlyObjectProperty&lt;Throwable&gt; exceptionProperty() { checkThread(); return exception; }

    private final DoubleProperty workDone = new SimpleDoubleProperty(this, &quot;workDone&quot;, -1);
    @Override public final double getWorkDone() { checkThread(); return workDone.get(); }
    @Override public final ReadOnlyDoubleProperty workDoneProperty() { checkThread(); return workDone; }

    private final DoubleProperty totalWorkToBeDone = new SimpleDoubleProperty(this, &quot;totalWork&quot;, -1);
    @Override public final double getTotalWork() { checkThread(); return totalWorkToBeDone.get(); }
    @Override public final ReadOnlyDoubleProperty totalWorkProperty() { checkThread(); return totalWorkToBeDone; }

    private final DoubleProperty progress = new SimpleDoubleProperty(this, &quot;progress&quot;, -1);
    @Override public final double getProgress() { checkThread(); return progress.get(); }
    @Override public final ReadOnlyDoubleProperty progressProperty() { checkThread(); return progress; }

    private final BooleanProperty running = new SimpleBooleanProperty(this, &quot;running&quot;, false);
    @Override public final boolean isRunning() { checkThread(); return running.get(); }
    @Override public final ReadOnlyBooleanProperty runningProperty() { checkThread(); return running; }

    private final StringProperty message = new SimpleStringProperty(this, &quot;message&quot;, &quot;&quot;);
    @Override public final String getMessage() { checkThread(); return message.get(); }
    @Override public final ReadOnlyStringProperty messageProperty() { checkThread(); return message; }

    private final StringProperty title = new SimpleStringProperty(this, &quot;title&quot;, &quot;&quot;);
    @Override public final String getTitle() { checkThread(); return title.get(); }
    @Override public final ReadOnlyStringProperty titleProperty() { checkThread(); return title; }

    /**
     * The executor to use for running this Service. If no executor is specified, then
     * a new daemon thread will be created and used for running the Service using some
     * default executor.
     */
    private final ObjectProperty&lt;Executor&gt; executor = new SimpleObjectProperty&lt;&gt;(this, &quot;executor&quot;);
    public final void setExecutor(Executor value) { checkThread(); executor.set(value); }
    public final Executor getExecutor() { checkThread(); return executor.get(); }
    public final ObjectProperty&lt;Executor&gt; executorProperty() { checkThread(); return executor; }

    /**
     * The onReady event handler is called whenever the Task state transitions
     * to the READY state.
     *
     * @return the onReady event handler property
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;WorkerStateEvent&gt;&gt; onReadyProperty() {
        checkThread();
        return getEventHelper().onReadyProperty();
    }

    /**
     * The onReady event handler is called whenever the Task state transitions
     * to the READY state.
     *
     * @return the onReady event handler, if any
     * @since JavaFX 2.1
     */
    public final EventHandler&lt;WorkerStateEvent&gt; getOnReady() {
        checkThread();
        return eventHelper == null ? null : eventHelper.getOnReady();
    }

    /**
     * The onReady event handler is called whenever the Task state transitions
     * to the READY state.
     *
     * @param value the event handler, can be null to clear it
     * @since JavaFX 2.1
     */
    public final void setOnReady(EventHandler&lt;WorkerStateEvent&gt; value) {
        checkThread();
        getEventHelper().setOnReady(value);
    }

    /**
     * A protected convenience method for subclasses, called whenever the
     * state of the Service has transitioned to the READY state.
     * This method is invoked after the Service has been fully transitioned to the new state.
     * @since JavaFX 2.1
     */
    protected void ready() { }

    /**
     * The onSchedule event handler is called whenever the Task state
     * transitions to the SCHEDULED state.
     *
     * @return the onScheduled event handler property
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;WorkerStateEvent&gt;&gt; onScheduledProperty() {
        checkThread();
        return getEventHelper().onScheduledProperty();
    }

    /**
     * The onSchedule event handler is called whenever the Task state
     * transitions to the SCHEDULED state.
     *
     * @return the onScheduled event handler, if any
     * @since JavaFX 2.1
     */
    public final EventHandler&lt;WorkerStateEvent&gt; getOnScheduled() {
        checkThread();
        return eventHelper == null ? null : eventHelper.getOnScheduled();
    }

    /**
     * The onSchedule event handler is called whenever the Task state
     * transitions to the SCHEDULED state.
     *
     * @param value the event handler, can be null to clear it
     * @since JavaFX 2.1
     */
    public final void setOnScheduled(EventHandler&lt;WorkerStateEvent&gt; value) {
        checkThread();
        getEventHelper().setOnScheduled(value);
    }

    /**
     * A protected convenience method for subclasses, called whenever the
     * state of the Service has transitioned to the SCHEDULED state.
     * This method is invoked after the Service has been fully transitioned to the new state.
     * @since JavaFX 2.1
     */
    protected void scheduled() { }

    /**
     * The onRunning event handler is called whenever the Task state
     * transitions to the RUNNING state.
     *
     * @return the onRunning event handler property
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;WorkerStateEvent&gt;&gt; onRunningProperty() {
        checkThread();
        return getEventHelper().onRunningProperty();
    }

    /**
     * The onRunning event handler is called whenever the Task state
     * transitions to the RUNNING state.
     *
     * @return the onRunning event handler, if any
     * @since JavaFX 2.1
     */
    public final EventHandler&lt;WorkerStateEvent&gt; getOnRunning() {
        checkThread();
        return eventHelper == null ? null : eventHelper.getOnRunning();
    }

    /**
     * The onRunning event handler is called whenever the Task state
     * transitions to the RUNNING state.
     *
     * @param value the event handler, can be null to clear it
     * @since JavaFX 2.1
     */
    public final void setOnRunning(EventHandler&lt;WorkerStateEvent&gt; value) {
        checkThread();
        getEventHelper().setOnRunning(value);
    }

    /**
     * A protected convenience method for subclasses, called whenever the
     * state of the Service has transitioned to the RUNNING state.
     * This method is invoked after the Service has been fully transitioned to the new state.
     * @since JavaFX 2.1
     */
    protected void running() { }

    /**
     * The onSucceeded event handler is called whenever the Task state
     * transitions to the SUCCEEDED state.
     *
     * @return the onSucceeded event handler property
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;WorkerStateEvent&gt;&gt; onSucceededProperty() {
        checkThread();
        return getEventHelper().onSucceededProperty();
    }

    /**
     * The onSucceeded event handler is called whenever the Task state
     * transitions to the SUCCEEDED state.
     *
     * @return the onSucceeded event handler, if any
     * @since JavaFX 2.1
     */
    public final EventHandler&lt;WorkerStateEvent&gt; getOnSucceeded() {
        checkThread();
        return eventHelper == null ? null : eventHelper.getOnSucceeded();
    }

    /**
     * The onSucceeded event handler is called whenever the Task state
     * transitions to the SUCCEEDED state.
     *
     * @param value the event handler, can be null to clear it
     * @since JavaFX 2.1
     */
    public final void setOnSucceeded(EventHandler&lt;WorkerStateEvent&gt; value) {
        checkThread();
        getEventHelper().setOnSucceeded(value);
    }

    /**
     * A protected convenience method for subclasses, called whenever the
     * state of the Service has transitioned to the SUCCEEDED state.
     * This method is invoked after the Service has been fully transitioned to the new state.
     * @since JavaFX 2.1
     */
    protected void succeeded() { }

    /**
     * The onCancelled event handler is called whenever the Task state
     * transitions to the CANCELLED state.
     *
     * @return the onCancelled event handler property
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;WorkerStateEvent&gt;&gt; onCancelledProperty() {
        checkThread();
        return getEventHelper().onCancelledProperty();
    }

    /**
     * The onCancelled event handler is called whenever the Task state
     * transitions to the CANCELLED state.
     *
     * @return the onCancelled event handler, if any
     * @since JavaFX 2.1
     */
    public final EventHandler&lt;WorkerStateEvent&gt; getOnCancelled() {
        checkThread();
        return eventHelper == null ? null : eventHelper.getOnCancelled();
    }

    /**
     * The onCancelled event handler is called whenever the Task state
     * transitions to the CANCELLED state.
     *
     * @param value the event handler, can be null to clear it
     * @since JavaFX 2.1
     */
    public final void setOnCancelled(EventHandler&lt;WorkerStateEvent&gt; value) {
        checkThread();
        getEventHelper().setOnCancelled(value);
    }

    /**
     * A protected convenience method for subclasses, called whenever the
     * state of the Service has transitioned to the CANCELLED state.
     * This method is invoked after the Service has been fully transitioned to the new state.
     * @since JavaFX 2.1
     */
    protected void cancelled() { }

    /**
     * The onFailed event handler is called whenever the Task state
     * transitions to the FAILED state.
     *
     * @return the onFailed event handler property
     * @since JavaFX 2.1
     */
    public final ObjectProperty&lt;EventHandler&lt;WorkerStateEvent&gt;&gt; onFailedProperty() {
        checkThread();
        return getEventHelper().onFailedProperty();
    }

    /**
     * The onFailed event handler is called whenever the Task state
     * transitions to the FAILED state.
     *
     * @return the onFailed event handler, if any
     * @since JavaFX 2.1
     */
    public final EventHandler&lt;WorkerStateEvent&gt; getOnFailed() {
        checkThread();
        return eventHelper == null ? null : eventHelper.getOnFailed();
    }

    /**
     * The onFailed event handler is called whenever the Task state
     * transitions to the FAILED state.
     *
     * @param value the event handler, can be null to clear it
     * @since JavaFX 2.1
     */
    public final void setOnFailed(EventHandler&lt;WorkerStateEvent&gt; value) {
        checkThread();
        getEventHelper().setOnFailed(value);
    }

    /**
     * A protected convenience method for subclasses, called whenever the
     * state of the Service has transitioned to the FAILED state.
     * This method is invoked after the Service has been fully transitioned to the new state.
     * @since JavaFX 2.1
     */
    protected void failed() { }

    /**
     * A reference to the last task that was executed. I need this reference so that in the
     * restart method I can cancel the currently running task, and so the cancel method
     * can cancel the currently running task.
     */
    private Task&lt;V&gt; task;

    /**
     * This boolean is set to true once the Service has been initially started. You can initialize
     * the Service from any thread, and you can initially start it from any thread. But any
     * subsequent usage of the service's methods must occur on the FX application thread.
     */
    private volatile boolean startedOnce = false;

    /**
     * Create a new Service.
     */
    protected Service() {
        // Add a listener to the state, such that we can fire the correct event
        // notifications whenever the state of the Service has changed.
        state.addListener((observableValue, old, value1) -&gt; {

            // Invoke the appropriate event handler
            switch (value1) {
                case CANCELLED:
                    fireEvent(new WorkerStateEvent(Service.this, WORKER_STATE_CANCELLED));
                    cancelled();
                    break;
                case FAILED:
                    fireEvent(new WorkerStateEvent(Service.this, WORKER_STATE_FAILED));
                    failed();
                    break;
                case READY:
                    fireEvent(new WorkerStateEvent(Service.this, WORKER_STATE_READY));
                    ready();
                    break;
                case RUNNING:
                    fireEvent(new WorkerStateEvent(Service.this, WORKER_STATE_RUNNING));
                    running();
                    break;
                case SCHEDULED:
                    fireEvent(new WorkerStateEvent(Service.this, WORKER_STATE_SCHEDULED));
                    scheduled();
                    break;
                case SUCCEEDED:
                    fireEvent(new WorkerStateEvent(Service.this, WORKER_STATE_SUCCEEDED));
                    succeeded();
                    break;
                default: throw new AssertionError(&quot;Should be unreachable&quot;);
            }
        });
    }

    /**
     * Cancels any currently running Task, if any. The state will be set to CANCELLED.
     * @return returns true if the cancel was successful
     */
    @Override public boolean cancel() {
        checkThread();
        if (task == null) {
            if (state.get() == State.CANCELLED || state.get() == State.SUCCEEDED) {
                return false;
            }
            state.set(State.CANCELLED);
            return true;
        } else {
            return task.cancel(true);
        }
    }

    /**
     * Cancels any currently running Task, if any, and restarts this Service. The state
     * will be reset to READY prior to execution. This method should only be called on
     * the FX application thread.
     */
    public void restart() {
        checkThread();

        // Cancel the current task, if there is one
        if (task != null) {
            task.cancel();
            task = null;

            // RT-20880: IllegalStateException thrown from Service#restart()
            // The problem is that the reset method explodes if the state
            // is SCHEDULED or RUNNING. Although we have cancelled the
            // task above, it is possible that cancelling does not change
            // state to the CANCELLED state. However we still need to
            // succeed in resetting. I believe that although the old task is
            // still running away, everything is about to be unbound so
            // we really can just let the old task run and create a new
            // task and the Service will be none the wiser.
            state.unbind();
            state.set(State.CANCELLED);
        }

        // Reset
        reset();

        // Start the thing up again.
        start();
    }

    /**
     * Resets the Service. May only be called while in one of the finish states,
     * that is, SUCCEEDED, FAILED, or CANCELLED, or when READY. This method should
     * only be called on the FX application thread.
     */
    public void reset() {
        checkThread();
        final State s = getState();
        if (s == State.SCHEDULED || s == State.RUNNING) {
            throw new IllegalStateException();
        }

        task = null;
        state.unbind();
        state.set(State.READY);
        value.unbind();
<A NAME="17"></A>        value.set(null);
        exception.unbind();
        exception.set(null);
        <FONT color="#800517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#17',2,'match49-top.html#17',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>workDone.unbind();
        workDone.set(-1);
        totalWorkToBeDone.unbind();
        totalWorkToBeDone.set(-1);
        progress.unbind();
        progress.set(-1);
        running.unbind();
        running.set(false);
        message.unbind();
        message.set(&quot;&quot;);
        title.unbind();
        title.set(&quot;&quot;);
    }

    /**
     * Starts this Service. The Service must be in the READY state to succeed in this call.
     * This method should only be called on the FX application thread.
     */
    public void start() {
        checkThread</B></FONT>();

        if (getState() != State.READY) {
            throw new IllegalStateException(
                    &quot;Can only start a Service in the READY state. Was in state &quot; + getState());
        }

        // Create the task
        task = createTask();

        // Wire up all the properties so they use this task
        state.bind(task.stateProperty());
        value.bind(task.valueProperty());
        exception.bind(task.exceptionProperty());
        workDone.bind(task.workDoneProperty());
        totalWorkToBeDone.bind(task.totalWorkProperty());
        progress.bind(task.progressProperty());
        running.bind(task.runningProperty());
        message.bind(task.messageProperty());
        title.bind(task.titleProperty());

        // Record that start has been called once, so we don't allow it to be called again from
        // any thread other than the fx thread
        startedOnce = true;

        if (!isFxApplicationThread()) {
            runLater(() -&gt; {
                // Advance the task to the &quot;SCHEDULED&quot; state
                task.setState(State.SCHEDULED);

                // Start the task
                executeTask(task);
            });
        } else {
            // Advance the task to the &quot;SCHEDULED&quot; state
            task.setState(State.SCHEDULED);

            // Start the task
            executeTask(task);
        }
    }

    /**
     * This is used by ScheduledService to cancel a Service that is in the READY state. The problem is
     * that a ScheduledService will iterate from SUCCEEDED to READY, and then call start() to transition
     * from READY to SCHEDULED and kick off a new iteration. However, if from the SUCCEEDED event handler
     * a developer calls &quot;cancel&quot; to stop a ScheduledService, we have a problem, since the Service
     * specification does not allow to transition from a terminal state (SUCCEEDED) to another terminal
     * state (CANCELLED), but this is clearly what we need to do. So what this method will do is allow
     * us to transition from the READY state to the CANCELLED state, by transitioning through SCHEDULED
     */
    void cancelFromReadyState() {
        state.set(State.SCHEDULED);
        state.set(State.CANCELLED);
    }

    /**
     * &lt;p&gt;
     *     Uses the &lt;code&gt;executor&lt;/code&gt; defined on this Service to execute the
     *     given task. If the &lt;code&gt;executor&lt;/code&gt; is null, then a default
     *     executor is used which will create a new daemon thread on which to
     *     execute this task.
     * &lt;/p&gt;
     * &lt;p&gt;
     *     This method is intended only to be called by the Service
     *     implementation.
     * &lt;/p&gt;
     * @param task a non-null task to execute
     * @since JavaFX 2.1
     */
    protected void executeTask(final Task&lt;V&gt; task) {
        final AccessControlContext acc = AccessController.getContext();
        final Executor e = getExecutor() != null ? getExecutor() : EXECUTOR;
        e.execute(() -&gt; {
            AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
                task.run();
                return null;
            }, acc);
        });
    }

    /***************************************************************************
     *                                                                         *
     *                         Event Dispatch                                  *
     *                                                                         *
     **************************************************************************/

    private EventHelper eventHelper = null;
    private EventHelper getEventHelper() {
        if (eventHelper == null) {
            eventHelper = new EventHelper(this);
        }
        return eventHelper;
    }

    /**
     * Registers an event handler to this task. Any event filters are first
     * processed, then the specified onFoo event handlers, and finally any
     * event handlers registered by this method. As with other events
     * in the scene graph, if an event is consumed, it will not continue
     * dispatching.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the type of the events to receive by the handler
     * @param eventHandler the handler to register
     * @throws NullPointerException if the event type or handler is null
     * @since JavaFX 2.1
     */
    public final &lt;T extends Event&gt; void addEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        checkThread();
        getEventHelper().addEventHandler(eventType, eventHandler);
    }

    /**
     * Unregisters a previously registered event handler from this task. One
     * handler might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the handler.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type from which to unregister
     * @param eventHandler the handler to unregister
     * @throws NullPointerException if the event type or handler is null
     * @since JavaFX 2.1
     */
    public final &lt;T extends Event&gt; void removeEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        checkThread();
        getEventHelper().removeEventHandler(eventType, eventHandler);
    }

    /**
     * Registers an event filter to this task. Registered event filters get
     * an event before any associated event handlers.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the type of the events to receive by the filter
     * @param eventFilter the filter to register
     * @throws NullPointerException if the event type or filter is null
     * @since JavaFX 2.1
     */
    public final &lt;T extends Event&gt; void addEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        checkThread();
        getEventHelper().addEventFilter(eventType, eventFilter);
    }

    /**
     * Unregisters a previously registered event filter from this task. One
     * filter might have been registered for different event types, so the
     * caller needs to specify the particular event type from which to
     * unregister the filter.
     *
     * @param &lt;T&gt; the specific event class of the filter
     * @param eventType the event type from which to unregister
     * @param eventFilter the filter to unregister
     * @throws NullPointerException if the event type or filter is null
     * @since JavaFX 2.1
     */
    public final &lt;T extends Event&gt; void removeEventFilter(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventFilter) {
        checkThread();
        getEventHelper().removeEventFilter(eventType, eventFilter);
    }

    /**
     * Sets the handler to use for this event type. There can only be one such
     * handler specified at a time. This handler is guaranteed to be called
     * first. This is used for registering the user-defined onFoo event
     * handlers.
     *
     * @param &lt;T&gt; the specific event class of the handler
     * @param eventType the event type to associate with the given eventHandler
     * @param eventHandler the handler to register, or null to unregister
     * @throws NullPointerException if the event type is null
     * @since JavaFX 2.1
     */
    protected final &lt;T extends Event&gt; void setEventHandler(
            final EventType&lt;T&gt; eventType,
            final EventHandler&lt;? super T&gt; eventHandler) {
        checkThread();
        getEventHelper().setEventHandler(eventType, eventHandler);
    }

    /**
     * Fires the specified event. Any event filter encountered will
     * be notified and can consume the event. If not consumed by the filters,
     * the event handlers on this task are notified. If these don't consume the
     * event either, then all event handlers are called and can consume the
     * event.
     * &lt;p&gt;
     * This method must be called on the FX user thread.
     *
     * @param event the event to fire
     * @since JavaFX 2.1
     */
    protected final void fireEvent(Event event) {
        checkThread();
        getEventHelper().fireEvent(event);
    }

    @Override
    public EventDispatchChain buildEventDispatchChain(EventDispatchChain tail) {
        checkThread();
        return getEventHelper().buildEventDispatchChain(tail);
    }

    /**
     * Invoked after the Service is started on the JavaFX Application Thread.
     * Implementations should save off any state into final variables prior to
     * creating the Task, since accessing properties defined on the Service
     * within the background thread code of the Task will result in exceptions.
     *
     * For example:
     * &lt;pre&gt;&lt;code&gt;
     *     protected Task createTask() {
     *         final String url = myService.getUrl();
     *         {@literal return new Task&lt;String&gt;()} {
     *             protected String call() {
     *                 URL u = new URL(&quot;http://www.oracle.com&quot;);
     *                 BufferedReader in = new BufferedReader(
     *                         new InputStreamReader(u.openStream()));
     *                 String result = in.readLine();
     *                 in.close();
     *                 return result;
     *             }
     *         }
     *     }
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;p&gt;
     *     If the Task is a pre-defined class (as opposed to being an
     *     anonymous class), and if it followed the recommended best-practice,
     *     then there is no need to save off state prior to constructing
     *     the Task since its state is completely provided in its constructor.
     * &lt;/p&gt;
     *
     * &lt;pre&gt;{@code
     *     protected Task createTask() {
     *         // This is safe because getUrl is called on the FX Application
     *         // Thread and the FirstLineReaderTasks stores it as an
     *         // immutable property
     *         return new FirstLineReaderTask(myService.getUrl());
     *     }
     * }&lt;/pre&gt;
     * @return the Task to execute
     */
    protected abstract Task&lt;V&gt; createTask();

    void checkThread() {
        if (startedOnce &amp;&amp; !isFxApplicationThread()) {
            throw new IllegalStateException(&quot;Service must only be used from the FX Application Thread&quot;);
        }
    }

    // This method exists for the sake of testing, so I can subclass and override
    // this method in the test and not actually use Platform.runLater.
    void runLater(Runnable r) {
        Platform.runLater(r);
    }

    // This method exists for the sake of testing, so I can subclass and override
    // this method in the test and not actually use Platform.isFxApplicationThread.
    boolean isFxApplicationThread() {
        return Platform.isFxApplicationThread();
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/Cursor.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
<A NAME="0"></A>
package javafx.scene;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#0',2,'match49-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import java.net.MalformedURLException;
import java.net.URL;
import java.util.Locale;
import javafx.scene.image.Image;
import com.sun.javafx.cursor.CursorFrame;
import com.sun.javafx.cursor.CursorType;
import com.sun.javafx.cursor.StandardCursorFrame;

/**
 * A class to encapsulate the bitmap representation of the mouse cursor.
 * @since JavaFX 2.0
 */
public abstract class Cursor {
    /**
     * The default cursor type (gets set if no cursor is defined).
     */
    public static final Cursor DEFAULT =
            new StandardCursor(&quot;DEFAULT&quot;, CursorType.DEFAULT);

    /**
     * The crosshair cursor type.
     */
    public static final Cursor CROSSHAIR =
            new StandardCursor(&quot;CROSSHAIR&quot;, CursorType.CROSSHAIR);

    /**
     * The text cursor type.
     */
    public static final Cursor TEXT =
            new StandardCursor(&quot;TEXT&quot;, CursorType.TEXT);

    /**
     * The wait cursor type.
     */
    public static final Cursor WAIT =
            new StandardCursor(&quot;WAIT&quot;, CursorType.WAIT);

    /**
     * The south-west-resize cursor type.
     */
    public static final Cursor SW_RESIZE =
            new StandardCursor(&quot;SW_RESIZE&quot;, CursorType.SW_RESIZE);

    /**
     * The south-east-resize cursor type.
     */
    public static final Cursor SE_RESIZE =
            new StandardCursor(&quot;SE_RESIZE&quot;, CursorType.SE_RESIZE);

    /**
     * The north-west-resize cursor type.
     */
    public static final Cursor NW_RESIZE =
            new StandardCursor(&quot;NW_RESIZE&quot;, CursorType.NW_RESIZE);

    /**
     * The north-east-resize cursor type.
     */
    public static final Cursor NE_RESIZE =
            new StandardCursor(&quot;NE_RESIZE&quot;, CursorType.NE_RESIZE);

    /**
     * The north-resize cursor type.
     */
    public static final Cursor N_RESIZE =
            new StandardCursor(&quot;N_RESIZE&quot;, CursorType.N_RESIZE);

    /**
     * The south-resize cursor type.
     */
    public static final Cursor S_RESIZE =
            new StandardCursor(&quot;S_RESIZE&quot;, CursorType.S_RESIZE);

    /**
     * The west-resize cursor type.
     */
    public static final Cursor W_RESIZE =
            new StandardCursor(&quot;W_RESIZE&quot;, CursorType.W_RESIZE);

    /**
     * The east-resize cursor type.
     */
    public static final Cursor E_RESIZE =
            new StandardCursor(&quot;E_RESIZE&quot;, CursorType.E_RESIZE);

    /**
     * A cursor with a hand which is open
     */
    public static final Cursor OPEN_HAND =
            new StandardCursor(&quot;OPEN_HAND&quot;, CursorType.OPEN_HAND);

    /**
     * A cursor with a hand that is closed, often used when
     * &quot;grabbing&quot;, for example, when panning.
     */
    public static final Cursor CLOSED_HAND =
            new StandardCursor(&quot;CLOSED_HAND&quot;, CursorType.CLOSED_HAND);

    /**
     * The hand cursor type, resembling a pointing hand, often
     * used to indicate that something can be clicked, such as
     * a hyperlink.
     */
    public static final Cursor HAND =
            new StandardCursor(&quot;HAND&quot;, CursorType.HAND);

    /**
     * The move cursor type.
     */
    public static final Cursor MOVE =
            new StandardCursor(&quot;MOVE&quot;, CursorType.MOVE);

    /**
     * The disappear cursor type. This is often used when dragging
     * something, such that when the user releases the mouse, the
     * item will disappear. On Mac, this is used when dragging items
     * off a toolbar or in other such situations.
     */
    public static final Cursor DISAPPEAR =
            new StandardCursor(&quot;DISAPPEAR&quot;, CursorType.DISAPPEAR);

    /**
     * The horizontal cursor type.
     */
    public static final Cursor H_RESIZE =
            new StandardCursor(&quot;H_RESIZE&quot;, CursorType.H_RESIZE);

    /**
     * The vertical cursor type.
     */
    public static final Cursor V_RESIZE =
            new</B></FONT> StandardCursor(&quot;V_RESIZE&quot;, CursorType.V_RESIZE);

    /**
     * The none cursor type. On platforms that don't support
     * custom cursors, this will be the same as {@code DEFAULT}.
     */
    public static final Cursor NONE =
            new StandardCursor(&quot;NONE&quot;, CursorType.NONE);

    private String name = &quot;CUSTOM&quot;;

    Cursor() { }
    Cursor(String name) {
        this.name = name;
    }

    abstract CursorFrame getCurrentFrame();

    /**
     * Activates the cursor. Cursor should be activated to make sure
     * that the {@code getCurrentFrame} returns up-to date values.
     */
    void activate() {
        // no activation necessary for standard cursors
    }

    /**
     * Deactivates the cursor. Cursor should be deactivated, when no longer in
     * use to make it collectible by GC.
     */
    void deactivate() {
    }

    /**
     * Returns a string representation for the cursor.
     * @return a string representation for the cursor.
     */
    @Override public String toString() {
        return name;
    }

    // PENDING_DOC_REVIEW
    /**
     * Returns a cursor for the specified identifier. The identifier can be
     * either a name of some standard cursor or a valid URL string. If the
     * identifier names a standard cursor the corresponding cursor is returned.
     * In the case of a URL string, the method returns a new {@code ImageCursor}
     * created for that URL.
     *
     * @param identifier the cursor identifier
     * @return the cursor for the identifier
     * @throws IllegalArgumentException if the cursor identifier is not a
     *      valid URL string nor any standard cursor name
     */
    public static Cursor cursor(final String identifier) {
        if (identifier == null) {
            throw new NullPointerException(
                    &quot;The cursor identifier must not be null&quot;);
        }

        if (isUrl(identifier)) {
            return new ImageCursor(new Image(identifier));
        }

        String uName = identifier.toUpperCase(Locale.ROOT);
        if (uName.equals(DEFAULT.name)) {
            return DEFAULT;
        } else if(uName.equals(CROSSHAIR.name)) {
            return CROSSHAIR;
        } else if (uName.equals(TEXT.name)) {
            return TEXT;
        } else if (uName.equals(WAIT.name)) {
            return WAIT;
        } else if (uName.equals(MOVE.name)) {
            return MOVE;
        } else if (uName.equals(SW_RESIZE.name)) {
            return SW_RESIZE;
        } else if (uName.equals(SE_RESIZE.name)) {
            return SE_RESIZE;
        } else if (uName.equals(NW_RESIZE.name)) {
            return NW_RESIZE;
        } else if (uName.equals(NE_RESIZE.name)) {
            return NE_RESIZE;
        } else if (uName.equals(N_RESIZE.name)) {
            return N_RESIZE;
        } else if (uName.equals(S_RESIZE.name)) {
            return S_RESIZE;
        } else if (uName.equals(W_RESIZE.name)) {
            return W_RESIZE;
        } else if (uName.equals(E_RESIZE.name)) {
            return E_RESIZE;
        } else if (uName.equals(OPEN_HAND.name)) {
            return OPEN_HAND;
        } else if (uName.equals(CLOSED_HAND.name)) {
            return CLOSED_HAND;
        } else if (uName.equals(HAND.name)) {
            return HAND;
        } else if (uName.equals(H_RESIZE.name)) {
            return H_RESIZE;
        } else if (uName.equals(V_RESIZE.name)) {
            return V_RESIZE;
        } else if (uName.equals(DISAPPEAR.name)) {
            return DISAPPEAR;
        } else if (uName.equals(NONE.name)) {
            return NONE;
        }

        throw new IllegalArgumentException(&quot;Invalid cursor specification&quot;);
    }

    private static boolean isUrl(final String identifier) {
        try {
            new URL(identifier);
        } catch (final MalformedURLException e) {
            return false;
        }

        return true;
    }

    private static final class StandardCursor extends Cursor {
        private final CursorFrame singleFrame;

        public StandardCursor(final String name, final CursorType type) {
            super(name);
            singleFrame = new StandardCursorFrame(type);
        }

        @Override
        CursorFrame getCurrentFrame() {
            return singleFrame;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.graphics/javafx/scene/layout/TilePane.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.layout;

import com.sun.javafx.binding.ExpressionHelper;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyDoubleProperty;
import javafx.css.CssMetaData;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableIntegerProperty;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.geometry.Orientation;
import javafx.geometry.Pos;
import javafx.geometry.VPos;
import javafx.scene.Node;
import javafx.css.converter.EnumConverter;
import javafx.css.converter.SizeConverter;
import javafx.beans.InvalidationListener;
import javafx.beans.value.ChangeListener;
import javafx.css.Styleable;

import static javafx.geometry.Orientation.*;
import javafx.util.Callback;


/**
 * TilePane lays out its children in a grid of uniformly sized &quot;tiles&quot;.
 * &lt;p&gt;
 * A horizontal tilepane (the default) will tile nodes in rows, wrapping at the
 * tilepane's width.  A vertical tilepane will tile nodes in columns,
 * wrapping at the tilepane's height.
 * &lt;p&gt;
 * The size of each &quot;tile&quot; defaults to the size needed to encompass the largest
 * preferred width and height of the tilepane's children and the tilepane
 * will recompute the size of the tiles as needed to accommodate the largest preferred
 * size of its children as it changes.   The application may also control the size
 * of the tiles directly by setting prefTileWidth/prefTileHeight
 * properties to a value other than USE_COMPUTED_SIZE (the default).
 * &lt;p&gt;
 * Applications should initialize either &lt;code&gt;prefColumns&lt;/code&gt; (for horizontal)
 * or &lt;code&gt;prefRows&lt;/code&gt; (for vertical) to establish the tilepane's preferred
 * size (the arbitrary default is 5).  Note that prefColumns/prefRows
 * is used only for calculating the preferred size and may not reflect the actual
 * number of rows or columns, which may change as the tilepane is resized and
 * the tiles are wrapped at its actual boundaries.
 * &lt;p&gt;
 * The alignment property controls how the rows and columns are aligned
 * within the bounds of the tilepane and defaults to Pos.TOP_LEFT.  It is also possible
 * to control the alignment of nodes within the individual tiles by setting
 * {@link #tileAlignmentProperty() tileAlignment}, which defaults to Pos.CENTER.
 * &lt;p&gt;
 * A horizontal tilepane example:
 * &lt;pre&gt;{@code
 *    TilePane tile = new TilePane();
 *    tile.setHgap(8);
 *    tile.setPrefColumns(4);
 *    for (int i = 0; i &lt; 20; i++) {
 *        tile.getChildren().add(new ImageView(...));
 *    }
 * }&lt;/pre&gt;
 * &lt;p&gt;
 * A vertical TilePane example:
 * &lt;pre&gt;{@code
 *    TilePane tile = new TilePane(Orientation.VERTICAL);
 *    tile.setTileAlignment(Pos.CENTER_LEFT);
 *    tile.setPrefRows(10);
 *    for (int i = 0; i &lt; 50; i++) {
 *        tile.getChildren().add(new ImageView(...));
 *    }
 * }&lt;/pre&gt;
 *
 * The TilePane will attempt to resize each child to fill its tile.
 * If the child could not be sized to fill the tile (either because it was not
 * resizable or its size limits prevented it) then it will be aligned within the
 * tile using tileAlignment.
 *
 * &lt;h3&gt;Resizable Range&lt;/h3&gt;
 *
 * &lt;p&gt;
 * A tilepane's parent will resize the tilepane within the tilepane's resizable range
 * during layout. By default the tilepane computes this range based on its content
 * as outlined in the tables below.
 * &lt;/p&gt;
 * &lt;table border=&quot;1&quot;&gt;
 * &lt;caption&gt;Horizontal&lt;/caption&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;th scope=&quot;col&quot;&gt;width&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;height&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;minimum&lt;/th&gt;
 * &lt;td&gt;left/right insets plus the tile width.&lt;/td&gt;
 * &lt;td&gt;top/bottom insets plus height required to display all tiles when wrapped at a specified width with a vgap between each row.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;preferred&lt;/th&gt;
 * &lt;td&gt;left/right insets plus prefColumns multiplied by the tile width.&lt;/td&gt;
 * &lt;td&gt;top/bottom insets plus height required to display all tiles when wrapped at a specified width with a vgap between each row.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;maximum&lt;/th&gt;
 * &lt;td&gt;Double.MAX_VALUE&lt;/td&gt;&lt;td&gt;Double.MAX_VALUE&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;br&gt;
 * &lt;table border=&quot;1&quot;&gt;
 * &lt;caption&gt;Vertical&lt;/caption&gt;
 * &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;th scope=&quot;col&quot;&gt;width&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;height&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;minimum&lt;/th&gt;
 * &lt;td&gt;left/right insets plus width required to display all tiles when wrapped at a specified height with an hgap between each column.&lt;/td&gt;
 * &lt;td&gt;top/bottom insets plus the tile height.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;preferred&lt;/th&gt;
 * &lt;td&gt;left/right insets plus width required to display all tiles when wrapped at the specified height with an hgap between each column.&lt;/td&gt;
 * &lt;td&gt;top/bottom insets plus prefRows multiplied by the tile height.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;maximum&lt;/th&gt;
 * &lt;td&gt;Double.MAX_VALUE&lt;/td&gt;&lt;td&gt;Double.MAX_VALUE&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;p&gt;
 * A tilepane's unbounded maximum width and height are an indication to the parent that
 * it may be resized beyond its preferred size to fill whatever space is assigned to it.
 * &lt;p&gt;
 * TilePane provides properties for setting the size range directly.  These
 * properties default to the sentinel value Region.USE_COMPUTED_SIZE, however the
 * application may set them to other values as needed:
 * &lt;pre&gt;&lt;code&gt;
 *     &lt;b&gt;tilePane.setMaxWidth(500);&lt;/b&gt;
 * &lt;/code&gt;&lt;/pre&gt;
 * Applications may restore the computed values by setting these properties back
 * to Region.USE_COMPUTED_SIZE.
 * &lt;p&gt;
 * TilePane does not clip its content by default, so it is possible that children's'
 * bounds may extend outside the tiles (and possibly the tilepane bounds) if a
 * child's pref size prevents it from being fit within its tile. Also, if the tilepane
 * is resized smaller than its preferred size, it may not be able to fit all the
 * tiles within its bounds and the content will extend outside.
 *
 * &lt;h3&gt;Optional Layout Constraints&lt;/h3&gt;
 *
 * &lt;p&gt;
 * An application may set constraints on individual children to customize TilePane's layout.
 * For each constraint, TilePane provides a static method for setting it on the child.
 * &lt;/p&gt;
 *
 * &lt;table border=&quot;1&quot;&gt;
 * &lt;caption&gt;TilePane Constraint Table&lt;/caption&gt;
 * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Constraint&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Type&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;alignment&lt;/th&gt;&lt;td&gt;javafx.geometry.Pos&lt;/td&gt;&lt;td&gt;The alignment of the child within its tile.&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;margin&lt;/th&gt;&lt;td&gt;javafx.geometry.Insets&lt;/td&gt;&lt;td&gt;Margin space around the outside of the child.&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 * &lt;p&gt;
 * Example:
 * &lt;pre&gt;{@code
 *     TilePane tilepane = new TilePane();
 *     for (int i = 0; i &lt; 20; i++) {
 *        Label title = new Label(imageTitle[i]):
 *        Imageview imageview = new ImageView(new Image(imageName[i]));
 *        TilePane.setAlignment(label, Pos.BOTTOM_RIGHT);
 *        tilepane.getChildren().addAll(title, imageview);
 *     }
 * }&lt;/pre&gt;
 * @since JavaFX 2.0
 */
public class TilePane extends Pane {

    /********************************************************************
     *  BEGIN static methods
     ********************************************************************/

    private static final String MARGIN_CONSTRAINT = &quot;tilepane-margin&quot;;
    private static final String ALIGNMENT_CONSTRAINT = &quot;tilepane-alignment&quot;;

    /**
     * Sets the alignment for the child when contained by a tilepane.
     * If set, will override the tilepane's default alignment for children
     * within their 'tiles'.
     * Setting the value to null will remove the constraint.
     * @param node the child node of a tilepane
     * @param value the alignment position for the child
     */
    public static void setAlignment(Node node, Pos value) {
        setConstraint(node, ALIGNMENT_CONSTRAINT, value);
    }

    /**
     * Returns the child's alignment constraint if set.
     * @param node the child node of a tilepane
     * @return the alignment position for the child or null if no alignment was set
     */
    public static Pos getAlignment(Node node) {
        return (Pos)getConstraint(node, ALIGNMENT_CONSTRAINT);
    }

    /**
     * Sets the margin for the child when contained by a tilepane.
     * If set, the tilepane will layout the child with the margin space around it.
     * Setting the value to null will remove the constraint.
     * @param node the child node of a tilepane
     * @param value the margin of space around the child
     */
    public static void setMargin(Node node, Insets value) {
        setConstraint(node, MARGIN_CONSTRAINT, value);
    }

    /**
     * Returns the child's margin constraint if set.
     * @param node the child node of a tilepane
     * @return the margin for the child or null if no margin was set
     */
    public static Insets getMargin(Node node) {
        return (Insets)getConstraint(node, MARGIN_CONSTRAINT);
    }

    private static final Callback&lt;Node, Insets&gt; marginAccessor = n -&gt; getMargin(n);

    /**
     * Removes all tilepane constraints from the child node.
     * @param child the child node
     */
    public static void clearConstraints(Node child) {
        setAlignment(child, null);
        setMargin(child, null);
    }

    /********************************************************************
     *  END static methods
     ********************************************************************/

    private double _tileWidth = -1;
    private double _tileHeight = -1;

    /**
     * Creates a horizontal TilePane layout with prefColumn = 5 and hgap/vgap = 0.
     */
    public TilePane() {
        super();
    }

    /**
     * Creates a TilePane layout with the specified orientation,
     * prefColumn/prefRows = 5 and hgap/vgap = 0.
     * @param orientation the direction the tiles should flow &amp;amp; wrap
     */
    public TilePane(Orientation orientation) {
        super();
        setOrientation(orientation);
    }

    /**
     * Creates a horizontal TilePane layout with prefColumn = 5 and the specified
     * hgap/vgap.
     * @param hgap the amount of horizontal space between each tile
     * @param vgap the amount of vertical space between each tile
     */
    public TilePane(double hgap, double vgap) {
        super();
        setHgap(hgap);
        setVgap(vgap);
    }

    /**
     * Creates a TilePane layout with the specified orientation, hgap/vgap,
     * and prefRows/prefColumns = 5.
     * @param orientation the direction the tiles should flow &amp;amp; wrap
     * @param hgap the amount of horizontal space between each tile
     * @param vgap the amount of vertical space between each tile
     */
    public TilePane(Orientation orientation, double hgap, double vgap) {
        this();
        setOrientation(orientation);
        setHgap(hgap);
        setVgap(vgap);
    }

    /**
     * Creates a horizontal TilePane layout with prefColumn = 5 and hgap/vgap = 0.
     * @param children The initial set of children for this pane.
<A NAME="11"></A>     * @since JavaFX 8.0
     */
    public TilePane(Node... children) {
        <FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#11',2,'match49-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>super();
        getChildren().addAll(children);
    }

    /**
     * Creates a TilePane layout with the specified orientation,
     * prefColumn/prefRows = 5 and hgap/vgap = 0.
     * @param orientation the direction the tiles should flow &amp;amp; wrap
     * @param children The initial set of children for this pane.
     * @since JavaFX 8.0
     */
    public TilePane(Orientation orientation, Node... children) {
        super();
        setOrientation(orientation);
        getChildren().addAll(children);
    }

    /**
     * Creates a horizontal TilePane layout with prefColumn = 5 and the specified
     * hgap/vgap.
     * @param hgap the amount of horizontal space between each tile
     * @param vgap the amount of vertical space between each tile
     * @param children The initial set of children for this pane.
     * @since JavaFX 8.0
     */
    public TilePane(double hgap, double vgap</B></FONT>, Node... children) {
        super();
        setHgap(hgap);
        setVgap(vgap);
        getChildren().addAll(children);
    }

    /**
     * Creates a TilePane layout with the specified orientation, hgap/vgap,
     * and prefRows/prefColumns = 5.
     * @param orientation the direction the tiles should flow &amp;amp; wrap
     * @param hgap the amount of horizontal space between each tile
     * @param vgap the amount of vertical space between each tile
     * @param children The initial set of children for this pane.
     * @since JavaFX 8.0
     */
    public TilePane(Orientation orientation, double hgap, double vgap, Node... children) {
        this();
        setOrientation(orientation);
        setHgap(hgap);
        setVgap(vgap);
        getChildren().addAll(children);
    }

    /**
     * The orientation of this tilepane.
     * A horizontal tilepane lays out children in tiles, left to right, wrapping
     * tiles at the tilepane's width boundary.   A vertical tilepane lays out
     * children in tiles, top to bottom, wrapping at the tilepane's height.
     * The default is horizontal.
     * @return the orientation of this tilepane
     */
    public final ObjectProperty&lt;Orientation&gt; orientationProperty() {
        if (orientation == null) {
            orientation = new StyleableObjectProperty(HORIZONTAL) {
                @Override
                public void invalidated() {
                    requestLayout();
                }

                @Override
                public CssMetaData&lt;TilePane, Orientation&gt; getCssMetaData() {
                    return StyleableProperties.ORIENTATION;
                }

                @Override
                public Object getBean() {
                    return TilePane.this;
                }

                @Override
                public String getName() {
                    return &quot;orientation&quot;;
                }
            };
        }
        return orientation;
    }

    private ObjectProperty&lt;Orientation&gt; orientation;
    public final void setOrientation(Orientation value) { orientationProperty().set(value); }
    public final Orientation getOrientation() { return orientation == null ? HORIZONTAL : orientation.get();  }


    /**
     * The preferred number of rows for a vertical tilepane.
     * This value is used only to compute the preferred size of the tilepane
     * and may not reflect the actual number of rows, which may change
     * if the tilepane is resized to something other than its preferred height.
     * This property is ignored for a horizontal tilepane.
     * &lt;p&gt;
     * It is recommended that the application initialize this value for a
     * vertical tilepane.
     * @return the preferred number of rows for a vertical tilepane
     */
    public final IntegerProperty prefRowsProperty() {
        if (prefRows == null) {
            prefRows = new StyleableIntegerProperty(5) {
                @Override
                public void invalidated() {
                    requestLayout();
                }

                @Override
                public CssMetaData&lt;TilePane, Number&gt; getCssMetaData() {
                    return StyleableProperties.PREF_ROWS;
                }

                @Override
                public Object getBean() {
                    return TilePane.this;
                }

                @Override
                public String getName() {
                    return &quot;prefRows&quot;;
                }
            };
        }
        return prefRows;
    }

    private IntegerProperty prefRows;
    public final void setPrefRows(int value) { prefRowsProperty().set(value); }
    public final int getPrefRows() { return prefRows == null ? 5 : prefRows.get(); }

    /**
     * The preferred number of columns for a horizontal tilepane.
     * This value is used only to compute the preferred size of the tilepane
     * and may not reflect the actual number of rows, which may change if the
     * tilepane is resized to something other than its preferred height.
     * This property is ignored for a vertical tilepane.
     * &lt;p&gt;
     * It is recommended that the application initialize this value for a
     * horizontal tilepane.
     * @return the preferred number of columns for a horizontal tilepane
     */
    public final IntegerProperty prefColumnsProperty() {
        if (prefColumns == null) {
            prefColumns = new StyleableIntegerProperty(5) {
                @Override
                public void invalidated() {
                    requestLayout();
                }

                @Override
                public CssMetaData&lt;TilePane, Number&gt; getCssMetaData() {
                    return StyleableProperties.PREF_COLUMNS;
                }

                @Override
                public Object getBean() {
                    return TilePane.this;
                }

                @Override
                public String getName() {
                    return &quot;prefColumns&quot;;
                }
            };
        }
        return prefColumns;
    }

    private IntegerProperty prefColumns;
    public final void setPrefColumns(int value) { prefColumnsProperty().set(value); }
    public final int getPrefColumns() { return prefColumns == null ? 5 : prefColumns.get(); }

    /**
     * The preferred width of each tile.
     * If equal to USE_COMPUTED_SIZE (the default) the tile width wlll be
     * automatically recomputed by the tilepane when the preferred size of children
     * changes to accommodate the widest child.  If the application sets this property
     * to value greater than 0, then tiles will be set to that width and the tilepane
     * will attempt to resize children to fit within that width (if they are resizable and
     * their min-max width range allows it).
     * @return the preferred width of each tile
     */
    public final DoubleProperty prefTileWidthProperty() {
        if (prefTileWidth == null) {
            prefTileWidth = new StyleableDoubleProperty(USE_COMPUTED_SIZE) {
                @Override
                public void invalidated() {
                    requestLayout();
                }

                @Override
                public CssMetaData&lt;TilePane, Number&gt; getCssMetaData() {
                    return StyleableProperties.PREF_TILE_WIDTH;
                }

                @Override
                public Object getBean() {
                    return TilePane.this;
                }

                @Override
                public String getName() {
                    return &quot;prefTileWidth&quot;;
                }
            };
        }
        return prefTileWidth;
    }

    private DoubleProperty prefTileWidth;
    public final void setPrefTileWidth(double value) { prefTileWidthProperty().set(value); }
    public final double getPrefTileWidth() { return prefTileWidth == null ? USE_COMPUTED_SIZE : prefTileWidth.get(); }

    /**
     * The preferred height of each tile.
     * If equal to USE_COMPUTED_SIZE (the default) the tile height wlll be
     * automatically recomputed by the tilepane when the preferred size of children
     * changes to accommodate the tallest child.  If the application sets this property
     * to value greater than 0, then tiles will be set to that height and the tilepane
     * will attempt to resize children to fit within that height (if they are resizable and
     * their min-max height range allows it).
     * @return the preferred height of each tile
     */
    public final DoubleProperty prefTileHeightProperty() {
        if (prefTileHeight == null) {
            prefTileHeight = new StyleableDoubleProperty(USE_COMPUTED_SIZE) {
                @Override
                public void invalidated() {
                    requestLayout();
                }

                @Override
                public CssMetaData&lt;TilePane, Number&gt; getCssMetaData() {
                    return StyleableProperties.PREF_TILE_HEIGHT;
                }

                @Override
                public Object getBean() {
                    return TilePane.this;
                }

                @Override
                public String getName() {
                    return &quot;prefTileHeight&quot;;
                }
            };
        }
        return prefTileHeight;
    }

    private DoubleProperty prefTileHeight;
    public final void setPrefTileHeight(double value) { prefTileHeightProperty().set(value); }
    public final double getPrefTileHeight() { return prefTileHeight == null ? USE_COMPUTED_SIZE : prefTileHeight.get(); }

    /**
     * The actual width of each tile.  This property is read-only.
     * @return the actual width of each tile
     */
    public final ReadOnlyDoubleProperty tileWidthProperty() {
        if (tileWidth == null) {
            tileWidth = new TileSizeProperty(&quot;tileWidth&quot;, _tileWidth) {

                @Override
                public double compute() {
                    return computeTileWidth();
                }

            };
        }
        return tileWidth;
    }
    private TileSizeProperty tileWidth;
    private void invalidateTileWidth() {
        if (tileWidth != null) {
            tileWidth.invalidate();
        } else {
            _tileWidth = -1;
        }
    }

    public final double getTileWidth() {
        if (tileWidth != null) {
            return tileWidth.get();
        }
        if (_tileWidth == -1) {
            _tileWidth = computeTileWidth();
        }
        return _tileWidth;
    }

    /**
     * The actual height of each tile.  This property is read-only.
     * @return the actual height of each tile
     */
    public final ReadOnlyDoubleProperty tileHeightProperty() {
        if (tileHeight == null) {
            tileHeight = new TileSizeProperty(&quot;tileHeight&quot;, _tileHeight) {

                @Override
                public double compute() {
                    return computeTileHeight();
                }

            };
        }
        return tileHeight;
    }
    private TileSizeProperty tileHeight;
    private void invalidateTileHeight() {
        if (tileHeight != null) {
            tileHeight.invalidate();
        } else {
            _tileHeight = -1;
        }
    }

    public final double getTileHeight() {
        if (tileHeight != null) {
            return tileHeight.get();
        }
        if (_tileHeight == -1) {
            _tileHeight = computeTileHeight();
        }
        return _tileHeight;
    }

    /**
     * The amount of horizontal space between each tile in a row.
     * @return the amount of horizontal space between each tile in a row
     */
    public final DoubleProperty hgapProperty() {
        if (hgap == null) {
            hgap = new StyleableDoubleProperty() {
                @Override
                public void invalidated() {
                    requestLayout();
                }

                @Override
                public CssMetaData&lt;TilePane, Number&gt; getCssMetaData() {
                    return StyleableProperties.HGAP;
                }

                @Override
                public Object getBean() {
                    return TilePane.this;
                }

                @Override
                public String getName() {
                    return &quot;hgap&quot;;
                }
            };
        }
        return hgap;
    }

    private DoubleProperty hgap;
    public final void setHgap(double value) { hgapProperty().set(value); }
    public final double getHgap() { return hgap == null ? 0 : hgap.get(); }

    /**
     * The amount of vertical space between each tile in a column.
     * @return the amount of vertical space between each tile in a column
     */
    public final DoubleProperty vgapProperty() {
        if (vgap == null) {
            vgap = new StyleableDoubleProperty() {
                @Override
                public void invalidated() {
                    requestLayout();
                }

                @Override
                public CssMetaData&lt;TilePane, Number&gt; getCssMetaData() {
                    return StyleableProperties.VGAP;
                }

                @Override
                public Object getBean() {
                    return TilePane.this;
                }

                @Override
                public String getName() {
                    return &quot;vgap&quot;;
                }
            };
        }
        return vgap;
    }

    private DoubleProperty vgap;
    public final void setVgap(double value) { vgapProperty().set(value); }
    public final double getVgap() { return vgap == null ? 0 : vgap.get(); }

    /**
     * The overall alignment of the tilepane's content within its width and height.
     * &lt;p&gt;For a horizontal tilepane, each row will be aligned within the tilepane's width
     * using the alignment's hpos value, and the rows will be aligned within the
     * tilepane's height using the alignment's vpos value.
     * &lt;p&gt;For a vertical tilepane, each column will be aligned within the tilepane's height
     * using the alignment's vpos value, and the columns will be aligned within the
     * tilepane's width using the alignment's hpos value.
     *
     * @return the overall alignment of the tilepane's content within its width
     * and height
     */
    public final ObjectProperty&lt;Pos&gt; alignmentProperty() {
        if (alignment == null) {
            alignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.TOP_LEFT) {
                @Override
                public void invalidated() {
                    requestLayout();
                }

                @Override
                public CssMetaData&lt;TilePane, Pos&gt; getCssMetaData() {
                    return StyleableProperties.ALIGNMENT;
                }

                @Override
                public Object getBean() {
                    return TilePane.this;
                }

                @Override
                public String getName() {
                    return &quot;alignment&quot;;
                }
            };
        }
        return alignment;
    }

    private ObjectProperty&lt;Pos&gt; alignment;
    public final void setAlignment(Pos value) { alignmentProperty().set(value); }
    public final Pos getAlignment() { return alignment == null ? Pos.TOP_LEFT : alignment.get(); }
    private Pos getAlignmentInternal() {
        Pos localPos = getAlignment();
        return localPos == null ? Pos.TOP_LEFT : localPos;
    }

    /**
     * The default alignment of each child within its tile.
     * This may be overridden on individual children by setting the child's
     * alignment constraint.
     * @return the default alignment of each child within its tile
     */
    public final ObjectProperty&lt;Pos&gt; tileAlignmentProperty() {
        if (tileAlignment == null) {
            tileAlignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.CENTER) {
                @Override
                public void invalidated() {
                    requestLayout();
                }

                @Override
                public CssMetaData&lt;TilePane, Pos&gt; getCssMetaData() {
                    return StyleableProperties.TILE_ALIGNMENT;
                }

                @Override
                public Object getBean() {
                    return TilePane.this;
                }

                @Override
                public String getName() {
                    return &quot;tileAlignment&quot;;
                }
            };
        }
        return tileAlignment;
    }

    private ObjectProperty&lt;Pos&gt; tileAlignment;
    public final void setTileAlignment(Pos value) { tileAlignmentProperty().set(value); }
    public final Pos getTileAlignment() { return tileAlignment == null ? Pos.CENTER : tileAlignment.get(); }
    private Pos getTileAlignmentInternal() {
        Pos localPos = getTileAlignment();
        return localPos == null ? Pos.CENTER : localPos;
    }

    @Override public Orientation getContentBias() {
        return getOrientation();
    }

    @Override public void requestLayout() {
        invalidateTileWidth();
        invalidateTileHeight();
        super.requestLayout();
    }

    @Override protected double computeMinWidth(double height) {
        if (getContentBias() == Orientation.HORIZONTAL) {
            return getInsets().getLeft() + getTileWidth() + getInsets().getRight();
        }
        return computePrefWidth(height);
    }

    @Override protected double computeMinHeight(double width) {
        if (getContentBias() == Orientation.VERTICAL) {
            return getInsets().getTop() + getTileHeight() + getInsets().getBottom();
        }
        return computePrefHeight(width);
    }

    @Override protected double computePrefWidth(double forHeight) {
        List&lt;Node&gt; managed = getManagedChildren();
        final Insets insets = getInsets();
        int prefCols = 0;
        if (forHeight != -1) {
            // first compute number of rows that will fit in given height and
            // compute pref columns from that
            int prefRows = computeRows(forHeight - snapSpaceY(insets.getTop()) - snapSpaceY(insets.getBottom()), getTileHeight());
            prefCols = computeOther(managed.size(), prefRows);
        } else {
            prefCols = getOrientation() == HORIZONTAL? getPrefColumns() : computeOther(managed.size(), getPrefRows());
        }
        return snapSpaceX(insets.getLeft()) +
               computeContentWidth(prefCols, getTileWidth()) +
               snapSpaceX(insets.getRight());
    }

    @Override protected double computePrefHeight(double forWidth) {
        List&lt;Node&gt; managed = getManagedChildren();
        final Insets insets = getInsets();
        int prefRows = 0;
        if (forWidth != -1) {
            // first compute number of columns that will fit in given width and
            // compute pref rows from that
            int prefCols = computeColumns(forWidth - snapSpaceX(insets.getLeft()) - snapSpaceX(insets.getRight()), getTileWidth());
            prefRows = computeOther(managed.size(), prefCols);
        } else {
            prefRows = getOrientation() == HORIZONTAL? computeOther(managed.size(), getPrefColumns()) : getPrefRows();
        }
        return snapSpaceY(insets.getTop()) +
               computeContentHeight(prefRows, getTileHeight()) +
               snapSpaceY(insets.getBottom());
    }

    private double computeTileWidth() {
        List&lt;Node&gt; managed = getManagedChildren();
        double preftilewidth = getPrefTileWidth();
        if (preftilewidth == USE_COMPUTED_SIZE) {
            double h = -1;
            boolean vertBias = false;
            for (int i = 0, size = managed.size(); i &lt; size; i++) {
                Node child = managed.get(i);
                if (child.getContentBias() == VERTICAL) {
                    vertBias = true;
                    break;
                }
            }
            if (vertBias) {
                // widest may depend on height of tile
                h = computeMaxPrefAreaHeight(managed, marginAccessor, -1, getTileAlignmentInternal().getVpos());
            }
            return snapSizeX(computeMaxPrefAreaWidth(managed, marginAccessor, h, true));
        }
        return snapSizeX(preftilewidth);
    }

    private double computeTileHeight() {
        List&lt;Node&gt; managed = getManagedChildren();
        double preftileheight = getPrefTileHeight();
        if (preftileheight == USE_COMPUTED_SIZE) {
            double w = -1;
            boolean horizBias = false;
            for (int i = 0, size = managed.size(); i &lt; size; i++) {
                Node child = managed.get(i);
                if (child.getContentBias() == Orientation.HORIZONTAL) {
                    horizBias = true;
                    break;
                }
            }
            if (horizBias) {
                // tallest may depend on width of tile
                w = computeMaxPrefAreaWidth(managed, marginAccessor);
            }
            return snapSizeY(computeMaxPrefAreaHeight(managed, marginAccessor, w, getTileAlignmentInternal().getVpos()));
        }
        return snapSizeY(preftileheight);
    }

    private int computeOther(int numNodes, int numCells) {
        double other = (double)numNodes/(double)Math.max(1, numCells);
        return (int)Math.ceil(other);
    }

    private int computeColumns(double width, double tilewidth) {
        double snappedHgap = snapSpaceX(getHgap());
        return Math.max(1,(int)((width + snappedHgap) / (tilewidth + snappedHgap)));
    }

    private int computeRows(double height, double tileheight) {
        double snappedVgap = snapSpaceY(getVgap());
        return Math.max(1, (int)((height + snappedVgap) / (tileheight + snappedVgap)));
    }

    private double computeContentWidth(int columns, double tilewidth) {
        if (columns == 0) return 0;
        return columns * tilewidth + (columns - 1) * snapSpaceX(getHgap());
    }

    private double computeContentHeight(int rows, double tileheight) {
        if (rows == 0) return 0;
        return rows * tileheight + (rows - 1) * snapSpaceY(getVgap());
    }

    @Override protected void layoutChildren() {
        List&lt;Node&gt; managed = getManagedChildren();
        HPos hpos = getAlignmentInternal().getHpos();
        VPos vpos = getAlignmentInternal().getVpos();
        double width = getWidth();
        double height = getHeight();
        double top = snapSpaceY(getInsets().getTop());
        double left = snapSpaceX(getInsets().getLeft());
        double bottom = snapSpaceY(getInsets().getBottom());
        double right = snapSpaceX(getInsets().getRight());
        double vgap = snapSpaceY(getVgap());
        double hgap = snapSpaceX(getHgap());
        double insideWidth = width - left - right;
        double insideHeight = height - top - bottom;

        double tileWidth = getTileWidth() &gt; insideWidth ? insideWidth : getTileWidth();
        double tileHeight = getTileHeight() &gt; insideHeight ? insideHeight : getTileHeight();

        int lastRowRemainder = 0;
        int lastColumnRemainder = 0;
        if (getOrientation() == HORIZONTAL) {
            actualColumns = computeColumns(insideWidth, tileWidth);
            actualRows = computeOther(managed.size(), actualColumns);
            // remainder will be 0 if last row is filled
            lastRowRemainder = hpos != HPos.LEFT?
                 actualColumns - (actualColumns*actualRows - managed.size()) : 0;
        } else {
            // vertical
            actualRows = computeRows(insideHeight, tileHeight);
            actualColumns = computeOther(managed.size(), actualRows);
            // remainder will be 0 if last column is filled
            lastColumnRemainder = vpos != VPos.TOP?
                actualRows - (actualColumns*actualRows - managed.size()) : 0;
        }
        double rowX = left + computeXOffset(insideWidth,
                                            computeContentWidth(actualColumns, tileWidth),
                                            hpos);
        double columnY = top + computeYOffset(insideHeight,
                                            computeContentHeight(actualRows, tileHeight),
                                            vpos);

        double lastRowX = lastRowRemainder &gt; 0?
                          left + computeXOffset(insideWidth,
                                            computeContentWidth(lastRowRemainder, tileWidth),
                                            hpos) :  rowX;
        double lastColumnY = lastColumnRemainder &gt; 0?
                          top + computeYOffset(insideHeight,
                                            computeContentHeight(lastColumnRemainder, tileHeight),
                                            vpos) : columnY;
        double baselineOffset = getTileAlignmentInternal().getVpos() == VPos.BASELINE ?
                getAreaBaselineOffset(managed, marginAccessor, i -&gt; tileWidth, tileHeight, false) : -1;

        int r = 0;
        int c = 0;
        for (int i = 0, size = managed.size(); i &lt; size; i++) {
            Node child = managed.get(i);
            double xoffset = r == (actualRows - 1)? lastRowX : rowX;
            double yoffset = c == (actualColumns - 1)? lastColumnY : columnY;

            double tileX = xoffset + (c * (tileWidth + hgap));
            double tileY = yoffset + (r * (tileHeight + vgap));

            Pos childAlignment = getAlignment(child);

            layoutInArea(child, tileX, tileY, tileWidth, tileHeight, baselineOffset,
                    getMargin(child),
                    childAlignment != null? childAlignment.getHpos() : getTileAlignmentInternal().getHpos(),
                    childAlignment != null? childAlignment.getVpos() : getTileAlignmentInternal().getVpos());

            if (getOrientation() == HORIZONTAL) {
                if (++c == actualColumns) {
                    c = 0;
                    r++;
                }
            } else {
                // vertical
                if (++r == actualRows) {
                    r = 0;
                    c++;
                }
            }
        }
    }

    private int actualRows = 0;
    private int actualColumns = 0;

    /***************************************************************************
     *                                                                         *
     *                         Stylesheet Handling                             *
     *                                                                         *
     **************************************************************************/


     /*
      * Super-lazy instantiation pattern from Bill Pugh.
      */
     private static class StyleableProperties {

         private static final CssMetaData&lt;TilePane,Pos&gt; ALIGNMENT =
             new CssMetaData&lt;TilePane,Pos&gt;(&quot;-fx-alignment&quot;,
                 new EnumConverter&lt;Pos&gt;(Pos.class),
                 Pos.TOP_LEFT) {

            @Override
            public boolean isSettable(TilePane node) {
                return node.alignment == null || !node.alignment.isBound();
            }

            @Override
            public StyleableProperty&lt;Pos&gt; getStyleableProperty(TilePane node) {
                return (StyleableProperty&lt;Pos&gt;)node.alignmentProperty();
            }
        };

         private static final CssMetaData&lt;TilePane,Number&gt; PREF_COLUMNS =
             new CssMetaData&lt;TilePane,Number&gt;(&quot;-fx-pref-columns&quot;,
                 SizeConverter.getInstance(), 5.0) {

            @Override
            public boolean isSettable(TilePane node) {
                return node.prefColumns == null ||
                        !node.prefColumns.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(TilePane node) {
                return (StyleableProperty&lt;Number&gt;)node.prefColumnsProperty();
            }
        };

         private static final CssMetaData&lt;TilePane,Number&gt; HGAP =
             new CssMetaData&lt;TilePane,Number&gt;(&quot;-fx-hgap&quot;,
                 SizeConverter.getInstance(), 0.0) {

            @Override
            public boolean isSettable(TilePane node) {
                return node.hgap == null ||
                        !node.hgap.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(TilePane node) {
                return (StyleableProperty&lt;Number&gt;)node.hgapProperty();
            }
        };

         private static final CssMetaData&lt;TilePane,Number&gt; PREF_ROWS =
             new CssMetaData&lt;TilePane,Number&gt;(&quot;-fx-pref-rows&quot;,
                 SizeConverter.getInstance(), 5.0) {

            @Override
            public boolean isSettable(TilePane node) {
                return node.prefRows == null ||
                        !node.prefRows.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(TilePane node) {
                return (StyleableProperty&lt;Number&gt;)node.prefRowsProperty();
            }
        };

         private static final CssMetaData&lt;TilePane,Pos&gt; TILE_ALIGNMENT =
             new CssMetaData&lt;TilePane,Pos&gt;(&quot;-fx-tile-alignment&quot;,
                 new EnumConverter&lt;Pos&gt;(Pos.class),
                 Pos.CENTER) {

            @Override
            public boolean isSettable(TilePane node) {
                return node.tileAlignment == null ||
                        !node.tileAlignment.isBound();
            }

            @Override
            public StyleableProperty&lt;Pos&gt; getStyleableProperty(TilePane node) {
                return (StyleableProperty&lt;Pos&gt;)node.tileAlignmentProperty();
            }
         };

         private static final CssMetaData&lt;TilePane,Number&gt; PREF_TILE_WIDTH =
             new CssMetaData&lt;TilePane,Number&gt;(&quot;-fx-pref-tile-width&quot;,
                 SizeConverter.getInstance(), USE_COMPUTED_SIZE) {

            @Override
            public boolean isSettable(TilePane node) {
                return node.prefTileWidth == null ||
                        !node.prefTileWidth.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(TilePane node) {
                return (StyleableProperty&lt;Number&gt;)node.prefTileWidthProperty();
            }
        };

         private static final CssMetaData&lt;TilePane,Number&gt; PREF_TILE_HEIGHT =
             new CssMetaData&lt;TilePane,Number&gt;(&quot;-fx-pref-tile-height&quot;,
                 SizeConverter.getInstance(), USE_COMPUTED_SIZE) {

            @Override
            public boolean isSettable(TilePane node) {
                return node.prefTileHeight == null ||
                        !node.prefTileHeight.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(TilePane node) {
                return (StyleableProperty&lt;Number&gt;)node.prefTileHeightProperty();
            }
         };

         private static final CssMetaData&lt;TilePane,Orientation&gt; ORIENTATION =
             new CssMetaData&lt;TilePane,Orientation&gt;(&quot;-fx-orientation&quot;,
                 new EnumConverter&lt;Orientation&gt;(Orientation.class),
                 Orientation.HORIZONTAL) {

                @Override
                public Orientation getInitialValue(TilePane node) {
                    // A vertical TilePane should remain vertical
                    return node.getOrientation();
                }

                @Override
                public boolean isSettable(TilePane node) {
                    return node.orientation == null ||
                            !node.orientation.isBound();
                }

                @Override
                public StyleableProperty&lt;Orientation&gt; getStyleableProperty(TilePane node) {
                    return (StyleableProperty&lt;Orientation&gt;)node.orientationProperty();
                }
         };

         private static final CssMetaData&lt;TilePane,Number&gt; VGAP =
             new CssMetaData&lt;TilePane,Number&gt;(&quot;-fx-vgap&quot;,
                 SizeConverter.getInstance(), 0.0) {

            @Override
            public boolean isSettable(TilePane node) {
                return node.vgap == null ||
                        !node.vgap.isBound();
            }

            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(TilePane node) {
                return (StyleableProperty&lt;Number&gt;)node.vgapProperty();
            }
        };

         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
         static {
            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());
            styleables.add(ALIGNMENT);
            styleables.add(HGAP);
            styleables.add(ORIENTATION);
            styleables.add(PREF_COLUMNS);
            styleables.add(PREF_ROWS);
            styleables.add(PREF_TILE_WIDTH);
            styleables.add(PREF_TILE_HEIGHT);
            styleables.add(TILE_ALIGNMENT);
            styleables.add(VGAP);
            STYLEABLES = Collections.unmodifiableList(styleables);
         }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     *
     * @since JavaFX 8.0
     */


    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    private abstract class TileSizeProperty extends ReadOnlyDoubleProperty {
        private final String name;
        private ExpressionHelper&lt;Number&gt; helper;
        private double value;
        private boolean valid;

        TileSizeProperty(String name, double initSize) {
            this.name = name;
            this.value = initSize;
            this.valid = initSize != -1;
        }


        @Override
        public Object getBean() {
            return TilePane.this;
        }

        @Override
        public String getName() {
            return name;
        }

        @Override
        public void addListener(InvalidationListener listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(InvalidationListener listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public void addListener(ChangeListener&lt;? super Number&gt; listener) {
            helper = ExpressionHelper.addListener(helper, this, listener);
        }

        @Override
        public void removeListener(ChangeListener&lt;? super Number&gt; listener) {
            helper = ExpressionHelper.removeListener(helper, listener);
        }

        @Override
        public double get() {
            if (!valid) {
                value = compute();
                valid = true;
            }

            return value;
        }

        public void invalidate() {
            if (valid) {
                valid = false;
                ExpressionHelper.fireValueChangedEvent(helper);
            }
        }

        public abstract double compute();
    }

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.media/com/sun/media/jfxmedia/MediaError.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.media.jfxmedia;

import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;

public enum MediaError {

    ERROR_BASE_MEDIA(0x00000100),
    ERROR_BASE_MANAGER(0x00000200),
    ERROR_BASE_PIPELINE(0x00000300),
    ERROR_BASE_FACTORY(0x00000400),
    ERROR_BASE_LOCATOR(0x00000500),
    ERROR_BASE_REGISTRY(0x00000600),
    ERROR_BASE_GSTREAMER(0x00000800),
    ERROR_BASE_SYSTEM(0x00000A00),
    ERROR_BASE_FUNCTION(0x00000B00),
    ERROR_BASE_JNI(0x00000C00),       // JNI upcall from native into Java
<A NAME="9"></A>    ERROR_BASE_OSX(0x00000D00),

    WARNING_BASE_JFXMEDIA(0x00100000),
    <FONT color="#f88017"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#9',2,'match49-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>WARNING_BASE_GSTREAMER(0x00800000),
    WARNING_BASE_GLIB(0x00900000),

    ERROR_MASK_BASE(0x00000F00),
    WARNING_MASK_BASE(0x00F00000),

    ERROR_NONE(0x0),

    ERROR_MANAGER_NULL(ERROR_BASE_MANAGER.code</B></FONT>()+0x0001),
    ERROR_MANAGER_CREATION(ERROR_BASE_MANAGER.code()+0x0002),
    ERROR_MANAGER_ENGINEINIT_FAIL(ERROR_BASE_MANAGER.code()+0x0003),
    ERROR_MANAGER_RUNLOOP_FAIL(ERROR_BASE_MANAGER.code()+0x0004),
    ERROR_MANAGER_LOGGER_INIT(ERROR_BASE_MANAGER.code()+0x0005),

    ERROR_MEDIA_NULL(ERROR_BASE_MEDIA.code()+0x0001),
    ERROR_MEDIA_CREATION(ERROR_BASE_MEDIA.code()+0x0002),
    ERROR_MEDIA_UNKNOWN_PIXEL_FORMAT(ERROR_BASE_MEDIA.code()+0x0003),
    ERROR_MEDIA_INVALID(ERROR_BASE_MEDIA.code()+0x0004),
    ERROR_MEDIA_MARKER_NAME_NULL(ERROR_BASE_MEDIA.code()+0x0005),
    ERROR_MEDIA_MARKER_TIME_NEGATIVE(ERROR_BASE_MEDIA.code()+0x0006),
    ERROR_MEDIA_MARKER_MAP_NULL(ERROR_BASE_MEDIA.code()+0x0007),
    ERROR_MEDIA_VIDEO_FORMAT_UNSUPPORTED(ERROR_BASE_MEDIA.code()+0x0008),
    ERROR_MEDIA_AUDIO_FORMAT_UNSUPPORTED(ERROR_BASE_MEDIA.code()+0x0009),
    ERROR_MEDIA_MP3_FORMAT_UNSUPPORTED(ERROR_BASE_MEDIA.code()+0x000A),
    ERROR_MEDIA_AAC_FORMAT_UNSUPPORTED(ERROR_BASE_MEDIA.code()+0x000B),
    ERROR_MEDIA_H264_FORMAT_UNSUPPORTED(ERROR_BASE_MEDIA.code()+0x000C),
    ERROR_MEDIA_HLS_FORMAT_UNSUPPORTED(ERROR_BASE_MEDIA.code()+0x000D),
    ERROR_MEDIA_CORRUPTED(ERROR_BASE_MEDIA.code()+0x000E),

    ERROR_PIPELINE_NULL(ERROR_BASE_PIPELINE.code()+0x0001),
    ERROR_PIPELINE_CREATION(ERROR_BASE_PIPELINE.code()+0x0002),
    ERROR_PIPELINE_NO_FRAME_QUEUE(ERROR_BASE_PIPELINE.code()+0x0003),

    ERROR_FACTORY_NULL(ERROR_BASE_FACTORY.code()+0x0001),
    ERROR_FACTORY_CONTAINER_CREATION(ERROR_BASE_FACTORY.code()+0x0002),
    ERROR_FACTORY_INVALID_URI(ERROR_BASE_FACTORY.code()+0x0003),

    ERROR_LOCATOR_NULL(ERROR_BASE_LOCATOR.code()+0x0001),
    ERROR_LOCATOR_UNSUPPORTED_TYPE(ERROR_BASE_LOCATOR.code()+0x0002),
    ERROR_LOCATOR_UNSUPPORTED_MEDIA_FORMAT(ERROR_BASE_LOCATOR.code()+0x0003),
    ERROR_LOCATOR_CONNECTION_LOST(ERROR_BASE_LOCATOR.code()+0x0004),
    ERROR_LOCATOR_CONTENT_TYPE_NULL(ERROR_BASE_LOCATOR.code()+0x0005),

    ERROR_REGISTRY_NULL(ERROR_BASE_REGISTRY.code()+0x0001),
    ERROR_REGISTRY_PLUGIN_ALREADY_EXIST(ERROR_BASE_REGISTRY.code()+0x0002),
    ERROR_REGISTRY_PLUGIN_PATH(ERROR_BASE_REGISTRY.code()+0x0003),
    ERROR_REGISTRY_NO_MATCHING_RECIPE(ERROR_BASE_REGISTRY.code()+0x0004),

    ERROR_GSTREAMER_ERROR(ERROR_BASE_GSTREAMER.code()+0x0001),
    ERROR_GSTREAMER_PIPELINE_CREATION(ERROR_BASE_GSTREAMER.code()+0x0002),
    ERROR_GSTREAMER_AUDIO_DECODER_SINK_PAD(ERROR_BASE_GSTREAMER.code()+0x0003),
    ERROR_GSTREAMER_AUDIO_DECODER_SRC_PAD(ERROR_BASE_GSTREAMER.code()+0x0004),
    ERROR_GSTREAMER_AUDIO_SINK_SINK_PAD(ERROR_BASE_GSTREAMER.code()+0x0005),
    ERROR_GSTREAMER_VIDEO_DECODER_SINK_PAD(ERROR_BASE_GSTREAMER.code()+0x0006),
    ERROR_GSTREAMER_PIPELINE_STATE_CHANGE(ERROR_BASE_GSTREAMER.code()+0x0007),
    ERROR_GSTREAMER_PIPELINE_SEEK(ERROR_BASE_GSTREAMER.code()+0x0008),
    ERROR_GSTREAMER_PIPELINE_QUERY_LENGTH(ERROR_BASE_GSTREAMER.code()+0x0009),
    ERROR_GSTREAMER_PIPELINE_QUERY_POS(ERROR_BASE_GSTREAMER.code()+0x000A),
    ERROR_GSTREAMER_PIPELINE_METADATA_TYPE(ERROR_BASE_GSTREAMER.code()+0x000B),
    ERROR_GSTREAMER_AUDIO_SINK_CREATE(ERROR_BASE_GSTREAMER.code()+0x000C),
    ERROR_GSTREAMER_GET_BUFFER_SRC_PAD(ERROR_BASE_GSTREAMER.code()+0x000D),
    ERROR_GSTREAMER_CREATE_GHOST_PAD(ERROR_BASE_GSTREAMER.code()+0x000E),
    ERROR_GSTREAMER_ELEMENT_ADD_PAD(ERROR_BASE_GSTREAMER.code()+0x000F),
    ERROR_GSTREAMER_UNSUPPORTED_PROTOCOL(ERROR_BASE_GSTREAMER.code()+0x0010),
    ERROR_GSTREAMER_SOURCEFILE_NONEXISTENT(ERROR_BASE_GSTREAMER.code()+0x0020),
    ERROR_GSTREAMER_SOURCEFILE_NONREGULAR(ERROR_BASE_GSTREAMER.code()+0x0030),
    ERROR_GSTREAMER_ELEMENT_LINK(ERROR_BASE_GSTREAMER.code()+0x0040),
    ERROR_GSTREAMER_ELEMENT_LINK_AUDIO_BIN(ERROR_BASE_GSTREAMER.code()+0x0050),
    ERROR_GSTREAMER_ELEMENT_LINK_VIDEO_BIN(ERROR_BASE_GSTREAMER.code()+0x0060),
    ERROR_GSTREAMER_ELEMENT_CREATE(ERROR_BASE_GSTREAMER.code()+0x0070),
    ERROR_GSTREAMER_VIDEO_SINK_CREATE(ERROR_BASE_GSTREAMER.code()+0x0080),
    ERROR_GSTREAMER_BIN_CREATE(ERROR_BASE_GSTREAMER.code()+0x0090),
    ERROR_GSTREAMER_BIN_ADD_ELEMENT(ERROR_BASE_GSTREAMER.code()+0x00A0),
    ERROR_GSTREAMER_ELEMENT_GET_PAD(ERROR_BASE_GSTREAMER.code()+0x00B0),
    ERROR_GSTREAMER_MAIN_LOOP_CREATE(ERROR_BASE_GSTREAMER.code()+0x00C0),
    ERROR_GSTREAMER_BUS_SOURCE_ATTACH(ERROR_BASE_GSTREAMER.code()+0x00C1),
    ERROR_GSTREAMER_PIPELINE_SET_RATE_ZERO(ERROR_BASE_GSTREAMER.code()+0x00D0),
    ERROR_GSTREAMER_VIDEO_SINK_SINK_PAD(ERROR_BASE_GSTREAMER.code()+0x00E0),

    ERROR_NOT_IMPLEMENTED(ERROR_BASE_SYSTEM.code()+0x0001),
    ERROR_MEMORY_ALLOCATION(ERROR_BASE_SYSTEM.code()+0x0002),
    ERROR_OS_UNSUPPORTED(ERROR_BASE_SYSTEM.code()+0x0003),
    ERROR_PLATFORM_UNSUPPORTED(ERROR_BASE_SYSTEM.code()+0x0004),

    ERROR_FUNCTION_PARAM(ERROR_BASE_FUNCTION.code()+0x0001),
    ERROR_FUNCTION_PARAM_NULL(ERROR_BASE_FUNCTION.code()+0x0002),

    ERROR_JNI_SEND_PLAYER_MEDIA_ERROR_EVENT(ERROR_BASE_JNI.code()+0x0001),
    ERROR_JNI_SEND_PLAYER_HALT_EVENT(ERROR_BASE_JNI.code()+0x0002),
    ERROR_JNI_SEND_PLAYER_STATE_EVENT(ERROR_BASE_JNI.code()+0x0003),
    ERROR_JNI_SEND_NEW_FRAME_EVENT(ERROR_BASE_JNI.code()+0x0004),
    ERROR_JNI_SEND_FRAME_SIZE_CHANGED_EVENT(ERROR_BASE_JNI.code()+0x0005),
    ERROR_JNI_SEND_END_OF_MEDIA_EVENT(ERROR_BASE_JNI.code()+0x0006),
    ERROR_JNI_SEND_AUDIO_TRACK_EVENT(ERROR_BASE_JNI.code()+0x0007),
    ERROR_JNI_SEND_VIDEO_TRACK_EVENT(ERROR_BASE_JNI.code()+0x0008),
    ERROR_JNI_SEND_METADATA_EVENT(ERROR_BASE_JNI.code()+0x0009),
    ERROR_JNI_SEND_MARKER_EVENT(ERROR_BASE_JNI.code()+0x000A),
    ERROR_JNI_SEND_BUFFER_PROGRESS_EVENT(ERROR_BASE_JNI.code()+0x000B),
    ERROR_JNI_SEND_STOP_REACHED_EVENT(ERROR_BASE_JNI.code()+0x000C),
    ERROR_JNI_SEND_DURATION_UPDATE_EVENT(ERROR_BASE_JNI.code()+0x000D),
    ERROR_JNI_SEND_AUDIO_SPECTRUM_EVENT(ERROR_BASE_JNI.code()+0x000E),

    ERROR_OSX_INIT(ERROR_BASE_OSX.code() + 0x0001),

    WARNING_JFXMEDIA_BALANCE(WARNING_BASE_JFXMEDIA.code() + 0x0001),

    WARNING_GSTREAMER_WARNING(WARNING_BASE_GSTREAMER.code()+0x0001),
    WARNING_GSTREAMER_PIPELINE_ERROR(WARNING_BASE_GSTREAMER.code()+0x0002),
    WARNING_GSTREAMER_PIPELINE_WARNING(WARNING_BASE_GSTREAMER.code()+0x0003),
    WARNING_GSTREAMER_PIPELINE_STATE_EVENT(WARNING_BASE_GSTREAMER.code()+0x0004),
    WARNING_GSTREAMER_PIPELINE_FRAME_SIZE(WARNING_BASE_GSTREAMER.code()+0x0005),
    WARNING_GSTREAMER_INVALID_FRAME(WARNING_BASE_GSTREAMER.code()+0x0006),
    WARNING_GSTREAMER_PIPELINE_INFO_ERROR(WARNING_BASE_GSTREAMER.code()+0x0007),
    WARNING_GSTREAMER_AUDIO_BUFFER_FIELD(WARNING_BASE_GSTREAMER.code()+0x0008);

    private static ResourceBundle bundle;
    private static final Map&lt;Integer, MediaError&gt; map = new HashMap&lt;Integer, MediaError&gt;();

    static {
        try {
            bundle = ResourceBundle.getBundle(&quot;MediaErrors&quot;, Locale.getDefault());
        } catch(MissingResourceException e) {
            bundle = null;
        }

        for (MediaError error : MediaError.values()) {
            map.put(error.code(), error);
        }
    }

    private int    code;
    private String description;

    private MediaError(int code) {
        this.code = code;
    }

    public int code() {
        return code;
    }

    public String description() {
        if (description == null) {
            String errorName = name();
            if (bundle != null) {
                try {
                    description = bundle.getString(errorName);
                } catch (MissingResourceException e) {
                    description = errorName;
                }
            } else {
                description = errorName;
            }
        }
        return description;
    }

    public static MediaError getFromCode(int code) {
        return map.get(code);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/webkit/graphics/WCMediaPlayer.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.webkit.graphics;

import com.sun.javafx.logging.PlatformLogger;
import com.sun.webkit.Invoker;

public abstract class WCMediaPlayer extends Ref {

    protected final static PlatformLogger log = PlatformLogger.getLogger(&quot;webkit.mediaplayer&quot;);

    // pointer to native Player object;
    // read the value only on FX event thread, check that it has non-zero value;
    // setters (ctor &amp;&amp; fwkDispose) are called on event thread.
    private long nPtr;

    protected WCMediaPlayer() {
    }

    void setNativePointer(long nativePointer) {
        if (nativePointer == 0) {
            throw new IllegalArgumentException(&quot;nativePointer is 0&quot;);
        }
        if (nPtr != 0) {
            throw new IllegalStateException(&quot;nPtr is not 0&quot;);
        }
        this.nPtr = nativePointer;
    }

    /**
     * Methods to implement
     */
    protected abstract void load(String url, String userAgent);
    protected abstract void cancelLoad();
    protected abstract void disposePlayer();

    protected abstract void prepareToPlay();
    protected abstract void play();
    protected abstract void pause();

    protected abstract float getCurrentTime();
    // the method _must_ call notifySeeking(true)/notifySeeking(false)
    protected abstract void seek(float time);
    protected abstract void setRate(float rate);
    protected abstract void setVolume(float volume);
    protected abstract void setMute(boolean mute);
    protected abstract void setSize(int w, int h);
    protected abstract void setPreservesPitch(boolean preserve);

    protected abstract void renderCurrentFrame(WCGraphicsContext gc, int x, int y, int w, int h);

    /**
     * Obtains current &quot;preserves pitch&quot; value.
     */
    protected boolean getPreservesPitch() {
        return preserve;
    }

    protected int getNetworkState() {
        return networkState;
    }

    protected int getReadyState() {
        return readyState;
    }

    protected int getPreload() {
        return preload;
    }

    protected boolean isPaused() {
        return paused;
    }

    protected boolean isSeeking() {
        return seeking;
    }


    /* ======================================= */
    /*  Methods to notify webkit about events  */
    /* ======================================= */
    //enum NetworkState { Empty, Idle, Loading, Loaded, FormatError, NetworkError, DecodeError };
    protected final static int NETWORK_STATE_EMPTY              = 0;
    protected final static int NETWORK_STATE_IDLE               = 1;
    protected final static int NETWORK_STATE_LOADING            = 2;
    protected final static int NETWORK_STATE_LOADED             = 3;
    protected final static int NETWORK_STATE_FORMAT_ERROR       = 4;
    protected final static int NETWORK_STATE_NETWORK_ERROR      = 5;
    protected final static int NETWORK_STATE_DECODE_ERROR       = 6;
    //enum ReadyState  { HaveNothing, HaveMetadata, HaveCurrentData, HaveFutureData, HaveEnoughData };
    protected final static int READY_STATE_HAVE_NOTHING         = 0;
    protected final static int READY_STATE_HAVE_METADATA        = 1;
    protected final static int READY_STATE_HAVE_CURRENT_DATA    = 2;
    protected final static int READY_STATE_HAVE_FUTURE_DATA     = 3;
    protected final static int READY_STATE_HAVE_ENOUGH_DATA     = 4;
    //enum Preload { None, MetaData, Auto };
    protected final static int PRELOAD_NONE                     = 0;
    protected final static int PRELOAD_METADATA                 = 1;
    protected final static int PRELOAD_AUTO                     = 2;

    private int networkState = NETWORK_STATE_EMPTY;
    private int readyState = READY_STATE_HAVE_NOTHING;
    private int preload = PRELOAD_AUTO;
    private boolean paused = true;
    private boolean seeking = false;


    protected void notifyNetworkStateChanged(int networkState) {
        if (this.networkState != networkState) {
            this.networkState = networkState;
            final int _networkState = networkState;
            Invoker.getInvoker().invokeOnEventThread(() -&gt; {
                if (nPtr != 0) {
                    notifyNetworkStateChanged(nPtr, _networkState);
                }
            });
        }
    }

    protected void notifyReadyStateChanged(int readyState) {
        if (this.readyState != readyState) {
            this.readyState = readyState;
            final int _readyState = readyState;
            Invoker.getInvoker().invokeOnEventThread(() -&gt; {
                if (nPtr != 0) {
                    notifyReadyStateChanged(nPtr, _readyState);
                }
            });
        }
    }

    protected void notifyPaused(boolean paused) {
        log.fine(&quot;notifyPaused, {0} =&gt; {1}&quot;,
                new Object[]{Boolean.valueOf(this.paused), Boolean.valueOf(paused)});
        if (this.paused != paused) {
            this.paused = paused;
            final boolean _paused = paused;
            Invoker.getInvoker().invokeOnEventThread(() -&gt; {
                if (nPtr != 0) {
                    notifyPaused(nPtr, _paused);
                }
            });
        }
    }

    // pass -1 as readyState value if the state is not changed
    protected void notifySeeking(boolean seeking, int readyState) {
        log.fine(&quot;notifySeeking, {0} =&gt; {1}&quot;,
                new Object[]{Boolean.valueOf(this.seeking), Boolean.valueOf(seeking)});
        if (this.seeking != seeking || this.readyState != readyState) {
            this.seeking = seeking;
            this.readyState = readyState;
            final boolean _seeking = seeking;
            final int _readyState = readyState;
            Invoker.getInvoker().invokeOnEventThread(() -&gt; {
                if (nPtr != 0) {
                    notifySeeking(nPtr, _seeking, _readyState);
                }
            });
        }
    }

    protected void notifyFinished() {
        Invoker.getInvoker().invokeOnEventThread(() -&gt; {
            if (nPtr != 0) {
                notifyFinished(nPtr);
            }
        });
    }

    /** got metadata */
    protected void notifyReady(boolean hasVideo, boolean hasAudio, float duration) {
        final boolean _hasVideo = hasVideo;
        final boolean _hasAudio = hasAudio;
        final float _duration = duration;
        Invoker.getInvoker().invokeOnEventThread(() -&gt; {
            if (nPtr != 0) {
                notifyReady(nPtr, _hasVideo, _hasAudio, _duration);
            }
        });
    }

    protected void notifyDurationChanged(float newDuration) {
        final float _newDuration = newDuration;
        Invoker.getInvoker().invokeOnEventThread(() -&gt; {
            if (nPtr != 0) {
                notifyDurationChanged(nPtr, _newDuration);
            }
        });
    }

    protected void notifySizeChanged(int width, int height) {
        // notify on event thread to ensure native object is valid (nPtr != 0)
        final int _width = width;
        final int _height = height;
        Invoker.getInvoker().invokeOnEventThread(() -&gt; {
            if (nPtr != 0) {
                notifySizeChanged(nPtr, _width, _height);
            }
        });
    }

    private Runnable newFrameNotifier = () -&gt; {
        if (nPtr != 0) {
            notifyNewFrame(nPtr);
        }
    };

    protected void notifyNewFrame() {
        Invoker.getInvoker().invokeOnEventThread(newFrameNotifier);
    }

    /** {@code ranges} array contains pairs [start,end] of the buffered times */
    protected void notifyBufferChanged(float[] ranges, int bytesLoaded) {
        // notify on event thread to ensure native object is valid (nPtr != 0)
        final float[] _ranges = ranges;
        final int _bytesLoaded = bytesLoaded;
        Invoker.getInvoker().invokeOnEventThread(() -&gt; {
            if (nPtr != 0) {
                notifyBufferChanged(nPtr, _ranges, _bytesLoaded);
            }
        });
    }


    /* ======================================= */
    /*  Methods called from webkit             */
    /* ======================================= */

    private void fwkLoad(String url, String userAgent) {
        log.fine(&quot;fwkLoad, url={0}, userAgent={1}&quot;, new Object[] {url, userAgent});
        load(url, userAgent);
    }

    private void fwkCancelLoad() {
        log.fine(&quot;fwkCancelLoad&quot;);
        cancelLoad();
<A NAME="27"></A>    }

    private void fwkPrepareToPlay() {
        <FONT color="#e77471"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#27',2,'match49-top.html#27',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>log.fine(&quot;fwkPrepareToPlay&quot;);
        prepareToPlay();
    }

    private void fwkDispose() {
        log.fine(&quot;fwkDispose&quot;);
        nPtr = 0;
        cancelLoad();
        disposePlayer</B></FONT>();
    }

    private void fwkPlay() {
        log.fine(&quot;fwkPlay&quot;);
        play();
    }

    private void fwkPause() {
        log.fine(&quot;fwkPause&quot;);
        pause();
    }

    private float fwkGetCurrentTime() {
        float res = getCurrentTime();
        log.finer(&quot;fwkGetCurrentTime(), return {0}&quot;, res);
        return res;
    }

    private void fwkSeek(float time) {
        log.fine(&quot;fwkSeek({0})&quot;, time);
        seek(time);
    }

    private void fwkSetRate(float rate) {
        log.fine(&quot;fwkSetRate({0})&quot;, rate);
        setRate(rate);
    }

    private void fwkSetVolume(float volume) {
        log.fine(&quot;fwkSetVolume({0})&quot;, volume);
        setVolume(volume);
    }

    private void fwkSetMute(boolean mute) {
        log.fine(&quot;fwkSetMute({0})&quot;, mute);
        setMute(mute);
    }

    private void fwkSetSize(int w, int h) {
        //log.fine(&quot;setSize({0} x {1})&quot;, new Object[]{w, h});
        setSize(w, h);
    }

    private boolean preserve = true;

    private void fwkSetPreservesPitch(boolean preserve) {
        log.fine(&quot;setPreservesPitch({0})&quot;, preserve);
//        synchronized(renderLock) {
            this.preserve = preserve;
            setPreservesPitch(preserve);
//        }
    }

    private void fwkSetPreload(int preload) {
        log.fine(&quot;fwkSetPreload({0})&quot;,
                preload == PRELOAD_NONE ? &quot;PRELOAD_NONE&quot;
                : preload == PRELOAD_METADATA ? &quot;PRELOAD_METADATA&quot;
                : preload == PRELOAD_AUTO ? &quot;PRELOAD_AUTO&quot;
                : (&quot;INVALID VALUE: &quot; + preload));
        this.preload = preload;
    }

    /* called from GraphicsDecoder */
    void render(WCGraphicsContext gc, int x, int y, int w, int h) {
        log.finer(&quot;render(x={0}, y={1}, w={2}, h={3}&quot;, new Object[]{x, y, w, h});
        renderCurrentFrame(gc, x, y, w, h);
    }


    /* native methods */
    private native void notifyNetworkStateChanged(long nPtr, int networkState);
    private native void notifyReadyStateChanged(long nPtr, int readyState);
    private native void notifyPaused(long nPtr, boolean paused);
    private native void notifySeeking(long nPtr, boolean seeking, int readyState);
    private native void notifyFinished(long nPtr);
    private native void notifyReady(long nPtr, boolean hasVideo, boolean hasAudio, float duration);
    private native void notifyDurationChanged(long nPtr, float duration);
    private native void notifySizeChanged(long nPtr, int width, int height);
    private native void notifyNewFrame(long nPtr);
    private native void notifyBufferChanged(long nPtr, float[] ranges, int bytesLoaded);

}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/com/sun/webkit/network/SocketStreamHandle.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.webkit.network;

import com.sun.javafx.logging.PlatformLogger;
import com.sun.javafx.logging.PlatformLogger.Level;
import com.sun.webkit.Invoker;
import com.sun.webkit.WebPage;
import java.io.IOException;
import java.io.InputStream;
import static java.lang.String.format;
import java.net.ConnectException;
import java.net.InetSocketAddress;
import java.net.NoRouteToHostException;
import java.net.PortUnreachableException;
import java.net.Proxy;
import java.net.ProxySelector;
import java.net.Socket;
import java.net.SocketException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.UnknownHostException;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.List;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Pattern;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLSocket;

final class SocketStreamHandle {
    private static final Pattern FIRST_LINE_PATTERN = Pattern.compile(
            &quot;^HTTP/1.[01]\\s+(\\d{3})(?:\\s.*)?$&quot;);
    private static final PlatformLogger logger = PlatformLogger.getLogger(
            SocketStreamHandle.class.getName());
    private static final ThreadPoolExecutor threadPool = new ThreadPoolExecutor(
            0, Integer.MAX_VALUE,
            10, TimeUnit.SECONDS,
            new SynchronousQueue&lt;Runnable&gt;(),
            new CustomThreadFactory());

    private enum State {ACTIVE, CLOSE_REQUESTED, DISPOSED}

    private final String host;
    private final int port;
    private final boolean ssl;
    private final WebPage webPage;
    private final long data;
    private volatile Socket socket;
    private volatile State state = State.ACTIVE;
    private volatile boolean connected;

    private SocketStreamHandle(String host, int port, boolean ssl,
                               WebPage webPage, long data)
    {
        this.host = host;
        this.port = port;
        this.ssl = ssl;
        this.webPage = webPage;
        this.data = data;
    }

    private static SocketStreamHandle fwkCreate(String host, int port,
                                                boolean ssl, WebPage webPage,
                                                long data)
    {
        final SocketStreamHandle ssh =
                new SocketStreamHandle(host, port, ssl, webPage, data);
        logger.finest(&quot;Starting {0}&quot;, ssh);
        threadPool.submit(() -&gt; {
            ssh.run();
        });
        return ssh;
    }

    private void run() {
        if (webPage == null) {
            logger.finest(&quot;{0} is not associated with any web &quot;
                    + &quot;page, aborted&quot;, this);
            // In theory we could pump this error through the doRun()'s
            // error handling code but in that case that error handling
            // code would have to run outside the doPrivileged block,
            // which is something we want to avoid.
            didFail(0, &quot;Web socket is not associated with any web page&quot;);
            didClose();
            return;
        }
        AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
            doRun();
            return null;
        }, webPage.getAccessControlContext());
    }

    private void doRun() {
        Throwable error = null;
        String errorDescription = null;
        try {
            logger.finest(&quot;{0} started&quot;, this);
            connect();
            connected = true;
            logger.finest(&quot;{0} connected&quot;, this);
            didOpen();
            InputStream is = socket.getInputStream();
            while (true) {
                byte[] buffer = new byte[8192];
                int n = is.read(buffer);
                if(n &gt; 0) {
                    if (logger.isLoggable(Level.FINEST)) {
                        logger.finest(format(&quot;%s received len: [%d], data:%s&quot;,
                                this, n, dump(buffer, n)));
                    }
                    didReceiveData(buffer, n);
                } else {
                    logger.finest(&quot;{0} connection closed by remote host&quot;, this);
                    break;
                }
            }
        } catch (UnknownHostException ex) {
            error = ex;
            errorDescription = &quot;Unknown host&quot;;
        } catch (ConnectException ex) {
            error = ex;
            errorDescription = &quot;Unable to connect&quot;;
        } catch (NoRouteToHostException ex) {
            error = ex;
            errorDescription = &quot;No route to host&quot;;
        } catch (PortUnreachableException ex) {
            error = ex;
            errorDescription = &quot;Port unreachable&quot;;
        } catch (SocketException ex) {
            if (state != State.ACTIVE) {
                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(format(&quot;%s exception (most &quot;
                            + &quot;likely caused by local close)&quot;, this), ex);
                }
            } else {
                error = ex;
                errorDescription = &quot;Socket error&quot;;
            }
        } catch (SSLException ex) {
            error = ex;
            errorDescription = &quot;SSL error&quot;;
        } catch (IOException ex) {
            error = ex;
            errorDescription = &quot;I/O error&quot;;
        } catch (SecurityException ex) {
            error = ex;
            errorDescription = &quot;Security error&quot;;
        } catch (Throwable th) {
            error = th;
        }

        if (error != null) {
            if (errorDescription == null) {
                errorDescription = &quot;Unknown error&quot;;
                logger.warning(format(&quot;%s unexpected error&quot;, this), error);
            } else {
                logger.finest(format(&quot;%s exception&quot;, this), error);
            }
            didFail(0, errorDescription);
        }

        try {
            socket.close();
        } catch (IOException ignore) {}
        didClose();

        logger.finest(&quot;{0} finished&quot;, this);
    }

    private void connect() throws IOException {
        SecurityManager securityManager = System.getSecurityManager();
        if (securityManager != null) {
            securityManager.checkConnect(host, port);
        }

        // The proxy trial logic here is meant to mimic
        // sun.net.www.protocol.http.HttpURLConnection.plainConnect
        boolean success = false;
        IOException lastException = null;
        boolean triedDirectConnection = false;
        ProxySelector proxySelector = AccessController.doPrivileged(
                (PrivilegedAction&lt;ProxySelector&gt;) () -&gt; ProxySelector.getDefault());
        if (proxySelector != null) {
            URI uri;
            try {
                uri = new URI((ssl ? &quot;https&quot; : &quot;http&quot;) + &quot;://&quot; + host);
            } catch (URISyntaxException ex) {
                throw new IOException(ex);
            }
            if (logger.isLoggable(Level.FINEST)) {
                logger.finest(format(&quot;%s selecting proxies for: [%s]&quot;, this, uri));
            }
            List&lt;Proxy&gt; proxies = proxySelector.select(uri);
            if (logger.isLoggable(Level.FINEST)) {
                logger.finest(format(&quot;%s selected proxies: %s&quot;, this, proxies));
            }
            for (Proxy proxy : proxies) {
                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(format(&quot;%s trying proxy: [%s]&quot;, this, proxy));
                }
                if (proxy.type() == Proxy.Type.DIRECT) {
                    triedDirectConnection = true;
                }
                try {
                    connect(proxy);
                    success = true;
                    break;
                } catch (IOException ex) {
                    logger.finest(format(&quot;%s exception&quot;, this), ex);
                    lastException = ex;
                    if (proxy.address() != null) {
                        proxySelector.connectFailed(uri, proxy.address(), ex);
                    }
                    continue;
                }
            }
        }
        if (!success &amp;&amp; !triedDirectConnection) {
            logger.finest(&quot;{0} trying direct connection&quot;, this);
            connect(Proxy.NO_PROXY);
            success = true;
        }
        if (!success) {
            throw lastException;
        }
    }

    private void connect(Proxy proxy) throws IOException {
        synchronized (this) {
            if (state != State.ACTIVE) {
                throw new SocketException(&quot;Close requested&quot;);
            }
            socket = new Socket(proxy);
        }
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(format(&quot;%s connecting to: [%s:%d]&quot;,
                    this, host, port));
        }
        socket.connect(new InetSocketAddress(host, port));
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(format(&quot;%s connected to: [%s:%d]&quot;,
                    this, host, port));
        }
        if (ssl) {
            synchronized (this) {
                if (state != State.ACTIVE) {
                    throw new SocketException(&quot;Close requested&quot;);
                }
                logger.finest(&quot;{0} starting SSL handshake&quot;, this);
                socket = HttpsURLConnection.getDefaultSSLSocketFactory()
                        .createSocket(socket, host, port, true);
            }
            ((SSLSocket) socket).startHandshake();
        }
    }

    private int fwkSend(byte[] buffer) {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(format(&quot;%s sending len: [%d], data:%s&quot;,
                    this, buffer.length, dump(buffer, buffer.length)));
        }
        if (connected) {
            try {
                socket.getOutputStream().write(buffer);
                return buffer.length;
            } catch (IOException ex) {
                logger.finest(format(&quot;%s exception&quot;, this), ex);
                didFail(0, &quot;I/O error&quot;);
                return 0;
            }
        } else {
            logger.finest(&quot;{0} not connected&quot;, this);
            didFail(0, &quot;Not connected&quot;);
            return 0;
        }
    }

    private void fwkClose() {
        synchronized (this) {
            logger.finest(&quot;{0}&quot;, this);
            state = State.CLOSE_REQUESTED;
            try {
                if (socket != null) {
                    socket.close();
                }
            } catch (IOException ignore) {}
        }
    }

    private void fwkNotifyDisposed() {
        logger.finest(&quot;{0}&quot;, this);
        state = State.DISPOSED;
    }

    private void didOpen() {
        Invoker.getInvoker().postOnEventThread(() -&gt; {
            if (state == State.ACTIVE) {
                notifyDidOpen();
            }
        });
    }

    private void didReceiveData(final byte[] buffer, final int len) {
        Invoker.getInvoker().postOnEventThread(() -&gt; {
            if (state == State.ACTIVE) {
                notifyDidReceiveData(buffer, len);
            }
        });
    }
<A NAME="25"></A>
    private void didFail(final int errorCode, final String errorDescription) {
        Invoker.getInvoker().postOnEventThread(() -&gt; {
            <FONT color="#87f717"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#25',2,'match49-top.html#25',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (state == State.ACTIVE) {
                notifyDidFail(errorCode, errorDescription);
            }
        });
    }

    private void didClose() {
        Invoker.getInvoker</B></FONT>().postOnEventThread(() -&gt; {
            if (state != State.DISPOSED) {
                notifyDidClose();
            }
        });
    }

    private void notifyDidOpen() {
        logger.finest(&quot;{0}&quot;, this);
        twkDidOpen(data);
    }

    private void notifyDidReceiveData(byte[] buffer, int len) {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(format(&quot;%s, len: [%d], data:%s&quot;,
                    this, len, dump(buffer, len)));
        }
        twkDidReceiveData(buffer, len, data);
    }

    private void notifyDidFail(int errorCode, String errorDescription) {
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(format(&quot;%s, errorCode: %d, &quot;
                    + &quot;errorDescription: %s&quot;,
                    this, errorCode, errorDescription));
        }
        twkDidFail(errorCode, errorDescription, data);
    }

    private void notifyDidClose() {
        logger.finest(&quot;{0}&quot;, this);
        twkDidClose(data);
    }

    private static native void twkDidOpen(long data);
    private static native void twkDidReceiveData(byte[] buffer, int len,
                                                 long data);
    private static native void twkDidFail(int errorCode,
                                          String errorDescription, long data);
    private static native void twkDidClose(long data);

    private static String dump(byte[] buffer, int len) {
        StringBuilder sb = new StringBuilder();
        int i = 0;
        while (i &lt; len) {
            StringBuilder c1 = new StringBuilder();
            StringBuilder c2 = new StringBuilder();
            for (int k = 0; k &lt; 16; k++, i++) {
                if (i &lt; len) {
                    int b = buffer[i] &amp; 0xff;
                    c1.append(format(&quot;%02x &quot;, b));
                    c2.append((b &gt;= 0x20 &amp;&amp; b &lt;= 0x7e) ? (char) b : '.');
                } else {
                    c1.append(&quot;   &quot;);
                }
            }
            sb.append(format(&quot;%n  &quot;)).append(c1).append(' ').append(c2);
        }
        return sb.toString();
    }

    @Override
    public String toString() {
        return format(&quot;SocketStreamHandle{host=%s, port=%d, ssl=%s, &quot;
                + &quot;data=0x%016X, state=%s, connected=%s}&quot;,
                host, port, ssl, data, state, connected);
    }

    private static final class CustomThreadFactory implements ThreadFactory {
        private final ThreadGroup group;
        private final AtomicInteger index = new AtomicInteger(1);

        private CustomThreadFactory() {
            SecurityManager sm = System.getSecurityManager();
            group = (sm != null) ? sm.getThreadGroup()
                    : Thread.currentThread().getThreadGroup();
        }

        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(group, r, &quot;SocketStreamHandle-&quot;
                    + index.getAndIncrement());
            t.setDaemon(true);
            if (t.getPriority() != Thread.NORM_PRIORITY) {
                t.setPriority(Thread.NORM_PRIORITY);
            }
            return t;
        }
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/javafx-sdk-11.0.2/lib/src/javafx.web/javafx/scene/web/WebView.java</CENTER></H3><HR>
<PRE>
/*
 * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javafx.scene.web;

import com.sun.java.scene.web.WebViewHelper;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyDoubleProperty;
import javafx.beans.property.ReadOnlyDoubleWrapper;
import javafx.collections.ObservableList;
import javafx.css.CssMetaData;
import javafx.css.Styleable;
import javafx.css.StyleableBooleanProperty;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableObjectProperty;
import javafx.css.StyleableProperty;
import javafx.event.EventHandler;
import javafx.event.EventType;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Point2D;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.input.DataFormat;
import javafx.scene.input.DragEvent;
import javafx.scene.input.Dragboard;
import javafx.scene.input.InputMethodEvent;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.input.TransferMode;
import javafx.scene.text.FontSmoothingType;
import javafx.stage.Stage;
import javafx.stage.Window;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import javafx.css.converter.BooleanConverter;
import javafx.css.converter.EnumConverter;
import javafx.css.converter.SizeConverter;
import com.sun.javafx.geom.BaseBounds;
import com.sun.javafx.geom.PickRay;
import com.sun.javafx.geom.transform.BaseTransform;
import com.sun.javafx.scene.DirtyBits;
import com.sun.javafx.scene.NodeHelper;
import com.sun.javafx.scene.SceneHelper;
import com.sun.javafx.scene.input.PickResultChooser;
import com.sun.javafx.sg.prism.NGNode;
import com.sun.javafx.sg.prism.web.NGWebView;
import com.sun.javafx.tk.TKPulseListener;
import com.sun.javafx.tk.Toolkit;
import com.sun.javafx.webkit.InputMethodClientImpl;
import com.sun.javafx.webkit.KeyCodeMap;
import com.sun.webkit.WebPage;
import com.sun.webkit.event.WCFocusEvent;
import com.sun.webkit.event.WCInputMethodEvent;
import com.sun.webkit.event.WCKeyEvent;
import com.sun.webkit.event.WCMouseEvent;
import com.sun.webkit.event.WCMouseWheelEvent;

/**
 * {@code WebView} is a {@link javafx.scene.Node} that manages a
 * {@link WebEngine} and displays its content. The associated {@code WebEngine}
 * is created automatically at construction time and cannot be changed
 * afterwards. {@code WebView} handles mouse and some keyboard events, and
 * manages scrolling automatically, so there's no need to put it into a
 * {@code ScrollPane}.
 *
 * &lt;p&gt;{@code WebView} objects must be created and accessed solely from the
 * FX thread.
 * @since JavaFX 2.0
 */
final public class WebView extends Parent {

    private static final Map&lt;Object, Integer&gt; idMap = new HashMap&lt;Object, Integer&gt;();

    private static final boolean DEFAULT_CONTEXT_MENU_ENABLED = true;
    private static final FontSmoothingType DEFAULT_FONT_SMOOTHING_TYPE = FontSmoothingType.LCD;
    private static final double DEFAULT_ZOOM = 1.0;
    private static final double DEFAULT_FONT_SCALE = 1.0;
    private static final double DEFAULT_MIN_WIDTH = 0;
    private static final double DEFAULT_MIN_HEIGHT = 0;
    private static final double DEFAULT_PREF_WIDTH = 800;
    private static final double DEFAULT_PREF_HEIGHT = 600;
    private static final double DEFAULT_MAX_WIDTH = Double.MAX_VALUE;
    private static final double DEFAULT_MAX_HEIGHT = Double.MAX_VALUE;

    private final WebPage page;
    private final WebEngine engine;
    private volatile InputMethodClientImpl imClient;

    /**
     * The stage pulse listener registered with the toolkit.
     * This field guarantees that the listener will exist throughout
     * the whole lifetime of the WebView node. This field is necessary
     * because the toolkit references its stage pulse listeners weakly.
     */
    private final TKPulseListener stagePulseListener;

    /**
     * Returns the {@code WebEngine} object.
     * @return the WebEngine
     */
    public final WebEngine getEngine() {
        return engine;
    }

    private final ReadOnlyDoubleWrapper width = new ReadOnlyDoubleWrapper(this, &quot;width&quot;);

    public final double getWidth() {
        return width.get();
    }

    /**
     * Width of this {@code WebView}.
     * @return the width property
     */
    public ReadOnlyDoubleProperty widthProperty() {
        return width.getReadOnlyProperty();
    }

    private final ReadOnlyDoubleWrapper height = new ReadOnlyDoubleWrapper(this, &quot;height&quot;);

    public final double getHeight() {
        return height.get();
    }

    /**
     * Height of this {@code WebView}.
     * @return the height property
     */
    public ReadOnlyDoubleProperty heightProperty() {
        return height.getReadOnlyProperty();
    }

    /*
     * Zoom factor applied to the entire page contents.
     */
    private DoubleProperty zoom;

    public final void setZoom(double value) {
        WebEngine.checkThread();
        zoomProperty().set(value);
    }

    public final double getZoom() {
        return (this.zoom != null)
                ? this.zoom.get()
                : DEFAULT_ZOOM;
    }

    /**
     * The current zoom factor applied to the entire page contents.
     *
     * @return the zoom property
     * @defaultValue 1.0
     *
     * @since JavaFX 8.0
     */
    public final DoubleProperty zoomProperty() {
        if (zoom == null) {
            zoom = new StyleableDoubleProperty(DEFAULT_ZOOM) {
                @Override public void invalidated() {
                    Toolkit.getToolkit().checkFxUserThread();
                    page.setZoomFactor((float) get(), false);
                }

                @Override public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
                    return StyleableProperties.ZOOM;
                }
                @Override public Object getBean() {
                    return WebView.this;
                }
                @Override public String getName() {
                    return &quot;zoom&quot;;
                }
            };
        }
        return zoom;
    }

    /**
     * Specifies scale factor applied to font. This setting affects
     * text content but not images and fixed size elements.
     *
     * @defaultValue 1.0
     */
    private DoubleProperty fontScale;

    public final void setFontScale(double value) {
        WebEngine.checkThread();
        fontScaleProperty().set(value);
    }

    public final double getFontScale() {
        return (this.fontScale != null)
                ? this.fontScale.get()
                : DEFAULT_FONT_SCALE;
    }

    public DoubleProperty fontScaleProperty() {
        if (fontScale == null) {
            fontScale = new StyleableDoubleProperty(DEFAULT_FONT_SCALE) {
                @Override public void invalidated() {
                    Toolkit.getToolkit().checkFxUserThread();
                    page.setZoomFactor((float)get(), true);
                }
                @Override public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
                    return StyleableProperties.FONT_SCALE;
                }
                @Override public Object getBean() {
                    return WebView.this;
                }
                @Override public String getName() {
                    return &quot;fontScale&quot;;
                }
            };
        }
        return fontScale;
    }

    {
        // To initialize the class helper at the begining each constructor of this class
        WebViewHelper.initHelper(this);
    }
    /**
     * Creates a {@code WebView} object.
     */
    public WebView() {
        setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
        getStyleClass().add(&quot;web-view&quot;);
        engine = new WebEngine();
        engine.setView(this);
        page = engine.getPage();
        page.setFontSmoothingType(DEFAULT_FONT_SMOOTHING_TYPE.ordinal());

        registerEventHandlers();
        stagePulseListener = () -&gt; {
            handleStagePulse();
        };
        focusedProperty().addListener((ov, t, t1) -&gt; {
            if (page != null) {
                // Traversal direction is not currently available in FX.
                WCFocusEvent focusEvent = new WCFocusEvent(
                    isFocused() ? WCFocusEvent.FOCUS_GAINED
                            : WCFocusEvent.FOCUS_LOST,
                WCFocusEvent.UNKNOWN);
                page.dispatchFocusEvent(focusEvent);
            }
        });
        setFocusTraversable(true);
        Toolkit.getToolkit().addStageTkPulseListener(stagePulseListener);
    }

    // Resizing support. Allows arbitrary growing and shrinking.
    // Designed after javafx.scene.control.Control

    @Override public boolean isResizable() {
        return true;
    }

    @Override public void resize(double width, double height) {
        if ((width != this.width.get()) || (height != this.height.get())) {
            this.width.set(width);
            this.height.set(height);
            NodeHelper.markDirty(this, DirtyBits.NODE_GEOMETRY);
            NodeHelper.geomChanged(this);
        }
    }

    /**
     * Called during layout to determine the minimum width for this node.
     *
     * @return the minimum width that this node should be resized to during layout
     */
    @Override public final double minWidth(double height) {
        final double result = getMinWidth();
        return Double.isNaN(result) || result &lt; 0 ? 0 : result;
    }

    /**
     * Called during layout to determine the minimum height for this node.
     *
     * @return the minimum height that this node should be resized to during layout
     */
    @Override public final double minHeight(double width) {
        final double result = getMinHeight();
        return Double.isNaN(result) || result &lt; 0 ? 0 : result;
    }


    /**
     * Called during layout to determine the preferred width for this node.
     *
     * @return the preferred width that this node should be resized to during layout
     */
    @Override public final double prefWidth(double height) {
        final double result = getPrefWidth();
        return Double.isNaN(result) || result &lt; 0 ? 0 : result;
    }

    /**
     * Called during layout to determine the preferred height for this node.
     *
     * @return the preferred height that this node should be resized to during layout
     */
    @Override public final double prefHeight(double width) {
        final double result = getPrefHeight();
        return Double.isNaN(result) || result &lt; 0 ? 0 : result;
    }
    /**
     * Called during layout to determine the maximum width for this node.
     *
     * @return the maximum width that this node should be resized to during layout
     */
    @Override public final double maxWidth(double height) {
        final double result = getMaxWidth();
        return Double.isNaN(result) || result &lt; 0 ? 0 : result;
    }

    /**
     * Called during layout to determine the maximum height for this node.
     *
     * @return the maximum height that this node should be resized to during layout
     */
    @Override public final double maxHeight(double width) {
        final double result = getMaxHeight();
        return Double.isNaN(result) || result &lt; 0 ? 0 : result;
    }

    /**
     * Minimum width property.
     * @return the minWidth property
     */
    public DoubleProperty minWidthProperty() {
        if (minWidth == null) {
            minWidth = new StyleableDoubleProperty(DEFAULT_MIN_WIDTH) {
                @Override
                public void invalidated() {
                    if (getParent() != null) {
                        getParent().requestLayout();
                    }
                }
                @Override
                public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
                    return StyleableProperties.MIN_WIDTH;
                }
                @Override
                public Object getBean() {
                    return WebView.this;
                }
                @Override
                public String getName() {
                    return &quot;minWidth&quot;;
                }
            };
        }
        return minWidth;
    }
    private DoubleProperty minWidth;

    public final void setMinWidth(double value) {
        minWidthProperty().set(value);
    }

    public final double getMinWidth() {
        return (this.minWidth != null)
                ? this.minWidth.get()
                : DEFAULT_MIN_WIDTH;
    }

    /**
     * Minimum height property.
     * @return the minHeight property
     */
    public DoubleProperty minHeightProperty() {
        if (minHeight == null) {
            minHeight = new StyleableDoubleProperty(DEFAULT_MIN_HEIGHT) {
                @Override
                public void invalidated() {
                    if (getParent() != null) {
                        getParent().requestLayout();
                    }
                }
                @Override
                public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
                    return StyleableProperties.MIN_HEIGHT;
                }
                @Override
                public Object getBean() {
                    return WebView.this;
                }
                @Override
                public String getName() {
                    return &quot;minHeight&quot;;
                }
            };
        }
        return minHeight;
    }
    private DoubleProperty minHeight;

    public final void setMinHeight(double value) {
        minHeightProperty().set(value);
    }

    public final double getMinHeight() {
        return (this.minHeight != null)
                ? this.minHeight.get()
                : DEFAULT_MIN_HEIGHT;
    }

    /**
     * Convenience method for setting minimum width and height.
     * @param minWidth the minimum width
     * @param minHeight the minimum height
     */
    public void setMinSize(double minWidth, double minHeight) {
        setMinWidth(minWidth);
        setMinHeight(minHeight);
    }

    /**
     * Preferred width property.
     * @return the prefWidth property
     */
    public DoubleProperty prefWidthProperty() {
        if (prefWidth == null) {
            prefWidth = new StyleableDoubleProperty(DEFAULT_PREF_WIDTH) {
                @Override
                public void invalidated() {
                    if (getParent() != null) {
                        getParent().requestLayout();
                    }
                }
                @Override
                public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
                    return StyleableProperties.PREF_WIDTH;
                }
                @Override
                public Object getBean() {
                    return WebView.this;
                }
                @Override
                public String getName() {
                    return &quot;prefWidth&quot;;
                }
            };
        }
        return prefWidth;
    }
    private DoubleProperty prefWidth;

    public final void setPrefWidth(double value) {
        prefWidthProperty().set(value);
    }

    public final double getPrefWidth() {
        return (this.prefWidth != null)
                ? this.prefWidth.get()
                : DEFAULT_PREF_WIDTH;
    }

    /**
     * Preferred height property.
     * @return the prefHeight property
     */
    public DoubleProperty prefHeightProperty() {
        if (prefHeight == null) {
            prefHeight = new StyleableDoubleProperty(DEFAULT_PREF_HEIGHT) {
                @Override
                public void invalidated() {
                    if (getParent() != null) {
                        getParent().requestLayout();
                    }
                }
                @Override
                public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
                    return StyleableProperties.PREF_HEIGHT;
                }
                @Override
                public Object getBean() {
                    return WebView.this;
                }
                @Override
                public String getName() {
                    return &quot;prefHeight&quot;;
                }
            };
        }
        return prefHeight;
    }
    private DoubleProperty prefHeight;

    public final void setPrefHeight(double value) {
        prefHeightProperty().set(value);
    }

    public final double getPrefHeight() {
        return (this.prefHeight != null)
                ? this.prefHeight.get()
                : DEFAULT_PREF_HEIGHT;
    }

    /**
     * Convenience method for setting preferred width and height.
     * @param prefWidth the preferred width
     * @param prefHeight the preferred height
     */
    public void setPrefSize(double prefWidth, double prefHeight) {
        setPrefWidth(prefWidth);
        setPrefHeight(prefHeight);
    }

    /**
     * Maximum width property.
     * @return the maxWidth property
     */
    public DoubleProperty maxWidthProperty() {
        if (maxWidth == null) {
            maxWidth = new StyleableDoubleProperty(DEFAULT_MAX_WIDTH) {
                @Override
                public void invalidated() {
                    if (getParent() != null) {
                        getParent().requestLayout();
                    }
                }
                @Override
                public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
                    return StyleableProperties.MAX_WIDTH;
                }
                @Override
                public Object getBean() {
                    return WebView.this;
                }
                @Override
                public String getName() {
                    return &quot;maxWidth&quot;;
                }
            };
        }
        return maxWidth;
    }
    private DoubleProperty maxWidth;

    public final void setMaxWidth(double value) {
        maxWidthProperty().set(value);
    }

    public final double getMaxWidth() {
        return (this.maxWidth != null)
                ? this.maxWidth.get()
                : DEFAULT_MAX_WIDTH;
    }

    /**
     * Maximum height property.
     * @return the maxHeight property
     */
    public DoubleProperty maxHeightProperty() {
        if (maxHeight == null) {
            maxHeight = new StyleableDoubleProperty(DEFAULT_MAX_HEIGHT) {
                @Override
                public void invalidated() {
                    if (getParent() != null) {
                        getParent().requestLayout();
                    }
                }
                @Override
                public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
                    return StyleableProperties.MAX_HEIGHT;
                }
                @Override
                public Object getBean() {
                    return WebView.this;
                }
                @Override
                public String getName() {
                    return &quot;maxHeight&quot;;
                }
            };
        }
        return maxHeight;
    }
    private DoubleProperty maxHeight;

    public final void setMaxHeight(double value) {
        maxHeightProperty().set(value);
    }

    public final double getMaxHeight() {
        return (this.maxHeight != null)
                ? this.maxHeight.get()
                : DEFAULT_MAX_HEIGHT;
    }

    /**
     * Convenience method for setting maximum width and height.
     * @param maxWidth the maximum width
     * @param maxHeight the maximum height
     */
    public void setMaxSize(double maxWidth, double maxHeight) {
        setMaxWidth(maxWidth);
        setMaxHeight(maxHeight);
    }


    /**
     * Specifies a requested font smoothing type : gray or LCD.
     *
     * The width of the bounding box is defined by the widest row.
     *
     * Note: LCD mode doesn't apply in numerous cases, such as various
     * compositing modes, where effects are applied and very large glyphs.
     *
     * @defaultValue FontSmoothingType.LCD
     * @since JavaFX 2.2
     */
    private ObjectProperty&lt;FontSmoothingType&gt; fontSmoothingType;

    public final void setFontSmoothingType(FontSmoothingType value) {
        fontSmoothingTypeProperty().set(value);
    }

    public final FontSmoothingType getFontSmoothingType() {
        return (this.fontSmoothingType != null)
                ? this.fontSmoothingType.get()
                : DEFAULT_FONT_SMOOTHING_TYPE;
    }

    public final ObjectProperty&lt;FontSmoothingType&gt; fontSmoothingTypeProperty() {
        if (this.fontSmoothingType == null) {
            this.fontSmoothingType = new StyleableObjectProperty&lt;FontSmoothingType&gt;(DEFAULT_FONT_SMOOTHING_TYPE) {
                @Override
                public void invalidated() {
                    Toolkit.getToolkit().checkFxUserThread();
                    page.setFontSmoothingType(get().ordinal());
                }
                @Override
                public CssMetaData&lt;WebView, FontSmoothingType&gt; getCssMetaData() {
                    return StyleableProperties.FONT_SMOOTHING_TYPE;
                }
                @Override
                public Object getBean() {
                    return WebView.this;
                }
                @Override
                public String getName() {
                    return &quot;fontSmoothingType&quot;;
                }
            };
        }
        return this.fontSmoothingType;
    }

    /**
     * Specifies whether context menu is enabled.
     *
     * @defaultValue true
     * @since JavaFX 2.2
     */
    private BooleanProperty contextMenuEnabled;

    public final void setContextMenuEnabled(boolean value) {
        contextMenuEnabledProperty().set(value);
    }

    public final boolean isContextMenuEnabled() {
        return contextMenuEnabled == null
                ? DEFAULT_CONTEXT_MENU_ENABLED
                : contextMenuEnabled.get();
    }

    public final BooleanProperty contextMenuEnabledProperty() {
        if (contextMenuEnabled == null) {
            contextMenuEnabled = new StyleableBooleanProperty(DEFAULT_CONTEXT_MENU_ENABLED) {
                @Override public void invalidated() {
                    Toolkit.getToolkit().checkFxUserThread();
                    page.setContextMenuEnabled(get());
                }

                @Override public CssMetaData&lt;WebView, Boolean&gt; getCssMetaData() {
                    return StyleableProperties.CONTEXT_MENU_ENABLED;
                }

                @Override public Object getBean() {
                    return WebView.this;
                }

                @Override public String getName() {
                    return &quot;contextMenuEnabled&quot;;
                }
            };
        }
        return contextMenuEnabled;
    }

    /**
     * Super-lazy instantiation pattern from Bill Pugh.
     */
    private static final class StyleableProperties {

        private static final CssMetaData&lt;WebView, Boolean&gt; CONTEXT_MENU_ENABLED
                = new CssMetaData&lt;WebView, Boolean&gt;(
                &quot;-fx-context-menu-enabled&quot;,
                BooleanConverter.getInstance(),
                DEFAULT_CONTEXT_MENU_ENABLED)
        {
            @Override public boolean isSettable(WebView view) {
                return view.contextMenuEnabled == null || !view.contextMenuEnabled.isBound();
            }
            @Override public StyleableProperty&lt;Boolean&gt; getStyleableProperty(WebView view) {
                return (StyleableProperty&lt;Boolean&gt;)view.contextMenuEnabledProperty();
            }
        };

        private static final CssMetaData&lt;WebView, FontSmoothingType&gt; FONT_SMOOTHING_TYPE
                = new CssMetaData&lt;WebView, FontSmoothingType&gt;(
                &quot;-fx-font-smoothing-type&quot;,
                new EnumConverter&lt;FontSmoothingType&gt;(FontSmoothingType.class),
                DEFAULT_FONT_SMOOTHING_TYPE) {
            @Override
            public boolean isSettable(WebView view) {
                return view.fontSmoothingType == null || !view.fontSmoothingType.isBound();
            }
            @Override
            public StyleableProperty&lt;FontSmoothingType&gt; getStyleableProperty(WebView view) {
                return (StyleableProperty&lt;FontSmoothingType&gt;)view.fontSmoothingTypeProperty();
            }
        };

        private static final CssMetaData&lt;WebView, Number&gt; ZOOM
                = new CssMetaData&lt;WebView, Number&gt;(
                &quot;-fx-zoom&quot;,
                SizeConverter.getInstance(),
                DEFAULT_ZOOM) {
            @Override public boolean isSettable(WebView view) {
                return view.zoom == null || !view.zoom.isBound();
            }
            @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
                return (StyleableProperty&lt;Number&gt;)view.zoomProperty();
            }
        };

        private static final CssMetaData&lt;WebView, Number&gt; FONT_SCALE
                = new CssMetaData&lt;WebView, Number&gt;(
                &quot;-fx-font-scale&quot;,
                SizeConverter.getInstance(),
                DEFAULT_FONT_SCALE) {
            @Override
            public boolean isSettable(WebView view) {
                return view.fontScale == null || !view.fontScale.isBound();
            }
            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
                return (StyleableProperty&lt;Number&gt;)view.fontScaleProperty();
            }
        };

        private static final CssMetaData&lt;WebView, Number&gt; MIN_WIDTH
                = new CssMetaData&lt;WebView, Number&gt;(
                &quot;-fx-min-width&quot;,
                SizeConverter.getInstance(),
                DEFAULT_MIN_WIDTH) {
            @Override
            public boolean isSettable(WebView view) {
                return view.minWidth == null || !view.minWidth.isBound();
            }
            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
                return (StyleableProperty&lt;Number&gt;)view.minWidthProperty();
            }
        };

        private static final CssMetaData&lt;WebView, Number&gt; MIN_HEIGHT
                = new CssMetaData&lt;WebView, Number&gt;(
                &quot;-fx-min-height&quot;,
                SizeConverter.getInstance(),
                DEFAULT_MIN_HEIGHT) {
            @Override
            public boolean isSettable(WebView view) {
                return view.minHeight == null || !view.minHeight.isBound();
            }
            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
                return (StyleableProperty&lt;Number&gt;)view.minHeightProperty();
            }
        };

        private static final CssMetaData&lt;WebView, Number&gt; MAX_WIDTH
                = new CssMetaData&lt;WebView, Number&gt;(
                &quot;-fx-max-width&quot;,
                SizeConverter.getInstance(),
                DEFAULT_MAX_WIDTH) {
            @Override
            public boolean isSettable(WebView view) {
                return view.maxWidth == null || !view.maxWidth.isBound();
            }
            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
                return (StyleableProperty&lt;Number&gt;)view.maxWidthProperty();
            }
        };

        private static final CssMetaData&lt;WebView, Number&gt; MAX_HEIGHT
                = new CssMetaData&lt;WebView, Number&gt;(
                &quot;-fx-max-height&quot;,
                SizeConverter.getInstance(),
                DEFAULT_MAX_HEIGHT) {
            @Override
            public boolean isSettable(WebView view) {
                return view.maxHeight == null || !view.maxHeight.isBound();
            }
            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
                return (StyleableProperty&lt;Number&gt;)view.maxHeightProperty();
            }
        };

        private static final CssMetaData&lt;WebView, Number&gt; PREF_WIDTH
                = new CssMetaData&lt;WebView, Number&gt;(
                &quot;-fx-pref-width&quot;,
                SizeConverter.getInstance(),
                DEFAULT_PREF_WIDTH) {
            @Override
            public boolean isSettable(WebView view) {
                return view.prefWidth == null || !view.prefWidth.isBound();
            }
            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
                return (StyleableProperty&lt;Number&gt;)view.prefWidthProperty();
            }
        };

        private static final CssMetaData&lt;WebView, Number&gt; PREF_HEIGHT
                = new CssMetaData&lt;WebView, Number&gt;(
                &quot;-fx-pref-height&quot;,
                SizeConverter.getInstance(),
                DEFAULT_PREF_HEIGHT) {
            @Override
            public boolean isSettable(WebView view) {
                return view.prefHeight == null || !view.prefHeight.isBound();
            }
            @Override
            public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
                return (StyleableProperty&lt;Number&gt;)view.prefHeightProperty();
            }
        };

        private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;

        static {
            List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables
                    = new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Parent.getClassCssMetaData());
            styleables.add(CONTEXT_MENU_ENABLED);
            styleables.add(FONT_SMOOTHING_TYPE);
            styleables.add(ZOOM);
            styleables.add(FONT_SCALE);
            styleables.add(MIN_WIDTH);
            styleables.add(PREF_WIDTH);
            styleables.add(MAX_WIDTH);
            styleables.add(MIN_HEIGHT);
            styleables.add(PREF_HEIGHT);
            styleables.add(MAX_HEIGHT);
            STYLEABLES = Collections.unmodifiableList(styleables);
         }
    }

    /**
     * @return The CssMetaData associated with this class, which may include the
     * CssMetaData of its superclasses.
     * @since JavaFX 8.0
     */
    public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
        return StyleableProperties.STYLEABLES;
    }

    /**
     * {@inheritDoc}
     * @since JavaFX 8.0
     */
    @Override
    public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
        return getClassCssMetaData();
    }

    // event handling

    // To handle stage pulse we need to know if currently webview and
    // tree is visible or not
    private boolean isTreeReallyVisible() {
        if (getScene() == null) {
            return false;
        }

        final Window window = getScene().getWindow();

        if (window == null) {
            return false;
        }

        boolean iconified = (window instanceof Stage) ? ((Stage)window).isIconified() : false;

        return NodeHelper.isTreeVisible(this)
               &amp;&amp; window.isShowing()
               &amp;&amp; window.getWidth() &gt; 0
               &amp;&amp; window.getHeight() &gt; 0
               &amp;&amp; !iconified;
    }

    private void handleStagePulse() {
        // The stage pulse occurs before the scene pulse.
        // Here the page content is updated before CSS/Layout/Sync pass
        // is initiated by the scene pulse. The update may
        // change the WebView children and, if so, the children should be
        // processed right away during the scene pulse.

        // The WebView node does not render its pending render queues
        // while it is invisible. Therefore, we should not schedule new
        // render queues while the WebView is invisible to prevent
        // the list of render queues from growing infinitely.
        // Also, if and when the WebView becomes invisible, the currently
        // pending render queues, if any, become obsolete and should be
        // discarded.

        if (page == null) return;

        boolean reallyVisible = isTreeReallyVisible();

        if (reallyVisible) {
            if (page.isDirty()) {
                SceneHelper.setAllowPGAccess(true);
                final NGWebView peer = NodeHelper.getPeer(this);
                peer.update(); // creates new render queues
                if (page.isRepaintPending()) {
                    NodeHelper.markDirty(this, DirtyBits.WEBVIEW_VIEW);
                }
                SceneHelper.setAllowPGAccess(false);
            }
        } else {
            page.dropRenderFrames();
        }
    }

    private void processMouseEvent(MouseEvent ev) {
        if (page == null) {
            return;
        }

        // RT-24511
        EventType&lt;? extends MouseEvent&gt; type = ev.getEventType();
        double x = ev.getX();
        double y = ev.getY();
        double screenX = ev.getScreenX();
        double screenY = ev.getScreenY();
        if (type == MouseEvent.MOUSE_EXITED) {
            type = MouseEvent.MOUSE_MOVED;
            x = Short.MIN_VALUE;
            y = Short.MIN_VALUE;
            Point2D screenPoint = localToScreen(x, y);
            if (screenPoint == null) {
                return;
            }
            screenX = screenPoint.getX();
            screenY = screenPoint.getY();
        }

        final Integer id = idMap.get(type);
        if (id == null) {
            // not supported by webkit
            return;
        }
        WCMouseEvent mouseEvent =
                new WCMouseEvent(id, idMap.get(ev.getButton()),
                    ev.getClickCount(), (int) x, (int) y,
                    (int) screenX, (int) screenY,
                    System.currentTimeMillis(),
                    ev.isShiftDown(), ev.isControlDown(), ev.isAltDown(),
                    ev.isMetaDown(), ev.isPopupTrigger());
        page.dispatchMouseEvent(mouseEvent);
        ev.consume();
    }

    private void processScrollEvent(ScrollEvent ev) {
        if (page == null) {
            return;
        }
        double dx = - ev.getDeltaX() * getFontScale() * getScaleX();
        double dy = - ev.getDeltaY() * getFontScale() * getScaleY();
        WCMouseWheelEvent wheelEvent =
                new WCMouseWheelEvent((int)ev.getX(), (int)ev.getY(),
                    (int)ev.getScreenX(), (int)ev.getScreenY(),
                    System.currentTimeMillis(),
                    ev.isShiftDown(), ev.isControlDown(), ev.isAltDown(),
                    ev.isMetaDown(), (float)dx, (float)dy);
        page.dispatchMouseWheelEvent(wheelEvent);
        ev.consume();
    }

    private void processKeyEvent(KeyEvent ev) {
        if (page == null) return;

        String text = null;
        String keyIdentifier = null;
        int windowsVirtualKeyCode = 0;
        if(ev.getEventType() == KeyEvent.KEY_TYPED) {
            text = ev.getCharacter();
        } else {
            KeyCodeMap.Entry keyCodeEntry = KeyCodeMap.lookup(ev.getCode());
            keyIdentifier = keyCodeEntry.getKeyIdentifier();
            windowsVirtualKeyCode = keyCodeEntry.getWindowsVirtualKeyCode();
        }

        WCKeyEvent keyEvent = new WCKeyEvent(
                idMap.get(ev.getEventType()),
                text,
                keyIdentifier,
                windowsVirtualKeyCode,
                ev.isShiftDown(), ev.isControlDown(),
                ev.isAltDown(), ev.isMetaDown(), System.currentTimeMillis());
        if (page.dispatchKeyEvent(keyEvent)) {
            ev.consume();
        }
    }

    private InputMethodClientImpl getInputMethodClient() {
         if (imClient == null) {
             synchronized (this) {
                 if (imClient == null) {
                     imClient = new InputMethodClientImpl(this, page);
                 }
             }
         }
         return imClient;
    }

    private void processInputMethodEvent(InputMethodEvent ie) {
        if (page == null) {
            return;
        }

        if (!getInputMethodClient().getInputMethodState()) {
            ie.consume();
            return;
        }

        WCInputMethodEvent imEvent = InputMethodClientImpl.convertToWCInputMethodEvent(ie);
        if (page.dispatchInputMethodEvent(imEvent)) {
            ie.consume();
            return;
        }
    }

    private static final int WK_DND_ACTION_NONE = 0x0;
    private static final int WK_DND_ACTION_COPY = 0x1;
    private static final int WK_DND_ACTION_MOVE = 0x2;
    private static final int WK_DND_ACTION_LINK = 0x40000000;

    private static int getWKDndEventType(EventType  et) {
        int commandId = 0;
        if (et == DragEvent.DRAG_ENTERED)
            commandId = WebPage.DND_DST_ENTER;
        else if (et == DragEvent.DRAG_EXITED)
            commandId = WebPage.DND_DST_EXIT;
        else if (et == DragEvent.DRAG_OVER)
            commandId = WebPage.DND_DST_OVER;
        else if (et == DragEvent.DRAG_DROPPED)
            commandId = WebPage.DND_DST_DROP;
        return commandId;
    }

    private static int getWKDndAction(TransferMode... tms) {
        int dndActionId = WK_DND_ACTION_NONE;
        for (TransferMode tm : tms) {
           if (tm == TransferMode.COPY)
               dndActionId |=  WK_DND_ACTION_COPY;
           else if (tm == TransferMode.MOVE)
               dndActionId |=  WK_DND_ACTION_MOVE;
           else if (tm == TransferMode.LINK)
               dndActionId |=  WK_DND_ACTION_LINK;
        }
        return dndActionId;
    }

    private static TransferMode[] getFXDndAction(int wkDndAction) {
        LinkedList&lt;TransferMode&gt; tms = new LinkedList&lt;TransferMode&gt;();
        if ((wkDndAction &amp; WK_DND_ACTION_COPY) != 0)
            tms.add(TransferMode.COPY);
        if ((wkDndAction &amp; WK_DND_ACTION_MOVE) != 0)
            tms.add(TransferMode.MOVE);
        if ((wkDndAction &amp; WK_DND_ACTION_LINK) != 0)
            tms.add(TransferMode.LINK);
        return tms.toArray(new TransferMode[0]);
    }

    private void registerEventHandlers() {
        addEventHandler(KeyEvent.ANY,
                event -&gt; {
                    processKeyEvent(event);
                });
        addEventHandler(MouseEvent.ANY,
                event -&gt; {
                    processMouseEvent(event);
                    if (event.isDragDetect() &amp;&amp; !page.isDragConfirmed()) {
                        //postpone drag recognition:
                        //Webkit cannot resolve here is it a drag
                        //or selection.
                        event.setDragDetect(false);
                    }
                });
        addEventHandler(ScrollEvent.SCROLL,
                event -&gt; {
                    processScrollEvent(event);
                });
        setOnInputMethodTextChanged(
                event -&gt; {
                    processInputMethodEvent(event);
                });
<A NAME="32"></A>
        //Drop target implementation:
        EventHandler&lt;DragEvent&gt; destHandler = event -&gt; {
            try <FONT color="#82cafa"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#32',2,'match49-top.html#32',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
                Dragboard db = event.getDragboard();
                LinkedList&lt;String&gt; mimes = new LinkedList&lt;String&gt;();
                LinkedList&lt;String&gt; values = new LinkedList&lt;String&gt;();
                for (DataFormat df : db.getContentTypes()) {</B></FONT>
                    //TODO: extend to non-string serialized values.
                    //Please, look at the native code.
                    Object content = db.getContent(df);
                    if (content != null) {
                        for (String mime : df.getIdentifiers()) {
                            mimes.add(mime);
                            values.add(content.toString());
                        }
                    }
                }
                if (!mimes.isEmpty()) {
                    int wkDndEventType = getWKDndEventType(event.getEventType());
                    int wkDndAction = page.dispatchDragOperation(
                        wkDndEventType,
                        mimes.toArray(new String[0]), values.toArray(new String[0]),
                        (int)event.getX(), (int)event.getY(),
                        (int)event.getScreenX(), (int)event.getScreenY(),
                        getWKDndAction(db.getTransferModes().toArray(new TransferMode[0])));

                    //we cannot accept nothing on drop (we skip FX exception)
                    if (!(wkDndEventType == WebPage.DND_DST_DROP &amp;&amp; wkDndAction == WK_DND_ACTION_NONE)) {
                        event.acceptTransferModes(getFXDndAction(wkDndAction));
                    }
                    event.consume();
                }
            } catch (SecurityException ex) {
                // Just ignore the exception
                //ex.printStackTrace();
            }
        };
        setOnDragEntered(destHandler);
        setOnDragExited(destHandler);
        setOnDragOver(destHandler);
        setOnDragDropped(destHandler);

        //Drag source implementation:
        setOnDragDetected(event -&gt; {
               if (page.isDragConfirmed()) {
                   page.confirmStartDrag();
                   event.consume();
               }
           });
        setOnDragDone(event -&gt; {
                page.dispatchDragOperation(
                    WebPage.DND_SRC_DROP,
                    null, null,
                    (int)event.getX(), (int)event.getY(),
                    (int)event.getScreenX(), (int)event.getScreenY(),
                    getWKDndAction(event.getAcceptedTransferMode()));
                event.consume();
            });

        setInputMethodRequests(getInputMethodClient());
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doPickNodeLocal(PickRay pickRay, PickResultChooser result) {
        NodeHelper.intersects(this, pickRay, result);
    }

    @Override protected ObservableList&lt;Node&gt; getChildren() {
        return super.getChildren();
    }

    // Node stuff

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private NGNode doCreatePeer() {
        return new NGWebView();
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {
        bounds.deriveWithNewBounds(0, 0, 0, (float) getWidth(), (float)getHeight(), 0);
        tx.transform(bounds, bounds);
        return bounds;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doTransformsChanged() {
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private boolean doComputeContains(double localX, double localY) {
        // Note: Local bounds contain test is already done by the caller. (Node.contains()).
        return true;
    }

    /*
     * Note: This method MUST only be called via its accessor method.
     */
    private void doUpdatePeer() {
        final NGWebView peer = NodeHelper.getPeer(this);

        if (NodeHelper.isDirty(this, DirtyBits.NODE_CONTENTS)) {
            peer.setPage(page);
        }
        if (NodeHelper.isDirty(this, DirtyBits.NODE_GEOMETRY)) {
            peer.resize((float)getWidth(), (float)getHeight());
        }
        if (NodeHelper.isDirty(this, DirtyBits.WEBVIEW_VIEW)) {
            peer.requestRender();
        }
    }

    static {
        WebViewHelper.setWebViewAccessor(new WebViewHelper.WebViewAccessor() {
            @Override
            public NGNode doCreatePeer(Node node) {
                return ((WebView) node).doCreatePeer();
            }

            @Override
            public void doUpdatePeer(Node node) {
                ((WebView) node).doUpdatePeer();
            }

            @Override
            public void doTransformsChanged(Node node) {
                ((WebView) node).doTransformsChanged();
            }

            @Override
            public BaseBounds doComputeGeomBounds(Node node,
                    BaseBounds bounds, BaseTransform tx) {
                return ((WebView) node).doComputeGeomBounds(bounds, tx);
            }

            @Override
            public boolean doComputeContains(Node node, double localX, double localY) {
                return ((WebView) node).doComputeContains(localX, localY);
            }

            @Override
            public void doPickNodeLocal(Node node, PickRay localPickRay,
                    PickResultChooser result) {
                ((WebView) node).doPickNodeLocal(localPickRay, result);
            }
        });

        idMap.put(MouseButton.NONE, WCMouseEvent.NOBUTTON);
        idMap.put(MouseButton.PRIMARY, WCMouseEvent.BUTTON1);
        idMap.put(MouseButton.MIDDLE, WCMouseEvent.BUTTON2);
        idMap.put(MouseButton.SECONDARY, WCMouseEvent.BUTTON3);

        idMap.put(MouseEvent.MOUSE_PRESSED, WCMouseEvent.MOUSE_PRESSED);
        idMap.put(MouseEvent.MOUSE_RELEASED, WCMouseEvent.MOUSE_RELEASED);
        idMap.put(MouseEvent.MOUSE_MOVED, WCMouseEvent.MOUSE_MOVED);
        idMap.put(MouseEvent.MOUSE_DRAGGED, WCMouseEvent.MOUSE_DRAGGED);

        idMap.put(KeyEvent.KEY_PRESSED, WCKeyEvent.KEY_PRESSED);
        idMap.put(KeyEvent.KEY_RELEASED, WCKeyEvent.KEY_RELEASED);
        idMap.put(KeyEvent.KEY_TYPED, WCKeyEvent.KEY_TYPED);
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/View/GameView.java</CENTER></H3><HR>
<PRE>
/*
  RMIT University Vietnam
  Course: INTE2512 Object-Oriented Programming
  Semester: 2019C
  Assessment: Assignment 2
  Author: Hoang Quoc Dai
  ID: s3426353
  Created  date: 15/12/2019
  Last modified: 16/12/2019
  Acknowledgement: If you use any resources, acknowledge here. Failure to do so will be considered as plagiarism.
*/
package sample.View;

import javafx.geometry.Pos;
import javafx.scene.image.Image;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontPosture;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import java.util.ArrayList;
import java.util.Random;
import java.util.Timer;
import java.util.TimerTask;

public class GameView extends VBox{
    int[] cardIndices = { 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10};
    ArrayList &lt;Card&gt; cards = new ArrayList&lt;&gt;();
    private GridPane matrixCards;
    private TimeBar timeBar;
    private Image image;
    private Text timeDisplay;
    private Timer timer;
    private int min = 1;
    private int sec = 59;
    private int milliSec = 99;
    private int totalFront;

    public GameView() {
        setSpacing(20);
        setAlignment(Pos.CENTER_RIGHT);

        matrixCards = new GridPane();
        String prefix = &quot;Images/&quot;;
        String postfix = &quot;.jpg&quot;;
        shuffleCards();
        for (int col = 1; col &lt;= 5; col++) {
            for (int row = 1; row &lt;= 4; row++) {
                String cardID = Integer.toString(cardIndices[row - 1 + 4*(col-1)]);
                Card temp = new Card(prefix + cardID + postfix);
                matrixCards.add(temp, col, row);
                cards.add(temp);
            }
        }
        setTimeBar(new TimeBar());
<A NAME="6"></A>        getChildren().addAll(matrixCards, getTimeBar());

        //Set timeDisplay
        <FONT color="#50ebec"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#6',2,'match49-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>setTimeDisplay(new Text(&quot;Time: 00:00:00&quot;));
        getTimeDisplay().setFill(Color.YELLOW);
        getTimeDisplay().setFont(Font.font(&quot;Courier&quot;, FontWeight.BOLD, FontPosture.REGULAR, 15));
        getChildren().add(getTimeDisplay());
        timerProcess(); //Set timer
    }

    //For Card
    public void shuffleCards() {
        Random rand = new</B></FONT> Random();
        for (int i = 0; i &lt; cardIndices.length; i++) {
            int randomIndexToSwap = rand.nextInt(cardIndices.length);
            int temp = cardIndices[randomIndexToSwap];
            cardIndices[randomIndexToSwap] = cardIndices[i];
            cardIndices[i] = temp;
        }
    }
    //For timer
    private void timerProcess() {

        setTotalFront(0);
        int delay = 40;
        int period = 40;
        setTimer(new Timer());
        getTimer().scheduleAtFixedRate(new TimerTask() {
            public void run() {
                getTimeDisplay().setText(&quot;Time: &quot;+ showCountDown());
            }
        }, delay, period);
    }

    //For timer
    private String showCountDown() {
        setMilliSec(getMilliSec() -4);
        if (getMilliSec() &lt; 0){
            setMilliSec(99);
            setSec(getSec() - 1);
        }
        if (getSec() == 0){
            setSec(59);
            setMin(getMin() - 1);
        }
        if (getMin() &lt; 0) {
            getTimer().cancel();
            return &quot;00:00:00&quot;;
        };
        if (getTotalFront() == 20){
            getTimer().cancel();
        }
        return &quot;0&quot;+Integer.toString(getMin())+&quot;:&quot;+Integer.toString(getSec()/10)+Integer.toString(getSec()%10)+&quot;:&quot;+Integer.toString(getMilliSec());
    }

    private TimeBar getTimeBar() {
        return timeBar;
    }

    private void setTimeBar(TimeBar timeBar) {
        this.timeBar = timeBar;
    }

    private Image getImage() {
        return image;
    }

    private void setImage(Image image) {
        this.image = image;
    }

    public ArrayList&lt;Card&gt; getCards() {
        return cards;
    }

    private Text getTimeDisplay() {
        return timeDisplay;
    }

    private void setTimeDisplay(Text timeDisplay) {
        this.timeDisplay = timeDisplay;
    }

    private Timer getTimer() {
        return timer;
    }

    private void setTimer(Timer timer) {
        this.timer = timer;
    }

    private int getMin() {
        return min;
    }

    private void setMin(int min) {
        this.min = min;
    }

    private int getSec() {
        return sec;
    }

    private void setSec(int sec) {
        this.sec = sec;
    }

    private int getMilliSec() {
        return milliSec;
    }

    private void setMilliSec(int milliSec) {
        this.milliSec = milliSec;
    }

    private int getTotalFront() {
        return totalFront;
    }

    private void setTotalFront(int totalFront) {
        this.totalFront = totalFront;
    }
}
</PRE>
<HR>
<H3><CENTER>OOP_Assignment2-3/src/sample/View/StartView.java</CENTER></H3><HR>
<PRE>
/*
  RMIT University Vietnam
  Course: INTE2512 Object-Oriented Programming
  Semester: 2019C
  Assessment: Assignment 2
  Author: Hoang Quoc Dai
  ID: s3426353
  Created  date: 15/12/2019
  Last modified: 16/12/2019
  Acknowledgement: If you use any resources, acknowledge here. Failure to do so will be considered as plagiarism.
*/
package sample.View;

import javafx.geometry.Pos;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;


public class StartView extends VBox {
    private Button btLevel1;
    private Button btLevel2;
    private Button btLevel3;
    private Button btSoundPlay;
    private Button btSoundPause;
    private Label message;
    private Label message1;

    public StartView() {
        // Create a vBox
        HBox hBox = new HBox();
<A NAME="34"></A>        hBox.setSpacing(10);
        hBox.setAlignment(Pos.CENTER);
        // Set name for buttons and message label
        <FONT color="#827d6b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49-0.html#34',2,'match49-top.html#34',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>setBtLevel1(new Button(&quot;Level 1&quot;));
        setBtLevel2(new Button(&quot;Level 2&quot;));
        setBtLevel3(new Button(&quot;Level 3&quot;));
        setBtSoundPlay(new Button(&quot;Music On&quot;));
        setBtSoundPause(new Button(&quot;Music Pause&quot;));
        setMessage(new Label(&quot;Hello, QUOC DAI ! &quot;));
        setMessage1(new Label(&quot;PLEASE CHOOSE THE LEVEL TO START !&quot;));
        //Set Front, Size, Color for Message
        getMessage().setFont</B></FONT>(new Font(&quot;Arial&quot;, 40));
        getMessage().setTextFill(Color.WHITE);
        //Set Front, Size, Color for Message1
        getMessage1().setFont(new Font(&quot;Arial&quot;, 40));
        getMessage1().setTextFill(Color.WHITE);
        // add 4 buttons to hBox
        hBox.getChildren().addAll(getBtLevel1(), getBtLevel2(), getBtLevel3(), getBtSoundPlay(), getBtSoundPause());

        setAlignment(Pos.CENTER);
        setSpacing(10);

        // add hBox and label to vBox
        getChildren().addAll(getMessage(), getMessage1(),hBox);
    }

    public Button getBtLevel1() {
        return btLevel1;
    }

    public Button getBtLevel2() {
        return btLevel2;
    }

    public Button getBtLevel3() {
        return btLevel3;
    }

    private void setBtLevel1(Button btLevel1) {
        this.btLevel1 = btLevel1;
    }

    private void setBtLevel2(Button btLevel2) {
        this.btLevel2 = btLevel2;
    }

    private void setBtLevel3(Button btLevel3) {
        this.btLevel3 = btLevel3;
    }

    private Label getMessage() {
        return message;
    }

    private void setMessage(Label message) {
        this.message = message;
    }

    private Label getMessage1() {
        return message1;
    }

    private void setMessage1(Label message1) {
        this.message1 = message1;
    }

    public Button getBtSoundPlay() {
        return btSoundPlay;
    }

    private void setBtSoundPlay(Button btSoundPlay) {
        this.btSoundPlay = btSoundPlay;
    }

    public Button getBtSoundPause() {
        return btSoundPause;
    }

    private void setBtSoundPause(Button btSoundPause) {
        this.btSoundPause = btSoundPause;
    }
}
</PRE>

</BODY>
</HTML>
